"use strict";
(function() {

Error.stackTraceLimit = Infinity;

var $global, $module;
if (typeof window !== "undefined") { /* web page */
  $global = window;
} else if (typeof self !== "undefined") { /* web worker */
  $global = self;
} else if (typeof global !== "undefined") { /* Node.js */
  $global = global;
  $global.require = require;
} else { /* others (e.g. Nashorn) */
  $global = this;
}

if ($global === undefined || $global.Array === undefined) {
  throw new Error("no global object found");
}
if (typeof module !== "undefined") {
  $module = module;
}

var $packages = {}, $idCounter = 0;
var $keys = function(m) { return m ? Object.keys(m) : []; };
var $flushConsole = function() {};
var $throwRuntimeError; /* set by package "runtime" */
var $throwNilPointerError = function() { $throwRuntimeError("invalid memory address or nil pointer dereference"); };
var $call = function(fn, rcvr, args) { return fn.apply(rcvr, args); };
var $makeFunc = function(fn) { return function() { return $externalize(fn(this, new ($sliceType($jsObjectPtr))($global.Array.prototype.slice.call(arguments, []))), $emptyInterface); }; };
var $unused = function(v) {};

var $mapArray = function(array, f) {
  var newArray = new array.constructor(array.length);
  for (var i = 0; i < array.length; i++) {
    newArray[i] = f(array[i]);
  }
  return newArray;
};

var $methodVal = function(recv, name) {
  var vals = recv.$methodVals || {};
  recv.$methodVals = vals; /* noop for primitives */
  var f = vals[name];
  if (f !== undefined) {
    return f;
  }
  var method = recv[name];
  f = function() {
    $stackDepthOffset--;
    try {
      return method.apply(recv, arguments);
    } finally {
      $stackDepthOffset++;
    }
  };
  vals[name] = f;
  return f;
};

var $methodExpr = function(typ, name) {
  var method = typ.prototype[name];
  if (method.$expr === undefined) {
    method.$expr = function() {
      $stackDepthOffset--;
      try {
        if (typ.wrapped) {
          arguments[0] = new typ(arguments[0]);
        }
        return Function.call.apply(method, arguments);
      } finally {
        $stackDepthOffset++;
      }
    };
  }
  return method.$expr;
};

var $ifaceMethodExprs = {};
var $ifaceMethodExpr = function(name) {
  var expr = $ifaceMethodExprs["$" + name];
  if (expr === undefined) {
    expr = $ifaceMethodExprs["$" + name] = function() {
      $stackDepthOffset--;
      try {
        return Function.call.apply(arguments[0][name], arguments);
      } finally {
        $stackDepthOffset++;
      }
    };
  }
  return expr;
};

var $subslice = function(slice, low, high, max) {
  if (high === undefined) {
    high = slice.$length;
  }
  if (max === undefined) {
    max = slice.$capacity;
  }
  if (low < 0 || high < low || max < high || high > slice.$capacity || max > slice.$capacity) {
    $throwRuntimeError("slice bounds out of range");
  }
  if (slice === slice.constructor.nil) {
    return slice;
  }
  var s = new slice.constructor(slice.$array);
  s.$offset = slice.$offset + low;
  s.$length = high - low;
  s.$capacity = max - low;
  return s;
};

var $substring = function(str, low, high) {
  if (low < 0 || high < low || high > str.length) {
    $throwRuntimeError("slice bounds out of range");
  }
  return str.substring(low, high);
};

var $sliceToArray = function(slice) {
  if (slice.$array.constructor !== Array) {
    return slice.$array.subarray(slice.$offset, slice.$offset + slice.$length);
  }
  return slice.$array.slice(slice.$offset, slice.$offset + slice.$length);
};

var $decodeRune = function(str, pos) {
  var c0 = str.charCodeAt(pos);

  if (c0 < 0x80) {
    return [c0, 1];
  }

  if (c0 !== c0 || c0 < 0xC0) {
    return [0xFFFD, 1];
  }

  var c1 = str.charCodeAt(pos + 1);
  if (c1 !== c1 || c1 < 0x80 || 0xC0 <= c1) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xE0) {
    var r = (c0 & 0x1F) << 6 | (c1 & 0x3F);
    if (r <= 0x7F) {
      return [0xFFFD, 1];
    }
    return [r, 2];
  }

  var c2 = str.charCodeAt(pos + 2);
  if (c2 !== c2 || c2 < 0x80 || 0xC0 <= c2) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xF0) {
    var r = (c0 & 0x0F) << 12 | (c1 & 0x3F) << 6 | (c2 & 0x3F);
    if (r <= 0x7FF) {
      return [0xFFFD, 1];
    }
    if (0xD800 <= r && r <= 0xDFFF) {
      return [0xFFFD, 1];
    }
    return [r, 3];
  }

  var c3 = str.charCodeAt(pos + 3);
  if (c3 !== c3 || c3 < 0x80 || 0xC0 <= c3) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xF8) {
    var r = (c0 & 0x07) << 18 | (c1 & 0x3F) << 12 | (c2 & 0x3F) << 6 | (c3 & 0x3F);
    if (r <= 0xFFFF || 0x10FFFF < r) {
      return [0xFFFD, 1];
    }
    return [r, 4];
  }

  return [0xFFFD, 1];
};

var $encodeRune = function(r) {
  if (r < 0 || r > 0x10FFFF || (0xD800 <= r && r <= 0xDFFF)) {
    r = 0xFFFD;
  }
  if (r <= 0x7F) {
    return String.fromCharCode(r);
  }
  if (r <= 0x7FF) {
    return String.fromCharCode(0xC0 | r >> 6, 0x80 | (r & 0x3F));
  }
  if (r <= 0xFFFF) {
    return String.fromCharCode(0xE0 | r >> 12, 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));
  }
  return String.fromCharCode(0xF0 | r >> 18, 0x80 | (r >> 12 & 0x3F), 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));
};

var $stringToBytes = function(str) {
  var array = new Uint8Array(str.length);
  for (var i = 0; i < str.length; i++) {
    array[i] = str.charCodeAt(i);
  }
  return array;
};

var $bytesToString = function(slice) {
  if (slice.$length === 0) {
    return "";
  }
  var str = "";
  for (var i = 0; i < slice.$length; i += 10000) {
    str += String.fromCharCode.apply(undefined, slice.$array.subarray(slice.$offset + i, slice.$offset + Math.min(slice.$length, i + 10000)));
  }
  return str;
};

var $stringToRunes = function(str) {
  var array = new Int32Array(str.length);
  var rune, j = 0;
  for (var i = 0; i < str.length; i += rune[1], j++) {
    rune = $decodeRune(str, i);
    array[j] = rune[0];
  }
  return array.subarray(0, j);
};

var $runesToString = function(slice) {
  if (slice.$length === 0) {
    return "";
  }
  var str = "";
  for (var i = 0; i < slice.$length; i++) {
    str += $encodeRune(slice.$array[slice.$offset + i]);
  }
  return str;
};

var $copyString = function(dst, src) {
  var n = Math.min(src.length, dst.$length);
  for (var i = 0; i < n; i++) {
    dst.$array[dst.$offset + i] = src.charCodeAt(i);
  }
  return n;
};

var $copySlice = function(dst, src) {
  var n = Math.min(src.$length, dst.$length);
  $copyArray(dst.$array, src.$array, dst.$offset, src.$offset, n, dst.constructor.elem);
  return n;
};

var $copyArray = function(dst, src, dstOffset, srcOffset, n, elem) {
  if (n === 0 || (dst === src && dstOffset === srcOffset)) {
    return;
  }

  if (src.subarray) {
    dst.set(src.subarray(srcOffset, srcOffset + n), dstOffset);
    return;
  }

  switch (elem.kind) {
  case $kindArray:
  case $kindStruct:
    if (dst === src && dstOffset > srcOffset) {
      for (var i = n - 1; i >= 0; i--) {
        elem.copy(dst[dstOffset + i], src[srcOffset + i]);
      }
      return;
    }
    for (var i = 0; i < n; i++) {
      elem.copy(dst[dstOffset + i], src[srcOffset + i]);
    }
    return;
  }

  if (dst === src && dstOffset > srcOffset) {
    for (var i = n - 1; i >= 0; i--) {
      dst[dstOffset + i] = src[srcOffset + i];
    }
    return;
  }
  for (var i = 0; i < n; i++) {
    dst[dstOffset + i] = src[srcOffset + i];
  }
};

var $clone = function(src, type) {
  var clone = type.zero();
  type.copy(clone, src);
  return clone;
};

var $pointerOfStructConversion = function(obj, type) {
  if(obj.$proxies === undefined) {
    obj.$proxies = {};
    obj.$proxies[obj.constructor.string] = obj;
  }
  var proxy = obj.$proxies[type.string];
  if (proxy === undefined) {
    var properties = {};
    for (var i = 0; i < type.elem.fields.length; i++) {
      (function(fieldProp) {
        properties[fieldProp] = {
          get: function() { return obj[fieldProp]; },
          set: function(value) { obj[fieldProp] = value; }
        };
      })(type.elem.fields[i].prop);
    }
    proxy = Object.create(type.prototype, properties);
    proxy.$val = proxy;
    obj.$proxies[type.string] = proxy;
    proxy.$proxies = obj.$proxies;
  }
  return proxy;
};

var $append = function(slice) {
  return $internalAppend(slice, arguments, 1, arguments.length - 1);
};

var $appendSlice = function(slice, toAppend) {
  if (toAppend.constructor === String) {
    var bytes = $stringToBytes(toAppend);
    return $internalAppend(slice, bytes, 0, bytes.length);
  }
  return $internalAppend(slice, toAppend.$array, toAppend.$offset, toAppend.$length);
};

var $internalAppend = function(slice, array, offset, length) {
  if (length === 0) {
    return slice;
  }

  var newArray = slice.$array;
  var newOffset = slice.$offset;
  var newLength = slice.$length + length;
  var newCapacity = slice.$capacity;

  if (newLength > newCapacity) {
    newOffset = 0;
    newCapacity = Math.max(newLength, slice.$capacity < 1024 ? slice.$capacity * 2 : Math.floor(slice.$capacity * 5 / 4));

    if (slice.$array.constructor === Array) {
      newArray = slice.$array.slice(slice.$offset, slice.$offset + slice.$length);
      newArray.length = newCapacity;
      var zero = slice.constructor.elem.zero;
      for (var i = slice.$length; i < newCapacity; i++) {
        newArray[i] = zero();
      }
    } else {
      newArray = new slice.$array.constructor(newCapacity);
      newArray.set(slice.$array.subarray(slice.$offset, slice.$offset + slice.$length));
    }
  }

  $copyArray(newArray, array, newOffset + slice.$length, offset, length, slice.constructor.elem);

  var newSlice = new slice.constructor(newArray);
  newSlice.$offset = newOffset;
  newSlice.$length = newLength;
  newSlice.$capacity = newCapacity;
  return newSlice;
};

var $equal = function(a, b, type) {
  if (type === $jsObjectPtr) {
    return a === b;
  }
  switch (type.kind) {
  case $kindComplex64:
  case $kindComplex128:
    return a.$real === b.$real && a.$imag === b.$imag;
  case $kindInt64:
  case $kindUint64:
    return a.$high === b.$high && a.$low === b.$low;
  case $kindArray:
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!$equal(a[i], b[i], type.elem)) {
        return false;
      }
    }
    return true;
  case $kindStruct:
    for (var i = 0; i < type.fields.length; i++) {
      var f = type.fields[i];
      if (!$equal(a[f.prop], b[f.prop], f.typ)) {
        return false;
      }
    }
    return true;
  case $kindInterface:
    return $interfaceIsEqual(a, b);
  default:
    return a === b;
  }
};

var $interfaceIsEqual = function(a, b) {
  if (a === $ifaceNil || b === $ifaceNil) {
    return a === b;
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a.constructor === $jsObjectPtr) {
    return a.object === b.object;
  }
  if (!a.constructor.comparable) {
    $throwRuntimeError("comparing uncomparable type " + a.constructor.string);
  }
  return $equal(a.$val, b.$val, a.constructor);
};

var $min = Math.min;
var $mod = function(x, y) { return x % y; };
var $parseInt = parseInt;
var $parseFloat = function(f) {
  if (f !== undefined && f !== null && f.constructor === Number) {
    return f;
  }
  return parseFloat(f);
};

var $froundBuf = new Float32Array(1);
var $fround = Math.fround || function(f) {
  $froundBuf[0] = f;
  return $froundBuf[0];
};

var $imul = Math.imul || function(a, b) {
  var ah = (a >>> 16) & 0xffff;
  var al = a & 0xffff;
  var bh = (b >>> 16) & 0xffff;
  var bl = b & 0xffff;
  return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) >> 0);
};

var $floatKey = function(f) {
  if (f !== f) {
    $idCounter++;
    return "NaN$" + $idCounter;
  }
  return String(f);
};

var $flatten64 = function(x) {
  return x.$high * 4294967296 + x.$low;
};

var $shiftLeft64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high << y | x.$low >>> (32 - y), (x.$low << y) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(x.$low << (y - 32), 0);
  }
  return new x.constructor(0, 0);
};

var $shiftRightInt64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high >> y, (x.$low >>> y | x.$high << (32 - y)) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(x.$high >> 31, (x.$high >> (y - 32)) >>> 0);
  }
  if (x.$high < 0) {
    return new x.constructor(-1, 4294967295);
  }
  return new x.constructor(0, 0);
};

var $shiftRightUint64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high >>> y, (x.$low >>> y | x.$high << (32 - y)) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(0, x.$high >>> (y - 32));
  }
  return new x.constructor(0, 0);
};

var $mul64 = function(x, y) {
  var high = 0, low = 0;
  if ((y.$low & 1) !== 0) {
    high = x.$high;
    low = x.$low;
  }
  for (var i = 1; i < 32; i++) {
    if ((y.$low & 1<<i) !== 0) {
      high += x.$high << i | x.$low >>> (32 - i);
      low += (x.$low << i) >>> 0;
    }
  }
  for (var i = 0; i < 32; i++) {
    if ((y.$high & 1<<i) !== 0) {
      high += x.$low << i;
    }
  }
  return new x.constructor(high, low);
};

var $div64 = function(x, y, returnRemainder) {
  if (y.$high === 0 && y.$low === 0) {
    $throwRuntimeError("integer divide by zero");
  }

  var s = 1;
  var rs = 1;

  var xHigh = x.$high;
  var xLow = x.$low;
  if (xHigh < 0) {
    s = -1;
    rs = -1;
    xHigh = -xHigh;
    if (xLow !== 0) {
      xHigh--;
      xLow = 4294967296 - xLow;
    }
  }

  var yHigh = y.$high;
  var yLow = y.$low;
  if (y.$high < 0) {
    s *= -1;
    yHigh = -yHigh;
    if (yLow !== 0) {
      yHigh--;
      yLow = 4294967296 - yLow;
    }
  }

  var high = 0, low = 0, n = 0;
  while (yHigh < 2147483648 && ((xHigh > yHigh) || (xHigh === yHigh && xLow > yLow))) {
    yHigh = (yHigh << 1 | yLow >>> 31) >>> 0;
    yLow = (yLow << 1) >>> 0;
    n++;
  }
  for (var i = 0; i <= n; i++) {
    high = high << 1 | low >>> 31;
    low = (low << 1) >>> 0;
    if ((xHigh > yHigh) || (xHigh === yHigh && xLow >= yLow)) {
      xHigh = xHigh - yHigh;
      xLow = xLow - yLow;
      if (xLow < 0) {
        xHigh--;
        xLow += 4294967296;
      }
      low++;
      if (low === 4294967296) {
        high++;
        low = 0;
      }
    }
    yLow = (yLow >>> 1 | yHigh << (32 - 1)) >>> 0;
    yHigh = yHigh >>> 1;
  }

  if (returnRemainder) {
    return new x.constructor(xHigh * rs, xLow * rs);
  }
  return new x.constructor(high * s, low * s);
};

var $divComplex = function(n, d) {
  var ninf = n.$real === Infinity || n.$real === -Infinity || n.$imag === Infinity || n.$imag === -Infinity;
  var dinf = d.$real === Infinity || d.$real === -Infinity || d.$imag === Infinity || d.$imag === -Infinity;
  var nnan = !ninf && (n.$real !== n.$real || n.$imag !== n.$imag);
  var dnan = !dinf && (d.$real !== d.$real || d.$imag !== d.$imag);
  if(nnan || dnan) {
    return new n.constructor(NaN, NaN);
  }
  if (ninf && !dinf) {
    return new n.constructor(Infinity, Infinity);
  }
  if (!ninf && dinf) {
    return new n.constructor(0, 0);
  }
  if (d.$real === 0 && d.$imag === 0) {
    if (n.$real === 0 && n.$imag === 0) {
      return new n.constructor(NaN, NaN);
    }
    return new n.constructor(Infinity, Infinity);
  }
  var a = Math.abs(d.$real);
  var b = Math.abs(d.$imag);
  if (a <= b) {
    var ratio = d.$real / d.$imag;
    var denom = d.$real * ratio + d.$imag;
    return new n.constructor((n.$real * ratio + n.$imag) / denom, (n.$imag * ratio - n.$real) / denom);
  }
  var ratio = d.$imag / d.$real;
  var denom = d.$imag * ratio + d.$real;
  return new n.constructor((n.$imag * ratio + n.$real) / denom, (n.$imag - n.$real * ratio) / denom);
};

var $kindBool = 1;
var $kindInt = 2;
var $kindInt8 = 3;
var $kindInt16 = 4;
var $kindInt32 = 5;
var $kindInt64 = 6;
var $kindUint = 7;
var $kindUint8 = 8;
var $kindUint16 = 9;
var $kindUint32 = 10;
var $kindUint64 = 11;
var $kindUintptr = 12;
var $kindFloat32 = 13;
var $kindFloat64 = 14;
var $kindComplex64 = 15;
var $kindComplex128 = 16;
var $kindArray = 17;
var $kindChan = 18;
var $kindFunc = 19;
var $kindInterface = 20;
var $kindMap = 21;
var $kindPtr = 22;
var $kindSlice = 23;
var $kindString = 24;
var $kindStruct = 25;
var $kindUnsafePointer = 26;

var $methodSynthesizers = [];
var $addMethodSynthesizer = function(f) {
  if ($methodSynthesizers === null) {
    f();
    return;
  }
  $methodSynthesizers.push(f);
};
var $synthesizeMethods = function() {
  $methodSynthesizers.forEach(function(f) { f(); });
  $methodSynthesizers = null;
};

var $ifaceKeyFor = function(x) {
  if (x === $ifaceNil) {
    return 'nil';
  }
  var c = x.constructor;
  return c.string + '$' + c.keyFor(x.$val);
};

var $identity = function(x) { return x; };

var $typeIDCounter = 0;

var $idKey = function(x) {
  if (x.$id === undefined) {
    $idCounter++;
    x.$id = $idCounter;
  }
  return String(x.$id);
};

var $newType = function(size, kind, string, named, pkg, exported, constructor) {
  var typ;
  switch(kind) {
  case $kindBool:
  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8:
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindUnsafePointer:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = $identity;
    break;

  case $kindString:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = function(x) { return "$" + x; };
    break;

  case $kindFloat32:
  case $kindFloat64:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = function(x) { return $floatKey(x); };
    break;

  case $kindInt64:
    typ = function(high, low) {
      this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >> 0;
      this.$low = low >>> 0;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$high + "$" + x.$low; };
    break;

  case $kindUint64:
    typ = function(high, low) {
      this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >>> 0;
      this.$low = low >>> 0;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$high + "$" + x.$low; };
    break;

  case $kindComplex64:
    typ = function(real, imag) {
      this.$real = $fround(real);
      this.$imag = $fround(imag);
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$real + "$" + x.$imag; };
    break;

  case $kindComplex128:
    typ = function(real, imag) {
      this.$real = real;
      this.$imag = imag;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$real + "$" + x.$imag; };
    break;

  case $kindArray:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.ptr = $newType(4, $kindPtr, "*" + string, false, "", false, function(array) {
      this.$get = function() { return array; };
      this.$set = function(v) { typ.copy(this, v); };
      this.$val = array;
    });
    typ.init = function(elem, len) {
      typ.elem = elem;
      typ.len = len;
      typ.comparable = elem.comparable;
      typ.keyFor = function(x) {
        return Array.prototype.join.call($mapArray(x, function(e) {
          return String(elem.keyFor(e)).replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
        }), "$");
      };
      typ.copy = function(dst, src) {
        $copyArray(dst, src, 0, 0, src.length, elem);
      };
      typ.ptr.init(typ);
      Object.defineProperty(typ.ptr.nil, "nilCheck", { get: $throwNilPointerError });
    };
    break;

  case $kindChan:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = $idKey;
    typ.init = function(elem, sendOnly, recvOnly) {
      typ.elem = elem;
      typ.sendOnly = sendOnly;
      typ.recvOnly = recvOnly;
    };
    break;

  case $kindFunc:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.init = function(params, results, variadic) {
      typ.params = params;
      typ.results = results;
      typ.variadic = variadic;
      typ.comparable = false;
    };
    break;

  case $kindInterface:
    typ = { implementedBy: {}, missingMethodFor: {} };
    typ.keyFor = $ifaceKeyFor;
    typ.init = function(methods) {
      typ.methods = methods;
      methods.forEach(function(m) {
        $ifaceNil[m.prop] = $throwNilPointerError;
      });
    };
    break;

  case $kindMap:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.init = function(key, elem) {
      typ.key = key;
      typ.elem = elem;
      typ.comparable = false;
    };
    break;

  case $kindPtr:
    typ = constructor || function(getter, setter, target) {
      this.$get = getter;
      this.$set = setter;
      this.$target = target;
      this.$val = this;
    };
    typ.keyFor = $idKey;
    typ.init = function(elem) {
      typ.elem = elem;
      typ.wrapped = (elem.kind === $kindArray);
      typ.nil = new typ($throwNilPointerError, $throwNilPointerError);
    };
    break;

  case $kindSlice:
    typ = function(array) {
      if (array.constructor !== typ.nativeArray) {
        array = new typ.nativeArray(array);
      }
      this.$array = array;
      this.$offset = 0;
      this.$length = array.length;
      this.$capacity = array.length;
      this.$val = this;
    };
    typ.init = function(elem) {
      typ.elem = elem;
      typ.comparable = false;
      typ.nativeArray = $nativeArray(elem.kind);
      typ.nil = new typ([]);
    };
    break;

  case $kindStruct:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.ptr = $newType(4, $kindPtr, "*" + string, false, pkg, exported, constructor);
    typ.ptr.elem = typ;
    typ.ptr.prototype.$get = function() { return this; };
    typ.ptr.prototype.$set = function(v) { typ.copy(this, v); };
    typ.init = function(pkgPath, fields) {
      typ.pkgPath = pkgPath;
      typ.fields = fields;
      fields.forEach(function(f) {
        if (!f.typ.comparable) {
          typ.comparable = false;
        }
      });
      typ.keyFor = function(x) {
        var val = x.$val;
        return $mapArray(fields, function(f) {
          return String(f.typ.keyFor(val[f.prop])).replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
        }).join("$");
      };
      typ.copy = function(dst, src) {
        for (var i = 0; i < fields.length; i++) {
          var f = fields[i];
          switch (f.typ.kind) {
          case $kindArray:
          case $kindStruct:
            f.typ.copy(dst[f.prop], src[f.prop]);
            continue;
          default:
            dst[f.prop] = src[f.prop];
            continue;
          }
        }
      };
      /* nil value */
      var properties = {};
      fields.forEach(function(f) {
        properties[f.prop] = { get: $throwNilPointerError, set: $throwNilPointerError };
      });
      typ.ptr.nil = Object.create(constructor.prototype, properties);
      typ.ptr.nil.$val = typ.ptr.nil;
      /* methods for embedded fields */
      $addMethodSynthesizer(function() {
        var synthesizeMethod = function(target, m, f) {
          if (target.prototype[m.prop] !== undefined) { return; }
          target.prototype[m.prop] = function() {
            var v = this.$val[f.prop];
            if (f.typ === $jsObjectPtr) {
              v = new $jsObjectPtr(v);
            }
            if (v.$val === undefined) {
              v = new f.typ(v);
            }
            return v[m.prop].apply(v, arguments);
          };
        };
        fields.forEach(function(f) {
          if (f.embedded) {
            $methodSet(f.typ).forEach(function(m) {
              synthesizeMethod(typ, m, f);
              synthesizeMethod(typ.ptr, m, f);
            });
            $methodSet($ptrType(f.typ)).forEach(function(m) {
              synthesizeMethod(typ.ptr, m, f);
            });
          }
        });
      });
    };
    break;

  default:
    $panic(new $String("invalid kind: " + kind));
  }

  switch (kind) {
  case $kindBool:
  case $kindMap:
    typ.zero = function() { return false; };
    break;

  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8 :
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindUnsafePointer:
  case $kindFloat32:
  case $kindFloat64:
    typ.zero = function() { return 0; };
    break;

  case $kindString:
    typ.zero = function() { return ""; };
    break;

  case $kindInt64:
  case $kindUint64:
  case $kindComplex64:
  case $kindComplex128:
    var zero = new typ(0, 0);
    typ.zero = function() { return zero; };
    break;

  case $kindPtr:
  case $kindSlice:
    typ.zero = function() { return typ.nil; };
    break;

  case $kindChan:
    typ.zero = function() { return $chanNil; };
    break;

  case $kindFunc:
    typ.zero = function() { return $throwNilPointerError; };
    break;

  case $kindInterface:
    typ.zero = function() { return $ifaceNil; };
    break;

  case $kindArray:
    typ.zero = function() {
      var arrayClass = $nativeArray(typ.elem.kind);
      if (arrayClass !== Array) {
        return new arrayClass(typ.len);
      }
      var array = new Array(typ.len);
      for (var i = 0; i < typ.len; i++) {
        array[i] = typ.elem.zero();
      }
      return array;
    };
    break;

  case $kindStruct:
    typ.zero = function() { return new typ.ptr(); };
    break;

  default:
    $panic(new $String("invalid kind: " + kind));
  }

  typ.id = $typeIDCounter;
  $typeIDCounter++;
  typ.size = size;
  typ.kind = kind;
  typ.string = string;
  typ.named = named;
  typ.pkg = pkg;
  typ.exported = exported;
  typ.methods = [];
  typ.methodSetCache = null;
  typ.comparable = true;
  return typ;
};

var $methodSet = function(typ) {
  if (typ.methodSetCache !== null) {
    return typ.methodSetCache;
  }
  var base = {};

  var isPtr = (typ.kind === $kindPtr);
  if (isPtr && typ.elem.kind === $kindInterface) {
    typ.methodSetCache = [];
    return [];
  }

  var current = [{typ: isPtr ? typ.elem : typ, indirect: isPtr}];

  var seen = {};

  while (current.length > 0) {
    var next = [];
    var mset = [];

    current.forEach(function(e) {
      if (seen[e.typ.string]) {
        return;
      }
      seen[e.typ.string] = true;

      if (e.typ.named) {
        mset = mset.concat(e.typ.methods);
        if (e.indirect) {
          mset = mset.concat($ptrType(e.typ).methods);
        }
      }

      switch (e.typ.kind) {
      case $kindStruct:
        e.typ.fields.forEach(function(f) {
          if (f.embedded) {
            var fTyp = f.typ;
            var fIsPtr = (fTyp.kind === $kindPtr);
            next.push({typ: fIsPtr ? fTyp.elem : fTyp, indirect: e.indirect || fIsPtr});
          }
        });
        break;

      case $kindInterface:
        mset = mset.concat(e.typ.methods);
        break;
      }
    });

    mset.forEach(function(m) {
      if (base[m.name] === undefined) {
        base[m.name] = m;
      }
    });

    current = next;
  }

  typ.methodSetCache = [];
  Object.keys(base).sort().forEach(function(name) {
    typ.methodSetCache.push(base[name]);
  });
  return typ.methodSetCache;
};

var $Bool          = $newType( 1, $kindBool,          "bool",           true, "", false, null);
var $Int           = $newType( 4, $kindInt,           "int",            true, "", false, null);
var $Int8          = $newType( 1, $kindInt8,          "int8",           true, "", false, null);
var $Int16         = $newType( 2, $kindInt16,         "int16",          true, "", false, null);
var $Int32         = $newType( 4, $kindInt32,         "int32",          true, "", false, null);
var $Int64         = $newType( 8, $kindInt64,         "int64",          true, "", false, null);
var $Uint          = $newType( 4, $kindUint,          "uint",           true, "", false, null);
var $Uint8         = $newType( 1, $kindUint8,         "uint8",          true, "", false, null);
var $Uint16        = $newType( 2, $kindUint16,        "uint16",         true, "", false, null);
var $Uint32        = $newType( 4, $kindUint32,        "uint32",         true, "", false, null);
var $Uint64        = $newType( 8, $kindUint64,        "uint64",         true, "", false, null);
var $Uintptr       = $newType( 4, $kindUintptr,       "uintptr",        true, "", false, null);
var $Float32       = $newType( 4, $kindFloat32,       "float32",        true, "", false, null);
var $Float64       = $newType( 8, $kindFloat64,       "float64",        true, "", false, null);
var $Complex64     = $newType( 8, $kindComplex64,     "complex64",      true, "", false, null);
var $Complex128    = $newType(16, $kindComplex128,    "complex128",     true, "", false, null);
var $String        = $newType( 8, $kindString,        "string",         true, "", false, null);
var $UnsafePointer = $newType( 4, $kindUnsafePointer, "unsafe.Pointer", true, "", false, null);

var $nativeArray = function(elemKind) {
  switch (elemKind) {
  case $kindInt:
    return Int32Array;
  case $kindInt8:
    return Int8Array;
  case $kindInt16:
    return Int16Array;
  case $kindInt32:
    return Int32Array;
  case $kindUint:
    return Uint32Array;
  case $kindUint8:
    return Uint8Array;
  case $kindUint16:
    return Uint16Array;
  case $kindUint32:
    return Uint32Array;
  case $kindUintptr:
    return Uint32Array;
  case $kindFloat32:
    return Float32Array;
  case $kindFloat64:
    return Float64Array;
  default:
    return Array;
  }
};
var $toNativeArray = function(elemKind, array) {
  var nativeArray = $nativeArray(elemKind);
  if (nativeArray === Array) {
    return array;
  }
  return new nativeArray(array);
};
var $arrayTypes = {};
var $arrayType = function(elem, len) {
  var typeKey = elem.id + "$" + len;
  var typ = $arrayTypes[typeKey];
  if (typ === undefined) {
    typ = $newType(12, $kindArray, "[" + len + "]" + elem.string, false, "", false, null);
    $arrayTypes[typeKey] = typ;
    typ.init(elem, len);
  }
  return typ;
};

var $chanType = function(elem, sendOnly, recvOnly) {
  var string = (recvOnly ? "<-" : "") + "chan" + (sendOnly ? "<- " : " ") + elem.string;
  var field = sendOnly ? "SendChan" : (recvOnly ? "RecvChan" : "Chan");
  var typ = elem[field];
  if (typ === undefined) {
    typ = $newType(4, $kindChan, string, false, "", false, null);
    elem[field] = typ;
    typ.init(elem, sendOnly, recvOnly);
  }
  return typ;
};
var $Chan = function(elem, capacity) {
  if (capacity < 0 || capacity > 2147483647) {
    $throwRuntimeError("makechan: size out of range");
  }
  this.$elem = elem;
  this.$capacity = capacity;
  this.$buffer = [];
  this.$sendQueue = [];
  this.$recvQueue = [];
  this.$closed = false;
};
var $chanNil = new $Chan(null, 0);
$chanNil.$sendQueue = $chanNil.$recvQueue = { length: 0, push: function() {}, shift: function() { return undefined; }, indexOf: function() { return -1; } };

var $funcTypes = {};
var $funcType = function(params, results, variadic) {
  var typeKey = $mapArray(params, function(p) { return p.id; }).join(",") + "$" + $mapArray(results, function(r) { return r.id; }).join(",") + "$" + variadic;
  var typ = $funcTypes[typeKey];
  if (typ === undefined) {
    var paramTypes = $mapArray(params, function(p) { return p.string; });
    if (variadic) {
      paramTypes[paramTypes.length - 1] = "..." + paramTypes[paramTypes.length - 1].substr(2);
    }
    var string = "func(" + paramTypes.join(", ") + ")";
    if (results.length === 1) {
      string += " " + results[0].string;
    } else if (results.length > 1) {
      string += " (" + $mapArray(results, function(r) { return r.string; }).join(", ") + ")";
    }
    typ = $newType(4, $kindFunc, string, false, "", false, null);
    $funcTypes[typeKey] = typ;
    typ.init(params, results, variadic);
  }
  return typ;
};

var $interfaceTypes = {};
var $interfaceType = function(methods) {
  var typeKey = $mapArray(methods, function(m) { return m.pkg + "," + m.name + "," + m.typ.id; }).join("$");
  var typ = $interfaceTypes[typeKey];
  if (typ === undefined) {
    var string = "interface {}";
    if (methods.length !== 0) {
      string = "interface { " + $mapArray(methods, function(m) {
        return (m.pkg !== "" ? m.pkg + "." : "") + m.name + m.typ.string.substr(4);
      }).join("; ") + " }";
    }
    typ = $newType(8, $kindInterface, string, false, "", false, null);
    $interfaceTypes[typeKey] = typ;
    typ.init(methods);
  }
  return typ;
};
var $emptyInterface = $interfaceType([]);
var $ifaceNil = {};
var $error = $newType(8, $kindInterface, "error", true, "", false, null);
$error.init([{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}]);

var $mapTypes = {};
var $mapType = function(key, elem) {
  var typeKey = key.id + "$" + elem.id;
  var typ = $mapTypes[typeKey];
  if (typ === undefined) {
    typ = $newType(4, $kindMap, "map[" + key.string + "]" + elem.string, false, "", false, null);
    $mapTypes[typeKey] = typ;
    typ.init(key, elem);
  }
  return typ;
};
var $makeMap = function(keyForFunc, entries) {
  var m = {};
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    m[keyForFunc(e.k)] = e;
  }
  return m;
};

var $ptrType = function(elem) {
  var typ = elem.ptr;
  if (typ === undefined) {
    typ = $newType(4, $kindPtr, "*" + elem.string, false, "", elem.exported, null);
    elem.ptr = typ;
    typ.init(elem);
  }
  return typ;
};

var $newDataPointer = function(data, constructor) {
  if (constructor.elem.kind === $kindStruct) {
    return data;
  }
  return new constructor(function() { return data; }, function(v) { data = v; });
};

var $indexPtr = function(array, index, constructor) {
  array.$ptr = array.$ptr || {};
  return array.$ptr[index] || (array.$ptr[index] = new constructor(function() { return array[index]; }, function(v) { array[index] = v; }));
};

var $sliceType = function(elem) {
  var typ = elem.slice;
  if (typ === undefined) {
    typ = $newType(12, $kindSlice, "[]" + elem.string, false, "", false, null);
    elem.slice = typ;
    typ.init(elem);
  }
  return typ;
};
var $makeSlice = function(typ, length, capacity) {
  capacity = capacity || length;
  if (length < 0 || length > 2147483647) {
    $throwRuntimeError("makeslice: len out of range");
  }
  if (capacity < 0 || capacity < length || capacity > 2147483647) {
    $throwRuntimeError("makeslice: cap out of range");
  }
  var array = new typ.nativeArray(capacity);
  if (typ.nativeArray === Array) {
    for (var i = 0; i < capacity; i++) {
      array[i] = typ.elem.zero();
    }
  }
  var slice = new typ(array);
  slice.$length = length;
  return slice;
};

var $structTypes = {};
var $structType = function(pkgPath, fields) {
  var typeKey = $mapArray(fields, function(f) { return f.name + "," + f.typ.id + "," + f.tag; }).join("$");
  var typ = $structTypes[typeKey];
  if (typ === undefined) {
    var string = "struct { " + $mapArray(fields, function(f) {
      return f.name + " " + f.typ.string + (f.tag !== "" ? (" \"" + f.tag.replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + "\"") : "");
    }).join("; ") + " }";
    if (fields.length === 0) {
      string = "struct {}";
    }
    typ = $newType(0, $kindStruct, string, false, "", false, function() {
      this.$val = this;
      for (var i = 0; i < fields.length; i++) {
        var f = fields[i];
        var arg = arguments[i];
        this[f.prop] = arg !== undefined ? arg : f.typ.zero();
      }
    });
    $structTypes[typeKey] = typ;
    typ.init(pkgPath, fields);
  }
  return typ;
};

var $assertType = function(value, type, returnTuple) {
  var isInterface = (type.kind === $kindInterface), ok, missingMethod = "";
  if (value === $ifaceNil) {
    ok = false;
  } else if (!isInterface) {
    ok = value.constructor === type;
  } else {
    var valueTypeString = value.constructor.string;
    ok = type.implementedBy[valueTypeString];
    if (ok === undefined) {
      ok = true;
      var valueMethodSet = $methodSet(value.constructor);
      var interfaceMethods = type.methods;
      for (var i = 0; i < interfaceMethods.length; i++) {
        var tm = interfaceMethods[i];
        var found = false;
        for (var j = 0; j < valueMethodSet.length; j++) {
          var vm = valueMethodSet[j];
          if (vm.name === tm.name && vm.pkg === tm.pkg && vm.typ === tm.typ) {
            found = true;
            break;
          }
        }
        if (!found) {
          ok = false;
          type.missingMethodFor[valueTypeString] = tm.name;
          break;
        }
      }
      type.implementedBy[valueTypeString] = ok;
    }
    if (!ok) {
      missingMethod = type.missingMethodFor[valueTypeString];
    }
  }

  if (!ok) {
    if (returnTuple) {
      return [type.zero(), false];
    }
    $panic(new $packages["runtime"].TypeAssertionError.ptr(
      $packages["runtime"]._type.ptr.nil,
      (value === $ifaceNil ? $packages["runtime"]._type.ptr.nil : new $packages["runtime"]._type.ptr(value.constructor.string)),
      new $packages["runtime"]._type.ptr(type.string),
      missingMethod));
  }

  if (!isInterface) {
    value = value.$val;
  }
  if (type === $jsObjectPtr) {
    value = value.object;
  }
  return returnTuple ? [value, true] : value;
};

var $stackDepthOffset = 0;
var $getStackDepth = function() {
  var err = new Error();
  if (err.stack === undefined) {
    return undefined;
  }
  return $stackDepthOffset + err.stack.split("\n").length;
};

var $panicStackDepth = null, $panicValue;
var $callDeferred = function(deferred, jsErr, fromPanic) {
  if (!fromPanic && deferred !== null && deferred.index >= $curGoroutine.deferStack.length) {
    throw jsErr;
  }
  if (jsErr !== null) {
    var newErr = null;
    try {
      $curGoroutine.deferStack.push(deferred);
      $panic(new $jsErrorPtr(jsErr));
    } catch (err) {
      newErr = err;
    }
    $curGoroutine.deferStack.pop();
    $callDeferred(deferred, newErr);
    return;
  }
  if ($curGoroutine.asleep) {
    return;
  }

  $stackDepthOffset--;
  var outerPanicStackDepth = $panicStackDepth;
  var outerPanicValue = $panicValue;

  var localPanicValue = $curGoroutine.panicStack.pop();
  if (localPanicValue !== undefined) {
    $panicStackDepth = $getStackDepth();
    $panicValue = localPanicValue;
  }

  try {
    while (true) {
      if (deferred === null) {
        deferred = $curGoroutine.deferStack[$curGoroutine.deferStack.length - 1];
        if (deferred === undefined) {
          /* The panic reached the top of the stack. Clear it and throw it as a JavaScript error. */
          $panicStackDepth = null;
          if (localPanicValue.Object instanceof Error) {
            throw localPanicValue.Object;
          }
          var msg;
          if (localPanicValue.constructor === $String) {
            msg = localPanicValue.$val;
          } else if (localPanicValue.Error !== undefined) {
            msg = localPanicValue.Error();
          } else if (localPanicValue.String !== undefined) {
            msg = localPanicValue.String();
          } else {
            msg = localPanicValue;
          }
          throw new Error(msg);
        }
      }
      var call = deferred.pop();
      if (call === undefined) {
        $curGoroutine.deferStack.pop();
        if (localPanicValue !== undefined) {
          deferred = null;
          continue;
        }
        return;
      }
      var r = call[0].apply(call[2], call[1]);
      if (r && r.$blk !== undefined) {
        deferred.push([r.$blk, [], r]);
        if (fromPanic) {
          throw null;
        }
        return;
      }

      if (localPanicValue !== undefined && $panicStackDepth === null) {
        throw null; /* error was recovered */
      }
    }
  } finally {
    if (localPanicValue !== undefined) {
      if ($panicStackDepth !== null) {
        $curGoroutine.panicStack.push(localPanicValue);
      }
      $panicStackDepth = outerPanicStackDepth;
      $panicValue = outerPanicValue;
    }
    $stackDepthOffset++;
  }
};

var $panic = function(value) {
  $curGoroutine.panicStack.push(value);
  $callDeferred(null, null, true);
};
var $recover = function() {
  if ($panicStackDepth === null || ($panicStackDepth !== undefined && $panicStackDepth !== $getStackDepth() - 2)) {
    return $ifaceNil;
  }
  $panicStackDepth = null;
  return $panicValue;
};
var $throw = function(err) { throw err; };

var $noGoroutine = { asleep: false, exit: false, deferStack: [], panicStack: [] };
var $curGoroutine = $noGoroutine, $totalGoroutines = 0, $awakeGoroutines = 0, $checkForDeadlock = true;
var $mainFinished = false;
var $go = function(fun, args) {
  $totalGoroutines++;
  $awakeGoroutines++;
  var $goroutine = function() {
    try {
      $curGoroutine = $goroutine;
      var r = fun.apply(undefined, args);
      if (r && r.$blk !== undefined) {
        fun = function() { return r.$blk(); };
        args = [];
        return;
      }
      $goroutine.exit = true;
    } catch (err) {
      if (!$goroutine.exit) {
        throw err;
      }
    } finally {
      $curGoroutine = $noGoroutine;
      if ($goroutine.exit) { /* also set by runtime.Goexit() */
        $totalGoroutines--;
        $goroutine.asleep = true;
      }
      if ($goroutine.asleep) {
        $awakeGoroutines--;
        if (!$mainFinished && $awakeGoroutines === 0 && $checkForDeadlock) {
          console.error("fatal error: all goroutines are asleep - deadlock!");
          if ($global.process !== undefined) {
            $global.process.exit(2);
          }
        }
      }
    }
  };
  $goroutine.asleep = false;
  $goroutine.exit = false;
  $goroutine.deferStack = [];
  $goroutine.panicStack = [];
  $schedule($goroutine);
};

var $scheduled = [];
var $runScheduled = function() {
  try {
    var r;
    while ((r = $scheduled.shift()) !== undefined) {
      r();
    }
  } finally {
    if ($scheduled.length > 0) {
      setTimeout($runScheduled, 0);
    }
  }
};

var $schedule = function(goroutine) {
  if (goroutine.asleep) {
    goroutine.asleep = false;
    $awakeGoroutines++;
  }
  $scheduled.push(goroutine);
  if ($curGoroutine === $noGoroutine) {
    $runScheduled();
  }
};

var $setTimeout = function(f, t) {
  $awakeGoroutines++;
  return setTimeout(function() {
    $awakeGoroutines--;
    f();
  }, t);
};

var $block = function() {
  if ($curGoroutine === $noGoroutine) {
    $throwRuntimeError("cannot block in JavaScript callback, fix by wrapping code in goroutine");
  }
  $curGoroutine.asleep = true;
};

var $send = function(chan, value) {
  if (chan.$closed) {
    $throwRuntimeError("send on closed channel");
  }
  var queuedRecv = chan.$recvQueue.shift();
  if (queuedRecv !== undefined) {
    queuedRecv([value, true]);
    return;
  }
  if (chan.$buffer.length < chan.$capacity) {
    chan.$buffer.push(value);
    return;
  }

  var thisGoroutine = $curGoroutine;
  var closedDuringSend;
  chan.$sendQueue.push(function(closed) {
    closedDuringSend = closed;
    $schedule(thisGoroutine);
    return value;
  });
  $block();
  return {
    $blk: function() {
      if (closedDuringSend) {
        $throwRuntimeError("send on closed channel");
      }
    }
  };
};
var $recv = function(chan) {
  var queuedSend = chan.$sendQueue.shift();
  if (queuedSend !== undefined) {
    chan.$buffer.push(queuedSend(false));
  }
  var bufferedValue = chan.$buffer.shift();
  if (bufferedValue !== undefined) {
    return [bufferedValue, true];
  }
  if (chan.$closed) {
    return [chan.$elem.zero(), false];
  }

  var thisGoroutine = $curGoroutine;
  var f = { $blk: function() { return this.value; } };
  var queueEntry = function(v) {
    f.value = v;
    $schedule(thisGoroutine);
  };
  chan.$recvQueue.push(queueEntry);
  $block();
  return f;
};
var $close = function(chan) {
  if (chan.$closed) {
    $throwRuntimeError("close of closed channel");
  }
  chan.$closed = true;
  while (true) {
    var queuedSend = chan.$sendQueue.shift();
    if (queuedSend === undefined) {
      break;
    }
    queuedSend(true); /* will panic */
  }
  while (true) {
    var queuedRecv = chan.$recvQueue.shift();
    if (queuedRecv === undefined) {
      break;
    }
    queuedRecv([chan.$elem.zero(), false]);
  }
};
var $select = function(comms) {
  var ready = [];
  var selection = -1;
  for (var i = 0; i < comms.length; i++) {
    var comm = comms[i];
    var chan = comm[0];
    switch (comm.length) {
    case 0: /* default */
      selection = i;
      break;
    case 1: /* recv */
      if (chan.$sendQueue.length !== 0 || chan.$buffer.length !== 0 || chan.$closed) {
        ready.push(i);
      }
      break;
    case 2: /* send */
      if (chan.$closed) {
        $throwRuntimeError("send on closed channel");
      }
      if (chan.$recvQueue.length !== 0 || chan.$buffer.length < chan.$capacity) {
        ready.push(i);
      }
      break;
    }
  }

  if (ready.length !== 0) {
    selection = ready[Math.floor(Math.random() * ready.length)];
  }
  if (selection !== -1) {
    var comm = comms[selection];
    switch (comm.length) {
    case 0: /* default */
      return [selection];
    case 1: /* recv */
      return [selection, $recv(comm[0])];
    case 2: /* send */
      $send(comm[0], comm[1]);
      return [selection];
    }
  }

  var entries = [];
  var thisGoroutine = $curGoroutine;
  var f = { $blk: function() { return this.selection; } };
  var removeFromQueues = function() {
    for (var i = 0; i < entries.length; i++) {
      var entry = entries[i];
      var queue = entry[0];
      var index = queue.indexOf(entry[1]);
      if (index !== -1) {
        queue.splice(index, 1);
      }
    }
  };
  for (var i = 0; i < comms.length; i++) {
    (function(i) {
      var comm = comms[i];
      switch (comm.length) {
      case 1: /* recv */
        var queueEntry = function(value) {
          f.selection = [i, value];
          removeFromQueues();
          $schedule(thisGoroutine);
        };
        entries.push([comm[0].$recvQueue, queueEntry]);
        comm[0].$recvQueue.push(queueEntry);
        break;
      case 2: /* send */
        var queueEntry = function() {
          if (comm[0].$closed) {
            $throwRuntimeError("send on closed channel");
          }
          f.selection = [i];
          removeFromQueues();
          $schedule(thisGoroutine);
          return comm[1];
        };
        entries.push([comm[0].$sendQueue, queueEntry]);
        comm[0].$sendQueue.push(queueEntry);
        break;
      }
    })(i);
  }
  $block();
  return f;
};

var $jsObjectPtr, $jsErrorPtr;

var $needsExternalization = function(t) {
  switch (t.kind) {
    case $kindBool:
    case $kindInt:
    case $kindInt8:
    case $kindInt16:
    case $kindInt32:
    case $kindUint:
    case $kindUint8:
    case $kindUint16:
    case $kindUint32:
    case $kindUintptr:
    case $kindFloat32:
    case $kindFloat64:
      return false;
    default:
      return t !== $jsObjectPtr;
  }
};

var $externalize = function(v, t) {
  if (t === $jsObjectPtr) {
    return v;
  }
  switch (t.kind) {
  case $kindBool:
  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8:
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindFloat32:
  case $kindFloat64:
    return v;
  case $kindInt64:
  case $kindUint64:
    return $flatten64(v);
  case $kindArray:
    if ($needsExternalization(t.elem)) {
      return $mapArray(v, function(e) { return $externalize(e, t.elem); });
    }
    return v;
  case $kindFunc:
    return $externalizeFunction(v, t, false);
  case $kindInterface:
    if (v === $ifaceNil) {
      return null;
    }
    if (v.constructor === $jsObjectPtr) {
      return v.$val.object;
    }
    return $externalize(v.$val, v.constructor);
  case $kindMap:
    var m = {};
    var keys = $keys(v);
    for (var i = 0; i < keys.length; i++) {
      var entry = v[keys[i]];
      m[$externalize(entry.k, t.key)] = $externalize(entry.v, t.elem);
    }
    return m;
  case $kindPtr:
    if (v === t.nil) {
      return null;
    }
    return $externalize(v.$get(), t.elem);
  case $kindSlice:
    if ($needsExternalization(t.elem)) {
      return $mapArray($sliceToArray(v), function(e) { return $externalize(e, t.elem); });
    }
    return $sliceToArray(v);
  case $kindString:
    if ($isASCII(v)) {
      return v;
    }
    var s = "", r;
    for (var i = 0; i < v.length; i += r[1]) {
      r = $decodeRune(v, i);
      var c = r[0];
      if (c > 0xFFFF) {
        var h = Math.floor((c - 0x10000) / 0x400) + 0xD800;
        var l = (c - 0x10000) % 0x400 + 0xDC00;
        s += String.fromCharCode(h, l);
        continue;
      }
      s += String.fromCharCode(c);
    }
    return s;
  case $kindStruct:
    var timePkg = $packages["time"];
    if (timePkg !== undefined && v.constructor === timePkg.Time.ptr) {
      var milli = $div64(v.UnixNano(), new $Int64(0, 1000000));
      return new Date($flatten64(milli));
    }

    var noJsObject = {};
    var searchJsObject = function(v, t) {
      if (t === $jsObjectPtr) {
        return v;
      }
      switch (t.kind) {
      case $kindPtr:
        if (v === t.nil) {
          return noJsObject;
        }
        return searchJsObject(v.$get(), t.elem);
      case $kindStruct:
        var f = t.fields[0];
        return searchJsObject(v[f.prop], f.typ);
      case $kindInterface:
        return searchJsObject(v.$val, v.constructor);
      default:
        return noJsObject;
      }
    };
    var o = searchJsObject(v, t);
    if (o !== noJsObject) {
      return o;
    }

    o = {};
    for (var i = 0; i < t.fields.length; i++) {
      var f = t.fields[i];
      if (!f.exported) {
        continue;
      }
      o[f.name] = $externalize(v[f.prop], f.typ);
    }
    return o;
  }
  $throwRuntimeError("cannot externalize " + t.string);
};

var $externalizeFunction = function(v, t, passThis) {
  if (v === $throwNilPointerError) {
    return null;
  }
  if (v.$externalizeWrapper === undefined) {
    $checkForDeadlock = false;
    v.$externalizeWrapper = function() {
      var args = [];
      for (var i = 0; i < t.params.length; i++) {
        if (t.variadic && i === t.params.length - 1) {
          var vt = t.params[i].elem, varargs = [];
          for (var j = i; j < arguments.length; j++) {
            varargs.push($internalize(arguments[j], vt));
          }
          args.push(new (t.params[i])(varargs));
          break;
        }
        args.push($internalize(arguments[i], t.params[i]));
      }
      var result = v.apply(passThis ? this : undefined, args);
      switch (t.results.length) {
      case 0:
        return;
      case 1:
        return $externalize(result, t.results[0]);
      default:
        for (var i = 0; i < t.results.length; i++) {
          result[i] = $externalize(result[i], t.results[i]);
        }
        return result;
      }
    };
  }
  return v.$externalizeWrapper;
};

var $internalize = function(v, t, recv) {
  if (t === $jsObjectPtr) {
    return v;
  }
  if (t === $jsObjectPtr.elem) {
    $throwRuntimeError("cannot internalize js.Object, use *js.Object instead");
  }
  if (v && v.__internal_object__ !== undefined) {
    return $assertType(v.__internal_object__, t, false);
  }
  var timePkg = $packages["time"];
  if (timePkg !== undefined && t === timePkg.Time) {
    if (!(v !== null && v !== undefined && v.constructor === Date)) {
      $throwRuntimeError("cannot internalize time.Time from " + typeof v + ", must be Date");
    }
    return timePkg.Unix(new $Int64(0, 0), new $Int64(0, v.getTime() * 1000000));
  }
  switch (t.kind) {
  case $kindBool:
    return !!v;
  case $kindInt:
    return parseInt(v);
  case $kindInt8:
    return parseInt(v) << 24 >> 24;
  case $kindInt16:
    return parseInt(v) << 16 >> 16;
  case $kindInt32:
    return parseInt(v) >> 0;
  case $kindUint:
    return parseInt(v);
  case $kindUint8:
    return parseInt(v) << 24 >>> 24;
  case $kindUint16:
    return parseInt(v) << 16 >>> 16;
  case $kindUint32:
  case $kindUintptr:
    return parseInt(v) >>> 0;
  case $kindInt64:
  case $kindUint64:
    return new t(0, v);
  case $kindFloat32:
  case $kindFloat64:
    return parseFloat(v);
  case $kindArray:
    if (v.length !== t.len) {
      $throwRuntimeError("got array with wrong size from JavaScript native");
    }
    return $mapArray(v, function(e) { return $internalize(e, t.elem); });
  case $kindFunc:
    return function() {
      var args = [];
      for (var i = 0; i < t.params.length; i++) {
        if (t.variadic && i === t.params.length - 1) {
          var vt = t.params[i].elem, varargs = arguments[i];
          for (var j = 0; j < varargs.$length; j++) {
            args.push($externalize(varargs.$array[varargs.$offset + j], vt));
          }
          break;
        }
        args.push($externalize(arguments[i], t.params[i]));
      }
      var result = v.apply(recv, args);
      switch (t.results.length) {
      case 0:
        return;
      case 1:
        return $internalize(result, t.results[0]);
      default:
        for (var i = 0; i < t.results.length; i++) {
          result[i] = $internalize(result[i], t.results[i]);
        }
        return result;
      }
    };
  case $kindInterface:
    if (t.methods.length !== 0) {
      $throwRuntimeError("cannot internalize " + t.string);
    }
    if (v === null) {
      return $ifaceNil;
    }
    if (v === undefined) {
      return new $jsObjectPtr(undefined);
    }
    switch (v.constructor) {
    case Int8Array:
      return new ($sliceType($Int8))(v);
    case Int16Array:
      return new ($sliceType($Int16))(v);
    case Int32Array:
      return new ($sliceType($Int))(v);
    case Uint8Array:
      return new ($sliceType($Uint8))(v);
    case Uint16Array:
      return new ($sliceType($Uint16))(v);
    case Uint32Array:
      return new ($sliceType($Uint))(v);
    case Float32Array:
      return new ($sliceType($Float32))(v);
    case Float64Array:
      return new ($sliceType($Float64))(v);
    case Array:
      return $internalize(v, $sliceType($emptyInterface));
    case Boolean:
      return new $Bool(!!v);
    case Date:
      if (timePkg === undefined) {
        /* time package is not present, internalize as &js.Object{Date} so it can be externalized into original Date. */
        return new $jsObjectPtr(v);
      }
      return new timePkg.Time($internalize(v, timePkg.Time));
    case Function:
      var funcType = $funcType([$sliceType($emptyInterface)], [$jsObjectPtr], true);
      return new funcType($internalize(v, funcType));
    case Number:
      return new $Float64(parseFloat(v));
    case String:
      return new $String($internalize(v, $String));
    default:
      if ($global.Node && v instanceof $global.Node) {
        return new $jsObjectPtr(v);
      }
      var mapType = $mapType($String, $emptyInterface);
      return new mapType($internalize(v, mapType));
    }
  case $kindMap:
    var m = {};
    var keys = $keys(v);
    for (var i = 0; i < keys.length; i++) {
      var k = $internalize(keys[i], t.key);
      m[t.key.keyFor(k)] = { k: k, v: $internalize(v[keys[i]], t.elem) };
    }
    return m;
  case $kindPtr:
    if (t.elem.kind === $kindStruct) {
      return $internalize(v, t.elem);
    }
  case $kindSlice:
    return new t($mapArray(v, function(e) { return $internalize(e, t.elem); }));
  case $kindString:
    v = String(v);
    if ($isASCII(v)) {
      return v;
    }
    var s = "";
    var i = 0;
    while (i < v.length) {
      var h = v.charCodeAt(i);
      if (0xD800 <= h && h <= 0xDBFF) {
        var l = v.charCodeAt(i + 1);
        var c = (h - 0xD800) * 0x400 + l - 0xDC00 + 0x10000;
        s += $encodeRune(c);
        i += 2;
        continue;
      }
      s += $encodeRune(h);
      i++;
    }
    return s;
  case $kindStruct:
    var noJsObject = {};
    var searchJsObject = function(t) {
      if (t === $jsObjectPtr) {
        return v;
      }
      if (t === $jsObjectPtr.elem) {
        $throwRuntimeError("cannot internalize js.Object, use *js.Object instead");
      }
      switch (t.kind) {
      case $kindPtr:
        return searchJsObject(t.elem);
      case $kindStruct:
        var f = t.fields[0];
        var o = searchJsObject(f.typ);
        if (o !== noJsObject) {
          var n = new t.ptr();
          n[f.prop] = o;
          return n;
        }
        return noJsObject;
      default:
        return noJsObject;
      }
    };
    var o = searchJsObject(t);
    if (o !== noJsObject) {
      return o;
    }
  }
  $throwRuntimeError("cannot internalize " + t.string);
};

/* $isASCII reports whether string s contains only ASCII characters. */
var $isASCII = function(s) {
  for (var i = 0; i < s.length; i++) {
    if (s.charCodeAt(i) >= 128) {
      return false;
    }
  }
  return true;
};

$packages["github.com/gopherjs/gopherjs/js"] = (function() {
	var $pkg = {}, $init, Object, Error, sliceType, ptrType, ptrType$1, MakeFunc, init;
	Object = $pkg.Object = $newType(0, $kindStruct, "js.Object", true, "github.com/gopherjs/gopherjs/js", true, function(object_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.object = null;
			return;
		}
		this.object = object_;
	});
	Error = $pkg.Error = $newType(0, $kindStruct, "js.Error", true, "github.com/gopherjs/gopherjs/js", true, function(Object_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Object = null;
			return;
		}
		this.Object = Object_;
	});
	sliceType = $sliceType($emptyInterface);
	ptrType = $ptrType(Object);
	ptrType$1 = $ptrType(Error);
	Object.ptr.prototype.Get = function(key) {
		var key, o;
		o = this;
		return o.object[$externalize(key, $String)];
	};
	Object.prototype.Get = function(key) { return this.$val.Get(key); };
	Object.ptr.prototype.Set = function(key, value) {
		var key, o, value;
		o = this;
		o.object[$externalize(key, $String)] = $externalize(value, $emptyInterface);
	};
	Object.prototype.Set = function(key, value) { return this.$val.Set(key, value); };
	Object.ptr.prototype.Delete = function(key) {
		var key, o;
		o = this;
		delete o.object[$externalize(key, $String)];
	};
	Object.prototype.Delete = function(key) { return this.$val.Delete(key); };
	Object.ptr.prototype.Length = function() {
		var o;
		o = this;
		return $parseInt(o.object.length);
	};
	Object.prototype.Length = function() { return this.$val.Length(); };
	Object.ptr.prototype.Index = function(i) {
		var i, o;
		o = this;
		return o.object[i];
	};
	Object.prototype.Index = function(i) { return this.$val.Index(i); };
	Object.ptr.prototype.SetIndex = function(i, value) {
		var i, o, value;
		o = this;
		o.object[i] = $externalize(value, $emptyInterface);
	};
	Object.prototype.SetIndex = function(i, value) { return this.$val.SetIndex(i, value); };
	Object.ptr.prototype.Call = function(name, args) {
		var args, name, o, obj;
		o = this;
		return (obj = o.object, obj[$externalize(name, $String)].apply(obj, $externalize(args, sliceType)));
	};
	Object.prototype.Call = function(name, args) { return this.$val.Call(name, args); };
	Object.ptr.prototype.Invoke = function(args) {
		var args, o;
		o = this;
		return o.object.apply(undefined, $externalize(args, sliceType));
	};
	Object.prototype.Invoke = function(args) { return this.$val.Invoke(args); };
	Object.ptr.prototype.New = function(args) {
		var args, o;
		o = this;
		return new ($global.Function.prototype.bind.apply(o.object, [undefined].concat($externalize(args, sliceType))));
	};
	Object.prototype.New = function(args) { return this.$val.New(args); };
	Object.ptr.prototype.Bool = function() {
		var o;
		o = this;
		return !!(o.object);
	};
	Object.prototype.Bool = function() { return this.$val.Bool(); };
	Object.ptr.prototype.String = function() {
		var o;
		o = this;
		return $internalize(o.object, $String);
	};
	Object.prototype.String = function() { return this.$val.String(); };
	Object.ptr.prototype.Int = function() {
		var o;
		o = this;
		return $parseInt(o.object) >> 0;
	};
	Object.prototype.Int = function() { return this.$val.Int(); };
	Object.ptr.prototype.Int64 = function() {
		var o;
		o = this;
		return $internalize(o.object, $Int64);
	};
	Object.prototype.Int64 = function() { return this.$val.Int64(); };
	Object.ptr.prototype.Uint64 = function() {
		var o;
		o = this;
		return $internalize(o.object, $Uint64);
	};
	Object.prototype.Uint64 = function() { return this.$val.Uint64(); };
	Object.ptr.prototype.Float = function() {
		var o;
		o = this;
		return $parseFloat(o.object);
	};
	Object.prototype.Float = function() { return this.$val.Float(); };
	Object.ptr.prototype.Interface = function() {
		var o;
		o = this;
		return $internalize(o.object, $emptyInterface);
	};
	Object.prototype.Interface = function() { return this.$val.Interface(); };
	Object.ptr.prototype.Unsafe = function() {
		var o;
		o = this;
		return o.object;
	};
	Object.prototype.Unsafe = function() { return this.$val.Unsafe(); };
	Error.ptr.prototype.Error = function() {
		var err;
		err = this;
		return "JavaScript error: " + $internalize(err.Object.message, $String);
	};
	Error.prototype.Error = function() { return this.$val.Error(); };
	Error.ptr.prototype.Stack = function() {
		var err;
		err = this;
		return $internalize(err.Object.stack, $String);
	};
	Error.prototype.Stack = function() { return this.$val.Stack(); };
	MakeFunc = function(fn) {
		var fn;
		return $makeFunc(fn);
	};
	$pkg.MakeFunc = MakeFunc;
	init = function() {
		var e;
		e = new Error.ptr(null);
		$unused(e);
	};
	ptrType.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([$String], [ptrType], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$String, $emptyInterface], [], false)}, {prop: "Delete", name: "Delete", pkg: "", typ: $funcType([$String], [], false)}, {prop: "Length", name: "Length", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Index", name: "Index", pkg: "", typ: $funcType([$Int], [ptrType], false)}, {prop: "SetIndex", name: "SetIndex", pkg: "", typ: $funcType([$Int, $emptyInterface], [], false)}, {prop: "Call", name: "Call", pkg: "", typ: $funcType([$String, sliceType], [ptrType], true)}, {prop: "Invoke", name: "Invoke", pkg: "", typ: $funcType([sliceType], [ptrType], true)}, {prop: "New", name: "New", pkg: "", typ: $funcType([sliceType], [ptrType], true)}, {prop: "Bool", name: "Bool", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Int64", name: "Int64", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "Float", name: "Float", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Interface", name: "Interface", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Unsafe", name: "Unsafe", pkg: "", typ: $funcType([], [$Uintptr], false)}];
	ptrType$1.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Stack", name: "Stack", pkg: "", typ: $funcType([], [$String], false)}];
	Object.init("github.com/gopherjs/gopherjs/js", [{prop: "object", name: "object", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	Error.init("", [{prop: "Object", name: "Object", embedded: true, exported: true, typ: ptrType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/cpu"] = (function() {
	var $pkg = {}, $init;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/bytealg"] = (function() {
	var $pkg = {}, $init, cpu, Index, Cutover, IndexByteString;
	cpu = $packages["internal/cpu"];
	Index = function(a, b) {
		var a, b;
		$panic(new $String("unimplemented"));
	};
	$pkg.Index = Index;
	Cutover = function(n) {
		var n;
		$panic(new $String("unimplemented"));
	};
	$pkg.Cutover = Cutover;
	IndexByteString = function(s, c) {
		var c, i, s;
		i = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			if (s.charCodeAt(i) === c) {
				return i;
			}
			i = i + (1) >> 0;
		}
		return -1;
	};
	$pkg.IndexByteString = IndexByteString;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = cpu.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.MaxLen = 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["runtime/internal/sys"] = (function() {
	var $pkg = {}, $init;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["runtime"] = (function() {
	var $pkg = {}, $init, js, bytealg, sys, _type, TypeAssertionError, errorString, ptrType, ptrType$4, init, GOROOT, Caller, Goexit, SetFinalizer, KeepAlive, throw$1;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	bytealg = $packages["internal/bytealg"];
	sys = $packages["runtime/internal/sys"];
	_type = $pkg._type = $newType(0, $kindStruct, "runtime._type", true, "runtime", false, function(str_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.str = "";
			return;
		}
		this.str = str_;
	});
	TypeAssertionError = $pkg.TypeAssertionError = $newType(0, $kindStruct, "runtime.TypeAssertionError", true, "runtime", true, function(_interface_, concrete_, asserted_, missingMethod_) {
		this.$val = this;
		if (arguments.length === 0) {
			this._interface = ptrType.nil;
			this.concrete = ptrType.nil;
			this.asserted = ptrType.nil;
			this.missingMethod = "";
			return;
		}
		this._interface = _interface_;
		this.concrete = concrete_;
		this.asserted = asserted_;
		this.missingMethod = missingMethod_;
	});
	errorString = $pkg.errorString = $newType(8, $kindString, "runtime.errorString", true, "runtime", false, null);
	ptrType = $ptrType(_type);
	ptrType$4 = $ptrType(TypeAssertionError);
	_type.ptr.prototype.string = function() {
		var t;
		t = this;
		return t.str;
	};
	_type.prototype.string = function() { return this.$val.string(); };
	_type.ptr.prototype.pkgpath = function() {
		var t;
		t = this;
		return "";
	};
	_type.prototype.pkgpath = function() { return this.$val.pkgpath(); };
	init = function() {
		var e, jsPkg;
		jsPkg = $packages[$externalize("github.com/gopherjs/gopherjs/js", $String)];
		$jsObjectPtr = jsPkg.Object.ptr;
		$jsErrorPtr = jsPkg.Error.ptr;
		$throwRuntimeError = throw$1;
		e = $ifaceNil;
		e = new TypeAssertionError.ptr(ptrType.nil, ptrType.nil, ptrType.nil, "");
		$unused(e);
	};
	GOROOT = function() {
		var goroot, process;
		process = $global.process;
		if (process === undefined) {
			return "/";
		}
		goroot = process.env.GOROOT;
		if (!(goroot === undefined)) {
			return $internalize(goroot, $String);
		}
		return "/usr/local/go";
	};
	$pkg.GOROOT = GOROOT;
	Caller = function(skip) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, file, info, line, ok, parts, pc, skip;
		pc = 0;
		file = "";
		line = 0;
		ok = false;
		info = new ($global.Error)().stack.split($externalize("\n", $String))[(skip + 2 >> 0)];
		if (info === undefined) {
			_tmp = 0;
			_tmp$1 = "";
			_tmp$2 = 0;
			_tmp$3 = false;
			pc = _tmp;
			file = _tmp$1;
			line = _tmp$2;
			ok = _tmp$3;
			return [pc, file, line, ok];
		}
		parts = info.substring(($parseInt(info.indexOf($externalize("(", $String))) >> 0) + 1 >> 0, $parseInt(info.indexOf($externalize(")", $String))) >> 0).split($externalize(":", $String));
		_tmp$4 = 0;
		_tmp$5 = $internalize(parts[0], $String);
		_tmp$6 = $parseInt(parts[1]) >> 0;
		_tmp$7 = true;
		pc = _tmp$4;
		file = _tmp$5;
		line = _tmp$6;
		ok = _tmp$7;
		return [pc, file, line, ok];
	};
	$pkg.Caller = Caller;
	Goexit = function() {
		$curGoroutine.exit = $externalize(true, $Bool);
		$throw(null);
	};
	$pkg.Goexit = Goexit;
	SetFinalizer = function(x, f) {
		var f, x;
	};
	$pkg.SetFinalizer = SetFinalizer;
	KeepAlive = function(param) {
		var param;
	};
	$pkg.KeepAlive = KeepAlive;
	throw$1 = function(s) {
		var s;
		$panic(new errorString((s)));
	};
	TypeAssertionError.ptr.prototype.RuntimeError = function() {
	};
	TypeAssertionError.prototype.RuntimeError = function() { return this.$val.RuntimeError(); };
	TypeAssertionError.ptr.prototype.Error = function() {
		var as, cs, e, inter, msg;
		e = this;
		inter = "interface";
		if (!(e._interface === ptrType.nil)) {
			inter = e._interface.string();
		}
		as = e.asserted.string();
		if (e.concrete === ptrType.nil) {
			return "interface conversion: " + inter + " is nil, not " + as;
		}
		cs = e.concrete.string();
		if (e.missingMethod === "") {
			msg = "interface conversion: " + inter + " is " + cs + ", not " + as;
			if (cs === as) {
				if (!(e.concrete.pkgpath() === e.asserted.pkgpath())) {
					msg = msg + (" (types from different packages)");
				} else {
					msg = msg + (" (types from different scopes)");
				}
			}
			return msg;
		}
		return "interface conversion: " + cs + " is not " + as + ": missing method " + e.missingMethod;
	};
	TypeAssertionError.prototype.Error = function() { return this.$val.Error(); };
	errorString.prototype.RuntimeError = function() {
		var e;
		e = this.$val;
	};
	$ptrType(errorString).prototype.RuntimeError = function() { return new errorString(this.$get()).RuntimeError(); };
	errorString.prototype.Error = function() {
		var e;
		e = this.$val;
		return "runtime error: " + (e);
	};
	$ptrType(errorString).prototype.Error = function() { return new errorString(this.$get()).Error(); };
	ptrType.methods = [{prop: "string", name: "string", pkg: "runtime", typ: $funcType([], [$String], false)}, {prop: "pkgpath", name: "pkgpath", pkg: "runtime", typ: $funcType([], [$String], false)}];
	ptrType$4.methods = [{prop: "RuntimeError", name: "RuntimeError", pkg: "", typ: $funcType([], [], false)}, {prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	errorString.methods = [{prop: "RuntimeError", name: "RuntimeError", pkg: "", typ: $funcType([], [], false)}, {prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	_type.init("runtime", [{prop: "str", name: "str", embedded: false, exported: false, typ: $String, tag: ""}]);
	TypeAssertionError.init("runtime", [{prop: "_interface", name: "_interface", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "concrete", name: "concrete", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "asserted", name: "asserted", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "missingMethod", name: "missingMethod", embedded: false, exported: false, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sys.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["errors"] = (function() {
	var $pkg = {}, $init, errorString, ptrType, New;
	errorString = $pkg.errorString = $newType(0, $kindStruct, "errors.errorString", true, "errors", false, function(s_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.s = "";
			return;
		}
		this.s = s_;
	});
	ptrType = $ptrType(errorString);
	New = function(text) {
		var text;
		return new errorString.ptr(text);
	};
	$pkg.New = New;
	errorString.ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.s;
	};
	errorString.prototype.Error = function() { return this.$val.Error(); };
	ptrType.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	errorString.init("errors", [{prop: "s", name: "s", embedded: false, exported: false, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/race"] = (function() {
	var $pkg = {}, $init, Acquire, Release, ReleaseMerge, Disable, Enable, ReadRange, WriteRange;
	Acquire = function(addr) {
		var addr;
	};
	$pkg.Acquire = Acquire;
	Release = function(addr) {
		var addr;
	};
	$pkg.Release = Release;
	ReleaseMerge = function(addr) {
		var addr;
	};
	$pkg.ReleaseMerge = ReleaseMerge;
	Disable = function() {
	};
	$pkg.Disable = Disable;
	Enable = function() {
	};
	$pkg.Enable = Enable;
	ReadRange = function(addr, len) {
		var addr, len;
	};
	$pkg.ReadRange = ReadRange;
	WriteRange = function(addr, len) {
		var addr, len;
	};
	$pkg.WriteRange = WriteRange;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["sync/atomic"] = (function() {
	var $pkg = {}, $init, js, Value, ptrType, CompareAndSwapInt32, CompareAndSwapUint64, AddInt32, LoadInt32, LoadUint32, LoadUint64, StoreInt32, StoreUint32;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	Value = $pkg.Value = $newType(0, $kindStruct, "atomic.Value", true, "sync/atomic", true, function(v_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.v = $ifaceNil;
			return;
		}
		this.v = v_;
	});
	ptrType = $ptrType(Value);
	CompareAndSwapInt32 = function(addr, old, new$1) {
		var addr, new$1, old;
		if (addr.$get() === old) {
			addr.$set(new$1);
			return true;
		}
		return false;
	};
	$pkg.CompareAndSwapInt32 = CompareAndSwapInt32;
	CompareAndSwapUint64 = function(addr, old, new$1) {
		var addr, new$1, old, x;
		if ((x = addr.$get(), (x.$high === old.$high && x.$low === old.$low))) {
			addr.$set(new$1);
			return true;
		}
		return false;
	};
	$pkg.CompareAndSwapUint64 = CompareAndSwapUint64;
	AddInt32 = function(addr, delta) {
		var addr, delta, new$1;
		new$1 = addr.$get() + delta >> 0;
		addr.$set(new$1);
		return new$1;
	};
	$pkg.AddInt32 = AddInt32;
	LoadInt32 = function(addr) {
		var addr;
		return addr.$get();
	};
	$pkg.LoadInt32 = LoadInt32;
	LoadUint32 = function(addr) {
		var addr;
		return addr.$get();
	};
	$pkg.LoadUint32 = LoadUint32;
	LoadUint64 = function(addr) {
		var addr;
		return addr.$get();
	};
	$pkg.LoadUint64 = LoadUint64;
	StoreInt32 = function(addr, val) {
		var addr, val;
		addr.$set(val);
	};
	$pkg.StoreInt32 = StoreInt32;
	StoreUint32 = function(addr, val) {
		var addr, val;
		addr.$set(val);
	};
	$pkg.StoreUint32 = StoreUint32;
	Value.ptr.prototype.Load = function() {
		var v, x;
		x = $ifaceNil;
		v = this;
		x = v.v;
		return x;
	};
	Value.prototype.Load = function() { return this.$val.Load(); };
	Value.ptr.prototype.Store = function(x) {
		var v, x;
		v = this;
		if ($interfaceIsEqual(x, $ifaceNil)) {
			$panic(new $String("sync/atomic: store of nil value into Value"));
		}
		if (!($interfaceIsEqual(v.v, $ifaceNil)) && !(x.constructor === v.v.constructor)) {
			$panic(new $String("sync/atomic: store of inconsistently typed value into Value"));
		}
		v.v = x;
	};
	Value.prototype.Store = function(x) { return this.$val.Store(x); };
	ptrType.methods = [{prop: "Load", name: "Load", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Store", name: "Store", pkg: "", typ: $funcType([$emptyInterface], [], false)}];
	Value.init("sync/atomic", [{prop: "v", name: "v", embedded: false, exported: false, typ: $emptyInterface, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["sync"] = (function() {
	var $pkg = {}, $init, js, race, runtime, atomic, Pool, Mutex, Locker, Once, poolLocalInternal, poolLocal, notifyList, RWMutex, rlocker, ptrType, sliceType, ptrType$1, chanType, sliceType$1, ptrType$6, ptrType$7, sliceType$4, ptrType$8, ptrType$9, funcType, ptrType$16, funcType$2, ptrType$17, arrayType$2, semWaiters, semAwoken, expunged, allPools, runtime_registerPoolCleanup, runtime_SemacquireMutex, runtime_Semrelease, runtime_notifyListCheck, runtime_canSpin, runtime_nanotime, throw$1, poolCleanup, init, indexLocal, init$1, runtime_doSpin;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	race = $packages["internal/race"];
	runtime = $packages["runtime"];
	atomic = $packages["sync/atomic"];
	Pool = $pkg.Pool = $newType(0, $kindStruct, "sync.Pool", true, "sync", true, function(local_, localSize_, store_, New_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.local = 0;
			this.localSize = 0;
			this.store = sliceType$4.nil;
			this.New = $throwNilPointerError;
			return;
		}
		this.local = local_;
		this.localSize = localSize_;
		this.store = store_;
		this.New = New_;
	});
	Mutex = $pkg.Mutex = $newType(0, $kindStruct, "sync.Mutex", true, "sync", true, function(state_, sema_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.state = 0;
			this.sema = 0;
			return;
		}
		this.state = state_;
		this.sema = sema_;
	});
	Locker = $pkg.Locker = $newType(8, $kindInterface, "sync.Locker", true, "sync", true, null);
	Once = $pkg.Once = $newType(0, $kindStruct, "sync.Once", true, "sync", true, function(m_, done_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.m = new Mutex.ptr(0, 0);
			this.done = 0;
			return;
		}
		this.m = m_;
		this.done = done_;
	});
	poolLocalInternal = $pkg.poolLocalInternal = $newType(0, $kindStruct, "sync.poolLocalInternal", true, "sync", false, function(private$0_, shared_, Mutex_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.private$0 = $ifaceNil;
			this.shared = sliceType$4.nil;
			this.Mutex = new Mutex.ptr(0, 0);
			return;
		}
		this.private$0 = private$0_;
		this.shared = shared_;
		this.Mutex = Mutex_;
	});
	poolLocal = $pkg.poolLocal = $newType(0, $kindStruct, "sync.poolLocal", true, "sync", false, function(poolLocalInternal_, pad_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.poolLocalInternal = new poolLocalInternal.ptr($ifaceNil, sliceType$4.nil, new Mutex.ptr(0, 0));
			this.pad = arrayType$2.zero();
			return;
		}
		this.poolLocalInternal = poolLocalInternal_;
		this.pad = pad_;
	});
	notifyList = $pkg.notifyList = $newType(0, $kindStruct, "sync.notifyList", true, "sync", false, function(wait_, notify_, lock_, head_, tail_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.wait = 0;
			this.notify = 0;
			this.lock = 0;
			this.head = 0;
			this.tail = 0;
			return;
		}
		this.wait = wait_;
		this.notify = notify_;
		this.lock = lock_;
		this.head = head_;
		this.tail = tail_;
	});
	RWMutex = $pkg.RWMutex = $newType(0, $kindStruct, "sync.RWMutex", true, "sync", true, function(w_, writerSem_, readerSem_, readerCount_, readerWait_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.w = new Mutex.ptr(0, 0);
			this.writerSem = 0;
			this.readerSem = 0;
			this.readerCount = 0;
			this.readerWait = 0;
			return;
		}
		this.w = w_;
		this.writerSem = writerSem_;
		this.readerSem = readerSem_;
		this.readerCount = readerCount_;
		this.readerWait = readerWait_;
	});
	rlocker = $pkg.rlocker = $newType(0, $kindStruct, "sync.rlocker", true, "sync", false, function(w_, writerSem_, readerSem_, readerCount_, readerWait_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.w = new Mutex.ptr(0, 0);
			this.writerSem = 0;
			this.readerSem = 0;
			this.readerCount = 0;
			this.readerWait = 0;
			return;
		}
		this.w = w_;
		this.writerSem = writerSem_;
		this.readerSem = readerSem_;
		this.readerCount = readerCount_;
		this.readerWait = readerWait_;
	});
	ptrType = $ptrType(Pool);
	sliceType = $sliceType(ptrType);
	ptrType$1 = $ptrType($Uint32);
	chanType = $chanType($Bool, false, false);
	sliceType$1 = $sliceType(chanType);
	ptrType$6 = $ptrType($Int32);
	ptrType$7 = $ptrType(poolLocal);
	sliceType$4 = $sliceType($emptyInterface);
	ptrType$8 = $ptrType(rlocker);
	ptrType$9 = $ptrType(RWMutex);
	funcType = $funcType([], [$emptyInterface], false);
	ptrType$16 = $ptrType(Mutex);
	funcType$2 = $funcType([], [], false);
	ptrType$17 = $ptrType(Once);
	arrayType$2 = $arrayType($Uint8, 100);
	Pool.ptr.prototype.Get = function() {
		var _r, p, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (p.store.$length === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (p.store.$length === 0) { */ case 1:
			/* */ if (!(p.New === $throwNilPointerError)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(p.New === $throwNilPointerError)) { */ case 3:
				_r = p.New(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } */ case 4:
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		x$2 = (x = p.store, x$1 = p.store.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		p.store = $subslice(p.store, 0, (p.store.$length - 1 >> 0));
		$s = -1; return x$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Pool.ptr.prototype.Get }; } $f._r = _r; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Pool.prototype.Get = function() { return this.$val.Get(); };
	Pool.ptr.prototype.Put = function(x) {
		var p, x;
		p = this;
		if ($interfaceIsEqual(x, $ifaceNil)) {
			return;
		}
		p.store = $append(p.store, x);
	};
	Pool.prototype.Put = function(x) { return this.$val.Put(x); };
	runtime_registerPoolCleanup = function(cleanup) {
		var cleanup;
	};
	runtime_SemacquireMutex = function(s, lifo) {
		var _entry, _entry$1, _entry$2, _entry$3, _entry$4, _key, _key$1, _key$2, _r, ch, lifo, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _entry$4 = $f._entry$4; _key = $f._key; _key$1 = $f._key$1; _key$2 = $f._key$2; _r = $f._r; ch = $f.ch; lifo = $f.lifo; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if (((s.$get() - (_entry = semAwoken[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : 0) >>> 0)) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (((s.$get() - (_entry = semAwoken[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : 0) >>> 0)) === 0) { */ case 1:
			ch = new $Chan($Bool, 0);
			if (lifo) {
				_key = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: $appendSlice(new sliceType$1([ch]), (_entry$1 = semWaiters[ptrType$1.keyFor(s)], _entry$1 !== undefined ? _entry$1.v : sliceType$1.nil)) };
			} else {
				_key$1 = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key$1)] = { k: _key$1, v: $append((_entry$2 = semWaiters[ptrType$1.keyFor(s)], _entry$2 !== undefined ? _entry$2.v : sliceType$1.nil), ch) };
			}
			_r = $recv(ch); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r[0];
			_key$2 = s; (semAwoken || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key$2)] = { k: _key$2, v: (_entry$3 = semAwoken[ptrType$1.keyFor(s)], _entry$3 !== undefined ? _entry$3.v : 0) - (1) >>> 0 };
			if ((_entry$4 = semAwoken[ptrType$1.keyFor(s)], _entry$4 !== undefined ? _entry$4.v : 0) === 0) {
				delete semAwoken[ptrType$1.keyFor(s)];
			}
		/* } */ case 2:
		s.$set(s.$get() - (1) >>> 0);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_SemacquireMutex }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._entry$4 = _entry$4; $f._key = _key; $f._key$1 = _key$1; $f._key$2 = _key$2; $f._r = _r; $f.ch = ch; $f.lifo = lifo; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	runtime_Semrelease = function(s, handoff) {
		var _entry, _entry$1, _key, _key$1, ch, handoff, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _key = $f._key; _key$1 = $f._key$1; ch = $f.ch; handoff = $f.handoff; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s.$set(s.$get() + (1) >>> 0);
		w = (_entry = semWaiters[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : sliceType$1.nil);
		if (w.$length === 0) {
			$s = -1; return;
		}
		ch = (0 >= w.$length ? ($throwRuntimeError("index out of range"), undefined) : w.$array[w.$offset + 0]);
		w = $subslice(w, 1);
		_key = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: w };
		if (w.$length === 0) {
			delete semWaiters[ptrType$1.keyFor(s)];
		}
		_key$1 = s; (semAwoken || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key$1)] = { k: _key$1, v: (_entry$1 = semAwoken[ptrType$1.keyFor(s)], _entry$1 !== undefined ? _entry$1.v : 0) + (1) >>> 0 };
		$r = $send(ch, true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_Semrelease }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._key = _key; $f._key$1 = _key$1; $f.ch = ch; $f.handoff = handoff; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	runtime_notifyListCheck = function(size) {
		var size;
	};
	runtime_canSpin = function(i) {
		var i;
		return false;
	};
	runtime_nanotime = function() {
		return $mul64($internalize(new ($global.Date)().getTime(), $Int64), new $Int64(0, 1000000));
	};
	throw$1 = function(s) {
		var s;
		$throwRuntimeError($externalize(s, $String));
	};
	Mutex.ptr.prototype.Lock = function() {
		var awoke, delta, iter, m, new$1, old, queueLifo, starving, waitStartTime, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; awoke = $f.awoke; delta = $f.delta; iter = $f.iter; m = $f.m; new$1 = $f.new$1; old = $f.old; queueLifo = $f.queueLifo; starving = $f.starving; waitStartTime = $f.waitStartTime; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), 0, 1)) {
			if (false) {
				race.Acquire((m));
			}
			$s = -1; return;
		}
		waitStartTime = new $Int64(0, 0);
		starving = false;
		awoke = false;
		iter = 0;
		old = m.state;
		/* while (true) { */ case 1:
			/* */ if (((old & 5) === 1) && runtime_canSpin(iter)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (((old & 5) === 1) && runtime_canSpin(iter)) { */ case 3:
				if (!awoke && ((old & 2) === 0) && !(((old >> 3 >> 0) === 0)) && atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, old | 2)) {
					awoke = true;
				}
				runtime_doSpin();
				iter = iter + (1) >> 0;
				old = m.state;
				/* continue; */ $s = 1; continue;
			/* } */ case 4:
			new$1 = old;
			if ((old & 4) === 0) {
				new$1 = new$1 | (1);
			}
			if (!(((old & 5) === 0))) {
				new$1 = new$1 + (8) >> 0;
			}
			if (starving && !(((old & 1) === 0))) {
				new$1 = new$1 | (4);
			}
			if (awoke) {
				if ((new$1 & 2) === 0) {
					throw$1("sync: inconsistent mutex state");
				}
				new$1 = (new$1 & ~(2)) >> 0;
			}
			/* */ if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 5:
				if ((old & 5) === 0) {
					/* break; */ $s = 2; continue;
				}
				queueLifo = !((waitStartTime.$high === 0 && waitStartTime.$low === 0));
				if ((waitStartTime.$high === 0 && waitStartTime.$low === 0)) {
					waitStartTime = runtime_nanotime();
				}
				$r = runtime_SemacquireMutex((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), queueLifo); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				starving = starving || (x = (x$1 = runtime_nanotime(), new $Int64(x$1.$high - waitStartTime.$high, x$1.$low - waitStartTime.$low)), (x.$high > 0 || (x.$high === 0 && x.$low > 1000000)));
				old = m.state;
				if (!(((old & 4) === 0))) {
					if (!(((old & 3) === 0)) || ((old >> 3 >> 0) === 0)) {
						throw$1("sync: inconsistent mutex state");
					}
					delta = -7;
					if (!starving || ((old >> 3 >> 0) === 1)) {
						delta = delta - (4) >> 0;
					}
					atomic.AddInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), delta);
					/* break; */ $s = 2; continue;
				}
				awoke = true;
				iter = 0;
				$s = 7; continue;
			/* } else { */ case 6:
				old = m.state;
			/* } */ case 7:
		/* } */ $s = 1; continue; case 2:
		if (false) {
			race.Acquire((m));
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Mutex.ptr.prototype.Lock }; } $f.awoke = awoke; $f.delta = delta; $f.iter = iter; $f.m = m; $f.new$1 = new$1; $f.old = old; $f.queueLifo = queueLifo; $f.starving = starving; $f.waitStartTime = waitStartTime; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Mutex.prototype.Lock = function() { return this.$val.Lock(); };
	Mutex.ptr.prototype.Unlock = function() {
		var m, new$1, old, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; m = $f.m; new$1 = $f.new$1; old = $f.old; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		if (false) {
			$unused(m.state);
			race.Release((m));
		}
		new$1 = atomic.AddInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), -1);
		if ((((new$1 + 1 >> 0)) & 1) === 0) {
			throw$1("sync: unlock of unlocked mutex");
		}
		/* */ if ((new$1 & 4) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((new$1 & 4) === 0) { */ case 1:
			old = new$1;
			/* while (true) { */ case 4:
				if (((old >> 3 >> 0) === 0) || !(((old & 7) === 0))) {
					$s = -1; return;
				}
				new$1 = ((old - 8 >> 0)) | 2;
				/* */ if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 6:
					$r = runtime_Semrelease((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), false); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					$s = -1; return;
				/* } */ case 7:
				old = m.state;
			/* } */ $s = 4; continue; case 5:
			$s = 3; continue;
		/* } else { */ case 2:
			$r = runtime_Semrelease((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), true); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Mutex.ptr.prototype.Unlock }; } $f.m = m; $f.new$1 = new$1; $f.old = old; $f.$s = $s; $f.$r = $r; return $f;
	};
	Mutex.prototype.Unlock = function() { return this.$val.Unlock(); };
	Once.ptr.prototype.Do = function(f) {
		var f, o, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; f = $f.f; o = $f.o; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		o = this;
		if (atomic.LoadUint32((o.$ptr_done || (o.$ptr_done = new ptrType$1(function() { return this.$target.done; }, function($v) { this.$target.done = $v; }, o)))) === 1) {
			$s = -1; return;
		}
		$r = o.m.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(o.m, "Unlock"), []]);
		/* */ if (o.done === 0) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (o.done === 0) { */ case 2:
			$deferred.push([atomic.StoreUint32, [(o.$ptr_done || (o.$ptr_done = new ptrType$1(function() { return this.$target.done; }, function($v) { this.$target.done = $v; }, o))), 1]]);
			$r = f(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Once.ptr.prototype.Do }; } $f.f = f; $f.o = o; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Once.prototype.Do = function(f) { return this.$val.Do(f); };
	poolCleanup = function() {
		var _i, _i$1, _ref, _ref$1, i, i$1, j, l, p, x;
		_ref = allPools;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			p = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			((i < 0 || i >= allPools.$length) ? ($throwRuntimeError("index out of range"), undefined) : allPools.$array[allPools.$offset + i] = ptrType.nil);
			i$1 = 0;
			while (true) {
				if (!(i$1 < ((p.localSize >> 0)))) { break; }
				l = indexLocal(p.local, i$1);
				l.poolLocalInternal.private$0 = $ifaceNil;
				_ref$1 = l.poolLocalInternal.shared;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					j = _i$1;
					(x = l.poolLocalInternal.shared, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j] = $ifaceNil));
					_i$1++;
				}
				l.poolLocalInternal.shared = sliceType$4.nil;
				i$1 = i$1 + (1) >> 0;
			}
			p.local = 0;
			p.localSize = 0;
			_i++;
		}
		allPools = new sliceType([]);
	};
	init = function() {
		runtime_registerPoolCleanup(poolCleanup);
	};
	indexLocal = function(l, i) {
		var i, l, lp;
		lp = (((l) + ($imul(((i >>> 0)), 128) >>> 0) >>> 0));
		return ($pointerOfStructConversion(lp, ptrType$7));
	};
	init$1 = function() {
		var n;
		n = new notifyList.ptr(0, 0, 0, 0, 0);
		runtime_notifyListCheck(20);
	};
	runtime_doSpin = function() {
		$throwRuntimeError("native function not implemented: sync.runtime_doSpin");
	};
	RWMutex.ptr.prototype.RLock = function() {
		var rw, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; rw = $f.rw; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		rw = this;
		if (false) {
			$unused(rw.w.state);
			race.Disable();
		}
		/* */ if (atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$6(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), 1) < 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$6(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), 1) < 0) { */ case 1:
			$r = runtime_SemacquireMutex((rw.$ptr_readerSem || (rw.$ptr_readerSem = new ptrType$1(function() { return this.$target.readerSem; }, function($v) { this.$target.readerSem = $v; }, rw))), false); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		if (false) {
			race.Enable();
			race.Acquire(((rw.$ptr_readerSem || (rw.$ptr_readerSem = new ptrType$1(function() { return this.$target.readerSem; }, function($v) { this.$target.readerSem = $v; }, rw)))));
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: RWMutex.ptr.prototype.RLock }; } $f.rw = rw; $f.$s = $s; $f.$r = $r; return $f;
	};
	RWMutex.prototype.RLock = function() { return this.$val.RLock(); };
	RWMutex.ptr.prototype.RUnlock = function() {
		var r, rw, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; r = $f.r; rw = $f.rw; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		rw = this;
		if (false) {
			$unused(rw.w.state);
			race.ReleaseMerge(((rw.$ptr_writerSem || (rw.$ptr_writerSem = new ptrType$1(function() { return this.$target.writerSem; }, function($v) { this.$target.writerSem = $v; }, rw)))));
			race.Disable();
		}
		r = atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$6(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), -1);
		/* */ if (r < 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r < 0) { */ case 1:
			if (((r + 1 >> 0) === 0) || ((r + 1 >> 0) === -1073741824)) {
				race.Enable();
				throw$1("sync: RUnlock of unlocked RWMutex");
			}
			/* */ if (atomic.AddInt32((rw.$ptr_readerWait || (rw.$ptr_readerWait = new ptrType$6(function() { return this.$target.readerWait; }, function($v) { this.$target.readerWait = $v; }, rw))), -1) === 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (atomic.AddInt32((rw.$ptr_readerWait || (rw.$ptr_readerWait = new ptrType$6(function() { return this.$target.readerWait; }, function($v) { this.$target.readerWait = $v; }, rw))), -1) === 0) { */ case 3:
				$r = runtime_Semrelease((rw.$ptr_writerSem || (rw.$ptr_writerSem = new ptrType$1(function() { return this.$target.writerSem; }, function($v) { this.$target.writerSem = $v; }, rw))), false); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 4:
		/* } */ case 2:
		if (false) {
			race.Enable();
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: RWMutex.ptr.prototype.RUnlock }; } $f.r = r; $f.rw = rw; $f.$s = $s; $f.$r = $r; return $f;
	};
	RWMutex.prototype.RUnlock = function() { return this.$val.RUnlock(); };
	RWMutex.ptr.prototype.Lock = function() {
		var r, rw, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; r = $f.r; rw = $f.rw; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		rw = this;
		if (false) {
			$unused(rw.w.state);
			race.Disable();
		}
		$r = rw.w.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		r = atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$6(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), -1073741824) + 1073741824 >> 0;
		/* */ if (!((r === 0)) && !((atomic.AddInt32((rw.$ptr_readerWait || (rw.$ptr_readerWait = new ptrType$6(function() { return this.$target.readerWait; }, function($v) { this.$target.readerWait = $v; }, rw))), r) === 0))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((r === 0)) && !((atomic.AddInt32((rw.$ptr_readerWait || (rw.$ptr_readerWait = new ptrType$6(function() { return this.$target.readerWait; }, function($v) { this.$target.readerWait = $v; }, rw))), r) === 0))) { */ case 2:
			$r = runtime_SemacquireMutex((rw.$ptr_writerSem || (rw.$ptr_writerSem = new ptrType$1(function() { return this.$target.writerSem; }, function($v) { this.$target.writerSem = $v; }, rw))), false); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		if (false) {
			race.Enable();
			race.Acquire(((rw.$ptr_readerSem || (rw.$ptr_readerSem = new ptrType$1(function() { return this.$target.readerSem; }, function($v) { this.$target.readerSem = $v; }, rw)))));
			race.Acquire(((rw.$ptr_writerSem || (rw.$ptr_writerSem = new ptrType$1(function() { return this.$target.writerSem; }, function($v) { this.$target.writerSem = $v; }, rw)))));
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: RWMutex.ptr.prototype.Lock }; } $f.r = r; $f.rw = rw; $f.$s = $s; $f.$r = $r; return $f;
	};
	RWMutex.prototype.Lock = function() { return this.$val.Lock(); };
	RWMutex.ptr.prototype.Unlock = function() {
		var i, r, rw, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; r = $f.r; rw = $f.rw; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		rw = this;
		if (false) {
			$unused(rw.w.state);
			race.Release(((rw.$ptr_readerSem || (rw.$ptr_readerSem = new ptrType$1(function() { return this.$target.readerSem; }, function($v) { this.$target.readerSem = $v; }, rw)))));
			race.Disable();
		}
		r = atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$6(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), 1073741824);
		if (r >= 1073741824) {
			race.Enable();
			throw$1("sync: Unlock of unlocked RWMutex");
		}
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < ((r >> 0)))) { break; } */ if(!(i < ((r >> 0)))) { $s = 2; continue; }
			$r = runtime_Semrelease((rw.$ptr_readerSem || (rw.$ptr_readerSem = new ptrType$1(function() { return this.$target.readerSem; }, function($v) { this.$target.readerSem = $v; }, rw))), false); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$r = rw.w.Unlock(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (false) {
			race.Enable();
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: RWMutex.ptr.prototype.Unlock }; } $f.i = i; $f.r = r; $f.rw = rw; $f.$s = $s; $f.$r = $r; return $f;
	};
	RWMutex.prototype.Unlock = function() { return this.$val.Unlock(); };
	RWMutex.ptr.prototype.RLocker = function() {
		var rw;
		rw = this;
		return ($pointerOfStructConversion(rw, ptrType$8));
	};
	RWMutex.prototype.RLocker = function() { return this.$val.RLocker(); };
	rlocker.ptr.prototype.Lock = function() {
		var r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		$r = ($pointerOfStructConversion(r, ptrType$9)).RLock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rlocker.ptr.prototype.Lock }; } $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	rlocker.prototype.Lock = function() { return this.$val.Lock(); };
	rlocker.ptr.prototype.Unlock = function() {
		var r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		$r = ($pointerOfStructConversion(r, ptrType$9)).RUnlock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rlocker.ptr.prototype.Unlock }; } $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	rlocker.prototype.Unlock = function() { return this.$val.Unlock(); };
	ptrType.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Put", name: "Put", pkg: "", typ: $funcType([$emptyInterface], [], false)}, {prop: "getSlow", name: "getSlow", pkg: "sync", typ: $funcType([], [$emptyInterface], false)}, {prop: "pin", name: "pin", pkg: "sync", typ: $funcType([], [ptrType$7], false)}, {prop: "pinSlow", name: "pinSlow", pkg: "sync", typ: $funcType([], [ptrType$7], false)}];
	ptrType$16.methods = [{prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false)}, {prop: "Unlock", name: "Unlock", pkg: "", typ: $funcType([], [], false)}];
	ptrType$17.methods = [{prop: "Do", name: "Do", pkg: "", typ: $funcType([funcType$2], [], false)}];
	ptrType$9.methods = [{prop: "RLock", name: "RLock", pkg: "", typ: $funcType([], [], false)}, {prop: "RUnlock", name: "RUnlock", pkg: "", typ: $funcType([], [], false)}, {prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false)}, {prop: "Unlock", name: "Unlock", pkg: "", typ: $funcType([], [], false)}, {prop: "RLocker", name: "RLocker", pkg: "", typ: $funcType([], [Locker], false)}];
	ptrType$8.methods = [{prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false)}, {prop: "Unlock", name: "Unlock", pkg: "", typ: $funcType([], [], false)}];
	Pool.init("sync", [{prop: "local", name: "local", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}, {prop: "localSize", name: "localSize", embedded: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "store", name: "store", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "New", name: "New", embedded: false, exported: true, typ: funcType, tag: ""}]);
	Mutex.init("sync", [{prop: "state", name: "state", embedded: false, exported: false, typ: $Int32, tag: ""}, {prop: "sema", name: "sema", embedded: false, exported: false, typ: $Uint32, tag: ""}]);
	Locker.init([{prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false)}, {prop: "Unlock", name: "Unlock", pkg: "", typ: $funcType([], [], false)}]);
	Once.init("sync", [{prop: "m", name: "m", embedded: false, exported: false, typ: Mutex, tag: ""}, {prop: "done", name: "done", embedded: false, exported: false, typ: $Uint32, tag: ""}]);
	poolLocalInternal.init("sync", [{prop: "private$0", name: "private", embedded: false, exported: false, typ: $emptyInterface, tag: ""}, {prop: "shared", name: "shared", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "Mutex", name: "Mutex", embedded: true, exported: true, typ: Mutex, tag: ""}]);
	poolLocal.init("sync", [{prop: "poolLocalInternal", name: "poolLocalInternal", embedded: true, exported: false, typ: poolLocalInternal, tag: ""}, {prop: "pad", name: "pad", embedded: false, exported: false, typ: arrayType$2, tag: ""}]);
	notifyList.init("sync", [{prop: "wait", name: "wait", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "notify", name: "notify", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "lock", name: "lock", embedded: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "head", name: "head", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}, {prop: "tail", name: "tail", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}]);
	RWMutex.init("sync", [{prop: "w", name: "w", embedded: false, exported: false, typ: Mutex, tag: ""}, {prop: "writerSem", name: "writerSem", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "readerSem", name: "readerSem", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "readerCount", name: "readerCount", embedded: false, exported: false, typ: $Int32, tag: ""}, {prop: "readerWait", name: "readerWait", embedded: false, exported: false, typ: $Int32, tag: ""}]);
	rlocker.init("sync", [{prop: "w", name: "w", embedded: false, exported: false, typ: Mutex, tag: ""}, {prop: "writerSem", name: "writerSem", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "readerSem", name: "readerSem", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "readerCount", name: "readerCount", embedded: false, exported: false, typ: $Int32, tag: ""}, {prop: "readerWait", name: "readerWait", embedded: false, exported: false, typ: $Int32, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = race.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		allPools = sliceType.nil;
		semWaiters = {};
		semAwoken = {};
		expunged = (new Uint8Array(8));
		init();
		init$1();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["io"] = (function() {
	var $pkg = {}, $init, errors, sync, atomic, Reader, Writer, ReadCloser, ReaderFrom, WriterTo, RuneReader, RuneScanner, sliceType, errWhence, errOffset, ReadAtLeast, ReadFull;
	errors = $packages["errors"];
	sync = $packages["sync"];
	atomic = $packages["sync/atomic"];
	Reader = $pkg.Reader = $newType(8, $kindInterface, "io.Reader", true, "io", true, null);
	Writer = $pkg.Writer = $newType(8, $kindInterface, "io.Writer", true, "io", true, null);
	ReadCloser = $pkg.ReadCloser = $newType(8, $kindInterface, "io.ReadCloser", true, "io", true, null);
	ReaderFrom = $pkg.ReaderFrom = $newType(8, $kindInterface, "io.ReaderFrom", true, "io", true, null);
	WriterTo = $pkg.WriterTo = $newType(8, $kindInterface, "io.WriterTo", true, "io", true, null);
	RuneReader = $pkg.RuneReader = $newType(8, $kindInterface, "io.RuneReader", true, "io", true, null);
	RuneScanner = $pkg.RuneScanner = $newType(8, $kindInterface, "io.RuneScanner", true, "io", true, null);
	sliceType = $sliceType($Uint8);
	ReadAtLeast = function(r, buf, min) {
		var _r, _tmp, _tmp$1, _tuple, buf, err, min, n, nn, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; buf = $f.buf; err = $f.err; min = $f.min; n = $f.n; nn = $f.nn; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		if (buf.$length < min) {
			_tmp = 0;
			_tmp$1 = $pkg.ErrShortBuffer;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		/* while (true) { */ case 1:
			/* if (!(n < min && $interfaceIsEqual(err, $ifaceNil))) { break; } */ if(!(n < min && $interfaceIsEqual(err, $ifaceNil))) { $s = 2; continue; }
			nn = 0;
			_r = r.Read($subslice(buf, n)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			nn = _tuple[0];
			err = _tuple[1];
			n = n + (nn) >> 0;
		/* } */ $s = 1; continue; case 2:
		if (n >= min) {
			err = $ifaceNil;
		} else if (n > 0 && $interfaceIsEqual(err, $pkg.EOF)) {
			err = $pkg.ErrUnexpectedEOF;
		}
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: ReadAtLeast }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.buf = buf; $f.err = err; $f.min = min; $f.n = n; $f.nn = nn; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ReadAtLeast = ReadAtLeast;
	ReadFull = function(r, buf) {
		var _r, _tuple, buf, err, n, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; buf = $f.buf; err = $f.err; n = $f.n; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_r = ReadAtLeast(r, buf, buf.$length); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: ReadFull }; } $f._r = _r; $f._tuple = _tuple; $f.buf = buf; $f.err = err; $f.n = n; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ReadFull = ReadFull;
	Reader.init([{prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}]);
	Writer.init([{prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}]);
	ReadCloser.init([{prop: "Close", name: "Close", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}]);
	ReaderFrom.init([{prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([Reader], [$Int64, $error], false)}]);
	WriterTo.init([{prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([Writer], [$Int64, $error], false)}]);
	RuneReader.init([{prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}]);
	RuneScanner.init([{prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrShortWrite = errors.New("short write");
		$pkg.ErrShortBuffer = errors.New("short buffer");
		$pkg.EOF = errors.New("EOF");
		$pkg.ErrUnexpectedEOF = errors.New("unexpected EOF");
		$pkg.ErrNoProgress = errors.New("multiple Read calls return no data or error");
		errWhence = errors.New("Seek: invalid whence");
		errOffset = errors.New("Seek: invalid offset");
		$pkg.ErrClosedPipe = errors.New("io: read/write on closed pipe");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["unicode"] = (function() {
	var $pkg = {}, $init, RangeTable, Range16, Range32, CaseRange, d, foldPair, arrayType, sliceType, sliceType$1, ptrType, sliceType$2, sliceType$3, sliceType$4, _C, _Cc, _Cf, _Co, _Cs, _L, _Ll, _Lm, _Lo, _Lt, _Lu, _M, _Mc, _Me, _Mn, _N, _Nd, _Nl, _No, _P, _Pc, _Pd, _Pe, _Pf, _Pi, _Po, _Ps, _S, _Sc, _Sk, _Sm, _So, _Z, _Zl, _Zp, _Zs, _Adlam, _Ahom, _Anatolian_Hieroglyphs, _Arabic, _Armenian, _Avestan, _Balinese, _Bamum, _Bassa_Vah, _Batak, _Bengali, _Bhaiksuki, _Bopomofo, _Brahmi, _Braille, _Buginese, _Buhid, _Canadian_Aboriginal, _Carian, _Caucasian_Albanian, _Chakma, _Cham, _Cherokee, _Common, _Coptic, _Cuneiform, _Cypriot, _Cyrillic, _Deseret, _Devanagari, _Duployan, _Egyptian_Hieroglyphs, _Elbasan, _Ethiopic, _Georgian, _Glagolitic, _Gothic, _Grantha, _Greek, _Gujarati, _Gurmukhi, _Han, _Hangul, _Hanunoo, _Hatran, _Hebrew, _Hiragana, _Imperial_Aramaic, _Inherited, _Inscriptional_Pahlavi, _Inscriptional_Parthian, _Javanese, _Kaithi, _Kannada, _Katakana, _Kayah_Li, _Kharoshthi, _Khmer, _Khojki, _Khudawadi, _Lao, _Latin, _Lepcha, _Limbu, _Linear_A, _Linear_B, _Lisu, _Lycian, _Lydian, _Mahajani, _Malayalam, _Mandaic, _Manichaean, _Marchen, _Masaram_Gondi, _Meetei_Mayek, _Mende_Kikakui, _Meroitic_Cursive, _Meroitic_Hieroglyphs, _Miao, _Modi, _Mongolian, _Mro, _Multani, _Myanmar, _Nabataean, _New_Tai_Lue, _Newa, _Nko, _Nushu, _Ogham, _Ol_Chiki, _Old_Hungarian, _Old_Italic, _Old_North_Arabian, _Old_Permic, _Old_Persian, _Old_South_Arabian, _Old_Turkic, _Oriya, _Osage, _Osmanya, _Pahawh_Hmong, _Palmyrene, _Pau_Cin_Hau, _Phags_Pa, _Phoenician, _Psalter_Pahlavi, _Rejang, _Runic, _Samaritan, _Saurashtra, _Sharada, _Shavian, _Siddham, _SignWriting, _Sinhala, _Sora_Sompeng, _Soyombo, _Sundanese, _Syloti_Nagri, _Syriac, _Tagalog, _Tagbanwa, _Tai_Le, _Tai_Tham, _Tai_Viet, _Takri, _Tamil, _Tangut, _Telugu, _Thaana, _Thai, _Tibetan, _Tifinagh, _Tirhuta, _Ugaritic, _Vai, _Warang_Citi, _Yi, _Zanabazar_Square, _CaseRanges, properties, asciiFold, caseOrbit, foldL, foldLl, foldLt, foldLu, foldM, foldMn, foldCommon, foldGreek, foldInherited, to, IsDigit, IsPrint, In, IsLetter, is16, is32, Is, isExcludingLatin, To, ToUpper, ToLower, SimpleFold;
	RangeTable = $pkg.RangeTable = $newType(0, $kindStruct, "unicode.RangeTable", true, "unicode", true, function(R16_, R32_, LatinOffset_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.R16 = sliceType.nil;
			this.R32 = sliceType$1.nil;
			this.LatinOffset = 0;
			return;
		}
		this.R16 = R16_;
		this.R32 = R32_;
		this.LatinOffset = LatinOffset_;
	});
	Range16 = $pkg.Range16 = $newType(0, $kindStruct, "unicode.Range16", true, "unicode", true, function(Lo_, Hi_, Stride_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Stride = 0;
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Stride = Stride_;
	});
	Range32 = $pkg.Range32 = $newType(0, $kindStruct, "unicode.Range32", true, "unicode", true, function(Lo_, Hi_, Stride_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Stride = 0;
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Stride = Stride_;
	});
	CaseRange = $pkg.CaseRange = $newType(0, $kindStruct, "unicode.CaseRange", true, "unicode", true, function(Lo_, Hi_, Delta_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Delta = arrayType.zero();
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Delta = Delta_;
	});
	d = $pkg.d = $newType(12, $kindArray, "unicode.d", true, "unicode", false, null);
	foldPair = $pkg.foldPair = $newType(0, $kindStruct, "unicode.foldPair", true, "unicode", false, function(From_, To_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.From = 0;
			this.To = 0;
			return;
		}
		this.From = From_;
		this.To = To_;
	});
	arrayType = $arrayType($Int32, 3);
	sliceType = $sliceType(Range16);
	sliceType$1 = $sliceType(Range32);
	ptrType = $ptrType(RangeTable);
	sliceType$2 = $sliceType(ptrType);
	sliceType$3 = $sliceType(CaseRange);
	sliceType$4 = $sliceType(foldPair);
	to = function(_case, r, caseRange) {
		var _case, _q, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, caseRange, cr, delta, foundMapping, hi, lo, m, mappedRune, r, x;
		mappedRune = 0;
		foundMapping = false;
		if (_case < 0 || 3 <= _case) {
			_tmp = 65533;
			_tmp$1 = false;
			mappedRune = _tmp;
			foundMapping = _tmp$1;
			return [mappedRune, foundMapping];
		}
		lo = 0;
		hi = caseRange.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			cr = ((m < 0 || m >= caseRange.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseRange.$array[caseRange.$offset + m]);
			if (((cr.Lo >> 0)) <= r && r <= ((cr.Hi >> 0))) {
				delta = ((x = cr.Delta, ((_case < 0 || _case >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[_case])));
				if (delta > 1114111) {
					_tmp$2 = ((cr.Lo >> 0)) + ((((((r - ((cr.Lo >> 0)) >> 0)) & ~1) >> 0) | (((_case & 1) >> 0)))) >> 0;
					_tmp$3 = true;
					mappedRune = _tmp$2;
					foundMapping = _tmp$3;
					return [mappedRune, foundMapping];
				}
				_tmp$4 = r + delta >> 0;
				_tmp$5 = true;
				mappedRune = _tmp$4;
				foundMapping = _tmp$5;
				return [mappedRune, foundMapping];
			}
			if (r < ((cr.Lo >> 0))) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		_tmp$6 = r;
		_tmp$7 = false;
		mappedRune = _tmp$6;
		foundMapping = _tmp$7;
		return [mappedRune, foundMapping];
	};
	IsDigit = function(r) {
		var r;
		if (r <= 255) {
			return 48 <= r && r <= 57;
		}
		return isExcludingLatin($pkg.Digit, r);
	};
	$pkg.IsDigit = IsDigit;
	IsPrint = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 128) >>> 0) === 0));
		}
		return In(r, $pkg.PrintRanges);
	};
	$pkg.IsPrint = IsPrint;
	In = function(r, ranges) {
		var _i, _ref, inside, r, ranges;
		_ref = ranges;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			inside = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (Is(inside, r)) {
				return true;
			}
			_i++;
		}
		return false;
	};
	$pkg.In = In;
	IsLetter = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 96) >>> 0) === 0));
		}
		return isExcludingLatin($pkg.Letter, r);
	};
	$pkg.IsLetter = IsLetter;
	is16 = function(ranges, r) {
		var _i, _q, _r, _r$1, _ref, hi, i, lo, m, r, range_, range_$1, ranges;
		if (ranges.$length <= 18 || r <= 255) {
			_ref = ranges;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				range_ = ((i < 0 || i >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + i]);
				if (r < range_.Lo) {
					return false;
				}
				if (r <= range_.Hi) {
					return (range_.Stride === 1) || ((_r = ((r - range_.Lo << 16 >>> 16)) % range_.Stride, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0);
				}
				_i++;
			}
			return false;
		}
		lo = 0;
		hi = ranges.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			range_$1 = ((m < 0 || m >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + m]);
			if (range_$1.Lo <= r && r <= range_$1.Hi) {
				return (range_$1.Stride === 1) || ((_r$1 = ((r - range_$1.Lo << 16 >>> 16)) % range_$1.Stride, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0);
			}
			if (r < range_$1.Lo) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return false;
	};
	is32 = function(ranges, r) {
		var _i, _q, _r, _r$1, _ref, hi, i, lo, m, r, range_, range_$1, ranges;
		if (ranges.$length <= 18) {
			_ref = ranges;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				range_ = ((i < 0 || i >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + i]);
				if (r < range_.Lo) {
					return false;
				}
				if (r <= range_.Hi) {
					return (range_.Stride === 1) || ((_r = ((r - range_.Lo >>> 0)) % range_.Stride, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0);
				}
				_i++;
			}
			return false;
		}
		lo = 0;
		hi = ranges.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			range_$1 = $clone(((m < 0 || m >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + m]), Range32);
			if (range_$1.Lo <= r && r <= range_$1.Hi) {
				return (range_$1.Stride === 1) || ((_r$1 = ((r - range_$1.Lo >>> 0)) % range_$1.Stride, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0);
			}
			if (r < range_$1.Lo) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return false;
	};
	Is = function(rangeTab, r) {
		var r, r16, r32, rangeTab, x;
		r16 = rangeTab.R16;
		if (r16.$length > 0 && r <= (((x = r16.$length - 1 >> 0, ((x < 0 || x >= r16.$length) ? ($throwRuntimeError("index out of range"), undefined) : r16.$array[r16.$offset + x])).Hi >> 0))) {
			return is16(r16, ((r << 16 >>> 16)));
		}
		r32 = rangeTab.R32;
		if (r32.$length > 0 && r >= (((0 >= r32.$length ? ($throwRuntimeError("index out of range"), undefined) : r32.$array[r32.$offset + 0]).Lo >> 0))) {
			return is32(r32, ((r >>> 0)));
		}
		return false;
	};
	$pkg.Is = Is;
	isExcludingLatin = function(rangeTab, r) {
		var off, r, r16, r32, rangeTab, x;
		r16 = rangeTab.R16;
		off = rangeTab.LatinOffset;
		if (r16.$length > off && r <= (((x = r16.$length - 1 >> 0, ((x < 0 || x >= r16.$length) ? ($throwRuntimeError("index out of range"), undefined) : r16.$array[r16.$offset + x])).Hi >> 0))) {
			return is16($subslice(r16, off), ((r << 16 >>> 16)));
		}
		r32 = rangeTab.R32;
		if (r32.$length > 0 && r >= (((0 >= r32.$length ? ($throwRuntimeError("index out of range"), undefined) : r32.$array[r32.$offset + 0]).Lo >> 0))) {
			return is32(r32, ((r >>> 0)));
		}
		return false;
	};
	To = function(_case, r) {
		var _case, _tuple, r;
		_tuple = to(_case, r, $pkg.CaseRanges);
		r = _tuple[0];
		return r;
	};
	$pkg.To = To;
	ToUpper = function(r) {
		var r;
		if (r <= 127) {
			if (97 <= r && r <= 122) {
				r = r - (32) >> 0;
			}
			return r;
		}
		return To(0, r);
	};
	$pkg.ToUpper = ToUpper;
	ToLower = function(r) {
		var r;
		if (r <= 127) {
			if (65 <= r && r <= 90) {
				r = r + (32) >> 0;
			}
			return r;
		}
		return To(1, r);
	};
	$pkg.ToLower = ToLower;
	SimpleFold = function(r) {
		var _q, hi, l, lo, m, r;
		if (r < 0 || r > 1114111) {
			return r;
		}
		if (((r >> 0)) < 128) {
			return ((((r < 0 || r >= asciiFold.length) ? ($throwRuntimeError("index out of range"), undefined) : asciiFold[r]) >> 0));
		}
		lo = 0;
		hi = caseOrbit.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((((m < 0 || m >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + m]).From >> 0)) < r) {
				lo = m + 1 >> 0;
			} else {
				hi = m;
			}
		}
		if (lo < caseOrbit.$length && (((((lo < 0 || lo >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + lo]).From >> 0)) === r)) {
			return ((((lo < 0 || lo >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + lo]).To >> 0));
		}
		l = ToLower(r);
		if (!((l === r))) {
			return l;
		}
		return ToUpper(r);
	};
	$pkg.SimpleFold = SimpleFold;
	RangeTable.init("", [{prop: "R16", name: "R16", embedded: false, exported: true, typ: sliceType, tag: ""}, {prop: "R32", name: "R32", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "LatinOffset", name: "LatinOffset", embedded: false, exported: true, typ: $Int, tag: ""}]);
	Range16.init("", [{prop: "Lo", name: "Lo", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Hi", name: "Hi", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Uint16, tag: ""}]);
	Range32.init("", [{prop: "Lo", name: "Lo", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Hi", name: "Hi", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Uint32, tag: ""}]);
	CaseRange.init("", [{prop: "Lo", name: "Lo", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Hi", name: "Hi", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Delta", name: "Delta", embedded: false, exported: true, typ: d, tag: ""}]);
	d.init($Int32, 3);
	foldPair.init("", [{prop: "From", name: "From", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "To", name: "To", embedded: false, exported: true, typ: $Uint16, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_C = new RangeTable.ptr(new sliceType([new Range16.ptr(0, 31, 1), new Range16.ptr(127, 159, 1), new Range16.ptr(173, 1536, 1363), new Range16.ptr(1537, 1541, 1), new Range16.ptr(1564, 1757, 193), new Range16.ptr(1807, 2274, 467), new Range16.ptr(6158, 8203, 2045), new Range16.ptr(8204, 8207, 1), new Range16.ptr(8234, 8238, 1), new Range16.ptr(8288, 8292, 1), new Range16.ptr(8294, 8303, 1), new Range16.ptr(55296, 63743, 1), new Range16.ptr(65279, 65529, 250), new Range16.ptr(65530, 65531, 1)]), new sliceType$1([new Range32.ptr(69821, 113824, 44003), new Range32.ptr(113825, 113827, 1), new Range32.ptr(119155, 119162, 1), new Range32.ptr(917505, 917536, 31), new Range32.ptr(917537, 917631, 1), new Range32.ptr(983040, 1048573, 1), new Range32.ptr(1048576, 1114109, 1)]), 2);
		_Cc = new RangeTable.ptr(new sliceType([new Range16.ptr(0, 31, 1), new Range16.ptr(127, 159, 1)]), sliceType$1.nil, 2);
		_Cf = new RangeTable.ptr(new sliceType([new Range16.ptr(173, 1536, 1363), new Range16.ptr(1537, 1541, 1), new Range16.ptr(1564, 1757, 193), new Range16.ptr(1807, 2274, 467), new Range16.ptr(6158, 8203, 2045), new Range16.ptr(8204, 8207, 1), new Range16.ptr(8234, 8238, 1), new Range16.ptr(8288, 8292, 1), new Range16.ptr(8294, 8303, 1), new Range16.ptr(65279, 65529, 250), new Range16.ptr(65530, 65531, 1)]), new sliceType$1([new Range32.ptr(69821, 113824, 44003), new Range32.ptr(113825, 113827, 1), new Range32.ptr(119155, 119162, 1), new Range32.ptr(917505, 917536, 31), new Range32.ptr(917537, 917631, 1)]), 0);
		_Co = new RangeTable.ptr(new sliceType([new Range16.ptr(57344, 63743, 1)]), new sliceType$1([new Range32.ptr(983040, 1048573, 1), new Range32.ptr(1048576, 1114109, 1)]), 0);
		_Cs = new RangeTable.ptr(new sliceType([new Range16.ptr(55296, 57343, 1)]), sliceType$1.nil, 0);
		_L = new RangeTable.ptr(new sliceType([new Range16.ptr(65, 90, 1), new Range16.ptr(97, 122, 1), new Range16.ptr(170, 181, 11), new Range16.ptr(186, 192, 6), new Range16.ptr(193, 214, 1), new Range16.ptr(216, 246, 1), new Range16.ptr(248, 705, 1), new Range16.ptr(710, 721, 1), new Range16.ptr(736, 740, 1), new Range16.ptr(748, 750, 2), new Range16.ptr(880, 884, 1), new Range16.ptr(886, 887, 1), new Range16.ptr(890, 893, 1), new Range16.ptr(895, 902, 7), new Range16.ptr(904, 906, 1), new Range16.ptr(908, 910, 2), new Range16.ptr(911, 929, 1), new Range16.ptr(931, 1013, 1), new Range16.ptr(1015, 1153, 1), new Range16.ptr(1162, 1327, 1), new Range16.ptr(1329, 1366, 1), new Range16.ptr(1369, 1377, 8), new Range16.ptr(1378, 1415, 1), new Range16.ptr(1488, 1514, 1), new Range16.ptr(1520, 1522, 1), new Range16.ptr(1568, 1610, 1), new Range16.ptr(1646, 1647, 1), new Range16.ptr(1649, 1747, 1), new Range16.ptr(1749, 1765, 16), new Range16.ptr(1766, 1774, 8), new Range16.ptr(1775, 1786, 11), new Range16.ptr(1787, 1788, 1), new Range16.ptr(1791, 1808, 17), new Range16.ptr(1810, 1839, 1), new Range16.ptr(1869, 1957, 1), new Range16.ptr(1969, 1994, 25), new Range16.ptr(1995, 2026, 1), new Range16.ptr(2036, 2037, 1), new Range16.ptr(2042, 2048, 6), new Range16.ptr(2049, 2069, 1), new Range16.ptr(2074, 2084, 10), new Range16.ptr(2088, 2112, 24), new Range16.ptr(2113, 2136, 1), new Range16.ptr(2144, 2154, 1), new Range16.ptr(2208, 2228, 1), new Range16.ptr(2230, 2237, 1), new Range16.ptr(2308, 2361, 1), new Range16.ptr(2365, 2384, 19), new Range16.ptr(2392, 2401, 1), new Range16.ptr(2417, 2432, 1), new Range16.ptr(2437, 2444, 1), new Range16.ptr(2447, 2448, 1), new Range16.ptr(2451, 2472, 1), new Range16.ptr(2474, 2480, 1), new Range16.ptr(2482, 2486, 4), new Range16.ptr(2487, 2489, 1), new Range16.ptr(2493, 2510, 17), new Range16.ptr(2524, 2525, 1), new Range16.ptr(2527, 2529, 1), new Range16.ptr(2544, 2545, 1), new Range16.ptr(2556, 2565, 9), new Range16.ptr(2566, 2570, 1), new Range16.ptr(2575, 2576, 1), new Range16.ptr(2579, 2600, 1), new Range16.ptr(2602, 2608, 1), new Range16.ptr(2610, 2611, 1), new Range16.ptr(2613, 2614, 1), new Range16.ptr(2616, 2617, 1), new Range16.ptr(2649, 2652, 1), new Range16.ptr(2654, 2674, 20), new Range16.ptr(2675, 2676, 1), new Range16.ptr(2693, 2701, 1), new Range16.ptr(2703, 2705, 1), new Range16.ptr(2707, 2728, 1), new Range16.ptr(2730, 2736, 1), new Range16.ptr(2738, 2739, 1), new Range16.ptr(2741, 2745, 1), new Range16.ptr(2749, 2768, 19), new Range16.ptr(2784, 2785, 1), new Range16.ptr(2809, 2821, 12), new Range16.ptr(2822, 2828, 1), new Range16.ptr(2831, 2832, 1), new Range16.ptr(2835, 2856, 1), new Range16.ptr(2858, 2864, 1), new Range16.ptr(2866, 2867, 1), new Range16.ptr(2869, 2873, 1), new Range16.ptr(2877, 2908, 31), new Range16.ptr(2909, 2911, 2), new Range16.ptr(2912, 2913, 1), new Range16.ptr(2929, 2947, 18), new Range16.ptr(2949, 2954, 1), new Range16.ptr(2958, 2960, 1), new Range16.ptr(2962, 2965, 1), new Range16.ptr(2969, 2970, 1), new Range16.ptr(2972, 2974, 2), new Range16.ptr(2975, 2979, 4), new Range16.ptr(2980, 2984, 4), new Range16.ptr(2985, 2986, 1), new Range16.ptr(2990, 3001, 1), new Range16.ptr(3024, 3077, 53), new Range16.ptr(3078, 3084, 1), new Range16.ptr(3086, 3088, 1), new Range16.ptr(3090, 3112, 1), new Range16.ptr(3114, 3129, 1), new Range16.ptr(3133, 3160, 27), new Range16.ptr(3161, 3162, 1), new Range16.ptr(3168, 3169, 1), new Range16.ptr(3200, 3205, 5), new Range16.ptr(3206, 3212, 1), new Range16.ptr(3214, 3216, 1), new Range16.ptr(3218, 3240, 1), new Range16.ptr(3242, 3251, 1), new Range16.ptr(3253, 3257, 1), new Range16.ptr(3261, 3294, 33), new Range16.ptr(3296, 3297, 1), new Range16.ptr(3313, 3314, 1), new Range16.ptr(3333, 3340, 1), new Range16.ptr(3342, 3344, 1), new Range16.ptr(3346, 3386, 1), new Range16.ptr(3389, 3406, 17), new Range16.ptr(3412, 3414, 1), new Range16.ptr(3423, 3425, 1), new Range16.ptr(3450, 3455, 1), new Range16.ptr(3461, 3478, 1), new Range16.ptr(3482, 3505, 1), new Range16.ptr(3507, 3515, 1), new Range16.ptr(3517, 3520, 3), new Range16.ptr(3521, 3526, 1), new Range16.ptr(3585, 3632, 1), new Range16.ptr(3634, 3635, 1), new Range16.ptr(3648, 3654, 1), new Range16.ptr(3713, 3714, 1), new Range16.ptr(3716, 3719, 3), new Range16.ptr(3720, 3722, 2), new Range16.ptr(3725, 3732, 7), new Range16.ptr(3733, 3735, 1), new Range16.ptr(3737, 3743, 1), new Range16.ptr(3745, 3747, 1), new Range16.ptr(3749, 3751, 2), new Range16.ptr(3754, 3755, 1), new Range16.ptr(3757, 3760, 1), new Range16.ptr(3762, 3763, 1), new Range16.ptr(3773, 3776, 3), new Range16.ptr(3777, 3780, 1), new Range16.ptr(3782, 3804, 22), new Range16.ptr(3805, 3807, 1), new Range16.ptr(3840, 3904, 64), new Range16.ptr(3905, 3911, 1), new Range16.ptr(3913, 3948, 1), new Range16.ptr(3976, 3980, 1), new Range16.ptr(4096, 4138, 1), new Range16.ptr(4159, 4176, 17), new Range16.ptr(4177, 4181, 1), new Range16.ptr(4186, 4189, 1), new Range16.ptr(4193, 4197, 4), new Range16.ptr(4198, 4206, 8), new Range16.ptr(4207, 4208, 1), new Range16.ptr(4213, 4225, 1), new Range16.ptr(4238, 4256, 18), new Range16.ptr(4257, 4293, 1), new Range16.ptr(4295, 4301, 6), new Range16.ptr(4304, 4346, 1), new Range16.ptr(4348, 4680, 1), new Range16.ptr(4682, 4685, 1), new Range16.ptr(4688, 4694, 1), new Range16.ptr(4696, 4698, 2), new Range16.ptr(4699, 4701, 1), new Range16.ptr(4704, 4744, 1), new Range16.ptr(4746, 4749, 1), new Range16.ptr(4752, 4784, 1), new Range16.ptr(4786, 4789, 1), new Range16.ptr(4792, 4798, 1), new Range16.ptr(4800, 4802, 2), new Range16.ptr(4803, 4805, 1), new Range16.ptr(4808, 4822, 1), new Range16.ptr(4824, 4880, 1), new Range16.ptr(4882, 4885, 1), new Range16.ptr(4888, 4954, 1), new Range16.ptr(4992, 5007, 1), new Range16.ptr(5024, 5109, 1), new Range16.ptr(5112, 5117, 1), new Range16.ptr(5121, 5740, 1), new Range16.ptr(5743, 5759, 1), new Range16.ptr(5761, 5786, 1), new Range16.ptr(5792, 5866, 1), new Range16.ptr(5873, 5880, 1), new Range16.ptr(5888, 5900, 1), new Range16.ptr(5902, 5905, 1), new Range16.ptr(5920, 5937, 1), new Range16.ptr(5952, 5969, 1), new Range16.ptr(5984, 5996, 1), new Range16.ptr(5998, 6000, 1), new Range16.ptr(6016, 6067, 1), new Range16.ptr(6103, 6108, 5), new Range16.ptr(6176, 6263, 1), new Range16.ptr(6272, 6276, 1), new Range16.ptr(6279, 6312, 1), new Range16.ptr(6314, 6320, 6), new Range16.ptr(6321, 6389, 1), new Range16.ptr(6400, 6430, 1), new Range16.ptr(6480, 6509, 1), new Range16.ptr(6512, 6516, 1), new Range16.ptr(6528, 6571, 1), new Range16.ptr(6576, 6601, 1), new Range16.ptr(6656, 6678, 1), new Range16.ptr(6688, 6740, 1), new Range16.ptr(6823, 6917, 94), new Range16.ptr(6918, 6963, 1), new Range16.ptr(6981, 6987, 1), new Range16.ptr(7043, 7072, 1), new Range16.ptr(7086, 7087, 1), new Range16.ptr(7098, 7141, 1), new Range16.ptr(7168, 7203, 1), new Range16.ptr(7245, 7247, 1), new Range16.ptr(7258, 7293, 1), new Range16.ptr(7296, 7304, 1), new Range16.ptr(7401, 7404, 1), new Range16.ptr(7406, 7409, 1), new Range16.ptr(7413, 7414, 1), new Range16.ptr(7424, 7615, 1), new Range16.ptr(7680, 7957, 1), new Range16.ptr(7960, 7965, 1), new Range16.ptr(7968, 8005, 1), new Range16.ptr(8008, 8013, 1), new Range16.ptr(8016, 8023, 1), new Range16.ptr(8025, 8031, 2), new Range16.ptr(8032, 8061, 1), new Range16.ptr(8064, 8116, 1), new Range16.ptr(8118, 8124, 1), new Range16.ptr(8126, 8130, 4), new Range16.ptr(8131, 8132, 1), new Range16.ptr(8134, 8140, 1), new Range16.ptr(8144, 8147, 1), new Range16.ptr(8150, 8155, 1), new Range16.ptr(8160, 8172, 1), new Range16.ptr(8178, 8180, 1), new Range16.ptr(8182, 8188, 1), new Range16.ptr(8305, 8319, 14), new Range16.ptr(8336, 8348, 1), new Range16.ptr(8450, 8455, 5), new Range16.ptr(8458, 8467, 1), new Range16.ptr(8469, 8473, 4), new Range16.ptr(8474, 8477, 1), new Range16.ptr(8484, 8490, 2), new Range16.ptr(8491, 8493, 1), new Range16.ptr(8495, 8505, 1), new Range16.ptr(8508, 8511, 1), new Range16.ptr(8517, 8521, 1), new Range16.ptr(8526, 8579, 53), new Range16.ptr(8580, 11264, 2684), new Range16.ptr(11265, 11310, 1), new Range16.ptr(11312, 11358, 1), new Range16.ptr(11360, 11492, 1), new Range16.ptr(11499, 11502, 1), new Range16.ptr(11506, 11507, 1), new Range16.ptr(11520, 11557, 1), new Range16.ptr(11559, 11565, 6), new Range16.ptr(11568, 11623, 1), new Range16.ptr(11631, 11648, 17), new Range16.ptr(11649, 11670, 1), new Range16.ptr(11680, 11686, 1), new Range16.ptr(11688, 11694, 1), new Range16.ptr(11696, 11702, 1), new Range16.ptr(11704, 11710, 1), new Range16.ptr(11712, 11718, 1), new Range16.ptr(11720, 11726, 1), new Range16.ptr(11728, 11734, 1), new Range16.ptr(11736, 11742, 1), new Range16.ptr(11823, 12293, 470), new Range16.ptr(12294, 12337, 43), new Range16.ptr(12338, 12341, 1), new Range16.ptr(12347, 12348, 1), new Range16.ptr(12353, 12438, 1), new Range16.ptr(12445, 12447, 1), new Range16.ptr(12449, 12538, 1), new Range16.ptr(12540, 12543, 1), new Range16.ptr(12549, 12590, 1), new Range16.ptr(12593, 12686, 1), new Range16.ptr(12704, 12730, 1), new Range16.ptr(12784, 12799, 1), new Range16.ptr(13312, 19893, 1), new Range16.ptr(19968, 40938, 1), new Range16.ptr(40960, 42124, 1), new Range16.ptr(42192, 42237, 1), new Range16.ptr(42240, 42508, 1), new Range16.ptr(42512, 42527, 1), new Range16.ptr(42538, 42539, 1), new Range16.ptr(42560, 42606, 1), new Range16.ptr(42623, 42653, 1), new Range16.ptr(42656, 42725, 1), new Range16.ptr(42775, 42783, 1), new Range16.ptr(42786, 42888, 1), new Range16.ptr(42891, 42926, 1), new Range16.ptr(42928, 42935, 1), new Range16.ptr(42999, 43009, 1), new Range16.ptr(43011, 43013, 1), new Range16.ptr(43015, 43018, 1), new Range16.ptr(43020, 43042, 1), new Range16.ptr(43072, 43123, 1), new Range16.ptr(43138, 43187, 1), new Range16.ptr(43250, 43255, 1), new Range16.ptr(43259, 43261, 2), new Range16.ptr(43274, 43301, 1), new Range16.ptr(43312, 43334, 1), new Range16.ptr(43360, 43388, 1), new Range16.ptr(43396, 43442, 1), new Range16.ptr(43471, 43488, 17), new Range16.ptr(43489, 43492, 1), new Range16.ptr(43494, 43503, 1), new Range16.ptr(43514, 43518, 1), new Range16.ptr(43520, 43560, 1), new Range16.ptr(43584, 43586, 1), new Range16.ptr(43588, 43595, 1), new Range16.ptr(43616, 43638, 1), new Range16.ptr(43642, 43646, 4), new Range16.ptr(43647, 43695, 1), new Range16.ptr(43697, 43701, 4), new Range16.ptr(43702, 43705, 3), new Range16.ptr(43706, 43709, 1), new Range16.ptr(43712, 43714, 2), new Range16.ptr(43739, 43741, 1), new Range16.ptr(43744, 43754, 1), new Range16.ptr(43762, 43764, 1), new Range16.ptr(43777, 43782, 1), new Range16.ptr(43785, 43790, 1), new Range16.ptr(43793, 43798, 1), new Range16.ptr(43808, 43814, 1), new Range16.ptr(43816, 43822, 1), new Range16.ptr(43824, 43866, 1), new Range16.ptr(43868, 43877, 1), new Range16.ptr(43888, 44002, 1), new Range16.ptr(44032, 55203, 1), new Range16.ptr(55216, 55238, 1), new Range16.ptr(55243, 55291, 1), new Range16.ptr(63744, 64109, 1), new Range16.ptr(64112, 64217, 1), new Range16.ptr(64256, 64262, 1), new Range16.ptr(64275, 64279, 1), new Range16.ptr(64285, 64287, 2), new Range16.ptr(64288, 64296, 1), new Range16.ptr(64298, 64310, 1), new Range16.ptr(64312, 64316, 1), new Range16.ptr(64318, 64320, 2), new Range16.ptr(64321, 64323, 2), new Range16.ptr(64324, 64326, 2), new Range16.ptr(64327, 64433, 1), new Range16.ptr(64467, 64829, 1), new Range16.ptr(64848, 64911, 1), new Range16.ptr(64914, 64967, 1), new Range16.ptr(65008, 65019, 1), new Range16.ptr(65136, 65140, 1), new Range16.ptr(65142, 65276, 1), new Range16.ptr(65313, 65338, 1), new Range16.ptr(65345, 65370, 1), new Range16.ptr(65382, 65470, 1), new Range16.ptr(65474, 65479, 1), new Range16.ptr(65482, 65487, 1), new Range16.ptr(65490, 65495, 1), new Range16.ptr(65498, 65500, 1)]), new sliceType$1([new Range32.ptr(65536, 65547, 1), new Range32.ptr(65549, 65574, 1), new Range32.ptr(65576, 65594, 1), new Range32.ptr(65596, 65597, 1), new Range32.ptr(65599, 65613, 1), new Range32.ptr(65616, 65629, 1), new Range32.ptr(65664, 65786, 1), new Range32.ptr(66176, 66204, 1), new Range32.ptr(66208, 66256, 1), new Range32.ptr(66304, 66335, 1), new Range32.ptr(66349, 66368, 1), new Range32.ptr(66370, 66377, 1), new Range32.ptr(66384, 66421, 1), new Range32.ptr(66432, 66461, 1), new Range32.ptr(66464, 66499, 1), new Range32.ptr(66504, 66511, 1), new Range32.ptr(66560, 66717, 1), new Range32.ptr(66736, 66771, 1), new Range32.ptr(66776, 66811, 1), new Range32.ptr(66816, 66855, 1), new Range32.ptr(66864, 66915, 1), new Range32.ptr(67072, 67382, 1), new Range32.ptr(67392, 67413, 1), new Range32.ptr(67424, 67431, 1), new Range32.ptr(67584, 67589, 1), new Range32.ptr(67592, 67594, 2), new Range32.ptr(67595, 67637, 1), new Range32.ptr(67639, 67640, 1), new Range32.ptr(67644, 67647, 3), new Range32.ptr(67648, 67669, 1), new Range32.ptr(67680, 67702, 1), new Range32.ptr(67712, 67742, 1), new Range32.ptr(67808, 67826, 1), new Range32.ptr(67828, 67829, 1), new Range32.ptr(67840, 67861, 1), new Range32.ptr(67872, 67897, 1), new Range32.ptr(67968, 68023, 1), new Range32.ptr(68030, 68031, 1), new Range32.ptr(68096, 68112, 16), new Range32.ptr(68113, 68115, 1), new Range32.ptr(68117, 68119, 1), new Range32.ptr(68121, 68147, 1), new Range32.ptr(68192, 68220, 1), new Range32.ptr(68224, 68252, 1), new Range32.ptr(68288, 68295, 1), new Range32.ptr(68297, 68324, 1), new Range32.ptr(68352, 68405, 1), new Range32.ptr(68416, 68437, 1), new Range32.ptr(68448, 68466, 1), new Range32.ptr(68480, 68497, 1), new Range32.ptr(68608, 68680, 1), new Range32.ptr(68736, 68786, 1), new Range32.ptr(68800, 68850, 1), new Range32.ptr(69635, 69687, 1), new Range32.ptr(69763, 69807, 1), new Range32.ptr(69840, 69864, 1), new Range32.ptr(69891, 69926, 1), new Range32.ptr(69968, 70002, 1), new Range32.ptr(70006, 70019, 13), new Range32.ptr(70020, 70066, 1), new Range32.ptr(70081, 70084, 1), new Range32.ptr(70106, 70108, 2), new Range32.ptr(70144, 70161, 1), new Range32.ptr(70163, 70187, 1), new Range32.ptr(70272, 70278, 1), new Range32.ptr(70280, 70282, 2), new Range32.ptr(70283, 70285, 1), new Range32.ptr(70287, 70301, 1), new Range32.ptr(70303, 70312, 1), new Range32.ptr(70320, 70366, 1), new Range32.ptr(70405, 70412, 1), new Range32.ptr(70415, 70416, 1), new Range32.ptr(70419, 70440, 1), new Range32.ptr(70442, 70448, 1), new Range32.ptr(70450, 70451, 1), new Range32.ptr(70453, 70457, 1), new Range32.ptr(70461, 70480, 19), new Range32.ptr(70493, 70497, 1), new Range32.ptr(70656, 70708, 1), new Range32.ptr(70727, 70730, 1), new Range32.ptr(70784, 70831, 1), new Range32.ptr(70852, 70853, 1), new Range32.ptr(70855, 71040, 185), new Range32.ptr(71041, 71086, 1), new Range32.ptr(71128, 71131, 1), new Range32.ptr(71168, 71215, 1), new Range32.ptr(71236, 71296, 60), new Range32.ptr(71297, 71338, 1), new Range32.ptr(71424, 71449, 1), new Range32.ptr(71840, 71903, 1), new Range32.ptr(71935, 72192, 257), new Range32.ptr(72203, 72242, 1), new Range32.ptr(72250, 72272, 22), new Range32.ptr(72284, 72323, 1), new Range32.ptr(72326, 72329, 1), new Range32.ptr(72384, 72440, 1), new Range32.ptr(72704, 72712, 1), new Range32.ptr(72714, 72750, 1), new Range32.ptr(72768, 72818, 50), new Range32.ptr(72819, 72847, 1), new Range32.ptr(72960, 72966, 1), new Range32.ptr(72968, 72969, 1), new Range32.ptr(72971, 73008, 1), new Range32.ptr(73030, 73728, 698), new Range32.ptr(73729, 74649, 1), new Range32.ptr(74880, 75075, 1), new Range32.ptr(77824, 78894, 1), new Range32.ptr(82944, 83526, 1), new Range32.ptr(92160, 92728, 1), new Range32.ptr(92736, 92766, 1), new Range32.ptr(92880, 92909, 1), new Range32.ptr(92928, 92975, 1), new Range32.ptr(92992, 92995, 1), new Range32.ptr(93027, 93047, 1), new Range32.ptr(93053, 93071, 1), new Range32.ptr(93952, 94020, 1), new Range32.ptr(94032, 94099, 67), new Range32.ptr(94100, 94111, 1), new Range32.ptr(94176, 94177, 1), new Range32.ptr(94208, 100332, 1), new Range32.ptr(100352, 101106, 1), new Range32.ptr(110592, 110878, 1), new Range32.ptr(110960, 111355, 1), new Range32.ptr(113664, 113770, 1), new Range32.ptr(113776, 113788, 1), new Range32.ptr(113792, 113800, 1), new Range32.ptr(113808, 113817, 1), new Range32.ptr(119808, 119892, 1), new Range32.ptr(119894, 119964, 1), new Range32.ptr(119966, 119967, 1), new Range32.ptr(119970, 119973, 3), new Range32.ptr(119974, 119977, 3), new Range32.ptr(119978, 119980, 1), new Range32.ptr(119982, 119993, 1), new Range32.ptr(119995, 119997, 2), new Range32.ptr(119998, 120003, 1), new Range32.ptr(120005, 120069, 1), new Range32.ptr(120071, 120074, 1), new Range32.ptr(120077, 120084, 1), new Range32.ptr(120086, 120092, 1), new Range32.ptr(120094, 120121, 1), new Range32.ptr(120123, 120126, 1), new Range32.ptr(120128, 120132, 1), new Range32.ptr(120134, 120138, 4), new Range32.ptr(120139, 120144, 1), new Range32.ptr(120146, 120485, 1), new Range32.ptr(120488, 120512, 1), new Range32.ptr(120514, 120538, 1), new Range32.ptr(120540, 120570, 1), new Range32.ptr(120572, 120596, 1), new Range32.ptr(120598, 120628, 1), new Range32.ptr(120630, 120654, 1), new Range32.ptr(120656, 120686, 1), new Range32.ptr(120688, 120712, 1), new Range32.ptr(120714, 120744, 1), new Range32.ptr(120746, 120770, 1), new Range32.ptr(120772, 120779, 1), new Range32.ptr(124928, 125124, 1), new Range32.ptr(125184, 125251, 1), new Range32.ptr(126464, 126467, 1), new Range32.ptr(126469, 126495, 1), new Range32.ptr(126497, 126498, 1), new Range32.ptr(126500, 126503, 3), new Range32.ptr(126505, 126514, 1), new Range32.ptr(126516, 126519, 1), new Range32.ptr(126521, 126523, 2), new Range32.ptr(126530, 126535, 5), new Range32.ptr(126537, 126541, 2), new Range32.ptr(126542, 126543, 1), new Range32.ptr(126545, 126546, 1), new Range32.ptr(126548, 126551, 3), new Range32.ptr(126553, 126561, 2), new Range32.ptr(126562, 126564, 2), new Range32.ptr(126567, 126570, 1), new Range32.ptr(126572, 126578, 1), new Range32.ptr(126580, 126583, 1), new Range32.ptr(126585, 126588, 1), new Range32.ptr(126590, 126592, 2), new Range32.ptr(126593, 126601, 1), new Range32.ptr(126603, 126619, 1), new Range32.ptr(126625, 126627, 1), new Range32.ptr(126629, 126633, 1), new Range32.ptr(126635, 126651, 1), new Range32.ptr(131072, 173782, 1), new Range32.ptr(173824, 177972, 1), new Range32.ptr(177984, 178205, 1), new Range32.ptr(178208, 183969, 1), new Range32.ptr(183984, 191456, 1), new Range32.ptr(194560, 195101, 1)]), 6);
		_Ll = new RangeTable.ptr(new sliceType([new Range16.ptr(97, 122, 1), new Range16.ptr(181, 223, 42), new Range16.ptr(224, 246, 1), new Range16.ptr(248, 255, 1), new Range16.ptr(257, 311, 2), new Range16.ptr(312, 328, 2), new Range16.ptr(329, 375, 2), new Range16.ptr(378, 382, 2), new Range16.ptr(383, 384, 1), new Range16.ptr(387, 389, 2), new Range16.ptr(392, 396, 4), new Range16.ptr(397, 402, 5), new Range16.ptr(405, 409, 4), new Range16.ptr(410, 411, 1), new Range16.ptr(414, 417, 3), new Range16.ptr(419, 421, 2), new Range16.ptr(424, 426, 2), new Range16.ptr(427, 429, 2), new Range16.ptr(432, 436, 4), new Range16.ptr(438, 441, 3), new Range16.ptr(442, 445, 3), new Range16.ptr(446, 447, 1), new Range16.ptr(454, 460, 3), new Range16.ptr(462, 476, 2), new Range16.ptr(477, 495, 2), new Range16.ptr(496, 499, 3), new Range16.ptr(501, 505, 4), new Range16.ptr(507, 563, 2), new Range16.ptr(564, 569, 1), new Range16.ptr(572, 575, 3), new Range16.ptr(576, 578, 2), new Range16.ptr(583, 591, 2), new Range16.ptr(592, 659, 1), new Range16.ptr(661, 687, 1), new Range16.ptr(881, 883, 2), new Range16.ptr(887, 891, 4), new Range16.ptr(892, 893, 1), new Range16.ptr(912, 940, 28), new Range16.ptr(941, 974, 1), new Range16.ptr(976, 977, 1), new Range16.ptr(981, 983, 1), new Range16.ptr(985, 1007, 2), new Range16.ptr(1008, 1011, 1), new Range16.ptr(1013, 1019, 3), new Range16.ptr(1020, 1072, 52), new Range16.ptr(1073, 1119, 1), new Range16.ptr(1121, 1153, 2), new Range16.ptr(1163, 1215, 2), new Range16.ptr(1218, 1230, 2), new Range16.ptr(1231, 1327, 2), new Range16.ptr(1377, 1415, 1), new Range16.ptr(5112, 5117, 1), new Range16.ptr(7296, 7304, 1), new Range16.ptr(7424, 7467, 1), new Range16.ptr(7531, 7543, 1), new Range16.ptr(7545, 7578, 1), new Range16.ptr(7681, 7829, 2), new Range16.ptr(7830, 7837, 1), new Range16.ptr(7839, 7935, 2), new Range16.ptr(7936, 7943, 1), new Range16.ptr(7952, 7957, 1), new Range16.ptr(7968, 7975, 1), new Range16.ptr(7984, 7991, 1), new Range16.ptr(8000, 8005, 1), new Range16.ptr(8016, 8023, 1), new Range16.ptr(8032, 8039, 1), new Range16.ptr(8048, 8061, 1), new Range16.ptr(8064, 8071, 1), new Range16.ptr(8080, 8087, 1), new Range16.ptr(8096, 8103, 1), new Range16.ptr(8112, 8116, 1), new Range16.ptr(8118, 8119, 1), new Range16.ptr(8126, 8130, 4), new Range16.ptr(8131, 8132, 1), new Range16.ptr(8134, 8135, 1), new Range16.ptr(8144, 8147, 1), new Range16.ptr(8150, 8151, 1), new Range16.ptr(8160, 8167, 1), new Range16.ptr(8178, 8180, 1), new Range16.ptr(8182, 8183, 1), new Range16.ptr(8458, 8462, 4), new Range16.ptr(8463, 8467, 4), new Range16.ptr(8495, 8505, 5), new Range16.ptr(8508, 8509, 1), new Range16.ptr(8518, 8521, 1), new Range16.ptr(8526, 8580, 54), new Range16.ptr(11312, 11358, 1), new Range16.ptr(11361, 11365, 4), new Range16.ptr(11366, 11372, 2), new Range16.ptr(11377, 11379, 2), new Range16.ptr(11380, 11382, 2), new Range16.ptr(11383, 11387, 1), new Range16.ptr(11393, 11491, 2), new Range16.ptr(11492, 11500, 8), new Range16.ptr(11502, 11507, 5), new Range16.ptr(11520, 11557, 1), new Range16.ptr(11559, 11565, 6), new Range16.ptr(42561, 42605, 2), new Range16.ptr(42625, 42651, 2), new Range16.ptr(42787, 42799, 2), new Range16.ptr(42800, 42801, 1), new Range16.ptr(42803, 42865, 2), new Range16.ptr(42866, 42872, 1), new Range16.ptr(42874, 42876, 2), new Range16.ptr(42879, 42887, 2), new Range16.ptr(42892, 42894, 2), new Range16.ptr(42897, 42899, 2), new Range16.ptr(42900, 42901, 1), new Range16.ptr(42903, 42921, 2), new Range16.ptr(42933, 42935, 2), new Range16.ptr(43002, 43824, 822), new Range16.ptr(43825, 43866, 1), new Range16.ptr(43872, 43877, 1), new Range16.ptr(43888, 43967, 1), new Range16.ptr(64256, 64262, 1), new Range16.ptr(64275, 64279, 1), new Range16.ptr(65345, 65370, 1)]), new sliceType$1([new Range32.ptr(66600, 66639, 1), new Range32.ptr(66776, 66811, 1), new Range32.ptr(68800, 68850, 1), new Range32.ptr(71872, 71903, 1), new Range32.ptr(119834, 119859, 1), new Range32.ptr(119886, 119892, 1), new Range32.ptr(119894, 119911, 1), new Range32.ptr(119938, 119963, 1), new Range32.ptr(119990, 119993, 1), new Range32.ptr(119995, 119997, 2), new Range32.ptr(119998, 120003, 1), new Range32.ptr(120005, 120015, 1), new Range32.ptr(120042, 120067, 1), new Range32.ptr(120094, 120119, 1), new Range32.ptr(120146, 120171, 1), new Range32.ptr(120198, 120223, 1), new Range32.ptr(120250, 120275, 1), new Range32.ptr(120302, 120327, 1), new Range32.ptr(120354, 120379, 1), new Range32.ptr(120406, 120431, 1), new Range32.ptr(120458, 120485, 1), new Range32.ptr(120514, 120538, 1), new Range32.ptr(120540, 120545, 1), new Range32.ptr(120572, 120596, 1), new Range32.ptr(120598, 120603, 1), new Range32.ptr(120630, 120654, 1), new Range32.ptr(120656, 120661, 1), new Range32.ptr(120688, 120712, 1), new Range32.ptr(120714, 120719, 1), new Range32.ptr(120746, 120770, 1), new Range32.ptr(120772, 120777, 1), new Range32.ptr(120779, 125218, 4439), new Range32.ptr(125219, 125251, 1)]), 4);
		_Lm = new RangeTable.ptr(new sliceType([new Range16.ptr(688, 705, 1), new Range16.ptr(710, 721, 1), new Range16.ptr(736, 740, 1), new Range16.ptr(748, 750, 2), new Range16.ptr(884, 890, 6), new Range16.ptr(1369, 1600, 231), new Range16.ptr(1765, 1766, 1), new Range16.ptr(2036, 2037, 1), new Range16.ptr(2042, 2074, 32), new Range16.ptr(2084, 2088, 4), new Range16.ptr(2417, 3654, 1237), new Range16.ptr(3782, 4348, 566), new Range16.ptr(6103, 6211, 108), new Range16.ptr(6823, 7288, 465), new Range16.ptr(7289, 7293, 1), new Range16.ptr(7468, 7530, 1), new Range16.ptr(7544, 7579, 35), new Range16.ptr(7580, 7615, 1), new Range16.ptr(8305, 8319, 14), new Range16.ptr(8336, 8348, 1), new Range16.ptr(11388, 11389, 1), new Range16.ptr(11631, 11823, 192), new Range16.ptr(12293, 12337, 44), new Range16.ptr(12338, 12341, 1), new Range16.ptr(12347, 12445, 98), new Range16.ptr(12446, 12540, 94), new Range16.ptr(12541, 12542, 1), new Range16.ptr(40981, 42232, 1251), new Range16.ptr(42233, 42237, 1), new Range16.ptr(42508, 42623, 115), new Range16.ptr(42652, 42653, 1), new Range16.ptr(42775, 42783, 1), new Range16.ptr(42864, 42888, 24), new Range16.ptr(43000, 43001, 1), new Range16.ptr(43471, 43494, 23), new Range16.ptr(43632, 43741, 109), new Range16.ptr(43763, 43764, 1), new Range16.ptr(43868, 43871, 1), new Range16.ptr(65392, 65438, 46), new Range16.ptr(65439, 65439, 1)]), new sliceType$1([new Range32.ptr(92992, 92992, 1), new Range32.ptr(92993, 92995, 1), new Range32.ptr(94099, 94111, 1), new Range32.ptr(94176, 94177, 1)]), 0);
		_Lo = new RangeTable.ptr(new sliceType([new Range16.ptr(170, 186, 16), new Range16.ptr(443, 448, 5), new Range16.ptr(449, 451, 1), new Range16.ptr(660, 1488, 828), new Range16.ptr(1489, 1514, 1), new Range16.ptr(1520, 1522, 1), new Range16.ptr(1568, 1599, 1), new Range16.ptr(1601, 1610, 1), new Range16.ptr(1646, 1647, 1), new Range16.ptr(1649, 1747, 1), new Range16.ptr(1749, 1774, 25), new Range16.ptr(1775, 1786, 11), new Range16.ptr(1787, 1788, 1), new Range16.ptr(1791, 1808, 17), new Range16.ptr(1810, 1839, 1), new Range16.ptr(1869, 1957, 1), new Range16.ptr(1969, 1994, 25), new Range16.ptr(1995, 2026, 1), new Range16.ptr(2048, 2069, 1), new Range16.ptr(2112, 2136, 1), new Range16.ptr(2144, 2154, 1), new Range16.ptr(2208, 2228, 1), new Range16.ptr(2230, 2237, 1), new Range16.ptr(2308, 2361, 1), new Range16.ptr(2365, 2384, 19), new Range16.ptr(2392, 2401, 1), new Range16.ptr(2418, 2432, 1), new Range16.ptr(2437, 2444, 1), new Range16.ptr(2447, 2448, 1), new Range16.ptr(2451, 2472, 1), new Range16.ptr(2474, 2480, 1), new Range16.ptr(2482, 2486, 4), new Range16.ptr(2487, 2489, 1), new Range16.ptr(2493, 2510, 17), new Range16.ptr(2524, 2525, 1), new Range16.ptr(2527, 2529, 1), new Range16.ptr(2544, 2545, 1), new Range16.ptr(2556, 2565, 9), new Range16.ptr(2566, 2570, 1), new Range16.ptr(2575, 2576, 1), new Range16.ptr(2579, 2600, 1), new Range16.ptr(2602, 2608, 1), new Range16.ptr(2610, 2611, 1), new Range16.ptr(2613, 2614, 1), new Range16.ptr(2616, 2617, 1), new Range16.ptr(2649, 2652, 1), new Range16.ptr(2654, 2674, 20), new Range16.ptr(2675, 2676, 1), new Range16.ptr(2693, 2701, 1), new Range16.ptr(2703, 2705, 1), new Range16.ptr(2707, 2728, 1), new Range16.ptr(2730, 2736, 1), new Range16.ptr(2738, 2739, 1), new Range16.ptr(2741, 2745, 1), new Range16.ptr(2749, 2768, 19), new Range16.ptr(2784, 2785, 1), new Range16.ptr(2809, 2821, 12), new Range16.ptr(2822, 2828, 1), new Range16.ptr(2831, 2832, 1), new Range16.ptr(2835, 2856, 1), new Range16.ptr(2858, 2864, 1), new Range16.ptr(2866, 2867, 1), new Range16.ptr(2869, 2873, 1), new Range16.ptr(2877, 2908, 31), new Range16.ptr(2909, 2911, 2), new Range16.ptr(2912, 2913, 1), new Range16.ptr(2929, 2947, 18), new Range16.ptr(2949, 2954, 1), new Range16.ptr(2958, 2960, 1), new Range16.ptr(2962, 2965, 1), new Range16.ptr(2969, 2970, 1), new Range16.ptr(2972, 2974, 2), new Range16.ptr(2975, 2979, 4), new Range16.ptr(2980, 2984, 4), new Range16.ptr(2985, 2986, 1), new Range16.ptr(2990, 3001, 1), new Range16.ptr(3024, 3077, 53), new Range16.ptr(3078, 3084, 1), new Range16.ptr(3086, 3088, 1), new Range16.ptr(3090, 3112, 1), new Range16.ptr(3114, 3129, 1), new Range16.ptr(3133, 3160, 27), new Range16.ptr(3161, 3162, 1), new Range16.ptr(3168, 3169, 1), new Range16.ptr(3200, 3205, 5), new Range16.ptr(3206, 3212, 1), new Range16.ptr(3214, 3216, 1), new Range16.ptr(3218, 3240, 1), new Range16.ptr(3242, 3251, 1), new Range16.ptr(3253, 3257, 1), new Range16.ptr(3261, 3294, 33), new Range16.ptr(3296, 3297, 1), new Range16.ptr(3313, 3314, 1), new Range16.ptr(3333, 3340, 1), new Range16.ptr(3342, 3344, 1), new Range16.ptr(3346, 3386, 1), new Range16.ptr(3389, 3406, 17), new Range16.ptr(3412, 3414, 1), new Range16.ptr(3423, 3425, 1), new Range16.ptr(3450, 3455, 1), new Range16.ptr(3461, 3478, 1), new Range16.ptr(3482, 3505, 1), new Range16.ptr(3507, 3515, 1), new Range16.ptr(3517, 3520, 3), new Range16.ptr(3521, 3526, 1), new Range16.ptr(3585, 3632, 1), new Range16.ptr(3634, 3635, 1), new Range16.ptr(3648, 3653, 1), new Range16.ptr(3713, 3714, 1), new Range16.ptr(3716, 3719, 3), new Range16.ptr(3720, 3722, 2), new Range16.ptr(3725, 3732, 7), new Range16.ptr(3733, 3735, 1), new Range16.ptr(3737, 3743, 1), new Range16.ptr(3745, 3747, 1), new Range16.ptr(3749, 3751, 2), new Range16.ptr(3754, 3755, 1), new Range16.ptr(3757, 3760, 1), new Range16.ptr(3762, 3763, 1), new Range16.ptr(3773, 3776, 3), new Range16.ptr(3777, 3780, 1), new Range16.ptr(3804, 3807, 1), new Range16.ptr(3840, 3904, 64), new Range16.ptr(3905, 3911, 1), new Range16.ptr(3913, 3948, 1), new Range16.ptr(3976, 3980, 1), new Range16.ptr(4096, 4138, 1), new Range16.ptr(4159, 4176, 17), new Range16.ptr(4177, 4181, 1), new Range16.ptr(4186, 4189, 1), new Range16.ptr(4193, 4197, 4), new Range16.ptr(4198, 4206, 8), new Range16.ptr(4207, 4208, 1), new Range16.ptr(4213, 4225, 1), new Range16.ptr(4238, 4304, 66), new Range16.ptr(4305, 4346, 1), new Range16.ptr(4349, 4680, 1), new Range16.ptr(4682, 4685, 1), new Range16.ptr(4688, 4694, 1), new Range16.ptr(4696, 4698, 2), new Range16.ptr(4699, 4701, 1), new Range16.ptr(4704, 4744, 1), new Range16.ptr(4746, 4749, 1), new Range16.ptr(4752, 4784, 1), new Range16.ptr(4786, 4789, 1), new Range16.ptr(4792, 4798, 1), new Range16.ptr(4800, 4802, 2), new Range16.ptr(4803, 4805, 1), new Range16.ptr(4808, 4822, 1), new Range16.ptr(4824, 4880, 1), new Range16.ptr(4882, 4885, 1), new Range16.ptr(4888, 4954, 1), new Range16.ptr(4992, 5007, 1), new Range16.ptr(5121, 5740, 1), new Range16.ptr(5743, 5759, 1), new Range16.ptr(5761, 5786, 1), new Range16.ptr(5792, 5866, 1), new Range16.ptr(5873, 5880, 1), new Range16.ptr(5888, 5900, 1), new Range16.ptr(5902, 5905, 1), new Range16.ptr(5920, 5937, 1), new Range16.ptr(5952, 5969, 1), new Range16.ptr(5984, 5996, 1), new Range16.ptr(5998, 6000, 1), new Range16.ptr(6016, 6067, 1), new Range16.ptr(6108, 6176, 68), new Range16.ptr(6177, 6210, 1), new Range16.ptr(6212, 6263, 1), new Range16.ptr(6272, 6276, 1), new Range16.ptr(6279, 6312, 1), new Range16.ptr(6314, 6320, 6), new Range16.ptr(6321, 6389, 1), new Range16.ptr(6400, 6430, 1), new Range16.ptr(6480, 6509, 1), new Range16.ptr(6512, 6516, 1), new Range16.ptr(6528, 6571, 1), new Range16.ptr(6576, 6601, 1), new Range16.ptr(6656, 6678, 1), new Range16.ptr(6688, 6740, 1), new Range16.ptr(6917, 6963, 1), new Range16.ptr(6981, 6987, 1), new Range16.ptr(7043, 7072, 1), new Range16.ptr(7086, 7087, 1), new Range16.ptr(7098, 7141, 1), new Range16.ptr(7168, 7203, 1), new Range16.ptr(7245, 7247, 1), new Range16.ptr(7258, 7287, 1), new Range16.ptr(7401, 7404, 1), new Range16.ptr(7406, 7409, 1), new Range16.ptr(7413, 7414, 1), new Range16.ptr(8501, 8504, 1), new Range16.ptr(11568, 11623, 1), new Range16.ptr(11648, 11670, 1), new Range16.ptr(11680, 11686, 1), new Range16.ptr(11688, 11694, 1), new Range16.ptr(11696, 11702, 1), new Range16.ptr(11704, 11710, 1), new Range16.ptr(11712, 11718, 1), new Range16.ptr(11720, 11726, 1), new Range16.ptr(11728, 11734, 1), new Range16.ptr(11736, 11742, 1), new Range16.ptr(12294, 12348, 54), new Range16.ptr(12353, 12438, 1), new Range16.ptr(12447, 12449, 2), new Range16.ptr(12450, 12538, 1), new Range16.ptr(12543, 12549, 6), new Range16.ptr(12550, 12590, 1), new Range16.ptr(12593, 12686, 1), new Range16.ptr(12704, 12730, 1), new Range16.ptr(12784, 12799, 1), new Range16.ptr(13312, 19893, 1), new Range16.ptr(19968, 40938, 1), new Range16.ptr(40960, 40980, 1), new Range16.ptr(40982, 42124, 1), new Range16.ptr(42192, 42231, 1), new Range16.ptr(42240, 42507, 1), new Range16.ptr(42512, 42527, 1), new Range16.ptr(42538, 42539, 1), new Range16.ptr(42606, 42656, 50), new Range16.ptr(42657, 42725, 1), new Range16.ptr(42895, 42999, 104), new Range16.ptr(43003, 43009, 1), new Range16.ptr(43011, 43013, 1), new Range16.ptr(43015, 43018, 1), new Range16.ptr(43020, 43042, 1), new Range16.ptr(43072, 43123, 1), new Range16.ptr(43138, 43187, 1), new Range16.ptr(43250, 43255, 1), new Range16.ptr(43259, 43261, 2), new Range16.ptr(43274, 43301, 1), new Range16.ptr(43312, 43334, 1), new Range16.ptr(43360, 43388, 1), new Range16.ptr(43396, 43442, 1), new Range16.ptr(43488, 43492, 1), new Range16.ptr(43495, 43503, 1), new Range16.ptr(43514, 43518, 1), new Range16.ptr(43520, 43560, 1), new Range16.ptr(43584, 43586, 1), new Range16.ptr(43588, 43595, 1), new Range16.ptr(43616, 43631, 1), new Range16.ptr(43633, 43638, 1), new Range16.ptr(43642, 43646, 4), new Range16.ptr(43647, 43695, 1), new Range16.ptr(43697, 43701, 4), new Range16.ptr(43702, 43705, 3), new Range16.ptr(43706, 43709, 1), new Range16.ptr(43712, 43714, 2), new Range16.ptr(43739, 43740, 1), new Range16.ptr(43744, 43754, 1), new Range16.ptr(43762, 43777, 15), new Range16.ptr(43778, 43782, 1), new Range16.ptr(43785, 43790, 1), new Range16.ptr(43793, 43798, 1), new Range16.ptr(43808, 43814, 1), new Range16.ptr(43816, 43822, 1), new Range16.ptr(43968, 44002, 1), new Range16.ptr(44032, 55203, 1), new Range16.ptr(55216, 55238, 1), new Range16.ptr(55243, 55291, 1), new Range16.ptr(63744, 64109, 1), new Range16.ptr(64112, 64217, 1), new Range16.ptr(64285, 64287, 2), new Range16.ptr(64288, 64296, 1), new Range16.ptr(64298, 64310, 1), new Range16.ptr(64312, 64316, 1), new Range16.ptr(64318, 64320, 2), new Range16.ptr(64321, 64323, 2), new Range16.ptr(64324, 64326, 2), new Range16.ptr(64327, 64433, 1), new Range16.ptr(64467, 64829, 1), new Range16.ptr(64848, 64911, 1), new Range16.ptr(64914, 64967, 1), new Range16.ptr(65008, 65019, 1), new Range16.ptr(65136, 65140, 1), new Range16.ptr(65142, 65276, 1), new Range16.ptr(65382, 65391, 1), new Range16.ptr(65393, 65437, 1), new Range16.ptr(65440, 65470, 1), new Range16.ptr(65474, 65479, 1), new Range16.ptr(65482, 65487, 1), new Range16.ptr(65490, 65495, 1), new Range16.ptr(65498, 65500, 1)]), new sliceType$1([new Range32.ptr(65536, 65547, 1), new Range32.ptr(65549, 65574, 1), new Range32.ptr(65576, 65594, 1), new Range32.ptr(65596, 65597, 1), new Range32.ptr(65599, 65613, 1), new Range32.ptr(65616, 65629, 1), new Range32.ptr(65664, 65786, 1), new Range32.ptr(66176, 66204, 1), new Range32.ptr(66208, 66256, 1), new Range32.ptr(66304, 66335, 1), new Range32.ptr(66349, 66368, 1), new Range32.ptr(66370, 66377, 1), new Range32.ptr(66384, 66421, 1), new Range32.ptr(66432, 66461, 1), new Range32.ptr(66464, 66499, 1), new Range32.ptr(66504, 66511, 1), new Range32.ptr(66640, 66717, 1), new Range32.ptr(66816, 66855, 1), new Range32.ptr(66864, 66915, 1), new Range32.ptr(67072, 67382, 1), new Range32.ptr(67392, 67413, 1), new Range32.ptr(67424, 67431, 1), new Range32.ptr(67584, 67589, 1), new Range32.ptr(67592, 67594, 2), new Range32.ptr(67595, 67637, 1), new Range32.ptr(67639, 67640, 1), new Range32.ptr(67644, 67647, 3), new Range32.ptr(67648, 67669, 1), new Range32.ptr(67680, 67702, 1), new Range32.ptr(67712, 67742, 1), new Range32.ptr(67808, 67826, 1), new Range32.ptr(67828, 67829, 1), new Range32.ptr(67840, 67861, 1), new Range32.ptr(67872, 67897, 1), new Range32.ptr(67968, 68023, 1), new Range32.ptr(68030, 68031, 1), new Range32.ptr(68096, 68112, 16), new Range32.ptr(68113, 68115, 1), new Range32.ptr(68117, 68119, 1), new Range32.ptr(68121, 68147, 1), new Range32.ptr(68192, 68220, 1), new Range32.ptr(68224, 68252, 1), new Range32.ptr(68288, 68295, 1), new Range32.ptr(68297, 68324, 1), new Range32.ptr(68352, 68405, 1), new Range32.ptr(68416, 68437, 1), new Range32.ptr(68448, 68466, 1), new Range32.ptr(68480, 68497, 1), new Range32.ptr(68608, 68680, 1), new Range32.ptr(69635, 69687, 1), new Range32.ptr(69763, 69807, 1), new Range32.ptr(69840, 69864, 1), new Range32.ptr(69891, 69926, 1), new Range32.ptr(69968, 70002, 1), new Range32.ptr(70006, 70019, 13), new Range32.ptr(70020, 70066, 1), new Range32.ptr(70081, 70084, 1), new Range32.ptr(70106, 70108, 2), new Range32.ptr(70144, 70161, 1), new Range32.ptr(70163, 70187, 1), new Range32.ptr(70272, 70278, 1), new Range32.ptr(70280, 70282, 2), new Range32.ptr(70283, 70285, 1), new Range32.ptr(70287, 70301, 1), new Range32.ptr(70303, 70312, 1), new Range32.ptr(70320, 70366, 1), new Range32.ptr(70405, 70412, 1), new Range32.ptr(70415, 70416, 1), new Range32.ptr(70419, 70440, 1), new Range32.ptr(70442, 70448, 1), new Range32.ptr(70450, 70451, 1), new Range32.ptr(70453, 70457, 1), new Range32.ptr(70461, 70480, 19), new Range32.ptr(70493, 70497, 1), new Range32.ptr(70656, 70708, 1), new Range32.ptr(70727, 70730, 1), new Range32.ptr(70784, 70831, 1), new Range32.ptr(70852, 70853, 1), new Range32.ptr(70855, 71040, 185), new Range32.ptr(71041, 71086, 1), new Range32.ptr(71128, 71131, 1), new Range32.ptr(71168, 71215, 1), new Range32.ptr(71236, 71296, 60), new Range32.ptr(71297, 71338, 1), new Range32.ptr(71424, 71449, 1), new Range32.ptr(71935, 72192, 257), new Range32.ptr(72203, 72242, 1), new Range32.ptr(72250, 72272, 22), new Range32.ptr(72284, 72323, 1), new Range32.ptr(72326, 72329, 1), new Range32.ptr(72384, 72440, 1), new Range32.ptr(72704, 72712, 1), new Range32.ptr(72714, 72750, 1), new Range32.ptr(72768, 72818, 50), new Range32.ptr(72819, 72847, 1), new Range32.ptr(72960, 72966, 1), new Range32.ptr(72968, 72969, 1), new Range32.ptr(72971, 73008, 1), new Range32.ptr(73030, 73728, 698), new Range32.ptr(73729, 74649, 1), new Range32.ptr(74880, 75075, 1), new Range32.ptr(77824, 78894, 1), new Range32.ptr(82944, 83526, 1), new Range32.ptr(92160, 92728, 1), new Range32.ptr(92736, 92766, 1), new Range32.ptr(92880, 92909, 1), new Range32.ptr(92928, 92975, 1), new Range32.ptr(93027, 93047, 1), new Range32.ptr(93053, 93071, 1), new Range32.ptr(93952, 94020, 1), new Range32.ptr(94032, 94208, 176), new Range32.ptr(94209, 100332, 1), new Range32.ptr(100352, 101106, 1), new Range32.ptr(110592, 110878, 1), new Range32.ptr(110960, 111355, 1), new Range32.ptr(113664, 113770, 1), new Range32.ptr(113776, 113788, 1), new Range32.ptr(113792, 113800, 1), new Range32.ptr(113808, 113817, 1), new Range32.ptr(124928, 125124, 1), new Range32.ptr(126464, 126467, 1), new Range32.ptr(126469, 126495, 1), new Range32.ptr(126497, 126498, 1), new Range32.ptr(126500, 126503, 3), new Range32.ptr(126505, 126514, 1), new Range32.ptr(126516, 126519, 1), new Range32.ptr(126521, 126523, 2), new Range32.ptr(126530, 126535, 5), new Range32.ptr(126537, 126541, 2), new Range32.ptr(126542, 126543, 1), new Range32.ptr(126545, 126546, 1), new Range32.ptr(126548, 126551, 3), new Range32.ptr(126553, 126561, 2), new Range32.ptr(126562, 126564, 2), new Range32.ptr(126567, 126570, 1), new Range32.ptr(126572, 126578, 1), new Range32.ptr(126580, 126583, 1), new Range32.ptr(126585, 126588, 1), new Range32.ptr(126590, 126592, 2), new Range32.ptr(126593, 126601, 1), new Range32.ptr(126603, 126619, 1), new Range32.ptr(126625, 126627, 1), new Range32.ptr(126629, 126633, 1), new Range32.ptr(126635, 126651, 1), new Range32.ptr(131072, 173782, 1), new Range32.ptr(173824, 177972, 1), new Range32.ptr(177984, 178205, 1), new Range32.ptr(178208, 183969, 1), new Range32.ptr(183984, 191456, 1), new Range32.ptr(194560, 195101, 1)]), 1);
		_Lt = new RangeTable.ptr(new sliceType([new Range16.ptr(453, 459, 3), new Range16.ptr(498, 8072, 7574), new Range16.ptr(8073, 8079, 1), new Range16.ptr(8088, 8095, 1), new Range16.ptr(8104, 8111, 1), new Range16.ptr(8124, 8140, 16), new Range16.ptr(8188, 8188, 1)]), sliceType$1.nil, 0);
		_Lu = new RangeTable.ptr(new sliceType([new Range16.ptr(65, 90, 1), new Range16.ptr(192, 214, 1), new Range16.ptr(216, 222, 1), new Range16.ptr(256, 310, 2), new Range16.ptr(313, 327, 2), new Range16.ptr(330, 376, 2), new Range16.ptr(377, 381, 2), new Range16.ptr(385, 386, 1), new Range16.ptr(388, 390, 2), new Range16.ptr(391, 393, 2), new Range16.ptr(394, 395, 1), new Range16.ptr(398, 401, 1), new Range16.ptr(403, 404, 1), new Range16.ptr(406, 408, 1), new Range16.ptr(412, 413, 1), new Range16.ptr(415, 416, 1), new Range16.ptr(418, 422, 2), new Range16.ptr(423, 425, 2), new Range16.ptr(428, 430, 2), new Range16.ptr(431, 433, 2), new Range16.ptr(434, 435, 1), new Range16.ptr(437, 439, 2), new Range16.ptr(440, 444, 4), new Range16.ptr(452, 461, 3), new Range16.ptr(463, 475, 2), new Range16.ptr(478, 494, 2), new Range16.ptr(497, 500, 3), new Range16.ptr(502, 504, 1), new Range16.ptr(506, 562, 2), new Range16.ptr(570, 571, 1), new Range16.ptr(573, 574, 1), new Range16.ptr(577, 579, 2), new Range16.ptr(580, 582, 1), new Range16.ptr(584, 590, 2), new Range16.ptr(880, 882, 2), new Range16.ptr(886, 895, 9), new Range16.ptr(902, 904, 2), new Range16.ptr(905, 906, 1), new Range16.ptr(908, 910, 2), new Range16.ptr(911, 913, 2), new Range16.ptr(914, 929, 1), new Range16.ptr(931, 939, 1), new Range16.ptr(975, 978, 3), new Range16.ptr(979, 980, 1), new Range16.ptr(984, 1006, 2), new Range16.ptr(1012, 1015, 3), new Range16.ptr(1017, 1018, 1), new Range16.ptr(1021, 1071, 1), new Range16.ptr(1120, 1152, 2), new Range16.ptr(1162, 1216, 2), new Range16.ptr(1217, 1229, 2), new Range16.ptr(1232, 1326, 2), new Range16.ptr(1329, 1366, 1), new Range16.ptr(4256, 4293, 1), new Range16.ptr(4295, 4301, 6), new Range16.ptr(5024, 5109, 1), new Range16.ptr(7680, 7828, 2), new Range16.ptr(7838, 7934, 2), new Range16.ptr(7944, 7951, 1), new Range16.ptr(7960, 7965, 1), new Range16.ptr(7976, 7983, 1), new Range16.ptr(7992, 7999, 1), new Range16.ptr(8008, 8013, 1), new Range16.ptr(8025, 8031, 2), new Range16.ptr(8040, 8047, 1), new Range16.ptr(8120, 8123, 1), new Range16.ptr(8136, 8139, 1), new Range16.ptr(8152, 8155, 1), new Range16.ptr(8168, 8172, 1), new Range16.ptr(8184, 8187, 1), new Range16.ptr(8450, 8455, 5), new Range16.ptr(8459, 8461, 1), new Range16.ptr(8464, 8466, 1), new Range16.ptr(8469, 8473, 4), new Range16.ptr(8474, 8477, 1), new Range16.ptr(8484, 8490, 2), new Range16.ptr(8491, 8493, 1), new Range16.ptr(8496, 8499, 1), new Range16.ptr(8510, 8511, 1), new Range16.ptr(8517, 8579, 62), new Range16.ptr(11264, 11310, 1), new Range16.ptr(11360, 11362, 2), new Range16.ptr(11363, 11364, 1), new Range16.ptr(11367, 11373, 2), new Range16.ptr(11374, 11376, 1), new Range16.ptr(11378, 11381, 3), new Range16.ptr(11390, 11392, 1), new Range16.ptr(11394, 11490, 2), new Range16.ptr(11499, 11501, 2), new Range16.ptr(11506, 42560, 31054), new Range16.ptr(42562, 42604, 2), new Range16.ptr(42624, 42650, 2), new Range16.ptr(42786, 42798, 2), new Range16.ptr(42802, 42862, 2), new Range16.ptr(42873, 42877, 2), new Range16.ptr(42878, 42886, 2), new Range16.ptr(42891, 42893, 2), new Range16.ptr(42896, 42898, 2), new Range16.ptr(42902, 42922, 2), new Range16.ptr(42923, 42926, 1), new Range16.ptr(42928, 42932, 1), new Range16.ptr(42934, 65313, 22379), new Range16.ptr(65314, 65338, 1)]), new sliceType$1([new Range32.ptr(66560, 66599, 1), new Range32.ptr(66736, 66771, 1), new Range32.ptr(68736, 68786, 1), new Range32.ptr(71840, 71871, 1), new Range32.ptr(119808, 119833, 1), new Range32.ptr(119860, 119885, 1), new Range32.ptr(119912, 119937, 1), new Range32.ptr(119964, 119966, 2), new Range32.ptr(119967, 119973, 3), new Range32.ptr(119974, 119977, 3), new Range32.ptr(119978, 119980, 1), new Range32.ptr(119982, 119989, 1), new Range32.ptr(120016, 120041, 1), new Range32.ptr(120068, 120069, 1), new Range32.ptr(120071, 120074, 1), new Range32.ptr(120077, 120084, 1), new Range32.ptr(120086, 120092, 1), new Range32.ptr(120120, 120121, 1), new Range32.ptr(120123, 120126, 1), new Range32.ptr(120128, 120132, 1), new Range32.ptr(120134, 120138, 4), new Range32.ptr(120139, 120144, 1), new Range32.ptr(120172, 120197, 1), new Range32.ptr(120224, 120249, 1), new Range32.ptr(120276, 120301, 1), new Range32.ptr(120328, 120353, 1), new Range32.ptr(120380, 120405, 1), new Range32.ptr(120432, 120457, 1), new Range32.ptr(120488, 120512, 1), new Range32.ptr(120546, 120570, 1), new Range32.ptr(120604, 120628, 1), new Range32.ptr(120662, 120686, 1), new Range32.ptr(120720, 120744, 1), new Range32.ptr(120778, 125184, 4406), new Range32.ptr(125185, 125217, 1)]), 3);
		_M = new RangeTable.ptr(new sliceType([new Range16.ptr(768, 879, 1), new Range16.ptr(1155, 1161, 1), new Range16.ptr(1425, 1469, 1), new Range16.ptr(1471, 1473, 2), new Range16.ptr(1474, 1476, 2), new Range16.ptr(1477, 1479, 2), new Range16.ptr(1552, 1562, 1), new Range16.ptr(1611, 1631, 1), new Range16.ptr(1648, 1750, 102), new Range16.ptr(1751, 1756, 1), new Range16.ptr(1759, 1764, 1), new Range16.ptr(1767, 1768, 1), new Range16.ptr(1770, 1773, 1), new Range16.ptr(1809, 1840, 31), new Range16.ptr(1841, 1866, 1), new Range16.ptr(1958, 1968, 1), new Range16.ptr(2027, 2035, 1), new Range16.ptr(2070, 2073, 1), new Range16.ptr(2075, 2083, 1), new Range16.ptr(2085, 2087, 1), new Range16.ptr(2089, 2093, 1), new Range16.ptr(2137, 2139, 1), new Range16.ptr(2260, 2273, 1), new Range16.ptr(2275, 2307, 1), new Range16.ptr(2362, 2364, 1), new Range16.ptr(2366, 2383, 1), new Range16.ptr(2385, 2391, 1), new Range16.ptr(2402, 2403, 1), new Range16.ptr(2433, 2435, 1), new Range16.ptr(2492, 2494, 2), new Range16.ptr(2495, 2500, 1), new Range16.ptr(2503, 2504, 1), new Range16.ptr(2507, 2509, 1), new Range16.ptr(2519, 2530, 11), new Range16.ptr(2531, 2561, 30), new Range16.ptr(2562, 2563, 1), new Range16.ptr(2620, 2622, 2), new Range16.ptr(2623, 2626, 1), new Range16.ptr(2631, 2632, 1), new Range16.ptr(2635, 2637, 1), new Range16.ptr(2641, 2672, 31), new Range16.ptr(2673, 2677, 4), new Range16.ptr(2689, 2691, 1), new Range16.ptr(2748, 2750, 2), new Range16.ptr(2751, 2757, 1), new Range16.ptr(2759, 2761, 1), new Range16.ptr(2763, 2765, 1), new Range16.ptr(2786, 2787, 1), new Range16.ptr(2810, 2815, 1), new Range16.ptr(2817, 2819, 1), new Range16.ptr(2876, 2878, 2), new Range16.ptr(2879, 2884, 1), new Range16.ptr(2887, 2888, 1), new Range16.ptr(2891, 2893, 1), new Range16.ptr(2902, 2903, 1), new Range16.ptr(2914, 2915, 1), new Range16.ptr(2946, 3006, 60), new Range16.ptr(3007, 3010, 1), new Range16.ptr(3014, 3016, 1), new Range16.ptr(3018, 3021, 1), new Range16.ptr(3031, 3072, 41), new Range16.ptr(3073, 3075, 1), new Range16.ptr(3134, 3140, 1), new Range16.ptr(3142, 3144, 1), new Range16.ptr(3146, 3149, 1), new Range16.ptr(3157, 3158, 1), new Range16.ptr(3170, 3171, 1), new Range16.ptr(3201, 3203, 1), new Range16.ptr(3260, 3262, 2), new Range16.ptr(3263, 3268, 1), new Range16.ptr(3270, 3272, 1), new Range16.ptr(3274, 3277, 1), new Range16.ptr(3285, 3286, 1), new Range16.ptr(3298, 3299, 1), new Range16.ptr(3328, 3331, 1), new Range16.ptr(3387, 3388, 1), new Range16.ptr(3390, 3396, 1), new Range16.ptr(3398, 3400, 1), new Range16.ptr(3402, 3405, 1), new Range16.ptr(3415, 3426, 11), new Range16.ptr(3427, 3458, 31), new Range16.ptr(3459, 3530, 71), new Range16.ptr(3535, 3540, 1), new Range16.ptr(3542, 3544, 2), new Range16.ptr(3545, 3551, 1), new Range16.ptr(3570, 3571, 1), new Range16.ptr(3633, 3636, 3), new Range16.ptr(3637, 3642, 1), new Range16.ptr(3655, 3662, 1), new Range16.ptr(3761, 3764, 3), new Range16.ptr(3765, 3769, 1), new Range16.ptr(3771, 3772, 1), new Range16.ptr(3784, 3789, 1), new Range16.ptr(3864, 3865, 1), new Range16.ptr(3893, 3897, 2), new Range16.ptr(3902, 3903, 1), new Range16.ptr(3953, 3972, 1), new Range16.ptr(3974, 3975, 1), new Range16.ptr(3981, 3991, 1), new Range16.ptr(3993, 4028, 1), new Range16.ptr(4038, 4139, 101), new Range16.ptr(4140, 4158, 1), new Range16.ptr(4182, 4185, 1), new Range16.ptr(4190, 4192, 1), new Range16.ptr(4194, 4196, 1), new Range16.ptr(4199, 4205, 1), new Range16.ptr(4209, 4212, 1), new Range16.ptr(4226, 4237, 1), new Range16.ptr(4239, 4250, 11), new Range16.ptr(4251, 4253, 1), new Range16.ptr(4957, 4959, 1), new Range16.ptr(5906, 5908, 1), new Range16.ptr(5938, 5940, 1), new Range16.ptr(5970, 5971, 1), new Range16.ptr(6002, 6003, 1), new Range16.ptr(6068, 6099, 1), new Range16.ptr(6109, 6155, 46), new Range16.ptr(6156, 6157, 1), new Range16.ptr(6277, 6278, 1), new Range16.ptr(6313, 6432, 119), new Range16.ptr(6433, 6443, 1), new Range16.ptr(6448, 6459, 1), new Range16.ptr(6679, 6683, 1), new Range16.ptr(6741, 6750, 1), new Range16.ptr(6752, 6780, 1), new Range16.ptr(6783, 6832, 49), new Range16.ptr(6833, 6846, 1), new Range16.ptr(6912, 6916, 1), new Range16.ptr(6964, 6980, 1), new Range16.ptr(7019, 7027, 1), new Range16.ptr(7040, 7042, 1), new Range16.ptr(7073, 7085, 1), new Range16.ptr(7142, 7155, 1), new Range16.ptr(7204, 7223, 1), new Range16.ptr(7376, 7378, 1), new Range16.ptr(7380, 7400, 1), new Range16.ptr(7405, 7410, 5), new Range16.ptr(7411, 7412, 1), new Range16.ptr(7415, 7417, 1), new Range16.ptr(7616, 7673, 1), new Range16.ptr(7675, 7679, 1), new Range16.ptr(8400, 8432, 1), new Range16.ptr(11503, 11505, 1), new Range16.ptr(11647, 11744, 97), new Range16.ptr(11745, 11775, 1), new Range16.ptr(12330, 12335, 1), new Range16.ptr(12441, 12442, 1), new Range16.ptr(42607, 42610, 1), new Range16.ptr(42612, 42621, 1), new Range16.ptr(42654, 42655, 1), new Range16.ptr(42736, 42737, 1), new Range16.ptr(43010, 43014, 4), new Range16.ptr(43019, 43043, 24), new Range16.ptr(43044, 43047, 1), new Range16.ptr(43136, 43137, 1), new Range16.ptr(43188, 43205, 1), new Range16.ptr(43232, 43249, 1), new Range16.ptr(43302, 43309, 1), new Range16.ptr(43335, 43347, 1), new Range16.ptr(43392, 43395, 1), new Range16.ptr(43443, 43456, 1), new Range16.ptr(43493, 43561, 68), new Range16.ptr(43562, 43574, 1), new Range16.ptr(43587, 43596, 9), new Range16.ptr(43597, 43643, 46), new Range16.ptr(43644, 43645, 1), new Range16.ptr(43696, 43698, 2), new Range16.ptr(43699, 43700, 1), new Range16.ptr(43703, 43704, 1), new Range16.ptr(43710, 43711, 1), new Range16.ptr(43713, 43755, 42), new Range16.ptr(43756, 43759, 1), new Range16.ptr(43765, 43766, 1), new Range16.ptr(44003, 44010, 1), new Range16.ptr(44012, 44013, 1), new Range16.ptr(64286, 65024, 738), new Range16.ptr(65025, 65039, 1), new Range16.ptr(65056, 65071, 1)]), new sliceType$1([new Range32.ptr(66045, 66272, 227), new Range32.ptr(66422, 66426, 1), new Range32.ptr(68097, 68099, 1), new Range32.ptr(68101, 68102, 1), new Range32.ptr(68108, 68111, 1), new Range32.ptr(68152, 68154, 1), new Range32.ptr(68159, 68325, 166), new Range32.ptr(68326, 69632, 1306), new Range32.ptr(69633, 69634, 1), new Range32.ptr(69688, 69702, 1), new Range32.ptr(69759, 69762, 1), new Range32.ptr(69808, 69818, 1), new Range32.ptr(69888, 69890, 1), new Range32.ptr(69927, 69940, 1), new Range32.ptr(70003, 70016, 13), new Range32.ptr(70017, 70018, 1), new Range32.ptr(70067, 70080, 1), new Range32.ptr(70090, 70092, 1), new Range32.ptr(70188, 70199, 1), new Range32.ptr(70206, 70367, 161), new Range32.ptr(70368, 70378, 1), new Range32.ptr(70400, 70403, 1), new Range32.ptr(70460, 70462, 2), new Range32.ptr(70463, 70468, 1), new Range32.ptr(70471, 70472, 1), new Range32.ptr(70475, 70477, 1), new Range32.ptr(70487, 70498, 11), new Range32.ptr(70499, 70502, 3), new Range32.ptr(70503, 70508, 1), new Range32.ptr(70512, 70516, 1), new Range32.ptr(70709, 70726, 1), new Range32.ptr(70832, 70851, 1), new Range32.ptr(71087, 71093, 1), new Range32.ptr(71096, 71104, 1), new Range32.ptr(71132, 71133, 1), new Range32.ptr(71216, 71232, 1), new Range32.ptr(71339, 71351, 1), new Range32.ptr(71453, 71467, 1), new Range32.ptr(72193, 72202, 1), new Range32.ptr(72243, 72249, 1), new Range32.ptr(72251, 72254, 1), new Range32.ptr(72263, 72273, 10), new Range32.ptr(72274, 72283, 1), new Range32.ptr(72330, 72345, 1), new Range32.ptr(72751, 72758, 1), new Range32.ptr(72760, 72767, 1), new Range32.ptr(72850, 72871, 1), new Range32.ptr(72873, 72886, 1), new Range32.ptr(73009, 73014, 1), new Range32.ptr(73018, 73020, 2), new Range32.ptr(73021, 73023, 2), new Range32.ptr(73024, 73029, 1), new Range32.ptr(73031, 92912, 19881), new Range32.ptr(92913, 92916, 1), new Range32.ptr(92976, 92982, 1), new Range32.ptr(94033, 94078, 1), new Range32.ptr(94095, 94098, 1), new Range32.ptr(113821, 113822, 1), new Range32.ptr(119141, 119145, 1), new Range32.ptr(119149, 119154, 1), new Range32.ptr(119163, 119170, 1), new Range32.ptr(119173, 119179, 1), new Range32.ptr(119210, 119213, 1), new Range32.ptr(119362, 119364, 1), new Range32.ptr(121344, 121398, 1), new Range32.ptr(121403, 121452, 1), new Range32.ptr(121461, 121476, 15), new Range32.ptr(121499, 121503, 1), new Range32.ptr(121505, 121519, 1), new Range32.ptr(122880, 122886, 1), new Range32.ptr(122888, 122904, 1), new Range32.ptr(122907, 122913, 1), new Range32.ptr(122915, 122916, 1), new Range32.ptr(122918, 122922, 1), new Range32.ptr(125136, 125142, 1), new Range32.ptr(125252, 125258, 1), new Range32.ptr(917760, 917999, 1)]), 0);
		_Mc = new RangeTable.ptr(new sliceType([new Range16.ptr(2307, 2363, 56), new Range16.ptr(2366, 2368, 1), new Range16.ptr(2377, 2380, 1), new Range16.ptr(2382, 2383, 1), new Range16.ptr(2434, 2435, 1), new Range16.ptr(2494, 2496, 1), new Range16.ptr(2503, 2504, 1), new Range16.ptr(2507, 2508, 1), new Range16.ptr(2519, 2563, 44), new Range16.ptr(2622, 2624, 1), new Range16.ptr(2691, 2750, 59), new Range16.ptr(2751, 2752, 1), new Range16.ptr(2761, 2763, 2), new Range16.ptr(2764, 2818, 54), new Range16.ptr(2819, 2878, 59), new Range16.ptr(2880, 2887, 7), new Range16.ptr(2888, 2891, 3), new Range16.ptr(2892, 2903, 11), new Range16.ptr(3006, 3007, 1), new Range16.ptr(3009, 3010, 1), new Range16.ptr(3014, 3016, 1), new Range16.ptr(3018, 3020, 1), new Range16.ptr(3031, 3073, 42), new Range16.ptr(3074, 3075, 1), new Range16.ptr(3137, 3140, 1), new Range16.ptr(3202, 3203, 1), new Range16.ptr(3262, 3264, 2), new Range16.ptr(3265, 3268, 1), new Range16.ptr(3271, 3272, 1), new Range16.ptr(3274, 3275, 1), new Range16.ptr(3285, 3286, 1), new Range16.ptr(3330, 3331, 1), new Range16.ptr(3390, 3392, 1), new Range16.ptr(3398, 3400, 1), new Range16.ptr(3402, 3404, 1), new Range16.ptr(3415, 3458, 43), new Range16.ptr(3459, 3535, 76), new Range16.ptr(3536, 3537, 1), new Range16.ptr(3544, 3551, 1), new Range16.ptr(3570, 3571, 1), new Range16.ptr(3902, 3903, 1), new Range16.ptr(3967, 4139, 172), new Range16.ptr(4140, 4145, 5), new Range16.ptr(4152, 4155, 3), new Range16.ptr(4156, 4182, 26), new Range16.ptr(4183, 4194, 11), new Range16.ptr(4195, 4196, 1), new Range16.ptr(4199, 4205, 1), new Range16.ptr(4227, 4228, 1), new Range16.ptr(4231, 4236, 1), new Range16.ptr(4239, 4250, 11), new Range16.ptr(4251, 4252, 1), new Range16.ptr(6070, 6078, 8), new Range16.ptr(6079, 6085, 1), new Range16.ptr(6087, 6088, 1), new Range16.ptr(6435, 6438, 1), new Range16.ptr(6441, 6443, 1), new Range16.ptr(6448, 6449, 1), new Range16.ptr(6451, 6456, 1), new Range16.ptr(6681, 6682, 1), new Range16.ptr(6741, 6743, 2), new Range16.ptr(6753, 6755, 2), new Range16.ptr(6756, 6765, 9), new Range16.ptr(6766, 6770, 1), new Range16.ptr(6916, 6965, 49), new Range16.ptr(6971, 6973, 2), new Range16.ptr(6974, 6977, 1), new Range16.ptr(6979, 6980, 1), new Range16.ptr(7042, 7073, 31), new Range16.ptr(7078, 7079, 1), new Range16.ptr(7082, 7143, 61), new Range16.ptr(7146, 7148, 1), new Range16.ptr(7150, 7154, 4), new Range16.ptr(7155, 7204, 49), new Range16.ptr(7205, 7211, 1), new Range16.ptr(7220, 7221, 1), new Range16.ptr(7393, 7410, 17), new Range16.ptr(7411, 7415, 4), new Range16.ptr(12334, 12335, 1), new Range16.ptr(43043, 43044, 1), new Range16.ptr(43047, 43136, 89), new Range16.ptr(43137, 43188, 51), new Range16.ptr(43189, 43203, 1), new Range16.ptr(43346, 43347, 1), new Range16.ptr(43395, 43444, 49), new Range16.ptr(43445, 43450, 5), new Range16.ptr(43451, 43453, 2), new Range16.ptr(43454, 43456, 1), new Range16.ptr(43567, 43568, 1), new Range16.ptr(43571, 43572, 1), new Range16.ptr(43597, 43643, 46), new Range16.ptr(43645, 43755, 110), new Range16.ptr(43758, 43759, 1), new Range16.ptr(43765, 44003, 238), new Range16.ptr(44004, 44006, 2), new Range16.ptr(44007, 44009, 2), new Range16.ptr(44010, 44012, 2)]), new sliceType$1([new Range32.ptr(69632, 69634, 2), new Range32.ptr(69762, 69808, 46), new Range32.ptr(69809, 69810, 1), new Range32.ptr(69815, 69816, 1), new Range32.ptr(69932, 70018, 86), new Range32.ptr(70067, 70069, 1), new Range32.ptr(70079, 70080, 1), new Range32.ptr(70188, 70190, 1), new Range32.ptr(70194, 70195, 1), new Range32.ptr(70197, 70368, 171), new Range32.ptr(70369, 70370, 1), new Range32.ptr(70402, 70403, 1), new Range32.ptr(70462, 70463, 1), new Range32.ptr(70465, 70468, 1), new Range32.ptr(70471, 70472, 1), new Range32.ptr(70475, 70477, 1), new Range32.ptr(70487, 70498, 11), new Range32.ptr(70499, 70709, 210), new Range32.ptr(70710, 70711, 1), new Range32.ptr(70720, 70721, 1), new Range32.ptr(70725, 70832, 107), new Range32.ptr(70833, 70834, 1), new Range32.ptr(70841, 70843, 2), new Range32.ptr(70844, 70846, 1), new Range32.ptr(70849, 71087, 238), new Range32.ptr(71088, 71089, 1), new Range32.ptr(71096, 71099, 1), new Range32.ptr(71102, 71216, 114), new Range32.ptr(71217, 71218, 1), new Range32.ptr(71227, 71228, 1), new Range32.ptr(71230, 71340, 110), new Range32.ptr(71342, 71343, 1), new Range32.ptr(71350, 71456, 106), new Range32.ptr(71457, 71462, 5), new Range32.ptr(72199, 72200, 1), new Range32.ptr(72249, 72279, 30), new Range32.ptr(72280, 72343, 63), new Range32.ptr(72751, 72766, 15), new Range32.ptr(72873, 72881, 8), new Range32.ptr(72884, 94033, 21149), new Range32.ptr(94034, 94078, 1), new Range32.ptr(119141, 119142, 1), new Range32.ptr(119149, 119154, 1)]), 0);
		_Me = new RangeTable.ptr(new sliceType([new Range16.ptr(1160, 1161, 1), new Range16.ptr(6846, 8413, 1567), new Range16.ptr(8414, 8416, 1), new Range16.ptr(8418, 8420, 1), new Range16.ptr(42608, 42610, 1)]), sliceType$1.nil, 0);
		_Mn = new RangeTable.ptr(new sliceType([new Range16.ptr(768, 879, 1), new Range16.ptr(1155, 1159, 1), new Range16.ptr(1425, 1469, 1), new Range16.ptr(1471, 1473, 2), new Range16.ptr(1474, 1476, 2), new Range16.ptr(1477, 1479, 2), new Range16.ptr(1552, 1562, 1), new Range16.ptr(1611, 1631, 1), new Range16.ptr(1648, 1750, 102), new Range16.ptr(1751, 1756, 1), new Range16.ptr(1759, 1764, 1), new Range16.ptr(1767, 1768, 1), new Range16.ptr(1770, 1773, 1), new Range16.ptr(1809, 1840, 31), new Range16.ptr(1841, 1866, 1), new Range16.ptr(1958, 1968, 1), new Range16.ptr(2027, 2035, 1), new Range16.ptr(2070, 2073, 1), new Range16.ptr(2075, 2083, 1), new Range16.ptr(2085, 2087, 1), new Range16.ptr(2089, 2093, 1), new Range16.ptr(2137, 2139, 1), new Range16.ptr(2260, 2273, 1), new Range16.ptr(2275, 2306, 1), new Range16.ptr(2362, 2364, 2), new Range16.ptr(2369, 2376, 1), new Range16.ptr(2381, 2385, 4), new Range16.ptr(2386, 2391, 1), new Range16.ptr(2402, 2403, 1), new Range16.ptr(2433, 2492, 59), new Range16.ptr(2497, 2500, 1), new Range16.ptr(2509, 2530, 21), new Range16.ptr(2531, 2561, 30), new Range16.ptr(2562, 2620, 58), new Range16.ptr(2625, 2626, 1), new Range16.ptr(2631, 2632, 1), new Range16.ptr(2635, 2637, 1), new Range16.ptr(2641, 2672, 31), new Range16.ptr(2673, 2677, 4), new Range16.ptr(2689, 2690, 1), new Range16.ptr(2748, 2753, 5), new Range16.ptr(2754, 2757, 1), new Range16.ptr(2759, 2760, 1), new Range16.ptr(2765, 2786, 21), new Range16.ptr(2787, 2810, 23), new Range16.ptr(2811, 2815, 1), new Range16.ptr(2817, 2876, 59), new Range16.ptr(2879, 2881, 2), new Range16.ptr(2882, 2884, 1), new Range16.ptr(2893, 2902, 9), new Range16.ptr(2914, 2915, 1), new Range16.ptr(2946, 3008, 62), new Range16.ptr(3021, 3072, 51), new Range16.ptr(3134, 3136, 1), new Range16.ptr(3142, 3144, 1), new Range16.ptr(3146, 3149, 1), new Range16.ptr(3157, 3158, 1), new Range16.ptr(3170, 3171, 1), new Range16.ptr(3201, 3260, 59), new Range16.ptr(3263, 3270, 7), new Range16.ptr(3276, 3277, 1), new Range16.ptr(3298, 3299, 1), new Range16.ptr(3328, 3329, 1), new Range16.ptr(3387, 3388, 1), new Range16.ptr(3393, 3396, 1), new Range16.ptr(3405, 3426, 21), new Range16.ptr(3427, 3530, 103), new Range16.ptr(3538, 3540, 1), new Range16.ptr(3542, 3633, 91), new Range16.ptr(3636, 3642, 1), new Range16.ptr(3655, 3662, 1), new Range16.ptr(3761, 3764, 3), new Range16.ptr(3765, 3769, 1), new Range16.ptr(3771, 3772, 1), new Range16.ptr(3784, 3789, 1), new Range16.ptr(3864, 3865, 1), new Range16.ptr(3893, 3897, 2), new Range16.ptr(3953, 3966, 1), new Range16.ptr(3968, 3972, 1), new Range16.ptr(3974, 3975, 1), new Range16.ptr(3981, 3991, 1), new Range16.ptr(3993, 4028, 1), new Range16.ptr(4038, 4141, 103), new Range16.ptr(4142, 4144, 1), new Range16.ptr(4146, 4151, 1), new Range16.ptr(4153, 4154, 1), new Range16.ptr(4157, 4158, 1), new Range16.ptr(4184, 4185, 1), new Range16.ptr(4190, 4192, 1), new Range16.ptr(4209, 4212, 1), new Range16.ptr(4226, 4229, 3), new Range16.ptr(4230, 4237, 7), new Range16.ptr(4253, 4957, 704), new Range16.ptr(4958, 4959, 1), new Range16.ptr(5906, 5908, 1), new Range16.ptr(5938, 5940, 1), new Range16.ptr(5970, 5971, 1), new Range16.ptr(6002, 6003, 1), new Range16.ptr(6068, 6069, 1), new Range16.ptr(6071, 6077, 1), new Range16.ptr(6086, 6089, 3), new Range16.ptr(6090, 6099, 1), new Range16.ptr(6109, 6155, 46), new Range16.ptr(6156, 6157, 1), new Range16.ptr(6277, 6278, 1), new Range16.ptr(6313, 6432, 119), new Range16.ptr(6433, 6434, 1), new Range16.ptr(6439, 6440, 1), new Range16.ptr(6450, 6457, 7), new Range16.ptr(6458, 6459, 1), new Range16.ptr(6679, 6680, 1), new Range16.ptr(6683, 6742, 59), new Range16.ptr(6744, 6750, 1), new Range16.ptr(6752, 6754, 2), new Range16.ptr(6757, 6764, 1), new Range16.ptr(6771, 6780, 1), new Range16.ptr(6783, 6832, 49), new Range16.ptr(6833, 6845, 1), new Range16.ptr(6912, 6915, 1), new Range16.ptr(6964, 6966, 2), new Range16.ptr(6967, 6970, 1), new Range16.ptr(6972, 6978, 6), new Range16.ptr(7019, 7027, 1), new Range16.ptr(7040, 7041, 1), new Range16.ptr(7074, 7077, 1), new Range16.ptr(7080, 7081, 1), new Range16.ptr(7083, 7085, 1), new Range16.ptr(7142, 7144, 2), new Range16.ptr(7145, 7149, 4), new Range16.ptr(7151, 7153, 1), new Range16.ptr(7212, 7219, 1), new Range16.ptr(7222, 7223, 1), new Range16.ptr(7376, 7378, 1), new Range16.ptr(7380, 7392, 1), new Range16.ptr(7394, 7400, 1), new Range16.ptr(7405, 7412, 7), new Range16.ptr(7416, 7417, 1), new Range16.ptr(7616, 7673, 1), new Range16.ptr(7675, 7679, 1), new Range16.ptr(8400, 8412, 1), new Range16.ptr(8417, 8421, 4), new Range16.ptr(8422, 8432, 1), new Range16.ptr(11503, 11505, 1), new Range16.ptr(11647, 11744, 97), new Range16.ptr(11745, 11775, 1), new Range16.ptr(12330, 12333, 1), new Range16.ptr(12441, 12442, 1), new Range16.ptr(42607, 42612, 5), new Range16.ptr(42613, 42621, 1), new Range16.ptr(42654, 42655, 1), new Range16.ptr(42736, 42737, 1), new Range16.ptr(43010, 43014, 4), new Range16.ptr(43019, 43045, 26), new Range16.ptr(43046, 43204, 158), new Range16.ptr(43205, 43232, 27), new Range16.ptr(43233, 43249, 1), new Range16.ptr(43302, 43309, 1), new Range16.ptr(43335, 43345, 1), new Range16.ptr(43392, 43394, 1), new Range16.ptr(43443, 43446, 3), new Range16.ptr(43447, 43449, 1), new Range16.ptr(43452, 43493, 41), new Range16.ptr(43561, 43566, 1), new Range16.ptr(43569, 43570, 1), new Range16.ptr(43573, 43574, 1), new Range16.ptr(43587, 43596, 9), new Range16.ptr(43644, 43696, 52), new Range16.ptr(43698, 43700, 1), new Range16.ptr(43703, 43704, 1), new Range16.ptr(43710, 43711, 1), new Range16.ptr(43713, 43756, 43), new Range16.ptr(43757, 43766, 9), new Range16.ptr(44005, 44008, 3), new Range16.ptr(44013, 64286, 20273), new Range16.ptr(65024, 65039, 1), new Range16.ptr(65056, 65071, 1)]), new sliceType$1([new Range32.ptr(66045, 66272, 227), new Range32.ptr(66422, 66426, 1), new Range32.ptr(68097, 68099, 1), new Range32.ptr(68101, 68102, 1), new Range32.ptr(68108, 68111, 1), new Range32.ptr(68152, 68154, 1), new Range32.ptr(68159, 68325, 166), new Range32.ptr(68326, 69633, 1307), new Range32.ptr(69688, 69702, 1), new Range32.ptr(69759, 69761, 1), new Range32.ptr(69811, 69814, 1), new Range32.ptr(69817, 69818, 1), new Range32.ptr(69888, 69890, 1), new Range32.ptr(69927, 69931, 1), new Range32.ptr(69933, 69940, 1), new Range32.ptr(70003, 70016, 13), new Range32.ptr(70017, 70070, 53), new Range32.ptr(70071, 70078, 1), new Range32.ptr(70090, 70092, 1), new Range32.ptr(70191, 70193, 1), new Range32.ptr(70196, 70198, 2), new Range32.ptr(70199, 70206, 7), new Range32.ptr(70367, 70371, 4), new Range32.ptr(70372, 70378, 1), new Range32.ptr(70400, 70401, 1), new Range32.ptr(70460, 70464, 4), new Range32.ptr(70502, 70508, 1), new Range32.ptr(70512, 70516, 1), new Range32.ptr(70712, 70719, 1), new Range32.ptr(70722, 70724, 1), new Range32.ptr(70726, 70835, 109), new Range32.ptr(70836, 70840, 1), new Range32.ptr(70842, 70847, 5), new Range32.ptr(70848, 70850, 2), new Range32.ptr(70851, 71090, 239), new Range32.ptr(71091, 71093, 1), new Range32.ptr(71100, 71101, 1), new Range32.ptr(71103, 71104, 1), new Range32.ptr(71132, 71133, 1), new Range32.ptr(71219, 71226, 1), new Range32.ptr(71229, 71231, 2), new Range32.ptr(71232, 71339, 107), new Range32.ptr(71341, 71344, 3), new Range32.ptr(71345, 71349, 1), new Range32.ptr(71351, 71453, 102), new Range32.ptr(71454, 71455, 1), new Range32.ptr(71458, 71461, 1), new Range32.ptr(71463, 71467, 1), new Range32.ptr(72193, 72198, 1), new Range32.ptr(72201, 72202, 1), new Range32.ptr(72243, 72248, 1), new Range32.ptr(72251, 72254, 1), new Range32.ptr(72263, 72273, 10), new Range32.ptr(72274, 72278, 1), new Range32.ptr(72281, 72283, 1), new Range32.ptr(72330, 72342, 1), new Range32.ptr(72344, 72345, 1), new Range32.ptr(72752, 72758, 1), new Range32.ptr(72760, 72765, 1), new Range32.ptr(72767, 72850, 83), new Range32.ptr(72851, 72871, 1), new Range32.ptr(72874, 72880, 1), new Range32.ptr(72882, 72883, 1), new Range32.ptr(72885, 72886, 1), new Range32.ptr(73009, 73014, 1), new Range32.ptr(73018, 73020, 2), new Range32.ptr(73021, 73023, 2), new Range32.ptr(73024, 73029, 1), new Range32.ptr(73031, 92912, 19881), new Range32.ptr(92913, 92916, 1), new Range32.ptr(92976, 92982, 1), new Range32.ptr(94095, 94098, 1), new Range32.ptr(113821, 113822, 1), new Range32.ptr(119143, 119145, 1), new Range32.ptr(119163, 119170, 1), new Range32.ptr(119173, 119179, 1), new Range32.ptr(119210, 119213, 1), new Range32.ptr(119362, 119364, 1), new Range32.ptr(121344, 121398, 1), new Range32.ptr(121403, 121452, 1), new Range32.ptr(121461, 121476, 15), new Range32.ptr(121499, 121503, 1), new Range32.ptr(121505, 121519, 1), new Range32.ptr(122880, 122886, 1), new Range32.ptr(122888, 122904, 1), new Range32.ptr(122907, 122913, 1), new Range32.ptr(122915, 122916, 1), new Range32.ptr(122918, 122922, 1), new Range32.ptr(125136, 125142, 1), new Range32.ptr(125252, 125258, 1), new Range32.ptr(917760, 917999, 1)]), 0);
		_N = new RangeTable.ptr(new sliceType([new Range16.ptr(48, 57, 1), new Range16.ptr(178, 179, 1), new Range16.ptr(185, 188, 3), new Range16.ptr(189, 190, 1), new Range16.ptr(1632, 1641, 1), new Range16.ptr(1776, 1785, 1), new Range16.ptr(1984, 1993, 1), new Range16.ptr(2406, 2415, 1), new Range16.ptr(2534, 2543, 1), new Range16.ptr(2548, 2553, 1), new Range16.ptr(2662, 2671, 1), new Range16.ptr(2790, 2799, 1), new Range16.ptr(2918, 2927, 1), new Range16.ptr(2930, 2935, 1), new Range16.ptr(3046, 3058, 1), new Range16.ptr(3174, 3183, 1), new Range16.ptr(3192, 3198, 1), new Range16.ptr(3302, 3311, 1), new Range16.ptr(3416, 3422, 1), new Range16.ptr(3430, 3448, 1), new Range16.ptr(3558, 3567, 1), new Range16.ptr(3664, 3673, 1), new Range16.ptr(3792, 3801, 1), new Range16.ptr(3872, 3891, 1), new Range16.ptr(4160, 4169, 1), new Range16.ptr(4240, 4249, 1), new Range16.ptr(4969, 4988, 1), new Range16.ptr(5870, 5872, 1), new Range16.ptr(6112, 6121, 1), new Range16.ptr(6128, 6137, 1), new Range16.ptr(6160, 6169, 1), new Range16.ptr(6470, 6479, 1), new Range16.ptr(6608, 6618, 1), new Range16.ptr(6784, 6793, 1), new Range16.ptr(6800, 6809, 1), new Range16.ptr(6992, 7001, 1), new Range16.ptr(7088, 7097, 1), new Range16.ptr(7232, 7241, 1), new Range16.ptr(7248, 7257, 1), new Range16.ptr(8304, 8308, 4), new Range16.ptr(8309, 8313, 1), new Range16.ptr(8320, 8329, 1), new Range16.ptr(8528, 8578, 1), new Range16.ptr(8581, 8585, 1), new Range16.ptr(9312, 9371, 1), new Range16.ptr(9450, 9471, 1), new Range16.ptr(10102, 10131, 1), new Range16.ptr(11517, 12295, 778), new Range16.ptr(12321, 12329, 1), new Range16.ptr(12344, 12346, 1), new Range16.ptr(12690, 12693, 1), new Range16.ptr(12832, 12841, 1), new Range16.ptr(12872, 12879, 1), new Range16.ptr(12881, 12895, 1), new Range16.ptr(12928, 12937, 1), new Range16.ptr(12977, 12991, 1), new Range16.ptr(42528, 42537, 1), new Range16.ptr(42726, 42735, 1), new Range16.ptr(43056, 43061, 1), new Range16.ptr(43216, 43225, 1), new Range16.ptr(43264, 43273, 1), new Range16.ptr(43472, 43481, 1), new Range16.ptr(43504, 43513, 1), new Range16.ptr(43600, 43609, 1), new Range16.ptr(44016, 44025, 1), new Range16.ptr(65296, 65305, 1)]), new sliceType$1([new Range32.ptr(65799, 65843, 1), new Range32.ptr(65856, 65912, 1), new Range32.ptr(65930, 65931, 1), new Range32.ptr(66273, 66299, 1), new Range32.ptr(66336, 66339, 1), new Range32.ptr(66369, 66378, 9), new Range32.ptr(66513, 66517, 1), new Range32.ptr(66720, 66729, 1), new Range32.ptr(67672, 67679, 1), new Range32.ptr(67705, 67711, 1), new Range32.ptr(67751, 67759, 1), new Range32.ptr(67835, 67839, 1), new Range32.ptr(67862, 67867, 1), new Range32.ptr(68028, 68029, 1), new Range32.ptr(68032, 68047, 1), new Range32.ptr(68050, 68095, 1), new Range32.ptr(68160, 68167, 1), new Range32.ptr(68221, 68222, 1), new Range32.ptr(68253, 68255, 1), new Range32.ptr(68331, 68335, 1), new Range32.ptr(68440, 68447, 1), new Range32.ptr(68472, 68479, 1), new Range32.ptr(68521, 68527, 1), new Range32.ptr(68858, 68863, 1), new Range32.ptr(69216, 69246, 1), new Range32.ptr(69714, 69743, 1), new Range32.ptr(69872, 69881, 1), new Range32.ptr(69942, 69951, 1), new Range32.ptr(70096, 70105, 1), new Range32.ptr(70113, 70132, 1), new Range32.ptr(70384, 70393, 1), new Range32.ptr(70736, 70745, 1), new Range32.ptr(70864, 70873, 1), new Range32.ptr(71248, 71257, 1), new Range32.ptr(71360, 71369, 1), new Range32.ptr(71472, 71483, 1), new Range32.ptr(71904, 71922, 1), new Range32.ptr(72784, 72812, 1), new Range32.ptr(73040, 73049, 1), new Range32.ptr(74752, 74862, 1), new Range32.ptr(92768, 92777, 1), new Range32.ptr(93008, 93017, 1), new Range32.ptr(93019, 93025, 1), new Range32.ptr(119648, 119665, 1), new Range32.ptr(120782, 120831, 1), new Range32.ptr(125127, 125135, 1), new Range32.ptr(125264, 125273, 1), new Range32.ptr(127232, 127244, 1)]), 4);
		_Nd = new RangeTable.ptr(new sliceType([new Range16.ptr(48, 57, 1), new Range16.ptr(1632, 1641, 1), new Range16.ptr(1776, 1785, 1), new Range16.ptr(1984, 1993, 1), new Range16.ptr(2406, 2415, 1), new Range16.ptr(2534, 2543, 1), new Range16.ptr(2662, 2671, 1), new Range16.ptr(2790, 2799, 1), new Range16.ptr(2918, 2927, 1), new Range16.ptr(3046, 3055, 1), new Range16.ptr(3174, 3183, 1), new Range16.ptr(3302, 3311, 1), new Range16.ptr(3430, 3439, 1), new Range16.ptr(3558, 3567, 1), new Range16.ptr(3664, 3673, 1), new Range16.ptr(3792, 3801, 1), new Range16.ptr(3872, 3881, 1), new Range16.ptr(4160, 4169, 1), new Range16.ptr(4240, 4249, 1), new Range16.ptr(6112, 6121, 1), new Range16.ptr(6160, 6169, 1), new Range16.ptr(6470, 6479, 1), new Range16.ptr(6608, 6617, 1), new Range16.ptr(6784, 6793, 1), new Range16.ptr(6800, 6809, 1), new Range16.ptr(6992, 7001, 1), new Range16.ptr(7088, 7097, 1), new Range16.ptr(7232, 7241, 1), new Range16.ptr(7248, 7257, 1), new Range16.ptr(42528, 42537, 1), new Range16.ptr(43216, 43225, 1), new Range16.ptr(43264, 43273, 1), new Range16.ptr(43472, 43481, 1), new Range16.ptr(43504, 43513, 1), new Range16.ptr(43600, 43609, 1), new Range16.ptr(44016, 44025, 1), new Range16.ptr(65296, 65305, 1)]), new sliceType$1([new Range32.ptr(66720, 66729, 1), new Range32.ptr(69734, 69743, 1), new Range32.ptr(69872, 69881, 1), new Range32.ptr(69942, 69951, 1), new Range32.ptr(70096, 70105, 1), new Range32.ptr(70384, 70393, 1), new Range32.ptr(70736, 70745, 1), new Range32.ptr(70864, 70873, 1), new Range32.ptr(71248, 71257, 1), new Range32.ptr(71360, 71369, 1), new Range32.ptr(71472, 71481, 1), new Range32.ptr(71904, 71913, 1), new Range32.ptr(72784, 72793, 1), new Range32.ptr(73040, 73049, 1), new Range32.ptr(92768, 92777, 1), new Range32.ptr(93008, 93017, 1), new Range32.ptr(120782, 120831, 1), new Range32.ptr(125264, 125273, 1)]), 1);
		_Nl = new RangeTable.ptr(new sliceType([new Range16.ptr(5870, 5872, 1), new Range16.ptr(8544, 8578, 1), new Range16.ptr(8581, 8584, 1), new Range16.ptr(12295, 12321, 26), new Range16.ptr(12322, 12329, 1), new Range16.ptr(12344, 12346, 1), new Range16.ptr(42726, 42735, 1)]), new sliceType$1([new Range32.ptr(65856, 65908, 1), new Range32.ptr(66369, 66378, 9), new Range32.ptr(66513, 66517, 1), new Range32.ptr(74752, 74862, 1)]), 0);
		_No = new RangeTable.ptr(new sliceType([new Range16.ptr(178, 179, 1), new Range16.ptr(185, 188, 3), new Range16.ptr(189, 190, 1), new Range16.ptr(2548, 2553, 1), new Range16.ptr(2930, 2935, 1), new Range16.ptr(3056, 3058, 1), new Range16.ptr(3192, 3198, 1), new Range16.ptr(3416, 3422, 1), new Range16.ptr(3440, 3448, 1), new Range16.ptr(3882, 3891, 1), new Range16.ptr(4969, 4988, 1), new Range16.ptr(6128, 6137, 1), new Range16.ptr(6618, 8304, 1686), new Range16.ptr(8308, 8313, 1), new Range16.ptr(8320, 8329, 1), new Range16.ptr(8528, 8543, 1), new Range16.ptr(8585, 9312, 727), new Range16.ptr(9313, 9371, 1), new Range16.ptr(9450, 9471, 1), new Range16.ptr(10102, 10131, 1), new Range16.ptr(11517, 12690, 1173), new Range16.ptr(12691, 12693, 1), new Range16.ptr(12832, 12841, 1), new Range16.ptr(12872, 12879, 1), new Range16.ptr(12881, 12895, 1), new Range16.ptr(12928, 12937, 1), new Range16.ptr(12977, 12991, 1), new Range16.ptr(43056, 43061, 1)]), new sliceType$1([new Range32.ptr(65799, 65843, 1), new Range32.ptr(65909, 65912, 1), new Range32.ptr(65930, 65931, 1), new Range32.ptr(66273, 66299, 1), new Range32.ptr(66336, 66339, 1), new Range32.ptr(67672, 67679, 1), new Range32.ptr(67705, 67711, 1), new Range32.ptr(67751, 67759, 1), new Range32.ptr(67835, 67839, 1), new Range32.ptr(67862, 67867, 1), new Range32.ptr(68028, 68029, 1), new Range32.ptr(68032, 68047, 1), new Range32.ptr(68050, 68095, 1), new Range32.ptr(68160, 68167, 1), new Range32.ptr(68221, 68222, 1), new Range32.ptr(68253, 68255, 1), new Range32.ptr(68331, 68335, 1), new Range32.ptr(68440, 68447, 1), new Range32.ptr(68472, 68479, 1), new Range32.ptr(68521, 68527, 1), new Range32.ptr(68858, 68863, 1), new Range32.ptr(69216, 69246, 1), new Range32.ptr(69714, 69733, 1), new Range32.ptr(70113, 70132, 1), new Range32.ptr(71482, 71483, 1), new Range32.ptr(71914, 71922, 1), new Range32.ptr(72794, 72812, 1), new Range32.ptr(93019, 93025, 1), new Range32.ptr(119648, 119665, 1), new Range32.ptr(125127, 125135, 1), new Range32.ptr(127232, 127244, 1)]), 3);
		_P = new RangeTable.ptr(new sliceType([new Range16.ptr(33, 35, 1), new Range16.ptr(37, 42, 1), new Range16.ptr(44, 47, 1), new Range16.ptr(58, 59, 1), new Range16.ptr(63, 64, 1), new Range16.ptr(91, 93, 1), new Range16.ptr(95, 123, 28), new Range16.ptr(125, 161, 36), new Range16.ptr(167, 171, 4), new Range16.ptr(182, 183, 1), new Range16.ptr(187, 191, 4), new Range16.ptr(894, 903, 9), new Range16.ptr(1370, 1375, 1), new Range16.ptr(1417, 1418, 1), new Range16.ptr(1470, 1472, 2), new Range16.ptr(1475, 1478, 3), new Range16.ptr(1523, 1524, 1), new Range16.ptr(1545, 1546, 1), new Range16.ptr(1548, 1549, 1), new Range16.ptr(1563, 1566, 3), new Range16.ptr(1567, 1642, 75), new Range16.ptr(1643, 1645, 1), new Range16.ptr(1748, 1792, 44), new Range16.ptr(1793, 1805, 1), new Range16.ptr(2039, 2041, 1), new Range16.ptr(2096, 2110, 1), new Range16.ptr(2142, 2404, 262), new Range16.ptr(2405, 2416, 11), new Range16.ptr(2557, 2800, 243), new Range16.ptr(3572, 3663, 91), new Range16.ptr(3674, 3675, 1), new Range16.ptr(3844, 3858, 1), new Range16.ptr(3860, 3898, 38), new Range16.ptr(3899, 3901, 1), new Range16.ptr(3973, 4048, 75), new Range16.ptr(4049, 4052, 1), new Range16.ptr(4057, 4058, 1), new Range16.ptr(4170, 4175, 1), new Range16.ptr(4347, 4960, 613), new Range16.ptr(4961, 4968, 1), new Range16.ptr(5120, 5741, 621), new Range16.ptr(5742, 5787, 45), new Range16.ptr(5788, 5867, 79), new Range16.ptr(5868, 5869, 1), new Range16.ptr(5941, 5942, 1), new Range16.ptr(6100, 6102, 1), new Range16.ptr(6104, 6106, 1), new Range16.ptr(6144, 6154, 1), new Range16.ptr(6468, 6469, 1), new Range16.ptr(6686, 6687, 1), new Range16.ptr(6816, 6822, 1), new Range16.ptr(6824, 6829, 1), new Range16.ptr(7002, 7008, 1), new Range16.ptr(7164, 7167, 1), new Range16.ptr(7227, 7231, 1), new Range16.ptr(7294, 7295, 1), new Range16.ptr(7360, 7367, 1), new Range16.ptr(7379, 8208, 829), new Range16.ptr(8209, 8231, 1), new Range16.ptr(8240, 8259, 1), new Range16.ptr(8261, 8273, 1), new Range16.ptr(8275, 8286, 1), new Range16.ptr(8317, 8318, 1), new Range16.ptr(8333, 8334, 1), new Range16.ptr(8968, 8971, 1), new Range16.ptr(9001, 9002, 1), new Range16.ptr(10088, 10101, 1), new Range16.ptr(10181, 10182, 1), new Range16.ptr(10214, 10223, 1), new Range16.ptr(10627, 10648, 1), new Range16.ptr(10712, 10715, 1), new Range16.ptr(10748, 10749, 1), new Range16.ptr(11513, 11516, 1), new Range16.ptr(11518, 11519, 1), new Range16.ptr(11632, 11776, 144), new Range16.ptr(11777, 11822, 1), new Range16.ptr(11824, 11849, 1), new Range16.ptr(12289, 12291, 1), new Range16.ptr(12296, 12305, 1), new Range16.ptr(12308, 12319, 1), new Range16.ptr(12336, 12349, 13), new Range16.ptr(12448, 12539, 91), new Range16.ptr(42238, 42239, 1), new Range16.ptr(42509, 42511, 1), new Range16.ptr(42611, 42622, 11), new Range16.ptr(42738, 42743, 1), new Range16.ptr(43124, 43127, 1), new Range16.ptr(43214, 43215, 1), new Range16.ptr(43256, 43258, 1), new Range16.ptr(43260, 43310, 50), new Range16.ptr(43311, 43359, 48), new Range16.ptr(43457, 43469, 1), new Range16.ptr(43486, 43487, 1), new Range16.ptr(43612, 43615, 1), new Range16.ptr(43742, 43743, 1), new Range16.ptr(43760, 43761, 1), new Range16.ptr(44011, 64830, 20819), new Range16.ptr(64831, 65040, 209), new Range16.ptr(65041, 65049, 1), new Range16.ptr(65072, 65106, 1), new Range16.ptr(65108, 65121, 1), new Range16.ptr(65123, 65128, 5), new Range16.ptr(65130, 65131, 1), new Range16.ptr(65281, 65283, 1), new Range16.ptr(65285, 65290, 1), new Range16.ptr(65292, 65295, 1), new Range16.ptr(65306, 65307, 1), new Range16.ptr(65311, 65312, 1), new Range16.ptr(65339, 65341, 1), new Range16.ptr(65343, 65371, 28), new Range16.ptr(65373, 65375, 2), new Range16.ptr(65376, 65381, 1)]), new sliceType$1([new Range32.ptr(65792, 65794, 1), new Range32.ptr(66463, 66512, 49), new Range32.ptr(66927, 67671, 744), new Range32.ptr(67871, 67903, 32), new Range32.ptr(68176, 68184, 1), new Range32.ptr(68223, 68336, 113), new Range32.ptr(68337, 68342, 1), new Range32.ptr(68409, 68415, 1), new Range32.ptr(68505, 68508, 1), new Range32.ptr(69703, 69709, 1), new Range32.ptr(69819, 69820, 1), new Range32.ptr(69822, 69825, 1), new Range32.ptr(69952, 69955, 1), new Range32.ptr(70004, 70005, 1), new Range32.ptr(70085, 70089, 1), new Range32.ptr(70093, 70107, 14), new Range32.ptr(70109, 70111, 1), new Range32.ptr(70200, 70205, 1), new Range32.ptr(70313, 70731, 418), new Range32.ptr(70732, 70735, 1), new Range32.ptr(70747, 70749, 2), new Range32.ptr(70854, 71105, 251), new Range32.ptr(71106, 71127, 1), new Range32.ptr(71233, 71235, 1), new Range32.ptr(71264, 71276, 1), new Range32.ptr(71484, 71486, 1), new Range32.ptr(72255, 72262, 1), new Range32.ptr(72346, 72348, 1), new Range32.ptr(72350, 72354, 1), new Range32.ptr(72769, 72773, 1), new Range32.ptr(72816, 72817, 1), new Range32.ptr(74864, 74868, 1), new Range32.ptr(92782, 92783, 1), new Range32.ptr(92917, 92983, 66), new Range32.ptr(92984, 92987, 1), new Range32.ptr(92996, 113823, 20827), new Range32.ptr(121479, 121483, 1), new Range32.ptr(125278, 125279, 1)]), 11);
		_Pc = new RangeTable.ptr(new sliceType([new Range16.ptr(95, 8255, 8160), new Range16.ptr(8256, 8276, 20), new Range16.ptr(65075, 65076, 1), new Range16.ptr(65101, 65103, 1), new Range16.ptr(65343, 65343, 1)]), sliceType$1.nil, 0);
		_Pd = new RangeTable.ptr(new sliceType([new Range16.ptr(45, 1418, 1373), new Range16.ptr(1470, 5120, 3650), new Range16.ptr(6150, 8208, 2058), new Range16.ptr(8209, 8213, 1), new Range16.ptr(11799, 11802, 3), new Range16.ptr(11834, 11835, 1), new Range16.ptr(11840, 12316, 476), new Range16.ptr(12336, 12448, 112), new Range16.ptr(65073, 65074, 1), new Range16.ptr(65112, 65123, 11), new Range16.ptr(65293, 65293, 1)]), sliceType$1.nil, 0);
		_Pe = new RangeTable.ptr(new sliceType([new Range16.ptr(41, 93, 52), new Range16.ptr(125, 3899, 3774), new Range16.ptr(3901, 5788, 1887), new Range16.ptr(8262, 8318, 56), new Range16.ptr(8334, 8969, 635), new Range16.ptr(8971, 9002, 31), new Range16.ptr(10089, 10101, 2), new Range16.ptr(10182, 10215, 33), new Range16.ptr(10217, 10223, 2), new Range16.ptr(10628, 10648, 2), new Range16.ptr(10713, 10715, 2), new Range16.ptr(10749, 11811, 1062), new Range16.ptr(11813, 11817, 2), new Range16.ptr(12297, 12305, 2), new Range16.ptr(12309, 12315, 2), new Range16.ptr(12318, 12319, 1), new Range16.ptr(64830, 65048, 218), new Range16.ptr(65078, 65092, 2), new Range16.ptr(65096, 65114, 18), new Range16.ptr(65116, 65118, 2), new Range16.ptr(65289, 65341, 52), new Range16.ptr(65373, 65379, 3)]), sliceType$1.nil, 1);
		_Pf = new RangeTable.ptr(new sliceType([new Range16.ptr(187, 8217, 8030), new Range16.ptr(8221, 8250, 29), new Range16.ptr(11779, 11781, 2), new Range16.ptr(11786, 11789, 3), new Range16.ptr(11805, 11809, 4)]), sliceType$1.nil, 0);
		_Pi = new RangeTable.ptr(new sliceType([new Range16.ptr(171, 8216, 8045), new Range16.ptr(8219, 8220, 1), new Range16.ptr(8223, 8249, 26), new Range16.ptr(11778, 11780, 2), new Range16.ptr(11785, 11788, 3), new Range16.ptr(11804, 11808, 4)]), sliceType$1.nil, 0);
		_Po = new RangeTable.ptr(new sliceType([new Range16.ptr(33, 35, 1), new Range16.ptr(37, 39, 1), new Range16.ptr(42, 46, 2), new Range16.ptr(47, 58, 11), new Range16.ptr(59, 63, 4), new Range16.ptr(64, 92, 28), new Range16.ptr(161, 167, 6), new Range16.ptr(182, 183, 1), new Range16.ptr(191, 894, 703), new Range16.ptr(903, 1370, 467), new Range16.ptr(1371, 1375, 1), new Range16.ptr(1417, 1472, 55), new Range16.ptr(1475, 1478, 3), new Range16.ptr(1523, 1524, 1), new Range16.ptr(1545, 1546, 1), new Range16.ptr(1548, 1549, 1), new Range16.ptr(1563, 1566, 3), new Range16.ptr(1567, 1642, 75), new Range16.ptr(1643, 1645, 1), new Range16.ptr(1748, 1792, 44), new Range16.ptr(1793, 1805, 1), new Range16.ptr(2039, 2041, 1), new Range16.ptr(2096, 2110, 1), new Range16.ptr(2142, 2404, 262), new Range16.ptr(2405, 2416, 11), new Range16.ptr(2557, 2800, 243), new Range16.ptr(3572, 3663, 91), new Range16.ptr(3674, 3675, 1), new Range16.ptr(3844, 3858, 1), new Range16.ptr(3860, 3973, 113), new Range16.ptr(4048, 4052, 1), new Range16.ptr(4057, 4058, 1), new Range16.ptr(4170, 4175, 1), new Range16.ptr(4347, 4960, 613), new Range16.ptr(4961, 4968, 1), new Range16.ptr(5741, 5742, 1), new Range16.ptr(5867, 5869, 1), new Range16.ptr(5941, 5942, 1), new Range16.ptr(6100, 6102, 1), new Range16.ptr(6104, 6106, 1), new Range16.ptr(6144, 6149, 1), new Range16.ptr(6151, 6154, 1), new Range16.ptr(6468, 6469, 1), new Range16.ptr(6686, 6687, 1), new Range16.ptr(6816, 6822, 1), new Range16.ptr(6824, 6829, 1), new Range16.ptr(7002, 7008, 1), new Range16.ptr(7164, 7167, 1), new Range16.ptr(7227, 7231, 1), new Range16.ptr(7294, 7295, 1), new Range16.ptr(7360, 7367, 1), new Range16.ptr(7379, 8214, 835), new Range16.ptr(8215, 8224, 9), new Range16.ptr(8225, 8231, 1), new Range16.ptr(8240, 8248, 1), new Range16.ptr(8251, 8254, 1), new Range16.ptr(8257, 8259, 1), new Range16.ptr(8263, 8273, 1), new Range16.ptr(8275, 8277, 2), new Range16.ptr(8278, 8286, 1), new Range16.ptr(11513, 11516, 1), new Range16.ptr(11518, 11519, 1), new Range16.ptr(11632, 11776, 144), new Range16.ptr(11777, 11782, 5), new Range16.ptr(11783, 11784, 1), new Range16.ptr(11787, 11790, 3), new Range16.ptr(11791, 11798, 1), new Range16.ptr(11800, 11801, 1), new Range16.ptr(11803, 11806, 3), new Range16.ptr(11807, 11818, 11), new Range16.ptr(11819, 11822, 1), new Range16.ptr(11824, 11833, 1), new Range16.ptr(11836, 11839, 1), new Range16.ptr(11841, 11843, 2), new Range16.ptr(11844, 11849, 1), new Range16.ptr(12289, 12291, 1), new Range16.ptr(12349, 12539, 190), new Range16.ptr(42238, 42239, 1), new Range16.ptr(42509, 42511, 1), new Range16.ptr(42611, 42622, 11), new Range16.ptr(42738, 42743, 1), new Range16.ptr(43124, 43127, 1), new Range16.ptr(43214, 43215, 1), new Range16.ptr(43256, 43258, 1), new Range16.ptr(43260, 43310, 50), new Range16.ptr(43311, 43359, 48), new Range16.ptr(43457, 43469, 1), new Range16.ptr(43486, 43487, 1), new Range16.ptr(43612, 43615, 1), new Range16.ptr(43742, 43743, 1), new Range16.ptr(43760, 43761, 1), new Range16.ptr(44011, 65040, 21029), new Range16.ptr(65041, 65046, 1), new Range16.ptr(65049, 65072, 23), new Range16.ptr(65093, 65094, 1), new Range16.ptr(65097, 65100, 1), new Range16.ptr(65104, 65106, 1), new Range16.ptr(65108, 65111, 1), new Range16.ptr(65119, 65121, 1), new Range16.ptr(65128, 65130, 2), new Range16.ptr(65131, 65281, 150), new Range16.ptr(65282, 65283, 1), new Range16.ptr(65285, 65287, 1), new Range16.ptr(65290, 65294, 2), new Range16.ptr(65295, 65306, 11), new Range16.ptr(65307, 65311, 4), new Range16.ptr(65312, 65340, 28), new Range16.ptr(65377, 65380, 3), new Range16.ptr(65381, 65381, 1)]), new sliceType$1([new Range32.ptr(65792, 65792, 1), new Range32.ptr(65793, 65794, 1), new Range32.ptr(66463, 66512, 49), new Range32.ptr(66927, 67671, 744), new Range32.ptr(67871, 67903, 32), new Range32.ptr(68176, 68184, 1), new Range32.ptr(68223, 68336, 113), new Range32.ptr(68337, 68342, 1), new Range32.ptr(68409, 68415, 1), new Range32.ptr(68505, 68508, 1), new Range32.ptr(69703, 69709, 1), new Range32.ptr(69819, 69820, 1), new Range32.ptr(69822, 69825, 1), new Range32.ptr(69952, 69955, 1), new Range32.ptr(70004, 70005, 1), new Range32.ptr(70085, 70089, 1), new Range32.ptr(70093, 70107, 14), new Range32.ptr(70109, 70111, 1), new Range32.ptr(70200, 70205, 1), new Range32.ptr(70313, 70731, 418), new Range32.ptr(70732, 70735, 1), new Range32.ptr(70747, 70749, 2), new Range32.ptr(70854, 71105, 251), new Range32.ptr(71106, 71127, 1), new Range32.ptr(71233, 71235, 1), new Range32.ptr(71264, 71276, 1), new Range32.ptr(71484, 71486, 1), new Range32.ptr(72255, 72262, 1), new Range32.ptr(72346, 72348, 1), new Range32.ptr(72350, 72354, 1), new Range32.ptr(72769, 72773, 1), new Range32.ptr(72816, 72817, 1), new Range32.ptr(74864, 74868, 1), new Range32.ptr(92782, 92783, 1), new Range32.ptr(92917, 92983, 66), new Range32.ptr(92984, 92987, 1), new Range32.ptr(92996, 113823, 20827), new Range32.ptr(121479, 121483, 1), new Range32.ptr(125278, 125279, 1)]), 8);
		_Ps = new RangeTable.ptr(new sliceType([new Range16.ptr(40, 91, 51), new Range16.ptr(123, 3898, 3775), new Range16.ptr(3900, 5787, 1887), new Range16.ptr(8218, 8222, 4), new Range16.ptr(8261, 8317, 56), new Range16.ptr(8333, 8968, 635), new Range16.ptr(8970, 9001, 31), new Range16.ptr(10088, 10100, 2), new Range16.ptr(10181, 10214, 33), new Range16.ptr(10216, 10222, 2), new Range16.ptr(10627, 10647, 2), new Range16.ptr(10712, 10714, 2), new Range16.ptr(10748, 11810, 1062), new Range16.ptr(11812, 11816, 2), new Range16.ptr(11842, 12296, 454), new Range16.ptr(12298, 12304, 2), new Range16.ptr(12308, 12314, 2), new Range16.ptr(12317, 64831, 52514), new Range16.ptr(65047, 65077, 30), new Range16.ptr(65079, 65091, 2), new Range16.ptr(65095, 65113, 18), new Range16.ptr(65115, 65117, 2), new Range16.ptr(65288, 65339, 51), new Range16.ptr(65371, 65375, 4), new Range16.ptr(65378, 65378, 1)]), sliceType$1.nil, 1);
		_S = new RangeTable.ptr(new sliceType([new Range16.ptr(36, 43, 7), new Range16.ptr(60, 62, 1), new Range16.ptr(94, 96, 2), new Range16.ptr(124, 126, 2), new Range16.ptr(162, 166, 1), new Range16.ptr(168, 169, 1), new Range16.ptr(172, 174, 2), new Range16.ptr(175, 177, 1), new Range16.ptr(180, 184, 4), new Range16.ptr(215, 247, 32), new Range16.ptr(706, 709, 1), new Range16.ptr(722, 735, 1), new Range16.ptr(741, 747, 1), new Range16.ptr(749, 751, 2), new Range16.ptr(752, 767, 1), new Range16.ptr(885, 900, 15), new Range16.ptr(901, 1014, 113), new Range16.ptr(1154, 1421, 267), new Range16.ptr(1422, 1423, 1), new Range16.ptr(1542, 1544, 1), new Range16.ptr(1547, 1550, 3), new Range16.ptr(1551, 1758, 207), new Range16.ptr(1769, 1789, 20), new Range16.ptr(1790, 2038, 248), new Range16.ptr(2546, 2547, 1), new Range16.ptr(2554, 2555, 1), new Range16.ptr(2801, 2928, 127), new Range16.ptr(3059, 3066, 1), new Range16.ptr(3199, 3407, 208), new Range16.ptr(3449, 3647, 198), new Range16.ptr(3841, 3843, 1), new Range16.ptr(3859, 3861, 2), new Range16.ptr(3862, 3863, 1), new Range16.ptr(3866, 3871, 1), new Range16.ptr(3892, 3896, 2), new Range16.ptr(4030, 4037, 1), new Range16.ptr(4039, 4044, 1), new Range16.ptr(4046, 4047, 1), new Range16.ptr(4053, 4056, 1), new Range16.ptr(4254, 4255, 1), new Range16.ptr(5008, 5017, 1), new Range16.ptr(6107, 6464, 357), new Range16.ptr(6622, 6655, 1), new Range16.ptr(7009, 7018, 1), new Range16.ptr(7028, 7036, 1), new Range16.ptr(8125, 8127, 2), new Range16.ptr(8128, 8129, 1), new Range16.ptr(8141, 8143, 1), new Range16.ptr(8157, 8159, 1), new Range16.ptr(8173, 8175, 1), new Range16.ptr(8189, 8190, 1), new Range16.ptr(8260, 8274, 14), new Range16.ptr(8314, 8316, 1), new Range16.ptr(8330, 8332, 1), new Range16.ptr(8352, 8383, 1), new Range16.ptr(8448, 8449, 1), new Range16.ptr(8451, 8454, 1), new Range16.ptr(8456, 8457, 1), new Range16.ptr(8468, 8470, 2), new Range16.ptr(8471, 8472, 1), new Range16.ptr(8478, 8483, 1), new Range16.ptr(8485, 8489, 2), new Range16.ptr(8494, 8506, 12), new Range16.ptr(8507, 8512, 5), new Range16.ptr(8513, 8516, 1), new Range16.ptr(8522, 8525, 1), new Range16.ptr(8527, 8586, 59), new Range16.ptr(8587, 8592, 5), new Range16.ptr(8593, 8967, 1), new Range16.ptr(8972, 9000, 1), new Range16.ptr(9003, 9254, 1), new Range16.ptr(9280, 9290, 1), new Range16.ptr(9372, 9449, 1), new Range16.ptr(9472, 10087, 1), new Range16.ptr(10132, 10180, 1), new Range16.ptr(10183, 10213, 1), new Range16.ptr(10224, 10626, 1), new Range16.ptr(10649, 10711, 1), new Range16.ptr(10716, 10747, 1), new Range16.ptr(10750, 11123, 1), new Range16.ptr(11126, 11157, 1), new Range16.ptr(11160, 11193, 1), new Range16.ptr(11197, 11208, 1), new Range16.ptr(11210, 11218, 1), new Range16.ptr(11244, 11247, 1), new Range16.ptr(11493, 11498, 1), new Range16.ptr(11904, 11929, 1), new Range16.ptr(11931, 12019, 1), new Range16.ptr(12032, 12245, 1), new Range16.ptr(12272, 12283, 1), new Range16.ptr(12292, 12306, 14), new Range16.ptr(12307, 12320, 13), new Range16.ptr(12342, 12343, 1), new Range16.ptr(12350, 12351, 1), new Range16.ptr(12443, 12444, 1), new Range16.ptr(12688, 12689, 1), new Range16.ptr(12694, 12703, 1), new Range16.ptr(12736, 12771, 1), new Range16.ptr(12800, 12830, 1), new Range16.ptr(12842, 12871, 1), new Range16.ptr(12880, 12896, 16), new Range16.ptr(12897, 12927, 1), new Range16.ptr(12938, 12976, 1), new Range16.ptr(12992, 13054, 1), new Range16.ptr(13056, 13311, 1), new Range16.ptr(19904, 19967, 1), new Range16.ptr(42128, 42182, 1), new Range16.ptr(42752, 42774, 1), new Range16.ptr(42784, 42785, 1), new Range16.ptr(42889, 42890, 1), new Range16.ptr(43048, 43051, 1), new Range16.ptr(43062, 43065, 1), new Range16.ptr(43639, 43641, 1), new Range16.ptr(43867, 64297, 20430), new Range16.ptr(64434, 64449, 1), new Range16.ptr(65020, 65021, 1), new Range16.ptr(65122, 65124, 2), new Range16.ptr(65125, 65126, 1), new Range16.ptr(65129, 65284, 155), new Range16.ptr(65291, 65308, 17), new Range16.ptr(65309, 65310, 1), new Range16.ptr(65342, 65344, 2), new Range16.ptr(65372, 65374, 2), new Range16.ptr(65504, 65510, 1), new Range16.ptr(65512, 65518, 1), new Range16.ptr(65532, 65533, 1)]), new sliceType$1([new Range32.ptr(65847, 65855, 1), new Range32.ptr(65913, 65929, 1), new Range32.ptr(65932, 65934, 1), new Range32.ptr(65936, 65947, 1), new Range32.ptr(65952, 66000, 48), new Range32.ptr(66001, 66044, 1), new Range32.ptr(67703, 67704, 1), new Range32.ptr(68296, 71487, 3191), new Range32.ptr(92988, 92991, 1), new Range32.ptr(92997, 113820, 20823), new Range32.ptr(118784, 119029, 1), new Range32.ptr(119040, 119078, 1), new Range32.ptr(119081, 119140, 1), new Range32.ptr(119146, 119148, 1), new Range32.ptr(119171, 119172, 1), new Range32.ptr(119180, 119209, 1), new Range32.ptr(119214, 119272, 1), new Range32.ptr(119296, 119361, 1), new Range32.ptr(119365, 119552, 187), new Range32.ptr(119553, 119638, 1), new Range32.ptr(120513, 120539, 26), new Range32.ptr(120571, 120597, 26), new Range32.ptr(120629, 120655, 26), new Range32.ptr(120687, 120713, 26), new Range32.ptr(120745, 120771, 26), new Range32.ptr(120832, 121343, 1), new Range32.ptr(121399, 121402, 1), new Range32.ptr(121453, 121460, 1), new Range32.ptr(121462, 121475, 1), new Range32.ptr(121477, 121478, 1), new Range32.ptr(126704, 126705, 1), new Range32.ptr(126976, 127019, 1), new Range32.ptr(127024, 127123, 1), new Range32.ptr(127136, 127150, 1), new Range32.ptr(127153, 127167, 1), new Range32.ptr(127169, 127183, 1), new Range32.ptr(127185, 127221, 1), new Range32.ptr(127248, 127278, 1), new Range32.ptr(127280, 127339, 1), new Range32.ptr(127344, 127404, 1), new Range32.ptr(127462, 127490, 1), new Range32.ptr(127504, 127547, 1), new Range32.ptr(127552, 127560, 1), new Range32.ptr(127568, 127569, 1), new Range32.ptr(127584, 127589, 1), new Range32.ptr(127744, 128724, 1), new Range32.ptr(128736, 128748, 1), new Range32.ptr(128752, 128760, 1), new Range32.ptr(128768, 128883, 1), new Range32.ptr(128896, 128980, 1), new Range32.ptr(129024, 129035, 1), new Range32.ptr(129040, 129095, 1), new Range32.ptr(129104, 129113, 1), new Range32.ptr(129120, 129159, 1), new Range32.ptr(129168, 129197, 1), new Range32.ptr(129280, 129291, 1), new Range32.ptr(129296, 129342, 1), new Range32.ptr(129344, 129356, 1), new Range32.ptr(129360, 129387, 1), new Range32.ptr(129408, 129431, 1), new Range32.ptr(129472, 129488, 16), new Range32.ptr(129489, 129510, 1)]), 10);
		_Sc = new RangeTable.ptr(new sliceType([new Range16.ptr(36, 162, 126), new Range16.ptr(163, 165, 1), new Range16.ptr(1423, 1547, 124), new Range16.ptr(2546, 2547, 1), new Range16.ptr(2555, 2801, 246), new Range16.ptr(3065, 3647, 582), new Range16.ptr(6107, 8352, 2245), new Range16.ptr(8353, 8383, 1), new Range16.ptr(43064, 65020, 21956), new Range16.ptr(65129, 65284, 155), new Range16.ptr(65504, 65505, 1), new Range16.ptr(65509, 65510, 1)]), sliceType$1.nil, 2);
		_Sk = new RangeTable.ptr(new sliceType([new Range16.ptr(94, 96, 2), new Range16.ptr(168, 175, 7), new Range16.ptr(180, 184, 4), new Range16.ptr(706, 709, 1), new Range16.ptr(722, 735, 1), new Range16.ptr(741, 747, 1), new Range16.ptr(749, 751, 2), new Range16.ptr(752, 767, 1), new Range16.ptr(885, 900, 15), new Range16.ptr(901, 8125, 7224), new Range16.ptr(8127, 8129, 1), new Range16.ptr(8141, 8143, 1), new Range16.ptr(8157, 8159, 1), new Range16.ptr(8173, 8175, 1), new Range16.ptr(8189, 8190, 1), new Range16.ptr(12443, 12444, 1), new Range16.ptr(42752, 42774, 1), new Range16.ptr(42784, 42785, 1), new Range16.ptr(42889, 42890, 1), new Range16.ptr(43867, 64434, 20567), new Range16.ptr(64435, 64449, 1), new Range16.ptr(65342, 65344, 2), new Range16.ptr(65507, 65507, 1)]), new sliceType$1([new Range32.ptr(127995, 127995, 1), new Range32.ptr(127996, 127999, 1)]), 3);
		_Sm = new RangeTable.ptr(new sliceType([new Range16.ptr(43, 60, 17), new Range16.ptr(61, 62, 1), new Range16.ptr(124, 126, 2), new Range16.ptr(172, 177, 5), new Range16.ptr(215, 247, 32), new Range16.ptr(1014, 1542, 528), new Range16.ptr(1543, 1544, 1), new Range16.ptr(8260, 8274, 14), new Range16.ptr(8314, 8316, 1), new Range16.ptr(8330, 8332, 1), new Range16.ptr(8472, 8512, 40), new Range16.ptr(8513, 8516, 1), new Range16.ptr(8523, 8592, 69), new Range16.ptr(8593, 8596, 1), new Range16.ptr(8602, 8603, 1), new Range16.ptr(8608, 8614, 3), new Range16.ptr(8622, 8654, 32), new Range16.ptr(8655, 8658, 3), new Range16.ptr(8660, 8692, 32), new Range16.ptr(8693, 8959, 1), new Range16.ptr(8992, 8993, 1), new Range16.ptr(9084, 9115, 31), new Range16.ptr(9116, 9139, 1), new Range16.ptr(9180, 9185, 1), new Range16.ptr(9655, 9665, 10), new Range16.ptr(9720, 9727, 1), new Range16.ptr(9839, 10176, 337), new Range16.ptr(10177, 10180, 1), new Range16.ptr(10183, 10213, 1), new Range16.ptr(10224, 10239, 1), new Range16.ptr(10496, 10626, 1), new Range16.ptr(10649, 10711, 1), new Range16.ptr(10716, 10747, 1), new Range16.ptr(10750, 11007, 1), new Range16.ptr(11056, 11076, 1), new Range16.ptr(11079, 11084, 1), new Range16.ptr(64297, 65122, 825), new Range16.ptr(65124, 65126, 1), new Range16.ptr(65291, 65308, 17), new Range16.ptr(65309, 65310, 1), new Range16.ptr(65372, 65374, 2), new Range16.ptr(65506, 65513, 7), new Range16.ptr(65514, 65516, 1)]), new sliceType$1([new Range32.ptr(120513, 120539, 26), new Range32.ptr(120571, 120597, 26), new Range32.ptr(120629, 120655, 26), new Range32.ptr(120687, 120713, 26), new Range32.ptr(120745, 120771, 26), new Range32.ptr(126704, 126705, 1)]), 5);
		_So = new RangeTable.ptr(new sliceType([new Range16.ptr(166, 169, 3), new Range16.ptr(174, 176, 2), new Range16.ptr(1154, 1421, 267), new Range16.ptr(1422, 1550, 128), new Range16.ptr(1551, 1758, 207), new Range16.ptr(1769, 1789, 20), new Range16.ptr(1790, 2038, 248), new Range16.ptr(2554, 2928, 374), new Range16.ptr(3059, 3064, 1), new Range16.ptr(3066, 3199, 133), new Range16.ptr(3407, 3449, 42), new Range16.ptr(3841, 3843, 1), new Range16.ptr(3859, 3861, 2), new Range16.ptr(3862, 3863, 1), new Range16.ptr(3866, 3871, 1), new Range16.ptr(3892, 3896, 2), new Range16.ptr(4030, 4037, 1), new Range16.ptr(4039, 4044, 1), new Range16.ptr(4046, 4047, 1), new Range16.ptr(4053, 4056, 1), new Range16.ptr(4254, 4255, 1), new Range16.ptr(5008, 5017, 1), new Range16.ptr(6464, 6622, 158), new Range16.ptr(6623, 6655, 1), new Range16.ptr(7009, 7018, 1), new Range16.ptr(7028, 7036, 1), new Range16.ptr(8448, 8449, 1), new Range16.ptr(8451, 8454, 1), new Range16.ptr(8456, 8457, 1), new Range16.ptr(8468, 8470, 2), new Range16.ptr(8471, 8478, 7), new Range16.ptr(8479, 8483, 1), new Range16.ptr(8485, 8489, 2), new Range16.ptr(8494, 8506, 12), new Range16.ptr(8507, 8522, 15), new Range16.ptr(8524, 8525, 1), new Range16.ptr(8527, 8586, 59), new Range16.ptr(8587, 8597, 10), new Range16.ptr(8598, 8601, 1), new Range16.ptr(8604, 8607, 1), new Range16.ptr(8609, 8610, 1), new Range16.ptr(8612, 8613, 1), new Range16.ptr(8615, 8621, 1), new Range16.ptr(8623, 8653, 1), new Range16.ptr(8656, 8657, 1), new Range16.ptr(8659, 8661, 2), new Range16.ptr(8662, 8691, 1), new Range16.ptr(8960, 8967, 1), new Range16.ptr(8972, 8991, 1), new Range16.ptr(8994, 9000, 1), new Range16.ptr(9003, 9083, 1), new Range16.ptr(9085, 9114, 1), new Range16.ptr(9140, 9179, 1), new Range16.ptr(9186, 9254, 1), new Range16.ptr(9280, 9290, 1), new Range16.ptr(9372, 9449, 1), new Range16.ptr(9472, 9654, 1), new Range16.ptr(9656, 9664, 1), new Range16.ptr(9666, 9719, 1), new Range16.ptr(9728, 9838, 1), new Range16.ptr(9840, 10087, 1), new Range16.ptr(10132, 10175, 1), new Range16.ptr(10240, 10495, 1), new Range16.ptr(11008, 11055, 1), new Range16.ptr(11077, 11078, 1), new Range16.ptr(11085, 11123, 1), new Range16.ptr(11126, 11157, 1), new Range16.ptr(11160, 11193, 1), new Range16.ptr(11197, 11208, 1), new Range16.ptr(11210, 11218, 1), new Range16.ptr(11244, 11247, 1), new Range16.ptr(11493, 11498, 1), new Range16.ptr(11904, 11929, 1), new Range16.ptr(11931, 12019, 1), new Range16.ptr(12032, 12245, 1), new Range16.ptr(12272, 12283, 1), new Range16.ptr(12292, 12306, 14), new Range16.ptr(12307, 12320, 13), new Range16.ptr(12342, 12343, 1), new Range16.ptr(12350, 12351, 1), new Range16.ptr(12688, 12689, 1), new Range16.ptr(12694, 12703, 1), new Range16.ptr(12736, 12771, 1), new Range16.ptr(12800, 12830, 1), new Range16.ptr(12842, 12871, 1), new Range16.ptr(12880, 12896, 16), new Range16.ptr(12897, 12927, 1), new Range16.ptr(12938, 12976, 1), new Range16.ptr(12992, 13054, 1), new Range16.ptr(13056, 13311, 1), new Range16.ptr(19904, 19967, 1), new Range16.ptr(42128, 42182, 1), new Range16.ptr(43048, 43051, 1), new Range16.ptr(43062, 43063, 1), new Range16.ptr(43065, 43639, 574), new Range16.ptr(43640, 43641, 1), new Range16.ptr(65021, 65508, 487), new Range16.ptr(65512, 65517, 5), new Range16.ptr(65518, 65532, 14), new Range16.ptr(65533, 65533, 1)]), new sliceType$1([new Range32.ptr(65847, 65847, 1), new Range32.ptr(65848, 65855, 1), new Range32.ptr(65913, 65929, 1), new Range32.ptr(65932, 65934, 1), new Range32.ptr(65936, 65947, 1), new Range32.ptr(65952, 66000, 48), new Range32.ptr(66001, 66044, 1), new Range32.ptr(67703, 67704, 1), new Range32.ptr(68296, 71487, 3191), new Range32.ptr(92988, 92991, 1), new Range32.ptr(92997, 113820, 20823), new Range32.ptr(118784, 119029, 1), new Range32.ptr(119040, 119078, 1), new Range32.ptr(119081, 119140, 1), new Range32.ptr(119146, 119148, 1), new Range32.ptr(119171, 119172, 1), new Range32.ptr(119180, 119209, 1), new Range32.ptr(119214, 119272, 1), new Range32.ptr(119296, 119361, 1), new Range32.ptr(119365, 119552, 187), new Range32.ptr(119553, 119638, 1), new Range32.ptr(120832, 121343, 1), new Range32.ptr(121399, 121402, 1), new Range32.ptr(121453, 121460, 1), new Range32.ptr(121462, 121475, 1), new Range32.ptr(121477, 121478, 1), new Range32.ptr(126976, 127019, 1), new Range32.ptr(127024, 127123, 1), new Range32.ptr(127136, 127150, 1), new Range32.ptr(127153, 127167, 1), new Range32.ptr(127169, 127183, 1), new Range32.ptr(127185, 127221, 1), new Range32.ptr(127248, 127278, 1), new Range32.ptr(127280, 127339, 1), new Range32.ptr(127344, 127404, 1), new Range32.ptr(127462, 127490, 1), new Range32.ptr(127504, 127547, 1), new Range32.ptr(127552, 127560, 1), new Range32.ptr(127568, 127569, 1), new Range32.ptr(127584, 127589, 1), new Range32.ptr(127744, 127994, 1), new Range32.ptr(128000, 128724, 1), new Range32.ptr(128736, 128748, 1), new Range32.ptr(128752, 128760, 1), new Range32.ptr(128768, 128883, 1), new Range32.ptr(128896, 128980, 1), new Range32.ptr(129024, 129035, 1), new Range32.ptr(129040, 129095, 1), new Range32.ptr(129104, 129113, 1), new Range32.ptr(129120, 129159, 1), new Range32.ptr(129168, 129197, 1), new Range32.ptr(129280, 129291, 1), new Range32.ptr(129296, 129342, 1), new Range32.ptr(129344, 129356, 1), new Range32.ptr(129360, 129387, 1), new Range32.ptr(129408, 129431, 1), new Range32.ptr(129472, 129488, 16), new Range32.ptr(129489, 129510, 1)]), 2);
		_Z = new RangeTable.ptr(new sliceType([new Range16.ptr(32, 160, 128), new Range16.ptr(5760, 8192, 2432), new Range16.ptr(8193, 8202, 1), new Range16.ptr(8232, 8233, 1), new Range16.ptr(8239, 8287, 48), new Range16.ptr(12288, 12288, 1)]), sliceType$1.nil, 1);
		_Zl = new RangeTable.ptr(new sliceType([new Range16.ptr(8232, 8232, 1)]), sliceType$1.nil, 0);
		_Zp = new RangeTable.ptr(new sliceType([new Range16.ptr(8233, 8233, 1)]), sliceType$1.nil, 0);
		_Zs = new RangeTable.ptr(new sliceType([new Range16.ptr(32, 160, 128), new Range16.ptr(5760, 8192, 2432), new Range16.ptr(8193, 8202, 1), new Range16.ptr(8239, 8287, 48), new Range16.ptr(12288, 12288, 1)]), sliceType$1.nil, 1);
		$pkg.Cc = _Cc;
		$pkg.Cf = _Cf;
		$pkg.Co = _Co;
		$pkg.Cs = _Cs;
		$pkg.Digit = _Nd;
		$pkg.Nd = _Nd;
		$pkg.Letter = _L;
		$pkg.L = _L;
		$pkg.Lm = _Lm;
		$pkg.Lo = _Lo;
		$pkg.Ll = _Ll;
		$pkg.M = _M;
		$pkg.Mc = _Mc;
		$pkg.Me = _Me;
		$pkg.Mn = _Mn;
		$pkg.Nl = _Nl;
		$pkg.No = _No;
		$pkg.N = _N;
		$pkg.C = _C;
		$pkg.Pc = _Pc;
		$pkg.Pd = _Pd;
		$pkg.Pe = _Pe;
		$pkg.Pf = _Pf;
		$pkg.Pi = _Pi;
		$pkg.Po = _Po;
		$pkg.Ps = _Ps;
		$pkg.P = _P;
		$pkg.Sc = _Sc;
		$pkg.Sk = _Sk;
		$pkg.Sm = _Sm;
		$pkg.So = _So;
		$pkg.Z = _Z;
		$pkg.S = _S;
		$pkg.PrintRanges = new sliceType$2([$pkg.L, $pkg.M, $pkg.N, $pkg.P, $pkg.S]);
		$pkg.Lt = _Lt;
		$pkg.Lu = _Lu;
		$pkg.Zl = _Zl;
		$pkg.Zp = _Zp;
		$pkg.Zs = _Zs;
		$pkg.Categories = $makeMap($String.keyFor, [{ k: "C", v: $pkg.C }, { k: "Cc", v: $pkg.Cc }, { k: "Cf", v: $pkg.Cf }, { k: "Co", v: $pkg.Co }, { k: "Cs", v: $pkg.Cs }, { k: "L", v: $pkg.L }, { k: "Ll", v: $pkg.Ll }, { k: "Lm", v: $pkg.Lm }, { k: "Lo", v: $pkg.Lo }, { k: "Lt", v: $pkg.Lt }, { k: "Lu", v: $pkg.Lu }, { k: "M", v: $pkg.M }, { k: "Mc", v: $pkg.Mc }, { k: "Me", v: $pkg.Me }, { k: "Mn", v: $pkg.Mn }, { k: "N", v: $pkg.N }, { k: "Nd", v: $pkg.Nd }, { k: "Nl", v: $pkg.Nl }, { k: "No", v: $pkg.No }, { k: "P", v: $pkg.P }, { k: "Pc", v: $pkg.Pc }, { k: "Pd", v: $pkg.Pd }, { k: "Pe", v: $pkg.Pe }, { k: "Pf", v: $pkg.Pf }, { k: "Pi", v: $pkg.Pi }, { k: "Po", v: $pkg.Po }, { k: "Ps", v: $pkg.Ps }, { k: "S", v: $pkg.S }, { k: "Sc", v: $pkg.Sc }, { k: "Sk", v: $pkg.Sk }, { k: "Sm", v: $pkg.Sm }, { k: "So", v: $pkg.So }, { k: "Z", v: $pkg.Z }, { k: "Zl", v: $pkg.Zl }, { k: "Zp", v: $pkg.Zp }, { k: "Zs", v: $pkg.Zs }]);
		_Adlam = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(125184, 125258, 1), new Range32.ptr(125264, 125273, 1), new Range32.ptr(125278, 125279, 1)]), 0);
		_Ahom = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(71424, 71449, 1), new Range32.ptr(71453, 71467, 1), new Range32.ptr(71472, 71487, 1)]), 0);
		_Anatolian_Hieroglyphs = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(82944, 83526, 1)]), 0);
		_Arabic = new RangeTable.ptr(new sliceType([new Range16.ptr(1536, 1540, 1), new Range16.ptr(1542, 1547, 1), new Range16.ptr(1549, 1562, 1), new Range16.ptr(1564, 1564, 1), new Range16.ptr(1566, 1566, 1), new Range16.ptr(1568, 1599, 1), new Range16.ptr(1601, 1610, 1), new Range16.ptr(1622, 1647, 1), new Range16.ptr(1649, 1756, 1), new Range16.ptr(1758, 1791, 1), new Range16.ptr(1872, 1919, 1), new Range16.ptr(2208, 2228, 1), new Range16.ptr(2230, 2237, 1), new Range16.ptr(2260, 2273, 1), new Range16.ptr(2275, 2303, 1), new Range16.ptr(64336, 64449, 1), new Range16.ptr(64467, 64829, 1), new Range16.ptr(64848, 64911, 1), new Range16.ptr(64914, 64967, 1), new Range16.ptr(65008, 65021, 1), new Range16.ptr(65136, 65140, 1), new Range16.ptr(65142, 65276, 1)]), new sliceType$1([new Range32.ptr(69216, 69246, 1), new Range32.ptr(126464, 126467, 1), new Range32.ptr(126469, 126495, 1), new Range32.ptr(126497, 126498, 1), new Range32.ptr(126500, 126500, 1), new Range32.ptr(126503, 126503, 1), new Range32.ptr(126505, 126514, 1), new Range32.ptr(126516, 126519, 1), new Range32.ptr(126521, 126521, 1), new Range32.ptr(126523, 126523, 1), new Range32.ptr(126530, 126530, 1), new Range32.ptr(126535, 126535, 1), new Range32.ptr(126537, 126537, 1), new Range32.ptr(126539, 126539, 1), new Range32.ptr(126541, 126543, 1), new Range32.ptr(126545, 126546, 1), new Range32.ptr(126548, 126548, 1), new Range32.ptr(126551, 126551, 1), new Range32.ptr(126553, 126553, 1), new Range32.ptr(126555, 126555, 1), new Range32.ptr(126557, 126557, 1), new Range32.ptr(126559, 126559, 1), new Range32.ptr(126561, 126562, 1), new Range32.ptr(126564, 126564, 1), new Range32.ptr(126567, 126570, 1), new Range32.ptr(126572, 126578, 1), new Range32.ptr(126580, 126583, 1), new Range32.ptr(126585, 126588, 1), new Range32.ptr(126590, 126590, 1), new Range32.ptr(126592, 126601, 1), new Range32.ptr(126603, 126619, 1), new Range32.ptr(126625, 126627, 1), new Range32.ptr(126629, 126633, 1), new Range32.ptr(126635, 126651, 1), new Range32.ptr(126704, 126705, 1)]), 0);
		_Armenian = new RangeTable.ptr(new sliceType([new Range16.ptr(1329, 1366, 1), new Range16.ptr(1369, 1375, 1), new Range16.ptr(1377, 1415, 1), new Range16.ptr(1418, 1418, 1), new Range16.ptr(1421, 1423, 1), new Range16.ptr(64275, 64279, 1)]), sliceType$1.nil, 0);
		_Avestan = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68352, 68405, 1), new Range32.ptr(68409, 68415, 1)]), 0);
		_Balinese = new RangeTable.ptr(new sliceType([new Range16.ptr(6912, 6987, 1), new Range16.ptr(6992, 7036, 1)]), sliceType$1.nil, 0);
		_Bamum = new RangeTable.ptr(new sliceType([new Range16.ptr(42656, 42743, 1)]), new sliceType$1([new Range32.ptr(92160, 92728, 1)]), 0);
		_Bassa_Vah = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(92880, 92909, 1), new Range32.ptr(92912, 92917, 1)]), 0);
		_Batak = new RangeTable.ptr(new sliceType([new Range16.ptr(7104, 7155, 1), new Range16.ptr(7164, 7167, 1)]), sliceType$1.nil, 0);
		_Bengali = new RangeTable.ptr(new sliceType([new Range16.ptr(2432, 2435, 1), new Range16.ptr(2437, 2444, 1), new Range16.ptr(2447, 2448, 1), new Range16.ptr(2451, 2472, 1), new Range16.ptr(2474, 2480, 1), new Range16.ptr(2482, 2482, 1), new Range16.ptr(2486, 2489, 1), new Range16.ptr(2492, 2500, 1), new Range16.ptr(2503, 2504, 1), new Range16.ptr(2507, 2510, 1), new Range16.ptr(2519, 2519, 1), new Range16.ptr(2524, 2525, 1), new Range16.ptr(2527, 2531, 1), new Range16.ptr(2534, 2557, 1)]), sliceType$1.nil, 0);
		_Bhaiksuki = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(72704, 72712, 1), new Range32.ptr(72714, 72758, 1), new Range32.ptr(72760, 72773, 1), new Range32.ptr(72784, 72812, 1)]), 0);
		_Bopomofo = new RangeTable.ptr(new sliceType([new Range16.ptr(746, 747, 1), new Range16.ptr(12549, 12590, 1), new Range16.ptr(12704, 12730, 1)]), sliceType$1.nil, 0);
		_Brahmi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(69632, 69709, 1), new Range32.ptr(69714, 69743, 1), new Range32.ptr(69759, 69759, 1)]), 0);
		_Braille = new RangeTable.ptr(new sliceType([new Range16.ptr(10240, 10495, 1)]), sliceType$1.nil, 0);
		_Buginese = new RangeTable.ptr(new sliceType([new Range16.ptr(6656, 6683, 1), new Range16.ptr(6686, 6687, 1)]), sliceType$1.nil, 0);
		_Buhid = new RangeTable.ptr(new sliceType([new Range16.ptr(5952, 5971, 1)]), sliceType$1.nil, 0);
		_Canadian_Aboriginal = new RangeTable.ptr(new sliceType([new Range16.ptr(5120, 5759, 1), new Range16.ptr(6320, 6389, 1)]), sliceType$1.nil, 0);
		_Carian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66208, 66256, 1)]), 0);
		_Caucasian_Albanian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66864, 66915, 1), new Range32.ptr(66927, 66927, 1)]), 0);
		_Chakma = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(69888, 69940, 1), new Range32.ptr(69942, 69955, 1)]), 0);
		_Cham = new RangeTable.ptr(new sliceType([new Range16.ptr(43520, 43574, 1), new Range16.ptr(43584, 43597, 1), new Range16.ptr(43600, 43609, 1), new Range16.ptr(43612, 43615, 1)]), sliceType$1.nil, 0);
		_Cherokee = new RangeTable.ptr(new sliceType([new Range16.ptr(5024, 5109, 1), new Range16.ptr(5112, 5117, 1), new Range16.ptr(43888, 43967, 1)]), sliceType$1.nil, 0);
		_Common = new RangeTable.ptr(new sliceType([new Range16.ptr(0, 64, 1), new Range16.ptr(91, 96, 1), new Range16.ptr(123, 169, 1), new Range16.ptr(171, 185, 1), new Range16.ptr(187, 191, 1), new Range16.ptr(215, 215, 1), new Range16.ptr(247, 247, 1), new Range16.ptr(697, 735, 1), new Range16.ptr(741, 745, 1), new Range16.ptr(748, 767, 1), new Range16.ptr(884, 884, 1), new Range16.ptr(894, 894, 1), new Range16.ptr(901, 901, 1), new Range16.ptr(903, 903, 1), new Range16.ptr(1417, 1417, 1), new Range16.ptr(1541, 1541, 1), new Range16.ptr(1548, 1548, 1), new Range16.ptr(1563, 1563, 1), new Range16.ptr(1567, 1567, 1), new Range16.ptr(1600, 1600, 1), new Range16.ptr(1757, 1757, 1), new Range16.ptr(2274, 2274, 1), new Range16.ptr(2404, 2405, 1), new Range16.ptr(3647, 3647, 1), new Range16.ptr(4053, 4056, 1), new Range16.ptr(4347, 4347, 1), new Range16.ptr(5867, 5869, 1), new Range16.ptr(5941, 5942, 1), new Range16.ptr(6146, 6147, 1), new Range16.ptr(6149, 6149, 1), new Range16.ptr(7379, 7379, 1), new Range16.ptr(7393, 7393, 1), new Range16.ptr(7401, 7404, 1), new Range16.ptr(7406, 7411, 1), new Range16.ptr(7413, 7415, 1), new Range16.ptr(8192, 8203, 1), new Range16.ptr(8206, 8292, 1), new Range16.ptr(8294, 8304, 1), new Range16.ptr(8308, 8318, 1), new Range16.ptr(8320, 8334, 1), new Range16.ptr(8352, 8383, 1), new Range16.ptr(8448, 8485, 1), new Range16.ptr(8487, 8489, 1), new Range16.ptr(8492, 8497, 1), new Range16.ptr(8499, 8525, 1), new Range16.ptr(8527, 8543, 1), new Range16.ptr(8585, 8587, 1), new Range16.ptr(8592, 9254, 1), new Range16.ptr(9280, 9290, 1), new Range16.ptr(9312, 10239, 1), new Range16.ptr(10496, 11123, 1), new Range16.ptr(11126, 11157, 1), new Range16.ptr(11160, 11193, 1), new Range16.ptr(11197, 11208, 1), new Range16.ptr(11210, 11218, 1), new Range16.ptr(11244, 11247, 1), new Range16.ptr(11776, 11849, 1), new Range16.ptr(12272, 12283, 1), new Range16.ptr(12288, 12292, 1), new Range16.ptr(12294, 12294, 1), new Range16.ptr(12296, 12320, 1), new Range16.ptr(12336, 12343, 1), new Range16.ptr(12348, 12351, 1), new Range16.ptr(12443, 12444, 1), new Range16.ptr(12448, 12448, 1), new Range16.ptr(12539, 12540, 1), new Range16.ptr(12688, 12703, 1), new Range16.ptr(12736, 12771, 1), new Range16.ptr(12832, 12895, 1), new Range16.ptr(12927, 13007, 1), new Range16.ptr(13144, 13311, 1), new Range16.ptr(19904, 19967, 1), new Range16.ptr(42752, 42785, 1), new Range16.ptr(42888, 42890, 1), new Range16.ptr(43056, 43065, 1), new Range16.ptr(43310, 43310, 1), new Range16.ptr(43471, 43471, 1), new Range16.ptr(43867, 43867, 1), new Range16.ptr(64830, 64831, 1), new Range16.ptr(65040, 65049, 1), new Range16.ptr(65072, 65106, 1), new Range16.ptr(65108, 65126, 1), new Range16.ptr(65128, 65131, 1), new Range16.ptr(65279, 65279, 1), new Range16.ptr(65281, 65312, 1), new Range16.ptr(65339, 65344, 1), new Range16.ptr(65371, 65381, 1), new Range16.ptr(65392, 65392, 1), new Range16.ptr(65438, 65439, 1), new Range16.ptr(65504, 65510, 1), new Range16.ptr(65512, 65518, 1), new Range16.ptr(65529, 65533, 1)]), new sliceType$1([new Range32.ptr(65792, 65794, 1), new Range32.ptr(65799, 65843, 1), new Range32.ptr(65847, 65855, 1), new Range32.ptr(65936, 65947, 1), new Range32.ptr(66000, 66044, 1), new Range32.ptr(66273, 66299, 1), new Range32.ptr(113824, 113827, 1), new Range32.ptr(118784, 119029, 1), new Range32.ptr(119040, 119078, 1), new Range32.ptr(119081, 119142, 1), new Range32.ptr(119146, 119162, 1), new Range32.ptr(119171, 119172, 1), new Range32.ptr(119180, 119209, 1), new Range32.ptr(119214, 119272, 1), new Range32.ptr(119552, 119638, 1), new Range32.ptr(119648, 119665, 1), new Range32.ptr(119808, 119892, 1), new Range32.ptr(119894, 119964, 1), new Range32.ptr(119966, 119967, 1), new Range32.ptr(119970, 119970, 1), new Range32.ptr(119973, 119974, 1), new Range32.ptr(119977, 119980, 1), new Range32.ptr(119982, 119993, 1), new Range32.ptr(119995, 119995, 1), new Range32.ptr(119997, 120003, 1), new Range32.ptr(120005, 120069, 1), new Range32.ptr(120071, 120074, 1), new Range32.ptr(120077, 120084, 1), new Range32.ptr(120086, 120092, 1), new Range32.ptr(120094, 120121, 1), new Range32.ptr(120123, 120126, 1), new Range32.ptr(120128, 120132, 1), new Range32.ptr(120134, 120134, 1), new Range32.ptr(120138, 120144, 1), new Range32.ptr(120146, 120485, 1), new Range32.ptr(120488, 120779, 1), new Range32.ptr(120782, 120831, 1), new Range32.ptr(126976, 127019, 1), new Range32.ptr(127024, 127123, 1), new Range32.ptr(127136, 127150, 1), new Range32.ptr(127153, 127167, 1), new Range32.ptr(127169, 127183, 1), new Range32.ptr(127185, 127221, 1), new Range32.ptr(127232, 127244, 1), new Range32.ptr(127248, 127278, 1), new Range32.ptr(127280, 127339, 1), new Range32.ptr(127344, 127404, 1), new Range32.ptr(127462, 127487, 1), new Range32.ptr(127489, 127490, 1), new Range32.ptr(127504, 127547, 1), new Range32.ptr(127552, 127560, 1), new Range32.ptr(127568, 127569, 1), new Range32.ptr(127584, 127589, 1), new Range32.ptr(127744, 128724, 1), new Range32.ptr(128736, 128748, 1), new Range32.ptr(128752, 128760, 1), new Range32.ptr(128768, 128883, 1), new Range32.ptr(128896, 128980, 1), new Range32.ptr(129024, 129035, 1), new Range32.ptr(129040, 129095, 1), new Range32.ptr(129104, 129113, 1), new Range32.ptr(129120, 129159, 1), new Range32.ptr(129168, 129197, 1), new Range32.ptr(129280, 129291, 1), new Range32.ptr(129296, 129342, 1), new Range32.ptr(129344, 129356, 1), new Range32.ptr(129360, 129387, 1), new Range32.ptr(129408, 129431, 1), new Range32.ptr(129472, 129472, 1), new Range32.ptr(129488, 129510, 1), new Range32.ptr(917505, 917505, 1), new Range32.ptr(917536, 917631, 1)]), 7);
		_Coptic = new RangeTable.ptr(new sliceType([new Range16.ptr(994, 1007, 1), new Range16.ptr(11392, 11507, 1), new Range16.ptr(11513, 11519, 1)]), sliceType$1.nil, 0);
		_Cuneiform = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(73728, 74649, 1), new Range32.ptr(74752, 74862, 1), new Range32.ptr(74864, 74868, 1), new Range32.ptr(74880, 75075, 1)]), 0);
		_Cypriot = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67584, 67589, 1), new Range32.ptr(67592, 67592, 1), new Range32.ptr(67594, 67637, 1), new Range32.ptr(67639, 67640, 1), new Range32.ptr(67644, 67644, 1), new Range32.ptr(67647, 67647, 1)]), 0);
		_Cyrillic = new RangeTable.ptr(new sliceType([new Range16.ptr(1024, 1156, 1), new Range16.ptr(1159, 1327, 1), new Range16.ptr(7296, 7304, 1), new Range16.ptr(7467, 7467, 1), new Range16.ptr(7544, 7544, 1), new Range16.ptr(11744, 11775, 1), new Range16.ptr(42560, 42655, 1), new Range16.ptr(65070, 65071, 1)]), sliceType$1.nil, 0);
		_Deseret = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66560, 66639, 1)]), 0);
		_Devanagari = new RangeTable.ptr(new sliceType([new Range16.ptr(2304, 2384, 1), new Range16.ptr(2387, 2403, 1), new Range16.ptr(2406, 2431, 1), new Range16.ptr(43232, 43261, 1)]), sliceType$1.nil, 0);
		_Duployan = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(113664, 113770, 1), new Range32.ptr(113776, 113788, 1), new Range32.ptr(113792, 113800, 1), new Range32.ptr(113808, 113817, 1), new Range32.ptr(113820, 113823, 1)]), 0);
		_Egyptian_Hieroglyphs = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(77824, 78894, 1)]), 0);
		_Elbasan = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66816, 66855, 1)]), 0);
		_Ethiopic = new RangeTable.ptr(new sliceType([new Range16.ptr(4608, 4680, 1), new Range16.ptr(4682, 4685, 1), new Range16.ptr(4688, 4694, 1), new Range16.ptr(4696, 4696, 1), new Range16.ptr(4698, 4701, 1), new Range16.ptr(4704, 4744, 1), new Range16.ptr(4746, 4749, 1), new Range16.ptr(4752, 4784, 1), new Range16.ptr(4786, 4789, 1), new Range16.ptr(4792, 4798, 1), new Range16.ptr(4800, 4800, 1), new Range16.ptr(4802, 4805, 1), new Range16.ptr(4808, 4822, 1), new Range16.ptr(4824, 4880, 1), new Range16.ptr(4882, 4885, 1), new Range16.ptr(4888, 4954, 1), new Range16.ptr(4957, 4988, 1), new Range16.ptr(4992, 5017, 1), new Range16.ptr(11648, 11670, 1), new Range16.ptr(11680, 11686, 1), new Range16.ptr(11688, 11694, 1), new Range16.ptr(11696, 11702, 1), new Range16.ptr(11704, 11710, 1), new Range16.ptr(11712, 11718, 1), new Range16.ptr(11720, 11726, 1), new Range16.ptr(11728, 11734, 1), new Range16.ptr(11736, 11742, 1), new Range16.ptr(43777, 43782, 1), new Range16.ptr(43785, 43790, 1), new Range16.ptr(43793, 43798, 1), new Range16.ptr(43808, 43814, 1), new Range16.ptr(43816, 43822, 1)]), sliceType$1.nil, 0);
		_Georgian = new RangeTable.ptr(new sliceType([new Range16.ptr(4256, 4293, 1), new Range16.ptr(4295, 4295, 1), new Range16.ptr(4301, 4301, 1), new Range16.ptr(4304, 4346, 1), new Range16.ptr(4348, 4351, 1), new Range16.ptr(11520, 11557, 1), new Range16.ptr(11559, 11559, 1), new Range16.ptr(11565, 11565, 1)]), sliceType$1.nil, 0);
		_Glagolitic = new RangeTable.ptr(new sliceType([new Range16.ptr(11264, 11310, 1), new Range16.ptr(11312, 11358, 1)]), new sliceType$1([new Range32.ptr(122880, 122886, 1), new Range32.ptr(122888, 122904, 1), new Range32.ptr(122907, 122913, 1), new Range32.ptr(122915, 122916, 1), new Range32.ptr(122918, 122922, 1)]), 0);
		_Gothic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66352, 66378, 1)]), 0);
		_Grantha = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70400, 70403, 1), new Range32.ptr(70405, 70412, 1), new Range32.ptr(70415, 70416, 1), new Range32.ptr(70419, 70440, 1), new Range32.ptr(70442, 70448, 1), new Range32.ptr(70450, 70451, 1), new Range32.ptr(70453, 70457, 1), new Range32.ptr(70460, 70468, 1), new Range32.ptr(70471, 70472, 1), new Range32.ptr(70475, 70477, 1), new Range32.ptr(70480, 70480, 1), new Range32.ptr(70487, 70487, 1), new Range32.ptr(70493, 70499, 1), new Range32.ptr(70502, 70508, 1), new Range32.ptr(70512, 70516, 1)]), 0);
		_Greek = new RangeTable.ptr(new sliceType([new Range16.ptr(880, 883, 1), new Range16.ptr(885, 887, 1), new Range16.ptr(890, 893, 1), new Range16.ptr(895, 895, 1), new Range16.ptr(900, 900, 1), new Range16.ptr(902, 902, 1), new Range16.ptr(904, 906, 1), new Range16.ptr(908, 908, 1), new Range16.ptr(910, 929, 1), new Range16.ptr(931, 993, 1), new Range16.ptr(1008, 1023, 1), new Range16.ptr(7462, 7466, 1), new Range16.ptr(7517, 7521, 1), new Range16.ptr(7526, 7530, 1), new Range16.ptr(7615, 7615, 1), new Range16.ptr(7936, 7957, 1), new Range16.ptr(7960, 7965, 1), new Range16.ptr(7968, 8005, 1), new Range16.ptr(8008, 8013, 1), new Range16.ptr(8016, 8023, 1), new Range16.ptr(8025, 8025, 1), new Range16.ptr(8027, 8027, 1), new Range16.ptr(8029, 8029, 1), new Range16.ptr(8031, 8061, 1), new Range16.ptr(8064, 8116, 1), new Range16.ptr(8118, 8132, 1), new Range16.ptr(8134, 8147, 1), new Range16.ptr(8150, 8155, 1), new Range16.ptr(8157, 8175, 1), new Range16.ptr(8178, 8180, 1), new Range16.ptr(8182, 8190, 1), new Range16.ptr(8486, 8486, 1), new Range16.ptr(43877, 43877, 1)]), new sliceType$1([new Range32.ptr(65856, 65934, 1), new Range32.ptr(65952, 65952, 1), new Range32.ptr(119296, 119365, 1)]), 0);
		_Gujarati = new RangeTable.ptr(new sliceType([new Range16.ptr(2689, 2691, 1), new Range16.ptr(2693, 2701, 1), new Range16.ptr(2703, 2705, 1), new Range16.ptr(2707, 2728, 1), new Range16.ptr(2730, 2736, 1), new Range16.ptr(2738, 2739, 1), new Range16.ptr(2741, 2745, 1), new Range16.ptr(2748, 2757, 1), new Range16.ptr(2759, 2761, 1), new Range16.ptr(2763, 2765, 1), new Range16.ptr(2768, 2768, 1), new Range16.ptr(2784, 2787, 1), new Range16.ptr(2790, 2801, 1), new Range16.ptr(2809, 2815, 1)]), sliceType$1.nil, 0);
		_Gurmukhi = new RangeTable.ptr(new sliceType([new Range16.ptr(2561, 2563, 1), new Range16.ptr(2565, 2570, 1), new Range16.ptr(2575, 2576, 1), new Range16.ptr(2579, 2600, 1), new Range16.ptr(2602, 2608, 1), new Range16.ptr(2610, 2611, 1), new Range16.ptr(2613, 2614, 1), new Range16.ptr(2616, 2617, 1), new Range16.ptr(2620, 2620, 1), new Range16.ptr(2622, 2626, 1), new Range16.ptr(2631, 2632, 1), new Range16.ptr(2635, 2637, 1), new Range16.ptr(2641, 2641, 1), new Range16.ptr(2649, 2652, 1), new Range16.ptr(2654, 2654, 1), new Range16.ptr(2662, 2677, 1)]), sliceType$1.nil, 0);
		_Han = new RangeTable.ptr(new sliceType([new Range16.ptr(11904, 11929, 1), new Range16.ptr(11931, 12019, 1), new Range16.ptr(12032, 12245, 1), new Range16.ptr(12293, 12293, 1), new Range16.ptr(12295, 12295, 1), new Range16.ptr(12321, 12329, 1), new Range16.ptr(12344, 12347, 1), new Range16.ptr(13312, 19893, 1), new Range16.ptr(19968, 40938, 1), new Range16.ptr(63744, 64109, 1), new Range16.ptr(64112, 64217, 1)]), new sliceType$1([new Range32.ptr(131072, 173782, 1), new Range32.ptr(173824, 177972, 1), new Range32.ptr(177984, 178205, 1), new Range32.ptr(178208, 183969, 1), new Range32.ptr(183984, 191456, 1), new Range32.ptr(194560, 195101, 1)]), 0);
		_Hangul = new RangeTable.ptr(new sliceType([new Range16.ptr(4352, 4607, 1), new Range16.ptr(12334, 12335, 1), new Range16.ptr(12593, 12686, 1), new Range16.ptr(12800, 12830, 1), new Range16.ptr(12896, 12926, 1), new Range16.ptr(43360, 43388, 1), new Range16.ptr(44032, 55203, 1), new Range16.ptr(55216, 55238, 1), new Range16.ptr(55243, 55291, 1), new Range16.ptr(65440, 65470, 1), new Range16.ptr(65474, 65479, 1), new Range16.ptr(65482, 65487, 1), new Range16.ptr(65490, 65495, 1), new Range16.ptr(65498, 65500, 1)]), sliceType$1.nil, 0);
		_Hanunoo = new RangeTable.ptr(new sliceType([new Range16.ptr(5920, 5940, 1)]), sliceType$1.nil, 0);
		_Hatran = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67808, 67826, 1), new Range32.ptr(67828, 67829, 1), new Range32.ptr(67835, 67839, 1)]), 0);
		_Hebrew = new RangeTable.ptr(new sliceType([new Range16.ptr(1425, 1479, 1), new Range16.ptr(1488, 1514, 1), new Range16.ptr(1520, 1524, 1), new Range16.ptr(64285, 64310, 1), new Range16.ptr(64312, 64316, 1), new Range16.ptr(64318, 64318, 1), new Range16.ptr(64320, 64321, 1), new Range16.ptr(64323, 64324, 1), new Range16.ptr(64326, 64335, 1)]), sliceType$1.nil, 0);
		_Hiragana = new RangeTable.ptr(new sliceType([new Range16.ptr(12353, 12438, 1), new Range16.ptr(12445, 12447, 1)]), new sliceType$1([new Range32.ptr(110593, 110878, 1), new Range32.ptr(127488, 127488, 1)]), 0);
		_Imperial_Aramaic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67648, 67669, 1), new Range32.ptr(67671, 67679, 1)]), 0);
		_Inherited = new RangeTable.ptr(new sliceType([new Range16.ptr(768, 879, 1), new Range16.ptr(1157, 1158, 1), new Range16.ptr(1611, 1621, 1), new Range16.ptr(1648, 1648, 1), new Range16.ptr(2385, 2386, 1), new Range16.ptr(6832, 6846, 1), new Range16.ptr(7376, 7378, 1), new Range16.ptr(7380, 7392, 1), new Range16.ptr(7394, 7400, 1), new Range16.ptr(7405, 7405, 1), new Range16.ptr(7412, 7412, 1), new Range16.ptr(7416, 7417, 1), new Range16.ptr(7616, 7673, 1), new Range16.ptr(7675, 7679, 1), new Range16.ptr(8204, 8205, 1), new Range16.ptr(8400, 8432, 1), new Range16.ptr(12330, 12333, 1), new Range16.ptr(12441, 12442, 1), new Range16.ptr(65024, 65039, 1), new Range16.ptr(65056, 65069, 1)]), new sliceType$1([new Range32.ptr(66045, 66045, 1), new Range32.ptr(66272, 66272, 1), new Range32.ptr(119143, 119145, 1), new Range32.ptr(119163, 119170, 1), new Range32.ptr(119173, 119179, 1), new Range32.ptr(119210, 119213, 1), new Range32.ptr(917760, 917999, 1)]), 0);
		_Inscriptional_Pahlavi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68448, 68466, 1), new Range32.ptr(68472, 68479, 1)]), 0);
		_Inscriptional_Parthian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68416, 68437, 1), new Range32.ptr(68440, 68447, 1)]), 0);
		_Javanese = new RangeTable.ptr(new sliceType([new Range16.ptr(43392, 43469, 1), new Range16.ptr(43472, 43481, 1), new Range16.ptr(43486, 43487, 1)]), sliceType$1.nil, 0);
		_Kaithi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(69760, 69825, 1)]), 0);
		_Kannada = new RangeTable.ptr(new sliceType([new Range16.ptr(3200, 3203, 1), new Range16.ptr(3205, 3212, 1), new Range16.ptr(3214, 3216, 1), new Range16.ptr(3218, 3240, 1), new Range16.ptr(3242, 3251, 1), new Range16.ptr(3253, 3257, 1), new Range16.ptr(3260, 3268, 1), new Range16.ptr(3270, 3272, 1), new Range16.ptr(3274, 3277, 1), new Range16.ptr(3285, 3286, 1), new Range16.ptr(3294, 3294, 1), new Range16.ptr(3296, 3299, 1), new Range16.ptr(3302, 3311, 1), new Range16.ptr(3313, 3314, 1)]), sliceType$1.nil, 0);
		_Katakana = new RangeTable.ptr(new sliceType([new Range16.ptr(12449, 12538, 1), new Range16.ptr(12541, 12543, 1), new Range16.ptr(12784, 12799, 1), new Range16.ptr(13008, 13054, 1), new Range16.ptr(13056, 13143, 1), new Range16.ptr(65382, 65391, 1), new Range16.ptr(65393, 65437, 1)]), new sliceType$1([new Range32.ptr(110592, 110592, 1)]), 0);
		_Kayah_Li = new RangeTable.ptr(new sliceType([new Range16.ptr(43264, 43309, 1), new Range16.ptr(43311, 43311, 1)]), sliceType$1.nil, 0);
		_Kharoshthi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68096, 68099, 1), new Range32.ptr(68101, 68102, 1), new Range32.ptr(68108, 68115, 1), new Range32.ptr(68117, 68119, 1), new Range32.ptr(68121, 68147, 1), new Range32.ptr(68152, 68154, 1), new Range32.ptr(68159, 68167, 1), new Range32.ptr(68176, 68184, 1)]), 0);
		_Khmer = new RangeTable.ptr(new sliceType([new Range16.ptr(6016, 6109, 1), new Range16.ptr(6112, 6121, 1), new Range16.ptr(6128, 6137, 1), new Range16.ptr(6624, 6655, 1)]), sliceType$1.nil, 0);
		_Khojki = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70144, 70161, 1), new Range32.ptr(70163, 70206, 1)]), 0);
		_Khudawadi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70320, 70378, 1), new Range32.ptr(70384, 70393, 1)]), 0);
		_Lao = new RangeTable.ptr(new sliceType([new Range16.ptr(3713, 3714, 1), new Range16.ptr(3716, 3716, 1), new Range16.ptr(3719, 3720, 1), new Range16.ptr(3722, 3722, 1), new Range16.ptr(3725, 3725, 1), new Range16.ptr(3732, 3735, 1), new Range16.ptr(3737, 3743, 1), new Range16.ptr(3745, 3747, 1), new Range16.ptr(3749, 3749, 1), new Range16.ptr(3751, 3751, 1), new Range16.ptr(3754, 3755, 1), new Range16.ptr(3757, 3769, 1), new Range16.ptr(3771, 3773, 1), new Range16.ptr(3776, 3780, 1), new Range16.ptr(3782, 3782, 1), new Range16.ptr(3784, 3789, 1), new Range16.ptr(3792, 3801, 1), new Range16.ptr(3804, 3807, 1)]), sliceType$1.nil, 0);
		_Latin = new RangeTable.ptr(new sliceType([new Range16.ptr(65, 90, 1), new Range16.ptr(97, 122, 1), new Range16.ptr(170, 170, 1), new Range16.ptr(186, 186, 1), new Range16.ptr(192, 214, 1), new Range16.ptr(216, 246, 1), new Range16.ptr(248, 696, 1), new Range16.ptr(736, 740, 1), new Range16.ptr(7424, 7461, 1), new Range16.ptr(7468, 7516, 1), new Range16.ptr(7522, 7525, 1), new Range16.ptr(7531, 7543, 1), new Range16.ptr(7545, 7614, 1), new Range16.ptr(7680, 7935, 1), new Range16.ptr(8305, 8305, 1), new Range16.ptr(8319, 8319, 1), new Range16.ptr(8336, 8348, 1), new Range16.ptr(8490, 8491, 1), new Range16.ptr(8498, 8498, 1), new Range16.ptr(8526, 8526, 1), new Range16.ptr(8544, 8584, 1), new Range16.ptr(11360, 11391, 1), new Range16.ptr(42786, 42887, 1), new Range16.ptr(42891, 42926, 1), new Range16.ptr(42928, 42935, 1), new Range16.ptr(42999, 43007, 1), new Range16.ptr(43824, 43866, 1), new Range16.ptr(43868, 43876, 1), new Range16.ptr(64256, 64262, 1), new Range16.ptr(65313, 65338, 1), new Range16.ptr(65345, 65370, 1)]), sliceType$1.nil, 6);
		_Lepcha = new RangeTable.ptr(new sliceType([new Range16.ptr(7168, 7223, 1), new Range16.ptr(7227, 7241, 1), new Range16.ptr(7245, 7247, 1)]), sliceType$1.nil, 0);
		_Limbu = new RangeTable.ptr(new sliceType([new Range16.ptr(6400, 6430, 1), new Range16.ptr(6432, 6443, 1), new Range16.ptr(6448, 6459, 1), new Range16.ptr(6464, 6464, 1), new Range16.ptr(6468, 6479, 1)]), sliceType$1.nil, 0);
		_Linear_A = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67072, 67382, 1), new Range32.ptr(67392, 67413, 1), new Range32.ptr(67424, 67431, 1)]), 0);
		_Linear_B = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(65536, 65547, 1), new Range32.ptr(65549, 65574, 1), new Range32.ptr(65576, 65594, 1), new Range32.ptr(65596, 65597, 1), new Range32.ptr(65599, 65613, 1), new Range32.ptr(65616, 65629, 1), new Range32.ptr(65664, 65786, 1)]), 0);
		_Lisu = new RangeTable.ptr(new sliceType([new Range16.ptr(42192, 42239, 1)]), sliceType$1.nil, 0);
		_Lycian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66176, 66204, 1)]), 0);
		_Lydian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67872, 67897, 1), new Range32.ptr(67903, 67903, 1)]), 0);
		_Mahajani = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(69968, 70006, 1)]), 0);
		_Malayalam = new RangeTable.ptr(new sliceType([new Range16.ptr(3328, 3331, 1), new Range16.ptr(3333, 3340, 1), new Range16.ptr(3342, 3344, 1), new Range16.ptr(3346, 3396, 1), new Range16.ptr(3398, 3400, 1), new Range16.ptr(3402, 3407, 1), new Range16.ptr(3412, 3427, 1), new Range16.ptr(3430, 3455, 1)]), sliceType$1.nil, 0);
		_Mandaic = new RangeTable.ptr(new sliceType([new Range16.ptr(2112, 2139, 1), new Range16.ptr(2142, 2142, 1)]), sliceType$1.nil, 0);
		_Manichaean = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68288, 68326, 1), new Range32.ptr(68331, 68342, 1)]), 0);
		_Marchen = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(72816, 72847, 1), new Range32.ptr(72850, 72871, 1), new Range32.ptr(72873, 72886, 1)]), 0);
		_Masaram_Gondi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(72960, 72966, 1), new Range32.ptr(72968, 72969, 1), new Range32.ptr(72971, 73014, 1), new Range32.ptr(73018, 73018, 1), new Range32.ptr(73020, 73021, 1), new Range32.ptr(73023, 73031, 1), new Range32.ptr(73040, 73049, 1)]), 0);
		_Meetei_Mayek = new RangeTable.ptr(new sliceType([new Range16.ptr(43744, 43766, 1), new Range16.ptr(43968, 44013, 1), new Range16.ptr(44016, 44025, 1)]), sliceType$1.nil, 0);
		_Mende_Kikakui = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(124928, 125124, 1), new Range32.ptr(125127, 125142, 1)]), 0);
		_Meroitic_Cursive = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68000, 68023, 1), new Range32.ptr(68028, 68047, 1), new Range32.ptr(68050, 68095, 1)]), 0);
		_Meroitic_Hieroglyphs = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67968, 67999, 1)]), 0);
		_Miao = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(93952, 94020, 1), new Range32.ptr(94032, 94078, 1), new Range32.ptr(94095, 94111, 1)]), 0);
		_Modi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(71168, 71236, 1), new Range32.ptr(71248, 71257, 1)]), 0);
		_Mongolian = new RangeTable.ptr(new sliceType([new Range16.ptr(6144, 6145, 1), new Range16.ptr(6148, 6148, 1), new Range16.ptr(6150, 6158, 1), new Range16.ptr(6160, 6169, 1), new Range16.ptr(6176, 6263, 1), new Range16.ptr(6272, 6314, 1)]), new sliceType$1([new Range32.ptr(71264, 71276, 1)]), 0);
		_Mro = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(92736, 92766, 1), new Range32.ptr(92768, 92777, 1), new Range32.ptr(92782, 92783, 1)]), 0);
		_Multani = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70272, 70278, 1), new Range32.ptr(70280, 70280, 1), new Range32.ptr(70282, 70285, 1), new Range32.ptr(70287, 70301, 1), new Range32.ptr(70303, 70313, 1)]), 0);
		_Myanmar = new RangeTable.ptr(new sliceType([new Range16.ptr(4096, 4255, 1), new Range16.ptr(43488, 43518, 1), new Range16.ptr(43616, 43647, 1)]), sliceType$1.nil, 0);
		_Nabataean = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67712, 67742, 1), new Range32.ptr(67751, 67759, 1)]), 0);
		_New_Tai_Lue = new RangeTable.ptr(new sliceType([new Range16.ptr(6528, 6571, 1), new Range16.ptr(6576, 6601, 1), new Range16.ptr(6608, 6618, 1), new Range16.ptr(6622, 6623, 1)]), sliceType$1.nil, 0);
		_Newa = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70656, 70745, 1), new Range32.ptr(70747, 70747, 1), new Range32.ptr(70749, 70749, 1)]), 0);
		_Nko = new RangeTable.ptr(new sliceType([new Range16.ptr(1984, 2042, 1)]), sliceType$1.nil, 0);
		_Nushu = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(94177, 94177, 1), new Range32.ptr(110960, 111355, 1)]), 0);
		_Ogham = new RangeTable.ptr(new sliceType([new Range16.ptr(5760, 5788, 1)]), sliceType$1.nil, 0);
		_Ol_Chiki = new RangeTable.ptr(new sliceType([new Range16.ptr(7248, 7295, 1)]), sliceType$1.nil, 0);
		_Old_Hungarian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68736, 68786, 1), new Range32.ptr(68800, 68850, 1), new Range32.ptr(68858, 68863, 1)]), 0);
		_Old_Italic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66304, 66339, 1), new Range32.ptr(66349, 66351, 1)]), 0);
		_Old_North_Arabian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68224, 68255, 1)]), 0);
		_Old_Permic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66384, 66426, 1)]), 0);
		_Old_Persian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66464, 66499, 1), new Range32.ptr(66504, 66517, 1)]), 0);
		_Old_South_Arabian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68192, 68223, 1)]), 0);
		_Old_Turkic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68608, 68680, 1)]), 0);
		_Oriya = new RangeTable.ptr(new sliceType([new Range16.ptr(2817, 2819, 1), new Range16.ptr(2821, 2828, 1), new Range16.ptr(2831, 2832, 1), new Range16.ptr(2835, 2856, 1), new Range16.ptr(2858, 2864, 1), new Range16.ptr(2866, 2867, 1), new Range16.ptr(2869, 2873, 1), new Range16.ptr(2876, 2884, 1), new Range16.ptr(2887, 2888, 1), new Range16.ptr(2891, 2893, 1), new Range16.ptr(2902, 2903, 1), new Range16.ptr(2908, 2909, 1), new Range16.ptr(2911, 2915, 1), new Range16.ptr(2918, 2935, 1)]), sliceType$1.nil, 0);
		_Osage = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66736, 66771, 1), new Range32.ptr(66776, 66811, 1)]), 0);
		_Osmanya = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66688, 66717, 1), new Range32.ptr(66720, 66729, 1)]), 0);
		_Pahawh_Hmong = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(92928, 92997, 1), new Range32.ptr(93008, 93017, 1), new Range32.ptr(93019, 93025, 1), new Range32.ptr(93027, 93047, 1), new Range32.ptr(93053, 93071, 1)]), 0);
		_Palmyrene = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67680, 67711, 1)]), 0);
		_Pau_Cin_Hau = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(72384, 72440, 1)]), 0);
		_Phags_Pa = new RangeTable.ptr(new sliceType([new Range16.ptr(43072, 43127, 1)]), sliceType$1.nil, 0);
		_Phoenician = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(67840, 67867, 1), new Range32.ptr(67871, 67871, 1)]), 0);
		_Psalter_Pahlavi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(68480, 68497, 1), new Range32.ptr(68505, 68508, 1), new Range32.ptr(68521, 68527, 1)]), 0);
		_Rejang = new RangeTable.ptr(new sliceType([new Range16.ptr(43312, 43347, 1), new Range16.ptr(43359, 43359, 1)]), sliceType$1.nil, 0);
		_Runic = new RangeTable.ptr(new sliceType([new Range16.ptr(5792, 5866, 1), new Range16.ptr(5870, 5880, 1)]), sliceType$1.nil, 0);
		_Samaritan = new RangeTable.ptr(new sliceType([new Range16.ptr(2048, 2093, 1), new Range16.ptr(2096, 2110, 1)]), sliceType$1.nil, 0);
		_Saurashtra = new RangeTable.ptr(new sliceType([new Range16.ptr(43136, 43205, 1), new Range16.ptr(43214, 43225, 1)]), sliceType$1.nil, 0);
		_Sharada = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70016, 70093, 1), new Range32.ptr(70096, 70111, 1)]), 0);
		_Shavian = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66640, 66687, 1)]), 0);
		_Siddham = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(71040, 71093, 1), new Range32.ptr(71096, 71133, 1)]), 0);
		_SignWriting = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(120832, 121483, 1), new Range32.ptr(121499, 121503, 1), new Range32.ptr(121505, 121519, 1)]), 0);
		_Sinhala = new RangeTable.ptr(new sliceType([new Range16.ptr(3458, 3459, 1), new Range16.ptr(3461, 3478, 1), new Range16.ptr(3482, 3505, 1), new Range16.ptr(3507, 3515, 1), new Range16.ptr(3517, 3517, 1), new Range16.ptr(3520, 3526, 1), new Range16.ptr(3530, 3530, 1), new Range16.ptr(3535, 3540, 1), new Range16.ptr(3542, 3542, 1), new Range16.ptr(3544, 3551, 1), new Range16.ptr(3558, 3567, 1), new Range16.ptr(3570, 3572, 1)]), new sliceType$1([new Range32.ptr(70113, 70132, 1)]), 0);
		_Sora_Sompeng = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(69840, 69864, 1), new Range32.ptr(69872, 69881, 1)]), 0);
		_Soyombo = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(72272, 72323, 1), new Range32.ptr(72326, 72348, 1), new Range32.ptr(72350, 72354, 1)]), 0);
		_Sundanese = new RangeTable.ptr(new sliceType([new Range16.ptr(7040, 7103, 1), new Range16.ptr(7360, 7367, 1)]), sliceType$1.nil, 0);
		_Syloti_Nagri = new RangeTable.ptr(new sliceType([new Range16.ptr(43008, 43051, 1)]), sliceType$1.nil, 0);
		_Syriac = new RangeTable.ptr(new sliceType([new Range16.ptr(1792, 1805, 1), new Range16.ptr(1807, 1866, 1), new Range16.ptr(1869, 1871, 1), new Range16.ptr(2144, 2154, 1)]), sliceType$1.nil, 0);
		_Tagalog = new RangeTable.ptr(new sliceType([new Range16.ptr(5888, 5900, 1), new Range16.ptr(5902, 5908, 1)]), sliceType$1.nil, 0);
		_Tagbanwa = new RangeTable.ptr(new sliceType([new Range16.ptr(5984, 5996, 1), new Range16.ptr(5998, 6000, 1), new Range16.ptr(6002, 6003, 1)]), sliceType$1.nil, 0);
		_Tai_Le = new RangeTable.ptr(new sliceType([new Range16.ptr(6480, 6509, 1), new Range16.ptr(6512, 6516, 1)]), sliceType$1.nil, 0);
		_Tai_Tham = new RangeTable.ptr(new sliceType([new Range16.ptr(6688, 6750, 1), new Range16.ptr(6752, 6780, 1), new Range16.ptr(6783, 6793, 1), new Range16.ptr(6800, 6809, 1), new Range16.ptr(6816, 6829, 1)]), sliceType$1.nil, 0);
		_Tai_Viet = new RangeTable.ptr(new sliceType([new Range16.ptr(43648, 43714, 1), new Range16.ptr(43739, 43743, 1)]), sliceType$1.nil, 0);
		_Takri = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(71296, 71351, 1), new Range32.ptr(71360, 71369, 1)]), 0);
		_Tamil = new RangeTable.ptr(new sliceType([new Range16.ptr(2946, 2947, 1), new Range16.ptr(2949, 2954, 1), new Range16.ptr(2958, 2960, 1), new Range16.ptr(2962, 2965, 1), new Range16.ptr(2969, 2970, 1), new Range16.ptr(2972, 2972, 1), new Range16.ptr(2974, 2975, 1), new Range16.ptr(2979, 2980, 1), new Range16.ptr(2984, 2986, 1), new Range16.ptr(2990, 3001, 1), new Range16.ptr(3006, 3010, 1), new Range16.ptr(3014, 3016, 1), new Range16.ptr(3018, 3021, 1), new Range16.ptr(3024, 3024, 1), new Range16.ptr(3031, 3031, 1), new Range16.ptr(3046, 3066, 1)]), sliceType$1.nil, 0);
		_Tangut = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(94176, 94176, 1), new Range32.ptr(94208, 100332, 1), new Range32.ptr(100352, 101106, 1)]), 0);
		_Telugu = new RangeTable.ptr(new sliceType([new Range16.ptr(3072, 3075, 1), new Range16.ptr(3077, 3084, 1), new Range16.ptr(3086, 3088, 1), new Range16.ptr(3090, 3112, 1), new Range16.ptr(3114, 3129, 1), new Range16.ptr(3133, 3140, 1), new Range16.ptr(3142, 3144, 1), new Range16.ptr(3146, 3149, 1), new Range16.ptr(3157, 3158, 1), new Range16.ptr(3160, 3162, 1), new Range16.ptr(3168, 3171, 1), new Range16.ptr(3174, 3183, 1), new Range16.ptr(3192, 3199, 1)]), sliceType$1.nil, 0);
		_Thaana = new RangeTable.ptr(new sliceType([new Range16.ptr(1920, 1969, 1)]), sliceType$1.nil, 0);
		_Thai = new RangeTable.ptr(new sliceType([new Range16.ptr(3585, 3642, 1), new Range16.ptr(3648, 3675, 1)]), sliceType$1.nil, 0);
		_Tibetan = new RangeTable.ptr(new sliceType([new Range16.ptr(3840, 3911, 1), new Range16.ptr(3913, 3948, 1), new Range16.ptr(3953, 3991, 1), new Range16.ptr(3993, 4028, 1), new Range16.ptr(4030, 4044, 1), new Range16.ptr(4046, 4052, 1), new Range16.ptr(4057, 4058, 1)]), sliceType$1.nil, 0);
		_Tifinagh = new RangeTable.ptr(new sliceType([new Range16.ptr(11568, 11623, 1), new Range16.ptr(11631, 11632, 1), new Range16.ptr(11647, 11647, 1)]), sliceType$1.nil, 0);
		_Tirhuta = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(70784, 70855, 1), new Range32.ptr(70864, 70873, 1)]), 0);
		_Ugaritic = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(66432, 66461, 1), new Range32.ptr(66463, 66463, 1)]), 0);
		_Vai = new RangeTable.ptr(new sliceType([new Range16.ptr(42240, 42539, 1)]), sliceType$1.nil, 0);
		_Warang_Citi = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(71840, 71922, 1), new Range32.ptr(71935, 71935, 1)]), 0);
		_Yi = new RangeTable.ptr(new sliceType([new Range16.ptr(40960, 42124, 1), new Range16.ptr(42128, 42182, 1)]), sliceType$1.nil, 0);
		_Zanabazar_Square = new RangeTable.ptr(new sliceType([]), new sliceType$1([new Range32.ptr(72192, 72263, 1)]), 0);
		$pkg.Adlam = _Adlam;
		$pkg.Ahom = _Ahom;
		$pkg.Anatolian_Hieroglyphs = _Anatolian_Hieroglyphs;
		$pkg.Arabic = _Arabic;
		$pkg.Armenian = _Armenian;
		$pkg.Avestan = _Avestan;
		$pkg.Balinese = _Balinese;
		$pkg.Bamum = _Bamum;
		$pkg.Bassa_Vah = _Bassa_Vah;
		$pkg.Batak = _Batak;
		$pkg.Bengali = _Bengali;
		$pkg.Bhaiksuki = _Bhaiksuki;
		$pkg.Bopomofo = _Bopomofo;
		$pkg.Brahmi = _Brahmi;
		$pkg.Braille = _Braille;
		$pkg.Buginese = _Buginese;
		$pkg.Buhid = _Buhid;
		$pkg.Canadian_Aboriginal = _Canadian_Aboriginal;
		$pkg.Carian = _Carian;
		$pkg.Caucasian_Albanian = _Caucasian_Albanian;
		$pkg.Chakma = _Chakma;
		$pkg.Cham = _Cham;
		$pkg.Cherokee = _Cherokee;
		$pkg.Common = _Common;
		$pkg.Coptic = _Coptic;
		$pkg.Cuneiform = _Cuneiform;
		$pkg.Cypriot = _Cypriot;
		$pkg.Cyrillic = _Cyrillic;
		$pkg.Deseret = _Deseret;
		$pkg.Devanagari = _Devanagari;
		$pkg.Duployan = _Duployan;
		$pkg.Egyptian_Hieroglyphs = _Egyptian_Hieroglyphs;
		$pkg.Elbasan = _Elbasan;
		$pkg.Ethiopic = _Ethiopic;
		$pkg.Georgian = _Georgian;
		$pkg.Glagolitic = _Glagolitic;
		$pkg.Gothic = _Gothic;
		$pkg.Grantha = _Grantha;
		$pkg.Greek = _Greek;
		$pkg.Gujarati = _Gujarati;
		$pkg.Gurmukhi = _Gurmukhi;
		$pkg.Han = _Han;
		$pkg.Hangul = _Hangul;
		$pkg.Hanunoo = _Hanunoo;
		$pkg.Hatran = _Hatran;
		$pkg.Hebrew = _Hebrew;
		$pkg.Hiragana = _Hiragana;
		$pkg.Imperial_Aramaic = _Imperial_Aramaic;
		$pkg.Inherited = _Inherited;
		$pkg.Inscriptional_Pahlavi = _Inscriptional_Pahlavi;
		$pkg.Inscriptional_Parthian = _Inscriptional_Parthian;
		$pkg.Javanese = _Javanese;
		$pkg.Kaithi = _Kaithi;
		$pkg.Kannada = _Kannada;
		$pkg.Katakana = _Katakana;
		$pkg.Kayah_Li = _Kayah_Li;
		$pkg.Kharoshthi = _Kharoshthi;
		$pkg.Khmer = _Khmer;
		$pkg.Khojki = _Khojki;
		$pkg.Khudawadi = _Khudawadi;
		$pkg.Lao = _Lao;
		$pkg.Latin = _Latin;
		$pkg.Lepcha = _Lepcha;
		$pkg.Limbu = _Limbu;
		$pkg.Linear_A = _Linear_A;
		$pkg.Linear_B = _Linear_B;
		$pkg.Lisu = _Lisu;
		$pkg.Lycian = _Lycian;
		$pkg.Lydian = _Lydian;
		$pkg.Mahajani = _Mahajani;
		$pkg.Malayalam = _Malayalam;
		$pkg.Mandaic = _Mandaic;
		$pkg.Manichaean = _Manichaean;
		$pkg.Marchen = _Marchen;
		$pkg.Masaram_Gondi = _Masaram_Gondi;
		$pkg.Meetei_Mayek = _Meetei_Mayek;
		$pkg.Mende_Kikakui = _Mende_Kikakui;
		$pkg.Meroitic_Cursive = _Meroitic_Cursive;
		$pkg.Meroitic_Hieroglyphs = _Meroitic_Hieroglyphs;
		$pkg.Miao = _Miao;
		$pkg.Modi = _Modi;
		$pkg.Mongolian = _Mongolian;
		$pkg.Mro = _Mro;
		$pkg.Multani = _Multani;
		$pkg.Myanmar = _Myanmar;
		$pkg.Nabataean = _Nabataean;
		$pkg.New_Tai_Lue = _New_Tai_Lue;
		$pkg.Newa = _Newa;
		$pkg.Nko = _Nko;
		$pkg.Nushu = _Nushu;
		$pkg.Ogham = _Ogham;
		$pkg.Ol_Chiki = _Ol_Chiki;
		$pkg.Old_Hungarian = _Old_Hungarian;
		$pkg.Old_Italic = _Old_Italic;
		$pkg.Old_North_Arabian = _Old_North_Arabian;
		$pkg.Old_Permic = _Old_Permic;
		$pkg.Old_Persian = _Old_Persian;
		$pkg.Old_South_Arabian = _Old_South_Arabian;
		$pkg.Old_Turkic = _Old_Turkic;
		$pkg.Oriya = _Oriya;
		$pkg.Osage = _Osage;
		$pkg.Osmanya = _Osmanya;
		$pkg.Pahawh_Hmong = _Pahawh_Hmong;
		$pkg.Palmyrene = _Palmyrene;
		$pkg.Pau_Cin_Hau = _Pau_Cin_Hau;
		$pkg.Phags_Pa = _Phags_Pa;
		$pkg.Phoenician = _Phoenician;
		$pkg.Psalter_Pahlavi = _Psalter_Pahlavi;
		$pkg.Rejang = _Rejang;
		$pkg.Runic = _Runic;
		$pkg.Samaritan = _Samaritan;
		$pkg.Saurashtra = _Saurashtra;
		$pkg.Sharada = _Sharada;
		$pkg.Shavian = _Shavian;
		$pkg.Siddham = _Siddham;
		$pkg.SignWriting = _SignWriting;
		$pkg.Sinhala = _Sinhala;
		$pkg.Sora_Sompeng = _Sora_Sompeng;
		$pkg.Soyombo = _Soyombo;
		$pkg.Sundanese = _Sundanese;
		$pkg.Syloti_Nagri = _Syloti_Nagri;
		$pkg.Syriac = _Syriac;
		$pkg.Tagalog = _Tagalog;
		$pkg.Tagbanwa = _Tagbanwa;
		$pkg.Tai_Le = _Tai_Le;
		$pkg.Tai_Tham = _Tai_Tham;
		$pkg.Tai_Viet = _Tai_Viet;
		$pkg.Takri = _Takri;
		$pkg.Tamil = _Tamil;
		$pkg.Tangut = _Tangut;
		$pkg.Telugu = _Telugu;
		$pkg.Thaana = _Thaana;
		$pkg.Thai = _Thai;
		$pkg.Tibetan = _Tibetan;
		$pkg.Tifinagh = _Tifinagh;
		$pkg.Tirhuta = _Tirhuta;
		$pkg.Ugaritic = _Ugaritic;
		$pkg.Vai = _Vai;
		$pkg.Warang_Citi = _Warang_Citi;
		$pkg.Yi = _Yi;
		$pkg.Zanabazar_Square = _Zanabazar_Square;
		$pkg.Scripts = $makeMap($String.keyFor, [{ k: "Adlam", v: $pkg.Adlam }, { k: "Ahom", v: $pkg.Ahom }, { k: "Anatolian_Hieroglyphs", v: $pkg.Anatolian_Hieroglyphs }, { k: "Arabic", v: $pkg.Arabic }, { k: "Armenian", v: $pkg.Armenian }, { k: "Avestan", v: $pkg.Avestan }, { k: "Balinese", v: $pkg.Balinese }, { k: "Bamum", v: $pkg.Bamum }, { k: "Bassa_Vah", v: $pkg.Bassa_Vah }, { k: "Batak", v: $pkg.Batak }, { k: "Bengali", v: $pkg.Bengali }, { k: "Bhaiksuki", v: $pkg.Bhaiksuki }, { k: "Bopomofo", v: $pkg.Bopomofo }, { k: "Brahmi", v: $pkg.Brahmi }, { k: "Braille", v: $pkg.Braille }, { k: "Buginese", v: $pkg.Buginese }, { k: "Buhid", v: $pkg.Buhid }, { k: "Canadian_Aboriginal", v: $pkg.Canadian_Aboriginal }, { k: "Carian", v: $pkg.Carian }, { k: "Caucasian_Albanian", v: $pkg.Caucasian_Albanian }, { k: "Chakma", v: $pkg.Chakma }, { k: "Cham", v: $pkg.Cham }, { k: "Cherokee", v: $pkg.Cherokee }, { k: "Common", v: $pkg.Common }, { k: "Coptic", v: $pkg.Coptic }, { k: "Cuneiform", v: $pkg.Cuneiform }, { k: "Cypriot", v: $pkg.Cypriot }, { k: "Cyrillic", v: $pkg.Cyrillic }, { k: "Deseret", v: $pkg.Deseret }, { k: "Devanagari", v: $pkg.Devanagari }, { k: "Duployan", v: $pkg.Duployan }, { k: "Egyptian_Hieroglyphs", v: $pkg.Egyptian_Hieroglyphs }, { k: "Elbasan", v: $pkg.Elbasan }, { k: "Ethiopic", v: $pkg.Ethiopic }, { k: "Georgian", v: $pkg.Georgian }, { k: "Glagolitic", v: $pkg.Glagolitic }, { k: "Gothic", v: $pkg.Gothic }, { k: "Grantha", v: $pkg.Grantha }, { k: "Greek", v: $pkg.Greek }, { k: "Gujarati", v: $pkg.Gujarati }, { k: "Gurmukhi", v: $pkg.Gurmukhi }, { k: "Han", v: $pkg.Han }, { k: "Hangul", v: $pkg.Hangul }, { k: "Hanunoo", v: $pkg.Hanunoo }, { k: "Hatran", v: $pkg.Hatran }, { k: "Hebrew", v: $pkg.Hebrew }, { k: "Hiragana", v: $pkg.Hiragana }, { k: "Imperial_Aramaic", v: $pkg.Imperial_Aramaic }, { k: "Inherited", v: $pkg.Inherited }, { k: "Inscriptional_Pahlavi", v: $pkg.Inscriptional_Pahlavi }, { k: "Inscriptional_Parthian", v: $pkg.Inscriptional_Parthian }, { k: "Javanese", v: $pkg.Javanese }, { k: "Kaithi", v: $pkg.Kaithi }, { k: "Kannada", v: $pkg.Kannada }, { k: "Katakana", v: $pkg.Katakana }, { k: "Kayah_Li", v: $pkg.Kayah_Li }, { k: "Kharoshthi", v: $pkg.Kharoshthi }, { k: "Khmer", v: $pkg.Khmer }, { k: "Khojki", v: $pkg.Khojki }, { k: "Khudawadi", v: $pkg.Khudawadi }, { k: "Lao", v: $pkg.Lao }, { k: "Latin", v: $pkg.Latin }, { k: "Lepcha", v: $pkg.Lepcha }, { k: "Limbu", v: $pkg.Limbu }, { k: "Linear_A", v: $pkg.Linear_A }, { k: "Linear_B", v: $pkg.Linear_B }, { k: "Lisu", v: $pkg.Lisu }, { k: "Lycian", v: $pkg.Lycian }, { k: "Lydian", v: $pkg.Lydian }, { k: "Mahajani", v: $pkg.Mahajani }, { k: "Malayalam", v: $pkg.Malayalam }, { k: "Mandaic", v: $pkg.Mandaic }, { k: "Manichaean", v: $pkg.Manichaean }, { k: "Marchen", v: $pkg.Marchen }, { k: "Masaram_Gondi", v: $pkg.Masaram_Gondi }, { k: "Meetei_Mayek", v: $pkg.Meetei_Mayek }, { k: "Mende_Kikakui", v: $pkg.Mende_Kikakui }, { k: "Meroitic_Cursive", v: $pkg.Meroitic_Cursive }, { k: "Meroitic_Hieroglyphs", v: $pkg.Meroitic_Hieroglyphs }, { k: "Miao", v: $pkg.Miao }, { k: "Modi", v: $pkg.Modi }, { k: "Mongolian", v: $pkg.Mongolian }, { k: "Mro", v: $pkg.Mro }, { k: "Multani", v: $pkg.Multani }, { k: "Myanmar", v: $pkg.Myanmar }, { k: "Nabataean", v: $pkg.Nabataean }, { k: "New_Tai_Lue", v: $pkg.New_Tai_Lue }, { k: "Newa", v: $pkg.Newa }, { k: "Nko", v: $pkg.Nko }, { k: "Nushu", v: $pkg.Nushu }, { k: "Ogham", v: $pkg.Ogham }, { k: "Ol_Chiki", v: $pkg.Ol_Chiki }, { k: "Old_Hungarian", v: $pkg.Old_Hungarian }, { k: "Old_Italic", v: $pkg.Old_Italic }, { k: "Old_North_Arabian", v: $pkg.Old_North_Arabian }, { k: "Old_Permic", v: $pkg.Old_Permic }, { k: "Old_Persian", v: $pkg.Old_Persian }, { k: "Old_South_Arabian", v: $pkg.Old_South_Arabian }, { k: "Old_Turkic", v: $pkg.Old_Turkic }, { k: "Oriya", v: $pkg.Oriya }, { k: "Osage", v: $pkg.Osage }, { k: "Osmanya", v: $pkg.Osmanya }, { k: "Pahawh_Hmong", v: $pkg.Pahawh_Hmong }, { k: "Palmyrene", v: $pkg.Palmyrene }, { k: "Pau_Cin_Hau", v: $pkg.Pau_Cin_Hau }, { k: "Phags_Pa", v: $pkg.Phags_Pa }, { k: "Phoenician", v: $pkg.Phoenician }, { k: "Psalter_Pahlavi", v: $pkg.Psalter_Pahlavi }, { k: "Rejang", v: $pkg.Rejang }, { k: "Runic", v: $pkg.Runic }, { k: "Samaritan", v: $pkg.Samaritan }, { k: "Saurashtra", v: $pkg.Saurashtra }, { k: "Sharada", v: $pkg.Sharada }, { k: "Shavian", v: $pkg.Shavian }, { k: "Siddham", v: $pkg.Siddham }, { k: "SignWriting", v: $pkg.SignWriting }, { k: "Sinhala", v: $pkg.Sinhala }, { k: "Sora_Sompeng", v: $pkg.Sora_Sompeng }, { k: "Soyombo", v: $pkg.Soyombo }, { k: "Sundanese", v: $pkg.Sundanese }, { k: "Syloti_Nagri", v: $pkg.Syloti_Nagri }, { k: "Syriac", v: $pkg.Syriac }, { k: "Tagalog", v: $pkg.Tagalog }, { k: "Tagbanwa", v: $pkg.Tagbanwa }, { k: "Tai_Le", v: $pkg.Tai_Le }, { k: "Tai_Tham", v: $pkg.Tai_Tham }, { k: "Tai_Viet", v: $pkg.Tai_Viet }, { k: "Takri", v: $pkg.Takri }, { k: "Tamil", v: $pkg.Tamil }, { k: "Tangut", v: $pkg.Tangut }, { k: "Telugu", v: $pkg.Telugu }, { k: "Thaana", v: $pkg.Thaana }, { k: "Thai", v: $pkg.Thai }, { k: "Tibetan", v: $pkg.Tibetan }, { k: "Tifinagh", v: $pkg.Tifinagh }, { k: "Tirhuta", v: $pkg.Tirhuta }, { k: "Ugaritic", v: $pkg.Ugaritic }, { k: "Vai", v: $pkg.Vai }, { k: "Warang_Citi", v: $pkg.Warang_Citi }, { k: "Yi", v: $pkg.Yi }, { k: "Zanabazar_Square", v: $pkg.Zanabazar_Square }]);
		_CaseRanges = new sliceType$3([new CaseRange.ptr(65, 90, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(97, 122, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(181, 181, $toNativeArray($kindInt32, [743, 0, 743])), new CaseRange.ptr(192, 214, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(216, 222, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(224, 246, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(248, 254, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(255, 255, $toNativeArray($kindInt32, [121, 0, 121])), new CaseRange.ptr(256, 303, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(304, 304, $toNativeArray($kindInt32, [0, -199, 0])), new CaseRange.ptr(305, 305, $toNativeArray($kindInt32, [-232, 0, -232])), new CaseRange.ptr(306, 311, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(313, 328, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(330, 375, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(376, 376, $toNativeArray($kindInt32, [0, -121, 0])), new CaseRange.ptr(377, 382, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(383, 383, $toNativeArray($kindInt32, [-300, 0, -300])), new CaseRange.ptr(384, 384, $toNativeArray($kindInt32, [195, 0, 195])), new CaseRange.ptr(385, 385, $toNativeArray($kindInt32, [0, 210, 0])), new CaseRange.ptr(386, 389, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(390, 390, $toNativeArray($kindInt32, [0, 206, 0])), new CaseRange.ptr(391, 392, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(393, 394, $toNativeArray($kindInt32, [0, 205, 0])), new CaseRange.ptr(395, 396, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(398, 398, $toNativeArray($kindInt32, [0, 79, 0])), new CaseRange.ptr(399, 399, $toNativeArray($kindInt32, [0, 202, 0])), new CaseRange.ptr(400, 400, $toNativeArray($kindInt32, [0, 203, 0])), new CaseRange.ptr(401, 402, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(403, 403, $toNativeArray($kindInt32, [0, 205, 0])), new CaseRange.ptr(404, 404, $toNativeArray($kindInt32, [0, 207, 0])), new CaseRange.ptr(405, 405, $toNativeArray($kindInt32, [97, 0, 97])), new CaseRange.ptr(406, 406, $toNativeArray($kindInt32, [0, 211, 0])), new CaseRange.ptr(407, 407, $toNativeArray($kindInt32, [0, 209, 0])), new CaseRange.ptr(408, 409, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(410, 410, $toNativeArray($kindInt32, [163, 0, 163])), new CaseRange.ptr(412, 412, $toNativeArray($kindInt32, [0, 211, 0])), new CaseRange.ptr(413, 413, $toNativeArray($kindInt32, [0, 213, 0])), new CaseRange.ptr(414, 414, $toNativeArray($kindInt32, [130, 0, 130])), new CaseRange.ptr(415, 415, $toNativeArray($kindInt32, [0, 214, 0])), new CaseRange.ptr(416, 421, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(422, 422, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(423, 424, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(425, 425, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(428, 429, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(430, 430, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(431, 432, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(433, 434, $toNativeArray($kindInt32, [0, 217, 0])), new CaseRange.ptr(435, 438, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(439, 439, $toNativeArray($kindInt32, [0, 219, 0])), new CaseRange.ptr(440, 441, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(444, 445, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(447, 447, $toNativeArray($kindInt32, [56, 0, 56])), new CaseRange.ptr(452, 452, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(453, 453, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(454, 454, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(455, 455, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(456, 456, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(457, 457, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(458, 458, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(459, 459, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(460, 460, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(461, 476, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(477, 477, $toNativeArray($kindInt32, [-79, 0, -79])), new CaseRange.ptr(478, 495, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(497, 497, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(498, 498, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(499, 499, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(500, 501, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(502, 502, $toNativeArray($kindInt32, [0, -97, 0])), new CaseRange.ptr(503, 503, $toNativeArray($kindInt32, [0, -56, 0])), new CaseRange.ptr(504, 543, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(544, 544, $toNativeArray($kindInt32, [0, -130, 0])), new CaseRange.ptr(546, 563, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(570, 570, $toNativeArray($kindInt32, [0, 10795, 0])), new CaseRange.ptr(571, 572, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(573, 573, $toNativeArray($kindInt32, [0, -163, 0])), new CaseRange.ptr(574, 574, $toNativeArray($kindInt32, [0, 10792, 0])), new CaseRange.ptr(575, 576, $toNativeArray($kindInt32, [10815, 0, 10815])), new CaseRange.ptr(577, 578, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(579, 579, $toNativeArray($kindInt32, [0, -195, 0])), new CaseRange.ptr(580, 580, $toNativeArray($kindInt32, [0, 69, 0])), new CaseRange.ptr(581, 581, $toNativeArray($kindInt32, [0, 71, 0])), new CaseRange.ptr(582, 591, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(592, 592, $toNativeArray($kindInt32, [10783, 0, 10783])), new CaseRange.ptr(593, 593, $toNativeArray($kindInt32, [10780, 0, 10780])), new CaseRange.ptr(594, 594, $toNativeArray($kindInt32, [10782, 0, 10782])), new CaseRange.ptr(595, 595, $toNativeArray($kindInt32, [-210, 0, -210])), new CaseRange.ptr(596, 596, $toNativeArray($kindInt32, [-206, 0, -206])), new CaseRange.ptr(598, 599, $toNativeArray($kindInt32, [-205, 0, -205])), new CaseRange.ptr(601, 601, $toNativeArray($kindInt32, [-202, 0, -202])), new CaseRange.ptr(603, 603, $toNativeArray($kindInt32, [-203, 0, -203])), new CaseRange.ptr(604, 604, $toNativeArray($kindInt32, [42319, 0, 42319])), new CaseRange.ptr(608, 608, $toNativeArray($kindInt32, [-205, 0, -205])), new CaseRange.ptr(609, 609, $toNativeArray($kindInt32, [42315, 0, 42315])), new CaseRange.ptr(611, 611, $toNativeArray($kindInt32, [-207, 0, -207])), new CaseRange.ptr(613, 613, $toNativeArray($kindInt32, [42280, 0, 42280])), new CaseRange.ptr(614, 614, $toNativeArray($kindInt32, [42308, 0, 42308])), new CaseRange.ptr(616, 616, $toNativeArray($kindInt32, [-209, 0, -209])), new CaseRange.ptr(617, 617, $toNativeArray($kindInt32, [-211, 0, -211])), new CaseRange.ptr(618, 618, $toNativeArray($kindInt32, [42308, 0, 42308])), new CaseRange.ptr(619, 619, $toNativeArray($kindInt32, [10743, 0, 10743])), new CaseRange.ptr(620, 620, $toNativeArray($kindInt32, [42305, 0, 42305])), new CaseRange.ptr(623, 623, $toNativeArray($kindInt32, [-211, 0, -211])), new CaseRange.ptr(625, 625, $toNativeArray($kindInt32, [10749, 0, 10749])), new CaseRange.ptr(626, 626, $toNativeArray($kindInt32, [-213, 0, -213])), new CaseRange.ptr(629, 629, $toNativeArray($kindInt32, [-214, 0, -214])), new CaseRange.ptr(637, 637, $toNativeArray($kindInt32, [10727, 0, 10727])), new CaseRange.ptr(640, 640, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(643, 643, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(647, 647, $toNativeArray($kindInt32, [42282, 0, 42282])), new CaseRange.ptr(648, 648, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(649, 649, $toNativeArray($kindInt32, [-69, 0, -69])), new CaseRange.ptr(650, 651, $toNativeArray($kindInt32, [-217, 0, -217])), new CaseRange.ptr(652, 652, $toNativeArray($kindInt32, [-71, 0, -71])), new CaseRange.ptr(658, 658, $toNativeArray($kindInt32, [-219, 0, -219])), new CaseRange.ptr(669, 669, $toNativeArray($kindInt32, [42261, 0, 42261])), new CaseRange.ptr(670, 670, $toNativeArray($kindInt32, [42258, 0, 42258])), new CaseRange.ptr(837, 837, $toNativeArray($kindInt32, [84, 0, 84])), new CaseRange.ptr(880, 883, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(886, 887, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(891, 893, $toNativeArray($kindInt32, [130, 0, 130])), new CaseRange.ptr(895, 895, $toNativeArray($kindInt32, [0, 116, 0])), new CaseRange.ptr(902, 902, $toNativeArray($kindInt32, [0, 38, 0])), new CaseRange.ptr(904, 906, $toNativeArray($kindInt32, [0, 37, 0])), new CaseRange.ptr(908, 908, $toNativeArray($kindInt32, [0, 64, 0])), new CaseRange.ptr(910, 911, $toNativeArray($kindInt32, [0, 63, 0])), new CaseRange.ptr(913, 929, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(931, 939, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(940, 940, $toNativeArray($kindInt32, [-38, 0, -38])), new CaseRange.ptr(941, 943, $toNativeArray($kindInt32, [-37, 0, -37])), new CaseRange.ptr(945, 961, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(962, 962, $toNativeArray($kindInt32, [-31, 0, -31])), new CaseRange.ptr(963, 971, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(972, 972, $toNativeArray($kindInt32, [-64, 0, -64])), new CaseRange.ptr(973, 974, $toNativeArray($kindInt32, [-63, 0, -63])), new CaseRange.ptr(975, 975, $toNativeArray($kindInt32, [0, 8, 0])), new CaseRange.ptr(976, 976, $toNativeArray($kindInt32, [-62, 0, -62])), new CaseRange.ptr(977, 977, $toNativeArray($kindInt32, [-57, 0, -57])), new CaseRange.ptr(981, 981, $toNativeArray($kindInt32, [-47, 0, -47])), new CaseRange.ptr(982, 982, $toNativeArray($kindInt32, [-54, 0, -54])), new CaseRange.ptr(983, 983, $toNativeArray($kindInt32, [-8, 0, -8])), new CaseRange.ptr(984, 1007, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1008, 1008, $toNativeArray($kindInt32, [-86, 0, -86])), new CaseRange.ptr(1009, 1009, $toNativeArray($kindInt32, [-80, 0, -80])), new CaseRange.ptr(1010, 1010, $toNativeArray($kindInt32, [7, 0, 7])), new CaseRange.ptr(1011, 1011, $toNativeArray($kindInt32, [-116, 0, -116])), new CaseRange.ptr(1012, 1012, $toNativeArray($kindInt32, [0, -60, 0])), new CaseRange.ptr(1013, 1013, $toNativeArray($kindInt32, [-96, 0, -96])), new CaseRange.ptr(1015, 1016, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1017, 1017, $toNativeArray($kindInt32, [0, -7, 0])), new CaseRange.ptr(1018, 1019, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1021, 1023, $toNativeArray($kindInt32, [0, -130, 0])), new CaseRange.ptr(1024, 1039, $toNativeArray($kindInt32, [0, 80, 0])), new CaseRange.ptr(1040, 1071, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(1072, 1103, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(1104, 1119, $toNativeArray($kindInt32, [-80, 0, -80])), new CaseRange.ptr(1120, 1153, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1162, 1215, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1216, 1216, $toNativeArray($kindInt32, [0, 15, 0])), new CaseRange.ptr(1217, 1230, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1231, 1231, $toNativeArray($kindInt32, [-15, 0, -15])), new CaseRange.ptr(1232, 1327, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1329, 1366, $toNativeArray($kindInt32, [0, 48, 0])), new CaseRange.ptr(1377, 1414, $toNativeArray($kindInt32, [-48, 0, -48])), new CaseRange.ptr(4256, 4293, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(4295, 4295, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(4301, 4301, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(5024, 5103, $toNativeArray($kindInt32, [0, 38864, 0])), new CaseRange.ptr(5104, 5109, $toNativeArray($kindInt32, [0, 8, 0])), new CaseRange.ptr(5112, 5117, $toNativeArray($kindInt32, [-8, 0, -8])), new CaseRange.ptr(7296, 7296, $toNativeArray($kindInt32, [-6254, 0, -6254])), new CaseRange.ptr(7297, 7297, $toNativeArray($kindInt32, [-6253, 0, -6253])), new CaseRange.ptr(7298, 7298, $toNativeArray($kindInt32, [-6244, 0, -6244])), new CaseRange.ptr(7299, 7300, $toNativeArray($kindInt32, [-6242, 0, -6242])), new CaseRange.ptr(7301, 7301, $toNativeArray($kindInt32, [-6243, 0, -6243])), new CaseRange.ptr(7302, 7302, $toNativeArray($kindInt32, [-6236, 0, -6236])), new CaseRange.ptr(7303, 7303, $toNativeArray($kindInt32, [-6181, 0, -6181])), new CaseRange.ptr(7304, 7304, $toNativeArray($kindInt32, [35266, 0, 35266])), new CaseRange.ptr(7545, 7545, $toNativeArray($kindInt32, [35332, 0, 35332])), new CaseRange.ptr(7549, 7549, $toNativeArray($kindInt32, [3814, 0, 3814])), new CaseRange.ptr(7680, 7829, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(7835, 7835, $toNativeArray($kindInt32, [-59, 0, -59])), new CaseRange.ptr(7838, 7838, $toNativeArray($kindInt32, [0, -7615, 0])), new CaseRange.ptr(7840, 7935, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(7936, 7943, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7944, 7951, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7952, 7957, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7960, 7965, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7968, 7975, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7976, 7983, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7984, 7991, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7992, 7999, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8000, 8005, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8008, 8013, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8017, 8017, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8019, 8019, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8021, 8021, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8023, 8023, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8025, 8025, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8027, 8027, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8029, 8029, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8031, 8031, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8032, 8039, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8040, 8047, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8048, 8049, $toNativeArray($kindInt32, [74, 0, 74])), new CaseRange.ptr(8050, 8053, $toNativeArray($kindInt32, [86, 0, 86])), new CaseRange.ptr(8054, 8055, $toNativeArray($kindInt32, [100, 0, 100])), new CaseRange.ptr(8056, 8057, $toNativeArray($kindInt32, [128, 0, 128])), new CaseRange.ptr(8058, 8059, $toNativeArray($kindInt32, [112, 0, 112])), new CaseRange.ptr(8060, 8061, $toNativeArray($kindInt32, [126, 0, 126])), new CaseRange.ptr(8064, 8071, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8072, 8079, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8080, 8087, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8088, 8095, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8096, 8103, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8104, 8111, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8112, 8113, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8115, 8115, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8120, 8121, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8122, 8123, $toNativeArray($kindInt32, [0, -74, 0])), new CaseRange.ptr(8124, 8124, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8126, 8126, $toNativeArray($kindInt32, [-7205, 0, -7205])), new CaseRange.ptr(8131, 8131, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8136, 8139, $toNativeArray($kindInt32, [0, -86, 0])), new CaseRange.ptr(8140, 8140, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8144, 8145, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8152, 8153, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8154, 8155, $toNativeArray($kindInt32, [0, -100, 0])), new CaseRange.ptr(8160, 8161, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8165, 8165, $toNativeArray($kindInt32, [7, 0, 7])), new CaseRange.ptr(8168, 8169, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8170, 8171, $toNativeArray($kindInt32, [0, -112, 0])), new CaseRange.ptr(8172, 8172, $toNativeArray($kindInt32, [0, -7, 0])), new CaseRange.ptr(8179, 8179, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8184, 8185, $toNativeArray($kindInt32, [0, -128, 0])), new CaseRange.ptr(8186, 8187, $toNativeArray($kindInt32, [0, -126, 0])), new CaseRange.ptr(8188, 8188, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8486, 8486, $toNativeArray($kindInt32, [0, -7517, 0])), new CaseRange.ptr(8490, 8490, $toNativeArray($kindInt32, [0, -8383, 0])), new CaseRange.ptr(8491, 8491, $toNativeArray($kindInt32, [0, -8262, 0])), new CaseRange.ptr(8498, 8498, $toNativeArray($kindInt32, [0, 28, 0])), new CaseRange.ptr(8526, 8526, $toNativeArray($kindInt32, [-28, 0, -28])), new CaseRange.ptr(8544, 8559, $toNativeArray($kindInt32, [0, 16, 0])), new CaseRange.ptr(8560, 8575, $toNativeArray($kindInt32, [-16, 0, -16])), new CaseRange.ptr(8579, 8580, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(9398, 9423, $toNativeArray($kindInt32, [0, 26, 0])), new CaseRange.ptr(9424, 9449, $toNativeArray($kindInt32, [-26, 0, -26])), new CaseRange.ptr(11264, 11310, $toNativeArray($kindInt32, [0, 48, 0])), new CaseRange.ptr(11312, 11358, $toNativeArray($kindInt32, [-48, 0, -48])), new CaseRange.ptr(11360, 11361, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11362, 11362, $toNativeArray($kindInt32, [0, -10743, 0])), new CaseRange.ptr(11363, 11363, $toNativeArray($kindInt32, [0, -3814, 0])), new CaseRange.ptr(11364, 11364, $toNativeArray($kindInt32, [0, -10727, 0])), new CaseRange.ptr(11365, 11365, $toNativeArray($kindInt32, [-10795, 0, -10795])), new CaseRange.ptr(11366, 11366, $toNativeArray($kindInt32, [-10792, 0, -10792])), new CaseRange.ptr(11367, 11372, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11373, 11373, $toNativeArray($kindInt32, [0, -10780, 0])), new CaseRange.ptr(11374, 11374, $toNativeArray($kindInt32, [0, -10749, 0])), new CaseRange.ptr(11375, 11375, $toNativeArray($kindInt32, [0, -10783, 0])), new CaseRange.ptr(11376, 11376, $toNativeArray($kindInt32, [0, -10782, 0])), new CaseRange.ptr(11378, 11379, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11381, 11382, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11390, 11391, $toNativeArray($kindInt32, [0, -10815, 0])), new CaseRange.ptr(11392, 11491, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11499, 11502, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11506, 11507, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11520, 11557, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(11559, 11559, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(11565, 11565, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(42560, 42605, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42624, 42651, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42786, 42799, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42802, 42863, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42873, 42876, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42877, 42877, $toNativeArray($kindInt32, [0, -35332, 0])), new CaseRange.ptr(42878, 42887, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42891, 42892, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42893, 42893, $toNativeArray($kindInt32, [0, -42280, 0])), new CaseRange.ptr(42896, 42899, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42902, 42921, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42922, 42922, $toNativeArray($kindInt32, [0, -42308, 0])), new CaseRange.ptr(42923, 42923, $toNativeArray($kindInt32, [0, -42319, 0])), new CaseRange.ptr(42924, 42924, $toNativeArray($kindInt32, [0, -42315, 0])), new CaseRange.ptr(42925, 42925, $toNativeArray($kindInt32, [0, -42305, 0])), new CaseRange.ptr(42926, 42926, $toNativeArray($kindInt32, [0, -42308, 0])), new CaseRange.ptr(42928, 42928, $toNativeArray($kindInt32, [0, -42258, 0])), new CaseRange.ptr(42929, 42929, $toNativeArray($kindInt32, [0, -42282, 0])), new CaseRange.ptr(42930, 42930, $toNativeArray($kindInt32, [0, -42261, 0])), new CaseRange.ptr(42931, 42931, $toNativeArray($kindInt32, [0, 928, 0])), new CaseRange.ptr(42932, 42935, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(43859, 43859, $toNativeArray($kindInt32, [-928, 0, -928])), new CaseRange.ptr(43888, 43967, $toNativeArray($kindInt32, [-38864, 0, -38864])), new CaseRange.ptr(65313, 65338, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(65345, 65370, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(66560, 66599, $toNativeArray($kindInt32, [0, 40, 0])), new CaseRange.ptr(66600, 66639, $toNativeArray($kindInt32, [-40, 0, -40])), new CaseRange.ptr(66736, 66771, $toNativeArray($kindInt32, [0, 40, 0])), new CaseRange.ptr(66776, 66811, $toNativeArray($kindInt32, [-40, 0, -40])), new CaseRange.ptr(68736, 68786, $toNativeArray($kindInt32, [0, 64, 0])), new CaseRange.ptr(68800, 68850, $toNativeArray($kindInt32, [-64, 0, -64])), new CaseRange.ptr(71840, 71871, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(71872, 71903, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(125184, 125217, $toNativeArray($kindInt32, [0, 34, 0])), new CaseRange.ptr(125218, 125251, $toNativeArray($kindInt32, [-34, 0, -34]))]);
		$pkg.CaseRanges = _CaseRanges;
		properties = $toNativeArray($kindUint8, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 144, 130, 130, 130, 136, 130, 130, 130, 130, 130, 130, 136, 130, 130, 130, 130, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 130, 130, 136, 136, 136, 130, 130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 130, 130, 130, 136, 130, 136, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 130, 136, 130, 136, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 130, 136, 136, 136, 136, 136, 130, 136, 136, 224, 130, 136, 0, 136, 136, 136, 136, 132, 132, 136, 192, 130, 130, 136, 132, 224, 130, 132, 132, 132, 130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 136, 160, 160, 160, 160, 160, 160, 160, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 136, 192, 192, 192, 192, 192, 192, 192, 192]);
		asciiFold = $toNativeArray($kindUint16, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 91, 92, 93, 94, 95, 96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 8490, 76, 77, 78, 79, 80, 81, 82, 383, 84, 85, 86, 87, 88, 89, 90, 123, 124, 125, 126, 127]);
		caseOrbit = new sliceType$4([new foldPair.ptr(75, 107), new foldPair.ptr(83, 115), new foldPair.ptr(107, 8490), new foldPair.ptr(115, 383), new foldPair.ptr(181, 924), new foldPair.ptr(197, 229), new foldPair.ptr(223, 7838), new foldPair.ptr(229, 8491), new foldPair.ptr(304, 304), new foldPair.ptr(305, 305), new foldPair.ptr(383, 83), new foldPair.ptr(452, 453), new foldPair.ptr(453, 454), new foldPair.ptr(454, 452), new foldPair.ptr(455, 456), new foldPair.ptr(456, 457), new foldPair.ptr(457, 455), new foldPair.ptr(458, 459), new foldPair.ptr(459, 460), new foldPair.ptr(460, 458), new foldPair.ptr(497, 498), new foldPair.ptr(498, 499), new foldPair.ptr(499, 497), new foldPair.ptr(837, 921), new foldPair.ptr(914, 946), new foldPair.ptr(917, 949), new foldPair.ptr(920, 952), new foldPair.ptr(921, 953), new foldPair.ptr(922, 954), new foldPair.ptr(924, 956), new foldPair.ptr(928, 960), new foldPair.ptr(929, 961), new foldPair.ptr(931, 962), new foldPair.ptr(934, 966), new foldPair.ptr(937, 969), new foldPair.ptr(946, 976), new foldPair.ptr(949, 1013), new foldPair.ptr(952, 977), new foldPair.ptr(953, 8126), new foldPair.ptr(954, 1008), new foldPair.ptr(956, 181), new foldPair.ptr(960, 982), new foldPair.ptr(961, 1009), new foldPair.ptr(962, 963), new foldPair.ptr(963, 931), new foldPair.ptr(966, 981), new foldPair.ptr(969, 8486), new foldPair.ptr(976, 914), new foldPair.ptr(977, 1012), new foldPair.ptr(981, 934), new foldPair.ptr(982, 928), new foldPair.ptr(1008, 922), new foldPair.ptr(1009, 929), new foldPair.ptr(1012, 920), new foldPair.ptr(1013, 917), new foldPair.ptr(1042, 1074), new foldPair.ptr(1044, 1076), new foldPair.ptr(1054, 1086), new foldPair.ptr(1057, 1089), new foldPair.ptr(1058, 1090), new foldPair.ptr(1066, 1098), new foldPair.ptr(1074, 7296), new foldPair.ptr(1076, 7297), new foldPair.ptr(1086, 7298), new foldPair.ptr(1089, 7299), new foldPair.ptr(1090, 7300), new foldPair.ptr(1098, 7302), new foldPair.ptr(1122, 1123), new foldPair.ptr(1123, 7303), new foldPair.ptr(7296, 1042), new foldPair.ptr(7297, 1044), new foldPair.ptr(7298, 1054), new foldPair.ptr(7299, 1057), new foldPair.ptr(7300, 7301), new foldPair.ptr(7301, 1058), new foldPair.ptr(7302, 1066), new foldPair.ptr(7303, 1122), new foldPair.ptr(7304, 42570), new foldPair.ptr(7776, 7777), new foldPair.ptr(7777, 7835), new foldPair.ptr(7835, 7776), new foldPair.ptr(7838, 223), new foldPair.ptr(8126, 837), new foldPair.ptr(8486, 937), new foldPair.ptr(8490, 75), new foldPair.ptr(8491, 197), new foldPair.ptr(42570, 42571), new foldPair.ptr(42571, 7304)]);
		foldL = new RangeTable.ptr(new sliceType([new Range16.ptr(837, 837, 1)]), sliceType$1.nil, 0);
		foldLl = new RangeTable.ptr(new sliceType([new Range16.ptr(65, 90, 1), new Range16.ptr(192, 214, 1), new Range16.ptr(216, 222, 1), new Range16.ptr(256, 302, 2), new Range16.ptr(306, 310, 2), new Range16.ptr(313, 327, 2), new Range16.ptr(330, 376, 2), new Range16.ptr(377, 381, 2), new Range16.ptr(385, 386, 1), new Range16.ptr(388, 390, 2), new Range16.ptr(391, 393, 2), new Range16.ptr(394, 395, 1), new Range16.ptr(398, 401, 1), new Range16.ptr(403, 404, 1), new Range16.ptr(406, 408, 1), new Range16.ptr(412, 413, 1), new Range16.ptr(415, 416, 1), new Range16.ptr(418, 422, 2), new Range16.ptr(423, 425, 2), new Range16.ptr(428, 430, 2), new Range16.ptr(431, 433, 2), new Range16.ptr(434, 435, 1), new Range16.ptr(437, 439, 2), new Range16.ptr(440, 444, 4), new Range16.ptr(452, 453, 1), new Range16.ptr(455, 456, 1), new Range16.ptr(458, 459, 1), new Range16.ptr(461, 475, 2), new Range16.ptr(478, 494, 2), new Range16.ptr(497, 498, 1), new Range16.ptr(500, 502, 2), new Range16.ptr(503, 504, 1), new Range16.ptr(506, 562, 2), new Range16.ptr(570, 571, 1), new Range16.ptr(573, 574, 1), new Range16.ptr(577, 579, 2), new Range16.ptr(580, 582, 1), new Range16.ptr(584, 590, 2), new Range16.ptr(837, 880, 43), new Range16.ptr(882, 886, 4), new Range16.ptr(895, 902, 7), new Range16.ptr(904, 906, 1), new Range16.ptr(908, 910, 2), new Range16.ptr(911, 913, 2), new Range16.ptr(914, 929, 1), new Range16.ptr(931, 939, 1), new Range16.ptr(975, 984, 9), new Range16.ptr(986, 1006, 2), new Range16.ptr(1012, 1015, 3), new Range16.ptr(1017, 1018, 1), new Range16.ptr(1021, 1071, 1), new Range16.ptr(1120, 1152, 2), new Range16.ptr(1162, 1216, 2), new Range16.ptr(1217, 1229, 2), new Range16.ptr(1232, 1326, 2), new Range16.ptr(1329, 1366, 1), new Range16.ptr(4256, 4293, 1), new Range16.ptr(4295, 4301, 6), new Range16.ptr(5024, 5109, 1), new Range16.ptr(7680, 7828, 2), new Range16.ptr(7838, 7934, 2), new Range16.ptr(7944, 7951, 1), new Range16.ptr(7960, 7965, 1), new Range16.ptr(7976, 7983, 1), new Range16.ptr(7992, 7999, 1), new Range16.ptr(8008, 8013, 1), new Range16.ptr(8025, 8031, 2), new Range16.ptr(8040, 8047, 1), new Range16.ptr(8072, 8079, 1), new Range16.ptr(8088, 8095, 1), new Range16.ptr(8104, 8111, 1), new Range16.ptr(8120, 8124, 1), new Range16.ptr(8136, 8140, 1), new Range16.ptr(8152, 8155, 1), new Range16.ptr(8168, 8172, 1), new Range16.ptr(8184, 8188, 1), new Range16.ptr(8486, 8490, 4), new Range16.ptr(8491, 8498, 7), new Range16.ptr(8579, 11264, 2685), new Range16.ptr(11265, 11310, 1), new Range16.ptr(11360, 11362, 2), new Range16.ptr(11363, 11364, 1), new Range16.ptr(11367, 11373, 2), new Range16.ptr(11374, 11376, 1), new Range16.ptr(11378, 11381, 3), new Range16.ptr(11390, 11392, 1), new Range16.ptr(11394, 11490, 2), new Range16.ptr(11499, 11501, 2), new Range16.ptr(11506, 42560, 31054), new Range16.ptr(42562, 42604, 2), new Range16.ptr(42624, 42650, 2), new Range16.ptr(42786, 42798, 2), new Range16.ptr(42802, 42862, 2), new Range16.ptr(42873, 42877, 2), new Range16.ptr(42878, 42886, 2), new Range16.ptr(42891, 42893, 2), new Range16.ptr(42896, 42898, 2), new Range16.ptr(42902, 42922, 2), new Range16.ptr(42923, 42926, 1), new Range16.ptr(42928, 42932, 1), new Range16.ptr(42934, 65313, 22379), new Range16.ptr(65314, 65338, 1)]), new sliceType$1([new Range32.ptr(66560, 66599, 1), new Range32.ptr(66736, 66771, 1), new Range32.ptr(68736, 68786, 1), new Range32.ptr(71840, 71871, 1), new Range32.ptr(125184, 125217, 1)]), 3);
		foldLt = new RangeTable.ptr(new sliceType([new Range16.ptr(452, 454, 2), new Range16.ptr(455, 457, 2), new Range16.ptr(458, 460, 2), new Range16.ptr(497, 499, 2), new Range16.ptr(8064, 8071, 1), new Range16.ptr(8080, 8087, 1), new Range16.ptr(8096, 8103, 1), new Range16.ptr(8115, 8131, 16), new Range16.ptr(8179, 8179, 1)]), sliceType$1.nil, 0);
		foldLu = new RangeTable.ptr(new sliceType([new Range16.ptr(97, 122, 1), new Range16.ptr(181, 223, 42), new Range16.ptr(224, 246, 1), new Range16.ptr(248, 255, 1), new Range16.ptr(257, 303, 2), new Range16.ptr(307, 311, 2), new Range16.ptr(314, 328, 2), new Range16.ptr(331, 375, 2), new Range16.ptr(378, 382, 2), new Range16.ptr(383, 384, 1), new Range16.ptr(387, 389, 2), new Range16.ptr(392, 396, 4), new Range16.ptr(402, 405, 3), new Range16.ptr(409, 410, 1), new Range16.ptr(414, 417, 3), new Range16.ptr(419, 421, 2), new Range16.ptr(424, 429, 5), new Range16.ptr(432, 436, 4), new Range16.ptr(438, 441, 3), new Range16.ptr(445, 447, 2), new Range16.ptr(453, 454, 1), new Range16.ptr(456, 457, 1), new Range16.ptr(459, 460, 1), new Range16.ptr(462, 476, 2), new Range16.ptr(477, 495, 2), new Range16.ptr(498, 499, 1), new Range16.ptr(501, 505, 4), new Range16.ptr(507, 543, 2), new Range16.ptr(547, 563, 2), new Range16.ptr(572, 575, 3), new Range16.ptr(576, 578, 2), new Range16.ptr(583, 591, 2), new Range16.ptr(592, 596, 1), new Range16.ptr(598, 599, 1), new Range16.ptr(601, 603, 2), new Range16.ptr(604, 608, 4), new Range16.ptr(609, 613, 2), new Range16.ptr(614, 616, 2), new Range16.ptr(617, 620, 1), new Range16.ptr(623, 625, 2), new Range16.ptr(626, 629, 3), new Range16.ptr(637, 643, 3), new Range16.ptr(647, 652, 1), new Range16.ptr(658, 669, 11), new Range16.ptr(670, 837, 167), new Range16.ptr(881, 883, 2), new Range16.ptr(887, 891, 4), new Range16.ptr(892, 893, 1), new Range16.ptr(940, 943, 1), new Range16.ptr(945, 974, 1), new Range16.ptr(976, 977, 1), new Range16.ptr(981, 983, 1), new Range16.ptr(985, 1007, 2), new Range16.ptr(1008, 1011, 1), new Range16.ptr(1013, 1019, 3), new Range16.ptr(1072, 1119, 1), new Range16.ptr(1121, 1153, 2), new Range16.ptr(1163, 1215, 2), new Range16.ptr(1218, 1230, 2), new Range16.ptr(1231, 1327, 2), new Range16.ptr(1377, 1414, 1), new Range16.ptr(5112, 5117, 1), new Range16.ptr(7296, 7304, 1), new Range16.ptr(7545, 7549, 4), new Range16.ptr(7681, 7829, 2), new Range16.ptr(7835, 7841, 6), new Range16.ptr(7843, 7935, 2), new Range16.ptr(7936, 7943, 1), new Range16.ptr(7952, 7957, 1), new Range16.ptr(7968, 7975, 1), new Range16.ptr(7984, 7991, 1), new Range16.ptr(8000, 8005, 1), new Range16.ptr(8017, 8023, 2), new Range16.ptr(8032, 8039, 1), new Range16.ptr(8048, 8061, 1), new Range16.ptr(8112, 8113, 1), new Range16.ptr(8126, 8144, 18), new Range16.ptr(8145, 8160, 15), new Range16.ptr(8161, 8165, 4), new Range16.ptr(8526, 8580, 54), new Range16.ptr(11312, 11358, 1), new Range16.ptr(11361, 11365, 4), new Range16.ptr(11366, 11372, 2), new Range16.ptr(11379, 11382, 3), new Range16.ptr(11393, 11491, 2), new Range16.ptr(11500, 11502, 2), new Range16.ptr(11507, 11520, 13), new Range16.ptr(11521, 11557, 1), new Range16.ptr(11559, 11565, 6), new Range16.ptr(42561, 42605, 2), new Range16.ptr(42625, 42651, 2), new Range16.ptr(42787, 42799, 2), new Range16.ptr(42803, 42863, 2), new Range16.ptr(42874, 42876, 2), new Range16.ptr(42879, 42887, 2), new Range16.ptr(42892, 42897, 5), new Range16.ptr(42899, 42903, 4), new Range16.ptr(42905, 42921, 2), new Range16.ptr(42933, 42935, 2), new Range16.ptr(43859, 43888, 29), new Range16.ptr(43889, 43967, 1), new Range16.ptr(65345, 65370, 1)]), new sliceType$1([new Range32.ptr(66600, 66639, 1), new Range32.ptr(66776, 66811, 1), new Range32.ptr(68800, 68850, 1), new Range32.ptr(71872, 71903, 1), new Range32.ptr(125218, 125251, 1)]), 4);
		foldM = new RangeTable.ptr(new sliceType([new Range16.ptr(921, 953, 32), new Range16.ptr(8126, 8126, 1)]), sliceType$1.nil, 0);
		foldMn = new RangeTable.ptr(new sliceType([new Range16.ptr(921, 953, 32), new Range16.ptr(8126, 8126, 1)]), sliceType$1.nil, 0);
		$pkg.FoldCategory = $makeMap($String.keyFor, [{ k: "L", v: foldL }, { k: "Ll", v: foldLl }, { k: "Lt", v: foldLt }, { k: "Lu", v: foldLu }, { k: "M", v: foldM }, { k: "Mn", v: foldMn }]);
		foldCommon = new RangeTable.ptr(new sliceType([new Range16.ptr(924, 956, 32)]), sliceType$1.nil, 0);
		foldGreek = new RangeTable.ptr(new sliceType([new Range16.ptr(181, 837, 656)]), sliceType$1.nil, 0);
		foldInherited = new RangeTable.ptr(new sliceType([new Range16.ptr(921, 953, 32), new Range16.ptr(8126, 8126, 1)]), sliceType$1.nil, 0);
		$pkg.FoldScript = $makeMap($String.keyFor, [{ k: "Common", v: foldCommon }, { k: "Greek", v: foldGreek }, { k: "Inherited", v: foldInherited }]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["unicode/utf8"] = (function() {
	var $pkg = {}, $init, acceptRange, first, acceptRanges, FullRune, DecodeRune, DecodeRuneInString, DecodeLastRune, DecodeLastRuneInString, RuneLen, EncodeRune, RuneCount, RuneCountInString, RuneStart, ValidString, ValidRune;
	acceptRange = $pkg.acceptRange = $newType(0, $kindStruct, "utf8.acceptRange", true, "unicode/utf8", false, function(lo_, hi_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.lo = 0;
			this.hi = 0;
			return;
		}
		this.lo = lo_;
		this.hi = hi_;
	});
	FullRune = function(p) {
		var accept, n, p, x, x$1, x$2;
		n = p.$length;
		if (n === 0) {
			return false;
		}
		x$1 = (x = (0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]), ((x < 0 || x >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[x]));
		if (n >= ((((x$1 & 7) >>> 0) >> 0))) {
			return true;
		}
		accept = $clone((x$2 = x$1 >>> 4 << 24 >>> 24, ((x$2 < 0 || x$2 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$2])), acceptRange);
		if (n > 1 && ((1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]) < accept.lo || accept.hi < (1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]))) {
			return true;
		} else if (n > 2 && ((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]) < 128 || 191 < (2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]))) {
			return true;
		}
		return false;
	};
	$pkg.FullRune = FullRune;
	DecodeRune = function(p) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, accept, b1, b2, b3, mask, n, p, p0, r, size, sz, x, x$1;
		r = 0;
		size = 0;
		n = p.$length;
		if (n < 1) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		p0 = (0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]);
		x = ((p0 < 0 || p0 >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[p0]);
		if (x >= 240) {
			mask = (((x >> 0)) << 31 >> 0) >> 31 >> 0;
			_tmp$2 = (((((0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]) >> 0)) & ~mask) >> 0) | (65533 & mask);
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		sz = (x & 7) >>> 0;
		accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
		if (n < ((sz >> 0))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		b1 = (1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]);
		if (b1 < accept.lo || accept.hi < b1) {
			_tmp$6 = 65533;
			_tmp$7 = 1;
			r = _tmp$6;
			size = _tmp$7;
			return [r, size];
		}
		if (sz === 2) {
			_tmp$8 = (((((p0 & 31) >>> 0) >> 0)) << 6 >> 0) | ((((b1 & 63) >>> 0) >> 0));
			_tmp$9 = 2;
			r = _tmp$8;
			size = _tmp$9;
			return [r, size];
		}
		b2 = (2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]);
		if (b2 < 128 || 191 < b2) {
			_tmp$10 = 65533;
			_tmp$11 = 1;
			r = _tmp$10;
			size = _tmp$11;
			return [r, size];
		}
		if (sz === 3) {
			_tmp$12 = ((((((p0 & 15) >>> 0) >> 0)) << 12 >> 0) | (((((b1 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((b2 & 63) >>> 0) >> 0));
			_tmp$13 = 3;
			r = _tmp$12;
			size = _tmp$13;
			return [r, size];
		}
		b3 = (3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3]);
		if (b3 < 128 || 191 < b3) {
			_tmp$14 = 65533;
			_tmp$15 = 1;
			r = _tmp$14;
			size = _tmp$15;
			return [r, size];
		}
		_tmp$16 = (((((((p0 & 7) >>> 0) >> 0)) << 18 >> 0) | (((((b1 & 63) >>> 0) >> 0)) << 12 >> 0)) | (((((b2 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((b3 & 63) >>> 0) >> 0));
		_tmp$17 = 4;
		r = _tmp$16;
		size = _tmp$17;
		return [r, size];
	};
	$pkg.DecodeRune = DecodeRune;
	DecodeRuneInString = function(s) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, accept, mask, n, r, s, s0, s1, s2, s3, size, sz, x, x$1;
		r = 0;
		size = 0;
		n = s.length;
		if (n < 1) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		s0 = s.charCodeAt(0);
		x = ((s0 < 0 || s0 >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[s0]);
		if (x >= 240) {
			mask = (((x >> 0)) << 31 >> 0) >> 31 >> 0;
			_tmp$2 = ((((s.charCodeAt(0) >> 0)) & ~mask) >> 0) | (65533 & mask);
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		sz = (x & 7) >>> 0;
		accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
		if (n < ((sz >> 0))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		s1 = s.charCodeAt(1);
		if (s1 < accept.lo || accept.hi < s1) {
			_tmp$6 = 65533;
			_tmp$7 = 1;
			r = _tmp$6;
			size = _tmp$7;
			return [r, size];
		}
		if (sz === 2) {
			_tmp$8 = (((((s0 & 31) >>> 0) >> 0)) << 6 >> 0) | ((((s1 & 63) >>> 0) >> 0));
			_tmp$9 = 2;
			r = _tmp$8;
			size = _tmp$9;
			return [r, size];
		}
		s2 = s.charCodeAt(2);
		if (s2 < 128 || 191 < s2) {
			_tmp$10 = 65533;
			_tmp$11 = 1;
			r = _tmp$10;
			size = _tmp$11;
			return [r, size];
		}
		if (sz === 3) {
			_tmp$12 = ((((((s0 & 15) >>> 0) >> 0)) << 12 >> 0) | (((((s1 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((s2 & 63) >>> 0) >> 0));
			_tmp$13 = 3;
			r = _tmp$12;
			size = _tmp$13;
			return [r, size];
		}
		s3 = s.charCodeAt(3);
		if (s3 < 128 || 191 < s3) {
			_tmp$14 = 65533;
			_tmp$15 = 1;
			r = _tmp$14;
			size = _tmp$15;
			return [r, size];
		}
		_tmp$16 = (((((((s0 & 7) >>> 0) >> 0)) << 18 >> 0) | (((((s1 & 63) >>> 0) >> 0)) << 12 >> 0)) | (((((s2 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((s3 & 63) >>> 0) >> 0));
		_tmp$17 = 4;
		r = _tmp$16;
		size = _tmp$17;
		return [r, size];
	};
	$pkg.DecodeRuneInString = DecodeRuneInString;
	DecodeLastRune = function(p) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, end, lim, p, r, size, start;
		r = 0;
		size = 0;
		end = p.$length;
		if (end === 0) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		start = end - 1 >> 0;
		r = ((((start < 0 || start >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + start]) >> 0));
		if (r < 128) {
			_tmp$2 = r;
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		lim = end - 4 >> 0;
		if (lim < 0) {
			lim = 0;
		}
		start = start - (1) >> 0;
		while (true) {
			if (!(start >= lim)) { break; }
			if (RuneStart(((start < 0 || start >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + start]))) {
				break;
			}
			start = start - (1) >> 0;
		}
		if (start < 0) {
			start = 0;
		}
		_tuple = DecodeRune($subslice(p, start, end));
		r = _tuple[0];
		size = _tuple[1];
		if (!(((start + size >> 0) === end))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		_tmp$6 = r;
		_tmp$7 = size;
		r = _tmp$6;
		size = _tmp$7;
		return [r, size];
	};
	$pkg.DecodeLastRune = DecodeLastRune;
	DecodeLastRuneInString = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, end, lim, r, s, size, start;
		r = 0;
		size = 0;
		end = s.length;
		if (end === 0) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		start = end - 1 >> 0;
		r = ((s.charCodeAt(start) >> 0));
		if (r < 128) {
			_tmp$2 = r;
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		lim = end - 4 >> 0;
		if (lim < 0) {
			lim = 0;
		}
		start = start - (1) >> 0;
		while (true) {
			if (!(start >= lim)) { break; }
			if (RuneStart(s.charCodeAt(start))) {
				break;
			}
			start = start - (1) >> 0;
		}
		if (start < 0) {
			start = 0;
		}
		_tuple = DecodeRuneInString($substring(s, start, end));
		r = _tuple[0];
		size = _tuple[1];
		if (!(((start + size >> 0) === end))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		_tmp$6 = r;
		_tmp$7 = size;
		r = _tmp$6;
		size = _tmp$7;
		return [r, size];
	};
	$pkg.DecodeLastRuneInString = DecodeLastRuneInString;
	RuneLen = function(r) {
		var r;
		if (r < 0) {
			return -1;
		} else if (r <= 127) {
			return 1;
		} else if (r <= 2047) {
			return 2;
		} else if (55296 <= r && r <= 57343) {
			return -1;
		} else if (r <= 65535) {
			return 3;
		} else if (r <= 1114111) {
			return 4;
		}
		return -1;
	};
	$pkg.RuneLen = RuneLen;
	EncodeRune = function(p, r) {
		var i, p, r;
		i = ((r >>> 0));
		if (i <= 127) {
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((r << 24 >>> 24)));
			return 1;
		} else if (i <= 2047) {
			$unused((1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((192 | (((r >> 6 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 2;
		} else if ((i > 1114111) || (55296 <= i && i <= 57343)) {
			r = 65533;
			$unused((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((224 | (((r >> 12 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 3;
		} else if (i <= 65535) {
			$unused((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((224 | (((r >> 12 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 3;
		} else {
			$unused((3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((240 | (((r >> 18 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 12 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 4;
		}
	};
	$pkg.EncodeRune = EncodeRune;
	RuneCount = function(p) {
		var accept, c, c$1, c$2, c$3, i, n, np, p, size, x, x$1, x$2, x$3, x$4;
		np = p.$length;
		n = 0;
		i = 0;
		while (true) {
			if (!(i < np)) { break; }
			n = n + (1) >> 0;
			c = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]);
			if (c < 128) {
				i = i + (1) >> 0;
				continue;
			}
			x = ((c < 0 || c >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[c]);
			if (x === 241) {
				i = i + (1) >> 0;
				continue;
			}
			size = ((((x & 7) >>> 0) >> 0));
			if ((i + size >> 0) > np) {
				i = i + (1) >> 0;
				continue;
			}
			accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
			c$1 = (x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$2]));
			if (c$1 < accept.lo || accept.hi < c$1) {
				size = 1;
			} else if (size === 2) {
			} else {
				c$2 = (x$3 = i + 2 >> 0, ((x$3 < 0 || x$3 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$3]));
				if (c$2 < 128 || 191 < c$2) {
					size = 1;
				} else if (size === 3) {
				} else {
					c$3 = (x$4 = i + 3 >> 0, ((x$4 < 0 || x$4 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$4]));
					if (c$3 < 128 || 191 < c$3) {
						size = 1;
					}
				}
			}
			i = i + (size) >> 0;
		}
		return n;
	};
	$pkg.RuneCount = RuneCount;
	RuneCountInString = function(s) {
		var accept, c, c$1, c$2, c$3, i, n, ns, s, size, x, x$1;
		n = 0;
		ns = s.length;
		i = 0;
		while (true) {
			if (!(i < ns)) { break; }
			c = s.charCodeAt(i);
			if (c < 128) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			x = ((c < 0 || c >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[c]);
			if (x === 241) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			size = ((((x & 7) >>> 0) >> 0));
			if ((i + size >> 0) > ns) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
			c$1 = s.charCodeAt((i + 1 >> 0));
			if (c$1 < accept.lo || accept.hi < c$1) {
				size = 1;
			} else if (size === 2) {
			} else {
				c$2 = s.charCodeAt((i + 2 >> 0));
				if (c$2 < 128 || 191 < c$2) {
					size = 1;
				} else if (size === 3) {
				} else {
					c$3 = s.charCodeAt((i + 3 >> 0));
					if (c$3 < 128 || 191 < c$3) {
						size = 1;
					}
				}
			}
			i = i + (size) >> 0;
			n = n + (1) >> 0;
		}
		n = n;
		return n;
	};
	$pkg.RuneCountInString = RuneCountInString;
	RuneStart = function(b) {
		var b;
		return !((((b & 192) >>> 0) === 128));
	};
	$pkg.RuneStart = RuneStart;
	ValidString = function(s) {
		var accept, c, c$1, c$2, i, n, s, si, size, x, x$1;
		n = s.length;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			si = s.charCodeAt(i);
			if (si < 128) {
				i = i + (1) >> 0;
				continue;
			}
			x = ((si < 0 || si >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[si]);
			if (x === 241) {
				return false;
			}
			size = ((((x & 7) >>> 0) >> 0));
			if ((i + size >> 0) > n) {
				return false;
			}
			accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
			c = s.charCodeAt((i + 1 >> 0));
			if (c < accept.lo || accept.hi < c) {
				return false;
			} else if (size === 2) {
			} else {
				c$1 = s.charCodeAt((i + 2 >> 0));
				if (c$1 < 128 || 191 < c$1) {
					return false;
				} else if (size === 3) {
				} else {
					c$2 = s.charCodeAt((i + 3 >> 0));
					if (c$2 < 128 || 191 < c$2) {
						return false;
					}
				}
			}
			i = i + (size) >> 0;
		}
		return true;
	};
	$pkg.ValidString = ValidString;
	ValidRune = function(r) {
		var r;
		if (0 <= r && r < 55296) {
			return true;
		} else if (57343 < r && r <= 1114111) {
			return true;
		}
		return false;
	};
	$pkg.ValidRune = ValidRune;
	acceptRange.init("unicode/utf8", [{prop: "lo", name: "lo", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "hi", name: "hi", embedded: false, exported: false, typ: $Uint8, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		first = $toNativeArray($kindUint8, [240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 19, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 35, 3, 3, 52, 4, 4, 4, 68, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241]);
		acceptRanges = $toNativeArray($kindStruct, [new acceptRange.ptr(128, 191), new acceptRange.ptr(160, 191), new acceptRange.ptr(128, 159), new acceptRange.ptr(144, 191), new acceptRange.ptr(128, 143)]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["bytes"] = (function() {
	var $pkg = {}, $init, errors, bytealg, io, unicode, utf8, Buffer, readOp, Reader, ptrType, sliceType, ptrType$2, errNegativeRead, IndexByte, Equal, makeSlice, HasPrefix, Index, indexRabinKarp, hashStr, NewReader;
	errors = $packages["errors"];
	bytealg = $packages["internal/bytealg"];
	io = $packages["io"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Buffer = $pkg.Buffer = $newType(0, $kindStruct, "bytes.Buffer", true, "bytes", true, function(buf_, off_, lastRead_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = sliceType.nil;
			this.off = 0;
			this.lastRead = 0;
			return;
		}
		this.buf = buf_;
		this.off = off_;
		this.lastRead = lastRead_;
	});
	readOp = $pkg.readOp = $newType(1, $kindInt8, "bytes.readOp", true, "bytes", false, null);
	Reader = $pkg.Reader = $newType(0, $kindStruct, "bytes.Reader", true, "bytes", true, function(s_, i_, prevRune_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.s = sliceType.nil;
			this.i = new $Int64(0, 0);
			this.prevRune = 0;
			return;
		}
		this.s = s_;
		this.i = i_;
		this.prevRune = prevRune_;
	});
	ptrType = $ptrType(Buffer);
	sliceType = $sliceType($Uint8);
	ptrType$2 = $ptrType(Reader);
	IndexByte = function(s, c) {
		var _i, _ref, b, c, i, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (b === c) {
				return i;
			}
			_i++;
		}
		return -1;
	};
	$pkg.IndexByte = IndexByte;
	Equal = function(a, b) {
		var _i, _ref, a, b, c, i;
		if (!((a.$length === b.$length))) {
			return false;
		}
		_ref = a;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((c === ((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i])))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	$pkg.Equal = Equal;
	Buffer.ptr.prototype.Bytes = function() {
		var b;
		b = this;
		return $subslice(b.buf, b.off);
	};
	Buffer.prototype.Bytes = function() { return this.$val.Bytes(); };
	Buffer.ptr.prototype.String = function() {
		var b;
		b = this;
		if (b === ptrType.nil) {
			return "<nil>";
		}
		return ($bytesToString($subslice(b.buf, b.off)));
	};
	Buffer.prototype.String = function() { return this.$val.String(); };
	Buffer.ptr.prototype.empty = function() {
		var b;
		b = this;
		return b.buf.$length <= b.off;
	};
	Buffer.prototype.empty = function() { return this.$val.empty(); };
	Buffer.ptr.prototype.Len = function() {
		var b;
		b = this;
		return b.buf.$length - b.off >> 0;
	};
	Buffer.prototype.Len = function() { return this.$val.Len(); };
	Buffer.ptr.prototype.Cap = function() {
		var b;
		b = this;
		return b.buf.$capacity;
	};
	Buffer.prototype.Cap = function() { return this.$val.Cap(); };
	Buffer.ptr.prototype.Truncate = function(n) {
		var b, n;
		b = this;
		if (n === 0) {
			b.Reset();
			return;
		}
		b.lastRead = 0;
		if (n < 0 || n > b.Len()) {
			$panic(new $String("bytes.Buffer: truncation out of range"));
		}
		b.buf = $subslice(b.buf, 0, (b.off + n >> 0));
	};
	Buffer.prototype.Truncate = function(n) { return this.$val.Truncate(n); };
	Buffer.ptr.prototype.Reset = function() {
		var b;
		b = this;
		b.buf = $subslice(b.buf, 0, 0);
		b.off = 0;
		b.lastRead = 0;
	};
	Buffer.prototype.Reset = function() { return this.$val.Reset(); };
	Buffer.ptr.prototype.tryGrowByReslice = function(n) {
		var b, l, n;
		b = this;
		l = b.buf.$length;
		if (n <= (b.buf.$capacity - l >> 0)) {
			b.buf = $subslice(b.buf, 0, (l + n >> 0));
			return [l, true];
		}
		return [0, false];
	};
	Buffer.prototype.tryGrowByReslice = function(n) { return this.$val.tryGrowByReslice(n); };
	Buffer.ptr.prototype.grow = function(n) {
		var _q, _tuple, b, buf, c, i, m, n, ok;
		b = this;
		m = b.Len();
		if ((m === 0) && !((b.off === 0))) {
			b.Reset();
		}
		_tuple = b.tryGrowByReslice(n);
		i = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			return i;
		}
		if (b.buf === sliceType.nil && n <= 64) {
			b.buf = $makeSlice(sliceType, n, 64);
			return 0;
		}
		c = b.buf.$capacity;
		if (n <= ((_q = c / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) - m >> 0)) {
			$copySlice(b.buf, $subslice(b.buf, b.off));
		} else if (c > ((2147483647 - c >> 0) - n >> 0)) {
			$panic($pkg.ErrTooLarge);
		} else {
			buf = makeSlice(($imul(2, c)) + n >> 0);
			$copySlice(buf, $subslice(b.buf, b.off));
			b.buf = buf;
		}
		b.off = 0;
		b.buf = $subslice(b.buf, 0, (m + n >> 0));
		return m;
	};
	Buffer.prototype.grow = function(n) { return this.$val.grow(n); };
	Buffer.ptr.prototype.Grow = function(n) {
		var b, m, n;
		b = this;
		if (n < 0) {
			$panic(new $String("bytes.Buffer.Grow: negative count"));
		}
		m = b.grow(n);
		b.buf = $subslice(b.buf, 0, m);
	};
	Buffer.prototype.Grow = function(n) { return this.$val.Grow(n); };
	Buffer.ptr.prototype.Write = function(p) {
		var _tmp, _tmp$1, _tuple, b, err, m, n, ok, p;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(p.$length);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(p.$length);
		}
		_tmp = $copySlice($subslice(b.buf, m), p);
		_tmp$1 = $ifaceNil;
		n = _tmp;
		err = _tmp$1;
		return [n, err];
	};
	Buffer.prototype.Write = function(p) { return this.$val.Write(p); };
	Buffer.ptr.prototype.WriteString = function(s) {
		var _tmp, _tmp$1, _tuple, b, err, m, n, ok, s;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(s.length);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(s.length);
		}
		_tmp = $copyString($subslice(b.buf, m), s);
		_tmp$1 = $ifaceNil;
		n = _tmp;
		err = _tmp$1;
		return [n, err];
	};
	Buffer.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	Buffer.ptr.prototype.ReadFrom = function(r) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, i, m, n, r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; i = $f.i; m = $f.m; n = $f.n; r = $f.r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		/* while (true) { */ case 1:
			i = b.grow(512);
			b.buf = $subslice(b.buf, 0, i);
			_r = r.Read($subslice(b.buf, i, b.buf.$capacity)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (m < 0) {
				$panic(errNegativeRead);
			}
			b.buf = $subslice(b.buf, 0, (i + m >> 0));
			n = (x = (new $Int64(0, m)), new $Int64(n.$high + x.$high, n.$low + x.$low));
			if ($interfaceIsEqual(e, io.EOF)) {
				_tmp = n;
				_tmp$1 = $ifaceNil;
				n = _tmp;
				err = _tmp$1;
				$s = -1; return [n, err];
			}
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				_tmp$2 = n;
				_tmp$3 = e;
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Buffer.ptr.prototype.ReadFrom }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.i = i; $f.m = m; $f.n = n; $f.r = r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Buffer.prototype.ReadFrom = function(r) { return this.$val.ReadFrom(r); };
	makeSlice = function(n) {
		var n, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$deferred.push([(function() {
			if (!($interfaceIsEqual($recover(), $ifaceNil))) {
				$panic($pkg.ErrTooLarge);
			}
		}), []]);
		return $makeSlice(sliceType, n);
		/* */ } catch(err) { $err = err; return sliceType.nil; } finally { $callDeferred($deferred, $err); }
	};
	Buffer.ptr.prototype.WriteTo = function(w) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, b, e, err, m, n, nBytes, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; m = $f.m; n = $f.n; nBytes = $f.nBytes; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		nBytes = b.Len();
		/* */ if (nBytes > 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (nBytes > 0) { */ case 1:
			_r = w.Write($subslice(b.buf, b.off)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (m > nBytes) {
				$panic(new $String("bytes.Buffer.WriteTo: invalid Write count"));
			}
			b.off = b.off + (m) >> 0;
			n = (new $Int64(0, m));
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				_tmp = n;
				_tmp$1 = e;
				n = _tmp;
				err = _tmp$1;
				$s = -1; return [n, err];
			}
			if (!((m === nBytes))) {
				_tmp$2 = n;
				_tmp$3 = io.ErrShortWrite;
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
		/* } */ case 2:
		b.Reset();
		_tmp$4 = n;
		_tmp$5 = $ifaceNil;
		n = _tmp$4;
		err = _tmp$5;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Buffer.ptr.prototype.WriteTo }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.m = m; $f.n = n; $f.nBytes = nBytes; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Buffer.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Buffer.ptr.prototype.WriteByte = function(c) {
		var _tuple, b, c, m, ok, x;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(1);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(1);
		}
		(x = b.buf, ((m < 0 || m >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + m] = c));
		return $ifaceNil;
	};
	Buffer.prototype.WriteByte = function(c) { return this.$val.WriteByte(c); };
	Buffer.ptr.prototype.WriteRune = function(r) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, err, m, n, ok, r;
		n = 0;
		err = $ifaceNil;
		b = this;
		if (r < 128) {
			b.WriteByte(((r << 24 >>> 24)));
			_tmp = 1;
			_tmp$1 = $ifaceNil;
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(4);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(4);
		}
		n = utf8.EncodeRune($subslice(b.buf, m, (m + 4 >> 0)), r);
		b.buf = $subslice(b.buf, 0, (m + n >> 0));
		_tmp$2 = n;
		_tmp$3 = $ifaceNil;
		n = _tmp$2;
		err = _tmp$3;
		return [n, err];
	};
	Buffer.prototype.WriteRune = function(r) { return this.$val.WriteRune(r); };
	Buffer.ptr.prototype.Read = function(p) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, err, n, p;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		if (b.empty()) {
			b.Reset();
			if (p.$length === 0) {
				_tmp = 0;
				_tmp$1 = $ifaceNil;
				n = _tmp;
				err = _tmp$1;
				return [n, err];
			}
			_tmp$2 = 0;
			_tmp$3 = io.EOF;
			n = _tmp$2;
			err = _tmp$3;
			return [n, err];
		}
		n = $copySlice(p, $subslice(b.buf, b.off));
		b.off = b.off + (n) >> 0;
		if (n > 0) {
			b.lastRead = -1;
		}
		_tmp$4 = n;
		_tmp$5 = $ifaceNil;
		n = _tmp$4;
		err = _tmp$5;
		return [n, err];
	};
	Buffer.prototype.Read = function(p) { return this.$val.Read(p); };
	Buffer.ptr.prototype.Next = function(n) {
		var b, data, m, n;
		b = this;
		b.lastRead = 0;
		m = b.Len();
		if (n > m) {
			n = m;
		}
		data = $subslice(b.buf, b.off, (b.off + n >> 0));
		b.off = b.off + (n) >> 0;
		if (n > 0) {
			b.lastRead = -1;
		}
		return data;
	};
	Buffer.prototype.Next = function(n) { return this.$val.Next(n); };
	Buffer.ptr.prototype.ReadByte = function() {
		var b, c, x, x$1;
		b = this;
		if (b.empty()) {
			b.Reset();
			return [0, io.EOF];
		}
		c = (x = b.buf, x$1 = b.off, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		b.off = b.off + (1) >> 0;
		b.lastRead = -1;
		return [c, $ifaceNil];
	};
	Buffer.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Buffer.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tuple, b, c, err, n, r, size, x, x$1;
		r = 0;
		size = 0;
		err = $ifaceNil;
		b = this;
		if (b.empty()) {
			b.Reset();
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = io.EOF;
			r = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			return [r, size, err];
		}
		c = (x = b.buf, x$1 = b.off, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (c < 128) {
			b.off = b.off + (1) >> 0;
			b.lastRead = 1;
			_tmp$3 = ((c >> 0));
			_tmp$4 = 1;
			_tmp$5 = $ifaceNil;
			r = _tmp$3;
			size = _tmp$4;
			err = _tmp$5;
			return [r, size, err];
		}
		_tuple = utf8.DecodeRune($subslice(b.buf, b.off));
		r = _tuple[0];
		n = _tuple[1];
		b.off = b.off + (n) >> 0;
		b.lastRead = ((n << 24 >> 24));
		_tmp$6 = r;
		_tmp$7 = n;
		_tmp$8 = $ifaceNil;
		r = _tmp$6;
		size = _tmp$7;
		err = _tmp$8;
		return [r, size, err];
	};
	Buffer.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Buffer.ptr.prototype.UnreadRune = function() {
		var b;
		b = this;
		if (b.lastRead <= 0) {
			return errors.New("bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune");
		}
		if (b.off >= ((b.lastRead >> 0))) {
			b.off = b.off - (((b.lastRead >> 0))) >> 0;
		}
		b.lastRead = 0;
		return $ifaceNil;
	};
	Buffer.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Buffer.ptr.prototype.UnreadByte = function() {
		var b;
		b = this;
		if (b.lastRead === 0) {
			return errors.New("bytes.Buffer: UnreadByte: previous operation was not a successful read");
		}
		b.lastRead = 0;
		if (b.off > 0) {
			b.off = b.off - (1) >> 0;
		}
		return $ifaceNil;
	};
	Buffer.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Buffer.ptr.prototype.ReadBytes = function(delim) {
		var _tmp, _tmp$1, _tuple, b, delim, err, line, slice;
		line = sliceType.nil;
		err = $ifaceNil;
		b = this;
		_tuple = b.readSlice(delim);
		slice = _tuple[0];
		err = _tuple[1];
		line = $appendSlice(line, slice);
		_tmp = line;
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.ReadBytes = function(delim) { return this.$val.ReadBytes(delim); };
	Buffer.ptr.prototype.readSlice = function(delim) {
		var _tmp, _tmp$1, b, delim, end, err, i, line;
		line = sliceType.nil;
		err = $ifaceNil;
		b = this;
		i = IndexByte($subslice(b.buf, b.off), delim);
		end = (b.off + i >> 0) + 1 >> 0;
		if (i < 0) {
			end = b.buf.$length;
			err = io.EOF;
		}
		line = $subslice(b.buf, b.off, end);
		b.off = end;
		b.lastRead = -1;
		_tmp = line;
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.readSlice = function(delim) { return this.$val.readSlice(delim); };
	Buffer.ptr.prototype.ReadString = function(delim) {
		var _tmp, _tmp$1, _tuple, b, delim, err, line, slice;
		line = "";
		err = $ifaceNil;
		b = this;
		_tuple = b.readSlice(delim);
		slice = _tuple[0];
		err = _tuple[1];
		_tmp = ($bytesToString(slice));
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.ReadString = function(delim) { return this.$val.ReadString(delim); };
	HasPrefix = function(s, prefix) {
		var prefix, s;
		return s.$length >= prefix.$length && Equal($subslice(s, 0, prefix.$length), prefix);
	};
	$pkg.HasPrefix = HasPrefix;
	Index = function(s, sep) {
		var c0, c0$1, c1, c1$1, fails, fails$1, i, i$1, j, n, o, o$1, r, s, sep, t, t$1, x, x$1;
		n = sep.$length;
		if ((n === 0)) {
			return 0;
		} else if ((n === 1)) {
			return IndexByte(s, (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]));
		} else if ((n === s.$length)) {
			if (Equal(sep, s)) {
				return 0;
			}
			return -1;
		} else if (n > s.$length) {
			return -1;
		} else if (n <= bytealg.MaxLen) {
			if (s.$length <= 0) {
				return bytealg.Index(s, sep);
			}
			c0 = (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]);
			c1 = (1 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 1]);
			i = 0;
			t = (s.$length - n >> 0) + 1 >> 0;
			fails = 0;
			while (true) {
				if (!(i < t)) { break; }
				if (!((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) === c0))) {
					o = IndexByte($subslice(s, i, t), c0);
					if (o < 0) {
						return -1;
					}
					i = i + (o) >> 0;
				}
				if (((x = i + 1 >> 0, ((x < 0 || x >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x])) === c1) && Equal($subslice(s, i, (i + n >> 0)), sep)) {
					return i;
				}
				fails = fails + (1) >> 0;
				i = i + (1) >> 0;
				if (fails > bytealg.Cutover(i)) {
					r = bytealg.Index($subslice(s, i), sep);
					if (r >= 0) {
						return r + i >> 0;
					}
					return -1;
				}
			}
			return -1;
		}
		c0$1 = (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]);
		c1$1 = (1 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 1]);
		i$1 = 0;
		fails$1 = 0;
		t$1 = (s.$length - n >> 0) + 1 >> 0;
		while (true) {
			if (!(i$1 < t$1)) { break; }
			if (!((((i$1 < 0 || i$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i$1]) === c0$1))) {
				o$1 = IndexByte($subslice(s, i$1, t$1), c0$1);
				if (o$1 < 0) {
					break;
				}
				i$1 = i$1 + (o$1) >> 0;
			}
			if (((x$1 = i$1 + 1 >> 0, ((x$1 < 0 || x$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x$1])) === c1$1) && Equal($subslice(s, i$1, (i$1 + n >> 0)), sep)) {
				return i$1;
			}
			i$1 = i$1 + (1) >> 0;
			fails$1 = fails$1 + (1) >> 0;
			if (fails$1 >= (4 + (i$1 >> 4 >> 0) >> 0) && i$1 < t$1) {
				j = indexRabinKarp($subslice(s, i$1), sep);
				if (j < 0) {
					return -1;
				}
				return i$1 + j >> 0;
			}
		}
		return -1;
	};
	$pkg.Index = Index;
	indexRabinKarp = function(s, sep) {
		var _tuple, h, hashsep, i, i$1, n, pow, s, sep, x;
		_tuple = hashStr(sep);
		hashsep = _tuple[0];
		pow = _tuple[1];
		n = sep.$length;
		h = 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			h = ($imul(h, 16777619) >>> 0) + ((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) >>> 0)) >>> 0;
			i = i + (1) >> 0;
		}
		if ((h === hashsep) && Equal($subslice(s, 0, n), sep)) {
			return 0;
		}
		i$1 = n;
		while (true) {
			if (!(i$1 < s.$length)) { break; }
			h = $imul(h, (16777619)) >>> 0;
			h = h + (((((i$1 < 0 || i$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i$1]) >>> 0))) >>> 0;
			h = h - (($imul(pow, (((x = i$1 - n >> 0, ((x < 0 || x >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x])) >>> 0))) >>> 0)) >>> 0;
			i$1 = i$1 + (1) >> 0;
			if ((h === hashsep) && Equal($subslice(s, (i$1 - n >> 0), i$1), sep)) {
				return i$1 - n >> 0;
			}
		}
		return -1;
	};
	hashStr = function(sep) {
		var _tmp, _tmp$1, hash, i, i$1, pow, sep, sq;
		hash = 0;
		i = 0;
		while (true) {
			if (!(i < sep.$length)) { break; }
			hash = ($imul(hash, 16777619) >>> 0) + ((((i < 0 || i >= sep.$length) ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + i]) >>> 0)) >>> 0;
			i = i + (1) >> 0;
		}
		_tmp = 1;
		_tmp$1 = 16777619;
		pow = _tmp;
		sq = _tmp$1;
		i$1 = sep.$length;
		while (true) {
			if (!(i$1 > 0)) { break; }
			if (!(((i$1 & 1) === 0))) {
				pow = $imul(pow, (sq)) >>> 0;
			}
			sq = $imul(sq, (sq)) >>> 0;
			i$1 = (i$1 >> $min((1), 31)) >> 0;
		}
		return [hash, pow];
	};
	Reader.ptr.prototype.Len = function() {
		var r, x, x$1, x$2, x$3, x$4;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.$length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			return 0;
		}
		return (((x$2 = (x$3 = (new $Int64(0, r.s.$length)), x$4 = r.i, new $Int64(x$3.$high - x$4.$high, x$3.$low - x$4.$low)), x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0));
	};
	Reader.prototype.Len = function() { return this.$val.Len(); };
	Reader.ptr.prototype.Size = function() {
		var r;
		r = this;
		return (new $Int64(0, r.s.$length));
	};
	Reader.prototype.Size = function() { return this.$val.Size(); };
	Reader.ptr.prototype.Read = function(b) {
		var _tmp, _tmp$1, b, err, n, r, x, x$1, x$2, x$3;
		n = 0;
		err = $ifaceNil;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.$length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			_tmp = 0;
			_tmp$1 = io.EOF;
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		r.prevRune = -1;
		n = $copySlice(b, $subslice(r.s, $flatten64(r.i)));
		r.i = (x$2 = r.i, x$3 = (new $Int64(0, n)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		return [n, err];
	};
	Reader.prototype.Read = function(b) { return this.$val.Read(b); };
	Reader.ptr.prototype.ReadAt = function(b, off) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, b, err, n, off, r, x;
		n = 0;
		err = $ifaceNil;
		r = this;
		if ((off.$high < 0 || (off.$high === 0 && off.$low < 0))) {
			_tmp = 0;
			_tmp$1 = errors.New("bytes.Reader.ReadAt: negative offset");
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		if ((x = (new $Int64(0, r.s.$length)), (off.$high > x.$high || (off.$high === x.$high && off.$low >= x.$low)))) {
			_tmp$2 = 0;
			_tmp$3 = io.EOF;
			n = _tmp$2;
			err = _tmp$3;
			return [n, err];
		}
		n = $copySlice(b, $subslice(r.s, $flatten64(off)));
		if (n < b.$length) {
			err = io.EOF;
		}
		return [n, err];
	};
	Reader.prototype.ReadAt = function(b, off) { return this.$val.ReadAt(b, off); };
	Reader.ptr.prototype.ReadByte = function() {
		var b, r, x, x$1, x$2, x$3, x$4, x$5;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.$length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			return [0, io.EOF];
		}
		b = (x$2 = r.s, x$3 = r.i, (($flatten64(x$3) < 0 || $flatten64(x$3) >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + $flatten64(x$3)]));
		r.i = (x$4 = r.i, x$5 = new $Int64(0, 1), new $Int64(x$4.$high + x$5.$high, x$4.$low + x$5.$low));
		return [b, $ifaceNil];
	};
	Reader.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Reader.ptr.prototype.UnreadByte = function() {
		var r, x, x$1, x$2;
		r = this;
		if ((x = r.i, (x.$high < 0 || (x.$high === 0 && x.$low <= 0)))) {
			return errors.New("bytes.Reader.UnreadByte: at beginning of slice");
		}
		r.prevRune = -1;
		r.i = (x$1 = r.i, x$2 = new $Int64(0, 1), new $Int64(x$1.$high - x$2.$high, x$1.$low - x$2.$low));
		return $ifaceNil;
	};
	Reader.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Reader.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, c, ch, err, r, size, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8;
		ch = 0;
		size = 0;
		err = $ifaceNil;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.$length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			r.prevRune = -1;
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = io.EOF;
			ch = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			return [ch, size, err];
		}
		r.prevRune = (((x$2 = r.i, x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0));
		c = (x$3 = r.s, x$4 = r.i, (($flatten64(x$4) < 0 || $flatten64(x$4) >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + $flatten64(x$4)]));
		if (c < 128) {
			r.i = (x$5 = r.i, x$6 = new $Int64(0, 1), new $Int64(x$5.$high + x$6.$high, x$5.$low + x$6.$low));
			_tmp$3 = ((c >> 0));
			_tmp$4 = 1;
			_tmp$5 = $ifaceNil;
			ch = _tmp$3;
			size = _tmp$4;
			err = _tmp$5;
			return [ch, size, err];
		}
		_tuple = utf8.DecodeRune($subslice(r.s, $flatten64(r.i)));
		ch = _tuple[0];
		size = _tuple[1];
		r.i = (x$7 = r.i, x$8 = (new $Int64(0, size)), new $Int64(x$7.$high + x$8.$high, x$7.$low + x$8.$low));
		return [ch, size, err];
	};
	Reader.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Reader.ptr.prototype.UnreadRune = function() {
		var r, x;
		r = this;
		if ((x = r.i, (x.$high < 0 || (x.$high === 0 && x.$low <= 0)))) {
			return errors.New("bytes.Reader.UnreadRune: at beginning of slice");
		}
		if (r.prevRune < 0) {
			return errors.New("bytes.Reader.UnreadRune: previous operation was not ReadRune");
		}
		r.i = (new $Int64(0, r.prevRune));
		r.prevRune = -1;
		return $ifaceNil;
	};
	Reader.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Reader.ptr.prototype.Seek = function(offset, whence) {
		var _1, abs, offset, r, whence, x, x$1;
		r = this;
		r.prevRune = -1;
		abs = new $Int64(0, 0);
		_1 = whence;
		if (_1 === (0)) {
			abs = offset;
		} else if (_1 === (1)) {
			abs = (x = r.i, new $Int64(x.$high + offset.$high, x.$low + offset.$low));
		} else if (_1 === (2)) {
			abs = (x$1 = (new $Int64(0, r.s.$length)), new $Int64(x$1.$high + offset.$high, x$1.$low + offset.$low));
		} else {
			return [new $Int64(0, 0), errors.New("bytes.Reader.Seek: invalid whence")];
		}
		if ((abs.$high < 0 || (abs.$high === 0 && abs.$low < 0))) {
			return [new $Int64(0, 0), errors.New("bytes.Reader.Seek: negative position")];
		}
		r.i = abs;
		return [abs, $ifaceNil];
	};
	Reader.prototype.Seek = function(offset, whence) { return this.$val.Seek(offset, whence); };
	Reader.ptr.prototype.WriteTo = function(w) {
		var _r, _tmp, _tmp$1, _tuple, b, err, m, n, r, w, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; m = $f.m; n = $f.n; r = $f.r; w = $f.w; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.$length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			_tmp = new $Int64(0, 0);
			_tmp$1 = $ifaceNil;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		b = $subslice(r.s, $flatten64(r.i));
		_r = w.Write(b); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		m = _tuple[0];
		err = _tuple[1];
		if (m > b.$length) {
			$panic(new $String("bytes.Reader.WriteTo: invalid Write count"));
		}
		r.i = (x$2 = r.i, x$3 = (new $Int64(0, m)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		n = (new $Int64(0, m));
		if (!((m === b.$length)) && $interfaceIsEqual(err, $ifaceNil)) {
			err = io.ErrShortWrite;
		}
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.WriteTo }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.m = m; $f.n = n; $f.r = r; $f.w = w; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Reader.ptr.prototype.Reset = function(b) {
		var b, r;
		r = this;
		Reader.copy(r, new Reader.ptr(b, new $Int64(0, 0), -1));
	};
	Reader.prototype.Reset = function(b) { return this.$val.Reset(b); };
	NewReader = function(b) {
		var b;
		return new Reader.ptr(b, new $Int64(0, 0), -1);
	};
	$pkg.NewReader = NewReader;
	ptrType.methods = [{prop: "Bytes", name: "Bytes", pkg: "", typ: $funcType([], [sliceType], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "empty", name: "empty", pkg: "bytes", typ: $funcType([], [$Bool], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Truncate", name: "Truncate", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [], false)}, {prop: "tryGrowByReslice", name: "tryGrowByReslice", pkg: "bytes", typ: $funcType([$Int], [$Int, $Bool], false)}, {prop: "grow", name: "grow", pkg: "bytes", typ: $funcType([$Int], [$Int], false)}, {prop: "Grow", name: "Grow", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}, {prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([io.Reader], [$Int64, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [$error], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [$Int, $error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "Next", name: "Next", pkg: "", typ: $funcType([$Int], [sliceType], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadBytes", name: "ReadBytes", pkg: "", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "readSlice", name: "readSlice", pkg: "bytes", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "ReadString", name: "ReadString", pkg: "", typ: $funcType([$Uint8], [$String, $error], false)}];
	ptrType$2.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "ReadAt", name: "ReadAt", pkg: "", typ: $funcType([sliceType, $Int64], [$Int, $error], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Seek", name: "Seek", pkg: "", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([sliceType], [], false)}];
	Buffer.init("bytes", [{prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "off", name: "off", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lastRead", name: "lastRead", embedded: false, exported: false, typ: readOp, tag: ""}]);
	Reader.init("bytes", [{prop: "s", name: "s", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "i", name: "i", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "prevRune", name: "prevRune", embedded: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrTooLarge = errors.New("bytes.Buffer: too large");
		errNegativeRead = errors.New("bytes.Buffer: reader returned negative count from Read");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["bufio"] = (function() {
	var $pkg = {}, $init, bytes, errors, io, utf8, Reader, sliceType, ptrType, sliceType$1, errNegativeRead, errNegativeWrite, NewReaderSize, NewReader;
	bytes = $packages["bytes"];
	errors = $packages["errors"];
	io = $packages["io"];
	utf8 = $packages["unicode/utf8"];
	Reader = $pkg.Reader = $newType(0, $kindStruct, "bufio.Reader", true, "bufio", true, function(buf_, rd_, r_, w_, err_, lastByte_, lastRuneSize_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = sliceType.nil;
			this.rd = $ifaceNil;
			this.r = 0;
			this.w = 0;
			this.err = $ifaceNil;
			this.lastByte = 0;
			this.lastRuneSize = 0;
			return;
		}
		this.buf = buf_;
		this.rd = rd_;
		this.r = r_;
		this.w = w_;
		this.err = err_;
		this.lastByte = lastByte_;
		this.lastRuneSize = lastRuneSize_;
	});
	sliceType = $sliceType($Uint8);
	ptrType = $ptrType(Reader);
	sliceType$1 = $sliceType(sliceType);
	NewReaderSize = function(rd, size) {
		var _tuple, b, ok, r, rd, size;
		_tuple = $assertType(rd, ptrType, true);
		b = _tuple[0];
		ok = _tuple[1];
		if (ok && b.buf.$length >= size) {
			return b;
		}
		if (size < 16) {
			size = 16;
		}
		r = new Reader.ptr(sliceType.nil, $ifaceNil, 0, 0, $ifaceNil, 0, 0);
		r.reset($makeSlice(sliceType, size), rd);
		return r;
	};
	$pkg.NewReaderSize = NewReaderSize;
	NewReader = function(rd) {
		var rd;
		return NewReaderSize(rd, 4096);
	};
	$pkg.NewReader = NewReader;
	Reader.ptr.prototype.Size = function() {
		var b;
		b = this;
		return b.buf.$length;
	};
	Reader.prototype.Size = function() { return this.$val.Size(); };
	Reader.ptr.prototype.Reset = function(r) {
		var b, r;
		b = this;
		b.reset(b.buf, r);
	};
	Reader.prototype.Reset = function(r) { return this.$val.Reset(r); };
	Reader.ptr.prototype.reset = function(buf, r) {
		var b, buf, r;
		b = this;
		Reader.copy(b, new Reader.ptr(buf, r, 0, 0, $ifaceNil, -1, -1));
	};
	Reader.prototype.reset = function(buf, r) { return this.$val.reset(buf, r); };
	Reader.ptr.prototype.fill = function() {
		var _r, _tuple, b, err, i, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; err = $f.err; i = $f.i; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		if (b.r > 0) {
			$copySlice(b.buf, $subslice(b.buf, b.r, b.w));
			b.w = b.w - (b.r) >> 0;
			b.r = 0;
		}
		if (b.w >= b.buf.$length) {
			$panic(new $String("bufio: tried to fill full buffer"));
		}
		i = 100;
		/* while (true) { */ case 1:
			/* if (!(i > 0)) { break; } */ if(!(i > 0)) { $s = 2; continue; }
			_r = b.rd.Read($subslice(b.buf, b.w)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			n = _tuple[0];
			err = _tuple[1];
			if (n < 0) {
				$panic(errNegativeRead);
			}
			b.w = b.w + (n) >> 0;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				b.err = err;
				$s = -1; return;
			}
			if (n > 0) {
				$s = -1; return;
			}
			i = i - (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		b.err = io.ErrNoProgress;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.fill }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.i = i; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.fill = function() { return this.$val.fill(); };
	Reader.ptr.prototype.readErr = function() {
		var b, err;
		b = this;
		err = b.err;
		b.err = $ifaceNil;
		return err;
	};
	Reader.prototype.readErr = function() { return this.$val.readErr(); };
	Reader.ptr.prototype.Peek = function(n) {
		var avail, b, err, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; avail = $f.avail; b = $f.b; err = $f.err; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		if (n < 0) {
			$s = -1; return [sliceType.nil, $pkg.ErrNegativeCount];
		}
		b.lastByte = -1;
		b.lastRuneSize = -1;
		/* while (true) { */ case 1:
			/* if (!((b.w - b.r >> 0) < n && (b.w - b.r >> 0) < b.buf.$length && $interfaceIsEqual(b.err, $ifaceNil))) { break; } */ if(!((b.w - b.r >> 0) < n && (b.w - b.r >> 0) < b.buf.$length && $interfaceIsEqual(b.err, $ifaceNil))) { $s = 2; continue; }
			$r = b.fill(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		if (n > b.buf.$length) {
			$s = -1; return [$subslice(b.buf, b.r, b.w), $pkg.ErrBufferFull];
		}
		err = $ifaceNil;
		avail = b.w - b.r >> 0;
		if (avail < n) {
			n = avail;
			err = b.readErr();
			if ($interfaceIsEqual(err, $ifaceNil)) {
				err = $pkg.ErrBufferFull;
			}
		}
		$s = -1; return [$subslice(b.buf, b.r, (b.r + n >> 0)), err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.Peek }; } $f.avail = avail; $f.b = b; $f.err = err; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.Peek = function(n) { return this.$val.Peek(n); };
	Reader.ptr.prototype.Discard = function(n) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, discarded, err, n, remain, skip, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; b = $f.b; discarded = $f.discarded; err = $f.err; n = $f.n; remain = $f.remain; skip = $f.skip; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		discarded = 0;
		err = $ifaceNil;
		b = this;
		if (n < 0) {
			_tmp = 0;
			_tmp$1 = $pkg.ErrNegativeCount;
			discarded = _tmp;
			err = _tmp$1;
			$s = -1; return [discarded, err];
		}
		if (n === 0) {
			$s = -1; return [discarded, err];
		}
		remain = n;
		/* while (true) { */ case 1:
			skip = b.Buffered();
			/* */ if (skip === 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (skip === 0) { */ case 3:
				$r = b.fill(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				skip = b.Buffered();
			/* } */ case 4:
			if (skip > remain) {
				skip = remain;
			}
			b.r = b.r + (skip) >> 0;
			remain = remain - (skip) >> 0;
			if (remain === 0) {
				_tmp$2 = n;
				_tmp$3 = $ifaceNil;
				discarded = _tmp$2;
				err = _tmp$3;
				$s = -1; return [discarded, err];
			}
			if (!($interfaceIsEqual(b.err, $ifaceNil))) {
				_tmp$4 = n - remain >> 0;
				_tmp$5 = b.readErr();
				discarded = _tmp$4;
				err = _tmp$5;
				$s = -1; return [discarded, err];
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [discarded, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.Discard }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f.b = b; $f.discarded = discarded; $f.err = err; $f.n = n; $f.remain = remain; $f.skip = skip; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.Discard = function(n) { return this.$val.Discard(n); };
	Reader.ptr.prototype.Read = function(p) {
		var _r, _r$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, b, err, n, p, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; b = $f.b; err = $f.err; n = $f.n; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		b = this;
		n = p.$length;
		if (n === 0) {
			_tmp = 0;
			_tmp$1 = b.readErr();
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		/* */ if (b.r === b.w) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (b.r === b.w) { */ case 1:
			if (!($interfaceIsEqual(b.err, $ifaceNil))) {
				_tmp$2 = 0;
				_tmp$3 = b.readErr();
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
			/* */ if (p.$length >= b.buf.$length) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (p.$length >= b.buf.$length) { */ case 3:
				_r = b.rd.Read(p); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				n = _tuple[0];
				b.err = _tuple[1];
				if (n < 0) {
					$panic(errNegativeRead);
				}
				if (n > 0) {
					b.lastByte = (((x = n - 1 >> 0, ((x < 0 || x >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x])) >> 0));
					b.lastRuneSize = -1;
				}
				_tmp$4 = n;
				_tmp$5 = b.readErr();
				n = _tmp$4;
				err = _tmp$5;
				$s = -1; return [n, err];
			/* } */ case 4:
			b.r = 0;
			b.w = 0;
			_r$1 = b.rd.Read(b.buf); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			n = _tuple$1[0];
			b.err = _tuple$1[1];
			if (n < 0) {
				$panic(errNegativeRead);
			}
			if (n === 0) {
				_tmp$6 = 0;
				_tmp$7 = b.readErr();
				n = _tmp$6;
				err = _tmp$7;
				$s = -1; return [n, err];
			}
			b.w = b.w + (n) >> 0;
		/* } */ case 2:
		n = $copySlice(p, $subslice(b.buf, b.r, b.w));
		b.r = b.r + (n) >> 0;
		b.lastByte = (((x$1 = b.buf, x$2 = b.r - 1 >> 0, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2])) >> 0));
		b.lastRuneSize = -1;
		_tmp$8 = n;
		_tmp$9 = $ifaceNil;
		n = _tmp$8;
		err = _tmp$9;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.Read }; } $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.b = b; $f.err = err; $f.n = n; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.Read = function(p) { return this.$val.Read(p); };
	Reader.ptr.prototype.ReadByte = function() {
		var b, c, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; c = $f.c; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		b.lastRuneSize = -1;
		/* while (true) { */ case 1:
			/* if (!(b.r === b.w)) { break; } */ if(!(b.r === b.w)) { $s = 2; continue; }
			if (!($interfaceIsEqual(b.err, $ifaceNil))) {
				$s = -1; return [0, b.readErr()];
			}
			$r = b.fill(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		c = (x = b.buf, x$1 = b.r, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		b.r = b.r + (1) >> 0;
		b.lastByte = ((c >> 0));
		$s = -1; return [c, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadByte }; } $f.b = b; $f.c = c; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Reader.ptr.prototype.UnreadByte = function() {
		var b, x, x$1;
		b = this;
		if (b.lastByte < 0 || (b.r === 0) && b.w > 0) {
			return $pkg.ErrInvalidUnreadByte;
		}
		if (b.r > 0) {
			b.r = b.r - (1) >> 0;
		} else {
			b.w = 1;
		}
		(x = b.buf, x$1 = b.r, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1] = ((b.lastByte << 24 >>> 24))));
		b.lastByte = -1;
		b.lastRuneSize = -1;
		return $ifaceNil;
	};
	Reader.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Reader.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, b, err, r, size, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tuple = $f._tuple; b = $f.b; err = $f.err; r = $f.r; size = $f.size; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = 0;
		size = 0;
		err = $ifaceNil;
		b = this;
		/* while (true) { */ case 1:
			/* if (!((b.r + 4 >> 0) > b.w && !utf8.FullRune($subslice(b.buf, b.r, b.w)) && $interfaceIsEqual(b.err, $ifaceNil) && (b.w - b.r >> 0) < b.buf.$length)) { break; } */ if(!((b.r + 4 >> 0) > b.w && !utf8.FullRune($subslice(b.buf, b.r, b.w)) && $interfaceIsEqual(b.err, $ifaceNil) && (b.w - b.r >> 0) < b.buf.$length)) { $s = 2; continue; }
			$r = b.fill(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		b.lastRuneSize = -1;
		if (b.r === b.w) {
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = b.readErr();
			r = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			$s = -1; return [r, size, err];
		}
		_tmp$3 = (((x = b.buf, x$1 = b.r, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])) >> 0));
		_tmp$4 = 1;
		r = _tmp$3;
		size = _tmp$4;
		if (r >= 128) {
			_tuple = utf8.DecodeRune($subslice(b.buf, b.r, b.w));
			r = _tuple[0];
			size = _tuple[1];
		}
		b.r = b.r + (size) >> 0;
		b.lastByte = (((x$2 = b.buf, x$3 = b.r - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])) >> 0));
		b.lastRuneSize = size;
		_tmp$5 = r;
		_tmp$6 = size;
		_tmp$7 = $ifaceNil;
		r = _tmp$5;
		size = _tmp$6;
		err = _tmp$7;
		$s = -1; return [r, size, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadRune }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.r = r; $f.size = size; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Reader.ptr.prototype.UnreadRune = function() {
		var b;
		b = this;
		if (b.lastRuneSize < 0 || b.r < b.lastRuneSize) {
			return $pkg.ErrInvalidUnreadRune;
		}
		b.r = b.r - (b.lastRuneSize) >> 0;
		b.lastByte = -1;
		b.lastRuneSize = -1;
		return $ifaceNil;
	};
	Reader.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Reader.ptr.prototype.Buffered = function() {
		var b;
		b = this;
		return b.w - b.r >> 0;
	};
	Reader.prototype.Buffered = function() { return this.$val.Buffered(); };
	Reader.ptr.prototype.ReadSlice = function(delim) {
		var b, delim, err, i, i$1, line, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; delim = $f.delim; err = $f.err; i = $f.i; i$1 = $f.i$1; line = $f.line; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		line = sliceType.nil;
		err = $ifaceNil;
		b = this;
		s = 0;
		/* while (true) { */ case 1:
			i = bytes.IndexByte($subslice(b.buf, (b.r + s >> 0), b.w), delim);
			if (i >= 0) {
				i = i + (s) >> 0;
				line = $subslice(b.buf, b.r, ((b.r + i >> 0) + 1 >> 0));
				b.r = b.r + ((i + 1 >> 0)) >> 0;
				/* break; */ $s = 2; continue;
			}
			if (!($interfaceIsEqual(b.err, $ifaceNil))) {
				line = $subslice(b.buf, b.r, b.w);
				b.r = b.w;
				err = b.readErr();
				/* break; */ $s = 2; continue;
			}
			if (b.Buffered() >= b.buf.$length) {
				b.r = b.w;
				line = b.buf;
				err = $pkg.ErrBufferFull;
				/* break; */ $s = 2; continue;
			}
			s = b.w - b.r >> 0;
			$r = b.fill(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		i$1 = line.$length - 1 >> 0;
		if (i$1 >= 0) {
			b.lastByte = ((((i$1 < 0 || i$1 >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + i$1]) >> 0));
			b.lastRuneSize = -1;
		}
		$s = -1; return [line, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadSlice }; } $f.b = b; $f.delim = delim; $f.err = err; $f.i = i; $f.i$1 = i$1; $f.line = line; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadSlice = function(delim) { return this.$val.ReadSlice(delim); };
	Reader.ptr.prototype.ReadLine = function() {
		var _r, _tmp, _tmp$1, _tmp$2, _tuple, b, drop, err, isPrefix, line, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tuple = $f._tuple; b = $f.b; drop = $f.drop; err = $f.err; isPrefix = $f.isPrefix; line = $f.line; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		line = sliceType.nil;
		isPrefix = false;
		err = $ifaceNil;
		b = this;
		_r = b.ReadSlice(10); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		line = _tuple[0];
		err = _tuple[1];
		if ($interfaceIsEqual(err, $pkg.ErrBufferFull)) {
			if (line.$length > 0 && ((x = line.$length - 1 >> 0, ((x < 0 || x >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + x])) === 13)) {
				if (b.r === 0) {
					$panic(new $String("bufio: tried to rewind past start of buffer"));
				}
				b.r = b.r - (1) >> 0;
				line = $subslice(line, 0, (line.$length - 1 >> 0));
			}
			_tmp = line;
			_tmp$1 = true;
			_tmp$2 = $ifaceNil;
			line = _tmp;
			isPrefix = _tmp$1;
			err = _tmp$2;
			$s = -1; return [line, isPrefix, err];
		}
		if (line.$length === 0) {
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				line = sliceType.nil;
			}
			$s = -1; return [line, isPrefix, err];
		}
		err = $ifaceNil;
		if ((x$1 = line.$length - 1 >> 0, ((x$1 < 0 || x$1 >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + x$1])) === 10) {
			drop = 1;
			if (line.$length > 1 && ((x$2 = line.$length - 2 >> 0, ((x$2 < 0 || x$2 >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + x$2])) === 13)) {
				drop = 2;
			}
			line = $subslice(line, 0, (line.$length - drop >> 0));
		}
		$s = -1; return [line, isPrefix, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadLine }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tuple = _tuple; $f.b = b; $f.drop = drop; $f.err = err; $f.isPrefix = isPrefix; $f.line = line; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadLine = function() { return this.$val.ReadLine(); };
	Reader.ptr.prototype.ReadBytes = function(delim) {
		var _i, _i$1, _r, _ref, _ref$1, _tuple, b, buf, buf$1, delim, e, err, frag, full, i, i$1, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; _tuple = $f._tuple; b = $f.b; buf = $f.buf; buf$1 = $f.buf$1; delim = $f.delim; e = $f.e; err = $f.err; frag = $f.frag; full = $f.full; i = $f.i; i$1 = $f.i$1; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		frag = sliceType.nil;
		full = sliceType$1.nil;
		err = $ifaceNil;
		/* while (true) { */ case 1:
			e = $ifaceNil;
			_r = b.ReadSlice(delim); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			frag = _tuple[0];
			e = _tuple[1];
			if ($interfaceIsEqual(e, $ifaceNil)) {
				/* break; */ $s = 2; continue;
			}
			if (!($interfaceIsEqual(e, $pkg.ErrBufferFull))) {
				err = e;
				/* break; */ $s = 2; continue;
			}
			buf = $makeSlice(sliceType, frag.$length);
			$copySlice(buf, frag);
			full = $append(full, buf);
		/* } */ $s = 1; continue; case 2:
		n = 0;
		_ref = full;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			n = n + (((i < 0 || i >= full.$length) ? ($throwRuntimeError("index out of range"), undefined) : full.$array[full.$offset + i]).$length) >> 0;
			_i++;
		}
		n = n + (frag.$length) >> 0;
		buf$1 = $makeSlice(sliceType, n);
		n = 0;
		_ref$1 = full;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			n = n + ($copySlice($subslice(buf$1, n), ((i$1 < 0 || i$1 >= full.$length) ? ($throwRuntimeError("index out of range"), undefined) : full.$array[full.$offset + i$1]))) >> 0;
			_i$1++;
		}
		$copySlice($subslice(buf$1, n), frag);
		$s = -1; return [buf$1, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadBytes }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tuple = _tuple; $f.b = b; $f.buf = buf; $f.buf$1 = buf$1; $f.delim = delim; $f.e = e; $f.err = err; $f.frag = frag; $f.full = full; $f.i = i; $f.i$1 = i$1; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadBytes = function(delim) { return this.$val.ReadBytes(delim); };
	Reader.ptr.prototype.ReadString = function(delim) {
		var _r, _tuple, b, bytes$1, delim, err, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; bytes$1 = $f.bytes$1; delim = $f.delim; err = $f.err; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		_r = b.ReadBytes(delim); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		bytes$1 = _tuple[0];
		err = _tuple[1];
		$s = -1; return [($bytesToString(bytes$1)), err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.ReadString }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.bytes$1 = bytes$1; $f.delim = delim; $f.err = err; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.ReadString = function(delim) { return this.$val.ReadString(delim); };
	Reader.ptr.prototype.WriteTo = function(w) {
		var _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, b, err, err$1, err$2, err$3, m, m$1, m$2, n, ok, ok$1, r, w, w$1, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; b = $f.b; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; m = $f.m; m$1 = $f.m$1; m$2 = $f.m$2; n = $f.n; ok = $f.ok; ok$1 = $f.ok$1; r = $f.r; w = $f.w; w$1 = $f.w$1; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		_r = b.writeBuf(w); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [n, err];
		}
		_tuple$1 = $assertType(b.rd, io.WriterTo, true);
		r = _tuple$1[0];
		ok = _tuple$1[1];
		/* */ if (ok) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (ok) { */ case 2:
			_r$1 = r.WriteTo(w); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$2 = _r$1;
			m = _tuple$2[0];
			err$1 = _tuple$2[1];
			n = (x = m, new $Int64(n.$high + x.$high, n.$low + x.$low));
			_tmp = n;
			_tmp$1 = err$1;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		/* } */ case 3:
		_tuple$3 = $assertType(w, io.ReaderFrom, true);
		w$1 = _tuple$3[0];
		ok$1 = _tuple$3[1];
		/* */ if (ok$1) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (ok$1) { */ case 5:
			_r$2 = w$1.ReadFrom(b.rd); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple$4 = _r$2;
			m$1 = _tuple$4[0];
			err$2 = _tuple$4[1];
			n = (x$1 = m$1, new $Int64(n.$high + x$1.$high, n.$low + x$1.$low));
			_tmp$2 = n;
			_tmp$3 = err$2;
			n = _tmp$2;
			err = _tmp$3;
			$s = -1; return [n, err];
		/* } */ case 6:
		/* */ if ((b.w - b.r >> 0) < b.buf.$length) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if ((b.w - b.r >> 0) < b.buf.$length) { */ case 8:
			$r = b.fill(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 9:
		/* while (true) { */ case 11:
			/* if (!(b.r < b.w)) { break; } */ if(!(b.r < b.w)) { $s = 12; continue; }
			_r$3 = b.writeBuf(w); /* */ $s = 13; case 13: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			_tuple$5 = _r$3;
			m$2 = _tuple$5[0];
			err$3 = _tuple$5[1];
			n = (x$2 = m$2, new $Int64(n.$high + x$2.$high, n.$low + x$2.$low));
			if (!($interfaceIsEqual(err$3, $ifaceNil))) {
				_tmp$4 = n;
				_tmp$5 = err$3;
				n = _tmp$4;
				err = _tmp$5;
				$s = -1; return [n, err];
			}
			$r = b.fill(); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 11; continue; case 12:
		if ($interfaceIsEqual(b.err, io.EOF)) {
			b.err = $ifaceNil;
		}
		_tmp$6 = n;
		_tmp$7 = b.readErr();
		n = _tmp$6;
		err = _tmp$7;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.WriteTo }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.b = b; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.m = m; $f.m$1 = m$1; $f.m$2 = m$2; $f.n = n; $f.ok = ok; $f.ok$1 = ok$1; $f.r = r; $f.w = w; $f.w$1 = w$1; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Reader.ptr.prototype.writeBuf = function(w) {
		var _r, _tuple, b, err, n, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; err = $f.err; n = $f.n; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		_r = w.Write($subslice(b.buf, b.r, b.w)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		if (n < 0) {
			$panic(errNegativeWrite);
		}
		b.r = b.r + (n) >> 0;
		$s = -1; return [(new $Int64(0, n)), err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.writeBuf }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.n = n; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.writeBuf = function(w) { return this.$val.writeBuf(w); };
	ptrType.methods = [{prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([io.Reader], [], false)}, {prop: "reset", name: "reset", pkg: "bufio", typ: $funcType([sliceType, io.Reader], [], false)}, {prop: "fill", name: "fill", pkg: "bufio", typ: $funcType([], [], false)}, {prop: "readErr", name: "readErr", pkg: "bufio", typ: $funcType([], [$error], false)}, {prop: "Peek", name: "Peek", pkg: "", typ: $funcType([$Int], [sliceType, $error], false)}, {prop: "Discard", name: "Discard", pkg: "", typ: $funcType([$Int], [$Int, $error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Buffered", name: "Buffered", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "ReadSlice", name: "ReadSlice", pkg: "", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "ReadLine", name: "ReadLine", pkg: "", typ: $funcType([], [sliceType, $Bool, $error], false)}, {prop: "ReadBytes", name: "ReadBytes", pkg: "", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "ReadString", name: "ReadString", pkg: "", typ: $funcType([$Uint8], [$String, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "writeBuf", name: "writeBuf", pkg: "bufio", typ: $funcType([io.Writer], [$Int64, $error], false)}];
	Reader.init("bufio", [{prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "rd", name: "rd", embedded: false, exported: false, typ: io.Reader, tag: ""}, {prop: "r", name: "r", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "w", name: "w", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "err", name: "err", embedded: false, exported: false, typ: $error, tag: ""}, {prop: "lastByte", name: "lastByte", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lastRuneSize", name: "lastRuneSize", embedded: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte");
		$pkg.ErrInvalidUnreadRune = errors.New("bufio: invalid use of UnreadRune");
		$pkg.ErrBufferFull = errors.New("bufio: buffer full");
		$pkg.ErrNegativeCount = errors.New("bufio: negative count");
		errNegativeRead = errors.New("bufio: reader returned negative count from Read");
		errNegativeWrite = errors.New("bufio: writer returned negative count from Write");
		$pkg.ErrTooLong = errors.New("bufio.Scanner: token too long");
		$pkg.ErrNegativeAdvance = errors.New("bufio.Scanner: SplitFunc returns negative advance count");
		$pkg.ErrAdvanceTooFar = errors.New("bufio.Scanner: SplitFunc returns advance count beyond input");
		$pkg.ErrFinalToken = errors.New("final token");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math/bits"] = (function() {
	var $pkg = {}, $init, deBruijn32tab, deBruijn64tab, rev8tab, len8tab, LeadingZeros64, TrailingZeros, TrailingZeros32, TrailingZeros64, Reverse8, Reverse16, Len64;
	LeadingZeros64 = function(x) {
		var x;
		return 64 - Len64(x) >> 0;
	};
	$pkg.LeadingZeros64 = LeadingZeros64;
	TrailingZeros = function(x) {
		var x;
		if (true) {
			return TrailingZeros32(((x >>> 0)));
		}
		return TrailingZeros64((new $Uint64(0, x)));
	};
	$pkg.TrailingZeros = TrailingZeros;
	TrailingZeros32 = function(x) {
		var x, x$1;
		if (x === 0) {
			return 32;
		}
		return (((x$1 = ($imul((((x & (-x >>> 0)) >>> 0)), 125613361) >>> 0) >>> 27 >>> 0, ((x$1 < 0 || x$1 >= deBruijn32tab.length) ? ($throwRuntimeError("index out of range"), undefined) : deBruijn32tab[x$1])) >> 0));
	};
	$pkg.TrailingZeros32 = TrailingZeros32;
	TrailingZeros64 = function(x) {
		var x, x$1, x$2;
		if ((x.$high === 0 && x.$low === 0)) {
			return 64;
		}
		return (((x$1 = $shiftRightUint64($mul64(((x$2 = new $Uint64(-x.$high, -x.$low), new $Uint64(x.$high & x$2.$high, (x.$low & x$2.$low) >>> 0))), new $Uint64(66559345, 3033172745)), 58), (($flatten64(x$1) < 0 || $flatten64(x$1) >= deBruijn64tab.length) ? ($throwRuntimeError("index out of range"), undefined) : deBruijn64tab[$flatten64(x$1)])) >> 0));
	};
	$pkg.TrailingZeros64 = TrailingZeros64;
	Reverse8 = function(x) {
		var x;
		return ((x < 0 || x >= rev8tab.length) ? ($throwRuntimeError("index out of range"), undefined) : rev8tab[x]);
	};
	$pkg.Reverse8 = Reverse8;
	Reverse16 = function(x) {
		var x, x$1, x$2;
		return ((((x$1 = x >>> 8 << 16 >>> 16, ((x$1 < 0 || x$1 >= rev8tab.length) ? ($throwRuntimeError("index out of range"), undefined) : rev8tab[x$1])) << 16 >>> 16)) | ((((x$2 = (x & 255) >>> 0, ((x$2 < 0 || x$2 >= rev8tab.length) ? ($throwRuntimeError("index out of range"), undefined) : rev8tab[x$2])) << 16 >>> 16)) << 8 << 16 >>> 16)) >>> 0;
	};
	$pkg.Reverse16 = Reverse16;
	Len64 = function(x) {
		var n, x;
		n = 0;
		if ((x.$high > 1 || (x.$high === 1 && x.$low >= 0))) {
			x = $shiftRightUint64(x, (32));
			n = 32;
		}
		if ((x.$high > 0 || (x.$high === 0 && x.$low >= 65536))) {
			x = $shiftRightUint64(x, (16));
			n = n + (16) >> 0;
		}
		if ((x.$high > 0 || (x.$high === 0 && x.$low >= 256))) {
			x = $shiftRightUint64(x, (8));
			n = n + (8) >> 0;
		}
		n = n + (((($flatten64(x) < 0 || $flatten64(x) >= len8tab.length) ? ($throwRuntimeError("index out of range"), undefined) : len8tab[$flatten64(x)]) >> 0)) >> 0;
		return n;
	};
	$pkg.Len64 = Len64;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		deBruijn32tab = $toNativeArray($kindUint8, [0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9]);
		deBruijn64tab = $toNativeArray($kindUint8, [0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6]);
		rev8tab = $toNativeArray($kindUint8, [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255]);
		len8tab = $toNativeArray($kindUint8, [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math"] = (function() {
	var $pkg = {}, $init, js, bits, arrayType, arrayType$1, arrayType$2, structType, math, zero, nan, buf, Ceil, Cos, Exp, IsNaN, Log, Sin, Sincos, Tan, init, Float32bits, Float64bits, Float64frombits, Abs;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	bits = $packages["math/bits"];
	arrayType = $arrayType($Uint32, 2);
	arrayType$1 = $arrayType($Float32, 2);
	arrayType$2 = $arrayType($Float64, 1);
	structType = $structType("math", [{prop: "uint32array", name: "uint32array", embedded: false, exported: false, typ: arrayType, tag: ""}, {prop: "float32array", name: "float32array", embedded: false, exported: false, typ: arrayType$1, tag: ""}, {prop: "float64array", name: "float64array", embedded: false, exported: false, typ: arrayType$2, tag: ""}]);
	Ceil = function(x) {
		var x;
		return $parseFloat(math.ceil(x));
	};
	$pkg.Ceil = Ceil;
	Cos = function(x) {
		var x;
		return $parseFloat(math.cos(x));
	};
	$pkg.Cos = Cos;
	Exp = function(x) {
		var x;
		return $parseFloat(math.exp(x));
	};
	$pkg.Exp = Exp;
	IsNaN = function(f) {
		var f, is;
		is = false;
		is = !((f === f));
		return is;
	};
	$pkg.IsNaN = IsNaN;
	Log = function(x) {
		var x;
		if (!((x === x))) {
			return nan;
		}
		return $parseFloat(math.log(x));
	};
	$pkg.Log = Log;
	Sin = function(x) {
		var x;
		return $parseFloat(math.sin(x));
	};
	$pkg.Sin = Sin;
	Sincos = function(x) {
		var _tmp, _tmp$1, cos$1, sin$1, x;
		sin$1 = 0;
		cos$1 = 0;
		_tmp = Sin(x);
		_tmp$1 = Cos(x);
		sin$1 = _tmp;
		cos$1 = _tmp$1;
		return [sin$1, cos$1];
	};
	$pkg.Sincos = Sincos;
	Tan = function(x) {
		var x;
		return $parseFloat(math.tan(x));
	};
	$pkg.Tan = Tan;
	init = function() {
		var ab;
		ab = new ($global.ArrayBuffer)(8);
		buf.uint32array = new ($global.Uint32Array)(ab);
		buf.float32array = new ($global.Float32Array)(ab);
		buf.float64array = new ($global.Float64Array)(ab);
	};
	Float32bits = function(f) {
		var f;
		buf.float32array[0] = f;
		return buf.uint32array[0];
	};
	$pkg.Float32bits = Float32bits;
	Float64bits = function(f) {
		var f, x, x$1;
		buf.float64array[0] = f;
		return (x = $shiftLeft64((new $Uint64(0, buf.uint32array[1])), 32), x$1 = (new $Uint64(0, buf.uint32array[0])), new $Uint64(x.$high + x$1.$high, x.$low + x$1.$low));
	};
	$pkg.Float64bits = Float64bits;
	Float64frombits = function(b) {
		var b;
		buf.uint32array[0] = ((b.$low >>> 0));
		buf.uint32array[1] = (($shiftRightUint64(b, 32).$low >>> 0));
		return buf.float64array[0];
	};
	$pkg.Float64frombits = Float64frombits;
	Abs = function(x) {
		var x, x$1;
		return Float64frombits((x$1 = Float64bits(x), new $Uint64(x$1.$high & ~2147483648, (x$1.$low & ~0) >>> 0)));
	};
	$pkg.Abs = Abs;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bits.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		buf = new structType.ptr(arrayType.zero(), arrayType$1.zero(), arrayType$2.zero());
		math = $global.Math;
		zero = 0;
		nan = 0 / zero;
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["strconv"] = (function() {
	var $pkg = {}, $init, errors, bytealg, math, bits, utf8, decimal, leftCheat, extFloat, floatInfo, decimalSlice, sliceType$3, sliceType$4, sliceType$5, arrayType, sliceType$6, arrayType$1, arrayType$2, ptrType$1, arrayType$3, arrayType$4, ptrType$2, ptrType$3, ptrType$4, optimize, leftcheats, smallPowersOfTen, powersOfTen, uint64pow10, float32info, float32info$24ptr, float64info, float64info$24ptr, isPrint16, isNotPrint16, isPrint32, isNotPrint32, isGraphic, digitZero, trim, rightShift, prefixIsLessThan, leftShift, shouldRoundUp, frexp10Many, adjustLastDigitFixed, adjustLastDigit, AppendFloat, genericFtoa, bigFtoa, formatDigits, roundShortest, fmtE, fmtF, fmtB, min, max, FormatUint, FormatInt, Itoa, small, formatBits, isPowerOfTwo, quoteWith, appendQuotedWith, appendQuotedRuneWith, appendEscapedRune, Quote, AppendQuote, QuoteToASCII, AppendQuoteToASCII, AppendQuoteRune, AppendQuoteRuneToASCII, CanBackquote, unhex, UnquoteChar, Unquote, contains, bsearch16, bsearch32, IsPrint, isInGraphicList;
	errors = $packages["errors"];
	bytealg = $packages["internal/bytealg"];
	math = $packages["math"];
	bits = $packages["math/bits"];
	utf8 = $packages["unicode/utf8"];
	decimal = $pkg.decimal = $newType(0, $kindStruct, "strconv.decimal", true, "strconv", false, function(d_, nd_, dp_, neg_, trunc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.d = arrayType.zero();
			this.nd = 0;
			this.dp = 0;
			this.neg = false;
			this.trunc = false;
			return;
		}
		this.d = d_;
		this.nd = nd_;
		this.dp = dp_;
		this.neg = neg_;
		this.trunc = trunc_;
	});
	leftCheat = $pkg.leftCheat = $newType(0, $kindStruct, "strconv.leftCheat", true, "strconv", false, function(delta_, cutoff_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.delta = 0;
			this.cutoff = "";
			return;
		}
		this.delta = delta_;
		this.cutoff = cutoff_;
	});
	extFloat = $pkg.extFloat = $newType(0, $kindStruct, "strconv.extFloat", true, "strconv", false, function(mant_, exp_, neg_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.mant = new $Uint64(0, 0);
			this.exp = 0;
			this.neg = false;
			return;
		}
		this.mant = mant_;
		this.exp = exp_;
		this.neg = neg_;
	});
	floatInfo = $pkg.floatInfo = $newType(0, $kindStruct, "strconv.floatInfo", true, "strconv", false, function(mantbits_, expbits_, bias_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.mantbits = 0;
			this.expbits = 0;
			this.bias = 0;
			return;
		}
		this.mantbits = mantbits_;
		this.expbits = expbits_;
		this.bias = bias_;
	});
	decimalSlice = $pkg.decimalSlice = $newType(0, $kindStruct, "strconv.decimalSlice", true, "strconv", false, function(d_, nd_, dp_, neg_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.d = sliceType$6.nil;
			this.nd = 0;
			this.dp = 0;
			this.neg = false;
			return;
		}
		this.d = d_;
		this.nd = nd_;
		this.dp = dp_;
		this.neg = neg_;
	});
	sliceType$3 = $sliceType(leftCheat);
	sliceType$4 = $sliceType($Uint16);
	sliceType$5 = $sliceType($Uint32);
	arrayType = $arrayType($Uint8, 800);
	sliceType$6 = $sliceType($Uint8);
	arrayType$1 = $arrayType($Uint8, 24);
	arrayType$2 = $arrayType($Uint8, 32);
	ptrType$1 = $ptrType(floatInfo);
	arrayType$3 = $arrayType($Uint8, 65);
	arrayType$4 = $arrayType($Uint8, 4);
	ptrType$2 = $ptrType(decimal);
	ptrType$3 = $ptrType(decimalSlice);
	ptrType$4 = $ptrType(extFloat);
	decimal.ptr.prototype.String = function() {
		var a, buf, n, w;
		a = this;
		n = 10 + a.nd >> 0;
		if (a.dp > 0) {
			n = n + (a.dp) >> 0;
		}
		if (a.dp < 0) {
			n = n + (-a.dp) >> 0;
		}
		buf = $makeSlice(sliceType$6, n);
		w = 0;
		if ((a.nd === 0)) {
			return "0";
		} else if (a.dp <= 0) {
			((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = 48);
			w = w + (1) >> 0;
			((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = 46);
			w = w + (1) >> 0;
			w = w + (digitZero($subslice(buf, w, (w + -a.dp >> 0)))) >> 0;
			w = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), 0, a.nd))) >> 0;
		} else if (a.dp < a.nd) {
			w = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), 0, a.dp))) >> 0;
			((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = 46);
			w = w + (1) >> 0;
			w = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), a.dp, a.nd))) >> 0;
		} else {
			w = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), 0, a.nd))) >> 0;
			w = w + (digitZero($subslice(buf, w, ((w + a.dp >> 0) - a.nd >> 0)))) >> 0;
		}
		return ($bytesToString($subslice(buf, 0, w)));
	};
	decimal.prototype.String = function() { return this.$val.String(); };
	digitZero = function(dst) {
		var _i, _ref, dst, i;
		_ref = dst;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			((i < 0 || i >= dst.$length) ? ($throwRuntimeError("index out of range"), undefined) : dst.$array[dst.$offset + i] = 48);
			_i++;
		}
		return dst.$length;
	};
	trim = function(a) {
		var a, x, x$1;
		while (true) {
			if (!(a.nd > 0 && ((x = a.d, x$1 = a.nd - 1 >> 0, ((x$1 < 0 || x$1 >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[x$1])) === 48))) { break; }
			a.nd = a.nd - (1) >> 0;
		}
		if (a.nd === 0) {
			a.dp = 0;
		}
	};
	decimal.ptr.prototype.Assign = function(v) {
		var a, buf, n, v, v1, x, x$1, x$2;
		a = this;
		buf = arrayType$1.zero();
		n = 0;
		while (true) {
			if (!((v.$high > 0 || (v.$high === 0 && v.$low > 0)))) { break; }
			v1 = $div64(v, new $Uint64(0, 10), false);
			v = (x = $mul64(new $Uint64(0, 10), v1), new $Uint64(v.$high - x.$high, v.$low - x.$low));
			((n < 0 || n >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[n] = ((new $Uint64(v.$high + 0, v.$low + 48).$low << 24 >>> 24)));
			n = n + (1) >> 0;
			v = v1;
		}
		a.nd = 0;
		n = n - (1) >> 0;
		while (true) {
			if (!(n >= 0)) { break; }
			(x$1 = a.d, x$2 = a.nd, ((x$2 < 0 || x$2 >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[x$2] = ((n < 0 || n >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[n])));
			a.nd = a.nd + (1) >> 0;
			n = n - (1) >> 0;
		}
		a.dp = a.nd;
		trim(a);
	};
	decimal.prototype.Assign = function(v) { return this.$val.Assign(v); };
	rightShift = function(a, k) {
		var a, c, c$1, dig, dig$1, k, mask, n, r, w, x, x$1, x$2, x$3, y, y$1, y$2, y$3, y$4;
		r = 0;
		w = 0;
		n = 0;
		while (true) {
			if (!(((y = k, y < 32 ? (n >>> y) : 0) >>> 0) === 0)) { break; }
			if (r >= a.nd) {
				if (n === 0) {
					a.nd = 0;
					return;
				}
				while (true) {
					if (!(((y$1 = k, y$1 < 32 ? (n >>> y$1) : 0) >>> 0) === 0)) { break; }
					n = n * 10 >>> 0;
					r = r + (1) >> 0;
				}
				break;
			}
			c = (((x = a.d, ((r < 0 || r >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[r])) >>> 0));
			n = ((n * 10 >>> 0) + c >>> 0) - 48 >>> 0;
			r = r + (1) >> 0;
		}
		a.dp = a.dp - ((r - 1 >> 0)) >> 0;
		mask = (((y$2 = k, y$2 < 32 ? (1 << y$2) : 0) >>> 0)) - 1 >>> 0;
		while (true) {
			if (!(r < a.nd)) { break; }
			c$1 = (((x$1 = a.d, ((r < 0 || r >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[r])) >>> 0));
			dig = (y$3 = k, y$3 < 32 ? (n >>> y$3) : 0) >>> 0;
			n = (n & (mask)) >>> 0;
			(x$2 = a.d, ((w < 0 || w >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[w] = (((dig + 48 >>> 0) << 24 >>> 24))));
			w = w + (1) >> 0;
			n = ((n * 10 >>> 0) + c$1 >>> 0) - 48 >>> 0;
			r = r + (1) >> 0;
		}
		while (true) {
			if (!(n > 0)) { break; }
			dig$1 = (y$4 = k, y$4 < 32 ? (n >>> y$4) : 0) >>> 0;
			n = (n & (mask)) >>> 0;
			if (w < 800) {
				(x$3 = a.d, ((w < 0 || w >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[w] = (((dig$1 + 48 >>> 0) << 24 >>> 24))));
				w = w + (1) >> 0;
			} else if (dig$1 > 0) {
				a.trunc = true;
			}
			n = n * 10 >>> 0;
		}
		a.nd = w;
		trim(a);
	};
	prefixIsLessThan = function(b, s) {
		var b, i, s;
		i = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			if (i >= b.$length) {
				return true;
			}
			if (!((((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i]) === s.charCodeAt(i)))) {
				return ((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i]) < s.charCodeAt(i);
			}
			i = i + (1) >> 0;
		}
		return false;
	};
	leftShift = function(a, k) {
		var _q, _q$1, a, delta, k, n, quo, quo$1, r, rem, rem$1, w, x, x$1, x$2, y;
		delta = ((k < 0 || k >= leftcheats.$length) ? ($throwRuntimeError("index out of range"), undefined) : leftcheats.$array[leftcheats.$offset + k]).delta;
		if (prefixIsLessThan($subslice(new sliceType$6(a.d), 0, a.nd), ((k < 0 || k >= leftcheats.$length) ? ($throwRuntimeError("index out of range"), undefined) : leftcheats.$array[leftcheats.$offset + k]).cutoff)) {
			delta = delta - (1) >> 0;
		}
		r = a.nd;
		w = a.nd + delta >> 0;
		n = 0;
		r = r - (1) >> 0;
		while (true) {
			if (!(r >= 0)) { break; }
			n = n + (((y = k, y < 32 ? ((((((x = a.d, ((r < 0 || r >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[r])) >>> 0)) - 48 >>> 0)) << y) : 0) >>> 0)) >>> 0;
			quo = (_q = n / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
			rem = n - (10 * quo >>> 0) >>> 0;
			w = w - (1) >> 0;
			if (w < 800) {
				(x$1 = a.d, ((w < 0 || w >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[w] = (((rem + 48 >>> 0) << 24 >>> 24))));
			} else if (!((rem === 0))) {
				a.trunc = true;
			}
			n = quo;
			r = r - (1) >> 0;
		}
		while (true) {
			if (!(n > 0)) { break; }
			quo$1 = (_q$1 = n / 10, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
			rem$1 = n - (10 * quo$1 >>> 0) >>> 0;
			w = w - (1) >> 0;
			if (w < 800) {
				(x$2 = a.d, ((w < 0 || w >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[w] = (((rem$1 + 48 >>> 0) << 24 >>> 24))));
			} else if (!((rem$1 === 0))) {
				a.trunc = true;
			}
			n = quo$1;
		}
		a.nd = a.nd + (delta) >> 0;
		if (a.nd >= 800) {
			a.nd = 800;
		}
		a.dp = a.dp + (delta) >> 0;
		trim(a);
	};
	decimal.ptr.prototype.Shift = function(k) {
		var a, k;
		a = this;
		if ((a.nd === 0)) {
		} else if (k > 0) {
			while (true) {
				if (!(k > 28)) { break; }
				leftShift(a, 28);
				k = k - (28) >> 0;
			}
			leftShift(a, ((k >>> 0)));
		} else if (k < 0) {
			while (true) {
				if (!(k < -28)) { break; }
				rightShift(a, 28);
				k = k + (28) >> 0;
			}
			rightShift(a, ((-k >>> 0)));
		}
	};
	decimal.prototype.Shift = function(k) { return this.$val.Shift(k); };
	shouldRoundUp = function(a, nd) {
		var _r, a, nd, x, x$1, x$2, x$3;
		if (nd < 0 || nd >= a.nd) {
			return false;
		}
		if (((x = a.d, ((nd < 0 || nd >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[nd])) === 53) && ((nd + 1 >> 0) === a.nd)) {
			if (a.trunc) {
				return true;
			}
			return nd > 0 && !(((_r = (((x$1 = a.d, x$2 = nd - 1 >> 0, ((x$2 < 0 || x$2 >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[x$2])) - 48 << 24 >>> 24)) % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0));
		}
		return (x$3 = a.d, ((nd < 0 || nd >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[nd])) >= 53;
	};
	decimal.ptr.prototype.Round = function(nd) {
		var a, nd;
		a = this;
		if (nd < 0 || nd >= a.nd) {
			return;
		}
		if (shouldRoundUp(a, nd)) {
			a.RoundUp(nd);
		} else {
			a.RoundDown(nd);
		}
	};
	decimal.prototype.Round = function(nd) { return this.$val.Round(nd); };
	decimal.ptr.prototype.RoundDown = function(nd) {
		var a, nd;
		a = this;
		if (nd < 0 || nd >= a.nd) {
			return;
		}
		a.nd = nd;
		trim(a);
	};
	decimal.prototype.RoundDown = function(nd) { return this.$val.RoundDown(nd); };
	decimal.ptr.prototype.RoundUp = function(nd) {
		var a, c, i, nd, x, x$1, x$2;
		a = this;
		if (nd < 0 || nd >= a.nd) {
			return;
		}
		i = nd - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			c = (x = a.d, ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i]));
			if (c < 57) {
				(x$2 = a.d, ((i < 0 || i >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i] = ((x$1 = a.d, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i])) + (1) << 24 >>> 24)));
				a.nd = i + 1 >> 0;
				return;
			}
			i = i - (1) >> 0;
		}
		a.d[0] = 49;
		a.nd = 1;
		a.dp = a.dp + (1) >> 0;
	};
	decimal.prototype.RoundUp = function(nd) { return this.$val.RoundUp(nd); };
	decimal.ptr.prototype.RoundedInteger = function() {
		var a, i, n, x, x$1, x$2, x$3;
		a = this;
		if (a.dp > 20) {
			return new $Uint64(4294967295, 4294967295);
		}
		i = 0;
		n = new $Uint64(0, 0);
		i = 0;
		while (true) {
			if (!(i < a.dp && i < a.nd)) { break; }
			n = (x = $mul64(n, new $Uint64(0, 10)), x$1 = (new $Uint64(0, ((x$2 = a.d, ((i < 0 || i >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i])) - 48 << 24 >>> 24))), new $Uint64(x.$high + x$1.$high, x.$low + x$1.$low));
			i = i + (1) >> 0;
		}
		while (true) {
			if (!(i < a.dp)) { break; }
			n = $mul64(n, (new $Uint64(0, 10)));
			i = i + (1) >> 0;
		}
		if (shouldRoundUp(a, a.dp)) {
			n = (x$3 = new $Uint64(0, 1), new $Uint64(n.$high + x$3.$high, n.$low + x$3.$low));
		}
		return n;
	};
	decimal.prototype.RoundedInteger = function() { return this.$val.RoundedInteger(); };
	extFloat.ptr.prototype.AssignComputeBounds = function(mant, exp, neg, flt) {
		var _tmp, _tmp$1, exp, expBiased, f, flt, lower, mant, neg, upper, x, x$1, x$2, x$3, x$4;
		lower = new extFloat.ptr(new $Uint64(0, 0), 0, false);
		upper = new extFloat.ptr(new $Uint64(0, 0), 0, false);
		f = this;
		f.mant = mant;
		f.exp = exp - ((flt.mantbits >> 0)) >> 0;
		f.neg = neg;
		if (f.exp <= 0 && (x = $shiftLeft64(($shiftRightUint64(mant, ((-f.exp >>> 0)))), ((-f.exp >>> 0))), (mant.$high === x.$high && mant.$low === x.$low))) {
			f.mant = $shiftRightUint64(f.mant, (((-f.exp >>> 0))));
			f.exp = 0;
			_tmp = $clone(f, extFloat);
			_tmp$1 = $clone(f, extFloat);
			extFloat.copy(lower, _tmp);
			extFloat.copy(upper, _tmp$1);
			return [lower, upper];
		}
		expBiased = exp - flt.bias >> 0;
		extFloat.copy(upper, new extFloat.ptr((x$1 = $mul64(new $Uint64(0, 2), f.mant), new $Uint64(x$1.$high + 0, x$1.$low + 1)), f.exp - 1 >> 0, f.neg));
		if (!((x$2 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), (mant.$high === x$2.$high && mant.$low === x$2.$low))) || (expBiased === 1)) {
			extFloat.copy(lower, new extFloat.ptr((x$3 = $mul64(new $Uint64(0, 2), f.mant), new $Uint64(x$3.$high - 0, x$3.$low - 1)), f.exp - 1 >> 0, f.neg));
		} else {
			extFloat.copy(lower, new extFloat.ptr((x$4 = $mul64(new $Uint64(0, 4), f.mant), new $Uint64(x$4.$high - 0, x$4.$low - 1)), f.exp - 2 >> 0, f.neg));
		}
		return [lower, upper];
	};
	extFloat.prototype.AssignComputeBounds = function(mant, exp, neg, flt) { return this.$val.AssignComputeBounds(mant, exp, neg, flt); };
	extFloat.ptr.prototype.Normalize = function() {
		var f, shift, x;
		f = this;
		if ((x = f.mant, (x.$high === 0 && x.$low === 0))) {
			return 0;
		}
		shift = bits.LeadingZeros64(f.mant);
		f.mant = $shiftLeft64(f.mant, (((shift >>> 0))));
		f.exp = f.exp - (shift) >> 0;
		return ((shift >>> 0));
	};
	extFloat.prototype.Normalize = function() { return this.$val.Normalize(); };
	extFloat.ptr.prototype.Multiply = function(g) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, cross1, cross2, f, fhi, flo, g, ghi, glo, rem, x, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		f = this;
		_tmp = $shiftRightUint64(f.mant, 32);
		_tmp$1 = (new $Uint64(0, ((f.mant.$low >>> 0))));
		fhi = _tmp;
		flo = _tmp$1;
		_tmp$2 = $shiftRightUint64(g.mant, 32);
		_tmp$3 = (new $Uint64(0, ((g.mant.$low >>> 0))));
		ghi = _tmp$2;
		glo = _tmp$3;
		cross1 = $mul64(fhi, glo);
		cross2 = $mul64(flo, ghi);
		f.mant = (x = (x$1 = $mul64(fhi, ghi), x$2 = $shiftRightUint64(cross1, 32), new $Uint64(x$1.$high + x$2.$high, x$1.$low + x$2.$low)), x$3 = $shiftRightUint64(cross2, 32), new $Uint64(x.$high + x$3.$high, x.$low + x$3.$low));
		rem = (x$4 = (x$5 = (new $Uint64(0, ((cross1.$low >>> 0)))), x$6 = (new $Uint64(0, ((cross2.$low >>> 0)))), new $Uint64(x$5.$high + x$6.$high, x$5.$low + x$6.$low)), x$7 = $shiftRightUint64(($mul64(flo, glo)), 32), new $Uint64(x$4.$high + x$7.$high, x$4.$low + x$7.$low));
		rem = (x$8 = new $Uint64(0, 2147483648), new $Uint64(rem.$high + x$8.$high, rem.$low + x$8.$low));
		f.mant = (x$9 = f.mant, x$10 = ($shiftRightUint64(rem, 32)), new $Uint64(x$9.$high + x$10.$high, x$9.$low + x$10.$low));
		f.exp = (f.exp + g.exp >> 0) + 64 >> 0;
	};
	extFloat.prototype.Multiply = function(g) { return this.$val.Multiply(g); };
	extFloat.ptr.prototype.AssignDecimal = function(mantissa, exp10, neg, trunc, flt) {
		var _q, _r, adjExp, denormalExp, errors$1, exp10, extrabits, f, flt, halfway, i, mant_extra, mantissa, neg, ok, shift, trunc, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y;
		ok = false;
		f = this;
		errors$1 = 0;
		if (trunc) {
			errors$1 = errors$1 + (4) >> 0;
		}
		f.mant = mantissa;
		f.exp = 0;
		f.neg = neg;
		i = (_q = ((exp10 - -348 >> 0)) / 8, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		if (exp10 < -348 || i >= 87) {
			ok = false;
			return ok;
		}
		adjExp = (_r = ((exp10 - -348 >> 0)) % 8, _r === _r ? _r : $throwRuntimeError("integer divide by zero"));
		if (adjExp < 19 && (x = (x$1 = 19 - adjExp >> 0, ((x$1 < 0 || x$1 >= uint64pow10.length) ? ($throwRuntimeError("index out of range"), undefined) : uint64pow10[x$1])), (mantissa.$high < x.$high || (mantissa.$high === x.$high && mantissa.$low < x.$low)))) {
			f.mant = $mul64(f.mant, (((adjExp < 0 || adjExp >= uint64pow10.length) ? ($throwRuntimeError("index out of range"), undefined) : uint64pow10[adjExp])));
			f.Normalize();
		} else {
			f.Normalize();
			f.Multiply($clone(((adjExp < 0 || adjExp >= smallPowersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : smallPowersOfTen[adjExp]), extFloat));
			errors$1 = errors$1 + (4) >> 0;
		}
		f.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : powersOfTen[i]), extFloat));
		if (errors$1 > 0) {
			errors$1 = errors$1 + (1) >> 0;
		}
		errors$1 = errors$1 + (4) >> 0;
		shift = f.Normalize();
		errors$1 = (y = (shift), y < 32 ? (errors$1 << y) : 0) >> 0;
		denormalExp = flt.bias - 63 >> 0;
		extrabits = 0;
		if (f.exp <= denormalExp) {
			extrabits = ((63 - flt.mantbits >>> 0) + 1 >>> 0) + (((denormalExp - f.exp >> 0) >>> 0)) >>> 0;
		} else {
			extrabits = 63 - flt.mantbits >>> 0;
		}
		halfway = $shiftLeft64(new $Uint64(0, 1), ((extrabits - 1 >>> 0)));
		mant_extra = (x$2 = f.mant, x$3 = (x$4 = $shiftLeft64(new $Uint64(0, 1), extrabits), new $Uint64(x$4.$high - 0, x$4.$low - 1)), new $Uint64(x$2.$high & x$3.$high, (x$2.$low & x$3.$low) >>> 0));
		if ((x$5 = (x$6 = (new $Int64(halfway.$high, halfway.$low)), x$7 = (new $Int64(0, errors$1)), new $Int64(x$6.$high - x$7.$high, x$6.$low - x$7.$low)), x$8 = (new $Int64(mant_extra.$high, mant_extra.$low)), (x$5.$high < x$8.$high || (x$5.$high === x$8.$high && x$5.$low < x$8.$low))) && (x$9 = (new $Int64(mant_extra.$high, mant_extra.$low)), x$10 = (x$11 = (new $Int64(halfway.$high, halfway.$low)), x$12 = (new $Int64(0, errors$1)), new $Int64(x$11.$high + x$12.$high, x$11.$low + x$12.$low)), (x$9.$high < x$10.$high || (x$9.$high === x$10.$high && x$9.$low < x$10.$low)))) {
			ok = false;
			return ok;
		}
		ok = true;
		return ok;
	};
	extFloat.prototype.AssignDecimal = function(mantissa, exp10, neg, trunc, flt) { return this.$val.AssignDecimal(mantissa, exp10, neg, trunc, flt); };
	extFloat.ptr.prototype.frexp10 = function() {
		var _q, _q$1, _tmp, _tmp$1, approxExp10, exp, exp10, f, i, index;
		exp10 = 0;
		index = 0;
		f = this;
		approxExp10 = (_q = ($imul(((-46 - f.exp >> 0)), 28)) / 93, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		i = (_q$1 = ((approxExp10 - -348 >> 0)) / 8, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"));
		Loop:
		while (true) {
			exp = (f.exp + ((i < 0 || i >= powersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : powersOfTen[i]).exp >> 0) + 64 >> 0;
			if (exp < -60) {
				i = i + (1) >> 0;
			} else if (exp > -32) {
				i = i - (1) >> 0;
			} else {
				break Loop;
			}
		}
		f.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : powersOfTen[i]), extFloat));
		_tmp = -((-348 + ($imul(i, 8)) >> 0));
		_tmp$1 = i;
		exp10 = _tmp;
		index = _tmp$1;
		return [exp10, index];
	};
	extFloat.prototype.frexp10 = function() { return this.$val.frexp10(); };
	frexp10Many = function(a, b, c) {
		var _tuple, a, b, c, exp10, i;
		exp10 = 0;
		_tuple = c.frexp10();
		exp10 = _tuple[0];
		i = _tuple[1];
		a.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : powersOfTen[i]), extFloat));
		b.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? ($throwRuntimeError("index out of range"), undefined) : powersOfTen[i]), extFloat));
		return exp10;
	};
	extFloat.ptr.prototype.FixedDecimal = function(d, n) {
		var $CE$B5, _q, _q$1, _tmp, _tmp$1, _tuple, buf, d, digit, exp10, f, fraction, i, i$1, i$2, integer, integerDigits, n, nd, needed, ok, pos, pow, pow10, rest, shift, v, v1, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		f = this;
		if ((x = f.mant, (x.$high === 0 && x.$low === 0))) {
			d.nd = 0;
			d.dp = 0;
			d.neg = f.neg;
			return true;
		}
		if (n === 0) {
			$panic(new $String("strconv: internal error: extFloat.FixedDecimal called with n == 0"));
		}
		f.Normalize();
		_tuple = f.frexp10();
		exp10 = _tuple[0];
		shift = ((-f.exp >>> 0));
		integer = (($shiftRightUint64(f.mant, shift).$low >>> 0));
		fraction = (x$1 = f.mant, x$2 = $shiftLeft64((new $Uint64(0, integer)), shift), new $Uint64(x$1.$high - x$2.$high, x$1.$low - x$2.$low));
		$CE$B5 = new $Uint64(0, 1);
		needed = n;
		integerDigits = 0;
		pow10 = new $Uint64(0, 1);
		_tmp = 0;
		_tmp$1 = new $Uint64(0, 1);
		i = _tmp;
		pow = _tmp$1;
		while (true) {
			if (!(i < 20)) { break; }
			if ((x$3 = (new $Uint64(0, integer)), (pow.$high > x$3.$high || (pow.$high === x$3.$high && pow.$low > x$3.$low)))) {
				integerDigits = i;
				break;
			}
			pow = $mul64(pow, (new $Uint64(0, 10)));
			i = i + (1) >> 0;
		}
		rest = integer;
		if (integerDigits > needed) {
			pow10 = (x$4 = integerDigits - needed >> 0, ((x$4 < 0 || x$4 >= uint64pow10.length) ? ($throwRuntimeError("index out of range"), undefined) : uint64pow10[x$4]));
			integer = (_q = integer / (((pow10.$low >>> 0))), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
			rest = rest - (($imul(integer, ((pow10.$low >>> 0))) >>> 0)) >>> 0;
		} else {
			rest = 0;
		}
		buf = arrayType$2.zero();
		pos = 32;
		v = integer;
		while (true) {
			if (!(v > 0)) { break; }
			v1 = (_q$1 = v / 10, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
			v = v - (($imul(10, v1) >>> 0)) >>> 0;
			pos = pos - (1) >> 0;
			((pos < 0 || pos >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[pos] = (((v + 48 >>> 0) << 24 >>> 24)));
			v = v1;
		}
		i$1 = pos;
		while (true) {
			if (!(i$1 < 32)) { break; }
			(x$5 = d.d, x$6 = i$1 - pos >> 0, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6] = ((i$1 < 0 || i$1 >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[i$1])));
			i$1 = i$1 + (1) >> 0;
		}
		nd = 32 - pos >> 0;
		d.nd = nd;
		d.dp = integerDigits + exp10 >> 0;
		needed = needed - (nd) >> 0;
		if (needed > 0) {
			if (!((rest === 0)) || !((pow10.$high === 0 && pow10.$low === 1))) {
				$panic(new $String("strconv: internal error, rest != 0 but needed > 0"));
			}
			while (true) {
				if (!(needed > 0)) { break; }
				fraction = $mul64(fraction, (new $Uint64(0, 10)));
				$CE$B5 = $mul64($CE$B5, (new $Uint64(0, 10)));
				if ((x$7 = $mul64(new $Uint64(0, 2), $CE$B5), x$8 = $shiftLeft64(new $Uint64(0, 1), shift), (x$7.$high > x$8.$high || (x$7.$high === x$8.$high && x$7.$low > x$8.$low)))) {
					return false;
				}
				digit = $shiftRightUint64(fraction, shift);
				(x$9 = d.d, ((nd < 0 || nd >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + nd] = ((new $Uint64(digit.$high + 0, digit.$low + 48).$low << 24 >>> 24))));
				fraction = (x$10 = $shiftLeft64(digit, shift), new $Uint64(fraction.$high - x$10.$high, fraction.$low - x$10.$low));
				nd = nd + (1) >> 0;
				needed = needed - (1) >> 0;
			}
			d.nd = nd;
		}
		ok = adjustLastDigitFixed(d, (x$11 = $shiftLeft64((new $Uint64(0, rest)), shift), new $Uint64(x$11.$high | fraction.$high, (x$11.$low | fraction.$low) >>> 0)), pow10, shift, $CE$B5);
		if (!ok) {
			return false;
		}
		i$2 = d.nd - 1 >> 0;
		while (true) {
			if (!(i$2 >= 0)) { break; }
			if (!(((x$12 = d.d, ((i$2 < 0 || i$2 >= x$12.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + i$2])) === 48))) {
				d.nd = i$2 + 1 >> 0;
				break;
			}
			i$2 = i$2 - (1) >> 0;
		}
		return true;
	};
	extFloat.prototype.FixedDecimal = function(d, n) { return this.$val.FixedDecimal(d, n); };
	adjustLastDigitFixed = function(d, num, den, shift, $CE$B5) {
		var $CE$B5, d, den, i, num, shift, x, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		if ((x = $shiftLeft64(den, shift), (num.$high > x.$high || (num.$high === x.$high && num.$low > x.$low)))) {
			$panic(new $String("strconv: num > den<<shift in adjustLastDigitFixed"));
		}
		if ((x$1 = $mul64(new $Uint64(0, 2), $CE$B5), x$2 = $shiftLeft64(den, shift), (x$1.$high > x$2.$high || (x$1.$high === x$2.$high && x$1.$low > x$2.$low)))) {
			$panic(new $String("strconv: \xCE\xB5 > (den<<shift)/2"));
		}
		if ((x$3 = $mul64(new $Uint64(0, 2), (new $Uint64(num.$high + $CE$B5.$high, num.$low + $CE$B5.$low))), x$4 = $shiftLeft64(den, shift), (x$3.$high < x$4.$high || (x$3.$high === x$4.$high && x$3.$low < x$4.$low)))) {
			return true;
		}
		if ((x$5 = $mul64(new $Uint64(0, 2), (new $Uint64(num.$high - $CE$B5.$high, num.$low - $CE$B5.$low))), x$6 = $shiftLeft64(den, shift), (x$5.$high > x$6.$high || (x$5.$high === x$6.$high && x$5.$low > x$6.$low)))) {
			i = d.nd - 1 >> 0;
			while (true) {
				if (!(i >= 0)) { break; }
				if ((x$7 = d.d, ((i < 0 || i >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + i])) === 57) {
					d.nd = d.nd - (1) >> 0;
				} else {
					break;
				}
				i = i - (1) >> 0;
			}
			if (i < 0) {
				(x$8 = d.d, (0 >= x$8.$length ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + 0] = 49));
				d.nd = 1;
				d.dp = d.dp + (1) >> 0;
			} else {
				(x$10 = d.d, ((i < 0 || i >= x$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + i] = ((x$9 = d.d, ((i < 0 || i >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + i])) + (1) << 24 >>> 24)));
			}
			return true;
		}
		return false;
	};
	extFloat.ptr.prototype.ShortestDecimal = function(d, lower, upper) {
		var _q, _tmp, _tmp$1, _tmp$2, _tmp$3, allowance, buf, currentDiff, d, digit, digit$1, exp10, f, fraction, i, i$1, i$2, integer, integerDigits, lower, multiplier, n, nd, pow, pow$1, shift, targetDiff, upper, v, v1, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$22, x$23, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		f = this;
		if ((x = f.mant, (x.$high === 0 && x.$low === 0))) {
			d.nd = 0;
			d.dp = 0;
			d.neg = f.neg;
			return true;
		}
		if ((f.exp === 0) && $equal(lower, f, extFloat) && $equal(lower, upper, extFloat)) {
			buf = arrayType$1.zero();
			n = 23;
			v = f.mant;
			while (true) {
				if (!((v.$high > 0 || (v.$high === 0 && v.$low > 0)))) { break; }
				v1 = $div64(v, new $Uint64(0, 10), false);
				v = (x$1 = $mul64(new $Uint64(0, 10), v1), new $Uint64(v.$high - x$1.$high, v.$low - x$1.$low));
				((n < 0 || n >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[n] = ((new $Uint64(v.$high + 0, v.$low + 48).$low << 24 >>> 24)));
				n = n - (1) >> 0;
				v = v1;
			}
			nd = (24 - n >> 0) - 1 >> 0;
			i = 0;
			while (true) {
				if (!(i < nd)) { break; }
				(x$3 = d.d, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i] = (x$2 = (n + 1 >> 0) + i >> 0, ((x$2 < 0 || x$2 >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[x$2]))));
				i = i + (1) >> 0;
			}
			_tmp = nd;
			_tmp$1 = nd;
			d.nd = _tmp;
			d.dp = _tmp$1;
			while (true) {
				if (!(d.nd > 0 && ((x$4 = d.d, x$5 = d.nd - 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])) === 48))) { break; }
				d.nd = d.nd - (1) >> 0;
			}
			if (d.nd === 0) {
				d.dp = 0;
			}
			d.neg = f.neg;
			return true;
		}
		upper.Normalize();
		if (f.exp > upper.exp) {
			f.mant = $shiftLeft64(f.mant, ((((f.exp - upper.exp >> 0) >>> 0))));
			f.exp = upper.exp;
		}
		if (lower.exp > upper.exp) {
			lower.mant = $shiftLeft64(lower.mant, ((((lower.exp - upper.exp >> 0) >>> 0))));
			lower.exp = upper.exp;
		}
		exp10 = frexp10Many(lower, f, upper);
		upper.mant = (x$6 = upper.mant, x$7 = new $Uint64(0, 1), new $Uint64(x$6.$high + x$7.$high, x$6.$low + x$7.$low));
		lower.mant = (x$8 = lower.mant, x$9 = new $Uint64(0, 1), new $Uint64(x$8.$high - x$9.$high, x$8.$low - x$9.$low));
		shift = ((-upper.exp >>> 0));
		integer = (($shiftRightUint64(upper.mant, shift).$low >>> 0));
		fraction = (x$10 = upper.mant, x$11 = $shiftLeft64((new $Uint64(0, integer)), shift), new $Uint64(x$10.$high - x$11.$high, x$10.$low - x$11.$low));
		allowance = (x$12 = upper.mant, x$13 = lower.mant, new $Uint64(x$12.$high - x$13.$high, x$12.$low - x$13.$low));
		targetDiff = (x$14 = upper.mant, x$15 = f.mant, new $Uint64(x$14.$high - x$15.$high, x$14.$low - x$15.$low));
		integerDigits = 0;
		_tmp$2 = 0;
		_tmp$3 = new $Uint64(0, 1);
		i$1 = _tmp$2;
		pow = _tmp$3;
		while (true) {
			if (!(i$1 < 20)) { break; }
			if ((x$16 = (new $Uint64(0, integer)), (pow.$high > x$16.$high || (pow.$high === x$16.$high && pow.$low > x$16.$low)))) {
				integerDigits = i$1;
				break;
			}
			pow = $mul64(pow, (new $Uint64(0, 10)));
			i$1 = i$1 + (1) >> 0;
		}
		i$2 = 0;
		while (true) {
			if (!(i$2 < integerDigits)) { break; }
			pow$1 = (x$17 = (integerDigits - i$2 >> 0) - 1 >> 0, ((x$17 < 0 || x$17 >= uint64pow10.length) ? ($throwRuntimeError("index out of range"), undefined) : uint64pow10[x$17]));
			digit = (_q = integer / ((pow$1.$low >>> 0)), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
			(x$18 = d.d, ((i$2 < 0 || i$2 >= x$18.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$18.$array[x$18.$offset + i$2] = (((digit + 48 >>> 0) << 24 >>> 24))));
			integer = integer - (($imul(digit, ((pow$1.$low >>> 0))) >>> 0)) >>> 0;
			currentDiff = (x$19 = $shiftLeft64((new $Uint64(0, integer)), shift), new $Uint64(x$19.$high + fraction.$high, x$19.$low + fraction.$low));
			if ((currentDiff.$high < allowance.$high || (currentDiff.$high === allowance.$high && currentDiff.$low < allowance.$low))) {
				d.nd = i$2 + 1 >> 0;
				d.dp = integerDigits + exp10 >> 0;
				d.neg = f.neg;
				return adjustLastDigit(d, currentDiff, targetDiff, allowance, $shiftLeft64(pow$1, shift), new $Uint64(0, 2));
			}
			i$2 = i$2 + (1) >> 0;
		}
		d.nd = integerDigits;
		d.dp = d.nd + exp10 >> 0;
		d.neg = f.neg;
		digit$1 = 0;
		multiplier = new $Uint64(0, 1);
		while (true) {
			fraction = $mul64(fraction, (new $Uint64(0, 10)));
			multiplier = $mul64(multiplier, (new $Uint64(0, 10)));
			digit$1 = (($shiftRightUint64(fraction, shift).$low >> 0));
			(x$20 = d.d, x$21 = d.nd, ((x$21 < 0 || x$21 >= x$20.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$20.$array[x$20.$offset + x$21] = (((digit$1 + 48 >> 0) << 24 >>> 24))));
			d.nd = d.nd + (1) >> 0;
			fraction = (x$22 = $shiftLeft64((new $Uint64(0, digit$1)), shift), new $Uint64(fraction.$high - x$22.$high, fraction.$low - x$22.$low));
			if ((x$23 = $mul64(allowance, multiplier), (fraction.$high < x$23.$high || (fraction.$high === x$23.$high && fraction.$low < x$23.$low)))) {
				return adjustLastDigit(d, fraction, $mul64(targetDiff, multiplier), $mul64(allowance, multiplier), $shiftLeft64(new $Uint64(0, 1), shift), $mul64(multiplier, new $Uint64(0, 2)));
			}
		}
	};
	extFloat.prototype.ShortestDecimal = function(d, lower, upper) { return this.$val.ShortestDecimal(d, lower, upper); };
	adjustLastDigit = function(d, currentDiff, targetDiff, maxDiff, ulpDecimal, ulpBinary) {
		var _index, currentDiff, d, maxDiff, targetDiff, ulpBinary, ulpDecimal, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		if ((x = $mul64(new $Uint64(0, 2), ulpBinary), (ulpDecimal.$high < x.$high || (ulpDecimal.$high === x.$high && ulpDecimal.$low < x.$low)))) {
			return false;
		}
		while (true) {
			if (!((x$1 = (x$2 = (x$3 = $div64(ulpDecimal, new $Uint64(0, 2), false), new $Uint64(currentDiff.$high + x$3.$high, currentDiff.$low + x$3.$low)), new $Uint64(x$2.$high + ulpBinary.$high, x$2.$low + ulpBinary.$low)), (x$1.$high < targetDiff.$high || (x$1.$high === targetDiff.$high && x$1.$low < targetDiff.$low))))) { break; }
			_index = d.nd - 1 >> 0;
			(x$5 = d.d, ((_index < 0 || _index >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + _index] = ((x$4 = d.d, ((_index < 0 || _index >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + _index])) - (1) << 24 >>> 24)));
			currentDiff = (x$6 = ulpDecimal, new $Uint64(currentDiff.$high + x$6.$high, currentDiff.$low + x$6.$low));
		}
		if ((x$7 = new $Uint64(currentDiff.$high + ulpDecimal.$high, currentDiff.$low + ulpDecimal.$low), x$8 = (x$9 = (x$10 = $div64(ulpDecimal, new $Uint64(0, 2), false), new $Uint64(targetDiff.$high + x$10.$high, targetDiff.$low + x$10.$low)), new $Uint64(x$9.$high + ulpBinary.$high, x$9.$low + ulpBinary.$low)), (x$7.$high < x$8.$high || (x$7.$high === x$8.$high && x$7.$low <= x$8.$low)))) {
			return false;
		}
		if ((currentDiff.$high < ulpBinary.$high || (currentDiff.$high === ulpBinary.$high && currentDiff.$low < ulpBinary.$low)) || (x$11 = new $Uint64(maxDiff.$high - ulpBinary.$high, maxDiff.$low - ulpBinary.$low), (currentDiff.$high > x$11.$high || (currentDiff.$high === x$11.$high && currentDiff.$low > x$11.$low)))) {
			return false;
		}
		if ((d.nd === 1) && ((x$12 = d.d, (0 >= x$12.$length ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + 0])) === 48)) {
			d.nd = 0;
			d.dp = 0;
		}
		return true;
	};
	AppendFloat = function(dst, f, fmt, prec, bitSize) {
		var bitSize, dst, f, fmt, prec;
		return genericFtoa(dst, f, fmt, prec, bitSize);
	};
	$pkg.AppendFloat = AppendFloat;
	genericFtoa = function(dst, val, fmt, prec, bitSize) {
		var _1, _2, _3, _4, _tuple, bitSize, bits$1, buf, buf$1, digits, digs, dst, exp, f, f$1, flt, fmt, lower, mant, neg, ok, prec, s, shortest, upper, val, x, x$1, x$2, x$3, y, y$1;
		bits$1 = new $Uint64(0, 0);
		flt = ptrType$1.nil;
		_1 = bitSize;
		if (_1 === (32)) {
			bits$1 = (new $Uint64(0, math.Float32bits(($fround(val)))));
			flt = float32info;
		} else if (_1 === (64)) {
			bits$1 = math.Float64bits(val);
			flt = float64info;
		} else {
			$panic(new $String("strconv: illegal AppendFloat/FormatFloat bitSize"));
		}
		neg = !((x = $shiftRightUint64(bits$1, ((flt.expbits + flt.mantbits >>> 0))), (x.$high === 0 && x.$low === 0)));
		exp = (($shiftRightUint64(bits$1, flt.mantbits).$low >> 0)) & ((((y = flt.expbits, y < 32 ? (1 << y) : 0) >> 0) - 1 >> 0));
		mant = (x$1 = (x$2 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), new $Uint64(x$2.$high - 0, x$2.$low - 1)), new $Uint64(bits$1.$high & x$1.$high, (bits$1.$low & x$1.$low) >>> 0));
		_2 = exp;
		if (_2 === ((((y$1 = flt.expbits, y$1 < 32 ? (1 << y$1) : 0) >> 0) - 1 >> 0))) {
			s = "";
			if (!((mant.$high === 0 && mant.$low === 0))) {
				s = "NaN";
			} else if (neg) {
				s = "-Inf";
			} else {
				s = "+Inf";
			}
			return $appendSlice(dst, s);
		} else if (_2 === (0)) {
			exp = exp + (1) >> 0;
		} else {
			mant = (x$3 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), new $Uint64(mant.$high | x$3.$high, (mant.$low | x$3.$low) >>> 0));
		}
		exp = exp + (flt.bias) >> 0;
		if (fmt === 98) {
			return fmtB(dst, neg, mant, exp, flt);
		}
		if (!optimize) {
			return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
		}
		digs = new decimalSlice.ptr(sliceType$6.nil, 0, 0, false);
		ok = false;
		shortest = prec < 0;
		if (shortest) {
			f = new extFloat.ptr(new $Uint64(0, 0), 0, false);
			_tuple = f.AssignComputeBounds(mant, exp, neg, flt);
			lower = $clone(_tuple[0], extFloat);
			upper = $clone(_tuple[1], extFloat);
			buf = arrayType$2.zero();
			digs.d = new sliceType$6(buf);
			ok = f.ShortestDecimal(digs, lower, upper);
			if (!ok) {
				return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
			}
			_3 = fmt;
			if ((_3 === (101)) || (_3 === (69))) {
				prec = max(digs.nd - 1 >> 0, 0);
			} else if (_3 === (102)) {
				prec = max(digs.nd - digs.dp >> 0, 0);
			} else if ((_3 === (103)) || (_3 === (71))) {
				prec = digs.nd;
			}
		} else if (!((fmt === 102))) {
			digits = prec;
			_4 = fmt;
			if ((_4 === (101)) || (_4 === (69))) {
				digits = digits + (1) >> 0;
			} else if ((_4 === (103)) || (_4 === (71))) {
				if (prec === 0) {
					prec = 1;
				}
				digits = prec;
			}
			if (digits <= 15) {
				buf$1 = arrayType$1.zero();
				digs.d = new sliceType$6(buf$1);
				f$1 = new extFloat.ptr(mant, exp - ((flt.mantbits >> 0)) >> 0, neg);
				ok = f$1.FixedDecimal(digs, digits);
			}
		}
		if (!ok) {
			return bigFtoa(dst, prec, fmt, neg, mant, exp, flt);
		}
		return formatDigits(dst, shortest, neg, $clone(digs, decimalSlice), prec, fmt);
	};
	bigFtoa = function(dst, prec, fmt, neg, mant, exp, flt) {
		var _1, _2, d, digs, dst, exp, flt, fmt, mant, neg, prec, shortest;
		d = new decimal.ptr(arrayType.zero(), 0, 0, false, false);
		d.Assign(mant);
		d.Shift(exp - ((flt.mantbits >> 0)) >> 0);
		digs = new decimalSlice.ptr(sliceType$6.nil, 0, 0, false);
		shortest = prec < 0;
		if (shortest) {
			roundShortest(d, mant, exp, flt);
			decimalSlice.copy(digs, new decimalSlice.ptr(new sliceType$6(d.d), d.nd, d.dp, false));
			_1 = fmt;
			if ((_1 === (101)) || (_1 === (69))) {
				prec = digs.nd - 1 >> 0;
			} else if (_1 === (102)) {
				prec = max(digs.nd - digs.dp >> 0, 0);
			} else if ((_1 === (103)) || (_1 === (71))) {
				prec = digs.nd;
			}
		} else {
			_2 = fmt;
			if ((_2 === (101)) || (_2 === (69))) {
				d.Round(prec + 1 >> 0);
			} else if (_2 === (102)) {
				d.Round(d.dp + prec >> 0);
			} else if ((_2 === (103)) || (_2 === (71))) {
				if (prec === 0) {
					prec = 1;
				}
				d.Round(prec);
			}
			decimalSlice.copy(digs, new decimalSlice.ptr(new sliceType$6(d.d), d.nd, d.dp, false));
		}
		return formatDigits(dst, shortest, neg, $clone(digs, decimalSlice), prec, fmt);
	};
	formatDigits = function(dst, shortest, neg, digs, prec, fmt) {
		var _1, digs, dst, eprec, exp, fmt, neg, prec, shortest;
		_1 = fmt;
		if ((_1 === (101)) || (_1 === (69))) {
			return fmtE(dst, neg, $clone(digs, decimalSlice), prec, fmt);
		} else if (_1 === (102)) {
			return fmtF(dst, neg, $clone(digs, decimalSlice), prec);
		} else if ((_1 === (103)) || (_1 === (71))) {
			eprec = prec;
			if (eprec > digs.nd && digs.nd >= digs.dp) {
				eprec = digs.nd;
			}
			if (shortest) {
				eprec = 6;
			}
			exp = digs.dp - 1 >> 0;
			if (exp < -4 || exp >= eprec) {
				if (prec > digs.nd) {
					prec = digs.nd;
				}
				return fmtE(dst, neg, $clone(digs, decimalSlice), prec - 1 >> 0, (fmt + 101 << 24 >>> 24) - 103 << 24 >>> 24);
			}
			if (prec > digs.dp) {
				prec = digs.nd;
			}
			return fmtF(dst, neg, $clone(digs, decimalSlice), max(prec - digs.dp >> 0, 0));
		}
		return $append(dst, 37, fmt);
	};
	roundShortest = function(d, mant, exp, flt) {
		var d, exp, explo, flt, i, inclusive, l, lower, m, mant, mantlo, minexp, okdown, okup, u, upper, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7;
		if ((mant.$high === 0 && mant.$low === 0)) {
			d.nd = 0;
			return;
		}
		minexp = flt.bias + 1 >> 0;
		if (exp > minexp && ($imul(332, ((d.dp - d.nd >> 0)))) >= ($imul(100, ((exp - ((flt.mantbits >> 0)) >> 0))))) {
			return;
		}
		upper = new decimal.ptr(arrayType.zero(), 0, 0, false, false);
		upper.Assign((x = $mul64(mant, new $Uint64(0, 2)), new $Uint64(x.$high + 0, x.$low + 1)));
		upper.Shift((exp - ((flt.mantbits >> 0)) >> 0) - 1 >> 0);
		mantlo = new $Uint64(0, 0);
		explo = 0;
		if ((x$1 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), (mant.$high > x$1.$high || (mant.$high === x$1.$high && mant.$low > x$1.$low))) || (exp === minexp)) {
			mantlo = new $Uint64(mant.$high - 0, mant.$low - 1);
			explo = exp;
		} else {
			mantlo = (x$2 = $mul64(mant, new $Uint64(0, 2)), new $Uint64(x$2.$high - 0, x$2.$low - 1));
			explo = exp - 1 >> 0;
		}
		lower = new decimal.ptr(arrayType.zero(), 0, 0, false, false);
		lower.Assign((x$3 = $mul64(mantlo, new $Uint64(0, 2)), new $Uint64(x$3.$high + 0, x$3.$low + 1)));
		lower.Shift((explo - ((flt.mantbits >> 0)) >> 0) - 1 >> 0);
		inclusive = (x$4 = $div64(mant, new $Uint64(0, 2), true), (x$4.$high === 0 && x$4.$low === 0));
		i = 0;
		while (true) {
			if (!(i < d.nd)) { break; }
			l = 48;
			if (i < lower.nd) {
				l = (x$5 = lower.d, ((i < 0 || i >= x$5.length) ? ($throwRuntimeError("index out of range"), undefined) : x$5[i]));
			}
			m = (x$6 = d.d, ((i < 0 || i >= x$6.length) ? ($throwRuntimeError("index out of range"), undefined) : x$6[i]));
			u = 48;
			if (i < upper.nd) {
				u = (x$7 = upper.d, ((i < 0 || i >= x$7.length) ? ($throwRuntimeError("index out of range"), undefined) : x$7[i]));
			}
			okdown = !((l === m)) || inclusive && ((i + 1 >> 0) === lower.nd);
			okup = !((m === u)) && (inclusive || (m + 1 << 24 >>> 24) < u || (i + 1 >> 0) < upper.nd);
			if (okdown && okup) {
				d.Round(i + 1 >> 0);
				return;
			} else if (okdown) {
				d.RoundDown(i + 1 >> 0);
				return;
			} else if (okup) {
				d.RoundUp(i + 1 >> 0);
				return;
			}
			i = i + (1) >> 0;
		}
	};
	fmtE = function(dst, neg, d, prec, fmt) {
		var _q, _q$1, _q$2, _r, _r$1, _r$2, ch, d, dst, exp, fmt, i, m, neg, prec, x;
		if (neg) {
			dst = $append(dst, 45);
		}
		ch = 48;
		if (!((d.nd === 0))) {
			ch = (x = d.d, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
		}
		dst = $append(dst, ch);
		if (prec > 0) {
			dst = $append(dst, 46);
			i = 1;
			m = min(d.nd, prec + 1 >> 0);
			if (i < m) {
				dst = $appendSlice(dst, $subslice(d.d, i, m));
				i = m;
			}
			while (true) {
				if (!(i <= prec)) { break; }
				dst = $append(dst, 48);
				i = i + (1) >> 0;
			}
		}
		dst = $append(dst, fmt);
		exp = d.dp - 1 >> 0;
		if (d.nd === 0) {
			exp = 0;
		}
		if (exp < 0) {
			ch = 45;
			exp = -exp;
		} else {
			ch = 43;
		}
		dst = $append(dst, ch);
		if (exp < 10) {
			dst = $append(dst, 48, ((exp << 24 >>> 24)) + 48 << 24 >>> 24);
		} else if (exp < 100) {
			dst = $append(dst, (((_q = exp / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) << 24 >>> 24)) + 48 << 24 >>> 24, (((_r = exp % 10, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) << 24 >>> 24)) + 48 << 24 >>> 24);
		} else {
			dst = $append(dst, (((_q$1 = exp / 100, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")) << 24 >>> 24)) + 48 << 24 >>> 24, (_r$1 = (((_q$2 = exp / 10, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero")) << 24 >>> 24)) % 10, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) + 48 << 24 >>> 24, (((_r$2 = exp % 10, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero")) << 24 >>> 24)) + 48 << 24 >>> 24);
		}
		return dst;
	};
	fmtF = function(dst, neg, d, prec) {
		var ch, d, dst, i, j, m, neg, prec, x;
		if (neg) {
			dst = $append(dst, 45);
		}
		if (d.dp > 0) {
			m = min(d.nd, d.dp);
			dst = $appendSlice(dst, $subslice(d.d, 0, m));
			while (true) {
				if (!(m < d.dp)) { break; }
				dst = $append(dst, 48);
				m = m + (1) >> 0;
			}
		} else {
			dst = $append(dst, 48);
		}
		if (prec > 0) {
			dst = $append(dst, 46);
			i = 0;
			while (true) {
				if (!(i < prec)) { break; }
				ch = 48;
				j = d.dp + i >> 0;
				if (0 <= j && j < d.nd) {
					ch = (x = d.d, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]));
				}
				dst = $append(dst, ch);
				i = i + (1) >> 0;
			}
		}
		return dst;
	};
	fmtB = function(dst, neg, mant, exp, flt) {
		var _tuple, _tuple$1, dst, exp, flt, mant, neg;
		if (neg) {
			dst = $append(dst, 45);
		}
		_tuple = formatBits(dst, mant, 10, false, true);
		dst = _tuple[0];
		dst = $append(dst, 112);
		exp = exp - (((flt.mantbits >> 0))) >> 0;
		if (exp >= 0) {
			dst = $append(dst, 43);
		}
		_tuple$1 = formatBits(dst, (new $Uint64(0, exp)), 10, exp < 0, true);
		dst = _tuple$1[0];
		return dst;
	};
	min = function(a, b) {
		var a, b;
		if (a < b) {
			return a;
		}
		return b;
	};
	max = function(a, b) {
		var a, b;
		if (a > b) {
			return a;
		}
		return b;
	};
	FormatUint = function(i, base) {
		var _tuple, base, i, s;
		if (true && (i.$high < 0 || (i.$high === 0 && i.$low < 100)) && (base === 10)) {
			return small(((i.$low >> 0)));
		}
		_tuple = formatBits(sliceType$6.nil, i, base, false, false);
		s = _tuple[1];
		return s;
	};
	$pkg.FormatUint = FormatUint;
	FormatInt = function(i, base) {
		var _tuple, base, i, s;
		if (true && (0 < i.$high || (0 === i.$high && 0 <= i.$low)) && (i.$high < 0 || (i.$high === 0 && i.$low < 100)) && (base === 10)) {
			return small((((i.$low + ((i.$high >> 31) * 4294967296)) >> 0)));
		}
		_tuple = formatBits(sliceType$6.nil, (new $Uint64(i.$high, i.$low)), base, (i.$high < 0 || (i.$high === 0 && i.$low < 0)), false);
		s = _tuple[1];
		return s;
	};
	$pkg.FormatInt = FormatInt;
	Itoa = function(i) {
		var i;
		return FormatInt((new $Int64(0, i)), 10);
	};
	$pkg.Itoa = Itoa;
	small = function(i) {
		var i;
		if (i < 10) {
			return $substring("0123456789abcdefghijklmnopqrstuvwxyz", i, (i + 1 >> 0));
		}
		return $substring("00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", ($imul(i, 2)), (($imul(i, 2)) + 2 >> 0));
	};
	formatBits = function(dst, u, base, neg, append_) {
		var _q, _q$1, _r, _r$1, a, append_, b, b$1, base, d, dst, i, is, is$1, is$2, j, m, neg, q, q$1, s, shift, u, us, us$1, x, x$1, x$2, x$3, x$4, x$5;
		d = sliceType$6.nil;
		s = "";
		if (base < 2 || base > 36) {
			$panic(new $String("strconv: illegal AppendInt/FormatInt base"));
		}
		a = arrayType$3.zero();
		i = 65;
		if (neg) {
			u = new $Uint64(-u.$high, -u.$low);
		}
		if (base === 10) {
			if (true) {
				while (true) {
					if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 1000000000)))) { break; }
					q = $div64(u, new $Uint64(0, 1000000000), false);
					us = (((x = $mul64(q, new $Uint64(0, 1000000000)), new $Uint64(u.$high - x.$high, u.$low - x.$low)).$low >>> 0));
					j = 4;
					while (true) {
						if (!(j > 0)) { break; }
						is = (_r = us % 100, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) * 2 >>> 0;
						us = (_q = us / (100), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
						i = i - (2) >> 0;
						(x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$1] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is + 1 >>> 0))));
						(x$2 = i + 0 >> 0, ((x$2 < 0 || x$2 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$2] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is + 0 >>> 0))));
						j = j - (1) >> 0;
					}
					i = i - (1) >> 0;
					((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(((us * 2 >>> 0) + 1 >>> 0)));
					u = q;
				}
			}
			us$1 = ((u.$low >>> 0));
			while (true) {
				if (!(us$1 >= 100)) { break; }
				is$1 = (_r$1 = us$1 % 100, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) * 2 >>> 0;
				us$1 = (_q$1 = us$1 / (100), (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
				i = i - (2) >> 0;
				(x$3 = i + 1 >> 0, ((x$3 < 0 || x$3 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$3] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$1 + 1 >>> 0))));
				(x$4 = i + 0 >> 0, ((x$4 < 0 || x$4 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$4] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$1 + 0 >>> 0))));
			}
			is$2 = us$1 * 2 >>> 0;
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$2 + 1 >>> 0)));
			if (us$1 >= 10) {
				i = i - (1) >> 0;
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(is$2));
			}
		} else if (isPowerOfTwo(base)) {
			shift = (((bits.TrailingZeros(((base >>> 0))) >>> 0)) & 7) >>> 0;
			b = (new $Uint64(0, base));
			m = ((base >>> 0)) - 1 >>> 0;
			while (true) {
				if (!((u.$high > b.$high || (u.$high === b.$high && u.$low >= b.$low)))) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((((u.$low >>> 0)) & m) >>> 0)));
				u = $shiftRightUint64(u, (shift));
			}
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((u.$low >>> 0))));
		} else {
			b$1 = (new $Uint64(0, base));
			while (true) {
				if (!((u.$high > b$1.$high || (u.$high === b$1.$high && u.$low >= b$1.$low)))) { break; }
				i = i - (1) >> 0;
				q$1 = $div64(u, b$1, false);
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt((((x$5 = $mul64(q$1, b$1), new $Uint64(u.$high - x$5.$high, u.$low - x$5.$low)).$low >>> 0))));
				u = q$1;
			}
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((u.$low >>> 0))));
		}
		if (neg) {
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = 45);
		}
		if (append_) {
			d = $appendSlice(dst, $subslice(new sliceType$6(a), i));
			return [d, s];
		}
		s = ($bytesToString($subslice(new sliceType$6(a), i)));
		return [d, s];
	};
	isPowerOfTwo = function(x) {
		var x;
		return (x & ((x - 1 >> 0))) === 0;
	};
	quoteWith = function(s, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _q, graphicOnly, quote, s;
		return ($bytesToString(appendQuotedWith($makeSlice(sliceType$6, 0, (_q = ($imul(3, s.length)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"))), s, quote, ASCIIonly, graphicOnly)));
	};
	appendQuotedWith = function(buf, s, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _tuple, buf, graphicOnly, quote, r, s, width;
		buf = $append(buf, quote);
		width = 0;
		while (true) {
			if (!(s.length > 0)) { break; }
			r = ((s.charCodeAt(0) >> 0));
			width = 1;
			if (r >= 128) {
				_tuple = utf8.DecodeRuneInString(s);
				r = _tuple[0];
				width = _tuple[1];
			}
			if ((width === 1) && (r === 65533)) {
				buf = $appendSlice(buf, "\\x");
				buf = $append(buf, "0123456789abcdef".charCodeAt((s.charCodeAt(0) >>> 4 << 24 >>> 24)));
				buf = $append(buf, "0123456789abcdef".charCodeAt(((s.charCodeAt(0) & 15) >>> 0)));
				s = $substring(s, width);
				continue;
			}
			buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
			s = $substring(s, width);
		}
		buf = $append(buf, quote);
		return buf;
	};
	appendQuotedRuneWith = function(buf, r, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, buf, graphicOnly, quote, r;
		buf = $append(buf, quote);
		if (!utf8.ValidRune(r)) {
			r = 65533;
		}
		buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
		buf = $append(buf, quote);
		return buf;
	};
	appendEscapedRune = function(buf, r, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _1, buf, graphicOnly, n, quote, r, runeTmp, s, s$1;
		runeTmp = arrayType$4.zero();
		if ((r === ((quote >> 0))) || (r === 92)) {
			buf = $append(buf, 92);
			buf = $append(buf, ((r << 24 >>> 24)));
			return buf;
		}
		if (ASCIIonly) {
			if (r < 128 && IsPrint(r)) {
				buf = $append(buf, ((r << 24 >>> 24)));
				return buf;
			}
		} else if (IsPrint(r) || graphicOnly && isInGraphicList(r)) {
			n = utf8.EncodeRune(new sliceType$6(runeTmp), r);
			buf = $appendSlice(buf, $subslice(new sliceType$6(runeTmp), 0, n));
			return buf;
		}
		_1 = r;
		if (_1 === (7)) {
			buf = $appendSlice(buf, "\\a");
		} else if (_1 === (8)) {
			buf = $appendSlice(buf, "\\b");
		} else if (_1 === (12)) {
			buf = $appendSlice(buf, "\\f");
		} else if (_1 === (10)) {
			buf = $appendSlice(buf, "\\n");
		} else if (_1 === (13)) {
			buf = $appendSlice(buf, "\\r");
		} else if (_1 === (9)) {
			buf = $appendSlice(buf, "\\t");
		} else if (_1 === (11)) {
			buf = $appendSlice(buf, "\\v");
		} else {
			if (r < 32) {
				buf = $appendSlice(buf, "\\x");
				buf = $append(buf, "0123456789abcdef".charCodeAt((((r << 24 >>> 24)) >>> 4 << 24 >>> 24)));
				buf = $append(buf, "0123456789abcdef".charCodeAt(((((r << 24 >>> 24)) & 15) >>> 0)));
			} else if (r > 1114111) {
				r = 65533;
				buf = $appendSlice(buf, "\\u");
				s = 12;
				while (true) {
					if (!(s >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s >>> 0)), 31)) >> 0) & 15)));
					s = s - (4) >> 0;
				}
			} else if (r < 65536) {
				buf = $appendSlice(buf, "\\u");
				s = 12;
				while (true) {
					if (!(s >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s >>> 0)), 31)) >> 0) & 15)));
					s = s - (4) >> 0;
				}
			} else {
				buf = $appendSlice(buf, "\\U");
				s$1 = 28;
				while (true) {
					if (!(s$1 >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s$1 >>> 0)), 31)) >> 0) & 15)));
					s$1 = s$1 - (4) >> 0;
				}
			}
		}
		return buf;
	};
	Quote = function(s) {
		var s;
		return quoteWith(s, 34, false, false);
	};
	$pkg.Quote = Quote;
	AppendQuote = function(dst, s) {
		var dst, s;
		return appendQuotedWith(dst, s, 34, false, false);
	};
	$pkg.AppendQuote = AppendQuote;
	QuoteToASCII = function(s) {
		var s;
		return quoteWith(s, 34, true, false);
	};
	$pkg.QuoteToASCII = QuoteToASCII;
	AppendQuoteToASCII = function(dst, s) {
		var dst, s;
		return appendQuotedWith(dst, s, 34, true, false);
	};
	$pkg.AppendQuoteToASCII = AppendQuoteToASCII;
	AppendQuoteRune = function(dst, r) {
		var dst, r;
		return appendQuotedRuneWith(dst, r, 39, false, false);
	};
	$pkg.AppendQuoteRune = AppendQuoteRune;
	AppendQuoteRuneToASCII = function(dst, r) {
		var dst, r;
		return appendQuotedRuneWith(dst, r, 39, true, false);
	};
	$pkg.AppendQuoteRuneToASCII = AppendQuoteRuneToASCII;
	CanBackquote = function(s) {
		var _tuple, r, s, wid;
		while (true) {
			if (!(s.length > 0)) { break; }
			_tuple = utf8.DecodeRuneInString(s);
			r = _tuple[0];
			wid = _tuple[1];
			s = $substring(s, wid);
			if (wid > 1) {
				if (r === 65279) {
					return false;
				}
				continue;
			}
			if (r === 65533) {
				return false;
			}
			if ((r < 32 && !((r === 9))) || (r === 96) || (r === 127)) {
				return false;
			}
		}
		return true;
	};
	$pkg.CanBackquote = CanBackquote;
	unhex = function(b) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, c, ok, v;
		v = 0;
		ok = false;
		c = ((b >> 0));
		if (48 <= c && c <= 57) {
			_tmp = c - 48 >> 0;
			_tmp$1 = true;
			v = _tmp;
			ok = _tmp$1;
			return [v, ok];
		} else if (97 <= c && c <= 102) {
			_tmp$2 = (c - 97 >> 0) + 10 >> 0;
			_tmp$3 = true;
			v = _tmp$2;
			ok = _tmp$3;
			return [v, ok];
		} else if (65 <= c && c <= 70) {
			_tmp$4 = (c - 65 >> 0) + 10 >> 0;
			_tmp$5 = true;
			v = _tmp$4;
			ok = _tmp$5;
			return [v, ok];
		}
		return [v, ok];
	};
	UnquoteChar = function(s, quote) {
		var _1, _2, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, c, c$1, err, j, j$1, multibyte, n, ok, quote, r, s, size, tail, v, v$1, value, x, x$1;
		value = 0;
		multibyte = false;
		tail = "";
		err = $ifaceNil;
		if (s.length === 0) {
			err = $pkg.ErrSyntax;
			return [value, multibyte, tail, err];
		}
		c = s.charCodeAt(0);
		if ((c === quote) && ((quote === 39) || (quote === 34))) {
			err = $pkg.ErrSyntax;
			return [value, multibyte, tail, err];
		} else if (c >= 128) {
			_tuple = utf8.DecodeRuneInString(s);
			r = _tuple[0];
			size = _tuple[1];
			_tmp = r;
			_tmp$1 = true;
			_tmp$2 = $substring(s, size);
			_tmp$3 = $ifaceNil;
			value = _tmp;
			multibyte = _tmp$1;
			tail = _tmp$2;
			err = _tmp$3;
			return [value, multibyte, tail, err];
		} else if (!((c === 92))) {
			_tmp$4 = ((s.charCodeAt(0) >> 0));
			_tmp$5 = false;
			_tmp$6 = $substring(s, 1);
			_tmp$7 = $ifaceNil;
			value = _tmp$4;
			multibyte = _tmp$5;
			tail = _tmp$6;
			err = _tmp$7;
			return [value, multibyte, tail, err];
		}
		if (s.length <= 1) {
			err = $pkg.ErrSyntax;
			return [value, multibyte, tail, err];
		}
		c$1 = s.charCodeAt(1);
		s = $substring(s, 2);
		switch (0) { default:
			_1 = c$1;
			if (_1 === (97)) {
				value = 7;
			} else if (_1 === (98)) {
				value = 8;
			} else if (_1 === (102)) {
				value = 12;
			} else if (_1 === (110)) {
				value = 10;
			} else if (_1 === (114)) {
				value = 13;
			} else if (_1 === (116)) {
				value = 9;
			} else if (_1 === (118)) {
				value = 11;
			} else if ((_1 === (120)) || (_1 === (117)) || (_1 === (85))) {
				n = 0;
				_2 = c$1;
				if (_2 === (120)) {
					n = 2;
				} else if (_2 === (117)) {
					n = 4;
				} else if (_2 === (85)) {
					n = 8;
				}
				v = 0;
				if (s.length < n) {
					err = $pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				j = 0;
				while (true) {
					if (!(j < n)) { break; }
					_tuple$1 = unhex(s.charCodeAt(j));
					x = _tuple$1[0];
					ok = _tuple$1[1];
					if (!ok) {
						err = $pkg.ErrSyntax;
						return [value, multibyte, tail, err];
					}
					v = (v << 4 >> 0) | x;
					j = j + (1) >> 0;
				}
				s = $substring(s, n);
				if (c$1 === 120) {
					value = v;
					break;
				}
				if (v > 1114111) {
					err = $pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				value = v;
				multibyte = true;
			} else if ((_1 === (48)) || (_1 === (49)) || (_1 === (50)) || (_1 === (51)) || (_1 === (52)) || (_1 === (53)) || (_1 === (54)) || (_1 === (55))) {
				v$1 = ((c$1 >> 0)) - 48 >> 0;
				if (s.length < 2) {
					err = $pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				j$1 = 0;
				while (true) {
					if (!(j$1 < 2)) { break; }
					x$1 = ((s.charCodeAt(j$1) >> 0)) - 48 >> 0;
					if (x$1 < 0 || x$1 > 7) {
						err = $pkg.ErrSyntax;
						return [value, multibyte, tail, err];
					}
					v$1 = ((v$1 << 3 >> 0)) | x$1;
					j$1 = j$1 + (1) >> 0;
				}
				s = $substring(s, 2);
				if (v$1 > 255) {
					err = $pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				value = v$1;
			} else if (_1 === (92)) {
				value = 92;
			} else if ((_1 === (39)) || (_1 === (34))) {
				if (!((c$1 === quote))) {
					err = $pkg.ErrSyntax;
					return [value, multibyte, tail, err];
				}
				value = ((c$1 >> 0));
			} else {
				err = $pkg.ErrSyntax;
				return [value, multibyte, tail, err];
			}
		}
		tail = s;
		return [value, multibyte, tail, err];
	};
	$pkg.UnquoteChar = UnquoteChar;
	Unquote = function(s) {
		var _1, _q, _tuple, _tuple$1, buf, buf$1, c, err, i, multibyte, n, n$1, quote, r, runeTmp, s, size, ss;
		n = s.length;
		if (n < 2) {
			return ["", $pkg.ErrSyntax];
		}
		quote = s.charCodeAt(0);
		if (!((quote === s.charCodeAt((n - 1 >> 0))))) {
			return ["", $pkg.ErrSyntax];
		}
		s = $substring(s, 1, (n - 1 >> 0));
		if (quote === 96) {
			if (contains(s, 96)) {
				return ["", $pkg.ErrSyntax];
			}
			if (contains(s, 13)) {
				buf = $makeSlice(sliceType$6, 0, (s.length - 1 >> 0));
				i = 0;
				while (true) {
					if (!(i < s.length)) { break; }
					if (!((s.charCodeAt(i) === 13))) {
						buf = $append(buf, s.charCodeAt(i));
					}
					i = i + (1) >> 0;
				}
				return [($bytesToString(buf)), $ifaceNil];
			}
			return [s, $ifaceNil];
		}
		if (!((quote === 34)) && !((quote === 39))) {
			return ["", $pkg.ErrSyntax];
		}
		if (contains(s, 10)) {
			return ["", $pkg.ErrSyntax];
		}
		if (!contains(s, 92) && !contains(s, quote)) {
			_1 = quote;
			if (_1 === (34)) {
				if (utf8.ValidString(s)) {
					return [s, $ifaceNil];
				}
			} else if (_1 === (39)) {
				_tuple = utf8.DecodeRuneInString(s);
				r = _tuple[0];
				size = _tuple[1];
				if ((size === s.length) && (!((r === 65533)) || !((size === 1)))) {
					return [s, $ifaceNil];
				}
			}
		}
		runeTmp = arrayType$4.zero();
		buf$1 = $makeSlice(sliceType$6, 0, (_q = ($imul(3, s.length)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")));
		while (true) {
			if (!(s.length > 0)) { break; }
			_tuple$1 = UnquoteChar(s, quote);
			c = _tuple$1[0];
			multibyte = _tuple$1[1];
			ss = _tuple$1[2];
			err = _tuple$1[3];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				return ["", err];
			}
			s = ss;
			if (c < 128 || !multibyte) {
				buf$1 = $append(buf$1, ((c << 24 >>> 24)));
			} else {
				n$1 = utf8.EncodeRune(new sliceType$6(runeTmp), c);
				buf$1 = $appendSlice(buf$1, $subslice(new sliceType$6(runeTmp), 0, n$1));
			}
			if ((quote === 39) && !((s.length === 0))) {
				return ["", $pkg.ErrSyntax];
			}
		}
		return [($bytesToString(buf$1)), $ifaceNil];
	};
	$pkg.Unquote = Unquote;
	contains = function(s, c) {
		var c, s;
		return !((bytealg.IndexByteString(s, c) === -1));
	};
	bsearch16 = function(a, x) {
		var _q, _tmp, _tmp$1, a, h, i, j, x;
		_tmp = 0;
		_tmp$1 = a.$length;
		i = _tmp;
		j = _tmp$1;
		while (true) {
			if (!(i < j)) { break; }
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((h < 0 || h >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + h]) < x) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	bsearch32 = function(a, x) {
		var _q, _tmp, _tmp$1, a, h, i, j, x;
		_tmp = 0;
		_tmp$1 = a.$length;
		i = _tmp;
		j = _tmp$1;
		while (true) {
			if (!(i < j)) { break; }
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((h < 0 || h >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + h]) < x) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	IsPrint = function(r) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, i, i$1, isNotPrint, isNotPrint$1, isPrint, isPrint$1, j, j$1, r, rr, rr$1, x, x$1, x$2, x$3;
		if (r <= 255) {
			if (32 <= r && r <= 126) {
				return true;
			}
			if (161 <= r && r <= 255) {
				return !((r === 173));
			}
			return false;
		}
		if (0 <= r && r < 65536) {
			_tmp = ((r << 16 >>> 16));
			_tmp$1 = isPrint16;
			_tmp$2 = isNotPrint16;
			rr = _tmp;
			isPrint = _tmp$1;
			isNotPrint = _tmp$2;
			i = bsearch16(isPrint, rr);
			if (i >= isPrint.$length || rr < (x = (i & ~1) >> 0, ((x < 0 || x >= isPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint.$array[isPrint.$offset + x])) || (x$1 = i | 1, ((x$1 < 0 || x$1 >= isPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint.$array[isPrint.$offset + x$1])) < rr) {
				return false;
			}
			j = bsearch16(isNotPrint, rr);
			return j >= isNotPrint.$length || !((((j < 0 || j >= isNotPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isNotPrint.$array[isNotPrint.$offset + j]) === rr));
		}
		_tmp$3 = ((r >>> 0));
		_tmp$4 = isPrint32;
		_tmp$5 = isNotPrint32;
		rr$1 = _tmp$3;
		isPrint$1 = _tmp$4;
		isNotPrint$1 = _tmp$5;
		i$1 = bsearch32(isPrint$1, rr$1);
		if (i$1 >= isPrint$1.$length || rr$1 < (x$2 = (i$1 & ~1) >> 0, ((x$2 < 0 || x$2 >= isPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint$1.$array[isPrint$1.$offset + x$2])) || (x$3 = i$1 | 1, ((x$3 < 0 || x$3 >= isPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint$1.$array[isPrint$1.$offset + x$3])) < rr$1) {
			return false;
		}
		if (r >= 131072) {
			return true;
		}
		r = r - (65536) >> 0;
		j$1 = bsearch16(isNotPrint$1, ((r << 16 >>> 16)));
		return j$1 >= isNotPrint$1.$length || !((((j$1 < 0 || j$1 >= isNotPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isNotPrint$1.$array[isNotPrint$1.$offset + j$1]) === ((r << 16 >>> 16))));
	};
	$pkg.IsPrint = IsPrint;
	isInGraphicList = function(r) {
		var i, r, rr;
		if (r > 65535) {
			return false;
		}
		rr = ((r << 16 >>> 16));
		i = bsearch16(isGraphic, rr);
		return i < isGraphic.$length && (rr === ((i < 0 || i >= isGraphic.$length) ? ($throwRuntimeError("index out of range"), undefined) : isGraphic.$array[isGraphic.$offset + i]));
	};
	ptrType$2.methods = [{prop: "set", name: "set", pkg: "strconv", typ: $funcType([$String], [$Bool], false)}, {prop: "floatBits", name: "floatBits", pkg: "strconv", typ: $funcType([ptrType$1], [$Uint64, $Bool], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Assign", name: "Assign", pkg: "", typ: $funcType([$Uint64], [], false)}, {prop: "Shift", name: "Shift", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Round", name: "Round", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "RoundDown", name: "RoundDown", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "RoundUp", name: "RoundUp", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "RoundedInteger", name: "RoundedInteger", pkg: "", typ: $funcType([], [$Uint64], false)}];
	ptrType$4.methods = [{prop: "floatBits", name: "floatBits", pkg: "strconv", typ: $funcType([ptrType$1], [$Uint64, $Bool], false)}, {prop: "AssignComputeBounds", name: "AssignComputeBounds", pkg: "", typ: $funcType([$Uint64, $Int, $Bool, ptrType$1], [extFloat, extFloat], false)}, {prop: "Normalize", name: "Normalize", pkg: "", typ: $funcType([], [$Uint], false)}, {prop: "Multiply", name: "Multiply", pkg: "", typ: $funcType([extFloat], [], false)}, {prop: "AssignDecimal", name: "AssignDecimal", pkg: "", typ: $funcType([$Uint64, $Int, $Bool, $Bool, ptrType$1], [$Bool], false)}, {prop: "frexp10", name: "frexp10", pkg: "strconv", typ: $funcType([], [$Int, $Int], false)}, {prop: "FixedDecimal", name: "FixedDecimal", pkg: "", typ: $funcType([ptrType$3, $Int], [$Bool], false)}, {prop: "ShortestDecimal", name: "ShortestDecimal", pkg: "", typ: $funcType([ptrType$3, ptrType$4, ptrType$4], [$Bool], false)}];
	decimal.init("strconv", [{prop: "d", name: "d", embedded: false, exported: false, typ: arrayType, tag: ""}, {prop: "nd", name: "nd", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "dp", name: "dp", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "neg", name: "neg", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "trunc", name: "trunc", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	leftCheat.init("strconv", [{prop: "delta", name: "delta", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "cutoff", name: "cutoff", embedded: false, exported: false, typ: $String, tag: ""}]);
	extFloat.init("strconv", [{prop: "mant", name: "mant", embedded: false, exported: false, typ: $Uint64, tag: ""}, {prop: "exp", name: "exp", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "neg", name: "neg", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	floatInfo.init("strconv", [{prop: "mantbits", name: "mantbits", embedded: false, exported: false, typ: $Uint, tag: ""}, {prop: "expbits", name: "expbits", embedded: false, exported: false, typ: $Uint, tag: ""}, {prop: "bias", name: "bias", embedded: false, exported: false, typ: $Int, tag: ""}]);
	decimalSlice.init("strconv", [{prop: "d", name: "d", embedded: false, exported: false, typ: sliceType$6, tag: ""}, {prop: "nd", name: "nd", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "dp", name: "dp", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "neg", name: "neg", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bits.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		optimize = true;
		$pkg.ErrRange = errors.New("value out of range");
		$pkg.ErrSyntax = errors.New("invalid syntax");
		leftcheats = new sliceType$3([new leftCheat.ptr(0, ""), new leftCheat.ptr(1, "5"), new leftCheat.ptr(1, "25"), new leftCheat.ptr(1, "125"), new leftCheat.ptr(2, "625"), new leftCheat.ptr(2, "3125"), new leftCheat.ptr(2, "15625"), new leftCheat.ptr(3, "78125"), new leftCheat.ptr(3, "390625"), new leftCheat.ptr(3, "1953125"), new leftCheat.ptr(4, "9765625"), new leftCheat.ptr(4, "48828125"), new leftCheat.ptr(4, "244140625"), new leftCheat.ptr(4, "1220703125"), new leftCheat.ptr(5, "6103515625"), new leftCheat.ptr(5, "30517578125"), new leftCheat.ptr(5, "152587890625"), new leftCheat.ptr(6, "762939453125"), new leftCheat.ptr(6, "3814697265625"), new leftCheat.ptr(6, "19073486328125"), new leftCheat.ptr(7, "95367431640625"), new leftCheat.ptr(7, "476837158203125"), new leftCheat.ptr(7, "2384185791015625"), new leftCheat.ptr(7, "11920928955078125"), new leftCheat.ptr(8, "59604644775390625"), new leftCheat.ptr(8, "298023223876953125"), new leftCheat.ptr(8, "1490116119384765625"), new leftCheat.ptr(9, "7450580596923828125"), new leftCheat.ptr(9, "37252902984619140625"), new leftCheat.ptr(9, "186264514923095703125"), new leftCheat.ptr(10, "931322574615478515625"), new leftCheat.ptr(10, "4656612873077392578125"), new leftCheat.ptr(10, "23283064365386962890625"), new leftCheat.ptr(10, "116415321826934814453125"), new leftCheat.ptr(11, "582076609134674072265625"), new leftCheat.ptr(11, "2910383045673370361328125"), new leftCheat.ptr(11, "14551915228366851806640625"), new leftCheat.ptr(12, "72759576141834259033203125"), new leftCheat.ptr(12, "363797880709171295166015625"), new leftCheat.ptr(12, "1818989403545856475830078125"), new leftCheat.ptr(13, "9094947017729282379150390625"), new leftCheat.ptr(13, "45474735088646411895751953125"), new leftCheat.ptr(13, "227373675443232059478759765625"), new leftCheat.ptr(13, "1136868377216160297393798828125"), new leftCheat.ptr(14, "5684341886080801486968994140625"), new leftCheat.ptr(14, "28421709430404007434844970703125"), new leftCheat.ptr(14, "142108547152020037174224853515625"), new leftCheat.ptr(15, "710542735760100185871124267578125"), new leftCheat.ptr(15, "3552713678800500929355621337890625"), new leftCheat.ptr(15, "17763568394002504646778106689453125"), new leftCheat.ptr(16, "88817841970012523233890533447265625"), new leftCheat.ptr(16, "444089209850062616169452667236328125"), new leftCheat.ptr(16, "2220446049250313080847263336181640625"), new leftCheat.ptr(16, "11102230246251565404236316680908203125"), new leftCheat.ptr(17, "55511151231257827021181583404541015625"), new leftCheat.ptr(17, "277555756156289135105907917022705078125"), new leftCheat.ptr(17, "1387778780781445675529539585113525390625"), new leftCheat.ptr(18, "6938893903907228377647697925567626953125"), new leftCheat.ptr(18, "34694469519536141888238489627838134765625"), new leftCheat.ptr(18, "173472347597680709441192448139190673828125"), new leftCheat.ptr(19, "867361737988403547205962240695953369140625")]);
		smallPowersOfTen = $toNativeArray($kindStruct, [new extFloat.ptr(new $Uint64(2147483648, 0), -63, false), new extFloat.ptr(new $Uint64(2684354560, 0), -60, false), new extFloat.ptr(new $Uint64(3355443200, 0), -57, false), new extFloat.ptr(new $Uint64(4194304000, 0), -54, false), new extFloat.ptr(new $Uint64(2621440000, 0), -50, false), new extFloat.ptr(new $Uint64(3276800000, 0), -47, false), new extFloat.ptr(new $Uint64(4096000000, 0), -44, false), new extFloat.ptr(new $Uint64(2560000000, 0), -40, false)]);
		powersOfTen = $toNativeArray($kindStruct, [new extFloat.ptr(new $Uint64(4203730336, 136053384), -1220, false), new extFloat.ptr(new $Uint64(3132023167, 2722021238), -1193, false), new extFloat.ptr(new $Uint64(2333539104, 810921078), -1166, false), new extFloat.ptr(new $Uint64(3477244234, 1573795306), -1140, false), new extFloat.ptr(new $Uint64(2590748842, 1432697645), -1113, false), new extFloat.ptr(new $Uint64(3860516611, 1025131999), -1087, false), new extFloat.ptr(new $Uint64(2876309015, 3348809418), -1060, false), new extFloat.ptr(new $Uint64(4286034428, 3200048207), -1034, false), new extFloat.ptr(new $Uint64(3193344495, 1097586188), -1007, false), new extFloat.ptr(new $Uint64(2379227053, 2424306748), -980, false), new extFloat.ptr(new $Uint64(3545324584, 827693699), -954, false), new extFloat.ptr(new $Uint64(2641472655, 2913388981), -927, false), new extFloat.ptr(new $Uint64(3936100983, 602835915), -901, false), new extFloat.ptr(new $Uint64(2932623761, 1081627501), -874, false), new extFloat.ptr(new $Uint64(2184974969, 1572261463), -847, false), new extFloat.ptr(new $Uint64(3255866422, 1308317239), -821, false), new extFloat.ptr(new $Uint64(2425809519, 944281679), -794, false), new extFloat.ptr(new $Uint64(3614737867, 629291719), -768, false), new extFloat.ptr(new $Uint64(2693189581, 2545915892), -741, false), new extFloat.ptr(new $Uint64(4013165208, 388672741), -715, false), new extFloat.ptr(new $Uint64(2990041083, 708162190), -688, false), new extFloat.ptr(new $Uint64(2227754207, 3536207675), -661, false), new extFloat.ptr(new $Uint64(3319612455, 450088378), -635, false), new extFloat.ptr(new $Uint64(2473304014, 3139815830), -608, false), new extFloat.ptr(new $Uint64(3685510180, 2103616900), -582, false), new extFloat.ptr(new $Uint64(2745919064, 224385782), -555, false), new extFloat.ptr(new $Uint64(4091738259, 3737383206), -529, false), new extFloat.ptr(new $Uint64(3048582568, 2868871352), -502, false), new extFloat.ptr(new $Uint64(2271371013, 1820084875), -475, false), new extFloat.ptr(new $Uint64(3384606560, 885076051), -449, false), new extFloat.ptr(new $Uint64(2521728396, 2444895829), -422, false), new extFloat.ptr(new $Uint64(3757668132, 1881767613), -396, false), new extFloat.ptr(new $Uint64(2799680927, 3102062735), -369, false), new extFloat.ptr(new $Uint64(4171849679, 2289335700), -343, false), new extFloat.ptr(new $Uint64(3108270227, 2410191823), -316, false), new extFloat.ptr(new $Uint64(2315841784, 3205436779), -289, false), new extFloat.ptr(new $Uint64(3450873173, 1697722806), -263, false), new extFloat.ptr(new $Uint64(2571100870, 3497754540), -236, false), new extFloat.ptr(new $Uint64(3831238852, 707476230), -210, false), new extFloat.ptr(new $Uint64(2854495385, 1769181907), -183, false), new extFloat.ptr(new $Uint64(4253529586, 2197867022), -157, false), new extFloat.ptr(new $Uint64(3169126500, 2450594539), -130, false), new extFloat.ptr(new $Uint64(2361183241, 1867548876), -103, false), new extFloat.ptr(new $Uint64(3518437208, 3793315116), -77, false), new extFloat.ptr(new $Uint64(2621440000, 0), -50, false), new extFloat.ptr(new $Uint64(3906250000, 0), -24, false), new extFloat.ptr(new $Uint64(2910383045, 2892103680), 3, false), new extFloat.ptr(new $Uint64(2168404344, 4170451332), 30, false), new extFloat.ptr(new $Uint64(3231174267, 3372684723), 56, false), new extFloat.ptr(new $Uint64(2407412430, 2078956656), 83, false), new extFloat.ptr(new $Uint64(3587324068, 2884206696), 109, false), new extFloat.ptr(new $Uint64(2672764710, 395977285), 136, false), new extFloat.ptr(new $Uint64(3982729777, 3569679143), 162, false), new extFloat.ptr(new $Uint64(2967364920, 2361961896), 189, false), new extFloat.ptr(new $Uint64(2210859150, 447440347), 216, false), new extFloat.ptr(new $Uint64(3294436857, 1114709402), 242, false), new extFloat.ptr(new $Uint64(2454546732, 2786846552), 269, false), new extFloat.ptr(new $Uint64(3657559652, 443583978), 295, false), new extFloat.ptr(new $Uint64(2725094297, 2599384906), 322, false), new extFloat.ptr(new $Uint64(4060706939, 3028118405), 348, false), new extFloat.ptr(new $Uint64(3025462433, 2044532855), 375, false), new extFloat.ptr(new $Uint64(2254145170, 1536935362), 402, false), new extFloat.ptr(new $Uint64(3358938053, 3365297469), 428, false), new extFloat.ptr(new $Uint64(2502603868, 4204241075), 455, false), new extFloat.ptr(new $Uint64(3729170365, 2577424355), 481, false), new extFloat.ptr(new $Uint64(2778448436, 3677981733), 508, false), new extFloat.ptr(new $Uint64(4140210802, 2744688476), 534, false), new extFloat.ptr(new $Uint64(3084697427, 1424604878), 561, false), new extFloat.ptr(new $Uint64(2298278679, 4062331362), 588, false), new extFloat.ptr(new $Uint64(3424702107, 3546052773), 614, false), new extFloat.ptr(new $Uint64(2551601907, 2065781727), 641, false), new extFloat.ptr(new $Uint64(3802183132, 2535403578), 667, false), new extFloat.ptr(new $Uint64(2832847187, 1558426518), 694, false), new extFloat.ptr(new $Uint64(4221271257, 2762425404), 720, false), new extFloat.ptr(new $Uint64(3145092172, 2812560400), 747, false), new extFloat.ptr(new $Uint64(2343276271, 3057687578), 774, false), new extFloat.ptr(new $Uint64(3491753744, 2790753324), 800, false), new extFloat.ptr(new $Uint64(2601559269, 3918606633), 827, false), new extFloat.ptr(new $Uint64(3876625403, 2711358621), 853, false), new extFloat.ptr(new $Uint64(2888311001, 1648096297), 880, false), new extFloat.ptr(new $Uint64(2151959390, 2057817989), 907, false), new extFloat.ptr(new $Uint64(3206669376, 61660461), 933, false), new extFloat.ptr(new $Uint64(2389154863, 1581580175), 960, false), new extFloat.ptr(new $Uint64(3560118173, 2626467905), 986, false), new extFloat.ptr(new $Uint64(2652494738, 3034782633), 1013, false), new extFloat.ptr(new $Uint64(3952525166, 3135207385), 1039, false), new extFloat.ptr(new $Uint64(2944860731, 2616258155), 1066, false)]);
		uint64pow10 = $toNativeArray($kindUint64, [new $Uint64(0, 1), new $Uint64(0, 10), new $Uint64(0, 100), new $Uint64(0, 1000), new $Uint64(0, 10000), new $Uint64(0, 100000), new $Uint64(0, 1000000), new $Uint64(0, 10000000), new $Uint64(0, 100000000), new $Uint64(0, 1000000000), new $Uint64(2, 1410065408), new $Uint64(23, 1215752192), new $Uint64(232, 3567587328), new $Uint64(2328, 1316134912), new $Uint64(23283, 276447232), new $Uint64(232830, 2764472320), new $Uint64(2328306, 1874919424), new $Uint64(23283064, 1569325056), new $Uint64(232830643, 2808348672), new $Uint64(2328306436, 2313682944)]);
		float32info = new floatInfo.ptr(23, 8, -127);
		float64info = new floatInfo.ptr(52, 11, -1023);
		isPrint16 = new sliceType$4([32, 126, 161, 887, 890, 895, 900, 1366, 1369, 1418, 1421, 1479, 1488, 1514, 1520, 1524, 1542, 1563, 1566, 1805, 1808, 1866, 1869, 1969, 1984, 2042, 2048, 2093, 2096, 2139, 2142, 2154, 2208, 2237, 2260, 2444, 2447, 2448, 2451, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2531, 2534, 2557, 2561, 2570, 2575, 2576, 2579, 2617, 2620, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2654, 2662, 2677, 2689, 2745, 2748, 2765, 2768, 2768, 2784, 2787, 2790, 2801, 2809, 2828, 2831, 2832, 2835, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2915, 2918, 2935, 2946, 2954, 2958, 2965, 2969, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3021, 3024, 3024, 3031, 3031, 3046, 3066, 3072, 3129, 3133, 3149, 3157, 3162, 3168, 3171, 3174, 3183, 3192, 3257, 3260, 3277, 3285, 3286, 3294, 3299, 3302, 3314, 3328, 3407, 3412, 3427, 3430, 3455, 3458, 3478, 3482, 3517, 3520, 3526, 3530, 3530, 3535, 3551, 3558, 3567, 3570, 3572, 3585, 3642, 3647, 3675, 3713, 3716, 3719, 3722, 3725, 3725, 3732, 3751, 3754, 3773, 3776, 3789, 3792, 3801, 3804, 3807, 3840, 3948, 3953, 4058, 4096, 4295, 4301, 4301, 4304, 4685, 4688, 4701, 4704, 4749, 4752, 4789, 4792, 4805, 4808, 4885, 4888, 4954, 4957, 4988, 4992, 5017, 5024, 5109, 5112, 5117, 5120, 5788, 5792, 5880, 5888, 5908, 5920, 5942, 5952, 5971, 5984, 6003, 6016, 6109, 6112, 6121, 6128, 6137, 6144, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6443, 6448, 6459, 6464, 6464, 6468, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6622, 6683, 6686, 6780, 6783, 6793, 6800, 6809, 6816, 6829, 6832, 6846, 6912, 6987, 6992, 7036, 7040, 7155, 7164, 7223, 7227, 7241, 7245, 7304, 7360, 7367, 7376, 7417, 7424, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8061, 8064, 8147, 8150, 8175, 8178, 8190, 8208, 8231, 8240, 8286, 8304, 8305, 8308, 8348, 8352, 8383, 8400, 8432, 8448, 8587, 8592, 9254, 9280, 9290, 9312, 11123, 11126, 11157, 11160, 11193, 11197, 11218, 11244, 11247, 11264, 11507, 11513, 11559, 11565, 11565, 11568, 11623, 11631, 11632, 11647, 11670, 11680, 11849, 11904, 12019, 12032, 12245, 12272, 12283, 12289, 12438, 12441, 12543, 12549, 12590, 12593, 12730, 12736, 12771, 12784, 19893, 19904, 40938, 40960, 42124, 42128, 42182, 42192, 42539, 42560, 42743, 42752, 42935, 42999, 43051, 43056, 43065, 43072, 43127, 43136, 43205, 43214, 43225, 43232, 43261, 43264, 43347, 43359, 43388, 43392, 43481, 43486, 43574, 43584, 43597, 43600, 43609, 43612, 43714, 43739, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43877, 43888, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64449, 64467, 64831, 64848, 64911, 64914, 64967, 65008, 65021, 65024, 65049, 65056, 65131, 65136, 65276, 65281, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65504, 65518, 65532, 65533]);
		isNotPrint16 = new sliceType$4([173, 907, 909, 930, 1328, 1376, 1416, 1424, 1757, 2111, 2143, 2229, 2274, 2436, 2473, 2481, 2526, 2564, 2601, 2609, 2612, 2615, 2621, 2653, 2692, 2702, 2706, 2729, 2737, 2740, 2758, 2762, 2816, 2820, 2857, 2865, 2868, 2910, 2948, 2961, 2971, 2973, 3017, 3076, 3085, 3089, 3113, 3141, 3145, 3159, 3204, 3213, 3217, 3241, 3252, 3269, 3273, 3295, 3312, 3332, 3341, 3345, 3397, 3401, 3460, 3506, 3516, 3541, 3543, 3715, 3721, 3736, 3744, 3748, 3750, 3756, 3770, 3781, 3783, 3912, 3992, 4029, 4045, 4294, 4681, 4695, 4697, 4745, 4785, 4799, 4801, 4823, 4881, 5760, 5901, 5997, 6001, 6431, 6751, 7674, 8024, 8026, 8028, 8030, 8117, 8133, 8156, 8181, 8335, 11209, 11311, 11359, 11558, 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, 11930, 12352, 12687, 12831, 13055, 42927, 43470, 43519, 43815, 43823, 64311, 64317, 64319, 64322, 64325, 65107, 65127, 65141, 65511]);
		isPrint32 = new sliceType$5([65536, 65613, 65616, 65629, 65664, 65786, 65792, 65794, 65799, 65843, 65847, 65947, 65952, 65952, 66000, 66045, 66176, 66204, 66208, 66256, 66272, 66299, 66304, 66339, 66349, 66378, 66384, 66426, 66432, 66499, 66504, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66927, 66927, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67640, 67644, 67644, 67647, 67742, 67751, 67759, 67808, 67829, 67835, 67867, 67871, 67897, 67903, 67903, 67968, 68023, 68028, 68047, 68050, 68102, 68108, 68147, 68152, 68154, 68159, 68167, 68176, 68184, 68192, 68255, 68288, 68326, 68331, 68342, 68352, 68405, 68409, 68437, 68440, 68466, 68472, 68497, 68505, 68508, 68521, 68527, 68608, 68680, 68736, 68786, 68800, 68850, 68858, 68863, 69216, 69246, 69632, 69709, 69714, 69743, 69759, 69825, 69840, 69864, 69872, 69881, 69888, 69955, 69968, 70006, 70016, 70093, 70096, 70132, 70144, 70206, 70272, 70313, 70320, 70378, 70384, 70393, 70400, 70412, 70415, 70416, 70419, 70457, 70460, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70749, 70784, 70855, 70864, 70873, 71040, 71093, 71096, 71133, 71168, 71236, 71248, 71257, 71264, 71276, 71296, 71351, 71360, 71369, 71424, 71449, 71453, 71467, 71472, 71487, 71840, 71922, 71935, 71935, 72192, 72263, 72272, 72323, 72326, 72354, 72384, 72440, 72704, 72773, 72784, 72812, 72816, 72847, 72850, 72886, 72960, 73014, 73018, 73031, 73040, 73049, 73728, 74649, 74752, 74868, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92777, 92782, 92783, 92880, 92909, 92912, 92917, 92928, 92997, 93008, 93047, 93053, 93071, 93952, 94020, 94032, 94078, 94095, 94111, 94176, 94177, 94208, 100332, 100352, 101106, 110592, 110878, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113820, 113823, 118784, 119029, 119040, 119078, 119081, 119154, 119163, 119272, 119296, 119365, 119552, 119638, 119648, 119665, 119808, 119967, 119970, 119970, 119973, 119974, 119977, 120074, 120077, 120134, 120138, 120485, 120488, 120779, 120782, 121483, 121499, 121519, 122880, 122904, 122907, 122922, 124928, 125124, 125127, 125142, 125184, 125258, 125264, 125273, 125278, 125279, 126464, 126500, 126503, 126523, 126530, 126530, 126535, 126548, 126551, 126564, 126567, 126619, 126625, 126651, 126704, 126705, 126976, 127019, 127024, 127123, 127136, 127150, 127153, 127221, 127232, 127244, 127248, 127339, 127344, 127404, 127462, 127490, 127504, 127547, 127552, 127560, 127568, 127569, 127584, 127589, 127744, 128724, 128736, 128748, 128752, 128760, 128768, 128883, 128896, 128980, 129024, 129035, 129040, 129095, 129104, 129113, 129120, 129159, 129168, 129197, 129280, 129291, 129296, 129356, 129360, 129387, 129408, 129431, 129472, 129472, 129488, 129510, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 917760, 917999]);
		isNotPrint32 = new sliceType$4([12, 39, 59, 62, 399, 926, 2057, 2102, 2134, 2291, 2564, 2580, 2584, 4285, 4405, 4576, 4626, 4743, 4745, 4750, 4766, 4868, 4905, 4913, 4916, 5210, 5212, 6813, 7177, 7223, 7336, 7431, 7434, 7483, 7486, 9327, 27231, 27482, 27490, 54357, 54429, 54445, 54458, 54460, 54468, 54534, 54549, 54557, 54586, 54591, 54597, 54609, 55968, 57351, 57378, 57381, 60932, 60960, 60963, 60968, 60979, 60984, 60986, 61000, 61002, 61004, 61008, 61011, 61016, 61018, 61020, 61022, 61024, 61027, 61035, 61043, 61048, 61053, 61055, 61066, 61092, 61098, 61632, 61648, 61743, 63807]);
		isGraphic = new sliceType$4([160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["reflect"] = (function() {
	var $pkg = {}, $init, errors, js, math, runtime, strconv, sync, unicode, utf8, uncommonType, funcType, name, nameData, mapIter, Type, Kind, tflag, rtype, typeAlg, method, ChanDir, arrayType, chanType, imethod, interfaceType, mapType, ptrType, sliceType, structField, structType, Method, nameOff, typeOff, textOff, StructField, StructTag, fieldScan, Value, flag, ValueError, MapIter, sliceType$1, ptrType$1, sliceType$2, sliceType$3, ptrType$2, funcType$1, sliceType$4, ptrType$3, ptrType$4, sliceType$5, sliceType$6, sliceType$7, ptrType$5, ptrType$6, structType$3, sliceType$8, sliceType$9, ptrType$7, sliceType$10, sliceType$11, ptrType$8, ptrType$9, ptrType$10, sliceType$13, sliceType$14, ptrType$11, sliceType$15, ptrType$17, sliceType$18, funcType$3, funcType$4, funcType$5, ptrType$18, arrayType$8, ptrType$19, ptrType$20, initialized, uncommonTypeMap, nameMap, nameOffList, typeOffList, callHelper, jsObjectPtr, selectHelper, kindNames, uint8Type, init, jsType, reflectType, setKindType, newName, newNameOff, newTypeOff, internalStr, isWrapped, copyStruct, makeValue, MakeSlice, TypeOf, ValueOf, FuncOf, SliceOf, Zero, unsafe_New, makeInt, typedmemmove, keyFor, mapaccess, mapassign, mapdelete, mapiterinit, mapiterkey, mapitervalue, mapiternext, maplen, cvtDirect, valueInterface, ifaceE2I, methodName, makeMethodValue, wrapJsObject, unwrapJsObject, getJsTag, chanrecv, chansend, methodReceiver, PtrTo, implements$1, directlyAssignable, haveIdenticalType, haveIdenticalUnderlyingType, toType, ifaceIndir, copyVal, overflowFloat32, New, convertOp, makeFloat, makeComplex, makeString, makeBytes, makeRunes, cvtInt, cvtUint, cvtFloatInt, cvtFloatUint, cvtIntFloat, cvtUintFloat, cvtFloat, cvtComplex, cvtIntString, cvtUintString, cvtBytesString, cvtStringBytes, cvtRunesString, cvtStringRunes, cvtT2I, cvtI2I;
	errors = $packages["errors"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	math = $packages["math"];
	runtime = $packages["runtime"];
	strconv = $packages["strconv"];
	sync = $packages["sync"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	uncommonType = $pkg.uncommonType = $newType(0, $kindStruct, "reflect.uncommonType", true, "reflect", false, function(pkgPath_, mcount_, xcount_, moff_, _methods_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.pkgPath = 0;
			this.mcount = 0;
			this.xcount = 0;
			this.moff = 0;
			this._methods = sliceType$5.nil;
			return;
		}
		this.pkgPath = pkgPath_;
		this.mcount = mcount_;
		this.xcount = xcount_;
		this.moff = moff_;
		this._methods = _methods_;
	});
	funcType = $pkg.funcType = $newType(0, $kindStruct, "reflect.funcType", true, "reflect", false, function(rtype_, inCount_, outCount_, _in_, _out_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.inCount = 0;
			this.outCount = 0;
			this._in = sliceType$2.nil;
			this._out = sliceType$2.nil;
			return;
		}
		this.rtype = rtype_;
		this.inCount = inCount_;
		this.outCount = outCount_;
		this._in = _in_;
		this._out = _out_;
	});
	name = $pkg.name = $newType(0, $kindStruct, "reflect.name", true, "reflect", false, function(bytes_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.bytes = ptrType$4.nil;
			return;
		}
		this.bytes = bytes_;
	});
	nameData = $pkg.nameData = $newType(0, $kindStruct, "reflect.nameData", true, "reflect", false, function(name_, tag_, exported_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = "";
			this.tag = "";
			this.exported = false;
			return;
		}
		this.name = name_;
		this.tag = tag_;
		this.exported = exported_;
	});
	mapIter = $pkg.mapIter = $newType(0, $kindStruct, "reflect.mapIter", true, "reflect", false, function(t_, m_, keys_, i_, last_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.t = $ifaceNil;
			this.m = null;
			this.keys = null;
			this.i = 0;
			this.last = null;
			return;
		}
		this.t = t_;
		this.m = m_;
		this.keys = keys_;
		this.i = i_;
		this.last = last_;
	});
	Type = $pkg.Type = $newType(8, $kindInterface, "reflect.Type", true, "reflect", true, null);
	Kind = $pkg.Kind = $newType(4, $kindUint, "reflect.Kind", true, "reflect", true, null);
	tflag = $pkg.tflag = $newType(1, $kindUint8, "reflect.tflag", true, "reflect", false, null);
	rtype = $pkg.rtype = $newType(0, $kindStruct, "reflect.rtype", true, "reflect", false, function(size_, ptrdata_, hash_, tflag_, align_, fieldAlign_, kind_, alg_, gcdata_, str_, ptrToThis_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.size = 0;
			this.ptrdata = 0;
			this.hash = 0;
			this.tflag = 0;
			this.align = 0;
			this.fieldAlign = 0;
			this.kind = 0;
			this.alg = ptrType$3.nil;
			this.gcdata = ptrType$4.nil;
			this.str = 0;
			this.ptrToThis = 0;
			return;
		}
		this.size = size_;
		this.ptrdata = ptrdata_;
		this.hash = hash_;
		this.tflag = tflag_;
		this.align = align_;
		this.fieldAlign = fieldAlign_;
		this.kind = kind_;
		this.alg = alg_;
		this.gcdata = gcdata_;
		this.str = str_;
		this.ptrToThis = ptrToThis_;
	});
	typeAlg = $pkg.typeAlg = $newType(0, $kindStruct, "reflect.typeAlg", true, "reflect", false, function(hash_, equal_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.hash = $throwNilPointerError;
			this.equal = $throwNilPointerError;
			return;
		}
		this.hash = hash_;
		this.equal = equal_;
	});
	method = $pkg.method = $newType(0, $kindStruct, "reflect.method", true, "reflect", false, function(name_, mtyp_, ifn_, tfn_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = 0;
			this.mtyp = 0;
			this.ifn = 0;
			this.tfn = 0;
			return;
		}
		this.name = name_;
		this.mtyp = mtyp_;
		this.ifn = ifn_;
		this.tfn = tfn_;
	});
	ChanDir = $pkg.ChanDir = $newType(4, $kindInt, "reflect.ChanDir", true, "reflect", true, null);
	arrayType = $pkg.arrayType = $newType(0, $kindStruct, "reflect.arrayType", true, "reflect", false, function(rtype_, elem_, slice_, len_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.elem = ptrType$1.nil;
			this.slice = ptrType$1.nil;
			this.len = 0;
			return;
		}
		this.rtype = rtype_;
		this.elem = elem_;
		this.slice = slice_;
		this.len = len_;
	});
	chanType = $pkg.chanType = $newType(0, $kindStruct, "reflect.chanType", true, "reflect", false, function(rtype_, elem_, dir_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.elem = ptrType$1.nil;
			this.dir = 0;
			return;
		}
		this.rtype = rtype_;
		this.elem = elem_;
		this.dir = dir_;
	});
	imethod = $pkg.imethod = $newType(0, $kindStruct, "reflect.imethod", true, "reflect", false, function(name_, typ_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = 0;
			this.typ = 0;
			return;
		}
		this.name = name_;
		this.typ = typ_;
	});
	interfaceType = $pkg.interfaceType = $newType(0, $kindStruct, "reflect.interfaceType", true, "reflect", false, function(rtype_, pkgPath_, methods_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.pkgPath = new name.ptr(ptrType$4.nil);
			this.methods = sliceType$6.nil;
			return;
		}
		this.rtype = rtype_;
		this.pkgPath = pkgPath_;
		this.methods = methods_;
	});
	mapType = $pkg.mapType = $newType(0, $kindStruct, "reflect.mapType", true, "reflect", false, function(rtype_, key_, elem_, bucket_, keysize_, valuesize_, bucketsize_, flags_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.key = ptrType$1.nil;
			this.elem = ptrType$1.nil;
			this.bucket = ptrType$1.nil;
			this.keysize = 0;
			this.valuesize = 0;
			this.bucketsize = 0;
			this.flags = 0;
			return;
		}
		this.rtype = rtype_;
		this.key = key_;
		this.elem = elem_;
		this.bucket = bucket_;
		this.keysize = keysize_;
		this.valuesize = valuesize_;
		this.bucketsize = bucketsize_;
		this.flags = flags_;
	});
	ptrType = $pkg.ptrType = $newType(0, $kindStruct, "reflect.ptrType", true, "reflect", false, function(rtype_, elem_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.elem = ptrType$1.nil;
			return;
		}
		this.rtype = rtype_;
		this.elem = elem_;
	});
	sliceType = $pkg.sliceType = $newType(0, $kindStruct, "reflect.sliceType", true, "reflect", false, function(rtype_, elem_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.elem = ptrType$1.nil;
			return;
		}
		this.rtype = rtype_;
		this.elem = elem_;
	});
	structField = $pkg.structField = $newType(0, $kindStruct, "reflect.structField", true, "reflect", false, function(name_, typ_, offsetEmbed_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = new name.ptr(ptrType$4.nil);
			this.typ = ptrType$1.nil;
			this.offsetEmbed = 0;
			return;
		}
		this.name = name_;
		this.typ = typ_;
		this.offsetEmbed = offsetEmbed_;
	});
	structType = $pkg.structType = $newType(0, $kindStruct, "reflect.structType", true, "reflect", false, function(rtype_, pkgPath_, fields_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
			this.pkgPath = new name.ptr(ptrType$4.nil);
			this.fields = sliceType$7.nil;
			return;
		}
		this.rtype = rtype_;
		this.pkgPath = pkgPath_;
		this.fields = fields_;
	});
	Method = $pkg.Method = $newType(0, $kindStruct, "reflect.Method", true, "reflect", true, function(Name_, PkgPath_, Type_, Func_, Index_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = "";
			this.PkgPath = "";
			this.Type = $ifaceNil;
			this.Func = new Value.ptr(ptrType$1.nil, 0, 0);
			this.Index = 0;
			return;
		}
		this.Name = Name_;
		this.PkgPath = PkgPath_;
		this.Type = Type_;
		this.Func = Func_;
		this.Index = Index_;
	});
	nameOff = $pkg.nameOff = $newType(4, $kindInt32, "reflect.nameOff", true, "reflect", false, null);
	typeOff = $pkg.typeOff = $newType(4, $kindInt32, "reflect.typeOff", true, "reflect", false, null);
	textOff = $pkg.textOff = $newType(4, $kindInt32, "reflect.textOff", true, "reflect", false, null);
	StructField = $pkg.StructField = $newType(0, $kindStruct, "reflect.StructField", true, "reflect", true, function(Name_, PkgPath_, Type_, Tag_, Offset_, Index_, Anonymous_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = "";
			this.PkgPath = "";
			this.Type = $ifaceNil;
			this.Tag = "";
			this.Offset = 0;
			this.Index = sliceType$13.nil;
			this.Anonymous = false;
			return;
		}
		this.Name = Name_;
		this.PkgPath = PkgPath_;
		this.Type = Type_;
		this.Tag = Tag_;
		this.Offset = Offset_;
		this.Index = Index_;
		this.Anonymous = Anonymous_;
	});
	StructTag = $pkg.StructTag = $newType(8, $kindString, "reflect.StructTag", true, "reflect", true, null);
	fieldScan = $pkg.fieldScan = $newType(0, $kindStruct, "reflect.fieldScan", true, "reflect", false, function(typ_, index_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.typ = ptrType$11.nil;
			this.index = sliceType$13.nil;
			return;
		}
		this.typ = typ_;
		this.index = index_;
	});
	Value = $pkg.Value = $newType(0, $kindStruct, "reflect.Value", true, "reflect", true, function(typ_, ptr_, flag_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.typ = ptrType$1.nil;
			this.ptr = 0;
			this.flag = 0;
			return;
		}
		this.typ = typ_;
		this.ptr = ptr_;
		this.flag = flag_;
	});
	flag = $pkg.flag = $newType(4, $kindUintptr, "reflect.flag", true, "reflect", false, null);
	ValueError = $pkg.ValueError = $newType(0, $kindStruct, "reflect.ValueError", true, "reflect", true, function(Method_, Kind_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Method = "";
			this.Kind = 0;
			return;
		}
		this.Method = Method_;
		this.Kind = Kind_;
	});
	MapIter = $pkg.MapIter = $newType(0, $kindStruct, "reflect.MapIter", true, "reflect", true, function(m_, it_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.m = new Value.ptr(ptrType$1.nil, 0, 0);
			this.it = 0;
			return;
		}
		this.m = m_;
		this.it = it_;
	});
	sliceType$1 = $sliceType(name);
	ptrType$1 = $ptrType(rtype);
	sliceType$2 = $sliceType(ptrType$1);
	sliceType$3 = $sliceType($emptyInterface);
	ptrType$2 = $ptrType(js.Object);
	funcType$1 = $funcType([sliceType$3], [ptrType$2], true);
	sliceType$4 = $sliceType($String);
	ptrType$3 = $ptrType(typeAlg);
	ptrType$4 = $ptrType($Uint8);
	sliceType$5 = $sliceType(method);
	sliceType$6 = $sliceType(imethod);
	sliceType$7 = $sliceType(structField);
	ptrType$5 = $ptrType(uncommonType);
	ptrType$6 = $ptrType(nameData);
	structType$3 = $structType("reflect", [{prop: "str", name: "str", embedded: false, exported: false, typ: $String, tag: ""}]);
	sliceType$8 = $sliceType(ptrType$2);
	sliceType$9 = $sliceType(Value);
	ptrType$7 = $ptrType(mapIter);
	sliceType$10 = $sliceType(Type);
	sliceType$11 = $sliceType(sliceType$8);
	ptrType$8 = $ptrType(funcType);
	ptrType$9 = $ptrType(interfaceType);
	ptrType$10 = $ptrType(imethod);
	sliceType$13 = $sliceType($Int);
	sliceType$14 = $sliceType(fieldScan);
	ptrType$11 = $ptrType(structType);
	sliceType$15 = $sliceType($Uint8);
	ptrType$17 = $ptrType($UnsafePointer);
	sliceType$18 = $sliceType($Int32);
	funcType$3 = $funcType([$String], [$Bool], false);
	funcType$4 = $funcType([$UnsafePointer, $Uintptr], [$Uintptr], false);
	funcType$5 = $funcType([$UnsafePointer, $UnsafePointer], [$Bool], false);
	ptrType$18 = $ptrType(structField);
	arrayType$8 = $arrayType($Uintptr, 2);
	ptrType$19 = $ptrType(MapIter);
	ptrType$20 = $ptrType(ValueError);
	init = function() {
		var used, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; used = $f.used; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		used = (function(i) {
			var i;
		});
		$r = used((x = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), new x.constructor.elem(x))); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$1 = new uncommonType.ptr(0, 0, 0, 0, sliceType$5.nil), new x$1.constructor.elem(x$1))); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$2 = new method.ptr(0, 0, 0, 0), new x$2.constructor.elem(x$2))); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$3 = new arrayType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), ptrType$1.nil, ptrType$1.nil, 0), new x$3.constructor.elem(x$3))); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$4 = new chanType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), ptrType$1.nil, 0), new x$4.constructor.elem(x$4))); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$5 = new funcType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), 0, 0, sliceType$2.nil, sliceType$2.nil), new x$5.constructor.elem(x$5))); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$6 = new interfaceType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), new name.ptr(ptrType$4.nil), sliceType$6.nil), new x$6.constructor.elem(x$6))); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$7 = new mapType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, 0, 0, 0, 0), new x$7.constructor.elem(x$7))); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$8 = new ptrType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), ptrType$1.nil), new x$8.constructor.elem(x$8))); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$9 = new sliceType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), ptrType$1.nil), new x$9.constructor.elem(x$9))); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$10 = new structType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), new name.ptr(ptrType$4.nil), sliceType$7.nil), new x$10.constructor.elem(x$10))); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$11 = new imethod.ptr(0, 0), new x$11.constructor.elem(x$11))); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = used((x$12 = new structField.ptr(new name.ptr(ptrType$4.nil), ptrType$1.nil, 0), new x$12.constructor.elem(x$12))); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		initialized = true;
		uint8Type = $assertType(TypeOf(new $Uint8(0)), ptrType$1);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f.used = used; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	jsType = function(typ) {
		var typ;
		return typ.jsType;
	};
	reflectType = function(typ) {
		var _1, _i, _i$1, _i$2, _i$3, _key, _ref, _ref$1, _ref$2, _ref$3, dir, exported, exported$1, f, fields, i, i$1, i$2, i$3, i$4, i$5, imethods, in$1, m, m$1, m$2, methodSet, methods, offsetEmbed, out, outCount, params, reflectFields, reflectMethods, results, rt, typ, ut, xcount;
		if (typ.reflectType === undefined) {
			rt = new rtype.ptr(((($parseInt(typ.size) >> 0) >>> 0)), 0, 0, 0, 0, 0, ((($parseInt(typ.kind) >> 0) << 24 >>> 24)), ptrType$3.nil, ptrType$4.nil, newNameOff($clone(newName(internalStr(typ.string), "", !!(typ.exported)), name)), 0);
			rt.jsType = typ;
			typ.reflectType = rt;
			methodSet = $methodSet(typ);
			if (!(($parseInt(methodSet.length) === 0)) || !!(typ.named)) {
				rt.tflag = (rt.tflag | (1)) >>> 0;
				if (!!(typ.named)) {
					rt.tflag = (rt.tflag | (4)) >>> 0;
				}
				reflectMethods = sliceType$5.nil;
				i = 0;
				while (true) {
					if (!(i < $parseInt(methodSet.length))) { break; }
					m = methodSet[i];
					exported = internalStr(m.pkg) === "";
					if (!exported) {
						i = i + (1) >> 0;
						continue;
					}
					reflectMethods = $append(reflectMethods, new method.ptr(newNameOff($clone(newName(internalStr(m.name), "", exported), name)), newTypeOff(reflectType(m.typ)), 0, 0));
					i = i + (1) >> 0;
				}
				xcount = ((reflectMethods.$length << 16 >>> 16));
				i$1 = 0;
				while (true) {
					if (!(i$1 < $parseInt(methodSet.length))) { break; }
					m$1 = methodSet[i$1];
					exported$1 = internalStr(m$1.pkg) === "";
					if (exported$1) {
						i$1 = i$1 + (1) >> 0;
						continue;
					}
					reflectMethods = $append(reflectMethods, new method.ptr(newNameOff($clone(newName(internalStr(m$1.name), "", exported$1), name)), newTypeOff(reflectType(m$1.typ)), 0, 0));
					i$1 = i$1 + (1) >> 0;
				}
				ut = new uncommonType.ptr(newNameOff($clone(newName(internalStr(typ.pkg), "", false), name)), (($parseInt(methodSet.length) << 16 >>> 16)), xcount, 0, reflectMethods);
				_key = rt; (uncommonTypeMap || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: ut };
				ut.jsType = typ;
			}
			_1 = rt.Kind();
			if (_1 === (17)) {
				setKindType(rt, new arrayType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), reflectType(typ.elem), ptrType$1.nil, ((($parseInt(typ.len) >> 0) >>> 0))));
			} else if (_1 === (18)) {
				dir = 3;
				if (!!(typ.sendOnly)) {
					dir = 2;
				}
				if (!!(typ.recvOnly)) {
					dir = 1;
				}
				setKindType(rt, new chanType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), reflectType(typ.elem), ((dir >>> 0))));
			} else if (_1 === (19)) {
				params = typ.params;
				in$1 = $makeSlice(sliceType$2, $parseInt(params.length));
				_ref = in$1;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					i$2 = _i;
					((i$2 < 0 || i$2 >= in$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : in$1.$array[in$1.$offset + i$2] = reflectType(params[i$2]));
					_i++;
				}
				results = typ.results;
				out = $makeSlice(sliceType$2, $parseInt(results.length));
				_ref$1 = out;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					i$3 = _i$1;
					((i$3 < 0 || i$3 >= out.$length) ? ($throwRuntimeError("index out of range"), undefined) : out.$array[out.$offset + i$3] = reflectType(results[i$3]));
					_i$1++;
				}
				outCount = (($parseInt(results.length) << 16 >>> 16));
				if (!!(typ.variadic)) {
					outCount = (outCount | (32768)) >>> 0;
				}
				setKindType(rt, new funcType.ptr($clone(rt, rtype), (($parseInt(params.length) << 16 >>> 16)), outCount, in$1, out));
			} else if (_1 === (20)) {
				methods = typ.methods;
				imethods = $makeSlice(sliceType$6, $parseInt(methods.length));
				_ref$2 = imethods;
				_i$2 = 0;
				while (true) {
					if (!(_i$2 < _ref$2.$length)) { break; }
					i$4 = _i$2;
					m$2 = methods[i$4];
					imethod.copy(((i$4 < 0 || i$4 >= imethods.$length) ? ($throwRuntimeError("index out of range"), undefined) : imethods.$array[imethods.$offset + i$4]), new imethod.ptr(newNameOff($clone(newName(internalStr(m$2.name), "", internalStr(m$2.pkg) === ""), name)), newTypeOff(reflectType(m$2.typ))));
					_i$2++;
				}
				setKindType(rt, new interfaceType.ptr($clone(rt, rtype), $clone(newName(internalStr(typ.pkg), "", false), name), imethods));
			} else if (_1 === (21)) {
				setKindType(rt, new mapType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), reflectType(typ.key), reflectType(typ.elem), ptrType$1.nil, 0, 0, 0, 0));
			} else if (_1 === (22)) {
				setKindType(rt, new ptrType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), reflectType(typ.elem)));
			} else if (_1 === (23)) {
				setKindType(rt, new sliceType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0), reflectType(typ.elem)));
			} else if (_1 === (25)) {
				fields = typ.fields;
				reflectFields = $makeSlice(sliceType$7, $parseInt(fields.length));
				_ref$3 = reflectFields;
				_i$3 = 0;
				while (true) {
					if (!(_i$3 < _ref$3.$length)) { break; }
					i$5 = _i$3;
					f = fields[i$5];
					offsetEmbed = ((i$5 >>> 0)) << 1 >>> 0;
					if (!!(f.embedded)) {
						offsetEmbed = (offsetEmbed | (1)) >>> 0;
					}
					structField.copy(((i$5 < 0 || i$5 >= reflectFields.$length) ? ($throwRuntimeError("index out of range"), undefined) : reflectFields.$array[reflectFields.$offset + i$5]), new structField.ptr($clone(newName(internalStr(f.name), internalStr(f.tag), !!(f.exported)), name), reflectType(f.typ), offsetEmbed));
					_i$3++;
				}
				setKindType(rt, new structType.ptr($clone(rt, rtype), $clone(newName(internalStr(typ.pkgPath), "", false), name), reflectFields));
			}
		}
		return ((typ.reflectType));
	};
	setKindType = function(rt, kindType) {
		var kindType, rt;
		rt.kindType = kindType;
		kindType.rtype = rt;
	};
	uncommonType.ptr.prototype.methods = function() {
		var t;
		t = this;
		return t._methods;
	};
	uncommonType.prototype.methods = function() { return this.$val.methods(); };
	uncommonType.ptr.prototype.exportedMethods = function() {
		var t;
		t = this;
		return $subslice(t._methods, 0, t.xcount, t.xcount);
	};
	uncommonType.prototype.exportedMethods = function() { return this.$val.exportedMethods(); };
	rtype.ptr.prototype.uncommon = function() {
		var _entry, t;
		t = this;
		return (_entry = uncommonTypeMap[ptrType$1.keyFor(t)], _entry !== undefined ? _entry.v : ptrType$5.nil);
	};
	rtype.prototype.uncommon = function() { return this.$val.uncommon(); };
	funcType.ptr.prototype.in$ = function() {
		var t;
		t = this;
		return t._in;
	};
	funcType.prototype.in$ = function() { return this.$val.in$(); };
	funcType.ptr.prototype.out = function() {
		var t;
		t = this;
		return t._out;
	};
	funcType.prototype.out = function() { return this.$val.out(); };
	name.ptr.prototype.name = function() {
		var _entry, n, s;
		s = "";
		n = this;
		s = (_entry = nameMap[ptrType$4.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$6.nil).name;
		return s;
	};
	name.prototype.name = function() { return this.$val.name(); };
	name.ptr.prototype.tag = function() {
		var _entry, n, s;
		s = "";
		n = this;
		s = (_entry = nameMap[ptrType$4.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$6.nil).tag;
		return s;
	};
	name.prototype.tag = function() { return this.$val.tag(); };
	name.ptr.prototype.pkgPath = function() {
		var n;
		n = this;
		return "";
	};
	name.prototype.pkgPath = function() { return this.$val.pkgPath(); };
	name.ptr.prototype.isExported = function() {
		var _entry, n;
		n = this;
		return (_entry = nameMap[ptrType$4.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$6.nil).exported;
	};
	name.prototype.isExported = function() { return this.$val.isExported(); };
	newName = function(n, tag, exported) {
		var _key, b, exported, n, tag;
		b = $newDataPointer(0, ptrType$4);
		_key = b; (nameMap || $throwRuntimeError("assignment to entry in nil map"))[ptrType$4.keyFor(_key)] = { k: _key, v: new nameData.ptr(n, tag, exported) };
		return new name.ptr(b);
	};
	rtype.ptr.prototype.nameOff = function(off) {
		var off, t, x;
		t = this;
		return (x = ((off >> 0)), ((x < 0 || x >= nameOffList.$length) ? ($throwRuntimeError("index out of range"), undefined) : nameOffList.$array[nameOffList.$offset + x]));
	};
	rtype.prototype.nameOff = function(off) { return this.$val.nameOff(off); };
	newNameOff = function(n) {
		var i, n;
		i = nameOffList.$length;
		nameOffList = $append(nameOffList, n);
		return ((i >> 0));
	};
	rtype.ptr.prototype.typeOff = function(off) {
		var off, t, x;
		t = this;
		return (x = ((off >> 0)), ((x < 0 || x >= typeOffList.$length) ? ($throwRuntimeError("index out of range"), undefined) : typeOffList.$array[typeOffList.$offset + x]));
	};
	rtype.prototype.typeOff = function(off) { return this.$val.typeOff(off); };
	newTypeOff = function(t) {
		var i, t;
		i = typeOffList.$length;
		typeOffList = $append(typeOffList, t);
		return ((i >> 0));
	};
	internalStr = function(strObj) {
		var c, strObj;
		c = new structType$3.ptr("");
		c.str = strObj;
		return c.str;
	};
	isWrapped = function(typ) {
		var typ;
		return !!(jsType(typ).wrapped);
	};
	copyStruct = function(dst, src, typ) {
		var dst, fields, i, prop, src, typ;
		fields = jsType(typ).fields;
		i = 0;
		while (true) {
			if (!(i < $parseInt(fields.length))) { break; }
			prop = $internalize(fields[i].prop, $String);
			dst[$externalize(prop, $String)] = src[$externalize(prop, $String)];
			i = i + (1) >> 0;
		}
	};
	makeValue = function(t, v, fl) {
		var _r, _r$1, _r$2, _r$3, _r$4, _r$5, _v, _v$1, fl, rt, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _v = $f._v; _v$1 = $f._v$1; fl = $f.fl; rt = $f.rt; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		rt = _r;
		_r$1 = t.Kind(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		if (_r$1 === 17) { _v$1 = true; $s = 5; continue s; }
		_r$2 = t.Kind(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_v$1 = _r$2 === 25; case 5:
		if (_v$1) { _v = true; $s = 4; continue s; }
		_r$3 = t.Kind(); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_v = _r$3 === 22; case 4:
		/* */ if (_v) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (_v) { */ case 2:
			_r$4 = t.Kind(); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			$s = -1; return new Value.ptr(rt, (v), (fl | ((_r$4 >>> 0))) >>> 0);
		/* } */ case 3:
		_r$5 = t.Kind(); /* */ $s = 10; case 10: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		$s = -1; return new Value.ptr(rt, ($newDataPointer(v, jsType(rt.ptrTo()))), (((fl | ((_r$5 >>> 0))) >>> 0) | 128) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeValue }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._v = _v; $f._v$1 = _v$1; $f.fl = fl; $f.rt = rt; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	MakeSlice = function(typ, len, cap) {
		var _r, _r$1, cap, len, typ, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; cap = $f.cap; len = $f.len; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		typ = [typ];
		_r = typ[0].Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 23))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 23))) { */ case 1:
			$panic(new $String("reflect.MakeSlice of non-slice type"));
		/* } */ case 2:
		if (len < 0) {
			$panic(new $String("reflect.MakeSlice: negative len"));
		}
		if (cap < 0) {
			$panic(new $String("reflect.MakeSlice: negative cap"));
		}
		if (len > cap) {
			$panic(new $String("reflect.MakeSlice: len > cap"));
		}
		_r$1 = makeValue(typ[0], $makeSlice(jsType(typ[0]), len, cap, (function(typ) { return function $b() {
			var _r$1, _r$2, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r$1 = typ[0].Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$2 = jsType(_r$1); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			$s = -1; return _r$2.zero();
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f.$s = $s; $f.$r = $r; return $f;
		}; })(typ)), 0); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MakeSlice }; } $f._r = _r; $f._r$1 = _r$1; $f.cap = cap; $f.len = len; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MakeSlice = MakeSlice;
	TypeOf = function(i) {
		var i;
		if (!initialized) {
			return new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$3.nil, ptrType$4.nil, 0, 0);
		}
		if ($interfaceIsEqual(i, $ifaceNil)) {
			return $ifaceNil;
		}
		return reflectType(i.constructor);
	};
	$pkg.TypeOf = TypeOf;
	ValueOf = function(i) {
		var _r, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if ($interfaceIsEqual(i, $ifaceNil)) {
			$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		}
		_r = makeValue(reflectType(i.constructor), i.$val, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ValueOf }; } $f._r = _r; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ValueOf = ValueOf;
	FuncOf = function(in$1, out, variadic) {
		var _i, _i$1, _r, _ref, _ref$1, _v, _v$1, i, i$1, in$1, jsIn, jsOut, out, v, v$1, variadic, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; _v = $f._v; _v$1 = $f._v$1; i = $f.i; i$1 = $f.i$1; in$1 = $f.in$1; jsIn = $f.jsIn; jsOut = $f.jsOut; out = $f.out; v = $f.v; v$1 = $f.v$1; variadic = $f.variadic; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (!(variadic)) { _v = false; $s = 3; continue s; }
		if (in$1.$length === 0) { _v$1 = true; $s = 4; continue s; }
		_r = (x = in$1.$length - 1 >> 0, ((x < 0 || x >= in$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : in$1.$array[in$1.$offset + x])).Kind(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_v$1 = !((_r === 23)); case 4:
		_v = _v$1; case 3:
		/* */ if (_v) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_v) { */ case 1:
			$panic(new $String("reflect.FuncOf: last arg of variadic func must be slice"));
		/* } */ case 2:
		jsIn = $makeSlice(sliceType$8, in$1.$length);
		_ref = in$1;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			v = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			((i < 0 || i >= jsIn.$length) ? ($throwRuntimeError("index out of range"), undefined) : jsIn.$array[jsIn.$offset + i] = jsType(v));
			_i++;
		}
		jsOut = $makeSlice(sliceType$8, out.$length);
		_ref$1 = out;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			v$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			((i$1 < 0 || i$1 >= jsOut.$length) ? ($throwRuntimeError("index out of range"), undefined) : jsOut.$array[jsOut.$offset + i$1] = jsType(v$1));
			_i$1++;
		}
		$s = -1; return reflectType($funcType($externalize(jsIn, sliceType$8), $externalize(jsOut, sliceType$8), $externalize(variadic, $Bool)));
		/* */ } return; } if ($f === undefined) { $f = { $blk: FuncOf }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f._v = _v; $f._v$1 = _v$1; $f.i = i; $f.i$1 = i$1; $f.in$1 = in$1; $f.jsIn = jsIn; $f.jsOut = jsOut; $f.out = out; $f.v = v; $f.v$1 = v$1; $f.variadic = variadic; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.FuncOf = FuncOf;
	rtype.ptr.prototype.ptrTo = function() {
		var t;
		t = this;
		return reflectType($ptrType(jsType(t)));
	};
	rtype.prototype.ptrTo = function() { return this.$val.ptrTo(); };
	SliceOf = function(t) {
		var t;
		return reflectType($sliceType(jsType(t)));
	};
	$pkg.SliceOf = SliceOf;
	Zero = function(typ) {
		var _r, typ, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeValue(typ, jsType(typ).zero(), 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Zero }; } $f._r = _r; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Zero = Zero;
	unsafe_New = function(typ) {
		var _1, typ;
		_1 = typ.Kind();
		if (_1 === (25)) {
			return (new (jsType(typ).ptr)());
		} else if (_1 === (17)) {
			return (jsType(typ).zero());
		} else {
			return ($newDataPointer(jsType(typ).zero(), jsType(typ.ptrTo())));
		}
	};
	makeInt = function(f, bits, t) {
		var _1, _r, bits, f, ptr, t, typ, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; bits = $f.bits; f = $f.f; ptr = $f.ptr; t = $f.t; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		typ = _r;
		ptr = unsafe_New(typ);
		_1 = typ.Kind();
		if (_1 === (3)) {
			(ptr).$set(((bits.$low << 24 >> 24)));
		} else if (_1 === (4)) {
			(ptr).$set(((bits.$low << 16 >> 16)));
		} else if ((_1 === (2)) || (_1 === (5))) {
			(ptr).$set(((bits.$low >> 0)));
		} else if (_1 === (6)) {
			(ptr).$set((new $Int64(bits.$high, bits.$low)));
		} else if (_1 === (8)) {
			(ptr).$set(((bits.$low << 24 >>> 24)));
		} else if (_1 === (9)) {
			(ptr).$set(((bits.$low << 16 >>> 16)));
		} else if ((_1 === (7)) || (_1 === (10)) || (_1 === (12))) {
			(ptr).$set(((bits.$low >>> 0)));
		} else if (_1 === (11)) {
			(ptr).$set((bits));
		}
		$s = -1; return new Value.ptr(typ, ptr, (((f | 128) >>> 0) | ((typ.Kind() >>> 0))) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeInt }; } $f._1 = _1; $f._r = _r; $f.bits = bits; $f.f = f; $f.ptr = ptr; $f.t = t; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;
	};
	typedmemmove = function(t, dst, src) {
		var dst, src, t;
		dst.$set(src.$get());
	};
	keyFor = function(t, key) {
		var k, key, kv, t;
		kv = key;
		if (!(kv.$get === undefined)) {
			kv = kv.$get();
		}
		k = $internalize(jsType(t.Key()).keyFor(kv), $String);
		return [kv, k];
	};
	mapaccess = function(t, m, key) {
		var _tuple, entry, k, key, m, t;
		_tuple = keyFor(t, key);
		k = _tuple[1];
		entry = m[$externalize(k, $String)];
		if (entry === undefined) {
			return 0;
		}
		return ($newDataPointer(entry.v, jsType(PtrTo(t.Elem()))));
	};
	mapassign = function(t, m, key, val) {
		var _r, _tuple, entry, et, jsVal, k, key, kv, m, newVal, t, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; entry = $f.entry; et = $f.et; jsVal = $f.jsVal; k = $f.k; key = $f.key; kv = $f.kv; m = $f.m; newVal = $f.newVal; t = $f.t; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = keyFor(t, key);
		kv = _tuple[0];
		k = _tuple[1];
		jsVal = val.$get();
		et = t.Elem();
		_r = et.Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r === 25) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r === 25) { */ case 1:
			newVal = jsType(et).zero();
			copyStruct(newVal, jsVal, et);
			jsVal = newVal;
		/* } */ case 2:
		entry = new ($global.Object)();
		entry.k = kv;
		entry.v = jsVal;
		m[$externalize(k, $String)] = entry;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: mapassign }; } $f._r = _r; $f._tuple = _tuple; $f.entry = entry; $f.et = et; $f.jsVal = jsVal; $f.k = k; $f.key = key; $f.kv = kv; $f.m = m; $f.newVal = newVal; $f.t = t; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	mapdelete = function(t, m, key) {
		var _tuple, k, key, m, t;
		_tuple = keyFor(t, key);
		k = _tuple[1];
		delete m[$externalize(k, $String)];
	};
	mapIter.ptr.prototype.skipUntilValidKey = function() {
		var iter, k;
		iter = this;
		while (true) {
			if (!(iter.i < $parseInt(iter.keys.length))) { break; }
			k = iter.keys[iter.i];
			if (!(iter.m[$externalize($internalize(k, $String), $String)] === undefined)) {
				break;
			}
			iter.i = iter.i + (1) >> 0;
		}
	};
	mapIter.prototype.skipUntilValidKey = function() { return this.$val.skipUntilValidKey(); };
	mapiterinit = function(t, m) {
		var m, t;
		return (new mapIter.ptr(t, m, $keys(m), 0, null));
	};
	mapiterkey = function(it) {
		var _r, _r$1, _r$2, it, iter, k, kv, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; it = $f.it; iter = $f.iter; k = $f.k; kv = $f.kv; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		iter = ($pointerOfStructConversion(it, ptrType$7));
		kv = null;
		if (!(iter.last === null)) {
			kv = iter.last;
		} else {
			iter.skipUntilValidKey();
			if (iter.i === $parseInt(iter.keys.length)) {
				$s = -1; return 0;
			}
			k = iter.keys[iter.i];
			kv = iter.m[$externalize($internalize(k, $String), $String)];
			iter.last = kv;
		}
		_r = iter.t.Key(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = PtrTo(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = jsType(_r$1); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return ($newDataPointer(kv.k, _r$2));
		/* */ } return; } if ($f === undefined) { $f = { $blk: mapiterkey }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.it = it; $f.iter = iter; $f.k = k; $f.kv = kv; $f.$s = $s; $f.$r = $r; return $f;
	};
	mapitervalue = function(it) {
		var _r, _r$1, _r$2, it, iter, k, kv, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; it = $f.it; iter = $f.iter; k = $f.k; kv = $f.kv; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		iter = ($pointerOfStructConversion(it, ptrType$7));
		kv = null;
		if (!(iter.last === null)) {
			kv = iter.last;
		} else {
			iter.skipUntilValidKey();
			if (iter.i === $parseInt(iter.keys.length)) {
				$s = -1; return 0;
			}
			k = iter.keys[iter.i];
			kv = iter.m[$externalize($internalize(k, $String), $String)];
			iter.last = kv;
		}
		_r = iter.t.Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = PtrTo(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = jsType(_r$1); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return ($newDataPointer(kv.v, _r$2));
		/* */ } return; } if ($f === undefined) { $f = { $blk: mapitervalue }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.it = it; $f.iter = iter; $f.k = k; $f.kv = kv; $f.$s = $s; $f.$r = $r; return $f;
	};
	mapiternext = function(it) {
		var it, iter;
		iter = ($pointerOfStructConversion(it, ptrType$7));
		iter.last = null;
		iter.i = iter.i + (1) >> 0;
	};
	maplen = function(m) {
		var m;
		return $parseInt($keys(m).length);
	};
	cvtDirect = function(v, typ) {
		var _1, _arg, _arg$1, _arg$2, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, k, slice, srcVal, typ, v, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; k = $f.k; slice = $f.slice; srcVal = $f.srcVal; typ = $f.typ; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		srcVal = $clone(v, Value).object();
		/* */ if (srcVal === jsType(v.typ).nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (srcVal === jsType(v.typ).nil) { */ case 1:
			_r = makeValue(typ, jsType(typ).nil, v.flag); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		val = null;
			_r$1 = typ.Kind(); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			k = _r$1;
			_1 = k;
			/* */ if (_1 === (23)) { $s = 6; continue; }
			/* */ if (_1 === (22)) { $s = 7; continue; }
			/* */ if (_1 === (25)) { $s = 8; continue; }
			/* */ if ((_1 === (17)) || (_1 === (1)) || (_1 === (18)) || (_1 === (19)) || (_1 === (20)) || (_1 === (21)) || (_1 === (24))) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_1 === (23)) { */ case 6:
				slice = new (jsType(typ))(srcVal.$array);
				slice.$offset = srcVal.$offset;
				slice.$length = srcVal.$length;
				slice.$capacity = srcVal.$capacity;
				val = $newDataPointer(slice, jsType(PtrTo(typ)));
				$s = 11; continue;
			/* } else if (_1 === (22)) { */ case 7:
				_r$2 = typ.Elem(); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$3 = _r$2.Kind(); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				/* */ if (_r$3 === 25) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (_r$3 === 25) { */ case 12:
					_r$4 = typ.Elem(); /* */ $s = 18; case 18: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					/* */ if ($interfaceIsEqual(_r$4, v.typ.Elem())) { $s = 16; continue; }
					/* */ $s = 17; continue;
					/* if ($interfaceIsEqual(_r$4, v.typ.Elem())) { */ case 16:
						val = srcVal;
						/* break; */ $s = 4; continue;
					/* } */ case 17:
					val = new (jsType(typ))();
					_arg = val;
					_arg$1 = srcVal;
					_r$5 = typ.Elem(); /* */ $s = 19; case 19: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					_arg$2 = _r$5;
					$r = copyStruct(_arg, _arg$1, _arg$2); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					/* break; */ $s = 4; continue;
				/* } */ case 13:
				val = new (jsType(typ))(srcVal.$get, srcVal.$set);
				$s = 11; continue;
			/* } else if (_1 === (25)) { */ case 8:
				val = new (jsType(typ).ptr)();
				copyStruct(val, srcVal, typ);
				$s = 11; continue;
			/* } else if ((_1 === (17)) || (_1 === (1)) || (_1 === (18)) || (_1 === (19)) || (_1 === (20)) || (_1 === (21)) || (_1 === (24))) { */ case 9:
				val = v.ptr;
				$s = 11; continue;
			/* } else { */ case 10:
				$panic(new ValueError.ptr("reflect.Convert", k));
			/* } */ case 11:
		case 4:
		_r$6 = typ.common(); /* */ $s = 21; case 21: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_r$7 = typ.Kind(); /* */ $s = 22; case 22: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		$s = -1; return new Value.ptr(_r$6, (val), (((new flag(v.flag).ro() | ((v.flag & 128) >>> 0)) >>> 0) | ((_r$7 >>> 0))) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtDirect }; } $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f.k = k; $f.slice = slice; $f.srcVal = srcVal; $f.typ = typ; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	valueInterface = function(v, safe) {
		var _r, safe, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; safe = $f.safe; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (v.flag === 0) {
			$panic(new ValueError.ptr("reflect.Value.Interface", 0));
		}
		if (safe && !((((v.flag & 96) >>> 0) === 0))) {
			$panic(new $String("reflect.Value.Interface: cannot return value obtained from unexported field or method"));
		}
		/* */ if (!((((v.flag & 512) >>> 0) === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
			_r = makeMethodValue("Interface", $clone(v, Value)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			v = _r;
		/* } */ case 2:
		if (isWrapped(v.typ)) {
			$s = -1; return ((new (jsType(v.typ))($clone(v, Value).object())));
		}
		$s = -1; return (($clone(v, Value).object()));
		/* */ } return; } if ($f === undefined) { $f = { $blk: valueInterface }; } $f._r = _r; $f.safe = safe; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	ifaceE2I = function(t, src, dst) {
		var dst, src, t;
		dst.$set(src);
	};
	methodName = function() {
		return "?FIXME?";
	};
	makeMethodValue = function(op, v) {
		var _r, _tuple, fn, fv, op, rcvr, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; fn = $f.fn; fv = $f.fv; op = $f.op; rcvr = $f.rcvr; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fn = [fn];
		rcvr = [rcvr];
		if (((v.flag & 512) >>> 0) === 0) {
			$panic(new $String("reflect: internal error: invalid use of makePartialFunc"));
		}
		_tuple = methodReceiver(op, $clone(v, Value), ((v.flag >> 0)) >> 10 >> 0);
		fn[0] = _tuple[2];
		rcvr[0] = $clone(v, Value).object();
		if (isWrapped(v.typ)) {
			rcvr[0] = new (jsType(v.typ))(rcvr[0]);
		}
		fv = js.MakeFunc((function(fn, rcvr) { return function(this$1, arguments$1) {
			var arguments$1, this$1;
			return new $jsObjectPtr(fn[0].apply(rcvr[0], $externalize(arguments$1, sliceType$8)));
		}; })(fn, rcvr));
		_r = $clone(v, Value).Type().common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return new Value.ptr(_r, (fv), (new flag(v.flag).ro() | 19) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeMethodValue }; } $f._r = _r; $f._tuple = _tuple; $f.fn = fn; $f.fv = fv; $f.op = op; $f.rcvr = rcvr; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.ptr.prototype.pointers = function() {
		var _1, t;
		t = this;
		_1 = t.Kind();
		if ((_1 === (22)) || (_1 === (21)) || (_1 === (18)) || (_1 === (19)) || (_1 === (25)) || (_1 === (17))) {
			return true;
		} else {
			return false;
		}
	};
	rtype.prototype.pointers = function() { return this.$val.pointers(); };
	rtype.ptr.prototype.Comparable = function() {
		var _1, _r, _r$1, i, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; i = $f.i; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
			_1 = t.Kind();
			/* */ if ((_1 === (19)) || (_1 === (23)) || (_1 === (21))) { $s = 2; continue; }
			/* */ if (_1 === (17)) { $s = 3; continue; }
			/* */ if (_1 === (25)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if ((_1 === (19)) || (_1 === (23)) || (_1 === (21))) { */ case 2:
				$s = -1; return false;
			/* } else if (_1 === (17)) { */ case 3:
				_r = t.Elem().Comparable(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (25)) { */ case 4:
				i = 0;
				/* while (true) { */ case 7:
					/* if (!(i < t.NumField())) { break; } */ if(!(i < t.NumField())) { $s = 8; continue; }
					_r$1 = t.Field(i).Type.Comparable(); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					/* */ if (!_r$1) { $s = 9; continue; }
					/* */ $s = 10; continue;
					/* if (!_r$1) { */ case 9:
						$s = -1; return false;
					/* } */ case 10:
					i = i + (1) >> 0;
				/* } */ $s = 7; continue; case 8:
			/* } */ case 5:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.Comparable }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.Comparable = function() { return this.$val.Comparable(); };
	rtype.ptr.prototype.Method = function(i) {
		var _i, _i$1, _r, _ref, _ref$1, arg, fl, fn, ft, i, in$1, m, methods, mt, mtyp, out, p, pname, prop, ret, t, tt, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; arg = $f.arg; fl = $f.fl; fn = $f.fn; ft = $f.ft; i = $f.i; in$1 = $f.in$1; m = $f.m; methods = $f.methods; mt = $f.mt; mtyp = $f.mtyp; out = $f.out; p = $f.p; pname = $f.pname; prop = $f.prop; ret = $f.ret; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		prop = [prop];
		m = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
		t = this;
		if (t.Kind() === 20) {
			tt = (t.kindType);
			Method.copy(m, tt.Method(i));
			$s = -1; return m;
		}
		methods = t.exportedMethods();
		if (i < 0 || i >= methods.$length) {
			$panic(new $String("reflect: Method index out of range"));
		}
		p = $clone(((i < 0 || i >= methods.$length) ? ($throwRuntimeError("index out of range"), undefined) : methods.$array[methods.$offset + i]), method);
		pname = $clone(t.nameOff(p.name), name);
		m.Name = $clone(pname, name).name();
		fl = 19;
		mtyp = t.typeOff(p.mtyp);
		ft = (mtyp.kindType);
		in$1 = $makeSlice(sliceType$10, 0, (1 + ft.in$().$length >> 0));
		in$1 = $append(in$1, t);
		_ref = ft.in$();
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			arg = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			in$1 = $append(in$1, arg);
			_i++;
		}
		out = $makeSlice(sliceType$10, 0, ft.out().$length);
		_ref$1 = ft.out();
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			ret = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			out = $append(out, ret);
			_i$1++;
		}
		_r = FuncOf(in$1, out, ft.rtype.IsVariadic()); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		mt = _r;
		m.Type = mt;
		prop[0] = $internalize($methodSet(t.jsType)[i].prop, $String);
		fn = js.MakeFunc((function(prop) { return function(this$1, arguments$1) {
			var arguments$1, rcvr, this$1;
			rcvr = (0 >= arguments$1.$length ? ($throwRuntimeError("index out of range"), undefined) : arguments$1.$array[arguments$1.$offset + 0]);
			return new $jsObjectPtr(rcvr[$externalize(prop[0], $String)].apply(rcvr, $externalize($subslice(arguments$1, 1), sliceType$8)));
		}; })(prop));
		m.Func = new Value.ptr($assertType(mt, ptrType$1), (fn), fl);
		m.Index = i;
		Method.copy(m, m);
		$s = -1; return m;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.Method }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f.arg = arg; $f.fl = fl; $f.fn = fn; $f.ft = ft; $f.i = i; $f.in$1 = in$1; $f.m = m; $f.methods = methods; $f.mt = mt; $f.mtyp = mtyp; $f.out = out; $f.p = p; $f.pname = pname; $f.prop = prop; $f.ret = ret; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.Method = function(i) { return this.$val.Method(i); };
	Value.ptr.prototype.object = function() {
		var _1, newVal, v, val;
		v = this;
		if ((v.typ.Kind() === 17) || (v.typ.Kind() === 25)) {
			return v.ptr;
		}
		if (!((((v.flag & 128) >>> 0) === 0))) {
			val = v.ptr.$get();
			if (!(val === $ifaceNil) && !(val.constructor === jsType(v.typ))) {
				switch (0) { default:
					_1 = v.typ.Kind();
					if ((_1 === (11)) || (_1 === (6))) {
						val = new (jsType(v.typ))(val.$high, val.$low);
					} else if ((_1 === (15)) || (_1 === (16))) {
						val = new (jsType(v.typ))(val.$real, val.$imag);
					} else if (_1 === (23)) {
						if (val === val.constructor.nil) {
							val = jsType(v.typ).nil;
							break;
						}
						newVal = new (jsType(v.typ))(val.$array);
						newVal.$offset = val.$offset;
						newVal.$length = val.$length;
						newVal.$capacity = val.$capacity;
						val = newVal;
					}
				}
			}
			return val;
		}
		return v.ptr;
	};
	Value.prototype.object = function() { return this.$val.object(); };
	Value.ptr.prototype.assignTo = function(context, dst, target) {
		var _r, _r$1, _r$2, context, dst, fl, target, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; context = $f.context; dst = $f.dst; fl = $f.fl; target = $f.target; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		/* */ if (!((((v.flag & 512) >>> 0) === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
			_r = makeMethodValue(context, $clone(v, Value)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			v = _r;
		/* } */ case 2:
			_r$1 = directlyAssignable(dst, v.typ); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (_r$1) { $s = 5; continue; }
			/* */ if (implements$1(dst, v.typ)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_r$1) { */ case 5:
				fl = (((v.flag & 384) >>> 0) | new flag(v.flag).ro()) >>> 0;
				fl = (fl | (((dst.Kind() >>> 0)))) >>> 0;
				$s = -1; return new Value.ptr(dst, v.ptr, fl);
			/* } else if (implements$1(dst, v.typ)) { */ case 6:
				if (target === 0) {
					target = unsafe_New(dst);
				}
				_r$2 = valueInterface($clone(v, Value), false); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				x = _r$2;
				if (dst.NumMethod() === 0) {
					(target).$set(x);
				} else {
					ifaceE2I(dst, x, target);
				}
				$s = -1; return new Value.ptr(dst, target, 148);
			/* } */ case 7:
		case 4:
		$panic(new $String(context + ": value of type " + v.typ.String() + " is not assignable to type " + dst.String()));
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.assignTo }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.context = context; $f.dst = dst; $f.fl = fl; $f.target = target; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.assignTo = function(context, dst, target) { return this.$val.assignTo(context, dst, target); };
	Value.ptr.prototype.Cap = function() {
		var _1, k, v;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (17)) {
			return v.typ.Len();
		} else if ((_1 === (18)) || (_1 === (23))) {
			return $parseInt($clone(v, Value).object().$capacity) >> 0;
		}
		$panic(new ValueError.ptr("reflect.Value.Cap", k));
	};
	Value.prototype.Cap = function() { return this.$val.Cap(); };
	wrapJsObject = function(typ, val) {
		var typ, val;
		if ($interfaceIsEqual(typ, jsObjectPtr)) {
			return new (jsType(jsObjectPtr))(val);
		}
		return val;
	};
	unwrapJsObject = function(typ, val) {
		var typ, val;
		if ($interfaceIsEqual(typ, jsObjectPtr)) {
			return val.object;
		}
		return val;
	};
	Value.ptr.prototype.Elem = function() {
		var _1, _r, fl, k, tt, typ, v, val, val$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; fl = $f.fl; k = $f.k; tt = $f.tt; typ = $f.typ; v = $f.v; val = $f.val; val$1 = $f.val$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
			k = new flag(v.flag).kind();
			_1 = k;
			/* */ if (_1 === (20)) { $s = 2; continue; }
			/* */ if (_1 === (22)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_1 === (20)) { */ case 2:
				val = $clone(v, Value).object();
				if (val === $ifaceNil) {
					$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
				}
				typ = reflectType(val.constructor);
				_r = makeValue(typ, val.$val, new flag(v.flag).ro()); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (22)) { */ case 3:
				if ($clone(v, Value).IsNil()) {
					$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
				}
				val$1 = $clone(v, Value).object();
				tt = (v.typ.kindType);
				fl = (((((v.flag & 96) >>> 0) | 128) >>> 0) | 256) >>> 0;
				fl = (fl | (((tt.elem.Kind() >>> 0)))) >>> 0;
				$s = -1; return new Value.ptr(tt.elem, (wrapJsObject(tt.elem, val$1)), fl);
			/* } else { */ case 4:
				$panic(new ValueError.ptr("reflect.Value.Elem", k));
			/* } */ case 5:
		case 1:
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Elem }; } $f._1 = _1; $f._r = _r; $f.fl = fl; $f.k = k; $f.tt = tt; $f.typ = typ; $f.v = v; $f.val = val; $f.val$1 = val$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Elem = function() { return this.$val.Elem(); };
	Value.ptr.prototype.Field = function(i) {
		var _r, _r$1, _r$2, field, fl, i, jsTag, o, prop, s, tag, tt, typ, v, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; field = $f.field; fl = $f.fl; i = $f.i; jsTag = $f.jsTag; o = $f.o; prop = $f.prop; s = $f.s; tag = $f.tag; tt = $f.tt; typ = $f.typ; v = $f.v; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		jsTag = [jsTag];
		prop = [prop];
		s = [s];
		typ = [typ];
		v = this;
		if (!((new flag(v.flag).kind() === 25))) {
			$panic(new ValueError.ptr("reflect.Value.Field", new flag(v.flag).kind()));
		}
		tt = (v.typ.kindType);
		if (((i >>> 0)) >= ((tt.fields.$length >>> 0))) {
			$panic(new $String("reflect: Field index out of range"));
		}
		prop[0] = $internalize(jsType(v.typ).fields[i].prop, $String);
		field = (x = tt.fields, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
		typ[0] = field.typ;
		fl = (((v.flag & 416) >>> 0) | ((typ[0].Kind() >>> 0))) >>> 0;
		if (!$clone(field.name, name).isExported()) {
			if (field.embedded()) {
				fl = (fl | (64)) >>> 0;
			} else {
				fl = (fl | (32)) >>> 0;
			}
		}
		tag = $clone((x$1 = tt.fields, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])).name, name).tag();
		/* */ if (!(tag === "") && !((i === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(tag === "") && !((i === 0))) { */ case 1:
			jsTag[0] = getJsTag(tag);
			/* */ if (!(jsTag[0] === "")) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(jsTag[0] === "")) { */ case 3:
				/* while (true) { */ case 5:
					o = [o];
					_r = $clone(v, Value).Field(0); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					v = _r;
					/* */ if (v.typ === jsObjectPtr) { $s = 8; continue; }
					/* */ $s = 9; continue;
					/* if (v.typ === jsObjectPtr) { */ case 8:
						o[0] = $clone(v, Value).object().object;
						$s = -1; return new Value.ptr(typ[0], (new (jsType(PtrTo(typ[0])))((function(jsTag, o, prop, s, typ) { return function() {
							return $internalize(o[0][$externalize(jsTag[0], $String)], jsType(typ[0]));
						}; })(jsTag, o, prop, s, typ), (function(jsTag, o, prop, s, typ) { return function(x$2) {
							var x$2;
							o[0][$externalize(jsTag[0], $String)] = $externalize(x$2, jsType(typ[0]));
						}; })(jsTag, o, prop, s, typ))), fl);
					/* } */ case 9:
					/* */ if (v.typ.Kind() === 22) { $s = 10; continue; }
					/* */ $s = 11; continue;
					/* if (v.typ.Kind() === 22) { */ case 10:
						_r$1 = $clone(v, Value).Elem(); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						v = _r$1;
					/* } */ case 11:
				/* } */ $s = 5; continue; case 6:
			/* } */ case 4:
		/* } */ case 2:
		s[0] = v.ptr;
		/* */ if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { $s = 13; continue; }
		/* */ $s = 14; continue;
		/* if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { */ case 13:
			$s = -1; return new Value.ptr(typ[0], (new (jsType(PtrTo(typ[0])))((function(jsTag, prop, s, typ) { return function() {
				return wrapJsObject(typ[0], s[0][$externalize(prop[0], $String)]);
			}; })(jsTag, prop, s, typ), (function(jsTag, prop, s, typ) { return function(x$2) {
				var x$2;
				s[0][$externalize(prop[0], $String)] = unwrapJsObject(typ[0], x$2);
			}; })(jsTag, prop, s, typ))), fl);
		/* } */ case 14:
		_r$2 = makeValue(typ[0], wrapJsObject(typ[0], s[0][$externalize(prop[0], $String)]), fl); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Field }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.field = field; $f.fl = fl; $f.i = i; $f.jsTag = jsTag; $f.o = o; $f.prop = prop; $f.s = s; $f.tag = tag; $f.tt = tt; $f.typ = typ; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Field = function(i) { return this.$val.Field(i); };
	getJsTag = function(tag) {
		var _tuple, i, name$1, qvalue, tag, value;
		while (true) {
			if (!(!(tag === ""))) { break; }
			i = 0;
			while (true) {
				if (!(i < tag.length && (tag.charCodeAt(i) === 32))) { break; }
				i = i + (1) >> 0;
			}
			tag = $substring(tag, i);
			if (tag === "") {
				break;
			}
			i = 0;
			while (true) {
				if (!(i < tag.length && !((tag.charCodeAt(i) === 32)) && !((tag.charCodeAt(i) === 58)) && !((tag.charCodeAt(i) === 34)))) { break; }
				i = i + (1) >> 0;
			}
			if ((i + 1 >> 0) >= tag.length || !((tag.charCodeAt(i) === 58)) || !((tag.charCodeAt((i + 1 >> 0)) === 34))) {
				break;
			}
			name$1 = ($substring(tag, 0, i));
			tag = $substring(tag, (i + 1 >> 0));
			i = 1;
			while (true) {
				if (!(i < tag.length && !((tag.charCodeAt(i) === 34)))) { break; }
				if (tag.charCodeAt(i) === 92) {
					i = i + (1) >> 0;
				}
				i = i + (1) >> 0;
			}
			if (i >= tag.length) {
				break;
			}
			qvalue = ($substring(tag, 0, (i + 1 >> 0)));
			tag = $substring(tag, (i + 1 >> 0));
			if (name$1 === "js") {
				_tuple = strconv.Unquote(qvalue);
				value = _tuple[0];
				return value;
			}
		}
		return "";
	};
	Value.ptr.prototype.Index = function(i) {
		var _1, _r, _r$1, a, a$1, c, fl, fl$1, fl$2, i, k, s, str, tt, tt$1, typ, typ$1, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; a = $f.a; a$1 = $f.a$1; c = $f.c; fl = $f.fl; fl$1 = $f.fl$1; fl$2 = $f.fl$2; i = $f.i; k = $f.k; s = $f.s; str = $f.str; tt = $f.tt; tt$1 = $f.tt$1; typ = $f.typ; typ$1 = $f.typ$1; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		a = [a];
		a$1 = [a$1];
		c = [c];
		i = [i];
		typ = [typ];
		typ$1 = [typ$1];
		v = this;
			k = new flag(v.flag).kind();
			_1 = k;
			/* */ if (_1 === (17)) { $s = 2; continue; }
			/* */ if (_1 === (23)) { $s = 3; continue; }
			/* */ if (_1 === (24)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_1 === (17)) { */ case 2:
				tt = (v.typ.kindType);
				if (i[0] < 0 || i[0] > ((tt.len >> 0))) {
					$panic(new $String("reflect: array index out of range"));
				}
				typ[0] = tt.elem;
				fl = (((((v.flag & 384) >>> 0) | new flag(v.flag).ro()) >>> 0) | ((typ[0].Kind() >>> 0))) >>> 0;
				a[0] = v.ptr;
				/* */ if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { $s = 7; continue; }
				/* */ $s = 8; continue;
				/* if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { */ case 7:
					$s = -1; return new Value.ptr(typ[0], (new (jsType(PtrTo(typ[0])))((function(a, a$1, c, i, typ, typ$1) { return function() {
						return wrapJsObject(typ[0], a[0][i[0]]);
					}; })(a, a$1, c, i, typ, typ$1), (function(a, a$1, c, i, typ, typ$1) { return function(x) {
						var x;
						a[0][i[0]] = unwrapJsObject(typ[0], x);
					}; })(a, a$1, c, i, typ, typ$1))), fl);
				/* } */ case 8:
				_r = makeValue(typ[0], wrapJsObject(typ[0], a[0][i[0]]), fl); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (23)) { */ case 3:
				s = $clone(v, Value).object();
				if (i[0] < 0 || i[0] >= ($parseInt(s.$length) >> 0)) {
					$panic(new $String("reflect: slice index out of range"));
				}
				tt$1 = (v.typ.kindType);
				typ$1[0] = tt$1.elem;
				fl$1 = (((384 | new flag(v.flag).ro()) >>> 0) | ((typ$1[0].Kind() >>> 0))) >>> 0;
				i[0] = i[0] + (($parseInt(s.$offset) >> 0)) >> 0;
				a$1[0] = s.$array;
				/* */ if (!((((fl$1 & 128) >>> 0) === 0)) && !((typ$1[0].Kind() === 17)) && !((typ$1[0].Kind() === 25))) { $s = 10; continue; }
				/* */ $s = 11; continue;
				/* if (!((((fl$1 & 128) >>> 0) === 0)) && !((typ$1[0].Kind() === 17)) && !((typ$1[0].Kind() === 25))) { */ case 10:
					$s = -1; return new Value.ptr(typ$1[0], (new (jsType(PtrTo(typ$1[0])))((function(a, a$1, c, i, typ, typ$1) { return function() {
						return wrapJsObject(typ$1[0], a$1[0][i[0]]);
					}; })(a, a$1, c, i, typ, typ$1), (function(a, a$1, c, i, typ, typ$1) { return function(x) {
						var x;
						a$1[0][i[0]] = unwrapJsObject(typ$1[0], x);
					}; })(a, a$1, c, i, typ, typ$1))), fl$1);
				/* } */ case 11:
				_r$1 = makeValue(typ$1[0], wrapJsObject(typ$1[0], a$1[0][i[0]]), fl$1); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$s = -1; return _r$1;
			/* } else if (_1 === (24)) { */ case 4:
				str = (v.ptr).$get();
				if (i[0] < 0 || i[0] >= str.length) {
					$panic(new $String("reflect: string index out of range"));
				}
				fl$2 = (((new flag(v.flag).ro() | 8) >>> 0) | 128) >>> 0;
				c[0] = str.charCodeAt(i[0]);
				$s = -1; return new Value.ptr(uint8Type, ((c.$ptr || (c.$ptr = new ptrType$4(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, c)))), fl$2);
			/* } else { */ case 5:
				$panic(new ValueError.ptr("reflect.Value.Index", k));
			/* } */ case 6:
		case 1:
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Index }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.a = a; $f.a$1 = a$1; $f.c = c; $f.fl = fl; $f.fl$1 = fl$1; $f.fl$2 = fl$2; $f.i = i; $f.k = k; $f.s = s; $f.str = str; $f.tt = tt; $f.tt$1 = tt$1; $f.typ = typ; $f.typ$1 = typ$1; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Index = function(i) { return this.$val.Index(i); };
	Value.ptr.prototype.InterfaceData = function() {
		var v;
		v = this;
		$panic(errors.New("InterfaceData is not supported by GopherJS"));
	};
	Value.prototype.InterfaceData = function() { return this.$val.InterfaceData(); };
	Value.ptr.prototype.IsNil = function() {
		var _1, k, v;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if ((_1 === (22)) || (_1 === (23))) {
			return $clone(v, Value).object() === jsType(v.typ).nil;
		} else if (_1 === (18)) {
			return $clone(v, Value).object() === $chanNil;
		} else if (_1 === (19)) {
			return $clone(v, Value).object() === $throwNilPointerError;
		} else if (_1 === (21)) {
			return $clone(v, Value).object() === false;
		} else if (_1 === (20)) {
			return $clone(v, Value).object() === $ifaceNil;
		} else if (_1 === (26)) {
			return $clone(v, Value).object() === 0;
		} else {
			$panic(new ValueError.ptr("reflect.Value.IsNil", k));
		}
	};
	Value.prototype.IsNil = function() { return this.$val.IsNil(); };
	Value.ptr.prototype.Len = function() {
		var _1, k, v;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if ((_1 === (17)) || (_1 === (24))) {
			return $parseInt($clone(v, Value).object().length);
		} else if (_1 === (23)) {
			return $parseInt($clone(v, Value).object().$length) >> 0;
		} else if (_1 === (18)) {
			return $parseInt($clone(v, Value).object().$buffer.length) >> 0;
		} else if (_1 === (21)) {
			return $parseInt($keys($clone(v, Value).object()).length);
		} else {
			$panic(new ValueError.ptr("reflect.Value.Len", k));
		}
	};
	Value.prototype.Len = function() { return this.$val.Len(); };
	Value.ptr.prototype.Pointer = function() {
		var _1, k, v;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if ((_1 === (18)) || (_1 === (21)) || (_1 === (22)) || (_1 === (26))) {
			if ($clone(v, Value).IsNil()) {
				return 0;
			}
			return $clone(v, Value).object();
		} else if (_1 === (19)) {
			if ($clone(v, Value).IsNil()) {
				return 0;
			}
			return 1;
		} else if (_1 === (23)) {
			if ($clone(v, Value).IsNil()) {
				return 0;
			}
			return $clone(v, Value).object().$array;
		} else {
			$panic(new ValueError.ptr("reflect.Value.Pointer", k));
		}
	};
	Value.prototype.Pointer = function() { return this.$val.Pointer(); };
	Value.ptr.prototype.Set = function(x) {
		var _1, _r, _r$1, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(x.flag).mustBeExported();
		_r = $clone(x, Value).assignTo("reflect.Set", v.typ, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		x = _r;
		/* */ if (!((((v.flag & 128) >>> 0) === 0))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((((v.flag & 128) >>> 0) === 0))) { */ case 2:
				_1 = v.typ.Kind();
				/* */ if (_1 === (17)) { $s = 5; continue; }
				/* */ if (_1 === (20)) { $s = 6; continue; }
				/* */ if (_1 === (25)) { $s = 7; continue; }
				/* */ $s = 8; continue;
				/* if (_1 === (17)) { */ case 5:
					jsType(v.typ).copy(v.ptr, x.ptr);
					$s = 9; continue;
				/* } else if (_1 === (20)) { */ case 6:
					_r$1 = valueInterface($clone(x, Value), false); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					v.ptr.$set(_r$1);
					$s = 9; continue;
				/* } else if (_1 === (25)) { */ case 7:
					copyStruct(v.ptr, x.ptr, v.typ);
					$s = 9; continue;
				/* } else { */ case 8:
					v.ptr.$set($clone(x, Value).object());
				/* } */ case 9:
			case 4:
			$s = -1; return;
		/* } */ case 3:
		v.ptr = x.ptr;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Set }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Set = function(x) { return this.$val.Set(x); };
	Value.ptr.prototype.SetBytes = function(x) {
		var _r, _r$1, _v, slice, typedSlice, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _v = $f._v; slice = $f.slice; typedSlice = $f.typedSlice; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(23);
		_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 8))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 8))) { */ case 1:
			$panic(new $String("reflect.Value.SetBytes of non-byte slice"));
		/* } */ case 2:
		slice = x;
		if (!(v.typ.Name() === "")) { _v = true; $s = 6; continue s; }
		_r$1 = v.typ.Elem().Name(); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_v = !(_r$1 === ""); case 6:
		/* */ if (_v) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (_v) { */ case 4:
			typedSlice = new (jsType(v.typ))(slice.$array);
			typedSlice.$offset = slice.$offset;
			typedSlice.$length = slice.$length;
			typedSlice.$capacity = slice.$capacity;
			slice = typedSlice;
		/* } */ case 5:
		v.ptr.$set(slice);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.SetBytes }; } $f._r = _r; $f._r$1 = _r$1; $f._v = _v; $f.slice = slice; $f.typedSlice = typedSlice; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.SetBytes = function(x) { return this.$val.SetBytes(x); };
	Value.ptr.prototype.SetCap = function(n) {
		var n, newSlice, s, v;
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(23);
		s = v.ptr.$get();
		if (n < ($parseInt(s.$length) >> 0) || n > ($parseInt(s.$capacity) >> 0)) {
			$panic(new $String("reflect: slice capacity out of range in SetCap"));
		}
		newSlice = new (jsType(v.typ))(s.$array);
		newSlice.$offset = s.$offset;
		newSlice.$length = s.$length;
		newSlice.$capacity = n;
		v.ptr.$set(newSlice);
	};
	Value.prototype.SetCap = function(n) { return this.$val.SetCap(n); };
	Value.ptr.prototype.SetLen = function(n) {
		var n, newSlice, s, v;
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(23);
		s = v.ptr.$get();
		if (n < 0 || n > ($parseInt(s.$capacity) >> 0)) {
			$panic(new $String("reflect: slice length out of range in SetLen"));
		}
		newSlice = new (jsType(v.typ))(s.$array);
		newSlice.$offset = s.$offset;
		newSlice.$length = n;
		newSlice.$capacity = s.$capacity;
		v.ptr.$set(newSlice);
	};
	Value.prototype.SetLen = function(n) { return this.$val.SetLen(n); };
	Value.ptr.prototype.Slice = function(i, j) {
		var _1, _r, _r$1, cap, i, j, kind, s, str, tt, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; cap = $f.cap; i = $f.i; j = $f.j; kind = $f.kind; s = $f.s; str = $f.str; tt = $f.tt; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		cap = 0;
		typ = $ifaceNil;
		s = null;
			kind = new flag(v.flag).kind();
			_1 = kind;
			/* */ if (_1 === (17)) { $s = 2; continue; }
			/* */ if (_1 === (23)) { $s = 3; continue; }
			/* */ if (_1 === (24)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_1 === (17)) { */ case 2:
				if (((v.flag & 256) >>> 0) === 0) {
					$panic(new $String("reflect.Value.Slice: slice of unaddressable array"));
				}
				tt = (v.typ.kindType);
				cap = ((tt.len >> 0));
				typ = SliceOf(tt.elem);
				s = new (jsType(typ))($clone(v, Value).object());
				$s = 6; continue;
			/* } else if (_1 === (23)) { */ case 3:
				typ = v.typ;
				s = $clone(v, Value).object();
				cap = $parseInt(s.$capacity) >> 0;
				$s = 6; continue;
			/* } else if (_1 === (24)) { */ case 4:
				str = (v.ptr).$get();
				if (i < 0 || j < i || j > str.length) {
					$panic(new $String("reflect.Value.Slice: string slice index out of bounds"));
				}
				_r = ValueOf(new $String($substring(str, i, j))); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else { */ case 5:
				$panic(new ValueError.ptr("reflect.Value.Slice", kind));
			/* } */ case 6:
		case 1:
		if (i < 0 || j < i || j > cap) {
			$panic(new $String("reflect.Value.Slice: slice index out of bounds"));
		}
		_r$1 = makeValue(typ, $subslice(s, i, j), new flag(v.flag).ro()); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Slice }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.cap = cap; $f.i = i; $f.j = j; $f.kind = kind; $f.s = s; $f.str = str; $f.tt = tt; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Slice = function(i, j) { return this.$val.Slice(i, j); };
	Value.ptr.prototype.Slice3 = function(i, j, k) {
		var _1, _r, cap, i, j, k, kind, s, tt, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; cap = $f.cap; i = $f.i; j = $f.j; k = $f.k; kind = $f.kind; s = $f.s; tt = $f.tt; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		cap = 0;
		typ = $ifaceNil;
		s = null;
		kind = new flag(v.flag).kind();
		_1 = kind;
		if (_1 === (17)) {
			if (((v.flag & 256) >>> 0) === 0) {
				$panic(new $String("reflect.Value.Slice: slice of unaddressable array"));
			}
			tt = (v.typ.kindType);
			cap = ((tt.len >> 0));
			typ = SliceOf(tt.elem);
			s = new (jsType(typ))($clone(v, Value).object());
		} else if (_1 === (23)) {
			typ = v.typ;
			s = $clone(v, Value).object();
			cap = $parseInt(s.$capacity) >> 0;
		} else {
			$panic(new ValueError.ptr("reflect.Value.Slice3", kind));
		}
		if (i < 0 || j < i || k < j || k > cap) {
			$panic(new $String("reflect.Value.Slice3: slice index out of bounds"));
		}
		_r = makeValue(typ, $subslice(s, i, j, k), new flag(v.flag).ro()); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Slice3 }; } $f._1 = _1; $f._r = _r; $f.cap = cap; $f.i = i; $f.j = j; $f.k = k; $f.kind = kind; $f.s = s; $f.tt = tt; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Slice3 = function(i, j, k) { return this.$val.Slice3(i, j, k); };
	Value.ptr.prototype.Close = function() {
		var v;
		v = this;
		new flag(v.flag).mustBe(18);
		new flag(v.flag).mustBeExported();
		$close($clone(v, Value).object());
	};
	Value.prototype.Close = function() { return this.$val.Close(); };
	chanrecv = function(ch, nb, val) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, ch, comms, nb, received, recvRes, selectRes, selected, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; ch = $f.ch; comms = $f.comms; nb = $f.nb; received = $f.received; recvRes = $f.recvRes; selectRes = $f.selectRes; selected = $f.selected; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		selected = false;
		received = false;
		comms = new sliceType$11([new sliceType$8([ch])]);
		if (nb) {
			comms = $append(comms, new sliceType$8([]));
		}
		_r = selectHelper(new sliceType$3([comms])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		selectRes = _r;
		if (nb && (($parseInt(selectRes[0]) >> 0) === 1)) {
			_tmp = false;
			_tmp$1 = false;
			selected = _tmp;
			received = _tmp$1;
			$s = -1; return [selected, received];
		}
		recvRes = selectRes[1];
		val.$set(recvRes[0]);
		_tmp$2 = true;
		_tmp$3 = !!(recvRes[1]);
		selected = _tmp$2;
		received = _tmp$3;
		$s = -1; return [selected, received];
		/* */ } return; } if ($f === undefined) { $f = { $blk: chanrecv }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.ch = ch; $f.comms = comms; $f.nb = nb; $f.received = received; $f.recvRes = recvRes; $f.selectRes = selectRes; $f.selected = selected; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	chansend = function(ch, val, nb) {
		var _r, ch, comms, nb, selectRes, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; ch = $f.ch; comms = $f.comms; nb = $f.nb; selectRes = $f.selectRes; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		comms = new sliceType$11([new sliceType$8([ch, val.$get()])]);
		if (nb) {
			comms = $append(comms, new sliceType$8([]));
		}
		_r = selectHelper(new sliceType$3([comms])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		selectRes = _r;
		if (nb && (($parseInt(selectRes[0]) >> 0) === 1)) {
			$s = -1; return false;
		}
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: chansend }; } $f._r = _r; $f.ch = ch; $f.comms = comms; $f.nb = nb; $f.selectRes = selectRes; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	methodReceiver = function(op, v, i) {
		var _$39, fn, i, m, m$1, ms, op, prop, rcvr, t, tt, v, x;
		_$39 = ptrType$1.nil;
		t = ptrType$8.nil;
		fn = 0;
		prop = "";
		if (v.typ.Kind() === 20) {
			tt = (v.typ.kindType);
			if (i < 0 || i >= tt.methods.$length) {
				$panic(new $String("reflect: internal error: invalid method index"));
			}
			m = (x = tt.methods, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if (!$clone(tt.rtype.nameOff(m.name), name).isExported()) {
				$panic(new $String("reflect: " + op + " of unexported method"));
			}
			t = (tt.rtype.typeOff(m.typ).kindType);
			prop = $clone(tt.rtype.nameOff(m.name), name).name();
		} else {
			ms = v.typ.exportedMethods();
			if (((i >>> 0)) >= ((ms.$length >>> 0))) {
				$panic(new $String("reflect: internal error: invalid method index"));
			}
			m$1 = $clone(((i < 0 || i >= ms.$length) ? ($throwRuntimeError("index out of range"), undefined) : ms.$array[ms.$offset + i]), method);
			if (!$clone(v.typ.nameOff(m$1.name), name).isExported()) {
				$panic(new $String("reflect: " + op + " of unexported method"));
			}
			t = (v.typ.typeOff(m$1.mtyp).kindType);
			prop = $internalize($methodSet(jsType(v.typ))[i].prop, $String);
		}
		rcvr = $clone(v, Value).object();
		if (isWrapped(v.typ)) {
			rcvr = new (jsType(v.typ))(rcvr);
		}
		fn = (rcvr[$externalize(prop, $String)]);
		return [_$39, t, fn];
	};
	Value.ptr.prototype.call = function(op, in$1) {
		var _1, _arg, _arg$1, _arg$2, _arg$3, _i, _i$1, _i$2, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, _ref$2, _tmp, _tmp$1, _tuple, arg, argsArray, elem, fn, i, i$1, i$2, i$3, in$1, isSlice, m, n, nin, nout, op, origIn, rcvr, results, ret, slice, t, targ, v, x, x$1, x$2, xt, xt$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; arg = $f.arg; argsArray = $f.argsArray; elem = $f.elem; fn = $f.fn; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; in$1 = $f.in$1; isSlice = $f.isSlice; m = $f.m; n = $f.n; nin = $f.nin; nout = $f.nout; op = $f.op; origIn = $f.origIn; rcvr = $f.rcvr; results = $f.results; ret = $f.ret; slice = $f.slice; t = $f.t; targ = $f.targ; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; xt = $f.xt; xt$1 = $f.xt$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		t = ptrType$8.nil;
		fn = 0;
		rcvr = null;
		if (!((((v.flag & 512) >>> 0) === 0))) {
			_tuple = methodReceiver(op, $clone(v, Value), ((v.flag >> 0)) >> 10 >> 0);
			t = _tuple[1];
			fn = _tuple[2];
			rcvr = $clone(v, Value).object();
			if (isWrapped(v.typ)) {
				rcvr = new (jsType(v.typ))(rcvr);
			}
		} else {
			t = (v.typ.kindType);
			fn = ($clone(v, Value).object());
			rcvr = undefined;
		}
		if (fn === 0) {
			$panic(new $String("reflect.Value.Call: call of nil function"));
		}
		isSlice = op === "CallSlice";
		n = t.rtype.NumIn();
		if (isSlice) {
			if (!t.rtype.IsVariadic()) {
				$panic(new $String("reflect: CallSlice of non-variadic function"));
			}
			if (in$1.$length < n) {
				$panic(new $String("reflect: CallSlice with too few input arguments"));
			}
			if (in$1.$length > n) {
				$panic(new $String("reflect: CallSlice with too many input arguments"));
			}
		} else {
			if (t.rtype.IsVariadic()) {
				n = n - (1) >> 0;
			}
			if (in$1.$length < n) {
				$panic(new $String("reflect: Call with too few input arguments"));
			}
			if (!t.rtype.IsVariadic() && in$1.$length > n) {
				$panic(new $String("reflect: Call with too many input arguments"));
			}
		}
		_ref = in$1;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			x = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if ($clone(x, Value).Kind() === 0) {
				$panic(new $String("reflect: " + op + " using zero Value argument"));
			}
			_i++;
		}
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 2; continue; }
			_tmp = $clone(((i < 0 || i >= in$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : in$1.$array[in$1.$offset + i]), Value).Type();
			_tmp$1 = t.rtype.In(i);
			xt = _tmp;
			targ = _tmp$1;
			_r = xt.AssignableTo(targ); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (!_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!_r) { */ case 3:
				_r$1 = xt.String(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$2 = targ.String(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				$panic(new $String("reflect: " + op + " using " + _r$1 + " as type " + _r$2));
			/* } */ case 4:
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		/* */ if (!isSlice && t.rtype.IsVariadic()) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if (!isSlice && t.rtype.IsVariadic()) { */ case 8:
			m = in$1.$length - n >> 0;
			_r$3 = MakeSlice(t.rtype.In(n), m, m); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			slice = _r$3;
			_r$4 = t.rtype.In(n).Elem(); /* */ $s = 11; case 11: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			elem = _r$4;
			i$1 = 0;
			/* while (true) { */ case 12:
				/* if (!(i$1 < m)) { break; } */ if(!(i$1 < m)) { $s = 13; continue; }
				x$2 = (x$1 = n + i$1 >> 0, ((x$1 < 0 || x$1 >= in$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : in$1.$array[in$1.$offset + x$1]));
				xt$1 = $clone(x$2, Value).Type();
				_r$5 = xt$1.AssignableTo(elem); /* */ $s = 16; case 16: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				/* */ if (!_r$5) { $s = 14; continue; }
				/* */ $s = 15; continue;
				/* if (!_r$5) { */ case 14:
					_r$6 = xt$1.String(); /* */ $s = 17; case 17: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
					_r$7 = elem.String(); /* */ $s = 18; case 18: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
					$panic(new $String("reflect: cannot use " + _r$6 + " as type " + _r$7 + " in " + op));
				/* } */ case 15:
				_r$8 = $clone(slice, Value).Index(i$1); /* */ $s = 19; case 19: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				$r = $clone(_r$8, Value).Set($clone(x$2, Value)); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				i$1 = i$1 + (1) >> 0;
			/* } */ $s = 12; continue; case 13:
			origIn = in$1;
			in$1 = $makeSlice(sliceType$9, (n + 1 >> 0));
			$copySlice($subslice(in$1, 0, n), origIn);
			((n < 0 || n >= in$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : in$1.$array[in$1.$offset + n] = slice);
		/* } */ case 9:
		nin = in$1.$length;
		if (!((nin === t.rtype.NumIn()))) {
			$panic(new $String("reflect.Value.Call: wrong argument count"));
		}
		nout = t.rtype.NumOut();
		argsArray = new ($global.Array)(t.rtype.NumIn());
		_ref$1 = in$1;
		_i$1 = 0;
		/* while (true) { */ case 21:
			/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 22; continue; }
			i$2 = _i$1;
			arg = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			_arg = t.rtype.In(i$2);
			_r$9 = t.rtype.In(i$2).common(); /* */ $s = 23; case 23: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
			_arg$1 = _r$9;
			_arg$2 = 0;
			_r$10 = $clone(arg, Value).assignTo("reflect.Value.Call", _arg$1, _arg$2); /* */ $s = 24; case 24: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			_r$11 = $clone(_r$10, Value).object(); /* */ $s = 25; case 25: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
			_arg$3 = _r$11;
			_r$12 = unwrapJsObject(_arg, _arg$3); /* */ $s = 26; case 26: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
			argsArray[i$2] = _r$12;
			_i$1++;
		/* } */ $s = 21; continue; case 22:
		_r$13 = callHelper(new sliceType$3([new $jsObjectPtr(fn), new $jsObjectPtr(rcvr), new $jsObjectPtr(argsArray)])); /* */ $s = 27; case 27: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
		results = _r$13;
			_1 = nout;
			/* */ if (_1 === (0)) { $s = 29; continue; }
			/* */ if (_1 === (1)) { $s = 30; continue; }
			/* */ $s = 31; continue;
			/* if (_1 === (0)) { */ case 29:
				$s = -1; return sliceType$9.nil;
			/* } else if (_1 === (1)) { */ case 30:
				_r$14 = makeValue(t.rtype.Out(0), wrapJsObject(t.rtype.Out(0), results), 0); /* */ $s = 33; case 33: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
				$s = -1; return new sliceType$9([$clone(_r$14, Value)]);
			/* } else { */ case 31:
				ret = $makeSlice(sliceType$9, nout);
				_ref$2 = ret;
				_i$2 = 0;
				/* while (true) { */ case 34:
					/* if (!(_i$2 < _ref$2.$length)) { break; } */ if(!(_i$2 < _ref$2.$length)) { $s = 35; continue; }
					i$3 = _i$2;
					_r$15 = makeValue(t.rtype.Out(i$3), wrapJsObject(t.rtype.Out(i$3), results[i$3]), 0); /* */ $s = 36; case 36: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
					((i$3 < 0 || i$3 >= ret.$length) ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + i$3] = _r$15);
					_i$2++;
				/* } */ $s = 34; continue; case 35:
				$s = -1; return ret;
			/* } */ case 32:
		case 28:
		$s = -1; return sliceType$9.nil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.call }; } $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.arg = arg; $f.argsArray = argsArray; $f.elem = elem; $f.fn = fn; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.in$1 = in$1; $f.isSlice = isSlice; $f.m = m; $f.n = n; $f.nin = nin; $f.nout = nout; $f.op = op; $f.origIn = origIn; $f.rcvr = rcvr; $f.results = results; $f.ret = ret; $f.slice = slice; $f.t = t; $f.targ = targ; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.xt = xt; $f.xt$1 = xt$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.call = function(op, in$1) { return this.$val.call(op, in$1); };
	structField.ptr.prototype.offset = function() {
		var f;
		f = this;
		return f.offsetEmbed >>> 1 >>> 0;
	};
	structField.prototype.offset = function() { return this.$val.offset(); };
	structField.ptr.prototype.embedded = function() {
		var f;
		f = this;
		return !((((f.offsetEmbed & 1) >>> 0) === 0));
	};
	structField.prototype.embedded = function() { return this.$val.embedded(); };
	Kind.prototype.String = function() {
		var k;
		k = this.$val;
		if (((k >> 0)) < kindNames.$length) {
			return ((k < 0 || k >= kindNames.$length) ? ($throwRuntimeError("index out of range"), undefined) : kindNames.$array[kindNames.$offset + k]);
		}
		return "kind" + strconv.Itoa(((k >> 0)));
	};
	$ptrType(Kind).prototype.String = function() { return new Kind(this.$get()).String(); };
	rtype.ptr.prototype.String = function() {
		var s, t;
		t = this;
		s = $clone(t.nameOff(t.str), name).name();
		if (!((((t.tflag & 2) >>> 0) === 0))) {
			return $substring(s, 1);
		}
		return s;
	};
	rtype.prototype.String = function() { return this.$val.String(); };
	rtype.ptr.prototype.Size = function() {
		var t;
		t = this;
		return t.size;
	};
	rtype.prototype.Size = function() { return this.$val.Size(); };
	rtype.ptr.prototype.Bits = function() {
		var k, t;
		t = this;
		if (t === ptrType$1.nil) {
			$panic(new $String("reflect: Bits of nil Type"));
		}
		k = t.Kind();
		if (k < 2 || k > 16) {
			$panic(new $String("reflect: Bits of non-arithmetic Type " + t.String()));
		}
		return $imul(((t.size >> 0)), 8);
	};
	rtype.prototype.Bits = function() { return this.$val.Bits(); };
	rtype.ptr.prototype.Align = function() {
		var t;
		t = this;
		return ((t.align >> 0));
	};
	rtype.prototype.Align = function() { return this.$val.Align(); };
	rtype.ptr.prototype.FieldAlign = function() {
		var t;
		t = this;
		return ((t.fieldAlign >> 0));
	};
	rtype.prototype.FieldAlign = function() { return this.$val.FieldAlign(); };
	rtype.ptr.prototype.Kind = function() {
		var t;
		t = this;
		return ((((t.kind & 31) >>> 0) >>> 0));
	};
	rtype.prototype.Kind = function() { return this.$val.Kind(); };
	rtype.ptr.prototype.common = function() {
		var t;
		t = this;
		return t;
	};
	rtype.prototype.common = function() { return this.$val.common(); };
	rtype.ptr.prototype.exportedMethods = function() {
		var t, ut;
		t = this;
		ut = t.uncommon();
		if (ut === ptrType$5.nil) {
			return sliceType$5.nil;
		}
		return ut.exportedMethods();
	};
	rtype.prototype.exportedMethods = function() { return this.$val.exportedMethods(); };
	rtype.ptr.prototype.NumMethod = function() {
		var t, tt;
		t = this;
		if (t.Kind() === 20) {
			tt = (t.kindType);
			return tt.NumMethod();
		}
		return t.exportedMethods().$length;
	};
	rtype.prototype.NumMethod = function() { return this.$val.NumMethod(); };
	rtype.ptr.prototype.MethodByName = function(name$1) {
		var _i, _r, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, i, m, name$1, ok, p, t, tt, ut, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; i = $f.i; m = $f.m; name$1 = $f.name$1; ok = $f.ok; p = $f.p; t = $f.t; tt = $f.tt; ut = $f.ut; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
		ok = false;
		t = this;
		if (t.Kind() === 20) {
			tt = (t.kindType);
			_tuple = tt.MethodByName(name$1);
			Method.copy(m, _tuple[0]);
			ok = _tuple[1];
			$s = -1; return [m, ok];
		}
		ut = t.uncommon();
		if (ut === ptrType$5.nil) {
			_tmp = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
			_tmp$1 = false;
			Method.copy(m, _tmp);
			ok = _tmp$1;
			$s = -1; return [m, ok];
		}
		_ref = ut.exportedMethods();
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			p = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), method);
			/* */ if ($clone(t.nameOff(p.name), name).name() === name$1) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if ($clone(t.nameOff(p.name), name).name() === name$1) { */ case 3:
				_r = t.Method(i); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tmp$2 = $clone(_r, Method);
				_tmp$3 = true;
				Method.copy(m, _tmp$2);
				ok = _tmp$3;
				$s = -1; return [m, ok];
			/* } */ case 4:
			_i++;
		/* } */ $s = 1; continue; case 2:
		_tmp$4 = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
		_tmp$5 = false;
		Method.copy(m, _tmp$4);
		ok = _tmp$5;
		$s = -1; return [m, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.MethodByName }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.i = i; $f.m = m; $f.name$1 = name$1; $f.ok = ok; $f.p = p; $f.t = t; $f.tt = tt; $f.ut = ut; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.MethodByName = function(name$1) { return this.$val.MethodByName(name$1); };
	rtype.ptr.prototype.PkgPath = function() {
		var t, ut;
		t = this;
		if (((t.tflag & 4) >>> 0) === 0) {
			return "";
		}
		ut = t.uncommon();
		if (ut === ptrType$5.nil) {
			return "";
		}
		return $clone(t.nameOff(ut.pkgPath), name).name();
	};
	rtype.prototype.PkgPath = function() { return this.$val.PkgPath(); };
	rtype.ptr.prototype.Name = function() {
		var i, s, t;
		t = this;
		if (((t.tflag & 4) >>> 0) === 0) {
			return "";
		}
		s = t.String();
		i = s.length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if (s.charCodeAt(i) === 46) {
				break;
			}
			i = i - (1) >> 0;
		}
		return $substring(s, (i + 1 >> 0));
	};
	rtype.prototype.Name = function() { return this.$val.Name(); };
	rtype.ptr.prototype.ChanDir = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 18))) {
			$panic(new $String("reflect: ChanDir of non-chan type"));
		}
		tt = (t.kindType);
		return ((tt.dir >> 0));
	};
	rtype.prototype.ChanDir = function() { return this.$val.ChanDir(); };
	rtype.ptr.prototype.IsVariadic = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			$panic(new $String("reflect: IsVariadic of non-func type"));
		}
		tt = (t.kindType);
		return !((((tt.outCount & 32768) >>> 0) === 0));
	};
	rtype.prototype.IsVariadic = function() { return this.$val.IsVariadic(); };
	rtype.ptr.prototype.Elem = function() {
		var _1, t, tt, tt$1, tt$2, tt$3, tt$4;
		t = this;
		_1 = t.Kind();
		if (_1 === (17)) {
			tt = (t.kindType);
			return toType(tt.elem);
		} else if (_1 === (18)) {
			tt$1 = (t.kindType);
			return toType(tt$1.elem);
		} else if (_1 === (21)) {
			tt$2 = (t.kindType);
			return toType(tt$2.elem);
		} else if (_1 === (22)) {
			tt$3 = (t.kindType);
			return toType(tt$3.elem);
		} else if (_1 === (23)) {
			tt$4 = (t.kindType);
			return toType(tt$4.elem);
		}
		$panic(new $String("reflect: Elem of invalid type"));
	};
	rtype.prototype.Elem = function() { return this.$val.Elem(); };
	rtype.ptr.prototype.Field = function(i) {
		var i, t, tt;
		t = this;
		if (!((t.Kind() === 25))) {
			$panic(new $String("reflect: Field of non-struct type"));
		}
		tt = (t.kindType);
		return tt.Field(i);
	};
	rtype.prototype.Field = function(i) { return this.$val.Field(i); };
	rtype.ptr.prototype.FieldByIndex = function(index) {
		var _r, index, t, tt, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; index = $f.index; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (!((t.Kind() === 25))) {
			$panic(new $String("reflect: FieldByIndex of non-struct type"));
		}
		tt = (t.kindType);
		_r = tt.FieldByIndex(index); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.FieldByIndex }; } $f._r = _r; $f.index = index; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.FieldByIndex = function(index) { return this.$val.FieldByIndex(index); };
	rtype.ptr.prototype.FieldByName = function(name$1) {
		var _r, name$1, t, tt, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; name$1 = $f.name$1; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (!((t.Kind() === 25))) {
			$panic(new $String("reflect: FieldByName of non-struct type"));
		}
		tt = (t.kindType);
		_r = tt.FieldByName(name$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.FieldByName }; } $f._r = _r; $f.name$1 = name$1; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.FieldByName = function(name$1) { return this.$val.FieldByName(name$1); };
	rtype.ptr.prototype.FieldByNameFunc = function(match) {
		var _r, match, t, tt, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; match = $f.match; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (!((t.Kind() === 25))) {
			$panic(new $String("reflect: FieldByNameFunc of non-struct type"));
		}
		tt = (t.kindType);
		_r = tt.FieldByNameFunc(match); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.FieldByNameFunc }; } $f._r = _r; $f.match = match; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.FieldByNameFunc = function(match) { return this.$val.FieldByNameFunc(match); };
	rtype.ptr.prototype.In = function(i) {
		var i, t, tt, x;
		t = this;
		if (!((t.Kind() === 19))) {
			$panic(new $String("reflect: In of non-func type"));
		}
		tt = (t.kindType);
		return toType((x = tt.in$(), ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])));
	};
	rtype.prototype.In = function(i) { return this.$val.In(i); };
	rtype.ptr.prototype.Key = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 21))) {
			$panic(new $String("reflect: Key of non-map type"));
		}
		tt = (t.kindType);
		return toType(tt.key);
	};
	rtype.prototype.Key = function() { return this.$val.Key(); };
	rtype.ptr.prototype.Len = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 17))) {
			$panic(new $String("reflect: Len of non-array type"));
		}
		tt = (t.kindType);
		return ((tt.len >> 0));
	};
	rtype.prototype.Len = function() { return this.$val.Len(); };
	rtype.ptr.prototype.NumField = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 25))) {
			$panic(new $String("reflect: NumField of non-struct type"));
		}
		tt = (t.kindType);
		return tt.fields.$length;
	};
	rtype.prototype.NumField = function() { return this.$val.NumField(); };
	rtype.ptr.prototype.NumIn = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			$panic(new $String("reflect: NumIn of non-func type"));
		}
		tt = (t.kindType);
		return ((tt.inCount >> 0));
	};
	rtype.prototype.NumIn = function() { return this.$val.NumIn(); };
	rtype.ptr.prototype.NumOut = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			$panic(new $String("reflect: NumOut of non-func type"));
		}
		tt = (t.kindType);
		return tt.out().$length;
	};
	rtype.prototype.NumOut = function() { return this.$val.NumOut(); };
	rtype.ptr.prototype.Out = function(i) {
		var i, t, tt, x;
		t = this;
		if (!((t.Kind() === 19))) {
			$panic(new $String("reflect: Out of non-func type"));
		}
		tt = (t.kindType);
		return toType((x = tt.out(), ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])));
	};
	rtype.prototype.Out = function(i) { return this.$val.Out(i); };
	ChanDir.prototype.String = function() {
		var _1, d;
		d = this.$val;
		_1 = d;
		if (_1 === (2)) {
			return "chan<-";
		} else if (_1 === (1)) {
			return "<-chan";
		} else if (_1 === (3)) {
			return "chan";
		}
		return "ChanDir" + strconv.Itoa(((d >> 0)));
	};
	$ptrType(ChanDir).prototype.String = function() { return new ChanDir(this.$get()).String(); };
	interfaceType.ptr.prototype.Method = function(i) {
		var i, m, p, pname, t, x;
		m = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
		t = this;
		if (i < 0 || i >= t.methods.$length) {
			return m;
		}
		p = (x = t.methods, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
		pname = $clone(t.rtype.nameOff(p.name), name);
		m.Name = $clone(pname, name).name();
		if (!$clone(pname, name).isExported()) {
			m.PkgPath = $clone(pname, name).pkgPath();
			if (m.PkgPath === "") {
				m.PkgPath = $clone(t.pkgPath, name).name();
			}
		}
		m.Type = toType(t.rtype.typeOff(p.typ));
		m.Index = i;
		return m;
	};
	interfaceType.prototype.Method = function(i) { return this.$val.Method(i); };
	interfaceType.ptr.prototype.NumMethod = function() {
		var t;
		t = this;
		return t.methods.$length;
	};
	interfaceType.prototype.NumMethod = function() { return this.$val.NumMethod(); };
	interfaceType.ptr.prototype.MethodByName = function(name$1) {
		var _i, _ref, _tmp, _tmp$1, i, m, name$1, ok, p, t, x;
		m = new Method.ptr("", "", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);
		ok = false;
		t = this;
		if (t === ptrType$9.nil) {
			return [m, ok];
		}
		p = ptrType$10.nil;
		_ref = t.methods;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			p = (x = t.methods, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if ($clone(t.rtype.nameOff(p.name), name).name() === name$1) {
				_tmp = $clone(t.Method(i), Method);
				_tmp$1 = true;
				Method.copy(m, _tmp);
				ok = _tmp$1;
				return [m, ok];
			}
			_i++;
		}
		return [m, ok];
	};
	interfaceType.prototype.MethodByName = function(name$1) { return this.$val.MethodByName(name$1); };
	StructTag.prototype.Get = function(key) {
		var _tuple, key, tag, v;
		tag = this.$val;
		_tuple = new StructTag(tag).Lookup(key);
		v = _tuple[0];
		return v;
	};
	$ptrType(StructTag).prototype.Get = function(key) { return new StructTag(this.$get()).Get(key); };
	StructTag.prototype.Lookup = function(key) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, err, i, key, name$1, ok, qvalue, tag, value, value$1;
		value = "";
		ok = false;
		tag = this.$val;
		while (true) {
			if (!(!(tag === ""))) { break; }
			i = 0;
			while (true) {
				if (!(i < tag.length && (tag.charCodeAt(i) === 32))) { break; }
				i = i + (1) >> 0;
			}
			tag = $substring(tag, i);
			if (tag === "") {
				break;
			}
			i = 0;
			while (true) {
				if (!(i < tag.length && tag.charCodeAt(i) > 32 && !((tag.charCodeAt(i) === 58)) && !((tag.charCodeAt(i) === 34)) && !((tag.charCodeAt(i) === 127)))) { break; }
				i = i + (1) >> 0;
			}
			if ((i === 0) || (i + 1 >> 0) >= tag.length || !((tag.charCodeAt(i) === 58)) || !((tag.charCodeAt((i + 1 >> 0)) === 34))) {
				break;
			}
			name$1 = ($substring(tag, 0, i));
			tag = $substring(tag, (i + 1 >> 0));
			i = 1;
			while (true) {
				if (!(i < tag.length && !((tag.charCodeAt(i) === 34)))) { break; }
				if (tag.charCodeAt(i) === 92) {
					i = i + (1) >> 0;
				}
				i = i + (1) >> 0;
			}
			if (i >= tag.length) {
				break;
			}
			qvalue = ($substring(tag, 0, (i + 1 >> 0)));
			tag = $substring(tag, (i + 1 >> 0));
			if (key === name$1) {
				_tuple = strconv.Unquote(qvalue);
				value$1 = _tuple[0];
				err = _tuple[1];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					break;
				}
				_tmp = value$1;
				_tmp$1 = true;
				value = _tmp;
				ok = _tmp$1;
				return [value, ok];
			}
		}
		_tmp$2 = "";
		_tmp$3 = false;
		value = _tmp$2;
		ok = _tmp$3;
		return [value, ok];
	};
	$ptrType(StructTag).prototype.Lookup = function(key) { return new StructTag(this.$get()).Lookup(key); };
	structType.ptr.prototype.Field = function(i) {
		var f, i, p, t, tag, x;
		f = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$13.nil, false);
		t = this;
		if (i < 0 || i >= t.fields.$length) {
			$panic(new $String("reflect: Field index out of bounds"));
		}
		p = (x = t.fields, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
		f.Type = toType(p.typ);
		f.Name = $clone(p.name, name).name();
		f.Anonymous = p.embedded();
		if (!$clone(p.name, name).isExported()) {
			f.PkgPath = $clone(t.pkgPath, name).name();
		}
		tag = $clone(p.name, name).tag();
		if (!(tag === "")) {
			f.Tag = (tag);
		}
		f.Offset = p.offset();
		f.Index = new sliceType$13([i]);
		return f;
	};
	structType.prototype.Field = function(i) { return this.$val.Field(i); };
	structType.ptr.prototype.FieldByIndex = function(index) {
		var _i, _r, _r$1, _r$2, _r$3, _r$4, _ref, _v, f, ft, i, index, t, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; _v = $f._v; f = $f.f; ft = $f.ft; i = $f.i; index = $f.index; t = $f.t; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$13.nil, false);
		t = this;
		f.Type = toType(t.rtype);
		_ref = index;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			x = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			/* */ if (i > 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (i > 0) { */ case 3:
				ft = f.Type;
				_r = ft.Kind(); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				if (!(_r === 22)) { _v = false; $s = 7; continue s; }
				_r$1 = ft.Elem(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$2 = _r$1.Kind(); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_v = _r$2 === 25; case 7:
				/* */ if (_v) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (_v) { */ case 5:
					_r$3 = ft.Elem(); /* */ $s = 11; case 11: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					ft = _r$3;
				/* } */ case 6:
				f.Type = ft;
			/* } */ case 4:
			_r$4 = f.Type.Field(x); /* */ $s = 12; case 12: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			StructField.copy(f, _r$4);
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return f;
		/* */ } return; } if ($f === undefined) { $f = { $blk: structType.ptr.prototype.FieldByIndex }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f._v = _v; $f.f = f; $f.ft = ft; $f.i = i; $f.index = index; $f.t = t; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	structType.prototype.FieldByIndex = function(index) { return this.$val.FieldByIndex(index); };
	structType.ptr.prototype.FieldByNameFunc = function(match) {
		var _entry, _entry$1, _entry$2, _entry$3, _i, _i$1, _key, _key$1, _key$2, _key$3, _r, _r$1, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, count, current, f, fname, i, index, match, next, nextCount, ntyp, ok, result, scan, styp, t, t$1, visited, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _i = $f._i; _i$1 = $f._i$1; _key = $f._key; _key$1 = $f._key$1; _key$2 = $f._key$2; _key$3 = $f._key$3; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; count = $f.count; current = $f.current; f = $f.f; fname = $f.fname; i = $f.i; index = $f.index; match = $f.match; next = $f.next; nextCount = $f.nextCount; ntyp = $f.ntyp; ok = $f.ok; result = $f.result; scan = $f.scan; styp = $f.styp; t = $f.t; t$1 = $f.t$1; visited = $f.visited; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$13.nil, false);
		ok = false;
		t = this;
		current = new sliceType$14([]);
		next = new sliceType$14([new fieldScan.ptr(t, sliceType$13.nil)]);
		nextCount = false;
		visited = $makeMap(ptrType$11.keyFor, []);
		/* while (true) { */ case 1:
			/* if (!(next.$length > 0)) { break; } */ if(!(next.$length > 0)) { $s = 2; continue; }
			_tmp = next;
			_tmp$1 = $subslice(current, 0, 0);
			current = _tmp;
			next = _tmp$1;
			count = nextCount;
			nextCount = false;
			_ref = current;
			_i = 0;
			/* while (true) { */ case 3:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }
				scan = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), fieldScan);
				t$1 = scan.typ;
				/* */ if ((_entry = visited[ptrType$11.keyFor(t$1)], _entry !== undefined ? _entry.v : false)) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if ((_entry = visited[ptrType$11.keyFor(t$1)], _entry !== undefined ? _entry.v : false)) { */ case 5:
					_i++;
					/* continue; */ $s = 3; continue;
				/* } */ case 6:
				_key = t$1; (visited || $throwRuntimeError("assignment to entry in nil map"))[ptrType$11.keyFor(_key)] = { k: _key, v: true };
				_ref$1 = t$1.fields;
				_i$1 = 0;
				/* while (true) { */ case 7:
					/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 8; continue; }
					i = _i$1;
					f = (x = t$1.fields, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
					fname = $clone(f.name, name).name();
					ntyp = ptrType$1.nil;
					/* */ if (f.embedded()) { $s = 9; continue; }
					/* */ $s = 10; continue;
					/* if (f.embedded()) { */ case 9:
						ntyp = f.typ;
						/* */ if (ntyp.Kind() === 22) { $s = 11; continue; }
						/* */ $s = 12; continue;
						/* if (ntyp.Kind() === 22) { */ case 11:
							_r = ntyp.Elem().common(); /* */ $s = 13; case 13: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
							ntyp = _r;
						/* } */ case 12:
					/* } */ case 10:
					_r$1 = match(fname); /* */ $s = 16; case 16: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					/* */ if (_r$1) { $s = 14; continue; }
					/* */ $s = 15; continue;
					/* if (_r$1) { */ case 14:
						if ((_entry$1 = count[ptrType$11.keyFor(t$1)], _entry$1 !== undefined ? _entry$1.v : 0) > 1 || ok) {
							_tmp$2 = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$13.nil, false);
							_tmp$3 = false;
							StructField.copy(result, _tmp$2);
							ok = _tmp$3;
							$s = -1; return [result, ok];
						}
						StructField.copy(result, t$1.Field(i));
						result.Index = sliceType$13.nil;
						result.Index = $appendSlice(result.Index, scan.index);
						result.Index = $append(result.Index, i);
						ok = true;
						_i$1++;
						/* continue; */ $s = 7; continue;
					/* } */ case 15:
					if (ok || ntyp === ptrType$1.nil || !((ntyp.Kind() === 25))) {
						_i$1++;
						/* continue; */ $s = 7; continue;
					}
					styp = (ntyp.kindType);
					if ((_entry$2 = nextCount[ptrType$11.keyFor(styp)], _entry$2 !== undefined ? _entry$2.v : 0) > 0) {
						_key$1 = styp; (nextCount || $throwRuntimeError("assignment to entry in nil map"))[ptrType$11.keyFor(_key$1)] = { k: _key$1, v: 2 };
						_i$1++;
						/* continue; */ $s = 7; continue;
					}
					if (nextCount === false) {
						nextCount = $makeMap(ptrType$11.keyFor, []);
					}
					_key$2 = styp; (nextCount || $throwRuntimeError("assignment to entry in nil map"))[ptrType$11.keyFor(_key$2)] = { k: _key$2, v: 1 };
					if ((_entry$3 = count[ptrType$11.keyFor(t$1)], _entry$3 !== undefined ? _entry$3.v : 0) > 1) {
						_key$3 = styp; (nextCount || $throwRuntimeError("assignment to entry in nil map"))[ptrType$11.keyFor(_key$3)] = { k: _key$3, v: 2 };
					}
					index = sliceType$13.nil;
					index = $appendSlice(index, scan.index);
					index = $append(index, i);
					next = $append(next, new fieldScan.ptr(styp, index));
					_i$1++;
				/* } */ $s = 7; continue; case 8:
				_i++;
			/* } */ $s = 3; continue; case 4:
			if (ok) {
				/* break; */ $s = 2; continue;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [result, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: structType.ptr.prototype.FieldByNameFunc }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._i = _i; $f._i$1 = _i$1; $f._key = _key; $f._key$1 = _key$1; $f._key$2 = _key$2; $f._key$3 = _key$3; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.count = count; $f.current = current; $f.f = f; $f.fname = fname; $f.i = i; $f.index = index; $f.match = match; $f.next = next; $f.nextCount = nextCount; $f.ntyp = ntyp; $f.ok = ok; $f.result = result; $f.scan = scan; $f.styp = styp; $f.t = t; $f.t$1 = t$1; $f.visited = visited; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	structType.prototype.FieldByNameFunc = function(match) { return this.$val.FieldByNameFunc(match); };
	structType.ptr.prototype.FieldByName = function(name$1) {
		var _i, _r, _ref, _tmp, _tmp$1, _tuple, f, hasEmbeds, i, name$1, present, t, tf, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; f = $f.f; hasEmbeds = $f.hasEmbeds; i = $f.i; name$1 = $f.name$1; present = $f.present; t = $f.t; tf = $f.tf; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		name$1 = [name$1];
		f = new StructField.ptr("", "", $ifaceNil, "", 0, sliceType$13.nil, false);
		present = false;
		t = this;
		hasEmbeds = false;
		if (!(name$1[0] === "")) {
			_ref = t.fields;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				tf = (x = t.fields, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
				if ($clone(tf.name, name).name() === name$1[0]) {
					_tmp = $clone(t.Field(i), StructField);
					_tmp$1 = true;
					StructField.copy(f, _tmp);
					present = _tmp$1;
					$s = -1; return [f, present];
				}
				if (tf.embedded()) {
					hasEmbeds = true;
				}
				_i++;
			}
		}
		if (!hasEmbeds) {
			$s = -1; return [f, present];
		}
		_r = t.FieldByNameFunc((function(name$1) { return function(s) {
			var s;
			return s === name$1[0];
		}; })(name$1)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		StructField.copy(f, _tuple[0]);
		present = _tuple[1];
		$s = -1; return [f, present];
		/* */ } return; } if ($f === undefined) { $f = { $blk: structType.ptr.prototype.FieldByName }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.f = f; $f.hasEmbeds = hasEmbeds; $f.i = i; $f.name$1 = name$1; $f.present = present; $f.t = t; $f.tf = tf; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	structType.prototype.FieldByName = function(name$1) { return this.$val.FieldByName(name$1); };
	PtrTo = function(t) {
		var t;
		return $assertType(t, ptrType$1).ptrTo();
	};
	$pkg.PtrTo = PtrTo;
	rtype.ptr.prototype.Implements = function(u) {
		var _r, t, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if ($interfaceIsEqual(u, $ifaceNil)) {
			$panic(new $String("reflect: nil type passed to Type.Implements"));
		}
		_r = u.Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 20))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 20))) { */ case 1:
			$panic(new $String("reflect: non-interface type passed to Type.Implements"));
		/* } */ case 2:
		$s = -1; return implements$1($assertType(u, ptrType$1), t);
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.Implements }; } $f._r = _r; $f.t = t; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.Implements = function(u) { return this.$val.Implements(u); };
	rtype.ptr.prototype.AssignableTo = function(u) {
		var _r, t, u, uu, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; u = $f.u; uu = $f.uu; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if ($interfaceIsEqual(u, $ifaceNil)) {
			$panic(new $String("reflect: nil type passed to Type.AssignableTo"));
		}
		uu = $assertType(u, ptrType$1);
		_r = directlyAssignable(uu, t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r || implements$1(uu, t);
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.AssignableTo }; } $f._r = _r; $f.t = t; $f.u = u; $f.uu = uu; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.AssignableTo = function(u) { return this.$val.AssignableTo(u); };
	rtype.ptr.prototype.ConvertibleTo = function(u) {
		var _r, t, u, uu, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; u = $f.u; uu = $f.uu; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if ($interfaceIsEqual(u, $ifaceNil)) {
			$panic(new $String("reflect: nil type passed to Type.ConvertibleTo"));
		}
		uu = $assertType(u, ptrType$1);
		_r = convertOp(uu, t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return !(_r === $throwNilPointerError);
		/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.ConvertibleTo }; } $f._r = _r; $f.t = t; $f.u = u; $f.uu = uu; $f.$s = $s; $f.$r = $r; return $f;
	};
	rtype.prototype.ConvertibleTo = function(u) { return this.$val.ConvertibleTo(u); };
	implements$1 = function(T, V) {
		var T, V, i, i$1, j, j$1, t, tm, tm$1, tmName, tmName$1, tmPkgPath, tmPkgPath$1, v, v$1, vm, vm$1, vmName, vmName$1, vmPkgPath, vmPkgPath$1, vmethods, x, x$1, x$2;
		if (!((T.Kind() === 20))) {
			return false;
		}
		t = (T.kindType);
		if (t.methods.$length === 0) {
			return true;
		}
		if (V.Kind() === 20) {
			v = (V.kindType);
			i = 0;
			j = 0;
			while (true) {
				if (!(j < v.methods.$length)) { break; }
				tm = (x = t.methods, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
				tmName = $clone(t.rtype.nameOff(tm.name), name);
				vm = (x$1 = v.methods, ((j < 0 || j >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + j]));
				vmName = $clone(V.nameOff(vm.name), name);
				if ($clone(vmName, name).name() === $clone(tmName, name).name() && V.typeOff(vm.typ) === t.rtype.typeOff(tm.typ)) {
					if (!$clone(tmName, name).isExported()) {
						tmPkgPath = $clone(tmName, name).pkgPath();
						if (tmPkgPath === "") {
							tmPkgPath = $clone(t.pkgPath, name).name();
						}
						vmPkgPath = $clone(vmName, name).pkgPath();
						if (vmPkgPath === "") {
							vmPkgPath = $clone(v.pkgPath, name).name();
						}
						if (!(tmPkgPath === vmPkgPath)) {
							j = j + (1) >> 0;
							continue;
						}
					}
					i = i + (1) >> 0;
					if (i >= t.methods.$length) {
						return true;
					}
				}
				j = j + (1) >> 0;
			}
			return false;
		}
		v$1 = V.uncommon();
		if (v$1 === ptrType$5.nil) {
			return false;
		}
		i$1 = 0;
		vmethods = v$1.methods();
		j$1 = 0;
		while (true) {
			if (!(j$1 < ((v$1.mcount >> 0)))) { break; }
			tm$1 = (x$2 = t.methods, ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1]));
			tmName$1 = $clone(t.rtype.nameOff(tm$1.name), name);
			vm$1 = $clone(((j$1 < 0 || j$1 >= vmethods.$length) ? ($throwRuntimeError("index out of range"), undefined) : vmethods.$array[vmethods.$offset + j$1]), method);
			vmName$1 = $clone(V.nameOff(vm$1.name), name);
			if ($clone(vmName$1, name).name() === $clone(tmName$1, name).name() && V.typeOff(vm$1.mtyp) === t.rtype.typeOff(tm$1.typ)) {
				if (!$clone(tmName$1, name).isExported()) {
					tmPkgPath$1 = $clone(tmName$1, name).pkgPath();
					if (tmPkgPath$1 === "") {
						tmPkgPath$1 = $clone(t.pkgPath, name).name();
					}
					vmPkgPath$1 = $clone(vmName$1, name).pkgPath();
					if (vmPkgPath$1 === "") {
						vmPkgPath$1 = $clone(V.nameOff(v$1.pkgPath), name).name();
					}
					if (!(tmPkgPath$1 === vmPkgPath$1)) {
						j$1 = j$1 + (1) >> 0;
						continue;
					}
				}
				i$1 = i$1 + (1) >> 0;
				if (i$1 >= t.methods.$length) {
					return true;
				}
			}
			j$1 = j$1 + (1) >> 0;
		}
		return false;
	};
	directlyAssignable = function(T, V) {
		var T, V, _r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; T = $f.T; V = $f.V; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (T === V) {
			$s = -1; return true;
		}
		if (!(T.Name() === "") && !(V.Name() === "") || !((T.Kind() === V.Kind()))) {
			$s = -1; return false;
		}
		_r = haveIdenticalUnderlyingType(T, V, true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: directlyAssignable }; } $f.T = T; $f.V = V; $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;
	};
	haveIdenticalType = function(T, V, cmpTags) {
		var T, V, _arg, _arg$1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _v, cmpTags, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; T = $f.T; V = $f.V; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _v = $f._v; cmpTags = $f.cmpTags; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (cmpTags) {
			$s = -1; return $interfaceIsEqual(T, V);
		}
		_r = T.Name(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = V.Name(); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		if (!(_r === _r$1)) { _v = true; $s = 3; continue s; }
		_r$2 = T.Kind(); /* */ $s = 6; case 6: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$3 = V.Kind(); /* */ $s = 7; case 7: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_v = !((_r$2 === _r$3)); case 3:
		/* */ if (_v) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_v) { */ case 1:
			$s = -1; return false;
		/* } */ case 2:
		_r$4 = T.common(); /* */ $s = 8; case 8: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_arg = _r$4;
		_r$5 = V.common(); /* */ $s = 9; case 9: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_arg$1 = _r$5;
		_r$6 = haveIdenticalUnderlyingType(_arg, _arg$1, false); /* */ $s = 10; case 10: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		$s = -1; return _r$6;
		/* */ } return; } if ($f === undefined) { $f = { $blk: haveIdenticalType }; } $f.T = T; $f.V = V; $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._v = _v; $f.cmpTags = cmpTags; $f.$s = $s; $f.$r = $r; return $f;
	};
	haveIdenticalUnderlyingType = function(T, V, cmpTags) {
		var T, V, _1, _i, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _ref, _v, _v$1, _v$2, _v$3, cmpTags, i, i$1, i$2, kind, t, t$1, t$2, tf, v, v$1, v$2, vf, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; T = $f.T; V = $f.V; _1 = $f._1; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _ref = $f._ref; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; _v$3 = $f._v$3; cmpTags = $f.cmpTags; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; kind = $f.kind; t = $f.t; t$1 = $f.t$1; t$2 = $f.t$2; tf = $f.tf; v = $f.v; v$1 = $f.v$1; v$2 = $f.v$2; vf = $f.vf; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (T === V) {
			$s = -1; return true;
		}
		kind = T.Kind();
		if (!((kind === V.Kind()))) {
			$s = -1; return false;
		}
		if (1 <= kind && kind <= 16 || (kind === 24) || (kind === 26)) {
			$s = -1; return true;
		}
			_1 = kind;
			/* */ if (_1 === (17)) { $s = 2; continue; }
			/* */ if (_1 === (18)) { $s = 3; continue; }
			/* */ if (_1 === (19)) { $s = 4; continue; }
			/* */ if (_1 === (20)) { $s = 5; continue; }
			/* */ if (_1 === (21)) { $s = 6; continue; }
			/* */ if ((_1 === (22)) || (_1 === (23))) { $s = 7; continue; }
			/* */ if (_1 === (25)) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (_1 === (17)) { */ case 2:
				if (!(T.Len() === V.Len())) { _v = false; $s = 10; continue s; }
				_r = haveIdenticalType(T.Elem(), V.Elem(), cmpTags); /* */ $s = 11; case 11: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_v = _r; case 10:
				$s = -1; return _v;
			/* } else if (_1 === (18)) { */ case 3:
				if (!(V.ChanDir() === 3)) { _v$1 = false; $s = 14; continue s; }
				_r$1 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags); /* */ $s = 15; case 15: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_v$1 = _r$1; case 14:
				/* */ if (_v$1) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (_v$1) { */ case 12:
					$s = -1; return true;
				/* } */ case 13:
				if (!(V.ChanDir() === T.ChanDir())) { _v$2 = false; $s = 16; continue s; }
				_r$2 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags); /* */ $s = 17; case 17: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_v$2 = _r$2; case 16:
				$s = -1; return _v$2;
			/* } else if (_1 === (19)) { */ case 4:
				t = (T.kindType);
				v = (V.kindType);
				if (!((t.outCount === v.outCount)) || !((t.inCount === v.inCount))) {
					$s = -1; return false;
				}
				i = 0;
				/* while (true) { */ case 18:
					/* if (!(i < t.rtype.NumIn())) { break; } */ if(!(i < t.rtype.NumIn())) { $s = 19; continue; }
					_r$3 = haveIdenticalType(t.rtype.In(i), v.rtype.In(i), cmpTags); /* */ $s = 22; case 22: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					/* */ if (!_r$3) { $s = 20; continue; }
					/* */ $s = 21; continue;
					/* if (!_r$3) { */ case 20:
						$s = -1; return false;
					/* } */ case 21:
					i = i + (1) >> 0;
				/* } */ $s = 18; continue; case 19:
				i$1 = 0;
				/* while (true) { */ case 23:
					/* if (!(i$1 < t.rtype.NumOut())) { break; } */ if(!(i$1 < t.rtype.NumOut())) { $s = 24; continue; }
					_r$4 = haveIdenticalType(t.rtype.Out(i$1), v.rtype.Out(i$1), cmpTags); /* */ $s = 27; case 27: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					/* */ if (!_r$4) { $s = 25; continue; }
					/* */ $s = 26; continue;
					/* if (!_r$4) { */ case 25:
						$s = -1; return false;
					/* } */ case 26:
					i$1 = i$1 + (1) >> 0;
				/* } */ $s = 23; continue; case 24:
				$s = -1; return true;
			/* } else if (_1 === (20)) { */ case 5:
				t$1 = (T.kindType);
				v$1 = (V.kindType);
				if ((t$1.methods.$length === 0) && (v$1.methods.$length === 0)) {
					$s = -1; return true;
				}
				$s = -1; return false;
			/* } else if (_1 === (21)) { */ case 6:
				_r$5 = haveIdenticalType(T.Key(), V.Key(), cmpTags); /* */ $s = 29; case 29: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				if (!(_r$5)) { _v$3 = false; $s = 28; continue s; }
				_r$6 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags); /* */ $s = 30; case 30: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_v$3 = _r$6; case 28:
				$s = -1; return _v$3;
			/* } else if ((_1 === (22)) || (_1 === (23))) { */ case 7:
				_r$7 = haveIdenticalType(T.Elem(), V.Elem(), cmpTags); /* */ $s = 31; case 31: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				$s = -1; return _r$7;
			/* } else if (_1 === (25)) { */ case 8:
				t$2 = (T.kindType);
				v$2 = (V.kindType);
				if (!((t$2.fields.$length === v$2.fields.$length))) {
					$s = -1; return false;
				}
				if (!($clone(t$2.pkgPath, name).name() === $clone(v$2.pkgPath, name).name())) {
					$s = -1; return false;
				}
				_ref = t$2.fields;
				_i = 0;
				/* while (true) { */ case 32:
					/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 33; continue; }
					i$2 = _i;
					tf = (x = t$2.fields, ((i$2 < 0 || i$2 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i$2]));
					vf = (x$1 = v$2.fields, ((i$2 < 0 || i$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i$2]));
					if (!($clone(tf.name, name).name() === $clone(vf.name, name).name())) {
						$s = -1; return false;
					}
					_r$8 = haveIdenticalType(tf.typ, vf.typ, cmpTags); /* */ $s = 36; case 36: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
					/* */ if (!_r$8) { $s = 34; continue; }
					/* */ $s = 35; continue;
					/* if (!_r$8) { */ case 34:
						$s = -1; return false;
					/* } */ case 35:
					if (cmpTags && !($clone(tf.name, name).tag() === $clone(vf.name, name).tag())) {
						$s = -1; return false;
					}
					if (!((tf.offsetEmbed === vf.offsetEmbed))) {
						$s = -1; return false;
					}
					_i++;
				/* } */ $s = 32; continue; case 33:
				$s = -1; return true;
			/* } */ case 9:
		case 1:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: haveIdenticalUnderlyingType }; } $f.T = T; $f.V = V; $f._1 = _1; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._ref = _ref; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f._v$3 = _v$3; $f.cmpTags = cmpTags; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.kind = kind; $f.t = t; $f.t$1 = t$1; $f.t$2 = t$2; $f.tf = tf; $f.v = v; $f.v$1 = v$1; $f.v$2 = v$2; $f.vf = vf; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	toType = function(t) {
		var t;
		if (t === ptrType$1.nil) {
			return $ifaceNil;
		}
		return t;
	};
	ifaceIndir = function(t) {
		var t;
		return ((t.kind & 32) >>> 0) === 0;
	};
	flag.prototype.kind = function() {
		var f;
		f = this.$val;
		return ((((f & 31) >>> 0) >>> 0));
	};
	$ptrType(flag).prototype.kind = function() { return new flag(this.$get()).kind(); };
	flag.prototype.ro = function() {
		var f;
		f = this.$val;
		if (!((((f & 96) >>> 0) === 0))) {
			return 32;
		}
		return 0;
	};
	$ptrType(flag).prototype.ro = function() { return new flag(this.$get()).ro(); };
	Value.ptr.prototype.pointer = function() {
		var v;
		v = this;
		if (!((v.typ.size === 4)) || !v.typ.pointers()) {
			$panic(new $String("can't call pointer on a non-pointer Value"));
		}
		if (!((((v.flag & 128) >>> 0) === 0))) {
			return (v.ptr).$get();
		}
		return v.ptr;
	};
	Value.prototype.pointer = function() { return this.$val.pointer(); };
	ValueError.ptr.prototype.Error = function() {
		var e;
		e = this;
		if (e.Kind === 0) {
			return "reflect: call of " + e.Method + " on zero Value";
		}
		return "reflect: call of " + e.Method + " on " + new Kind(e.Kind).String() + " Value";
	};
	ValueError.prototype.Error = function() { return this.$val.Error(); };
	flag.prototype.mustBe = function(expected) {
		var expected, f;
		f = this.$val;
		if (!((new flag(f).kind() === expected))) {
			$panic(new ValueError.ptr(methodName(), new flag(f).kind()));
		}
	};
	$ptrType(flag).prototype.mustBe = function(expected) { return new flag(this.$get()).mustBe(expected); };
	flag.prototype.mustBeExported = function() {
		var f;
		f = this.$val;
		if (f === 0) {
			$panic(new ValueError.ptr(methodName(), 0));
		}
		if (!((((f & 96) >>> 0) === 0))) {
			$panic(new $String("reflect: " + methodName() + " using value obtained using unexported field"));
		}
	};
	$ptrType(flag).prototype.mustBeExported = function() { return new flag(this.$get()).mustBeExported(); };
	flag.prototype.mustBeAssignable = function() {
		var f;
		f = this.$val;
		if (f === 0) {
			$panic(new ValueError.ptr(methodName(), 0));
		}
		if (!((((f & 96) >>> 0) === 0))) {
			$panic(new $String("reflect: " + methodName() + " using value obtained using unexported field"));
		}
		if (((f & 256) >>> 0) === 0) {
			$panic(new $String("reflect: " + methodName() + " using unaddressable value"));
		}
	};
	$ptrType(flag).prototype.mustBeAssignable = function() { return new flag(this.$get()).mustBeAssignable(); };
	Value.ptr.prototype.Addr = function() {
		var v;
		v = this;
		if (((v.flag & 256) >>> 0) === 0) {
			$panic(new $String("reflect.Value.Addr of unaddressable value"));
		}
		return new Value.ptr(v.typ.ptrTo(), v.ptr, (new flag(v.flag).ro() | 22) >>> 0);
	};
	Value.prototype.Addr = function() { return this.$val.Addr(); };
	Value.ptr.prototype.Bool = function() {
		var v;
		v = this;
		new flag(v.flag).mustBe(1);
		return (v.ptr).$get();
	};
	Value.prototype.Bool = function() { return this.$val.Bool(); };
	Value.ptr.prototype.Bytes = function() {
		var _r, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(23);
		_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 8))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 8))) { */ case 1:
			$panic(new $String("reflect.Value.Bytes of non-byte slice"));
		/* } */ case 2:
		$s = -1; return (v.ptr).$get();
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Bytes }; } $f._r = _r; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Bytes = function() { return this.$val.Bytes(); };
	Value.ptr.prototype.runes = function() {
		var _r, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(23);
		_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 5))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 5))) { */ case 1:
			$panic(new $String("reflect.Value.Bytes of non-rune slice"));
		/* } */ case 2:
		$s = -1; return (v.ptr).$get();
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.runes }; } $f._r = _r; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.runes = function() { return this.$val.runes(); };
	Value.ptr.prototype.CanAddr = function() {
		var v;
		v = this;
		return !((((v.flag & 256) >>> 0) === 0));
	};
	Value.prototype.CanAddr = function() { return this.$val.CanAddr(); };
	Value.ptr.prototype.CanSet = function() {
		var v;
		v = this;
		return ((v.flag & 352) >>> 0) === 256;
	};
	Value.prototype.CanSet = function() { return this.$val.CanSet(); };
	Value.ptr.prototype.Call = function(in$1) {
		var _r, in$1, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; in$1 = $f.in$1; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(19);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).call("Call", in$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Call }; } $f._r = _r; $f.in$1 = in$1; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Call = function(in$1) { return this.$val.Call(in$1); };
	Value.ptr.prototype.CallSlice = function(in$1) {
		var _r, in$1, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; in$1 = $f.in$1; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(19);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).call("CallSlice", in$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.CallSlice }; } $f._r = _r; $f.in$1 = in$1; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.CallSlice = function(in$1) { return this.$val.CallSlice(in$1); };
	Value.ptr.prototype.Complex = function() {
		var _1, k, v, x;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (15)) {
			return ((x = (v.ptr).$get(), new $Complex128(x.$real, x.$imag)));
		} else if (_1 === (16)) {
			return (v.ptr).$get();
		}
		$panic(new ValueError.ptr("reflect.Value.Complex", new flag(v.flag).kind()));
	};
	Value.prototype.Complex = function() { return this.$val.Complex(); };
	Value.ptr.prototype.FieldByIndex = function(index) {
		var _i, _r, _r$1, _r$2, _r$3, _ref, _v, i, index, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; _v = $f._v; i = $f.i; index = $f.index; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		/* */ if (index.$length === 1) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (index.$length === 1) { */ case 1:
			_r = $clone(v, Value).Field((0 >= index.$length ? ($throwRuntimeError("index out of range"), undefined) : index.$array[index.$offset + 0])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		new flag(v.flag).mustBe(25);
		_ref = index;
		_i = 0;
		/* while (true) { */ case 4:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
			i = _i;
			x = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			/* */ if (i > 0) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (i > 0) { */ case 6:
				if (!($clone(v, Value).Kind() === 22)) { _v = false; $s = 10; continue s; }
				_r$1 = v.typ.Elem().Kind(); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_v = _r$1 === 25; case 10:
				/* */ if (_v) { $s = 8; continue; }
				/* */ $s = 9; continue;
				/* if (_v) { */ case 8:
					if ($clone(v, Value).IsNil()) {
						$panic(new $String("reflect: indirection through nil pointer to embedded struct"));
					}
					_r$2 = $clone(v, Value).Elem(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					v = _r$2;
				/* } */ case 9:
			/* } */ case 7:
			_r$3 = $clone(v, Value).Field(x); /* */ $s = 13; case 13: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			v = _r$3;
			_i++;
		/* } */ $s = 4; continue; case 5:
		$s = -1; return v;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.FieldByIndex }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f._v = _v; $f.i = i; $f.index = index; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.FieldByIndex = function(index) { return this.$val.FieldByIndex(index); };
	Value.ptr.prototype.FieldByName = function(name$1) {
		var _r, _r$1, _tuple, f, name$1, ok, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; f = $f.f; name$1 = $f.name$1; ok = $f.ok; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(25);
		_r = v.typ.FieldByName(name$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		f = $clone(_tuple[0], StructField);
		ok = _tuple[1];
		/* */ if (ok) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (ok) { */ case 2:
			_r$1 = $clone(v, Value).FieldByIndex(f.Index); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
		/* } */ case 3:
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.FieldByName }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.f = f; $f.name$1 = name$1; $f.ok = ok; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.FieldByName = function(name$1) { return this.$val.FieldByName(name$1); };
	Value.ptr.prototype.FieldByNameFunc = function(match) {
		var _r, _r$1, _tuple, f, match, ok, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; f = $f.f; match = $f.match; ok = $f.ok; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		_r = v.typ.FieldByNameFunc(match); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		f = $clone(_tuple[0], StructField);
		ok = _tuple[1];
		/* */ if (ok) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (ok) { */ case 2:
			_r$1 = $clone(v, Value).FieldByIndex(f.Index); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
		/* } */ case 3:
		$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.FieldByNameFunc }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.f = f; $f.match = match; $f.ok = ok; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.FieldByNameFunc = function(match) { return this.$val.FieldByNameFunc(match); };
	Value.ptr.prototype.Float = function() {
		var _1, k, v;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (13)) {
			return ((v.ptr).$get());
		} else if (_1 === (14)) {
			return (v.ptr).$get();
		}
		$panic(new ValueError.ptr("reflect.Value.Float", new flag(v.flag).kind()));
	};
	Value.prototype.Float = function() { return this.$val.Float(); };
	Value.ptr.prototype.Int = function() {
		var _1, k, p, v;
		v = this;
		k = new flag(v.flag).kind();
		p = v.ptr;
		_1 = k;
		if (_1 === (2)) {
			return (new $Int64(0, (p).$get()));
		} else if (_1 === (3)) {
			return (new $Int64(0, (p).$get()));
		} else if (_1 === (4)) {
			return (new $Int64(0, (p).$get()));
		} else if (_1 === (5)) {
			return (new $Int64(0, (p).$get()));
		} else if (_1 === (6)) {
			return (p).$get();
		}
		$panic(new ValueError.ptr("reflect.Value.Int", new flag(v.flag).kind()));
	};
	Value.prototype.Int = function() { return this.$val.Int(); };
	Value.ptr.prototype.CanInterface = function() {
		var v;
		v = this;
		if (v.flag === 0) {
			$panic(new ValueError.ptr("reflect.Value.CanInterface", 0));
		}
		return ((v.flag & 96) >>> 0) === 0;
	};
	Value.prototype.CanInterface = function() { return this.$val.CanInterface(); };
	Value.ptr.prototype.Interface = function() {
		var _r, i, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = $ifaceNil;
		v = this;
		_r = valueInterface($clone(v, Value), true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		$s = -1; return i;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Interface }; } $f._r = _r; $f.i = i; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Interface = function() { return this.$val.Interface(); };
	Value.ptr.prototype.IsValid = function() {
		var v;
		v = this;
		return !((v.flag === 0));
	};
	Value.prototype.IsValid = function() { return this.$val.IsValid(); };
	Value.ptr.prototype.Kind = function() {
		var v;
		v = this;
		return new flag(v.flag).kind();
	};
	Value.prototype.Kind = function() { return this.$val.Kind(); };
	Value.ptr.prototype.MapIndex = function(key) {
		var _r, e, fl, k, key, tt, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; fl = $f.fl; k = $f.k; key = $f.key; tt = $f.tt; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(21);
		tt = (v.typ.kindType);
		_r = $clone(key, Value).assignTo("reflect.Value.MapIndex", tt.key, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		key = _r;
		k = 0;
		if (!((((key.flag & 128) >>> 0) === 0))) {
			k = key.ptr;
		} else {
			k = ((key.$ptr_ptr || (key.$ptr_ptr = new ptrType$17(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, key))));
		}
		e = mapaccess(v.typ, $clone(v, Value).pointer(), k);
		if (e === 0) {
			$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		}
		typ = tt.elem;
		fl = new flag((((v.flag | key.flag) >>> 0))).ro();
		fl = (fl | (((typ.Kind() >>> 0)))) >>> 0;
		$s = -1; return copyVal(typ, fl, e);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.MapIndex }; } $f._r = _r; $f.e = e; $f.fl = fl; $f.k = k; $f.key = key; $f.tt = tt; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.MapIndex = function(key) { return this.$val.MapIndex(key); };
	Value.ptr.prototype.MapKeys = function() {
		var _r, a, fl, i, it, key, keyType, m, mlen, tt, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; fl = $f.fl; i = $f.i; it = $f.it; key = $f.key; keyType = $f.keyType; m = $f.m; mlen = $f.mlen; tt = $f.tt; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(21);
		tt = (v.typ.kindType);
		keyType = tt.key;
		fl = (new flag(v.flag).ro() | ((keyType.Kind() >>> 0))) >>> 0;
		m = $clone(v, Value).pointer();
		mlen = 0;
		if (!(m === 0)) {
			mlen = maplen(m);
		}
		it = mapiterinit(v.typ, m);
		a = $makeSlice(sliceType$9, mlen);
		i = 0;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < a.$length)) { break; } */ if(!(i < a.$length)) { $s = 2; continue; }
			_r = mapiterkey(it); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			key = _r;
			if (key === 0) {
				/* break; */ $s = 2; continue;
			}
			((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = copyVal(keyType, fl, key));
			mapiternext(it);
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return $subslice(a, 0, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.MapKeys }; } $f._r = _r; $f.a = a; $f.fl = fl; $f.i = i; $f.it = it; $f.key = key; $f.keyType = keyType; $f.m = m; $f.mlen = mlen; $f.tt = tt; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.MapKeys = function() { return this.$val.MapKeys(); };
	MapIter.ptr.prototype.Key = function() {
		var _arg, _arg$1, _arg$2, _r, _r$1, _r$2, it, ktype, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; it = $f.it; ktype = $f.ktype; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		it = this;
		if (it.it === 0) {
			$panic(new $String("MapIter.Key called before Next"));
		}
		_r = mapiterkey(it.it); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r === 0) { */ case 1:
			$panic(new $String("MapIter.Key called on exhausted iterator"));
		/* } */ case 2:
		t = (it.m.typ.kindType);
		ktype = t.key;
		_arg = ktype;
		_arg$1 = (new flag(it.m.flag).ro() | ((ktype.Kind() >>> 0))) >>> 0;
		_r$1 = mapiterkey(it.it); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_arg$2 = _r$1;
		_r$2 = copyVal(_arg, _arg$1, _arg$2); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MapIter.ptr.prototype.Key }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.it = it; $f.ktype = ktype; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	MapIter.prototype.Key = function() { return this.$val.Key(); };
	MapIter.ptr.prototype.Value = function() {
		var _arg, _arg$1, _arg$2, _r, _r$1, _r$2, it, t, vtype, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; it = $f.it; t = $f.t; vtype = $f.vtype; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		it = this;
		if (it.it === 0) {
			$panic(new $String("MapIter.Value called before Next"));
		}
		_r = mapiterkey(it.it); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r === 0) { */ case 1:
			$panic(new $String("MapIter.Value called on exhausted iterator"));
		/* } */ case 2:
		t = (it.m.typ.kindType);
		vtype = t.elem;
		_arg = vtype;
		_arg$1 = (new flag(it.m.flag).ro() | ((vtype.Kind() >>> 0))) >>> 0;
		_r$1 = mapitervalue(it.it); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_arg$2 = _r$1;
		_r$2 = copyVal(_arg, _arg$1, _arg$2); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MapIter.ptr.prototype.Value }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.it = it; $f.t = t; $f.vtype = vtype; $f.$s = $s; $f.$r = $r; return $f;
	};
	MapIter.prototype.Value = function() { return this.$val.Value(); };
	MapIter.ptr.prototype.Next = function() {
		var _r, _r$1, it, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; it = $f.it; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		it = this;
		/* */ if (it.it === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (it.it === 0) { */ case 1:
			it.it = mapiterinit(it.m.typ, $clone(it.m, Value).pointer());
			$s = 3; continue;
		/* } else { */ case 2:
			_r = mapiterkey(it.it); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === 0) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_r === 0) { */ case 4:
				$panic(new $String("MapIter.Next called on exhausted iterator"));
			/* } */ case 5:
			mapiternext(it.it);
		/* } */ case 3:
		_r$1 = mapiterkey(it.it); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return !(_r$1 === 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: MapIter.ptr.prototype.Next }; } $f._r = _r; $f._r$1 = _r$1; $f.it = it; $f.$s = $s; $f.$r = $r; return $f;
	};
	MapIter.prototype.Next = function() { return this.$val.Next(); };
	Value.ptr.prototype.MapRange = function() {
		var v;
		v = this;
		new flag(v.flag).mustBe(21);
		return new MapIter.ptr($clone(v, Value), 0);
	};
	Value.prototype.MapRange = function() { return this.$val.MapRange(); };
	copyVal = function(typ, fl, ptr) {
		var c, fl, ptr, typ;
		if (ifaceIndir(typ)) {
			c = unsafe_New(typ);
			typedmemmove(typ, c, ptr);
			return new Value.ptr(typ, c, (fl | 128) >>> 0);
		}
		return new Value.ptr(typ, (ptr).$get(), fl);
	};
	Value.ptr.prototype.Method = function(i) {
		var fl, i, v;
		v = this;
		if (v.typ === ptrType$1.nil) {
			$panic(new ValueError.ptr("reflect.Value.Method", 0));
		}
		if (!((((v.flag & 512) >>> 0) === 0)) || ((i >>> 0)) >= ((v.typ.NumMethod() >>> 0))) {
			$panic(new $String("reflect: Method index out of range"));
		}
		if ((v.typ.Kind() === 20) && $clone(v, Value).IsNil()) {
			$panic(new $String("reflect: Method on nil interface value"));
		}
		fl = (v.flag & 160) >>> 0;
		fl = (fl | (19)) >>> 0;
		fl = (fl | ((((((i >>> 0)) << 10 >>> 0) | 512) >>> 0))) >>> 0;
		return new Value.ptr(v.typ, v.ptr, fl);
	};
	Value.prototype.Method = function(i) { return this.$val.Method(i); };
	Value.ptr.prototype.NumMethod = function() {
		var v;
		v = this;
		if (v.typ === ptrType$1.nil) {
			$panic(new ValueError.ptr("reflect.Value.NumMethod", 0));
		}
		if (!((((v.flag & 512) >>> 0) === 0))) {
			return 0;
		}
		return v.typ.NumMethod();
	};
	Value.prototype.NumMethod = function() { return this.$val.NumMethod(); };
	Value.ptr.prototype.MethodByName = function(name$1) {
		var _r, _tuple, m, name$1, ok, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; m = $f.m; name$1 = $f.name$1; ok = $f.ok; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		if (v.typ === ptrType$1.nil) {
			$panic(new ValueError.ptr("reflect.Value.MethodByName", 0));
		}
		if (!((((v.flag & 512) >>> 0) === 0))) {
			$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		}
		_r = v.typ.MethodByName(name$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		m = $clone(_tuple[0], Method);
		ok = _tuple[1];
		if (!ok) {
			$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);
		}
		$s = -1; return $clone(v, Value).Method(m.Index);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.MethodByName }; } $f._r = _r; $f._tuple = _tuple; $f.m = m; $f.name$1 = name$1; $f.ok = ok; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.MethodByName = function(name$1) { return this.$val.MethodByName(name$1); };
	Value.ptr.prototype.NumField = function() {
		var tt, v;
		v = this;
		new flag(v.flag).mustBe(25);
		tt = (v.typ.kindType);
		return tt.fields.$length;
	};
	Value.prototype.NumField = function() { return this.$val.NumField(); };
	Value.ptr.prototype.OverflowComplex = function(x) {
		var _1, k, v, x;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (15)) {
			return overflowFloat32(x.$real) || overflowFloat32(x.$imag);
		} else if (_1 === (16)) {
			return false;
		}
		$panic(new ValueError.ptr("reflect.Value.OverflowComplex", new flag(v.flag).kind()));
	};
	Value.prototype.OverflowComplex = function(x) { return this.$val.OverflowComplex(x); };
	Value.ptr.prototype.OverflowFloat = function(x) {
		var _1, k, v, x;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (13)) {
			return overflowFloat32(x);
		} else if (_1 === (14)) {
			return false;
		}
		$panic(new ValueError.ptr("reflect.Value.OverflowFloat", new flag(v.flag).kind()));
	};
	Value.prototype.OverflowFloat = function(x) { return this.$val.OverflowFloat(x); };
	overflowFloat32 = function(x) {
		var x;
		if (x < 0) {
			x = -x;
		}
		return 3.4028234663852886e+38 < x && x <= 1.7976931348623157e+308;
	};
	Value.ptr.prototype.OverflowInt = function(x) {
		var _1, bitSize, k, trunc, v, x;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) {
			bitSize = $imul(v.typ.size, 8) >>> 0;
			trunc = $shiftRightInt64(($shiftLeft64(x, ((64 - bitSize >>> 0)))), ((64 - bitSize >>> 0)));
			return !((x.$high === trunc.$high && x.$low === trunc.$low));
		}
		$panic(new ValueError.ptr("reflect.Value.OverflowInt", new flag(v.flag).kind()));
	};
	Value.prototype.OverflowInt = function(x) { return this.$val.OverflowInt(x); };
	Value.ptr.prototype.OverflowUint = function(x) {
		var _1, bitSize, k, trunc, v, x;
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if ((_1 === (7)) || (_1 === (12)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11))) {
			bitSize = $imul(v.typ.size, 8) >>> 0;
			trunc = $shiftRightUint64(($shiftLeft64(x, ((64 - bitSize >>> 0)))), ((64 - bitSize >>> 0)));
			return !((x.$high === trunc.$high && x.$low === trunc.$low));
		}
		$panic(new ValueError.ptr("reflect.Value.OverflowUint", new flag(v.flag).kind()));
	};
	Value.prototype.OverflowUint = function(x) { return this.$val.OverflowUint(x); };
	Value.ptr.prototype.Recv = function() {
		var _r, _tuple, ok, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; ok = $f.ok; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = new Value.ptr(ptrType$1.nil, 0, 0);
		ok = false;
		v = this;
		new flag(v.flag).mustBe(18);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).recv(false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		x = _tuple[0];
		ok = _tuple[1];
		$s = -1; return [x, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Recv }; } $f._r = _r; $f._tuple = _tuple; $f.ok = ok; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Recv = function() { return this.$val.Recv(); };
	Value.ptr.prototype.recv = function(nb) {
		var _r, _tuple, nb, ok, p, selected, t, tt, v, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; nb = $f.nb; ok = $f.ok; p = $f.p; selected = $f.selected; t = $f.t; tt = $f.tt; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		val = new Value.ptr(ptrType$1.nil, 0, 0);
		ok = false;
		v = this;
		tt = (v.typ.kindType);
		if ((((tt.dir >> 0)) & 1) === 0) {
			$panic(new $String("reflect: recv on send-only channel"));
		}
		t = tt.elem;
		val = new Value.ptr(t, 0, ((t.Kind() >>> 0)));
		p = 0;
		if (ifaceIndir(t)) {
			p = unsafe_New(t);
			val.ptr = p;
			val.flag = (val.flag | (128)) >>> 0;
		} else {
			p = ((val.$ptr_ptr || (val.$ptr_ptr = new ptrType$17(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, val))));
		}
		_r = chanrecv($clone(v, Value).pointer(), nb, p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		selected = _tuple[0];
		ok = _tuple[1];
		if (!selected) {
			val = new Value.ptr(ptrType$1.nil, 0, 0);
		}
		$s = -1; return [val, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.recv }; } $f._r = _r; $f._tuple = _tuple; $f.nb = nb; $f.ok = ok; $f.p = p; $f.selected = selected; $f.t = t; $f.tt = tt; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.recv = function(nb) { return this.$val.recv(nb); };
	Value.ptr.prototype.Send = function(x) {
		var _r, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(18);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).send($clone(x, Value), false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Send }; } $f._r = _r; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Send = function(x) { return this.$val.Send(x); };
	Value.ptr.prototype.send = function(x, nb) {
		var _r, _r$1, nb, p, selected, tt, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; nb = $f.nb; p = $f.p; selected = $f.selected; tt = $f.tt; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		selected = false;
		v = this;
		tt = (v.typ.kindType);
		if ((((tt.dir >> 0)) & 2) === 0) {
			$panic(new $String("reflect: send on recv-only channel"));
		}
		new flag(x.flag).mustBeExported();
		_r = $clone(x, Value).assignTo("reflect.Value.Send", tt.elem, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		x = _r;
		p = 0;
		if (!((((x.flag & 128) >>> 0) === 0))) {
			p = x.ptr;
		} else {
			p = ((x.$ptr_ptr || (x.$ptr_ptr = new ptrType$17(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, x))));
		}
		_r$1 = chansend($clone(v, Value).pointer(), p, nb); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		selected = _r$1;
		$s = -1; return selected;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.send }; } $f._r = _r; $f._r$1 = _r$1; $f.nb = nb; $f.p = p; $f.selected = selected; $f.tt = tt; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.send = function(x, nb) { return this.$val.send(x, nb); };
	Value.ptr.prototype.SetBool = function(x) {
		var v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(1);
		(v.ptr).$set(x);
	};
	Value.prototype.SetBool = function(x) { return this.$val.SetBool(x); };
	Value.ptr.prototype.setRunes = function(x) {
		var _r, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(23);
		_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 5))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 5))) { */ case 1:
			$panic(new $String("reflect.Value.setRunes of non-rune slice"));
		/* } */ case 2:
		(v.ptr).$set(x);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.setRunes }; } $f._r = _r; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.setRunes = function(x) { return this.$val.setRunes(x); };
	Value.ptr.prototype.SetComplex = function(x) {
		var _1, k, v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (15)) {
			(v.ptr).$set((new $Complex64(x.$real, x.$imag)));
		} else if (_1 === (16)) {
			(v.ptr).$set(x);
		} else {
			$panic(new ValueError.ptr("reflect.Value.SetComplex", new flag(v.flag).kind()));
		}
	};
	Value.prototype.SetComplex = function(x) { return this.$val.SetComplex(x); };
	Value.ptr.prototype.SetFloat = function(x) {
		var _1, k, v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (13)) {
			(v.ptr).$set(($fround(x)));
		} else if (_1 === (14)) {
			(v.ptr).$set(x);
		} else {
			$panic(new ValueError.ptr("reflect.Value.SetFloat", new flag(v.flag).kind()));
		}
	};
	Value.prototype.SetFloat = function(x) { return this.$val.SetFloat(x); };
	Value.ptr.prototype.SetInt = function(x) {
		var _1, k, v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (2)) {
			(v.ptr).$set((((x.$low + ((x.$high >> 31) * 4294967296)) >> 0)));
		} else if (_1 === (3)) {
			(v.ptr).$set((((x.$low + ((x.$high >> 31) * 4294967296)) << 24 >> 24)));
		} else if (_1 === (4)) {
			(v.ptr).$set((((x.$low + ((x.$high >> 31) * 4294967296)) << 16 >> 16)));
		} else if (_1 === (5)) {
			(v.ptr).$set((((x.$low + ((x.$high >> 31) * 4294967296)) >> 0)));
		} else if (_1 === (6)) {
			(v.ptr).$set(x);
		} else {
			$panic(new ValueError.ptr("reflect.Value.SetInt", new flag(v.flag).kind()));
		}
	};
	Value.prototype.SetInt = function(x) { return this.$val.SetInt(x); };
	Value.ptr.prototype.SetMapIndex = function(key, val) {
		var _r, _r$1, e, k, key, tt, v, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; e = $f.e; k = $f.k; key = $f.key; tt = $f.tt; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(21);
		new flag(v.flag).mustBeExported();
		new flag(key.flag).mustBeExported();
		tt = (v.typ.kindType);
		_r = $clone(key, Value).assignTo("reflect.Value.SetMapIndex", tt.key, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		key = _r;
		k = 0;
		if (!((((key.flag & 128) >>> 0) === 0))) {
			k = key.ptr;
		} else {
			k = ((key.$ptr_ptr || (key.$ptr_ptr = new ptrType$17(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, key))));
		}
		if (val.typ === ptrType$1.nil) {
			mapdelete(v.typ, $clone(v, Value).pointer(), k);
			$s = -1; return;
		}
		new flag(val.flag).mustBeExported();
		_r$1 = $clone(val, Value).assignTo("reflect.Value.SetMapIndex", tt.elem, 0); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		val = _r$1;
		e = 0;
		if (!((((val.flag & 128) >>> 0) === 0))) {
			e = val.ptr;
		} else {
			e = ((val.$ptr_ptr || (val.$ptr_ptr = new ptrType$17(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, val))));
		}
		$r = mapassign(v.typ, $clone(v, Value).pointer(), k, e); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.SetMapIndex }; } $f._r = _r; $f._r$1 = _r$1; $f.e = e; $f.k = k; $f.key = key; $f.tt = tt; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.SetMapIndex = function(key, val) { return this.$val.SetMapIndex(key, val); };
	Value.ptr.prototype.SetUint = function(x) {
		var _1, k, v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (7)) {
			(v.ptr).$set(((x.$low >>> 0)));
		} else if (_1 === (8)) {
			(v.ptr).$set(((x.$low << 24 >>> 24)));
		} else if (_1 === (9)) {
			(v.ptr).$set(((x.$low << 16 >>> 16)));
		} else if (_1 === (10)) {
			(v.ptr).$set(((x.$low >>> 0)));
		} else if (_1 === (11)) {
			(v.ptr).$set(x);
		} else if (_1 === (12)) {
			(v.ptr).$set(((x.$low >>> 0)));
		} else {
			$panic(new ValueError.ptr("reflect.Value.SetUint", new flag(v.flag).kind()));
		}
	};
	Value.prototype.SetUint = function(x) { return this.$val.SetUint(x); };
	Value.ptr.prototype.SetPointer = function(x) {
		var v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(26);
		(v.ptr).$set(x);
	};
	Value.prototype.SetPointer = function(x) { return this.$val.SetPointer(x); };
	Value.ptr.prototype.SetString = function(x) {
		var v, x;
		v = this;
		new flag(v.flag).mustBeAssignable();
		new flag(v.flag).mustBe(24);
		(v.ptr).$set(x);
	};
	Value.prototype.SetString = function(x) { return this.$val.SetString(x); };
	Value.ptr.prototype.String = function() {
		var _1, _r, k, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; k = $f.k; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		k = new flag(v.flag).kind();
		_1 = k;
		if (_1 === (0)) {
			$s = -1; return "<invalid Value>";
		} else if (_1 === (24)) {
			$s = -1; return (v.ptr).$get();
		}
		_r = $clone(v, Value).Type().String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return "<" + _r + " Value>";
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.String }; } $f._1 = _1; $f._r = _r; $f.k = k; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.String = function() { return this.$val.String(); };
	Value.ptr.prototype.TryRecv = function() {
		var _r, _tuple, ok, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; ok = $f.ok; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = new Value.ptr(ptrType$1.nil, 0, 0);
		ok = false;
		v = this;
		new flag(v.flag).mustBe(18);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).recv(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		x = _tuple[0];
		ok = _tuple[1];
		$s = -1; return [x, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.TryRecv }; } $f._r = _r; $f._tuple = _tuple; $f.ok = ok; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.TryRecv = function() { return this.$val.TryRecv(); };
	Value.ptr.prototype.TrySend = function(x) {
		var _r, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		new flag(v.flag).mustBe(18);
		new flag(v.flag).mustBeExported();
		_r = $clone(v, Value).send($clone(x, Value), true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.TrySend }; } $f._r = _r; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.TrySend = function(x) { return this.$val.TrySend(x); };
	Value.ptr.prototype.Type = function() {
		var f, i, m, m$1, ms, tt, v, x;
		v = this;
		f = v.flag;
		if (f === 0) {
			$panic(new ValueError.ptr("reflect.Value.Type", 0));
		}
		if (((f & 512) >>> 0) === 0) {
			return v.typ;
		}
		i = ((v.flag >> 0)) >> 10 >> 0;
		if (v.typ.Kind() === 20) {
			tt = (v.typ.kindType);
			if (((i >>> 0)) >= ((tt.methods.$length >>> 0))) {
				$panic(new $String("reflect: internal error: invalid method index"));
			}
			m = (x = tt.methods, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			return v.typ.typeOff(m.typ);
		}
		ms = v.typ.exportedMethods();
		if (((i >>> 0)) >= ((ms.$length >>> 0))) {
			$panic(new $String("reflect: internal error: invalid method index"));
		}
		m$1 = $clone(((i < 0 || i >= ms.$length) ? ($throwRuntimeError("index out of range"), undefined) : ms.$array[ms.$offset + i]), method);
		return v.typ.typeOff(m$1.mtyp);
	};
	Value.prototype.Type = function() { return this.$val.Type(); };
	Value.ptr.prototype.Uint = function() {
		var _1, k, p, v, x;
		v = this;
		k = new flag(v.flag).kind();
		p = v.ptr;
		_1 = k;
		if (_1 === (7)) {
			return (new $Uint64(0, (p).$get()));
		} else if (_1 === (8)) {
			return (new $Uint64(0, (p).$get()));
		} else if (_1 === (9)) {
			return (new $Uint64(0, (p).$get()));
		} else if (_1 === (10)) {
			return (new $Uint64(0, (p).$get()));
		} else if (_1 === (11)) {
			return (p).$get();
		} else if (_1 === (12)) {
			return ((x = (p).$get(), new $Uint64(0, x.constructor === Number ? x : 1)));
		}
		$panic(new ValueError.ptr("reflect.Value.Uint", new flag(v.flag).kind()));
	};
	Value.prototype.Uint = function() { return this.$val.Uint(); };
	Value.ptr.prototype.UnsafeAddr = function() {
		var v;
		v = this;
		if (v.typ === ptrType$1.nil) {
			$panic(new ValueError.ptr("reflect.Value.UnsafeAddr", 0));
		}
		if (((v.flag & 256) >>> 0) === 0) {
			$panic(new $String("reflect.Value.UnsafeAddr of unaddressable value"));
		}
		return (v.ptr);
	};
	Value.prototype.UnsafeAddr = function() { return this.$val.UnsafeAddr(); };
	New = function(typ) {
		var fl, ptr, t, typ;
		if ($interfaceIsEqual(typ, $ifaceNil)) {
			$panic(new $String("reflect: New(nil)"));
		}
		t = $assertType(typ, ptrType$1);
		ptr = unsafe_New(t);
		fl = 22;
		return new Value.ptr(t.ptrTo(), ptr, fl);
	};
	$pkg.New = New;
	Value.ptr.prototype.Convert = function(t) {
		var _r, _r$1, _r$2, _r$3, _r$4, op, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; op = $f.op; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		/* */ if (!((((v.flag & 512) >>> 0) === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:
			_r = makeMethodValue("Convert", $clone(v, Value)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			v = _r;
		/* } */ case 2:
		_r$1 = t.common(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = convertOp(_r$1, v.typ); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		op = _r$2;
		/* */ if (op === $throwNilPointerError) { $s = 6; continue; }
		/* */ $s = 7; continue;
		/* if (op === $throwNilPointerError) { */ case 6:
			_r$3 = t.String(); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			$panic(new $String("reflect.Value.Convert: value of type " + v.typ.String() + " cannot be converted to type " + _r$3));
		/* } */ case 7:
		_r$4 = op($clone(v, Value), t); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		$s = -1; return _r$4;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Convert }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.op = op; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Convert = function(t) { return this.$val.Convert(t); };
	convertOp = function(dst, src) {
		var _1, _2, _3, _4, _5, _6, _7, _arg, _arg$1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _v, _v$1, _v$2, dst, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _6 = $f._6; _7 = $f._7; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; dst = $f.dst; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = src.Kind();
			/* */ if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { $s = 2; continue; }
			/* */ if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 3; continue; }
			/* */ if ((_1 === (13)) || (_1 === (14))) { $s = 4; continue; }
			/* */ if ((_1 === (15)) || (_1 === (16))) { $s = 5; continue; }
			/* */ if (_1 === (24)) { $s = 6; continue; }
			/* */ if (_1 === (23)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 2:
				_2 = dst.Kind();
				if ((_2 === (2)) || (_2 === (3)) || (_2 === (4)) || (_2 === (5)) || (_2 === (6)) || (_2 === (7)) || (_2 === (8)) || (_2 === (9)) || (_2 === (10)) || (_2 === (11)) || (_2 === (12))) {
					$s = -1; return cvtInt;
				} else if ((_2 === (13)) || (_2 === (14))) {
					$s = -1; return cvtIntFloat;
				} else if (_2 === (24)) {
					$s = -1; return cvtIntString;
				}
				$s = 8; continue;
			/* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 3:
				_3 = dst.Kind();
				if ((_3 === (2)) || (_3 === (3)) || (_3 === (4)) || (_3 === (5)) || (_3 === (6)) || (_3 === (7)) || (_3 === (8)) || (_3 === (9)) || (_3 === (10)) || (_3 === (11)) || (_3 === (12))) {
					$s = -1; return cvtUint;
				} else if ((_3 === (13)) || (_3 === (14))) {
					$s = -1; return cvtUintFloat;
				} else if (_3 === (24)) {
					$s = -1; return cvtUintString;
				}
				$s = 8; continue;
			/* } else if ((_1 === (13)) || (_1 === (14))) { */ case 4:
				_4 = dst.Kind();
				if ((_4 === (2)) || (_4 === (3)) || (_4 === (4)) || (_4 === (5)) || (_4 === (6))) {
					$s = -1; return cvtFloatInt;
				} else if ((_4 === (7)) || (_4 === (8)) || (_4 === (9)) || (_4 === (10)) || (_4 === (11)) || (_4 === (12))) {
					$s = -1; return cvtFloatUint;
				} else if ((_4 === (13)) || (_4 === (14))) {
					$s = -1; return cvtFloat;
				}
				$s = 8; continue;
			/* } else if ((_1 === (15)) || (_1 === (16))) { */ case 5:
				_5 = dst.Kind();
				if ((_5 === (15)) || (_5 === (16))) {
					$s = -1; return cvtComplex;
				}
				$s = 8; continue;
			/* } else if (_1 === (24)) { */ case 6:
				if (!(dst.Kind() === 23)) { _v = false; $s = 11; continue s; }
				_r = dst.Elem().PkgPath(); /* */ $s = 12; case 12: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_v = _r === ""; case 11:
				/* */ if (_v) { $s = 9; continue; }
				/* */ $s = 10; continue;
				/* if (_v) { */ case 9:
						_r$1 = dst.Elem().Kind(); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						_6 = _r$1;
						if (_6 === (8)) {
							$s = -1; return cvtStringBytes;
						} else if (_6 === (5)) {
							$s = -1; return cvtStringRunes;
						}
					case 13:
				/* } */ case 10:
				$s = 8; continue;
			/* } else if (_1 === (23)) { */ case 7:
				if (!(dst.Kind() === 24)) { _v$1 = false; $s = 17; continue s; }
				_r$2 = src.Elem().PkgPath(); /* */ $s = 18; case 18: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_v$1 = _r$2 === ""; case 17:
				/* */ if (_v$1) { $s = 15; continue; }
				/* */ $s = 16; continue;
				/* if (_v$1) { */ case 15:
						_r$3 = src.Elem().Kind(); /* */ $s = 20; case 20: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						_7 = _r$3;
						if (_7 === (8)) {
							$s = -1; return cvtBytesString;
						} else if (_7 === (5)) {
							$s = -1; return cvtRunesString;
						}
					case 19:
				/* } */ case 16:
			/* } */ case 8:
		case 1:
		_r$4 = haveIdenticalUnderlyingType(dst, src, false); /* */ $s = 23; case 23: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		/* */ if (_r$4) { $s = 21; continue; }
		/* */ $s = 22; continue;
		/* if (_r$4) { */ case 21:
			$s = -1; return cvtDirect;
		/* } */ case 22:
		if (!((dst.Kind() === 22) && dst.Name() === "" && (src.Kind() === 22) && src.Name() === "")) { _v$2 = false; $s = 26; continue s; }
		_r$5 = dst.Elem().common(); /* */ $s = 27; case 27: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_arg = _r$5;
		_r$6 = src.Elem().common(); /* */ $s = 28; case 28: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_arg$1 = _r$6;
		_r$7 = haveIdenticalUnderlyingType(_arg, _arg$1, false); /* */ $s = 29; case 29: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_v$2 = _r$7; case 26:
		/* */ if (_v$2) { $s = 24; continue; }
		/* */ $s = 25; continue;
		/* if (_v$2) { */ case 24:
			$s = -1; return cvtDirect;
		/* } */ case 25:
		if (implements$1(dst, src)) {
			if (src.Kind() === 20) {
				$s = -1; return cvtI2I;
			}
			$s = -1; return cvtT2I;
		}
		$s = -1; return $throwNilPointerError;
		/* */ } return; } if ($f === undefined) { $f = { $blk: convertOp }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._6 = _6; $f._7 = _7; $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f.dst = dst; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeFloat = function(f, v, t) {
		var _1, _r, f, ptr, t, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; f = $f.f; ptr = $f.ptr; t = $f.t; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		typ = _r;
		ptr = unsafe_New(typ);
		_1 = typ.size;
		if (_1 === (4)) {
			(ptr).$set(($fround(v)));
		} else if (_1 === (8)) {
			(ptr).$set(v);
		}
		$s = -1; return new Value.ptr(typ, ptr, (((f | 128) >>> 0) | ((typ.Kind() >>> 0))) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeFloat }; } $f._1 = _1; $f._r = _r; $f.f = f; $f.ptr = ptr; $f.t = t; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeComplex = function(f, v, t) {
		var _1, _r, f, ptr, t, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; f = $f.f; ptr = $f.ptr; t = $f.t; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		typ = _r;
		ptr = unsafe_New(typ);
		_1 = typ.size;
		if (_1 === (8)) {
			(ptr).$set((new $Complex64(v.$real, v.$imag)));
		} else if (_1 === (16)) {
			(ptr).$set(v);
		}
		$s = -1; return new Value.ptr(typ, ptr, (((f | 128) >>> 0) | ((typ.Kind() >>> 0))) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeComplex }; } $f._1 = _1; $f._r = _r; $f.f = f; $f.ptr = ptr; $f.t = t; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeString = function(f, v, t) {
		var _r, f, ret, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; ret = $f.ret; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = $clone(New(t), Value).Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		ret = _r;
		$clone(ret, Value).SetString(v);
		ret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeString }; } $f._r = _r; $f.f = f; $f.ret = ret; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeBytes = function(f, v, t) {
		var _r, f, ret, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; ret = $f.ret; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = $clone(New(t), Value).Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		ret = _r;
		$r = $clone(ret, Value).SetBytes(v); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		ret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeBytes }; } $f._r = _r; $f.f = f; $f.ret = ret; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeRunes = function(f, v, t) {
		var _r, f, ret, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; ret = $f.ret; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = $clone(New(t), Value).Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		ret = _r;
		$r = $clone(ret, Value).setRunes(v); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		ret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeRunes }; } $f._r = _r; $f.f = f; $f.ret = ret; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtInt = function(v, t) {
		var _r, t, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeInt(new flag(v.flag).ro(), ((x = $clone(v, Value).Int(), new $Uint64(x.$high, x.$low))), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtInt }; } $f._r = _r; $f.t = t; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtUint = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeInt(new flag(v.flag).ro(), $clone(v, Value).Uint(), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtUint }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtFloatInt = function(v, t) {
		var _r, t, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeInt(new flag(v.flag).ro(), ((x = (new $Int64(0, $clone(v, Value).Float())), new $Uint64(x.$high, x.$low))), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtFloatInt }; } $f._r = _r; $f.t = t; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtFloatUint = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeInt(new flag(v.flag).ro(), (new $Uint64(0, $clone(v, Value).Float())), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtFloatUint }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtIntFloat = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeFloat(new flag(v.flag).ro(), ($flatten64($clone(v, Value).Int())), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtIntFloat }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtUintFloat = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeFloat(new flag(v.flag).ro(), ($flatten64($clone(v, Value).Uint())), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtUintFloat }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtFloat = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeFloat(new flag(v.flag).ro(), $clone(v, Value).Float(), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtFloat }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtComplex = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeComplex(new flag(v.flag).ro(), $clone(v, Value).Complex(), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtComplex }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtIntString = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeString(new flag(v.flag).ro(), ($encodeRune($clone(v, Value).Int().$low)), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtIntString }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtUintString = function(v, t) {
		var _r, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = makeString(new flag(v.flag).ro(), ($encodeRune($clone(v, Value).Uint().$low)), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtUintString }; } $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtBytesString = function(v, t) {
		var _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_arg = new flag(v.flag).ro();
		_r = $clone(v, Value).Bytes(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg$1 = ($bytesToString(_r));
		_arg$2 = t;
		_r$1 = makeString(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtBytesString }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtStringBytes = function(v, t) {
		var _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_arg = new flag(v.flag).ro();
		_r = $clone(v, Value).String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg$1 = (new sliceType$15($stringToBytes(_r)));
		_arg$2 = t;
		_r$1 = makeBytes(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtStringBytes }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtRunesString = function(v, t) {
		var _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_arg = new flag(v.flag).ro();
		_r = $clone(v, Value).runes(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg$1 = ($runesToString(_r));
		_arg$2 = t;
		_r$1 = makeString(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtRunesString }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtStringRunes = function(v, t) {
		var _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_arg = new flag(v.flag).ro();
		_r = $clone(v, Value).String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg$1 = (new sliceType$18($stringToRunes(_r)));
		_arg$2 = t;
		_r$1 = makeRunes(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtStringRunes }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtT2I = function(v, typ) {
		var _r, _r$1, _r$2, _r$3, _r$4, target, typ, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; target = $f.target; typ = $f.typ; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = typ.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = unsafe_New(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		target = _r$1;
		_r$2 = valueInterface($clone(v, Value), false); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		x = _r$2;
		_r$3 = typ.NumMethod(); /* */ $s = 7; case 7: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		/* */ if (_r$3 === 0) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (_r$3 === 0) { */ case 4:
			(target).$set(x);
			$s = 6; continue;
		/* } else { */ case 5:
			ifaceE2I($assertType(typ, ptrType$1), x, target);
		/* } */ case 6:
		_r$4 = typ.common(); /* */ $s = 8; case 8: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		$s = -1; return new Value.ptr(_r$4, target, (((new flag(v.flag).ro() | 128) >>> 0) | 20) >>> 0);
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtT2I }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.target = target; $f.typ = typ; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	cvtI2I = function(v, typ) {
		var _r, _r$1, _r$2, ret, typ, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; ret = $f.ret; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if ($clone(v, Value).IsNil()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($clone(v, Value).IsNil()) { */ case 1:
			_r = Zero(typ); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			ret = _r;
			ret.flag = (ret.flag | (new flag(v.flag).ro())) >>> 0;
			$s = -1; return ret;
		/* } */ case 2:
		_r$1 = $clone(v, Value).Elem(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = cvtT2I($clone(_r$1, Value), typ); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cvtI2I }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.ret = ret; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	ptrType$5.methods = [{prop: "methods", name: "methods", pkg: "reflect", typ: $funcType([], [sliceType$5], false)}, {prop: "exportedMethods", name: "exportedMethods", pkg: "reflect", typ: $funcType([], [sliceType$5], false)}];
	ptrType$8.methods = [{prop: "in$", name: "in", pkg: "reflect", typ: $funcType([], [sliceType$2], false)}, {prop: "out", name: "out", pkg: "reflect", typ: $funcType([], [sliceType$2], false)}];
	name.methods = [{prop: "name", name: "name", pkg: "reflect", typ: $funcType([], [$String], false)}, {prop: "tag", name: "tag", pkg: "reflect", typ: $funcType([], [$String], false)}, {prop: "pkgPath", name: "pkgPath", pkg: "reflect", typ: $funcType([], [$String], false)}, {prop: "isExported", name: "isExported", pkg: "reflect", typ: $funcType([], [$Bool], false)}, {prop: "data", name: "data", pkg: "reflect", typ: $funcType([$Int, $String], [ptrType$4], false)}, {prop: "nameLen", name: "nameLen", pkg: "reflect", typ: $funcType([], [$Int], false)}, {prop: "tagLen", name: "tagLen", pkg: "reflect", typ: $funcType([], [$Int], false)}];
	ptrType$7.methods = [{prop: "skipUntilValidKey", name: "skipUntilValidKey", pkg: "reflect", typ: $funcType([], [], false)}];
	Kind.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$1.methods = [{prop: "uncommon", name: "uncommon", pkg: "reflect", typ: $funcType([], [ptrType$5], false)}, {prop: "nameOff", name: "nameOff", pkg: "reflect", typ: $funcType([nameOff], [name], false)}, {prop: "typeOff", name: "typeOff", pkg: "reflect", typ: $funcType([typeOff], [ptrType$1], false)}, {prop: "ptrTo", name: "ptrTo", pkg: "reflect", typ: $funcType([], [ptrType$1], false)}, {prop: "pointers", name: "pointers", pkg: "reflect", typ: $funcType([], [$Bool], false)}, {prop: "Comparable", name: "Comparable", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Method", name: "Method", pkg: "", typ: $funcType([$Int], [Method], false)}, {prop: "textOff", name: "textOff", pkg: "reflect", typ: $funcType([textOff], [$UnsafePointer], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Uintptr], false)}, {prop: "Bits", name: "Bits", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Align", name: "Align", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "FieldAlign", name: "FieldAlign", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Kind", name: "Kind", pkg: "", typ: $funcType([], [Kind], false)}, {prop: "common", name: "common", pkg: "reflect", typ: $funcType([], [ptrType$1], false)}, {prop: "exportedMethods", name: "exportedMethods", pkg: "reflect", typ: $funcType([], [sliceType$5], false)}, {prop: "NumMethod", name: "NumMethod", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "MethodByName", name: "MethodByName", pkg: "", typ: $funcType([$String], [Method, $Bool], false)}, {prop: "PkgPath", name: "PkgPath", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Name", name: "Name", pkg: "", typ: $funcType([], [$String], false)}, {prop: "ChanDir", name: "ChanDir", pkg: "", typ: $funcType([], [ChanDir], false)}, {prop: "IsVariadic", name: "IsVariadic", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Elem", name: "Elem", pkg: "", typ: $funcType([], [Type], false)}, {prop: "Field", name: "Field", pkg: "", typ: $funcType([$Int], [StructField], false)}, {prop: "FieldByIndex", name: "FieldByIndex", pkg: "", typ: $funcType([sliceType$13], [StructField], false)}, {prop: "FieldByName", name: "FieldByName", pkg: "", typ: $funcType([$String], [StructField, $Bool], false)}, {prop: "FieldByNameFunc", name: "FieldByNameFunc", pkg: "", typ: $funcType([funcType$3], [StructField, $Bool], false)}, {prop: "In", name: "In", pkg: "", typ: $funcType([$Int], [Type], false)}, {prop: "Key", name: "Key", pkg: "", typ: $funcType([], [Type], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumField", name: "NumField", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIn", name: "NumIn", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumOut", name: "NumOut", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Out", name: "Out", pkg: "", typ: $funcType([$Int], [Type], false)}, {prop: "Implements", name: "Implements", pkg: "", typ: $funcType([Type], [$Bool], false)}, {prop: "AssignableTo", name: "AssignableTo", pkg: "", typ: $funcType([Type], [$Bool], false)}, {prop: "ConvertibleTo", name: "ConvertibleTo", pkg: "", typ: $funcType([Type], [$Bool], false)}];
	ChanDir.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$9.methods = [{prop: "Method", name: "Method", pkg: "", typ: $funcType([$Int], [Method], false)}, {prop: "NumMethod", name: "NumMethod", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "MethodByName", name: "MethodByName", pkg: "", typ: $funcType([$String], [Method, $Bool], false)}];
	ptrType$18.methods = [{prop: "offset", name: "offset", pkg: "reflect", typ: $funcType([], [$Uintptr], false)}, {prop: "embedded", name: "embedded", pkg: "reflect", typ: $funcType([], [$Bool], false)}];
	ptrType$11.methods = [{prop: "Field", name: "Field", pkg: "", typ: $funcType([$Int], [StructField], false)}, {prop: "FieldByIndex", name: "FieldByIndex", pkg: "", typ: $funcType([sliceType$13], [StructField], false)}, {prop: "FieldByNameFunc", name: "FieldByNameFunc", pkg: "", typ: $funcType([funcType$3], [StructField, $Bool], false)}, {prop: "FieldByName", name: "FieldByName", pkg: "", typ: $funcType([$String], [StructField, $Bool], false)}];
	StructTag.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "Lookup", name: "Lookup", pkg: "", typ: $funcType([$String], [$String, $Bool], false)}];
	Value.methods = [{prop: "object", name: "object", pkg: "reflect", typ: $funcType([], [ptrType$2], false)}, {prop: "assignTo", name: "assignTo", pkg: "reflect", typ: $funcType([$String, ptrType$1, $UnsafePointer], [Value], false)}, {prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Elem", name: "Elem", pkg: "", typ: $funcType([], [Value], false)}, {prop: "Field", name: "Field", pkg: "", typ: $funcType([$Int], [Value], false)}, {prop: "Index", name: "Index", pkg: "", typ: $funcType([$Int], [Value], false)}, {prop: "InterfaceData", name: "InterfaceData", pkg: "", typ: $funcType([], [arrayType$8], false)}, {prop: "IsNil", name: "IsNil", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Pointer", name: "Pointer", pkg: "", typ: $funcType([], [$Uintptr], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([Value], [], false)}, {prop: "SetBytes", name: "SetBytes", pkg: "", typ: $funcType([sliceType$15], [], false)}, {prop: "SetCap", name: "SetCap", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "SetLen", name: "SetLen", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Slice", name: "Slice", pkg: "", typ: $funcType([$Int, $Int], [Value], false)}, {prop: "Slice3", name: "Slice3", pkg: "", typ: $funcType([$Int, $Int, $Int], [Value], false)}, {prop: "Close", name: "Close", pkg: "", typ: $funcType([], [], false)}, {prop: "call", name: "call", pkg: "reflect", typ: $funcType([$String, sliceType$9], [sliceType$9], false)}, {prop: "pointer", name: "pointer", pkg: "reflect", typ: $funcType([], [$UnsafePointer], false)}, {prop: "Addr", name: "Addr", pkg: "", typ: $funcType([], [Value], false)}, {prop: "Bool", name: "Bool", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Bytes", name: "Bytes", pkg: "", typ: $funcType([], [sliceType$15], false)}, {prop: "runes", name: "runes", pkg: "reflect", typ: $funcType([], [sliceType$18], false)}, {prop: "CanAddr", name: "CanAddr", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "CanSet", name: "CanSet", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Call", name: "Call", pkg: "", typ: $funcType([sliceType$9], [sliceType$9], false)}, {prop: "CallSlice", name: "CallSlice", pkg: "", typ: $funcType([sliceType$9], [sliceType$9], false)}, {prop: "Complex", name: "Complex", pkg: "", typ: $funcType([], [$Complex128], false)}, {prop: "FieldByIndex", name: "FieldByIndex", pkg: "", typ: $funcType([sliceType$13], [Value], false)}, {prop: "FieldByName", name: "FieldByName", pkg: "", typ: $funcType([$String], [Value], false)}, {prop: "FieldByNameFunc", name: "FieldByNameFunc", pkg: "", typ: $funcType([funcType$3], [Value], false)}, {prop: "Float", name: "Float", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "CanInterface", name: "CanInterface", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Interface", name: "Interface", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "IsValid", name: "IsValid", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Kind", name: "Kind", pkg: "", typ: $funcType([], [Kind], false)}, {prop: "MapIndex", name: "MapIndex", pkg: "", typ: $funcType([Value], [Value], false)}, {prop: "MapKeys", name: "MapKeys", pkg: "", typ: $funcType([], [sliceType$9], false)}, {prop: "MapRange", name: "MapRange", pkg: "", typ: $funcType([], [ptrType$19], false)}, {prop: "Method", name: "Method", pkg: "", typ: $funcType([$Int], [Value], false)}, {prop: "NumMethod", name: "NumMethod", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "MethodByName", name: "MethodByName", pkg: "", typ: $funcType([$String], [Value], false)}, {prop: "NumField", name: "NumField", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "OverflowComplex", name: "OverflowComplex", pkg: "", typ: $funcType([$Complex128], [$Bool], false)}, {prop: "OverflowFloat", name: "OverflowFloat", pkg: "", typ: $funcType([$Float64], [$Bool], false)}, {prop: "OverflowInt", name: "OverflowInt", pkg: "", typ: $funcType([$Int64], [$Bool], false)}, {prop: "OverflowUint", name: "OverflowUint", pkg: "", typ: $funcType([$Uint64], [$Bool], false)}, {prop: "Recv", name: "Recv", pkg: "", typ: $funcType([], [Value, $Bool], false)}, {prop: "recv", name: "recv", pkg: "reflect", typ: $funcType([$Bool], [Value, $Bool], false)}, {prop: "Send", name: "Send", pkg: "", typ: $funcType([Value], [], false)}, {prop: "send", name: "send", pkg: "reflect", typ: $funcType([Value, $Bool], [$Bool], false)}, {prop: "SetBool", name: "SetBool", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "setRunes", name: "setRunes", pkg: "reflect", typ: $funcType([sliceType$18], [], false)}, {prop: "SetComplex", name: "SetComplex", pkg: "", typ: $funcType([$Complex128], [], false)}, {prop: "SetFloat", name: "SetFloat", pkg: "", typ: $funcType([$Float64], [], false)}, {prop: "SetInt", name: "SetInt", pkg: "", typ: $funcType([$Int64], [], false)}, {prop: "SetMapIndex", name: "SetMapIndex", pkg: "", typ: $funcType([Value, Value], [], false)}, {prop: "SetUint", name: "SetUint", pkg: "", typ: $funcType([$Uint64], [], false)}, {prop: "SetPointer", name: "SetPointer", pkg: "", typ: $funcType([$UnsafePointer], [], false)}, {prop: "SetString", name: "SetString", pkg: "", typ: $funcType([$String], [], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "TryRecv", name: "TryRecv", pkg: "", typ: $funcType([], [Value, $Bool], false)}, {prop: "TrySend", name: "TrySend", pkg: "", typ: $funcType([Value], [$Bool], false)}, {prop: "Type", name: "Type", pkg: "", typ: $funcType([], [Type], false)}, {prop: "Uint", name: "Uint", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "UnsafeAddr", name: "UnsafeAddr", pkg: "", typ: $funcType([], [$Uintptr], false)}, {prop: "Convert", name: "Convert", pkg: "", typ: $funcType([Type], [Value], false)}];
	flag.methods = [{prop: "kind", name: "kind", pkg: "reflect", typ: $funcType([], [Kind], false)}, {prop: "ro", name: "ro", pkg: "reflect", typ: $funcType([], [flag], false)}, {prop: "mustBe", name: "mustBe", pkg: "reflect", typ: $funcType([Kind], [], false)}, {prop: "mustBeExported", name: "mustBeExported", pkg: "reflect", typ: $funcType([], [], false)}, {prop: "mustBeAssignable", name: "mustBeAssignable", pkg: "reflect", typ: $funcType([], [], false)}];
	ptrType$20.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$19.methods = [{prop: "Key", name: "Key", pkg: "", typ: $funcType([], [Value], false)}, {prop: "Value", name: "Value", pkg: "", typ: $funcType([], [Value], false)}, {prop: "Next", name: "Next", pkg: "", typ: $funcType([], [$Bool], false)}];
	uncommonType.init("reflect", [{prop: "pkgPath", name: "pkgPath", embedded: false, exported: false, typ: nameOff, tag: ""}, {prop: "mcount", name: "mcount", embedded: false, exported: false, typ: $Uint16, tag: ""}, {prop: "xcount", name: "xcount", embedded: false, exported: false, typ: $Uint16, tag: ""}, {prop: "moff", name: "moff", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "_methods", name: "_methods", embedded: false, exported: false, typ: sliceType$5, tag: ""}]);
	funcType.init("reflect", [{prop: "rtype", name: "rtype", embedded: true, exported: false, typ: rtype, tag: "reflect:\"func\""}, {prop: "inCount", name: "inCount", embedded: false, exported: false, typ: $Uint16, tag: ""}, {prop: "outCount", name: "outCount", embedded: false, exported: false, typ: $Uint16, tag: ""}, {prop: "_in", name: "_in", embedded: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "_out", name: "_out", embedded: false, exported: false, typ: sliceType$2, tag: ""}]);
	name.init("reflect", [{prop: "bytes", name: "bytes", embedded: false, exported: false, typ: ptrType$4, tag: ""}]);
	nameData.init("reflect", [{prop: "name", name: "name", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "tag", name: "tag", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "exported", name: "exported", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	mapIter.init("reflect", [{prop: "t", name: "t", embedded: false, exported: false, typ: Type, tag: ""}, {prop: "m", name: "m", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "keys", name: "keys", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "i", name: "i", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "last", name: "last", embedded: false, exported: false, typ: ptrType$2, tag: ""}]);
	Type.init([{prop: "Align", name: "Align", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "AssignableTo", name: "AssignableTo", pkg: "", typ: $funcType([Type], [$Bool], false)}, {prop: "Bits", name: "Bits", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "ChanDir", name: "ChanDir", pkg: "", typ: $funcType([], [ChanDir], false)}, {prop: "Comparable", name: "Comparable", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "ConvertibleTo", name: "ConvertibleTo", pkg: "", typ: $funcType([Type], [$Bool], false)}, {prop: "Elem", name: "Elem", pkg: "", typ: $funcType([], [Type], false)}, {prop: "Field", name: "Field", pkg: "", typ: $funcType([$Int], [StructField], false)}, {prop: "FieldAlign", name: "FieldAlign", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "FieldByIndex", name: "FieldByIndex", pkg: "", typ: $funcType([sliceType$13], [StructField], false)}, {prop: "FieldByName", name: "FieldByName", pkg: "", typ: $funcType([$String], [StructField, $Bool], false)}, {prop: "FieldByNameFunc", name: "FieldByNameFunc", pkg: "", typ: $funcType([funcType$3], [StructField, $Bool], false)}, {prop: "Implements", name: "Implements", pkg: "", typ: $funcType([Type], [$Bool], false)}, {prop: "In", name: "In", pkg: "", typ: $funcType([$Int], [Type], false)}, {prop: "IsVariadic", name: "IsVariadic", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Key", name: "Key", pkg: "", typ: $funcType([], [Type], false)}, {prop: "Kind", name: "Kind", pkg: "", typ: $funcType([], [Kind], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Method", name: "Method", pkg: "", typ: $funcType([$Int], [Method], false)}, {prop: "MethodByName", name: "MethodByName", pkg: "", typ: $funcType([$String], [Method, $Bool], false)}, {prop: "Name", name: "Name", pkg: "", typ: $funcType([], [$String], false)}, {prop: "NumField", name: "NumField", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIn", name: "NumIn", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumMethod", name: "NumMethod", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumOut", name: "NumOut", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Out", name: "Out", pkg: "", typ: $funcType([$Int], [Type], false)}, {prop: "PkgPath", name: "PkgPath", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Uintptr], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "common", name: "common", pkg: "reflect", typ: $funcType([], [ptrType$1], false)}, {prop: "uncommon", name: "uncommon", pkg: "reflect", typ: $funcType([], [ptrType$5], false)}]);
	rtype.init("reflect", [{prop: "size", name: "size", embedded: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "ptrdata", name: "ptrdata", embedded: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "hash", name: "hash", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "tflag", name: "tflag", embedded: false, exported: false, typ: tflag, tag: ""}, {prop: "align", name: "align", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "fieldAlign", name: "fieldAlign", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "kind", name: "kind", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "alg", name: "alg", embedded: false, exported: false, typ: ptrType$3, tag: ""}, {prop: "gcdata", name: "gcdata", embedded: false, exported: false, typ: ptrType$4, tag: ""}, {prop: "str", name: "str", embedded: false, exported: false, typ: nameOff, tag: ""}, {prop: "ptrToThis", name: "ptrToThis", embedded: false, exported: false, typ: typeOff, tag: ""}]);
	typeAlg.init("reflect", [{prop: "hash", name: "hash", embedded: false, exported: false, typ: funcType$4, tag: ""}, {prop: "equal", name: "equal", embedded: false, exported: false, typ: funcType$5, tag: ""}]);
	method.init("reflect", [{prop: "name", name: "name", embedded: false, exported: false, typ: nameOff, tag: ""}, {prop: "mtyp", name: "mtyp", embedded: false, exported: false, typ: typeOff, tag: ""}, {prop: "ifn", name: "ifn", embedded: false, exported: false, typ: textOff, tag: ""}, {prop: "tfn", name: "tfn", embedded: false, exported: false, typ: textOff, tag: ""}]);
	arrayType.init("reflect", [{prop: "rtype", name: "rtype", embedded: true, exported: false, typ: rtype, tag: ""}, {prop: "elem", name: "elem", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "slice", name: "slice", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "len", name: "len", embedded: false, exported: false, typ: $Uintptr, tag: ""}]);
	chanType.init("reflect", [{prop: "rtype", name: "rtype", embedded: true, exported: false, typ: rtype, tag: ""}, {prop: "elem", name: "elem", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "dir", name: "dir", embedded: false, exported: false, typ: $Uintptr, tag: ""}]);
	imethod.init("reflect", [{prop: "name", name: "name", embedded: false, exported: false, typ: nameOff, tag: ""}, {prop: "typ", name: "typ", embedded: false, exported: false, typ: typeOff, tag: ""}]);
	interfaceType.init("reflect", [{prop: "rtype", name: "rtype", embedded: true, exported: false, typ: rtype, tag: ""}, {prop: "pkgPath", name: "pkgPath", embedded: false, exported: false, typ: name, tag: ""}, {prop: "methods", name: "methods", embedded: false, exported: false, typ: sliceType$6, tag: ""}]);
	mapType.init("reflect", [{prop: "rtype", name: "rtype", embedded: true, exported: false, typ: rtype, tag: ""}, {prop: "key", name: "key", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "elem", name: "elem", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "bucket", name: "bucket", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "keysize", name: "keysize", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "valuesize", name: "valuesize", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "bucketsize", name: "bucketsize", embedded: false, exported: false, typ: $Uint16, tag: ""}, {prop: "flags", name: "flags", embedded: false, exported: false, typ: $Uint32, tag: ""}]);
	ptrType.init("reflect", [{prop: "rtype", name: "rtype", embedded: true, exported: false, typ: rtype, tag: ""}, {prop: "elem", name: "elem", embedded: false, exported: false, typ: ptrType$1, tag: ""}]);
	sliceType.init("reflect", [{prop: "rtype", name: "rtype", embedded: true, exported: false, typ: rtype, tag: ""}, {prop: "elem", name: "elem", embedded: false, exported: false, typ: ptrType$1, tag: ""}]);
	structField.init("reflect", [{prop: "name", name: "name", embedded: false, exported: false, typ: name, tag: ""}, {prop: "typ", name: "typ", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "offsetEmbed", name: "offsetEmbed", embedded: false, exported: false, typ: $Uintptr, tag: ""}]);
	structType.init("reflect", [{prop: "rtype", name: "rtype", embedded: true, exported: false, typ: rtype, tag: ""}, {prop: "pkgPath", name: "pkgPath", embedded: false, exported: false, typ: name, tag: ""}, {prop: "fields", name: "fields", embedded: false, exported: false, typ: sliceType$7, tag: ""}]);
	Method.init("", [{prop: "Name", name: "Name", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "PkgPath", name: "PkgPath", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Type", name: "Type", embedded: false, exported: true, typ: Type, tag: ""}, {prop: "Func", name: "Func", embedded: false, exported: true, typ: Value, tag: ""}, {prop: "Index", name: "Index", embedded: false, exported: true, typ: $Int, tag: ""}]);
	StructField.init("", [{prop: "Name", name: "Name", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "PkgPath", name: "PkgPath", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Type", name: "Type", embedded: false, exported: true, typ: Type, tag: ""}, {prop: "Tag", name: "Tag", embedded: false, exported: true, typ: StructTag, tag: ""}, {prop: "Offset", name: "Offset", embedded: false, exported: true, typ: $Uintptr, tag: ""}, {prop: "Index", name: "Index", embedded: false, exported: true, typ: sliceType$13, tag: ""}, {prop: "Anonymous", name: "Anonymous", embedded: false, exported: true, typ: $Bool, tag: ""}]);
	fieldScan.init("reflect", [{prop: "typ", name: "typ", embedded: false, exported: false, typ: ptrType$11, tag: ""}, {prop: "index", name: "index", embedded: false, exported: false, typ: sliceType$13, tag: ""}]);
	Value.init("reflect", [{prop: "typ", name: "typ", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "ptr", name: "ptr", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}, {prop: "flag", name: "flag", embedded: true, exported: false, typ: flag, tag: ""}]);
	ValueError.init("", [{prop: "Method", name: "Method", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Kind", name: "Kind", embedded: false, exported: true, typ: Kind, tag: ""}]);
	MapIter.init("reflect", [{prop: "m", name: "m", embedded: false, exported: false, typ: Value, tag: ""}, {prop: "it", name: "it", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		nameOffList = sliceType$1.nil;
		typeOffList = sliceType$2.nil;
		initialized = false;
		uncommonTypeMap = {};
		nameMap = {};
		callHelper = $assertType($internalize($call, $emptyInterface), funcType$1);
		selectHelper = $assertType($internalize($select, $emptyInterface), funcType$1);
		jsObjectPtr = reflectType($jsObjectPtr);
		kindNames = new sliceType$4(["invalid", "bool", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "uintptr", "float32", "float64", "complex64", "complex128", "array", "chan", "func", "interface", "map", "ptr", "slice", "string", "struct", "unsafe.Pointer"]);
		uint8Type = $assertType(TypeOf(new $Uint8(0)), ptrType$1);
		$r = init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["sort"] = (function() {
	var $pkg = {}, $init, reflect, IntSlice, sliceType, Search, SearchInts, insertionSort, siftDown, heapSort, medianOfThree, swapRange, doPivot, quickSort, Sort, maxDepth, Ints, Stable, stable, symMerge, rotate;
	reflect = $packages["reflect"];
	IntSlice = $pkg.IntSlice = $newType(12, $kindSlice, "sort.IntSlice", true, "sort", true, null);
	sliceType = $sliceType($Int);
	Search = function(n, f) {
		var _r, _tmp, _tmp$1, f, h, i, j, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; f = $f.f; h = $f.h; i = $f.i; j = $f.j; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tmp = 0;
		_tmp$1 = n;
		i = _tmp;
		j = _tmp$1;
		/* while (true) { */ case 1:
			/* if (!(i < j)) { break; } */ if(!(i < j)) { $s = 2; continue; }
			h = ((((((i + j >> 0) >>> 0)) >>> 1 >>> 0) >> 0));
			_r = f(h); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (!_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!_r) { */ case 3:
				i = h + 1 >> 0;
				$s = 5; continue;
			/* } else { */ case 4:
				j = h;
			/* } */ case 5:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return i;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Search }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.f = f; $f.h = h; $f.i = i; $f.j = j; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Search = Search;
	SearchInts = function(a, x) {
		var _r, a, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		a = [a];
		x = [x];
		_r = Search(a[0].$length, (function(a, x) { return function(i) {
			var i;
			return ((i < 0 || i >= a[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : a[0].$array[a[0].$offset + i]) >= x[0];
		}; })(a, x)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: SearchInts }; } $f._r = _r; $f.a = a; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.SearchInts = SearchInts;
	IntSlice.prototype.Search = function(x) {
		var _r, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r = SearchInts($subslice(new sliceType(p.$array), p.$offset, p.$offset + p.$length), x); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: IntSlice.prototype.Search }; } $f._r = _r; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(IntSlice).prototype.Search = function(x) { return this.$get().Search(x); };
	insertionSort = function(data, a, b) {
		var _r, _v, a, b, data, i, j, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _v = $f._v; a = $f.a; b = $f.b; data = $f.data; i = $f.i; j = $f.j; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = a + 1 >> 0;
		/* while (true) { */ case 1:
			/* if (!(i < b)) { break; } */ if(!(i < b)) { $s = 2; continue; }
			j = i;
			/* while (true) { */ case 3:
				if (!(j > a)) { _v = false; $s = 5; continue s; }
				_r = data.Less(j, j - 1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_v = _r; case 5:
				/* if (!(_v)) { break; } */ if(!(_v)) { $s = 4; continue; }
				$r = data.Swap(j, j - 1 >> 0); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				j = j - (1) >> 0;
			/* } */ $s = 3; continue; case 4:
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: insertionSort }; } $f._r = _r; $f._v = _v; $f.a = a; $f.b = b; $f.data = data; $f.i = i; $f.j = j; $f.$s = $s; $f.$r = $r; return $f;
	};
	siftDown = function(data, lo, hi, first) {
		var _r, _r$1, _v, child, data, first, hi, lo, root, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _v = $f._v; child = $f.child; data = $f.data; first = $f.first; hi = $f.hi; lo = $f.lo; root = $f.root; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		root = lo;
		/* while (true) { */ case 1:
			child = ($imul(2, root)) + 1 >> 0;
			if (child >= hi) {
				/* break; */ $s = 2; continue;
			}
			if (!((child + 1 >> 0) < hi)) { _v = false; $s = 5; continue s; }
			_r = data.Less(first + child >> 0, (first + child >> 0) + 1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_v = _r; case 5:
			/* */ if (_v) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_v) { */ case 3:
				child = child + (1) >> 0;
			/* } */ case 4:
			_r$1 = data.Less(first + root >> 0, first + child >> 0); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (!_r$1) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!_r$1) { */ case 7:
				$s = -1; return;
			/* } */ case 8:
			$r = data.Swap(first + root >> 0, first + child >> 0); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			root = child;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: siftDown }; } $f._r = _r; $f._r$1 = _r$1; $f._v = _v; $f.child = child; $f.data = data; $f.first = first; $f.hi = hi; $f.lo = lo; $f.root = root; $f.$s = $s; $f.$r = $r; return $f;
	};
	heapSort = function(data, a, b) {
		var _q, a, b, data, first, hi, i, i$1, lo, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; a = $f.a; b = $f.b; data = $f.data; first = $f.first; hi = $f.hi; i = $f.i; i$1 = $f.i$1; lo = $f.lo; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		first = a;
		lo = 0;
		hi = b - a >> 0;
		i = (_q = ((hi - 1 >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		/* while (true) { */ case 1:
			/* if (!(i >= 0)) { break; } */ if(!(i >= 0)) { $s = 2; continue; }
			$r = siftDown(data, i, hi, first); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i = i - (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		i$1 = hi - 1 >> 0;
		/* while (true) { */ case 4:
			/* if (!(i$1 >= 0)) { break; } */ if(!(i$1 >= 0)) { $s = 5; continue; }
			$r = data.Swap(first, first + i$1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = siftDown(data, lo, i$1, first); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i$1 = i$1 - (1) >> 0;
		/* } */ $s = 4; continue; case 5:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: heapSort }; } $f._q = _q; $f.a = a; $f.b = b; $f.data = data; $f.first = first; $f.hi = hi; $f.i = i; $f.i$1 = i$1; $f.lo = lo; $f.$s = $s; $f.$r = $r; return $f;
	};
	medianOfThree = function(data, m1, m0, m2) {
		var _r, _r$1, _r$2, data, m0, m1, m2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; data = $f.data; m0 = $f.m0; m1 = $f.m1; m2 = $f.m2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = data.Less(m1, m0); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r) { */ case 1:
			$r = data.Swap(m1, m0); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		_r$1 = data.Less(m2, m1); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (_r$1) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (_r$1) { */ case 5:
			$r = data.Swap(m2, m1); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$2 = data.Less(m1, m0); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			/* */ if (_r$2) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_r$2) { */ case 9:
				$r = data.Swap(m1, m0); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 10:
		/* } */ case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: medianOfThree }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.data = data; $f.m0 = m0; $f.m1 = m1; $f.m2 = m2; $f.$s = $s; $f.$r = $r; return $f;
	};
	swapRange = function(data, a, b, n) {
		var a, b, data, i, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; a = $f.a; b = $f.b; data = $f.data; i = $f.i; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 2; continue; }
			$r = data.Swap(a + i >> 0, b + i >> 0); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: swapRange }; } $f.a = a; $f.b = b; $f.data = data; $f.i = i; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	doPivot = function(data, lo, hi) {
		var _q, _q$1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _tmp, _tmp$1, _tmp$2, _tmp$3, _v, _v$1, _v$2, _v$3, _v$4, a, b, c, data, dups, hi, lo, m, midhi, midlo, pivot, protect, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _q$1 = $f._q$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; _v$3 = $f._v$3; _v$4 = $f._v$4; a = $f.a; b = $f.b; c = $f.c; data = $f.data; dups = $f.dups; hi = $f.hi; lo = $f.lo; m = $f.m; midhi = $f.midhi; midlo = $f.midlo; pivot = $f.pivot; protect = $f.protect; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		midlo = 0;
		midhi = 0;
		m = ((((((lo + hi >> 0) >>> 0)) >>> 1 >>> 0) >> 0));
		/* */ if ((hi - lo >> 0) > 40) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((hi - lo >> 0) > 40) { */ case 1:
			s = (_q = ((hi - lo >> 0)) / 8, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			$r = medianOfThree(data, lo, lo + s >> 0, lo + ($imul(2, s)) >> 0); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = medianOfThree(data, m, m - s >> 0, m + s >> 0); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = medianOfThree(data, hi - 1 >> 0, (hi - 1 >> 0) - s >> 0, (hi - 1 >> 0) - ($imul(2, s)) >> 0); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		$r = medianOfThree(data, lo, m, hi - 1 >> 0); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		pivot = lo;
		_tmp = lo + 1 >> 0;
		_tmp$1 = hi - 1 >> 0;
		a = _tmp;
		c = _tmp$1;
		/* while (true) { */ case 7:
			if (!(a < c)) { _v = false; $s = 9; continue s; }
			_r = data.Less(a, pivot); /* */ $s = 10; case 10: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_v = _r; case 9:
			/* if (!(_v)) { break; } */ if(!(_v)) { $s = 8; continue; }
			a = a + (1) >> 0;
		/* } */ $s = 7; continue; case 8:
		b = a;
		/* while (true) { */ case 11:
			/* while (true) { */ case 13:
				if (!(b < c)) { _v$1 = false; $s = 15; continue s; }
				_r$1 = data.Less(pivot, b); /* */ $s = 16; case 16: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_v$1 = !_r$1; case 15:
				/* if (!(_v$1)) { break; } */ if(!(_v$1)) { $s = 14; continue; }
				b = b + (1) >> 0;
			/* } */ $s = 13; continue; case 14:
			/* while (true) { */ case 17:
				if (!(b < c)) { _v$2 = false; $s = 19; continue s; }
				_r$2 = data.Less(pivot, c - 1 >> 0); /* */ $s = 20; case 20: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_v$2 = _r$2; case 19:
				/* if (!(_v$2)) { break; } */ if(!(_v$2)) { $s = 18; continue; }
				c = c - (1) >> 0;
			/* } */ $s = 17; continue; case 18:
			if (b >= c) {
				/* break; */ $s = 12; continue;
			}
			$r = data.Swap(b, c - 1 >> 0); /* */ $s = 21; case 21: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			b = b + (1) >> 0;
			c = c - (1) >> 0;
		/* } */ $s = 11; continue; case 12:
		protect = (hi - c >> 0) < 5;
		/* */ if (!protect && (hi - c >> 0) < (_q$1 = ((hi - lo >> 0)) / 4, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"))) { $s = 22; continue; }
		/* */ $s = 23; continue;
		/* if (!protect && (hi - c >> 0) < (_q$1 = ((hi - lo >> 0)) / 4, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"))) { */ case 22:
			dups = 0;
			_r$3 = data.Less(pivot, hi - 1 >> 0); /* */ $s = 26; case 26: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			/* */ if (!_r$3) { $s = 24; continue; }
			/* */ $s = 25; continue;
			/* if (!_r$3) { */ case 24:
				$r = data.Swap(c, hi - 1 >> 0); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				c = c + (1) >> 0;
				dups = dups + (1) >> 0;
			/* } */ case 25:
			_r$4 = data.Less(b - 1 >> 0, pivot); /* */ $s = 30; case 30: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			/* */ if (!_r$4) { $s = 28; continue; }
			/* */ $s = 29; continue;
			/* if (!_r$4) { */ case 28:
				b = b - (1) >> 0;
				dups = dups + (1) >> 0;
			/* } */ case 29:
			_r$5 = data.Less(m, pivot); /* */ $s = 33; case 33: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			/* */ if (!_r$5) { $s = 31; continue; }
			/* */ $s = 32; continue;
			/* if (!_r$5) { */ case 31:
				$r = data.Swap(m, b - 1 >> 0); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				b = b - (1) >> 0;
				dups = dups + (1) >> 0;
			/* } */ case 32:
			protect = dups > 1;
		/* } */ case 23:
		/* */ if (protect) { $s = 35; continue; }
		/* */ $s = 36; continue;
		/* if (protect) { */ case 35:
			/* while (true) { */ case 37:
				/* while (true) { */ case 39:
					if (!(a < b)) { _v$3 = false; $s = 41; continue s; }
					_r$6 = data.Less(b - 1 >> 0, pivot); /* */ $s = 42; case 42: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
					_v$3 = !_r$6; case 41:
					/* if (!(_v$3)) { break; } */ if(!(_v$3)) { $s = 40; continue; }
					b = b - (1) >> 0;
				/* } */ $s = 39; continue; case 40:
				/* while (true) { */ case 43:
					if (!(a < b)) { _v$4 = false; $s = 45; continue s; }
					_r$7 = data.Less(a, pivot); /* */ $s = 46; case 46: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
					_v$4 = _r$7; case 45:
					/* if (!(_v$4)) { break; } */ if(!(_v$4)) { $s = 44; continue; }
					a = a + (1) >> 0;
				/* } */ $s = 43; continue; case 44:
				if (a >= b) {
					/* break; */ $s = 38; continue;
				}
				$r = data.Swap(a, b - 1 >> 0); /* */ $s = 47; case 47: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				a = a + (1) >> 0;
				b = b - (1) >> 0;
			/* } */ $s = 37; continue; case 38:
		/* } */ case 36:
		$r = data.Swap(pivot, b - 1 >> 0); /* */ $s = 48; case 48: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_tmp$2 = b - 1 >> 0;
		_tmp$3 = c;
		midlo = _tmp$2;
		midhi = _tmp$3;
		$s = -1; return [midlo, midhi];
		/* */ } return; } if ($f === undefined) { $f = { $blk: doPivot }; } $f._q = _q; $f._q$1 = _q$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f._v$3 = _v$3; $f._v$4 = _v$4; $f.a = a; $f.b = b; $f.c = c; $f.data = data; $f.dups = dups; $f.hi = hi; $f.lo = lo; $f.m = m; $f.midhi = midhi; $f.midlo = midlo; $f.pivot = pivot; $f.protect = protect; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	quickSort = function(data, a, b, maxDepth$1) {
		var _r, _r$1, _tuple, a, b, data, i, maxDepth$1, mhi, mlo, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; a = $f.a; b = $f.b; data = $f.data; i = $f.i; maxDepth$1 = $f.maxDepth$1; mhi = $f.mhi; mlo = $f.mlo; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* while (true) { */ case 1:
			/* if (!((b - a >> 0) > 12)) { break; } */ if(!((b - a >> 0) > 12)) { $s = 2; continue; }
			/* */ if (maxDepth$1 === 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (maxDepth$1 === 0) { */ case 3:
				$r = heapSort(data, a, b); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } */ case 4:
			maxDepth$1 = maxDepth$1 - (1) >> 0;
			_r = doPivot(data, a, b); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			mlo = _tuple[0];
			mhi = _tuple[1];
			/* */ if ((mlo - a >> 0) < (b - mhi >> 0)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if ((mlo - a >> 0) < (b - mhi >> 0)) { */ case 7:
				$r = quickSort(data, a, mlo, maxDepth$1); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				a = mhi;
				$s = 9; continue;
			/* } else { */ case 8:
				$r = quickSort(data, mhi, b, maxDepth$1); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				b = mlo;
			/* } */ case 9:
		/* } */ $s = 1; continue; case 2:
		/* */ if ((b - a >> 0) > 1) { $s = 12; continue; }
		/* */ $s = 13; continue;
		/* if ((b - a >> 0) > 1) { */ case 12:
			i = a + 6 >> 0;
			/* while (true) { */ case 14:
				/* if (!(i < b)) { break; } */ if(!(i < b)) { $s = 15; continue; }
				_r$1 = data.Less(i, i - 6 >> 0); /* */ $s = 18; case 18: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				/* */ if (_r$1) { $s = 16; continue; }
				/* */ $s = 17; continue;
				/* if (_r$1) { */ case 16:
					$r = data.Swap(i, i - 6 >> 0); /* */ $s = 19; case 19: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 17:
				i = i + (1) >> 0;
			/* } */ $s = 14; continue; case 15:
			$r = insertionSort(data, a, b); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 13:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: quickSort }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.a = a; $f.b = b; $f.data = data; $f.i = i; $f.maxDepth$1 = maxDepth$1; $f.mhi = mhi; $f.mlo = mlo; $f.$s = $s; $f.$r = $r; return $f;
	};
	Sort = function(data) {
		var _r, data, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; data = $f.data; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = data.Len(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		n = _r;
		$r = quickSort(data, 0, n, maxDepth(n)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Sort }; } $f._r = _r; $f.data = data; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Sort = Sort;
	maxDepth = function(n) {
		var depth, i, n;
		depth = 0;
		i = n;
		while (true) {
			if (!(i > 0)) { break; }
			depth = depth + (1) >> 0;
			i = (i >> $min((1), 31)) >> 0;
		}
		return $imul(depth, 2);
	};
	IntSlice.prototype.Len = function() {
		var p;
		p = this;
		return p.$length;
	};
	$ptrType(IntSlice).prototype.Len = function() { return this.$get().Len(); };
	IntSlice.prototype.Less = function(i, j) {
		var i, j, p;
		p = this;
		return ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]) < ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j]);
	};
	$ptrType(IntSlice).prototype.Less = function(i, j) { return this.$get().Less(i, j); };
	IntSlice.prototype.Swap = function(i, j) {
		var _tmp, _tmp$1, i, j, p;
		p = this;
		_tmp = ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j]);
		_tmp$1 = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]);
		((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i] = _tmp);
		((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j] = _tmp$1);
	};
	$ptrType(IntSlice).prototype.Swap = function(i, j) { return this.$get().Swap(i, j); };
	IntSlice.prototype.Sort = function() {
		var p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		$r = Sort(p); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: IntSlice.prototype.Sort }; } $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(IntSlice).prototype.Sort = function() { return this.$get().Sort(); };
	Ints = function(a) {
		var a, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; a = $f.a; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = Sort(($subslice(new IntSlice(a.$array), a.$offset, a.$offset + a.$length))); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Ints }; } $f.a = a; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Ints = Ints;
	Stable = function(data) {
		var _arg, _arg$1, _r, data, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; data = $f.data; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_arg = data;
		_r = data.Len(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg$1 = _r;
		$r = stable(_arg, _arg$1); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Stable }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f.data = data; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Stable = Stable;
	stable = function(data, n) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, a, b, blockSize, data, m, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; a = $f.a; b = $f.b; blockSize = $f.blockSize; data = $f.data; m = $f.m; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		blockSize = 20;
		_tmp = 0;
		_tmp$1 = blockSize;
		a = _tmp;
		b = _tmp$1;
		/* while (true) { */ case 1:
			/* if (!(b <= n)) { break; } */ if(!(b <= n)) { $s = 2; continue; }
			$r = insertionSort(data, a, b); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			a = b;
			b = b + (blockSize) >> 0;
		/* } */ $s = 1; continue; case 2:
		$r = insertionSort(data, a, n); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* while (true) { */ case 5:
			/* if (!(blockSize < n)) { break; } */ if(!(blockSize < n)) { $s = 6; continue; }
			_tmp$2 = 0;
			_tmp$3 = $imul(2, blockSize);
			a = _tmp$2;
			b = _tmp$3;
			/* while (true) { */ case 7:
				/* if (!(b <= n)) { break; } */ if(!(b <= n)) { $s = 8; continue; }
				$r = symMerge(data, a, a + blockSize >> 0, b); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				a = b;
				b = b + (($imul(2, blockSize))) >> 0;
			/* } */ $s = 7; continue; case 8:
			m = a + blockSize >> 0;
			/* */ if (m < n) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (m < n) { */ case 10:
				$r = symMerge(data, a, m, n); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 11:
			blockSize = $imul(blockSize, (2));
		/* } */ $s = 5; continue; case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: stable }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.a = a; $f.b = b; $f.blockSize = blockSize; $f.data = data; $f.m = m; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	symMerge = function(data, a, m, b) {
		var _r, _r$1, _r$2, _tmp, _tmp$1, a, b, c, data, end, h, h$1, i, i$1, j, j$1, k, k$1, m, mid, n, p, r, start, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; a = $f.a; b = $f.b; c = $f.c; data = $f.data; end = $f.end; h = $f.h; h$1 = $f.h$1; i = $f.i; i$1 = $f.i$1; j = $f.j; j$1 = $f.j$1; k = $f.k; k$1 = $f.k$1; m = $f.m; mid = $f.mid; n = $f.n; p = $f.p; r = $f.r; start = $f.start; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if ((m - a >> 0) === 1) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((m - a >> 0) === 1) { */ case 1:
			i = m;
			j = b;
			/* while (true) { */ case 3:
				/* if (!(i < j)) { break; } */ if(!(i < j)) { $s = 4; continue; }
				h = ((((((i + j >> 0) >>> 0)) >>> 1 >>> 0) >> 0));
				_r = data.Less(h, a); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				/* */ if (_r) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (_r) { */ case 5:
					i = h + 1 >> 0;
					$s = 7; continue;
				/* } else { */ case 6:
					j = h;
				/* } */ case 7:
			/* } */ $s = 3; continue; case 4:
			k = a;
			/* while (true) { */ case 9:
				/* if (!(k < (i - 1 >> 0))) { break; } */ if(!(k < (i - 1 >> 0))) { $s = 10; continue; }
				$r = data.Swap(k, k + 1 >> 0); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				k = k + (1) >> 0;
			/* } */ $s = 9; continue; case 10:
			$s = -1; return;
		/* } */ case 2:
		/* */ if ((b - m >> 0) === 1) { $s = 12; continue; }
		/* */ $s = 13; continue;
		/* if ((b - m >> 0) === 1) { */ case 12:
			i$1 = a;
			j$1 = m;
			/* while (true) { */ case 14:
				/* if (!(i$1 < j$1)) { break; } */ if(!(i$1 < j$1)) { $s = 15; continue; }
				h$1 = ((((((i$1 + j$1 >> 0) >>> 0)) >>> 1 >>> 0) >> 0));
				_r$1 = data.Less(m, h$1); /* */ $s = 19; case 19: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				/* */ if (!_r$1) { $s = 16; continue; }
				/* */ $s = 17; continue;
				/* if (!_r$1) { */ case 16:
					i$1 = h$1 + 1 >> 0;
					$s = 18; continue;
				/* } else { */ case 17:
					j$1 = h$1;
				/* } */ case 18:
			/* } */ $s = 14; continue; case 15:
			k$1 = m;
			/* while (true) { */ case 20:
				/* if (!(k$1 > i$1)) { break; } */ if(!(k$1 > i$1)) { $s = 21; continue; }
				$r = data.Swap(k$1, k$1 - 1 >> 0); /* */ $s = 22; case 22: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				k$1 = k$1 - (1) >> 0;
			/* } */ $s = 20; continue; case 21:
			$s = -1; return;
		/* } */ case 13:
		mid = ((((((a + b >> 0) >>> 0)) >>> 1 >>> 0) >> 0));
		n = mid + m >> 0;
		_tmp = 0;
		_tmp$1 = 0;
		start = _tmp;
		r = _tmp$1;
		if (m > mid) {
			start = n - b >> 0;
			r = mid;
		} else {
			start = a;
			r = m;
		}
		p = n - 1 >> 0;
		/* while (true) { */ case 23:
			/* if (!(start < r)) { break; } */ if(!(start < r)) { $s = 24; continue; }
			c = ((((((start + r >> 0) >>> 0)) >>> 1 >>> 0) >> 0));
			_r$2 = data.Less(p - c >> 0, c); /* */ $s = 28; case 28: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			/* */ if (!_r$2) { $s = 25; continue; }
			/* */ $s = 26; continue;
			/* if (!_r$2) { */ case 25:
				start = c + 1 >> 0;
				$s = 27; continue;
			/* } else { */ case 26:
				r = c;
			/* } */ case 27:
		/* } */ $s = 23; continue; case 24:
		end = n - start >> 0;
		/* */ if (start < m && m < end) { $s = 29; continue; }
		/* */ $s = 30; continue;
		/* if (start < m && m < end) { */ case 29:
			$r = rotate(data, start, m, end); /* */ $s = 31; case 31: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 30:
		/* */ if (a < start && start < mid) { $s = 32; continue; }
		/* */ $s = 33; continue;
		/* if (a < start && start < mid) { */ case 32:
			$r = symMerge(data, a, start, mid); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 33:
		/* */ if (mid < end && end < b) { $s = 35; continue; }
		/* */ $s = 36; continue;
		/* if (mid < end && end < b) { */ case 35:
			$r = symMerge(data, mid, end, b); /* */ $s = 37; case 37: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 36:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: symMerge }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.a = a; $f.b = b; $f.c = c; $f.data = data; $f.end = end; $f.h = h; $f.h$1 = h$1; $f.i = i; $f.i$1 = i$1; $f.j = j; $f.j$1 = j$1; $f.k = k; $f.k$1 = k$1; $f.m = m; $f.mid = mid; $f.n = n; $f.p = p; $f.r = r; $f.start = start; $f.$s = $s; $f.$r = $r; return $f;
	};
	rotate = function(data, a, m, b) {
		var a, b, data, i, j, m, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; a = $f.a; b = $f.b; data = $f.data; i = $f.i; j = $f.j; m = $f.m; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = m - a >> 0;
		j = b - m >> 0;
		/* while (true) { */ case 1:
			/* if (!(!((i === j)))) { break; } */ if(!(!((i === j)))) { $s = 2; continue; }
			/* */ if (i > j) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (i > j) { */ case 3:
				$r = swapRange(data, m - i >> 0, m, j); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				i = i - (j) >> 0;
				$s = 5; continue;
			/* } else { */ case 4:
				$r = swapRange(data, m - i >> 0, (m + j >> 0) - i >> 0, i); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				j = j - (i) >> 0;
			/* } */ case 5:
		/* } */ $s = 1; continue; case 2:
		$r = swapRange(data, m - i >> 0, m, i); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rotate }; } $f.a = a; $f.b = b; $f.data = data; $f.i = i; $f.j = j; $f.m = m; $f.$s = $s; $f.$r = $r; return $f;
	};
	IntSlice.methods = [{prop: "Search", name: "Search", pkg: "", typ: $funcType([$Int], [$Int], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Less", name: "Less", pkg: "", typ: $funcType([$Int, $Int], [$Bool], false)}, {prop: "Swap", name: "Swap", pkg: "", typ: $funcType([$Int, $Int], [], false)}, {prop: "Sort", name: "Sort", pkg: "", typ: $funcType([], [], false)}];
	IntSlice.init($Int);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = reflect.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/fmtsort"] = (function() {
	var $pkg = {}, $init, reflect, sort, SortedMap, ptrType, sliceType, Sort, compare, nilCompare, floatCompare, isNaN;
	reflect = $packages["reflect"];
	sort = $packages["sort"];
	SortedMap = $pkg.SortedMap = $newType(0, $kindStruct, "fmtsort.SortedMap", true, "internal/fmtsort", true, function(Key_, Value_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Key = sliceType.nil;
			this.Value = sliceType.nil;
			return;
		}
		this.Key = Key_;
		this.Value = Value_;
	});
	ptrType = $ptrType(SortedMap);
	sliceType = $sliceType(reflect.Value);
	SortedMap.ptr.prototype.Len = function() {
		var o;
		o = this;
		return o.Key.$length;
	};
	SortedMap.prototype.Len = function() { return this.$val.Len(); };
	SortedMap.ptr.prototype.Less = function(i, j) {
		var _r, i, j, o, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; j = $f.j; o = $f.o; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		o = this;
		_r = compare($clone((x = o.Key, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])), reflect.Value), $clone((x$1 = o.Key, ((j < 0 || j >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + j])), reflect.Value)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r < 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: SortedMap.ptr.prototype.Less }; } $f._r = _r; $f.i = i; $f.j = j; $f.o = o; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	SortedMap.prototype.Less = function(i, j) { return this.$val.Less(i, j); };
	SortedMap.ptr.prototype.Swap = function(i, j) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, i, j, o, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7;
		o = this;
		_tmp = (x = o.Key, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]));
		_tmp$1 = (x$1 = o.Key, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]));
		(x$2 = o.Key, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i] = _tmp));
		(x$3 = o.Key, ((j < 0 || j >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + j] = _tmp$1));
		_tmp$2 = (x$4 = o.Value, ((j < 0 || j >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + j]));
		_tmp$3 = (x$5 = o.Value, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i]));
		(x$6 = o.Value, ((i < 0 || i >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + i] = _tmp$2));
		(x$7 = o.Value, ((j < 0 || j >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + j] = _tmp$3));
	};
	SortedMap.prototype.Swap = function(i, j) { return this.$val.Swap(i, j); };
	Sort = function(mapValue) {
		var _r, _r$1, _r$2, _r$3, i, iter, key, mapValue, sorted, value, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; i = $f.i; iter = $f.iter; key = $f.key; mapValue = $f.mapValue; sorted = $f.sorted; value = $f.value; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = $clone(mapValue, reflect.Value).Type().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!((_r === 21))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!((_r === 21))) { */ case 1:
			$s = -1; return ptrType.nil;
		/* } */ case 2:
		key = $makeSlice(sliceType, $clone(mapValue, reflect.Value).Len());
		value = $makeSlice(sliceType, key.$length);
		iter = $clone(mapValue, reflect.Value).MapRange();
		i = 0;
		/* while (true) { */ case 4:
			_r$1 = iter.Next(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* if (!(_r$1)) { break; } */ if(!(_r$1)) { $s = 5; continue; }
			_r$2 = iter.Key(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			((i < 0 || i >= key.$length) ? ($throwRuntimeError("index out of range"), undefined) : key.$array[key.$offset + i] = _r$2);
			_r$3 = iter.Value(); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			((i < 0 || i >= value.$length) ? ($throwRuntimeError("index out of range"), undefined) : value.$array[value.$offset + i] = _r$3);
			i = i + (1) >> 0;
		/* } */ $s = 4; continue; case 5:
		sorted = new SortedMap.ptr(key, value);
		$r = sort.Stable(sorted); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return sorted;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Sort }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.i = i; $f.iter = iter; $f.key = key; $f.mapValue = mapValue; $f.sorted = sorted; $f.value = value; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Sort = Sort;
	compare = function(aVal, bVal) {
		var _1, _arg, _arg$1, _arg$2, _arg$3, _arg$4, _arg$5, _arg$6, _arg$7, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, a, a$1, a$2, a$3, a$4, a$5, aType, aVal, ap, b, b$1, b$2, b$3, b$4, b$5, bType, bVal, bp, c, c$1, c$2, c$3, c$4, c$5, i, i$1, ok, ok$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _arg$4 = $f._arg$4; _arg$5 = $f._arg$5; _arg$6 = $f._arg$6; _arg$7 = $f._arg$7; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; a$1 = $f.a$1; a$2 = $f.a$2; a$3 = $f.a$3; a$4 = $f.a$4; a$5 = $f.a$5; aType = $f.aType; aVal = $f.aVal; ap = $f.ap; b = $f.b; b$1 = $f.b$1; b$2 = $f.b$2; b$3 = $f.b$3; b$4 = $f.b$4; b$5 = $f.b$5; bType = $f.bType; bVal = $f.bVal; bp = $f.bp; c = $f.c; c$1 = $f.c$1; c$2 = $f.c$2; c$3 = $f.c$3; c$4 = $f.c$4; c$5 = $f.c$5; i = $f.i; i$1 = $f.i$1; ok = $f.ok; ok$1 = $f.ok$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tmp = $clone(aVal, reflect.Value).Type();
		_tmp$1 = $clone(bVal, reflect.Value).Type();
		aType = _tmp;
		bType = _tmp$1;
		if (!($interfaceIsEqual(aType, bType))) {
			$s = -1; return -1;
		}
			_1 = $clone(aVal, reflect.Value).Kind();
			/* */ if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { $s = 2; continue; }
			/* */ if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 3; continue; }
			/* */ if (_1 === (24)) { $s = 4; continue; }
			/* */ if ((_1 === (13)) || (_1 === (14))) { $s = 5; continue; }
			/* */ if ((_1 === (15)) || (_1 === (16))) { $s = 6; continue; }
			/* */ if (_1 === (1)) { $s = 7; continue; }
			/* */ if (_1 === (22)) { $s = 8; continue; }
			/* */ if (_1 === (18)) { $s = 9; continue; }
			/* */ if (_1 === (25)) { $s = 10; continue; }
			/* */ if (_1 === (17)) { $s = 11; continue; }
			/* */ if (_1 === (20)) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 2:
				_tmp$2 = $clone(aVal, reflect.Value).Int();
				_tmp$3 = $clone(bVal, reflect.Value).Int();
				a = _tmp$2;
				b = _tmp$3;
				if ((a.$high < b.$high || (a.$high === b.$high && a.$low < b.$low))) {
					$s = -1; return -1;
				} else if ((a.$high > b.$high || (a.$high === b.$high && a.$low > b.$low))) {
					$s = -1; return 1;
				} else {
					$s = -1; return 0;
				}
				$s = 14; continue;
			/* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 3:
				_tmp$4 = $clone(aVal, reflect.Value).Uint();
				_tmp$5 = $clone(bVal, reflect.Value).Uint();
				a$1 = _tmp$4;
				b$1 = _tmp$5;
				if ((a$1.$high < b$1.$high || (a$1.$high === b$1.$high && a$1.$low < b$1.$low))) {
					$s = -1; return -1;
				} else if ((a$1.$high > b$1.$high || (a$1.$high === b$1.$high && a$1.$low > b$1.$low))) {
					$s = -1; return 1;
				} else {
					$s = -1; return 0;
				}
				$s = 14; continue;
			/* } else if (_1 === (24)) { */ case 4:
				_r = $clone(aVal, reflect.Value).String(); /* */ $s = 15; case 15: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tmp$6 = _r;
				_r$1 = $clone(bVal, reflect.Value).String(); /* */ $s = 16; case 16: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tmp$7 = _r$1;
				a$2 = _tmp$6;
				b$2 = _tmp$7;
				if (a$2 < b$2) {
					$s = -1; return -1;
				} else if (a$2 > b$2) {
					$s = -1; return 1;
				} else {
					$s = -1; return 0;
				}
				$s = 14; continue;
			/* } else if ((_1 === (13)) || (_1 === (14))) { */ case 5:
				$s = -1; return floatCompare($clone(aVal, reflect.Value).Float(), $clone(bVal, reflect.Value).Float());
			/* } else if ((_1 === (15)) || (_1 === (16))) { */ case 6:
				_tmp$8 = $clone(aVal, reflect.Value).Complex();
				_tmp$9 = $clone(bVal, reflect.Value).Complex();
				a$3 = _tmp$8;
				b$3 = _tmp$9;
				c = floatCompare(a$3.$real, b$3.$real);
				if (!((c === 0))) {
					$s = -1; return c;
				}
				$s = -1; return floatCompare(a$3.$imag, b$3.$imag);
			/* } else if (_1 === (1)) { */ case 7:
				_tmp$10 = $clone(aVal, reflect.Value).Bool();
				_tmp$11 = $clone(bVal, reflect.Value).Bool();
				a$4 = _tmp$10;
				b$4 = _tmp$11;
				if (a$4 === b$4) {
					$s = -1; return 0;
				} else if (a$4) {
					$s = -1; return 1;
				} else {
					$s = -1; return -1;
				}
				$s = 14; continue;
			/* } else if (_1 === (22)) { */ case 8:
				_tmp$12 = $clone(aVal, reflect.Value).Pointer();
				_tmp$13 = $clone(bVal, reflect.Value).Pointer();
				a$5 = _tmp$12;
				b$5 = _tmp$13;
				if (a$5 < b$5) {
					$s = -1; return -1;
				} else if (a$5 > b$5) {
					$s = -1; return 1;
				} else {
					$s = -1; return 0;
				}
				$s = 14; continue;
			/* } else if (_1 === (18)) { */ case 9:
				_tuple = nilCompare($clone(aVal, reflect.Value), $clone(bVal, reflect.Value));
				c$1 = _tuple[0];
				ok = _tuple[1];
				if (ok) {
					$s = -1; return c$1;
				}
				_tmp$14 = $clone(aVal, reflect.Value).Pointer();
				_tmp$15 = $clone(bVal, reflect.Value).Pointer();
				ap = _tmp$14;
				bp = _tmp$15;
				if (ap < bp) {
					$s = -1; return -1;
				} else if (ap > bp) {
					$s = -1; return 1;
				} else {
					$s = -1; return 0;
				}
				$s = 14; continue;
			/* } else if (_1 === (25)) { */ case 10:
				i = 0;
				/* while (true) { */ case 17:
					/* if (!(i < $clone(aVal, reflect.Value).NumField())) { break; } */ if(!(i < $clone(aVal, reflect.Value).NumField())) { $s = 18; continue; }
					_r$2 = $clone(aVal, reflect.Value).Field(i); /* */ $s = 19; case 19: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_arg = $clone(_r$2, reflect.Value);
					_r$3 = $clone(bVal, reflect.Value).Field(i); /* */ $s = 20; case 20: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					_arg$1 = $clone(_r$3, reflect.Value);
					_r$4 = compare(_arg, _arg$1); /* */ $s = 21; case 21: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					c$2 = _r$4;
					if (!((c$2 === 0))) {
						$s = -1; return c$2;
					}
					i = i + (1) >> 0;
				/* } */ $s = 17; continue; case 18:
				$s = -1; return 0;
			/* } else if (_1 === (17)) { */ case 11:
				i$1 = 0;
				/* while (true) { */ case 22:
					/* if (!(i$1 < $clone(aVal, reflect.Value).Len())) { break; } */ if(!(i$1 < $clone(aVal, reflect.Value).Len())) { $s = 23; continue; }
					_r$5 = $clone(aVal, reflect.Value).Index(i$1); /* */ $s = 24; case 24: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					_arg$2 = $clone(_r$5, reflect.Value);
					_r$6 = $clone(bVal, reflect.Value).Index(i$1); /* */ $s = 25; case 25: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
					_arg$3 = $clone(_r$6, reflect.Value);
					_r$7 = compare(_arg$2, _arg$3); /* */ $s = 26; case 26: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
					c$3 = _r$7;
					if (!((c$3 === 0))) {
						$s = -1; return c$3;
					}
					i$1 = i$1 + (1) >> 0;
				/* } */ $s = 22; continue; case 23:
				$s = -1; return 0;
			/* } else if (_1 === (20)) { */ case 12:
				_tuple$1 = nilCompare($clone(aVal, reflect.Value), $clone(bVal, reflect.Value));
				c$4 = _tuple$1[0];
				ok$1 = _tuple$1[1];
				if (ok$1) {
					$s = -1; return c$4;
				}
				_r$8 = $clone(aVal, reflect.Value).Elem(); /* */ $s = 27; case 27: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				_r$9 = $clone(_r$8, reflect.Value).Type(); /* */ $s = 28; case 28: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				_r$10 = reflect.ValueOf(_r$9); /* */ $s = 29; case 29: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
				_arg$4 = $clone(_r$10, reflect.Value);
				_r$11 = $clone(bVal, reflect.Value).Elem(); /* */ $s = 30; case 30: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
				_r$12 = $clone(_r$11, reflect.Value).Type(); /* */ $s = 31; case 31: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
				_r$13 = reflect.ValueOf(_r$12); /* */ $s = 32; case 32: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
				_arg$5 = $clone(_r$13, reflect.Value);
				_r$14 = compare(_arg$4, _arg$5); /* */ $s = 33; case 33: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
				c$5 = _r$14;
				if (!((c$5 === 0))) {
					$s = -1; return c$5;
				}
				_r$15 = $clone(aVal, reflect.Value).Elem(); /* */ $s = 34; case 34: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
				_arg$6 = $clone(_r$15, reflect.Value);
				_r$16 = $clone(bVal, reflect.Value).Elem(); /* */ $s = 35; case 35: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
				_arg$7 = $clone(_r$16, reflect.Value);
				_r$17 = compare(_arg$6, _arg$7); /* */ $s = 36; case 36: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
				$s = -1; return _r$17;
			/* } else { */ case 13:
				_r$18 = aType.String(); /* */ $s = 37; case 37: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
				$panic(new $String("bad type in compare: " + _r$18));
			/* } */ case 14:
		case 1:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: compare }; } $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._arg$4 = _arg$4; $f._arg$5 = _arg$5; $f._arg$6 = _arg$6; $f._arg$7 = _arg$7; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.a$1 = a$1; $f.a$2 = a$2; $f.a$3 = a$3; $f.a$4 = a$4; $f.a$5 = a$5; $f.aType = aType; $f.aVal = aVal; $f.ap = ap; $f.b = b; $f.b$1 = b$1; $f.b$2 = b$2; $f.b$3 = b$3; $f.b$4 = b$4; $f.b$5 = b$5; $f.bType = bType; $f.bVal = bVal; $f.bp = bp; $f.c = c; $f.c$1 = c$1; $f.c$2 = c$2; $f.c$3 = c$3; $f.c$4 = c$4; $f.c$5 = c$5; $f.i = i; $f.i$1 = i$1; $f.ok = ok; $f.ok$1 = ok$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	nilCompare = function(aVal, bVal) {
		var aVal, bVal;
		if ($clone(aVal, reflect.Value).IsNil()) {
			if ($clone(bVal, reflect.Value).IsNil()) {
				return [0, true];
			}
			return [-1, true];
		}
		if ($clone(bVal, reflect.Value).IsNil()) {
			return [1, true];
		}
		return [0, false];
	};
	floatCompare = function(a, b) {
		var a, b;
		if (isNaN(a)) {
			return -1;
		} else if (isNaN(b)) {
			return 1;
		} else if (a < b) {
			return -1;
		} else if (a > b) {
			return 1;
		}
		return 0;
	};
	isNaN = function(a) {
		var a;
		return !((a === a));
	};
	ptrType.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Less", name: "Less", pkg: "", typ: $funcType([$Int, $Int], [$Bool], false)}, {prop: "Swap", name: "Swap", pkg: "", typ: $funcType([$Int, $Int], [], false)}];
	SortedMap.init("", [{prop: "Key", name: "Key", embedded: false, exported: true, typ: sliceType, tag: ""}, {prop: "Value", name: "Value", embedded: false, exported: true, typ: sliceType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = reflect.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sort.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["syscall"] = (function() {
	var $pkg = {}, $init, js, race, runtime, sync, RawConn, SockaddrLinklayer, SockaddrNetlink, mmapper, Errno, Sockaddr, SockaddrInet4, SockaddrInet6, SockaddrUnix, Timespec, Stat_t, RawSockaddrInet4, RawSockaddrInet6, RawSockaddrUnix, RawSockaddrLinklayer, RawSockaddrNetlink, RawSockaddr, RawSockaddrAny, _Socklen, Linger, Iovec, IPMreq, IPMreqn, IPv6Mreq, Msghdr, sliceType, sliceType$1, ptrType$2, ptrType$4, arrayType$1, ptrType$9, arrayType$2, ptrType$12, arrayType$4, arrayType$5, arrayType$8, arrayType$9, arrayType$10, arrayType$11, ptrType$19, ptrType$20, structType, ptrType$23, funcType, funcType$1, ptrType$25, ptrType$26, mapType, funcType$2, funcType$3, ptrType$27, ptrType$28, ptrType$29, ptrType$30, ptrType$32, warningPrinted, lineBuffer, syscallModule, alreadyTriedToLoad, minusOne, envs, mapper, errEAGAIN, errEINVAL, errENOENT, ioSync, ioSync$24ptr, errors, init, printWarning, printToConsole, Exit, indexByte, runtime_envs, syscallByName, Syscall, Syscall6, BytePtrFromString, readInt, readIntBE, readIntLE, ParseDirent, CloseOnExec, SetNonblock, msanRead, msanWrite, itoa, uitoa, anyToSockaddr, Accept, Accept4, SetsockoptIPMreqn, Recvmsg, SendmsgN, ReadDirent, direntIno, direntReclen, direntNamlen, Lstat, errnoErr, Read, Write, GetsockoptInt, Recvfrom, Sendto, SetsockoptByte, SetsockoptInt, SetsockoptInet4Addr, SetsockoptIPMreq, SetsockoptIPv6Mreq, SetsockoptLinger, Close, Dup, Fchdir, Fchmod, fcntl, Fsync, Getdents, read, write, munmap, Fchown, Fstat, Ftruncate, Pread, Pwrite, Seek, Shutdown, accept, accept4, fstatat, getsockopt, setsockopt, recvfrom, sendto, recvmsg, sendmsg, mmap;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	race = $packages["internal/race"];
	runtime = $packages["runtime"];
	sync = $packages["sync"];
	RawConn = $pkg.RawConn = $newType(8, $kindInterface, "syscall.RawConn", true, "syscall", true, null);
	SockaddrLinklayer = $pkg.SockaddrLinklayer = $newType(0, $kindStruct, "syscall.SockaddrLinklayer", true, "syscall", true, function(Protocol_, Ifindex_, Hatype_, Pkttype_, Halen_, Addr_, raw_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Protocol = 0;
			this.Ifindex = 0;
			this.Hatype = 0;
			this.Pkttype = 0;
			this.Halen = 0;
			this.Addr = arrayType$1.zero();
			this.raw = new RawSockaddrLinklayer.ptr(0, 0, 0, 0, 0, 0, arrayType$1.zero());
			return;
		}
		this.Protocol = Protocol_;
		this.Ifindex = Ifindex_;
		this.Hatype = Hatype_;
		this.Pkttype = Pkttype_;
		this.Halen = Halen_;
		this.Addr = Addr_;
		this.raw = raw_;
	});
	SockaddrNetlink = $pkg.SockaddrNetlink = $newType(0, $kindStruct, "syscall.SockaddrNetlink", true, "syscall", true, function(Family_, Pad_, Pid_, Groups_, raw_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Pad = 0;
			this.Pid = 0;
			this.Groups = 0;
			this.raw = new RawSockaddrNetlink.ptr(0, 0, 0, 0);
			return;
		}
		this.Family = Family_;
		this.Pad = Pad_;
		this.Pid = Pid_;
		this.Groups = Groups_;
		this.raw = raw_;
	});
	mmapper = $pkg.mmapper = $newType(0, $kindStruct, "syscall.mmapper", true, "syscall", false, function(Mutex_, active_, mmap_, munmap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Mutex = new sync.Mutex.ptr(0, 0);
			this.active = false;
			this.mmap = $throwNilPointerError;
			this.munmap = $throwNilPointerError;
			return;
		}
		this.Mutex = Mutex_;
		this.active = active_;
		this.mmap = mmap_;
		this.munmap = munmap_;
	});
	Errno = $pkg.Errno = $newType(4, $kindUintptr, "syscall.Errno", true, "syscall", true, null);
	Sockaddr = $pkg.Sockaddr = $newType(8, $kindInterface, "syscall.Sockaddr", true, "syscall", true, null);
	SockaddrInet4 = $pkg.SockaddrInet4 = $newType(0, $kindStruct, "syscall.SockaddrInet4", true, "syscall", true, function(Port_, Addr_, raw_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Port = 0;
			this.Addr = arrayType$9.zero();
			this.raw = new RawSockaddrInet4.ptr(0, 0, arrayType$9.zero(), arrayType$1.zero());
			return;
		}
		this.Port = Port_;
		this.Addr = Addr_;
		this.raw = raw_;
	});
	SockaddrInet6 = $pkg.SockaddrInet6 = $newType(0, $kindStruct, "syscall.SockaddrInet6", true, "syscall", true, function(Port_, ZoneId_, Addr_, raw_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Port = 0;
			this.ZoneId = 0;
			this.Addr = arrayType$2.zero();
			this.raw = new RawSockaddrInet6.ptr(0, 0, 0, arrayType$2.zero(), 0);
			return;
		}
		this.Port = Port_;
		this.ZoneId = ZoneId_;
		this.Addr = Addr_;
		this.raw = raw_;
	});
	SockaddrUnix = $pkg.SockaddrUnix = $newType(0, $kindStruct, "syscall.SockaddrUnix", true, "syscall", true, function(Name_, raw_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = "";
			this.raw = new RawSockaddrUnix.ptr(0, arrayType$8.zero());
			return;
		}
		this.Name = Name_;
		this.raw = raw_;
	});
	Timespec = $pkg.Timespec = $newType(0, $kindStruct, "syscall.Timespec", true, "syscall", true, function(Sec_, Nsec_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Sec = new $Int64(0, 0);
			this.Nsec = new $Int64(0, 0);
			return;
		}
		this.Sec = Sec_;
		this.Nsec = Nsec_;
	});
	Stat_t = $pkg.Stat_t = $newType(0, $kindStruct, "syscall.Stat_t", true, "syscall", true, function(Dev_, Ino_, Nlink_, Mode_, Uid_, Gid_, X__pad0_, Rdev_, Size_, Blksize_, Blocks_, Atim_, Mtim_, Ctim_, X__unused_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Dev = new $Uint64(0, 0);
			this.Ino = new $Uint64(0, 0);
			this.Nlink = new $Uint64(0, 0);
			this.Mode = 0;
			this.Uid = 0;
			this.Gid = 0;
			this.X__pad0 = 0;
			this.Rdev = new $Uint64(0, 0);
			this.Size = new $Int64(0, 0);
			this.Blksize = new $Int64(0, 0);
			this.Blocks = new $Int64(0, 0);
			this.Atim = new Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0));
			this.Mtim = new Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0));
			this.Ctim = new Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0));
			this.X__unused = arrayType$5.zero();
			return;
		}
		this.Dev = Dev_;
		this.Ino = Ino_;
		this.Nlink = Nlink_;
		this.Mode = Mode_;
		this.Uid = Uid_;
		this.Gid = Gid_;
		this.X__pad0 = X__pad0_;
		this.Rdev = Rdev_;
		this.Size = Size_;
		this.Blksize = Blksize_;
		this.Blocks = Blocks_;
		this.Atim = Atim_;
		this.Mtim = Mtim_;
		this.Ctim = Ctim_;
		this.X__unused = X__unused_;
	});
	RawSockaddrInet4 = $pkg.RawSockaddrInet4 = $newType(0, $kindStruct, "syscall.RawSockaddrInet4", true, "syscall", true, function(Family_, Port_, Addr_, Zero_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Port = 0;
			this.Addr = arrayType$9.zero();
			this.Zero = arrayType$1.zero();
			return;
		}
		this.Family = Family_;
		this.Port = Port_;
		this.Addr = Addr_;
		this.Zero = Zero_;
	});
	RawSockaddrInet6 = $pkg.RawSockaddrInet6 = $newType(0, $kindStruct, "syscall.RawSockaddrInet6", true, "syscall", true, function(Family_, Port_, Flowinfo_, Addr_, Scope_id_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Port = 0;
			this.Flowinfo = 0;
			this.Addr = arrayType$2.zero();
			this.Scope_id = 0;
			return;
		}
		this.Family = Family_;
		this.Port = Port_;
		this.Flowinfo = Flowinfo_;
		this.Addr = Addr_;
		this.Scope_id = Scope_id_;
	});
	RawSockaddrUnix = $pkg.RawSockaddrUnix = $newType(0, $kindStruct, "syscall.RawSockaddrUnix", true, "syscall", true, function(Family_, Path_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Path = arrayType$8.zero();
			return;
		}
		this.Family = Family_;
		this.Path = Path_;
	});
	RawSockaddrLinklayer = $pkg.RawSockaddrLinklayer = $newType(0, $kindStruct, "syscall.RawSockaddrLinklayer", true, "syscall", true, function(Family_, Protocol_, Ifindex_, Hatype_, Pkttype_, Halen_, Addr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Protocol = 0;
			this.Ifindex = 0;
			this.Hatype = 0;
			this.Pkttype = 0;
			this.Halen = 0;
			this.Addr = arrayType$1.zero();
			return;
		}
		this.Family = Family_;
		this.Protocol = Protocol_;
		this.Ifindex = Ifindex_;
		this.Hatype = Hatype_;
		this.Pkttype = Pkttype_;
		this.Halen = Halen_;
		this.Addr = Addr_;
	});
	RawSockaddrNetlink = $pkg.RawSockaddrNetlink = $newType(0, $kindStruct, "syscall.RawSockaddrNetlink", true, "syscall", true, function(Family_, Pad_, Pid_, Groups_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Pad = 0;
			this.Pid = 0;
			this.Groups = 0;
			return;
		}
		this.Family = Family_;
		this.Pad = Pad_;
		this.Pid = Pid_;
		this.Groups = Groups_;
	});
	RawSockaddr = $pkg.RawSockaddr = $newType(0, $kindStruct, "syscall.RawSockaddr", true, "syscall", true, function(Family_, Data_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Family = 0;
			this.Data = arrayType$10.zero();
			return;
		}
		this.Family = Family_;
		this.Data = Data_;
	});
	RawSockaddrAny = $pkg.RawSockaddrAny = $newType(0, $kindStruct, "syscall.RawSockaddrAny", true, "syscall", true, function(Addr_, Pad_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Addr = new RawSockaddr.ptr(0, arrayType$10.zero());
			this.Pad = arrayType$11.zero();
			return;
		}
		this.Addr = Addr_;
		this.Pad = Pad_;
	});
	_Socklen = $pkg._Socklen = $newType(4, $kindUint32, "syscall._Socklen", true, "syscall", false, null);
	Linger = $pkg.Linger = $newType(0, $kindStruct, "syscall.Linger", true, "syscall", true, function(Onoff_, Linger_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Onoff = 0;
			this.Linger = 0;
			return;
		}
		this.Onoff = Onoff_;
		this.Linger = Linger_;
	});
	Iovec = $pkg.Iovec = $newType(0, $kindStruct, "syscall.Iovec", true, "syscall", true, function(Base_, Len_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Base = ptrType$2.nil;
			this.Len = new $Uint64(0, 0);
			return;
		}
		this.Base = Base_;
		this.Len = Len_;
	});
	IPMreq = $pkg.IPMreq = $newType(0, $kindStruct, "syscall.IPMreq", true, "syscall", true, function(Multiaddr_, Interface_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Multiaddr = arrayType$9.zero();
			this.Interface = arrayType$9.zero();
			return;
		}
		this.Multiaddr = Multiaddr_;
		this.Interface = Interface_;
	});
	IPMreqn = $pkg.IPMreqn = $newType(0, $kindStruct, "syscall.IPMreqn", true, "syscall", true, function(Multiaddr_, Address_, Ifindex_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Multiaddr = arrayType$9.zero();
			this.Address = arrayType$9.zero();
			this.Ifindex = 0;
			return;
		}
		this.Multiaddr = Multiaddr_;
		this.Address = Address_;
		this.Ifindex = Ifindex_;
	});
	IPv6Mreq = $pkg.IPv6Mreq = $newType(0, $kindStruct, "syscall.IPv6Mreq", true, "syscall", true, function(Multiaddr_, Interface_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Multiaddr = arrayType$2.zero();
			this.Interface = 0;
			return;
		}
		this.Multiaddr = Multiaddr_;
		this.Interface = Interface_;
	});
	Msghdr = $pkg.Msghdr = $newType(0, $kindStruct, "syscall.Msghdr", true, "syscall", true, function(Name_, Namelen_, Pad_cgo_0_, Iov_, Iovlen_, Control_, Controllen_, Flags_, Pad_cgo_1_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = ptrType$2.nil;
			this.Namelen = 0;
			this.Pad_cgo_0 = arrayType$9.zero();
			this.Iov = ptrType$20.nil;
			this.Iovlen = new $Uint64(0, 0);
			this.Control = ptrType$2.nil;
			this.Controllen = new $Uint64(0, 0);
			this.Flags = 0;
			this.Pad_cgo_1 = arrayType$9.zero();
			return;
		}
		this.Name = Name_;
		this.Namelen = Namelen_;
		this.Pad_cgo_0 = Pad_cgo_0_;
		this.Iov = Iov_;
		this.Iovlen = Iovlen_;
		this.Control = Control_;
		this.Controllen = Controllen_;
		this.Flags = Flags_;
		this.Pad_cgo_1 = Pad_cgo_1_;
	});
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType($String);
	ptrType$2 = $ptrType($Uint8);
	ptrType$4 = $ptrType($Int32);
	arrayType$1 = $arrayType($Uint8, 8);
	ptrType$9 = $ptrType($Uint16);
	arrayType$2 = $arrayType($Uint8, 16);
	ptrType$12 = $ptrType(SockaddrNetlink);
	arrayType$4 = $arrayType($Uint8, 32);
	arrayType$5 = $arrayType($Int64, 3);
	arrayType$8 = $arrayType($Int8, 108);
	arrayType$9 = $arrayType($Uint8, 4);
	arrayType$10 = $arrayType($Int8, 14);
	arrayType$11 = $arrayType($Int8, 96);
	ptrType$19 = $ptrType(_Socklen);
	ptrType$20 = $ptrType(Iovec);
	structType = $structType("syscall", [{prop: "addr", name: "addr", embedded: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "len", name: "len", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "cap", name: "cap", embedded: false, exported: false, typ: $Int, tag: ""}]);
	ptrType$23 = $ptrType($Int64);
	funcType = $funcType([$Uintptr], [], false);
	funcType$1 = $funcType([$Uintptr], [$Bool], false);
	ptrType$25 = $ptrType(SockaddrLinklayer);
	ptrType$26 = $ptrType(mmapper);
	mapType = $mapType(ptrType$2, sliceType);
	funcType$2 = $funcType([$Uintptr, $Uintptr, $Int, $Int, $Int, $Int64], [$Uintptr, $error], false);
	funcType$3 = $funcType([$Uintptr, $Uintptr], [$error], false);
	ptrType$27 = $ptrType(SockaddrInet4);
	ptrType$28 = $ptrType(SockaddrInet6);
	ptrType$29 = $ptrType(SockaddrUnix);
	ptrType$30 = $ptrType(Timespec);
	ptrType$32 = $ptrType(Msghdr);
	init = function() {
		$flushConsole = (function() {
			if (!((lineBuffer.$length === 0))) {
				$global.console.log($externalize(($bytesToString(lineBuffer)), $String));
				lineBuffer = sliceType.nil;
			}
		});
	};
	printWarning = function() {
		if (!warningPrinted) {
			$global.console.error($externalize("warning: system calls not available, see https://github.com/gopherjs/gopherjs/blob/master/doc/syscalls.md", $String));
		}
		warningPrinted = true;
	};
	printToConsole = function(b) {
		var b, goPrintToConsole, i;
		goPrintToConsole = $global.goPrintToConsole;
		if (!(goPrintToConsole === undefined)) {
			goPrintToConsole(b);
			return;
		}
		lineBuffer = $appendSlice(lineBuffer, b);
		while (true) {
			i = indexByte(lineBuffer, 10);
			if (i === -1) {
				break;
			}
			$global.console.log($externalize(($bytesToString($subslice(lineBuffer, 0, i))), $String));
			lineBuffer = $subslice(lineBuffer, (i + 1 >> 0));
		}
	};
	Exit = function(code) {
		var code;
		Syscall(231, ((code >>> 0)), 0, 0);
	};
	$pkg.Exit = Exit;
	indexByte = function(s, c) {
		var _i, _ref, b, c, i, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (b === c) {
				return i;
			}
			_i++;
		}
		return -1;
	};
	runtime_envs = function() {
		var envkeys, envs$1, i, jsEnv, key, process;
		process = $global.process;
		if (process === undefined) {
			return sliceType$1.nil;
		}
		jsEnv = process.env;
		envkeys = $global.Object.keys(jsEnv);
		envs$1 = $makeSlice(sliceType$1, $parseInt(envkeys.length));
		i = 0;
		while (true) {
			if (!(i < $parseInt(envkeys.length))) { break; }
			key = $internalize(envkeys[i], $String);
			((i < 0 || i >= envs$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : envs$1.$array[envs$1.$offset + i] = key + "=" + $internalize(jsEnv[$externalize(key, $String)], $String));
			i = i + (1) >> 0;
		}
		return envs$1;
	};
	syscallByName = function(name) {
		var name, require, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$deferred.push([(function() {
			$recover();
		}), []]);
		if (syscallModule === null) {
			if (alreadyTriedToLoad) {
				return null;
			}
			alreadyTriedToLoad = true;
			require = $global.require;
			if (require === undefined) {
				$panic(new $String(""));
			}
			syscallModule = require($externalize("syscall", $String));
		}
		return syscallModule[$externalize(name, $String)];
		/* */ } catch(err) { $err = err; return null; } finally { $callDeferred($deferred, $err); }
	};
	Syscall = function(trap, a1, a2, a3) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, a1, a2, a3, array, err, f, r, r1, r2, slice, trap;
		r1 = 0;
		r2 = 0;
		err = 0;
		f = syscallByName("Syscall");
		if (!(f === null)) {
			r = f(trap, a1, a2, a3);
			_tmp = ((($parseInt(r[0]) >> 0) >>> 0));
			_tmp$1 = ((($parseInt(r[1]) >> 0) >>> 0));
			_tmp$2 = ((($parseInt(r[2]) >> 0) >>> 0));
			r1 = _tmp;
			r2 = _tmp$1;
			err = _tmp$2;
			return [r1, r2, err];
		}
		if ((trap === 1) && ((a1 === 1) || (a1 === 2))) {
			array = a2;
			slice = $makeSlice(sliceType, $parseInt(array.length));
			slice.$array = array;
			printToConsole(slice);
			_tmp$3 = (($parseInt(array.length) >>> 0));
			_tmp$4 = 0;
			_tmp$5 = 0;
			r1 = _tmp$3;
			r2 = _tmp$4;
			err = _tmp$5;
			return [r1, r2, err];
		}
		if (trap === 231) {
			runtime.Goexit();
		}
		printWarning();
		_tmp$6 = ((minusOne >>> 0));
		_tmp$7 = 0;
		_tmp$8 = 13;
		r1 = _tmp$6;
		r2 = _tmp$7;
		err = _tmp$8;
		return [r1, r2, err];
	};
	$pkg.Syscall = Syscall;
	Syscall6 = function(trap, a1, a2, a3, a4, a5, a6) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, a1, a2, a3, a4, a5, a6, err, f, r, r1, r2, trap;
		r1 = 0;
		r2 = 0;
		err = 0;
		f = syscallByName("Syscall6");
		if (!(f === null)) {
			r = f(trap, a1, a2, a3, a4, a5, a6);
			_tmp = ((($parseInt(r[0]) >> 0) >>> 0));
			_tmp$1 = ((($parseInt(r[1]) >> 0) >>> 0));
			_tmp$2 = ((($parseInt(r[2]) >> 0) >>> 0));
			r1 = _tmp;
			r2 = _tmp$1;
			err = _tmp$2;
			return [r1, r2, err];
		}
		if (!((trap === 202))) {
			printWarning();
		}
		_tmp$3 = ((minusOne >>> 0));
		_tmp$4 = 0;
		_tmp$5 = 13;
		r1 = _tmp$3;
		r2 = _tmp$4;
		err = _tmp$5;
		return [r1, r2, err];
	};
	$pkg.Syscall6 = Syscall6;
	BytePtrFromString = function(s) {
		var _i, _ref, array, b, i, s;
		array = new ($global.Uint8Array)(s.length + 1 >> 0);
		_ref = (new sliceType($stringToBytes(s)));
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (b === 0) {
				return [ptrType$2.nil, new Errno(22)];
			}
			array[i] = b;
			_i++;
		}
		array[s.length] = 0;
		return [((array)), $ifaceNil];
	};
	$pkg.BytePtrFromString = BytePtrFromString;
	readInt = function(b, off, size) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, off, ok, size, u;
		u = new $Uint64(0, 0);
		ok = false;
		if (b.$length < (((off + size >>> 0) >> 0))) {
			_tmp = new $Uint64(0, 0);
			_tmp$1 = false;
			u = _tmp;
			ok = _tmp$1;
			return [u, ok];
		}
		if (false) {
			_tmp$2 = readIntBE($subslice(b, off), size);
			_tmp$3 = true;
			u = _tmp$2;
			ok = _tmp$3;
			return [u, ok];
		}
		_tmp$4 = readIntLE($subslice(b, off), size);
		_tmp$5 = true;
		u = _tmp$4;
		ok = _tmp$5;
		return [u, ok];
	};
	readIntBE = function(b, size) {
		var _1, b, size, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		_1 = size;
		if (_1 === (1)) {
			return (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0])));
		} else if (_1 === (2)) {
			$unused((1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]));
			return (x = (new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), x$1 = $shiftLeft64((new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), 8), new $Uint64(x.$high | x$1.$high, (x.$low | x$1.$low) >>> 0));
		} else if (_1 === (4)) {
			$unused((3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]));
			return (x$2 = (x$3 = (x$4 = (new $Uint64(0, (3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]))), x$5 = $shiftLeft64((new $Uint64(0, (2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2]))), 8), new $Uint64(x$4.$high | x$5.$high, (x$4.$low | x$5.$low) >>> 0)), x$6 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 16), new $Uint64(x$3.$high | x$6.$high, (x$3.$low | x$6.$low) >>> 0)), x$7 = $shiftLeft64((new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), 24), new $Uint64(x$2.$high | x$7.$high, (x$2.$low | x$7.$low) >>> 0));
		} else if (_1 === (8)) {
			$unused((7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]));
			return (x$8 = (x$9 = (x$10 = (x$11 = (x$12 = (x$13 = (x$14 = (new $Uint64(0, (7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]))), x$15 = $shiftLeft64((new $Uint64(0, (6 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 6]))), 8), new $Uint64(x$14.$high | x$15.$high, (x$14.$low | x$15.$low) >>> 0)), x$16 = $shiftLeft64((new $Uint64(0, (5 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 5]))), 16), new $Uint64(x$13.$high | x$16.$high, (x$13.$low | x$16.$low) >>> 0)), x$17 = $shiftLeft64((new $Uint64(0, (4 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 4]))), 24), new $Uint64(x$12.$high | x$17.$high, (x$12.$low | x$17.$low) >>> 0)), x$18 = $shiftLeft64((new $Uint64(0, (3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]))), 32), new $Uint64(x$11.$high | x$18.$high, (x$11.$low | x$18.$low) >>> 0)), x$19 = $shiftLeft64((new $Uint64(0, (2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2]))), 40), new $Uint64(x$10.$high | x$19.$high, (x$10.$low | x$19.$low) >>> 0)), x$20 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 48), new $Uint64(x$9.$high | x$20.$high, (x$9.$low | x$20.$low) >>> 0)), x$21 = $shiftLeft64((new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), 56), new $Uint64(x$8.$high | x$21.$high, (x$8.$low | x$21.$low) >>> 0));
		} else {
			$panic(new $String("syscall: readInt with unsupported size"));
		}
	};
	readIntLE = function(b, size) {
		var _1, b, size, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		_1 = size;
		if (_1 === (1)) {
			return (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0])));
		} else if (_1 === (2)) {
			$unused((1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]));
			return (x = (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), x$1 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 8), new $Uint64(x.$high | x$1.$high, (x.$low | x$1.$low) >>> 0));
		} else if (_1 === (4)) {
			$unused((3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]));
			return (x$2 = (x$3 = (x$4 = (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), x$5 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 8), new $Uint64(x$4.$high | x$5.$high, (x$4.$low | x$5.$low) >>> 0)), x$6 = $shiftLeft64((new $Uint64(0, (2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2]))), 16), new $Uint64(x$3.$high | x$6.$high, (x$3.$low | x$6.$low) >>> 0)), x$7 = $shiftLeft64((new $Uint64(0, (3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]))), 24), new $Uint64(x$2.$high | x$7.$high, (x$2.$low | x$7.$low) >>> 0));
		} else if (_1 === (8)) {
			$unused((7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]));
			return (x$8 = (x$9 = (x$10 = (x$11 = (x$12 = (x$13 = (x$14 = (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), x$15 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 8), new $Uint64(x$14.$high | x$15.$high, (x$14.$low | x$15.$low) >>> 0)), x$16 = $shiftLeft64((new $Uint64(0, (2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2]))), 16), new $Uint64(x$13.$high | x$16.$high, (x$13.$low | x$16.$low) >>> 0)), x$17 = $shiftLeft64((new $Uint64(0, (3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]))), 24), new $Uint64(x$12.$high | x$17.$high, (x$12.$low | x$17.$low) >>> 0)), x$18 = $shiftLeft64((new $Uint64(0, (4 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 4]))), 32), new $Uint64(x$11.$high | x$18.$high, (x$11.$low | x$18.$low) >>> 0)), x$19 = $shiftLeft64((new $Uint64(0, (5 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 5]))), 40), new $Uint64(x$10.$high | x$19.$high, (x$10.$low | x$19.$low) >>> 0)), x$20 = $shiftLeft64((new $Uint64(0, (6 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 6]))), 48), new $Uint64(x$9.$high | x$20.$high, (x$9.$low | x$20.$low) >>> 0)), x$21 = $shiftLeft64((new $Uint64(0, (7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]))), 56), new $Uint64(x$8.$high | x$21.$high, (x$8.$low | x$21.$low) >>> 0));
		} else {
			$panic(new $String("syscall: readInt with unsupported size"));
		}
	};
	ParseDirent = function(buf, max, names) {
		var _i, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _tuple$2, buf, c, consumed, count, i, ino, max, name, names, namlen, newnames, ok, origlen, rec, reclen, x, x$1, x$2;
		consumed = 0;
		count = 0;
		newnames = sliceType$1.nil;
		origlen = buf.$length;
		count = 0;
		while (true) {
			if (!(!((max === 0)) && buf.$length > 0)) { break; }
			_tuple = direntReclen(buf);
			reclen = _tuple[0];
			ok = _tuple[1];
			if (!ok || (x = (new $Uint64(0, buf.$length)), (reclen.$high > x.$high || (reclen.$high === x.$high && reclen.$low > x.$low)))) {
				_tmp = origlen;
				_tmp$1 = count;
				_tmp$2 = names;
				consumed = _tmp;
				count = _tmp$1;
				newnames = _tmp$2;
				return [consumed, count, newnames];
			}
			rec = $subslice(buf, 0, $flatten64(reclen));
			buf = $subslice(buf, $flatten64(reclen));
			_tuple$1 = direntIno(rec);
			ino = _tuple$1[0];
			ok = _tuple$1[1];
			if (!ok) {
				break;
			}
			if ((ino.$high === 0 && ino.$low === 0)) {
				continue;
			}
			_tuple$2 = direntNamlen(rec);
			namlen = _tuple$2[0];
			ok = _tuple$2[1];
			if (!ok || (x$1 = new $Uint64(0 + namlen.$high, 19 + namlen.$low), x$2 = (new $Uint64(0, rec.$length)), (x$1.$high > x$2.$high || (x$1.$high === x$2.$high && x$1.$low > x$2.$low)))) {
				break;
			}
			name = $subslice(rec, 19, $flatten64(new $Uint64(0 + namlen.$high, 19 + namlen.$low)));
			_ref = name;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (c === 0) {
					name = $subslice(name, 0, i);
					break;
				}
				_i++;
			}
			if (($bytesToString(name)) === "." || ($bytesToString(name)) === "..") {
				continue;
			}
			max = max - (1) >> 0;
			count = count + (1) >> 0;
			names = $append(names, ($bytesToString(name)));
		}
		_tmp$3 = origlen - buf.$length >> 0;
		_tmp$4 = count;
		_tmp$5 = names;
		consumed = _tmp$3;
		count = _tmp$4;
		newnames = _tmp$5;
		return [consumed, count, newnames];
	};
	$pkg.ParseDirent = ParseDirent;
	CloseOnExec = function(fd) {
		var fd;
		fcntl(fd, 2, 1);
	};
	$pkg.CloseOnExec = CloseOnExec;
	SetNonblock = function(fd, nonblocking) {
		var _tuple, _tuple$1, err, fd, flag, nonblocking;
		err = $ifaceNil;
		_tuple = fcntl(fd, 3, 0);
		flag = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			err = err;
			return err;
		}
		if (nonblocking) {
			flag = flag | (2048);
		} else {
			flag = (flag & ~(2048)) >> 0;
		}
		_tuple$1 = fcntl(fd, 4, flag);
		err = _tuple$1[1];
		err = err;
		return err;
	};
	$pkg.SetNonblock = SetNonblock;
	msanRead = function(addr, len) {
		var addr, len;
	};
	msanWrite = function(addr, len) {
		var addr, len;
	};
	itoa = function(val) {
		var val;
		if (val < 0) {
			return "-" + uitoa(((-val >>> 0)));
		}
		return uitoa(((val >>> 0)));
	};
	uitoa = function(val) {
		var _q, _r, buf, i, val;
		buf = arrayType$4.zero();
		i = 31;
		while (true) {
			if (!(val >= 10)) { break; }
			((i < 0 || i >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[i] = ((((_r = val % 10, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) + 48 >>> 0) << 24 >>> 24)));
			i = i - (1) >> 0;
			val = (_q = val / (10), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		}
		((i < 0 || i >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[i] = (((val + 48 >>> 0) << 24 >>> 24)));
		return ($bytesToString($subslice(new sliceType(buf), i)));
	};
	Timespec.ptr.prototype.Unix = function() {
		var _tmp, _tmp$1, nsec, sec, ts;
		sec = new $Int64(0, 0);
		nsec = new $Int64(0, 0);
		ts = this;
		_tmp = (ts.Sec);
		_tmp$1 = (ts.Nsec);
		sec = _tmp;
		nsec = _tmp$1;
		return [sec, nsec];
	};
	Timespec.prototype.Unix = function() { return this.$val.Unix(); };
	Timespec.ptr.prototype.Nano = function() {
		var ts, x, x$1;
		ts = this;
		return (x = $mul64((ts.Sec), new $Int64(0, 1000000000)), x$1 = (ts.Nsec), new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
	};
	Timespec.prototype.Nano = function() { return this.$val.Nano(); };
	SockaddrInet4.ptr.prototype.sockaddr = function() {
		var _array, _struct, _view, i, p, sa, x, x$1, x$2;
		sa = this;
		if (sa.Port < 0 || sa.Port > 65535) {
			return [0, 0, new Errno(22)];
		}
		sa.raw.Family = 2;
		p = (((x = sa.raw, (x.$ptr_Port || (x.$ptr_Port = new ptrType$9(function() { return this.$target.Port; }, function($v) { this.$target.Port = $v; }, x))))));
		p.nilCheck, p[0] = (((sa.Port >> 8 >> 0) << 24 >>> 24));
		p.nilCheck, p[1] = ((sa.Port << 24 >>> 24));
		i = 0;
		while (true) {
			if (!(i < 4)) { break; }
			(x$2 = sa.raw.Addr, ((i < 0 || i >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i] = (x$1 = sa.Addr, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i]))));
			i = i + (1) >> 0;
		}
		_array = new Uint8Array(16);
		return [(_array), 16, $ifaceNil];
	};
	SockaddrInet4.prototype.sockaddr = function() { return this.$val.sockaddr(); };
	SockaddrInet6.ptr.prototype.sockaddr = function() {
		var _array, _struct, _view, i, p, sa, x, x$1, x$2;
		sa = this;
		if (sa.Port < 0 || sa.Port > 65535) {
			return [0, 0, new Errno(22)];
		}
		sa.raw.Family = 10;
		p = (((x = sa.raw, (x.$ptr_Port || (x.$ptr_Port = new ptrType$9(function() { return this.$target.Port; }, function($v) { this.$target.Port = $v; }, x))))));
		p.nilCheck, p[0] = (((sa.Port >> 8 >> 0) << 24 >>> 24));
		p.nilCheck, p[1] = ((sa.Port << 24 >>> 24));
		sa.raw.Scope_id = sa.ZoneId;
		i = 0;
		while (true) {
			if (!(i < 16)) { break; }
			(x$2 = sa.raw.Addr, ((i < 0 || i >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i] = (x$1 = sa.Addr, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i]))));
			i = i + (1) >> 0;
		}
		_array = new Uint8Array(28);
		return [(_array), 28, $ifaceNil];
	};
	SockaddrInet6.prototype.sockaddr = function() { return this.$val.sockaddr(); };
	SockaddrUnix.ptr.prototype.sockaddr = function() {
		var _array, _struct, _view, i, n, name, sa, sl, x;
		sa = this;
		name = sa.Name;
		n = name.length;
		if (n > 108) {
			return [0, 0, new Errno(22)];
		}
		if ((n === 108) && !((name.charCodeAt(0) === 64))) {
			return [0, 0, new Errno(22)];
		}
		sa.raw.Family = 1;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			(x = sa.raw.Path, ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i] = ((name.charCodeAt(i) << 24 >> 24))));
			i = i + (1) >> 0;
		}
		sl = 2;
		if (n > 0) {
			sl = sl + ((((n >>> 0)) + 1 >>> 0)) >>> 0;
		}
		if (sa.raw.Path[0] === 64) {
			sa.raw.Path[0] = 0;
			sl = sl - (1) >>> 0;
		}
		_array = new Uint8Array(110);
		return [(_array), sl, $ifaceNil];
	};
	SockaddrUnix.prototype.sockaddr = function() { return this.$val.sockaddr(); };
	SockaddrLinklayer.ptr.prototype.sockaddr = function() {
		var _array, _struct, _view, i, sa, x, x$1;
		sa = this;
		if (sa.Ifindex < 0 || sa.Ifindex > 2147483647) {
			return [0, 0, new Errno(22)];
		}
		sa.raw.Family = 17;
		sa.raw.Protocol = sa.Protocol;
		sa.raw.Ifindex = ((sa.Ifindex >> 0));
		sa.raw.Hatype = sa.Hatype;
		sa.raw.Pkttype = sa.Pkttype;
		sa.raw.Halen = sa.Halen;
		i = 0;
		while (true) {
			if (!(i < 8)) { break; }
			(x$1 = sa.raw.Addr, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i] = (x = sa.Addr, ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i]))));
			i = i + (1) >> 0;
		}
		_array = new Uint8Array(20);
		return [(_array), 20, $ifaceNil];
	};
	SockaddrLinklayer.prototype.sockaddr = function() { return this.$val.sockaddr(); };
	SockaddrNetlink.ptr.prototype.sockaddr = function() {
		var _array, _struct, _view, sa;
		sa = this;
		sa.raw.Family = 16;
		sa.raw.Pad = sa.Pad;
		sa.raw.Pid = sa.Pid;
		sa.raw.Groups = sa.Groups;
		_array = new Uint8Array(12);
		return [(_array), 12, $ifaceNil];
	};
	SockaddrNetlink.prototype.sockaddr = function() { return this.$val.sockaddr(); };
	anyToSockaddr = function(rsa) {
		var _1, _array, _array$1, _array$2, _array$3, _array$4, _array$5, _array$6, _array$7, _array$8, _array$9, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, _struct$6, _struct$7, _struct$8, _struct$9, _view, _view$1, _view$2, _view$3, _view$4, _view$5, _view$6, _view$7, _view$8, _view$9, bytes, i, i$1, i$2, n, p, p$1, pp, pp$1, pp$2, pp$3, pp$4, rsa, sa, sa$1, sa$2, sa$3, sa$4, x, x$1, x$2, x$3, x$4, x$5, x$6;
		_1 = rsa.Addr.Family;
		if (_1 === (16)) {
			_array$1 = new Uint8Array(112);
			pp = ((_array = (_array$1), _struct = new RawSockaddrNetlink.ptr(0, 0, 0, 0), _view = new DataView(_array.buffer, _array.byteOffset), _struct.Family = _view.getUint16(0, true), _struct.Pad = _view.getUint16(2, true), _struct.Pid = _view.getUint32(4, true), _struct.Groups = _view.getUint32(8, true), _struct));
			_struct$1 = rsa, _view$1 = new DataView(_array$1.buffer, _array$1.byteOffset), _struct$1.Addr.Family = _view$1.getUint16(0, true), _struct$1.Addr.Data = new ($nativeArray($kindInt8))(_array$1.buffer, $min(_array$1.byteOffset + 2, _array$1.buffer.byteLength)), _struct$1.Pad = new ($nativeArray($kindInt8))(_array$1.buffer, $min(_array$1.byteOffset + 16, _array$1.buffer.byteLength));
			sa = new SockaddrNetlink.ptr(0, 0, 0, 0, new RawSockaddrNetlink.ptr(0, 0, 0, 0));
			sa.Family = pp.Family;
			sa.Pad = pp.Pad;
			sa.Pid = pp.Pid;
			sa.Groups = pp.Groups;
			return [sa, $ifaceNil];
		} else if (_1 === (17)) {
			_array$3 = new Uint8Array(112);
			pp$1 = ((_array$2 = (_array$3), _struct$2 = new RawSockaddrLinklayer.ptr(0, 0, 0, 0, 0, 0, arrayType$1.zero()), _view$2 = new DataView(_array$2.buffer, _array$2.byteOffset), _struct$2.Family = _view$2.getUint16(0, true), _struct$2.Protocol = _view$2.getUint16(2, true), _struct$2.Ifindex = _view$2.getInt32(4, true), _struct$2.Hatype = _view$2.getUint16(8, true), _struct$2.Pkttype = _view$2.getUint8(10, true), _struct$2.Halen = _view$2.getUint8(11, true), _struct$2.Addr = new ($nativeArray($kindUint8))(_array$2.buffer, $min(_array$2.byteOffset + 12, _array$2.buffer.byteLength)), _struct$2));
			_struct$3 = rsa, _view$3 = new DataView(_array$3.buffer, _array$3.byteOffset), _struct$3.Addr.Family = _view$3.getUint16(0, true), _struct$3.Addr.Data = new ($nativeArray($kindInt8))(_array$3.buffer, $min(_array$3.byteOffset + 2, _array$3.buffer.byteLength)), _struct$3.Pad = new ($nativeArray($kindInt8))(_array$3.buffer, $min(_array$3.byteOffset + 16, _array$3.buffer.byteLength));
			sa$1 = new SockaddrLinklayer.ptr(0, 0, 0, 0, 0, arrayType$1.zero(), new RawSockaddrLinklayer.ptr(0, 0, 0, 0, 0, 0, arrayType$1.zero()));
			sa$1.Protocol = pp$1.Protocol;
			sa$1.Ifindex = ((pp$1.Ifindex >> 0));
			sa$1.Hatype = pp$1.Hatype;
			sa$1.Pkttype = pp$1.Pkttype;
			sa$1.Halen = pp$1.Halen;
			i = 0;
			while (true) {
				if (!(i < 8)) { break; }
				(x$1 = sa$1.Addr, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i] = (x = pp$1.Addr, ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i]))));
				i = i + (1) >> 0;
			}
			return [sa$1, $ifaceNil];
		} else if (_1 === (1)) {
			_array$5 = new Uint8Array(112);
			pp$2 = ((_array$4 = (_array$5), _struct$4 = new RawSockaddrUnix.ptr(0, arrayType$8.zero()), _view$4 = new DataView(_array$4.buffer, _array$4.byteOffset), _struct$4.Family = _view$4.getUint16(0, true), _struct$4.Path = new ($nativeArray($kindInt8))(_array$4.buffer, $min(_array$4.byteOffset + 2, _array$4.buffer.byteLength)), _struct$4));
			_struct$5 = rsa, _view$5 = new DataView(_array$5.buffer, _array$5.byteOffset), _struct$5.Addr.Family = _view$5.getUint16(0, true), _struct$5.Addr.Data = new ($nativeArray($kindInt8))(_array$5.buffer, $min(_array$5.byteOffset + 2, _array$5.buffer.byteLength)), _struct$5.Pad = new ($nativeArray($kindInt8))(_array$5.buffer, $min(_array$5.byteOffset + 16, _array$5.buffer.byteLength));
			sa$2 = new SockaddrUnix.ptr("", new RawSockaddrUnix.ptr(0, arrayType$8.zero()));
			if (pp$2.Path[0] === 0) {
				pp$2.Path[0] = 64;
			}
			n = 0;
			while (true) {
				if (!(n < 108 && !(((x$2 = pp$2.Path, ((n < 0 || n >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[n])) === 0)))) { break; }
				n = n + (1) >> 0;
			}
			bytes = $subslice(new sliceType((($sliceToArray(new sliceType(pp$2.Path))))), 0, n);
			sa$2.Name = ($bytesToString(bytes));
			return [sa$2, $ifaceNil];
		} else if (_1 === (2)) {
			_array$7 = new Uint8Array(112);
			pp$3 = ((_array$6 = (_array$7), _struct$6 = new RawSockaddrInet4.ptr(0, 0, arrayType$9.zero(), arrayType$1.zero()), _view$6 = new DataView(_array$6.buffer, _array$6.byteOffset), _struct$6.Family = _view$6.getUint16(0, true), _struct$6.Port = _view$6.getUint16(2, true), _struct$6.Addr = new ($nativeArray($kindUint8))(_array$6.buffer, $min(_array$6.byteOffset + 4, _array$6.buffer.byteLength)), _struct$6.Zero = new ($nativeArray($kindUint8))(_array$6.buffer, $min(_array$6.byteOffset + 8, _array$6.buffer.byteLength)), _struct$6));
			_struct$7 = rsa, _view$7 = new DataView(_array$7.buffer, _array$7.byteOffset), _struct$7.Addr.Family = _view$7.getUint16(0, true), _struct$7.Addr.Data = new ($nativeArray($kindInt8))(_array$7.buffer, $min(_array$7.byteOffset + 2, _array$7.buffer.byteLength)), _struct$7.Pad = new ($nativeArray($kindInt8))(_array$7.buffer, $min(_array$7.byteOffset + 16, _array$7.buffer.byteLength));
			sa$3 = new SockaddrInet4.ptr(0, arrayType$9.zero(), new RawSockaddrInet4.ptr(0, 0, arrayType$9.zero(), arrayType$1.zero()));
			p = (((pp$3.$ptr_Port || (pp$3.$ptr_Port = new ptrType$9(function() { return this.$target.Port; }, function($v) { this.$target.Port = $v; }, pp$3)))));
			sa$3.Port = ((((p.nilCheck, p[0]) >> 0)) << 8 >> 0) + (((p.nilCheck, p[1]) >> 0)) >> 0;
			i$1 = 0;
			while (true) {
				if (!(i$1 < 4)) { break; }
				(x$4 = sa$3.Addr, ((i$1 < 0 || i$1 >= x$4.length) ? ($throwRuntimeError("index out of range"), undefined) : x$4[i$1] = (x$3 = pp$3.Addr, ((i$1 < 0 || i$1 >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[i$1]))));
				i$1 = i$1 + (1) >> 0;
			}
			return [sa$3, $ifaceNil];
		} else if (_1 === (10)) {
			_array$9 = new Uint8Array(112);
			pp$4 = ((_array$8 = (_array$9), _struct$8 = new RawSockaddrInet6.ptr(0, 0, 0, arrayType$2.zero(), 0), _view$8 = new DataView(_array$8.buffer, _array$8.byteOffset), _struct$8.Family = _view$8.getUint16(0, true), _struct$8.Port = _view$8.getUint16(2, true), _struct$8.Flowinfo = _view$8.getUint32(4, true), _struct$8.Addr = new ($nativeArray($kindUint8))(_array$8.buffer, $min(_array$8.byteOffset + 8, _array$8.buffer.byteLength)), _struct$8.Scope_id = _view$8.getUint32(24, true), _struct$8));
			_struct$9 = rsa, _view$9 = new DataView(_array$9.buffer, _array$9.byteOffset), _struct$9.Addr.Family = _view$9.getUint16(0, true), _struct$9.Addr.Data = new ($nativeArray($kindInt8))(_array$9.buffer, $min(_array$9.byteOffset + 2, _array$9.buffer.byteLength)), _struct$9.Pad = new ($nativeArray($kindInt8))(_array$9.buffer, $min(_array$9.byteOffset + 16, _array$9.buffer.byteLength));
			sa$4 = new SockaddrInet6.ptr(0, 0, arrayType$2.zero(), new RawSockaddrInet6.ptr(0, 0, 0, arrayType$2.zero(), 0));
			p$1 = (((pp$4.$ptr_Port || (pp$4.$ptr_Port = new ptrType$9(function() { return this.$target.Port; }, function($v) { this.$target.Port = $v; }, pp$4)))));
			sa$4.Port = ((((p$1.nilCheck, p$1[0]) >> 0)) << 8 >> 0) + (((p$1.nilCheck, p$1[1]) >> 0)) >> 0;
			sa$4.ZoneId = pp$4.Scope_id;
			i$2 = 0;
			while (true) {
				if (!(i$2 < 16)) { break; }
				(x$6 = sa$4.Addr, ((i$2 < 0 || i$2 >= x$6.length) ? ($throwRuntimeError("index out of range"), undefined) : x$6[i$2] = (x$5 = pp$4.Addr, ((i$2 < 0 || i$2 >= x$5.length) ? ($throwRuntimeError("index out of range"), undefined) : x$5[i$2]))));
				i$2 = i$2 + (1) >> 0;
			}
			return [sa$4, $ifaceNil];
		}
		return [$ifaceNil, new Errno(97)];
	};
	Accept = function(fd) {
		var _tuple, _tuple$1, err, fd, len, len$24ptr, nfd, rsa, sa;
		nfd = 0;
		sa = $ifaceNil;
		err = $ifaceNil;
		rsa = new RawSockaddrAny.ptr(new RawSockaddr.ptr(0, arrayType$10.zero()), arrayType$11.zero());
		len = 112;
		_tuple = accept(fd, rsa, (len$24ptr || (len$24ptr = new ptrType$19(function() { return len; }, function($v) { len = $v; }))));
		nfd = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [nfd, sa, err];
		}
		_tuple$1 = anyToSockaddr(rsa);
		sa = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			Close(nfd);
			nfd = 0;
		}
		return [nfd, sa, err];
	};
	$pkg.Accept = Accept;
	Accept4 = function(fd, flags) {
		var _tuple, _tuple$1, err, fd, flags, len, len$24ptr, nfd, rsa, sa;
		nfd = 0;
		sa = $ifaceNil;
		err = $ifaceNil;
		rsa = new RawSockaddrAny.ptr(new RawSockaddr.ptr(0, arrayType$10.zero()), arrayType$11.zero());
		len = 112;
		_tuple = accept4(fd, rsa, (len$24ptr || (len$24ptr = new ptrType$19(function() { return len; }, function($v) { len = $v; }))), flags);
		nfd = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [nfd, sa, err];
		}
		if (len > 112) {
			$panic(new $String("RawSockaddrAny too small"));
		}
		_tuple$1 = anyToSockaddr(rsa);
		sa = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			Close(nfd);
			nfd = 0;
		}
		return [nfd, sa, err];
	};
	$pkg.Accept4 = Accept4;
	SetsockoptIPMreqn = function(fd, level, opt, mreq) {
		var _array, _struct, _view, err, fd, level, mreq, opt;
		err = $ifaceNil;
		_array = new Uint8Array(12);
		err = setsockopt(fd, level, opt, (_array), 12);
		_struct = mreq, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Multiaddr = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 0, _array.buffer.byteLength)), _struct.Address = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 4, _array.buffer.byteLength)), _struct.Ifindex = _view.getInt32(8, true);
		return err;
	};
	$pkg.SetsockoptIPMreqn = SetsockoptIPMreqn;
	Recvmsg = function(fd, p, oob, flags) {
		var _array, _struct, _tuple, _tuple$1, _tuple$2, _view, dummy, dummy$24ptr, err, fd, flags, from, iov, msg, n, oob, oobn, p, recvflags, rsa, sockType;
		n = 0;
		oobn = 0;
		recvflags = 0;
		from = $ifaceNil;
		err = $ifaceNil;
		msg = new Msghdr.ptr(ptrType$2.nil, 0, arrayType$9.zero(), ptrType$20.nil, new $Uint64(0, 0), ptrType$2.nil, new $Uint64(0, 0), 0, arrayType$9.zero());
		rsa = new RawSockaddrAny.ptr(new RawSockaddr.ptr(0, arrayType$10.zero()), arrayType$11.zero());
		_array = new Uint8Array(112);
		msg.Name = ((_array));
		_struct = rsa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 16, _array.buffer.byteLength));
		msg.Namelen = 112;
		iov = new Iovec.ptr(ptrType$2.nil, new $Uint64(0, 0));
		if (p.$length > 0) {
			iov.Base = $indexPtr(p.$array, p.$offset + 0, ptrType$2);
			iov.SetLen(p.$length);
		}
		dummy = 0;
		if (oob.$length > 0) {
			if (p.$length === 0) {
				sockType = 0;
				_tuple = GetsockoptInt(fd, 1, 3);
				sockType = _tuple[0];
				err = _tuple[1];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					return [n, oobn, recvflags, from, err];
				}
				if (!((sockType === 2))) {
					iov.Base = (dummy$24ptr || (dummy$24ptr = new ptrType$2(function() { return dummy; }, function($v) { dummy = $v; })));
					iov.SetLen(1);
				}
			}
			msg.Control = $indexPtr(oob.$array, oob.$offset + 0, ptrType$2);
			msg.SetControllen(oob.$length);
		}
		msg.Iov = iov;
		msg.Iovlen = new $Uint64(0, 1);
		_tuple$1 = recvmsg(fd, msg, flags);
		n = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [n, oobn, recvflags, from, err];
		}
		oobn = ((msg.Controllen.$low >> 0));
		recvflags = ((msg.Flags >> 0));
		if (!((rsa.Addr.Family === 0))) {
			_tuple$2 = anyToSockaddr(rsa);
			from = _tuple$2[0];
			err = _tuple$2[1];
		}
		return [n, oobn, recvflags, from, err];
	};
	$pkg.Recvmsg = Recvmsg;
	SendmsgN = function(fd, p, oob, to, flags) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, _tuple$2, dummy, err, err$1, fd, flags, iov, msg, n, oob, p, ptr, salen, sockType, to, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; dummy = $f.dummy; err = $f.err; err$1 = $f.err$1; fd = $f.fd; flags = $f.flags; iov = $f.iov; msg = $f.msg; n = $f.n; oob = $f.oob; p = $f.p; ptr = $f.ptr; salen = $f.salen; sockType = $f.sockType; to = $f.to; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		dummy = [dummy];
		iov = [iov];
		msg = [msg];
		n = 0;
		err = $ifaceNil;
		ptr = 0;
		salen = 0;
		/* */ if (!($interfaceIsEqual(to, $ifaceNil))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!($interfaceIsEqual(to, $ifaceNil))) { */ case 1:
			err$1 = $ifaceNil;
			_r = to.sockaddr(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			ptr = _tuple[0];
			salen = _tuple[1];
			err$1 = _tuple[2];
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				_tmp = 0;
				_tmp$1 = err$1;
				n = _tmp;
				err = _tmp$1;
				$s = -1; return [n, err];
			}
		/* } */ case 2:
		msg[0] = new Msghdr.ptr(ptrType$2.nil, 0, arrayType$9.zero(), ptrType$20.nil, new $Uint64(0, 0), ptrType$2.nil, new $Uint64(0, 0), 0, arrayType$9.zero());
		msg[0].Name = (ptr);
		msg[0].Namelen = ((salen >>> 0));
		iov[0] = new Iovec.ptr(ptrType$2.nil, new $Uint64(0, 0));
		if (p.$length > 0) {
			iov[0].Base = $indexPtr(p.$array, p.$offset + 0, ptrType$2);
			iov[0].SetLen(p.$length);
		}
		dummy[0] = 0;
		if (oob.$length > 0) {
			if (p.$length === 0) {
				sockType = 0;
				_tuple$1 = GetsockoptInt(fd, 1, 3);
				sockType = _tuple$1[0];
				err = _tuple$1[1];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					_tmp$2 = 0;
					_tmp$3 = err;
					n = _tmp$2;
					err = _tmp$3;
					$s = -1; return [n, err];
				}
				if (!((sockType === 2))) {
					iov[0].Base = (dummy.$ptr || (dummy.$ptr = new ptrType$2(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, dummy)));
					iov[0].SetLen(1);
				}
			}
			msg[0].Control = $indexPtr(oob.$array, oob.$offset + 0, ptrType$2);
			msg[0].SetControllen(oob.$length);
		}
		msg[0].Iov = iov[0];
		msg[0].Iovlen = new $Uint64(0, 1);
		_tuple$2 = sendmsg(fd, msg[0], flags);
		n = _tuple$2[0];
		err = _tuple$2[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			_tmp$4 = 0;
			_tmp$5 = err;
			n = _tmp$4;
			err = _tmp$5;
			$s = -1; return [n, err];
		}
		if (oob.$length > 0 && (p.$length === 0)) {
			n = 0;
		}
		_tmp$6 = n;
		_tmp$7 = $ifaceNil;
		n = _tmp$6;
		err = _tmp$7;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: SendmsgN }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.dummy = dummy; $f.err = err; $f.err$1 = err$1; $f.fd = fd; $f.flags = flags; $f.iov = iov; $f.msg = msg; $f.n = n; $f.oob = oob; $f.p = p; $f.ptr = ptr; $f.salen = salen; $f.sockType = sockType; $f.to = to; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.SendmsgN = SendmsgN;
	ReadDirent = function(fd, buf) {
		var _tuple, buf, err, fd, n;
		n = 0;
		err = $ifaceNil;
		_tuple = Getdents(fd, buf);
		n = _tuple[0];
		err = _tuple[1];
		return [n, err];
	};
	$pkg.ReadDirent = ReadDirent;
	direntIno = function(buf) {
		var buf;
		return readInt(buf, 0, 8);
	};
	direntReclen = function(buf) {
		var buf;
		return readInt(buf, 16, 2);
	};
	direntNamlen = function(buf) {
		var _tuple, buf, ok, reclen;
		_tuple = direntReclen(buf);
		reclen = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			return [new $Uint64(0, 0), false];
		}
		return [new $Uint64(reclen.$high - 0, reclen.$low - 19), true];
	};
	Lstat = function(path, stat) {
		var err, path, stat;
		err = $ifaceNil;
		err = fstatat(-100, path, stat, 256);
		return err;
	};
	$pkg.Lstat = Lstat;
	Iovec.ptr.prototype.SetLen = function(length) {
		var iov, length;
		iov = this;
		iov.Len = (new $Uint64(0, length));
	};
	Iovec.prototype.SetLen = function(length) { return this.$val.SetLen(length); };
	Msghdr.ptr.prototype.SetControllen = function(length) {
		var length, msghdr;
		msghdr = this;
		msghdr.Controllen = (new $Uint64(0, length));
	};
	Msghdr.prototype.SetControllen = function(length) { return this.$val.SetControllen(length); };
	mmapper.ptr.prototype.Mmap = function(fd, offset, length, prot, flags) {
		var _key, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, addr, b, data, err, errno, fd, flags, length, m, offset, p, prot, sl, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _key = $f._key; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; addr = $f.addr; b = $f.b; data = $f.data; err = $f.err; errno = $f.errno; fd = $f.fd; flags = $f.flags; length = $f.length; m = $f.m; offset = $f.offset; p = $f.p; prot = $f.prot; sl = $f.sl; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		sl = [sl];
		data = sliceType.nil;
		err = $ifaceNil;
		m = this;
		if (length <= 0) {
			_tmp = sliceType.nil;
			_tmp$1 = new Errno(22);
			data = _tmp;
			err = _tmp$1;
			$s = -1; return [data, err];
		}
		_r = m.mmap(0, ((length >>> 0)), prot, flags, fd, offset); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		addr = _tuple[0];
		errno = _tuple[1];
		if (!($interfaceIsEqual(errno, $ifaceNil))) {
			_tmp$2 = sliceType.nil;
			_tmp$3 = errno;
			data = _tmp$2;
			err = _tmp$3;
			$s = -1; return [data, err];
		}
		sl[0] = new structType.ptr(addr, length, length);
		b = sl[0];
		p = $indexPtr(b.$array, b.$offset + (b.$capacity - 1 >> 0), ptrType$2);
		$r = m.Mutex.Lock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(m.Mutex, "Unlock"), []]);
		_key = p; (m.active || $throwRuntimeError("assignment to entry in nil map"))[ptrType$2.keyFor(_key)] = { k: _key, v: b };
		_tmp$4 = b;
		_tmp$5 = $ifaceNil;
		data = _tmp$4;
		err = _tmp$5;
		$s = -1; return [data, err];
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  [data, err]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: mmapper.ptr.prototype.Mmap }; } $f._key = _key; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.addr = addr; $f.b = b; $f.data = data; $f.err = err; $f.errno = errno; $f.fd = fd; $f.flags = flags; $f.length = length; $f.m = m; $f.offset = offset; $f.p = p; $f.prot = prot; $f.sl = sl; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	mmapper.prototype.Mmap = function(fd, offset, length, prot, flags) { return this.$val.Mmap(fd, offset, length, prot, flags); };
	mmapper.ptr.prototype.Munmap = function(data) {
		var _entry, _r, b, data, err, errno, m, p, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; b = $f.b; data = $f.data; err = $f.err; errno = $f.errno; m = $f.m; p = $f.p; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		err = $ifaceNil;
		m = this;
		if ((data.$length === 0) || !((data.$length === data.$capacity))) {
			err = new Errno(22);
			$s = -1; return err;
		}
		p = $indexPtr(data.$array, data.$offset + (data.$capacity - 1 >> 0), ptrType$2);
		$r = m.Mutex.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(m.Mutex, "Unlock"), []]);
		b = (_entry = m.active[ptrType$2.keyFor(p)], _entry !== undefined ? _entry.v : sliceType.nil);
		if (b === sliceType.nil || !($indexPtr(b.$array, b.$offset + 0, ptrType$2) === $indexPtr(data.$array, data.$offset + 0, ptrType$2))) {
			err = new Errno(22);
			$s = -1; return err;
		}
		_r = m.munmap((($sliceToArray(b))), ((b.$length >>> 0))); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		errno = _r;
		if (!($interfaceIsEqual(errno, $ifaceNil))) {
			err = errno;
			$s = -1; return err;
		}
		delete m.active[ptrType$2.keyFor(p)];
		err = $ifaceNil;
		$s = -1; return err;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  err; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: mmapper.ptr.prototype.Munmap }; } $f._entry = _entry; $f._r = _r; $f.b = b; $f.data = data; $f.err = err; $f.errno = errno; $f.m = m; $f.p = p; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	mmapper.prototype.Munmap = function(data) { return this.$val.Munmap(data); };
	Errno.prototype.Error = function() {
		var e, s;
		e = this.$val;
		if (0 <= ((e >> 0)) && ((e >> 0)) < 133) {
			s = ((e < 0 || e >= errors.length) ? ($throwRuntimeError("index out of range"), undefined) : errors[e]);
			if (!(s === "")) {
				return s;
			}
		}
		return "errno " + itoa(((e >> 0)));
	};
	$ptrType(Errno).prototype.Error = function() { return new Errno(this.$get()).Error(); };
	Errno.prototype.Temporary = function() {
		var e;
		e = this.$val;
		return (e === 4) || (e === 24) || new Errno(e).Timeout();
	};
	$ptrType(Errno).prototype.Temporary = function() { return new Errno(this.$get()).Temporary(); };
	Errno.prototype.Timeout = function() {
		var e;
		e = this.$val;
		return (e === 11) || (e === 11) || (e === 110);
	};
	$ptrType(Errno).prototype.Timeout = function() { return new Errno(this.$get()).Timeout(); };
	errnoErr = function(e) {
		var _1, e;
		_1 = e;
		if (_1 === (0)) {
			return $ifaceNil;
		} else if (_1 === (11)) {
			return errEAGAIN;
		} else if (_1 === (22)) {
			return errEINVAL;
		} else if (_1 === (2)) {
			return errENOENT;
		}
		return new Errno(e);
	};
	Read = function(fd, p) {
		var _tuple, err, fd, n, p;
		n = 0;
		err = $ifaceNil;
		_tuple = read(fd, p);
		n = _tuple[0];
		err = _tuple[1];
		if (false) {
			if (n > 0) {
				race.WriteRange(($sliceToArray(p)), n);
			}
			if ($interfaceIsEqual(err, $ifaceNil)) {
				race.Acquire(((ioSync$24ptr || (ioSync$24ptr = new ptrType$23(function() { return ioSync; }, function($v) { ioSync = $v; })))));
			}
		}
		if (false && n > 0) {
			msanWrite(($sliceToArray(p)), n);
		}
		return [n, err];
	};
	$pkg.Read = Read;
	Write = function(fd, p) {
		var _tuple, err, fd, n, p;
		n = 0;
		err = $ifaceNil;
		if (false) {
			race.ReleaseMerge(((ioSync$24ptr || (ioSync$24ptr = new ptrType$23(function() { return ioSync; }, function($v) { ioSync = $v; })))));
		}
		_tuple = write(fd, p);
		n = _tuple[0];
		err = _tuple[1];
		if (false && n > 0) {
			race.ReadRange(($sliceToArray(p)), n);
		}
		if (false && n > 0) {
			msanRead(($sliceToArray(p)), n);
		}
		return [n, err];
	};
	$pkg.Write = Write;
	GetsockoptInt = function(fd, level, opt) {
		var _tmp, _tmp$1, err, fd, level, n, n$24ptr, opt, vallen, vallen$24ptr, value;
		value = 0;
		err = $ifaceNil;
		n = 0;
		vallen = 4;
		err = getsockopt(fd, level, opt, ((n$24ptr || (n$24ptr = new ptrType$4(function() { return n; }, function($v) { n = $v; })))), (vallen$24ptr || (vallen$24ptr = new ptrType$19(function() { return vallen; }, function($v) { vallen = $v; }))));
		_tmp = ((n >> 0));
		_tmp$1 = err;
		value = _tmp;
		err = _tmp$1;
		return [value, err];
	};
	$pkg.GetsockoptInt = GetsockoptInt;
	Recvfrom = function(fd, p, flags) {
		var _tuple, _tuple$1, err, fd, flags, from, len, len$24ptr, n, p, rsa;
		n = 0;
		from = $ifaceNil;
		err = $ifaceNil;
		rsa = new RawSockaddrAny.ptr(new RawSockaddr.ptr(0, arrayType$10.zero()), arrayType$11.zero());
		len = 112;
		_tuple = recvfrom(fd, p, flags, rsa, (len$24ptr || (len$24ptr = new ptrType$19(function() { return len; }, function($v) { len = $v; }))));
		n = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [n, from, err];
		}
		if (!((rsa.Addr.Family === 0))) {
			_tuple$1 = anyToSockaddr(rsa);
			from = _tuple$1[0];
			err = _tuple$1[1];
		}
		return [n, from, err];
	};
	$pkg.Recvfrom = Recvfrom;
	Sendto = function(fd, p, flags, to) {
		var _r, _tuple, err, fd, flags, n, p, ptr, to, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; fd = $f.fd; flags = $f.flags; n = $f.n; p = $f.p; ptr = $f.ptr; to = $f.to; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		err = $ifaceNil;
		_r = to.sockaddr(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		ptr = _tuple[0];
		n = _tuple[1];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			err = err;
			$s = -1; return err;
		}
		err = sendto(fd, p, flags, ptr, n);
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Sendto }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.fd = fd; $f.flags = flags; $f.n = n; $f.p = p; $f.ptr = ptr; $f.to = to; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Sendto = Sendto;
	SetsockoptByte = function(fd, level, opt, value) {
		var err, fd, level, opt, value, value$24ptr;
		err = $ifaceNil;
		err = setsockopt(fd, level, opt, ((value$24ptr || (value$24ptr = new ptrType$2(function() { return value; }, function($v) { value = $v; })))), 1);
		return err;
	};
	$pkg.SetsockoptByte = SetsockoptByte;
	SetsockoptInt = function(fd, level, opt, value) {
		var err, fd, level, n, n$24ptr, opt, value;
		err = $ifaceNil;
		n = ((value >> 0));
		err = setsockopt(fd, level, opt, ((n$24ptr || (n$24ptr = new ptrType$4(function() { return n; }, function($v) { n = $v; })))), 4);
		return err;
	};
	$pkg.SetsockoptInt = SetsockoptInt;
	SetsockoptInet4Addr = function(fd, level, opt, value) {
		var err, fd, level, opt, value;
		err = $ifaceNil;
		err = setsockopt(fd, level, opt, ($sliceToArray(new sliceType(value))), 4);
		return err;
	};
	$pkg.SetsockoptInet4Addr = SetsockoptInet4Addr;
	SetsockoptIPMreq = function(fd, level, opt, mreq) {
		var _array, _struct, _view, err, fd, level, mreq, opt;
		err = $ifaceNil;
		_array = new Uint8Array(8);
		err = setsockopt(fd, level, opt, (_array), 8);
		_struct = mreq, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Multiaddr = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 0, _array.buffer.byteLength)), _struct.Interface = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 4, _array.buffer.byteLength));
		return err;
	};
	$pkg.SetsockoptIPMreq = SetsockoptIPMreq;
	SetsockoptIPv6Mreq = function(fd, level, opt, mreq) {
		var _array, _struct, _view, err, fd, level, mreq, opt;
		err = $ifaceNil;
		_array = new Uint8Array(20);
		err = setsockopt(fd, level, opt, (_array), 20);
		_struct = mreq, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Multiaddr = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 0, _array.buffer.byteLength)), _struct.Interface = _view.getUint32(16, true);
		return err;
	};
	$pkg.SetsockoptIPv6Mreq = SetsockoptIPv6Mreq;
	SetsockoptLinger = function(fd, level, opt, l) {
		var _array, _struct, _view, err, fd, l, level, opt;
		err = $ifaceNil;
		_array = new Uint8Array(8);
		err = setsockopt(fd, level, opt, (_array), 8);
		_struct = l, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Onoff = _view.getInt32(0, true), _struct.Linger = _view.getInt32(4, true);
		return err;
	};
	$pkg.SetsockoptLinger = SetsockoptLinger;
	Close = function(fd) {
		var _tuple, e1, err, fd;
		err = $ifaceNil;
		_tuple = Syscall(3, ((fd >>> 0)), 0, 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Close = Close;
	Dup = function(oldfd) {
		var _tuple, e1, err, fd, oldfd, r0;
		fd = 0;
		err = $ifaceNil;
		_tuple = Syscall(32, ((oldfd >>> 0)), 0, 0);
		r0 = _tuple[0];
		e1 = _tuple[2];
		fd = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [fd, err];
	};
	$pkg.Dup = Dup;
	Fchdir = function(fd) {
		var _tuple, e1, err, fd;
		err = $ifaceNil;
		_tuple = Syscall(81, ((fd >>> 0)), 0, 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Fchdir = Fchdir;
	Fchmod = function(fd, mode) {
		var _tuple, e1, err, fd, mode;
		err = $ifaceNil;
		_tuple = Syscall(91, ((fd >>> 0)), ((mode >>> 0)), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Fchmod = Fchmod;
	fcntl = function(fd, cmd, arg) {
		var _tuple, arg, cmd, e1, err, fd, r0, val;
		val = 0;
		err = $ifaceNil;
		_tuple = Syscall(72, ((fd >>> 0)), ((cmd >>> 0)), ((arg >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		val = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [val, err];
	};
	Fsync = function(fd) {
		var _tuple, e1, err, fd;
		err = $ifaceNil;
		_tuple = Syscall(74, ((fd >>> 0)), 0, 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Fsync = Fsync;
	Getdents = function(fd, buf) {
		var _p0, _tuple, buf, e1, err, fd, n, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (buf.$length > 0) {
			_p0 = ($sliceToArray(buf));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall(217, ((fd >>> 0)), (_p0), ((buf.$length >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	$pkg.Getdents = Getdents;
	read = function(fd, p) {
		var _p0, _tuple, e1, err, fd, n, p, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (p.$length > 0) {
			_p0 = ($sliceToArray(p));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall(0, ((fd >>> 0)), (_p0), ((p.$length >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	write = function(fd, p) {
		var _p0, _tuple, e1, err, fd, n, p, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (p.$length > 0) {
			_p0 = ($sliceToArray(p));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall(1, ((fd >>> 0)), (_p0), ((p.$length >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	munmap = function(addr, length) {
		var _tuple, addr, e1, err, length;
		err = $ifaceNil;
		_tuple = Syscall(11, (addr), (length), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	Fchown = function(fd, uid, gid) {
		var _tuple, e1, err, fd, gid, uid;
		err = $ifaceNil;
		_tuple = Syscall(93, ((fd >>> 0)), ((uid >>> 0)), ((gid >>> 0)));
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Fchown = Fchown;
	Fstat = function(fd, stat) {
		var _array, _struct, _tuple, _view, e1, err, fd, stat;
		err = $ifaceNil;
		_array = new Uint8Array(144);
		_tuple = Syscall(5, ((fd >>> 0)), ((_array)), 0);
		_struct = stat, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Dev = new $Uint64(_view.getUint32(4, true), _view.getUint32(0, true)), _struct.Ino = new $Uint64(_view.getUint32(12, true), _view.getUint32(8, true)), _struct.Nlink = new $Uint64(_view.getUint32(20, true), _view.getUint32(16, true)), _struct.Mode = _view.getUint32(24, true), _struct.Uid = _view.getUint32(28, true), _struct.Gid = _view.getUint32(32, true), _struct.X__pad0 = _view.getInt32(36, true), _struct.Rdev = new $Uint64(_view.getUint32(44, true), _view.getUint32(40, true)), _struct.Size = new $Int64(_view.getUint32(52, true), _view.getUint32(48, true)), _struct.Blksize = new $Int64(_view.getUint32(60, true), _view.getUint32(56, true)), _struct.Blocks = new $Int64(_view.getUint32(68, true), _view.getUint32(64, true)), _struct.Atim.Sec = new $Int64(_view.getUint32(76, true), _view.getUint32(72, true)), _struct.Atim.Nsec = new $Int64(_view.getUint32(84, true), _view.getUint32(80, true)), _struct.Mtim.Sec = new $Int64(_view.getUint32(92, true), _view.getUint32(88, true)), _struct.Mtim.Nsec = new $Int64(_view.getUint32(100, true), _view.getUint32(96, true)), _struct.Ctim.Sec = new $Int64(_view.getUint32(108, true), _view.getUint32(104, true)), _struct.Ctim.Nsec = new $Int64(_view.getUint32(116, true), _view.getUint32(112, true)), _struct.X__unused = new ($nativeArray($kindInt64))(_array.buffer, $min(_array.byteOffset + 120, _array.buffer.byteLength));
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Fstat = Fstat;
	Ftruncate = function(fd, length) {
		var _tuple, e1, err, fd, length;
		err = $ifaceNil;
		_tuple = Syscall(77, ((fd >>> 0)), ((length.$low >>> 0)), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Ftruncate = Ftruncate;
	Pread = function(fd, p, offset) {
		var _p0, _tuple, e1, err, fd, n, offset, p, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (p.$length > 0) {
			_p0 = ($sliceToArray(p));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall6(17, ((fd >>> 0)), (_p0), ((p.$length >>> 0)), ((offset.$low >>> 0)), 0, 0);
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	$pkg.Pread = Pread;
	Pwrite = function(fd, p, offset) {
		var _p0, _tuple, e1, err, fd, n, offset, p, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (p.$length > 0) {
			_p0 = ($sliceToArray(p));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall6(18, ((fd >>> 0)), (_p0), ((p.$length >>> 0)), ((offset.$low >>> 0)), 0, 0);
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	$pkg.Pwrite = Pwrite;
	Seek = function(fd, offset, whence) {
		var _tuple, e1, err, fd, off, offset, r0, whence;
		off = new $Int64(0, 0);
		err = $ifaceNil;
		_tuple = Syscall(8, ((fd >>> 0)), ((offset.$low >>> 0)), ((whence >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		off = (new $Int64(0, r0.constructor === Number ? r0 : 1));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [off, err];
	};
	$pkg.Seek = Seek;
	Shutdown = function(fd, how) {
		var _tuple, e1, err, fd, how;
		err = $ifaceNil;
		_tuple = Syscall(48, ((fd >>> 0)), ((how >>> 0)), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	$pkg.Shutdown = Shutdown;
	accept = function(s, rsa, addrlen) {
		var _array, _struct, _tuple, _view, addrlen, e1, err, fd, r0, rsa, s;
		fd = 0;
		err = $ifaceNil;
		_array = new Uint8Array(112);
		_tuple = Syscall(43, ((s >>> 0)), ((_array)), ((addrlen)));
		_struct = rsa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 16, _array.buffer.byteLength));
		r0 = _tuple[0];
		e1 = _tuple[2];
		fd = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [fd, err];
	};
	accept4 = function(s, rsa, addrlen, flags) {
		var _array, _struct, _tuple, _view, addrlen, e1, err, fd, flags, r0, rsa, s;
		fd = 0;
		err = $ifaceNil;
		_array = new Uint8Array(112);
		_tuple = Syscall6(288, ((s >>> 0)), ((_array)), ((addrlen)), ((flags >>> 0)), 0, 0);
		_struct = rsa, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 16, _array.buffer.byteLength));
		r0 = _tuple[0];
		e1 = _tuple[2];
		fd = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [fd, err];
	};
	fstatat = function(fd, path, stat, flags) {
		var _array, _p0, _struct, _tuple, _tuple$1, _view, e1, err, fd, flags, path, stat;
		err = $ifaceNil;
		_p0 = ptrType$2.nil;
		_tuple = BytePtrFromString(path);
		_p0 = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return err;
		}
		_array = new Uint8Array(144);
		_tuple$1 = Syscall6(262, ((fd >>> 0)), ((_p0)), ((_array)), ((flags >>> 0)), 0, 0);
		_struct = stat, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Dev = new $Uint64(_view.getUint32(4, true), _view.getUint32(0, true)), _struct.Ino = new $Uint64(_view.getUint32(12, true), _view.getUint32(8, true)), _struct.Nlink = new $Uint64(_view.getUint32(20, true), _view.getUint32(16, true)), _struct.Mode = _view.getUint32(24, true), _struct.Uid = _view.getUint32(28, true), _struct.Gid = _view.getUint32(32, true), _struct.X__pad0 = _view.getInt32(36, true), _struct.Rdev = new $Uint64(_view.getUint32(44, true), _view.getUint32(40, true)), _struct.Size = new $Int64(_view.getUint32(52, true), _view.getUint32(48, true)), _struct.Blksize = new $Int64(_view.getUint32(60, true), _view.getUint32(56, true)), _struct.Blocks = new $Int64(_view.getUint32(68, true), _view.getUint32(64, true)), _struct.Atim.Sec = new $Int64(_view.getUint32(76, true), _view.getUint32(72, true)), _struct.Atim.Nsec = new $Int64(_view.getUint32(84, true), _view.getUint32(80, true)), _struct.Mtim.Sec = new $Int64(_view.getUint32(92, true), _view.getUint32(88, true)), _struct.Mtim.Nsec = new $Int64(_view.getUint32(100, true), _view.getUint32(96, true)), _struct.Ctim.Sec = new $Int64(_view.getUint32(108, true), _view.getUint32(104, true)), _struct.Ctim.Nsec = new $Int64(_view.getUint32(116, true), _view.getUint32(112, true)), _struct.X__unused = new ($nativeArray($kindInt64))(_array.buffer, $min(_array.byteOffset + 120, _array.buffer.byteLength));
		e1 = _tuple$1[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	getsockopt = function(s, level, name, val, vallen) {
		var _tuple, e1, err, level, name, s, val, vallen;
		err = $ifaceNil;
		_tuple = Syscall6(55, ((s >>> 0)), ((level >>> 0)), ((name >>> 0)), (val), ((vallen)), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	setsockopt = function(s, level, name, val, vallen) {
		var _tuple, e1, err, level, name, s, val, vallen;
		err = $ifaceNil;
		_tuple = Syscall6(54, ((s >>> 0)), ((level >>> 0)), ((name >>> 0)), (val), (vallen), 0);
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	recvfrom = function(fd, p, flags, from, fromlen) {
		var _array, _p0, _struct, _tuple, _view, e1, err, fd, flags, from, fromlen, n, p, r0;
		n = 0;
		err = $ifaceNil;
		_p0 = 0;
		if (p.$length > 0) {
			_p0 = ($sliceToArray(p));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_array = new Uint8Array(112);
		_tuple = Syscall6(45, ((fd >>> 0)), (_p0), ((p.$length >>> 0)), ((flags >>> 0)), ((_array)), ((fromlen)));
		_struct = from, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Addr.Family = _view.getUint16(0, true), _struct.Addr.Data = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 2, _array.buffer.byteLength)), _struct.Pad = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 16, _array.buffer.byteLength));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	sendto = function(s, buf, flags, to, addrlen) {
		var _p0, _tuple, addrlen, buf, e1, err, flags, s, to;
		err = $ifaceNil;
		_p0 = 0;
		if (buf.$length > 0) {
			_p0 = ($sliceToArray(buf));
		} else {
			_p0 = (new Uint8Array(0));
		}
		_tuple = Syscall6(44, ((s >>> 0)), (_p0), ((buf.$length >>> 0)), ((flags >>> 0)), (to), ((addrlen >>> 0)));
		e1 = _tuple[2];
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return err;
	};
	recvmsg = function(s, msg, flags) {
		var _array, _struct, _tuple, _view, e1, err, flags, msg, n, r0, s;
		n = 0;
		err = $ifaceNil;
		_array = new Uint8Array(48);
		_tuple = Syscall(47, ((s >>> 0)), ((_array)), ((flags >>> 0)));
		_struct = msg, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Namelen = _view.getUint32(4, true), _struct.Pad_cgo_0 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 8, _array.buffer.byteLength)), _struct.Iovlen = new $Uint64(_view.getUint32(20, true), _view.getUint32(16, true)), _struct.Controllen = new $Uint64(_view.getUint32(36, true), _view.getUint32(32, true)), _struct.Flags = _view.getInt32(40, true), _struct.Pad_cgo_1 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 44, _array.buffer.byteLength));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	sendmsg = function(s, msg, flags) {
		var _array, _struct, _tuple, _view, e1, err, flags, msg, n, r0, s;
		n = 0;
		err = $ifaceNil;
		_array = new Uint8Array(48);
		_tuple = Syscall(46, ((s >>> 0)), ((_array)), ((flags >>> 0)));
		_struct = msg, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Namelen = _view.getUint32(4, true), _struct.Pad_cgo_0 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 8, _array.buffer.byteLength)), _struct.Iovlen = new $Uint64(_view.getUint32(20, true), _view.getUint32(16, true)), _struct.Controllen = new $Uint64(_view.getUint32(36, true), _view.getUint32(32, true)), _struct.Flags = _view.getInt32(40, true), _struct.Pad_cgo_1 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 44, _array.buffer.byteLength));
		r0 = _tuple[0];
		e1 = _tuple[2];
		n = ((r0 >> 0));
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [n, err];
	};
	mmap = function(addr, length, prot, flags, fd, offset) {
		var _tuple, addr, e1, err, fd, flags, length, offset, prot, r0, xaddr;
		xaddr = 0;
		err = $ifaceNil;
		_tuple = Syscall6(9, (addr), (length), ((prot >>> 0)), ((flags >>> 0)), ((fd >>> 0)), ((offset.$low >>> 0)));
		r0 = _tuple[0];
		e1 = _tuple[2];
		xaddr = (r0);
		if (!((e1 === 0))) {
			err = errnoErr(e1);
		}
		return [xaddr, err];
	};
	ptrType$25.methods = [{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}];
	ptrType$12.methods = [{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}];
	ptrType$26.methods = [{prop: "Mmap", name: "Mmap", pkg: "", typ: $funcType([$Int, $Int64, $Int, $Int, $Int], [sliceType, $error], false)}, {prop: "Munmap", name: "Munmap", pkg: "", typ: $funcType([sliceType], [$error], false)}];
	Errno.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Temporary", name: "Temporary", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Timeout", name: "Timeout", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$27.methods = [{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}];
	ptrType$28.methods = [{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}];
	ptrType$29.methods = [{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}];
	ptrType$30.methods = [{prop: "Unix", name: "Unix", pkg: "", typ: $funcType([], [$Int64, $Int64], false)}, {prop: "Nano", name: "Nano", pkg: "", typ: $funcType([], [$Int64], false)}];
	ptrType$20.methods = [{prop: "SetLen", name: "SetLen", pkg: "", typ: $funcType([$Int], [], false)}];
	ptrType$32.methods = [{prop: "SetControllen", name: "SetControllen", pkg: "", typ: $funcType([$Int], [], false)}];
	RawConn.init([{prop: "Control", name: "Control", pkg: "", typ: $funcType([funcType], [$error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([funcType$1], [$error], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([funcType$1], [$error], false)}]);
	SockaddrLinklayer.init("syscall", [{prop: "Protocol", name: "Protocol", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Ifindex", name: "Ifindex", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Hatype", name: "Hatype", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pkttype", name: "Pkttype", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Halen", name: "Halen", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Addr", name: "Addr", embedded: false, exported: true, typ: arrayType$1, tag: ""}, {prop: "raw", name: "raw", embedded: false, exported: false, typ: RawSockaddrLinklayer, tag: ""}]);
	SockaddrNetlink.init("syscall", [{prop: "Family", name: "Family", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pad", name: "Pad", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pid", name: "Pid", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Groups", name: "Groups", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "raw", name: "raw", embedded: false, exported: false, typ: RawSockaddrNetlink, tag: ""}]);
	mmapper.init("syscall", [{prop: "Mutex", name: "Mutex", embedded: true, exported: true, typ: sync.Mutex, tag: ""}, {prop: "active", name: "active", embedded: false, exported: false, typ: mapType, tag: ""}, {prop: "mmap", name: "mmap", embedded: false, exported: false, typ: funcType$2, tag: ""}, {prop: "munmap", name: "munmap", embedded: false, exported: false, typ: funcType$3, tag: ""}]);
	Sockaddr.init([{prop: "sockaddr", name: "sockaddr", pkg: "syscall", typ: $funcType([], [$UnsafePointer, _Socklen, $error], false)}]);
	SockaddrInet4.init("syscall", [{prop: "Port", name: "Port", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Addr", name: "Addr", embedded: false, exported: true, typ: arrayType$9, tag: ""}, {prop: "raw", name: "raw", embedded: false, exported: false, typ: RawSockaddrInet4, tag: ""}]);
	SockaddrInet6.init("syscall", [{prop: "Port", name: "Port", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "ZoneId", name: "ZoneId", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Addr", name: "Addr", embedded: false, exported: true, typ: arrayType$2, tag: ""}, {prop: "raw", name: "raw", embedded: false, exported: false, typ: RawSockaddrInet6, tag: ""}]);
	SockaddrUnix.init("syscall", [{prop: "Name", name: "Name", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "raw", name: "raw", embedded: false, exported: false, typ: RawSockaddrUnix, tag: ""}]);
	Timespec.init("", [{prop: "Sec", name: "Sec", embedded: false, exported: true, typ: $Int64, tag: ""}, {prop: "Nsec", name: "Nsec", embedded: false, exported: true, typ: $Int64, tag: ""}]);
	Stat_t.init("", [{prop: "Dev", name: "Dev", embedded: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Ino", name: "Ino", embedded: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Nlink", name: "Nlink", embedded: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Mode", name: "Mode", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Uid", name: "Uid", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Gid", name: "Gid", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "X__pad0", name: "X__pad0", embedded: false, exported: true, typ: $Int32, tag: ""}, {prop: "Rdev", name: "Rdev", embedded: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Size", name: "Size", embedded: false, exported: true, typ: $Int64, tag: ""}, {prop: "Blksize", name: "Blksize", embedded: false, exported: true, typ: $Int64, tag: ""}, {prop: "Blocks", name: "Blocks", embedded: false, exported: true, typ: $Int64, tag: ""}, {prop: "Atim", name: "Atim", embedded: false, exported: true, typ: Timespec, tag: ""}, {prop: "Mtim", name: "Mtim", embedded: false, exported: true, typ: Timespec, tag: ""}, {prop: "Ctim", name: "Ctim", embedded: false, exported: true, typ: Timespec, tag: ""}, {prop: "X__unused", name: "X__unused", embedded: false, exported: true, typ: arrayType$5, tag: ""}]);
	RawSockaddrInet4.init("", [{prop: "Family", name: "Family", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Port", name: "Port", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Addr", name: "Addr", embedded: false, exported: true, typ: arrayType$9, tag: ""}, {prop: "Zero", name: "Zero", embedded: false, exported: true, typ: arrayType$1, tag: ""}]);
	RawSockaddrInet6.init("", [{prop: "Family", name: "Family", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Port", name: "Port", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Flowinfo", name: "Flowinfo", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Addr", name: "Addr", embedded: false, exported: true, typ: arrayType$2, tag: ""}, {prop: "Scope_id", name: "Scope_id", embedded: false, exported: true, typ: $Uint32, tag: ""}]);
	RawSockaddrUnix.init("", [{prop: "Family", name: "Family", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Path", name: "Path", embedded: false, exported: true, typ: arrayType$8, tag: ""}]);
	RawSockaddrLinklayer.init("", [{prop: "Family", name: "Family", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Protocol", name: "Protocol", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Ifindex", name: "Ifindex", embedded: false, exported: true, typ: $Int32, tag: ""}, {prop: "Hatype", name: "Hatype", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pkttype", name: "Pkttype", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Halen", name: "Halen", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Addr", name: "Addr", embedded: false, exported: true, typ: arrayType$1, tag: ""}]);
	RawSockaddrNetlink.init("", [{prop: "Family", name: "Family", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pad", name: "Pad", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Pid", name: "Pid", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Groups", name: "Groups", embedded: false, exported: true, typ: $Uint32, tag: ""}]);
	RawSockaddr.init("", [{prop: "Family", name: "Family", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Data", name: "Data", embedded: false, exported: true, typ: arrayType$10, tag: ""}]);
	RawSockaddrAny.init("", [{prop: "Addr", name: "Addr", embedded: false, exported: true, typ: RawSockaddr, tag: ""}, {prop: "Pad", name: "Pad", embedded: false, exported: true, typ: arrayType$11, tag: ""}]);
	Linger.init("", [{prop: "Onoff", name: "Onoff", embedded: false, exported: true, typ: $Int32, tag: ""}, {prop: "Linger", name: "Linger", embedded: false, exported: true, typ: $Int32, tag: ""}]);
	Iovec.init("", [{prop: "Base", name: "Base", embedded: false, exported: true, typ: ptrType$2, tag: ""}, {prop: "Len", name: "Len", embedded: false, exported: true, typ: $Uint64, tag: ""}]);
	IPMreq.init("", [{prop: "Multiaddr", name: "Multiaddr", embedded: false, exported: true, typ: arrayType$9, tag: ""}, {prop: "Interface", name: "Interface", embedded: false, exported: true, typ: arrayType$9, tag: ""}]);
	IPMreqn.init("", [{prop: "Multiaddr", name: "Multiaddr", embedded: false, exported: true, typ: arrayType$9, tag: ""}, {prop: "Address", name: "Address", embedded: false, exported: true, typ: arrayType$9, tag: ""}, {prop: "Ifindex", name: "Ifindex", embedded: false, exported: true, typ: $Int32, tag: ""}]);
	IPv6Mreq.init("", [{prop: "Multiaddr", name: "Multiaddr", embedded: false, exported: true, typ: arrayType$2, tag: ""}, {prop: "Interface", name: "Interface", embedded: false, exported: true, typ: $Uint32, tag: ""}]);
	Msghdr.init("", [{prop: "Name", name: "Name", embedded: false, exported: true, typ: ptrType$2, tag: ""}, {prop: "Namelen", name: "Namelen", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Pad_cgo_0", name: "Pad_cgo_0", embedded: false, exported: true, typ: arrayType$9, tag: ""}, {prop: "Iov", name: "Iov", embedded: false, exported: true, typ: ptrType$20, tag: ""}, {prop: "Iovlen", name: "Iovlen", embedded: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Control", name: "Control", embedded: false, exported: true, typ: ptrType$2, tag: ""}, {prop: "Controllen", name: "Controllen", embedded: false, exported: true, typ: $Uint64, tag: ""}, {prop: "Flags", name: "Flags", embedded: false, exported: true, typ: $Int32, tag: ""}, {prop: "Pad_cgo_1", name: "Pad_cgo_1", embedded: false, exported: true, typ: arrayType$9, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = race.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		lineBuffer = sliceType.nil;
		syscallModule = null;
		$pkg.ForkLock = new sync.RWMutex.ptr(new sync.Mutex.ptr(0, 0), 0, 0, 0, 0);
		ioSync = new $Int64(0, 0);
		warningPrinted = false;
		alreadyTriedToLoad = false;
		minusOne = -1;
		envs = runtime_envs();
		$pkg.Stdin = 0;
		$pkg.Stdout = 1;
		$pkg.Stderr = 2;
		errEAGAIN = new Errno(11);
		errEINVAL = new Errno(22);
		errENOENT = new Errno(2);
		errors = $toNativeArray($kindString, ["", "operation not permitted", "no such file or directory", "no such process", "interrupted system call", "input/output error", "no such device or address", "argument list too long", "exec format error", "bad file descriptor", "no child processes", "resource temporarily unavailable", "cannot allocate memory", "permission denied", "bad address", "block device required", "device or resource busy", "file exists", "invalid cross-device link", "no such device", "not a directory", "is a directory", "invalid argument", "too many open files in system", "too many open files", "inappropriate ioctl for device", "text file busy", "file too large", "no space left on device", "illegal seek", "read-only file system", "too many links", "broken pipe", "numerical argument out of domain", "numerical result out of range", "resource deadlock avoided", "file name too long", "no locks available", "function not implemented", "directory not empty", "too many levels of symbolic links", "", "no message of desired type", "identifier removed", "channel number out of range", "level 2 not synchronized", "level 3 halted", "level 3 reset", "link number out of range", "protocol driver not attached", "no CSI structure available", "level 2 halted", "invalid exchange", "invalid request descriptor", "exchange full", "no anode", "invalid request code", "invalid slot", "", "bad font file format", "device not a stream", "no data available", "timer expired", "out of streams resources", "machine is not on the network", "package not installed", "object is remote", "link has been severed", "advertise error", "srmount error", "communication error on send", "protocol error", "multihop attempted", "RFS specific error", "bad message", "value too large for defined data type", "name not unique on network", "file descriptor in bad state", "remote address changed", "can not access a needed shared library", "accessing a corrupted shared library", ".lib section in a.out corrupted", "attempting to link in too many shared libraries", "cannot exec a shared library directly", "invalid or incomplete multibyte or wide character", "interrupted system call should be restarted", "streams pipe error", "too many users", "socket operation on non-socket", "destination address required", "message too long", "protocol wrong type for socket", "protocol not available", "protocol not supported", "socket type not supported", "operation not supported", "protocol family not supported", "address family not supported by protocol", "address already in use", "cannot assign requested address", "network is down", "network is unreachable", "network dropped connection on reset", "software caused connection abort", "connection reset by peer", "no buffer space available", "transport endpoint is already connected", "transport endpoint is not connected", "cannot send after transport endpoint shutdown", "too many references: cannot splice", "connection timed out", "connection refused", "host is down", "no route to host", "operation already in progress", "operation now in progress", "stale NFS file handle", "structure needs cleaning", "not a XENIX named type file", "no XENIX semaphores available", "is a named type file", "remote I/O error", "disk quota exceeded", "no medium found", "wrong medium type", "operation canceled", "required key not available", "key has expired", "key has been revoked", "key was rejected by service", "owner died", "state not recoverable", "operation not possible due to RF-kill"]);
		mapper = new mmapper.ptr(new sync.Mutex.ptr(0, 0), {}, mmap, munmap);
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/gopherjs/gopherjs/nosync"] = (function() {
	var $pkg = {}, $init, Mutex, Once, Pool, ptrType$1, funcType$1, ptrType$4, sliceType, ptrType$5, funcType$2;
	Mutex = $pkg.Mutex = $newType(0, $kindStruct, "nosync.Mutex", true, "github.com/gopherjs/gopherjs/nosync", true, function(locked_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.locked = false;
			return;
		}
		this.locked = locked_;
	});
	Once = $pkg.Once = $newType(0, $kindStruct, "nosync.Once", true, "github.com/gopherjs/gopherjs/nosync", true, function(doing_, done_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.doing = false;
			this.done = false;
			return;
		}
		this.doing = doing_;
		this.done = done_;
	});
	Pool = $pkg.Pool = $newType(0, $kindStruct, "nosync.Pool", true, "github.com/gopherjs/gopherjs/nosync", true, function(store_, New_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.store = sliceType.nil;
			this.New = $throwNilPointerError;
			return;
		}
		this.store = store_;
		this.New = New_;
	});
	ptrType$1 = $ptrType(Mutex);
	funcType$1 = $funcType([], [], false);
	ptrType$4 = $ptrType(Once);
	sliceType = $sliceType($emptyInterface);
	ptrType$5 = $ptrType(Pool);
	funcType$2 = $funcType([], [$emptyInterface], false);
	Mutex.ptr.prototype.Lock = function() {
		var m;
		m = this;
		if (m.locked) {
			$panic(new $String("nosync: mutex is already locked"));
		}
		m.locked = true;
	};
	Mutex.prototype.Lock = function() { return this.$val.Lock(); };
	Mutex.ptr.prototype.Unlock = function() {
		var m;
		m = this;
		if (!m.locked) {
			$panic(new $String("nosync: unlock of unlocked mutex"));
		}
		m.locked = false;
	};
	Mutex.prototype.Unlock = function() { return this.$val.Unlock(); };
	Once.ptr.prototype.Do = function(f) {
		var f, o, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; f = $f.f; o = $f.o; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		o = [o];
		o[0] = this;
		if (o[0].done) {
			$s = -1; return;
		}
		if (o[0].doing) {
			$panic(new $String("nosync: Do called within f"));
		}
		o[0].doing = true;
		$deferred.push([(function(o) { return function() {
			o[0].doing = false;
			o[0].done = true;
		}; })(o), []]);
		$r = f(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Once.ptr.prototype.Do }; } $f.f = f; $f.o = o; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Once.prototype.Do = function(f) { return this.$val.Do(f); };
	Pool.ptr.prototype.Get = function() {
		var _r, p, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (p.store.$length === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (p.store.$length === 0) { */ case 1:
			/* */ if (!(p.New === $throwNilPointerError)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(p.New === $throwNilPointerError)) { */ case 3:
				_r = p.New(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } */ case 4:
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		x$2 = (x = p.store, x$1 = p.store.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		p.store = $subslice(p.store, 0, (p.store.$length - 1 >> 0));
		$s = -1; return x$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Pool.ptr.prototype.Get }; } $f._r = _r; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Pool.prototype.Get = function() { return this.$val.Get(); };
	Pool.ptr.prototype.Put = function(x) {
		var p, x;
		p = this;
		if ($interfaceIsEqual(x, $ifaceNil)) {
			return;
		}
		p.store = $append(p.store, x);
	};
	Pool.prototype.Put = function(x) { return this.$val.Put(x); };
	ptrType$1.methods = [{prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false)}, {prop: "Unlock", name: "Unlock", pkg: "", typ: $funcType([], [], false)}];
	ptrType$4.methods = [{prop: "Do", name: "Do", pkg: "", typ: $funcType([funcType$1], [], false)}];
	ptrType$5.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Put", name: "Put", pkg: "", typ: $funcType([$emptyInterface], [], false)}];
	Mutex.init("github.com/gopherjs/gopherjs/nosync", [{prop: "locked", name: "locked", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	Once.init("github.com/gopherjs/gopherjs/nosync", [{prop: "doing", name: "doing", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "done", name: "done", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	Pool.init("github.com/gopherjs/gopherjs/nosync", [{prop: "store", name: "store", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "New", name: "New", embedded: false, exported: true, typ: funcType$2, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["time"] = (function() {
	var $pkg = {}, $init, errors, js, nosync, runtime, syscall, ParseError, Time, Month, Weekday, Duration, Location, zone, zoneTrans, sliceType, sliceType$1, ptrType, sliceType$2, arrayType, sliceType$3, arrayType$1, arrayType$2, ptrType$2, arrayType$3, ptrType$4, ptrType$7, zoneSources, std0x, longDayNames, shortDayNames, shortMonthNames, longMonthNames, atoiError, errBad, errLeadingInt, months, days, daysBefore, startNano, utcLoc, utcLoc$24ptr, localLoc, localLoc$24ptr, localOnce, errLocation, badData, x, init, initLocal, runtimeNano, now, indexByte, startsWithLowerCase, nextStdChunk, match, lookup, appendInt, atoi, formatNano, quote, isDigit, getnum, cutspace, skip, Parse, parse, parseTimeZone, parseGMT, parseSignedOffset, parseNanoseconds, leadingInt, absWeekday, absClock, fmtFrac, fmtInt, lessThanHalf, absDate, daysIn, Now, unixTime, Unix, isLeap, norm, Date, div, FixedZone;
	errors = $packages["errors"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
	runtime = $packages["runtime"];
	syscall = $packages["syscall"];
	ParseError = $pkg.ParseError = $newType(0, $kindStruct, "time.ParseError", true, "time", true, function(Layout_, Value_, LayoutElem_, ValueElem_, Message_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Layout = "";
			this.Value = "";
			this.LayoutElem = "";
			this.ValueElem = "";
			this.Message = "";
			return;
		}
		this.Layout = Layout_;
		this.Value = Value_;
		this.LayoutElem = LayoutElem_;
		this.ValueElem = ValueElem_;
		this.Message = Message_;
	});
	Time = $pkg.Time = $newType(0, $kindStruct, "time.Time", true, "time", true, function(wall_, ext_, loc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.wall = new $Uint64(0, 0);
			this.ext = new $Int64(0, 0);
			this.loc = ptrType$2.nil;
			return;
		}
		this.wall = wall_;
		this.ext = ext_;
		this.loc = loc_;
	});
	Month = $pkg.Month = $newType(4, $kindInt, "time.Month", true, "time", true, null);
	Weekday = $pkg.Weekday = $newType(4, $kindInt, "time.Weekday", true, "time", true, null);
	Duration = $pkg.Duration = $newType(8, $kindInt64, "time.Duration", true, "time", true, null);
	Location = $pkg.Location = $newType(0, $kindStruct, "time.Location", true, "time", true, function(name_, zone_, tx_, cacheStart_, cacheEnd_, cacheZone_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = "";
			this.zone = sliceType.nil;
			this.tx = sliceType$1.nil;
			this.cacheStart = new $Int64(0, 0);
			this.cacheEnd = new $Int64(0, 0);
			this.cacheZone = ptrType.nil;
			return;
		}
		this.name = name_;
		this.zone = zone_;
		this.tx = tx_;
		this.cacheStart = cacheStart_;
		this.cacheEnd = cacheEnd_;
		this.cacheZone = cacheZone_;
	});
	zone = $pkg.zone = $newType(0, $kindStruct, "time.zone", true, "time", false, function(name_, offset_, isDST_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = "";
			this.offset = 0;
			this.isDST = false;
			return;
		}
		this.name = name_;
		this.offset = offset_;
		this.isDST = isDST_;
	});
	zoneTrans = $pkg.zoneTrans = $newType(0, $kindStruct, "time.zoneTrans", true, "time", false, function(when_, index_, isstd_, isutc_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.when = new $Int64(0, 0);
			this.index = 0;
			this.isstd = false;
			this.isutc = false;
			return;
		}
		this.when = when_;
		this.index = index_;
		this.isstd = isstd_;
		this.isutc = isutc_;
	});
	sliceType = $sliceType(zone);
	sliceType$1 = $sliceType(zoneTrans);
	ptrType = $ptrType(zone);
	sliceType$2 = $sliceType($String);
	arrayType = $arrayType($Uint8, 20);
	sliceType$3 = $sliceType($Uint8);
	arrayType$1 = $arrayType($Uint8, 9);
	arrayType$2 = $arrayType($Uint8, 64);
	ptrType$2 = $ptrType(Location);
	arrayType$3 = $arrayType($Uint8, 32);
	ptrType$4 = $ptrType(ParseError);
	ptrType$7 = $ptrType(Time);
	init = function() {
		$unused(Unix(new $Int64(0, 0), new $Int64(0, 0)));
	};
	initLocal = function() {
		var d, i, j, s;
		d = new ($global.Date)();
		s = $internalize(d, $String);
		i = indexByte(s, 40);
		j = indexByte(s, 41);
		if ((i === -1) || (j === -1)) {
			localLoc.name = "UTC";
			return;
		}
		localLoc.name = $substring(s, (i + 1 >> 0), j);
		localLoc.zone = new sliceType([new zone.ptr(localLoc.name, $imul(($parseInt(d.getTimezoneOffset()) >> 0), -60), false)]);
	};
	runtimeNano = function() {
		return $mul64($internalize(new ($global.Date)().getTime(), $Int64), new $Int64(0, 1000000));
	};
	now = function() {
		var _tmp, _tmp$1, _tmp$2, mono, n, nsec, sec, x$1;
		sec = new $Int64(0, 0);
		nsec = 0;
		mono = new $Int64(0, 0);
		n = runtimeNano();
		_tmp = $div64(n, new $Int64(0, 1000000000), false);
		_tmp$1 = (((x$1 = $div64(n, new $Int64(0, 1000000000), true), x$1.$low + ((x$1.$high >> 31) * 4294967296)) >> 0));
		_tmp$2 = n;
		sec = _tmp;
		nsec = _tmp$1;
		mono = _tmp$2;
		return [sec, nsec, mono];
	};
	indexByte = function(s, c) {
		var c, s;
		return $parseInt(s.indexOf($global.String.fromCharCode(c))) >> 0;
	};
	startsWithLowerCase = function(str) {
		var c, str;
		if (str.length === 0) {
			return false;
		}
		c = str.charCodeAt(0);
		return 97 <= c && c <= 122;
	};
	nextStdChunk = function(layout) {
		var _1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$29, _tmp$3, _tmp$30, _tmp$31, _tmp$32, _tmp$33, _tmp$34, _tmp$35, _tmp$36, _tmp$37, _tmp$38, _tmp$39, _tmp$4, _tmp$40, _tmp$41, _tmp$42, _tmp$43, _tmp$44, _tmp$45, _tmp$46, _tmp$47, _tmp$48, _tmp$49, _tmp$5, _tmp$50, _tmp$51, _tmp$52, _tmp$53, _tmp$54, _tmp$55, _tmp$56, _tmp$57, _tmp$58, _tmp$59, _tmp$6, _tmp$60, _tmp$61, _tmp$62, _tmp$63, _tmp$64, _tmp$65, _tmp$66, _tmp$67, _tmp$68, _tmp$69, _tmp$7, _tmp$70, _tmp$71, _tmp$72, _tmp$73, _tmp$74, _tmp$75, _tmp$76, _tmp$77, _tmp$78, _tmp$79, _tmp$8, _tmp$80, _tmp$81, _tmp$82, _tmp$83, _tmp$84, _tmp$85, _tmp$86, _tmp$9, c, ch, i, j, layout, prefix, std, std$1, suffix, x$1;
		prefix = "";
		std = 0;
		suffix = "";
		i = 0;
		while (true) {
			if (!(i < layout.length)) { break; }
			c = ((layout.charCodeAt(i) >> 0));
			_1 = c;
			if (_1 === (74)) {
				if (layout.length >= (i + 3 >> 0) && $substring(layout, i, (i + 3 >> 0)) === "Jan") {
					if (layout.length >= (i + 7 >> 0) && $substring(layout, i, (i + 7 >> 0)) === "January") {
						_tmp = $substring(layout, 0, i);
						_tmp$1 = 257;
						_tmp$2 = $substring(layout, (i + 7 >> 0));
						prefix = _tmp;
						std = _tmp$1;
						suffix = _tmp$2;
						return [prefix, std, suffix];
					}
					if (!startsWithLowerCase($substring(layout, (i + 3 >> 0)))) {
						_tmp$3 = $substring(layout, 0, i);
						_tmp$4 = 258;
						_tmp$5 = $substring(layout, (i + 3 >> 0));
						prefix = _tmp$3;
						std = _tmp$4;
						suffix = _tmp$5;
						return [prefix, std, suffix];
					}
				}
			} else if (_1 === (77)) {
				if (layout.length >= (i + 3 >> 0)) {
					if ($substring(layout, i, (i + 3 >> 0)) === "Mon") {
						if (layout.length >= (i + 6 >> 0) && $substring(layout, i, (i + 6 >> 0)) === "Monday") {
							_tmp$6 = $substring(layout, 0, i);
							_tmp$7 = 261;
							_tmp$8 = $substring(layout, (i + 6 >> 0));
							prefix = _tmp$6;
							std = _tmp$7;
							suffix = _tmp$8;
							return [prefix, std, suffix];
						}
						if (!startsWithLowerCase($substring(layout, (i + 3 >> 0)))) {
							_tmp$9 = $substring(layout, 0, i);
							_tmp$10 = 262;
							_tmp$11 = $substring(layout, (i + 3 >> 0));
							prefix = _tmp$9;
							std = _tmp$10;
							suffix = _tmp$11;
							return [prefix, std, suffix];
						}
					}
					if ($substring(layout, i, (i + 3 >> 0)) === "MST") {
						_tmp$12 = $substring(layout, 0, i);
						_tmp$13 = 21;
						_tmp$14 = $substring(layout, (i + 3 >> 0));
						prefix = _tmp$12;
						std = _tmp$13;
						suffix = _tmp$14;
						return [prefix, std, suffix];
					}
				}
			} else if (_1 === (48)) {
				if (layout.length >= (i + 2 >> 0) && 49 <= layout.charCodeAt((i + 1 >> 0)) && layout.charCodeAt((i + 1 >> 0)) <= 54) {
					_tmp$15 = $substring(layout, 0, i);
					_tmp$16 = (x$1 = layout.charCodeAt((i + 1 >> 0)) - 49 << 24 >>> 24, ((x$1 < 0 || x$1 >= std0x.length) ? ($throwRuntimeError("index out of range"), undefined) : std0x[x$1]));
					_tmp$17 = $substring(layout, (i + 2 >> 0));
					prefix = _tmp$15;
					std = _tmp$16;
					suffix = _tmp$17;
					return [prefix, std, suffix];
				}
			} else if (_1 === (49)) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 53)) {
					_tmp$18 = $substring(layout, 0, i);
					_tmp$19 = 522;
					_tmp$20 = $substring(layout, (i + 2 >> 0));
					prefix = _tmp$18;
					std = _tmp$19;
					suffix = _tmp$20;
					return [prefix, std, suffix];
				}
				_tmp$21 = $substring(layout, 0, i);
				_tmp$22 = 259;
				_tmp$23 = $substring(layout, (i + 1 >> 0));
				prefix = _tmp$21;
				std = _tmp$22;
				suffix = _tmp$23;
				return [prefix, std, suffix];
			} else if (_1 === (50)) {
				if (layout.length >= (i + 4 >> 0) && $substring(layout, i, (i + 4 >> 0)) === "2006") {
					_tmp$24 = $substring(layout, 0, i);
					_tmp$25 = 273;
					_tmp$26 = $substring(layout, (i + 4 >> 0));
					prefix = _tmp$24;
					std = _tmp$25;
					suffix = _tmp$26;
					return [prefix, std, suffix];
				}
				_tmp$27 = $substring(layout, 0, i);
				_tmp$28 = 263;
				_tmp$29 = $substring(layout, (i + 1 >> 0));
				prefix = _tmp$27;
				std = _tmp$28;
				suffix = _tmp$29;
				return [prefix, std, suffix];
			} else if (_1 === (95)) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 50)) {
					if (layout.length >= (i + 5 >> 0) && $substring(layout, (i + 1 >> 0), (i + 5 >> 0)) === "2006") {
						_tmp$30 = $substring(layout, 0, (i + 1 >> 0));
						_tmp$31 = 273;
						_tmp$32 = $substring(layout, (i + 5 >> 0));
						prefix = _tmp$30;
						std = _tmp$31;
						suffix = _tmp$32;
						return [prefix, std, suffix];
					}
					_tmp$33 = $substring(layout, 0, i);
					_tmp$34 = 264;
					_tmp$35 = $substring(layout, (i + 2 >> 0));
					prefix = _tmp$33;
					std = _tmp$34;
					suffix = _tmp$35;
					return [prefix, std, suffix];
				}
			} else if (_1 === (51)) {
				_tmp$36 = $substring(layout, 0, i);
				_tmp$37 = 523;
				_tmp$38 = $substring(layout, (i + 1 >> 0));
				prefix = _tmp$36;
				std = _tmp$37;
				suffix = _tmp$38;
				return [prefix, std, suffix];
			} else if (_1 === (52)) {
				_tmp$39 = $substring(layout, 0, i);
				_tmp$40 = 525;
				_tmp$41 = $substring(layout, (i + 1 >> 0));
				prefix = _tmp$39;
				std = _tmp$40;
				suffix = _tmp$41;
				return [prefix, std, suffix];
			} else if (_1 === (53)) {
				_tmp$42 = $substring(layout, 0, i);
				_tmp$43 = 527;
				_tmp$44 = $substring(layout, (i + 1 >> 0));
				prefix = _tmp$42;
				std = _tmp$43;
				suffix = _tmp$44;
				return [prefix, std, suffix];
			} else if (_1 === (80)) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 77)) {
					_tmp$45 = $substring(layout, 0, i);
					_tmp$46 = 531;
					_tmp$47 = $substring(layout, (i + 2 >> 0));
					prefix = _tmp$45;
					std = _tmp$46;
					suffix = _tmp$47;
					return [prefix, std, suffix];
				}
			} else if (_1 === (112)) {
				if (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 109)) {
					_tmp$48 = $substring(layout, 0, i);
					_tmp$49 = 532;
					_tmp$50 = $substring(layout, (i + 2 >> 0));
					prefix = _tmp$48;
					std = _tmp$49;
					suffix = _tmp$50;
					return [prefix, std, suffix];
				}
			} else if (_1 === (45)) {
				if (layout.length >= (i + 7 >> 0) && $substring(layout, i, (i + 7 >> 0)) === "-070000") {
					_tmp$51 = $substring(layout, 0, i);
					_tmp$52 = 28;
					_tmp$53 = $substring(layout, (i + 7 >> 0));
					prefix = _tmp$51;
					std = _tmp$52;
					suffix = _tmp$53;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 9 >> 0) && $substring(layout, i, (i + 9 >> 0)) === "-07:00:00") {
					_tmp$54 = $substring(layout, 0, i);
					_tmp$55 = 31;
					_tmp$56 = $substring(layout, (i + 9 >> 0));
					prefix = _tmp$54;
					std = _tmp$55;
					suffix = _tmp$56;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 5 >> 0) && $substring(layout, i, (i + 5 >> 0)) === "-0700") {
					_tmp$57 = $substring(layout, 0, i);
					_tmp$58 = 27;
					_tmp$59 = $substring(layout, (i + 5 >> 0));
					prefix = _tmp$57;
					std = _tmp$58;
					suffix = _tmp$59;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 6 >> 0) && $substring(layout, i, (i + 6 >> 0)) === "-07:00") {
					_tmp$60 = $substring(layout, 0, i);
					_tmp$61 = 30;
					_tmp$62 = $substring(layout, (i + 6 >> 0));
					prefix = _tmp$60;
					std = _tmp$61;
					suffix = _tmp$62;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 3 >> 0) && $substring(layout, i, (i + 3 >> 0)) === "-07") {
					_tmp$63 = $substring(layout, 0, i);
					_tmp$64 = 29;
					_tmp$65 = $substring(layout, (i + 3 >> 0));
					prefix = _tmp$63;
					std = _tmp$64;
					suffix = _tmp$65;
					return [prefix, std, suffix];
				}
			} else if (_1 === (90)) {
				if (layout.length >= (i + 7 >> 0) && $substring(layout, i, (i + 7 >> 0)) === "Z070000") {
					_tmp$66 = $substring(layout, 0, i);
					_tmp$67 = 23;
					_tmp$68 = $substring(layout, (i + 7 >> 0));
					prefix = _tmp$66;
					std = _tmp$67;
					suffix = _tmp$68;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 9 >> 0) && $substring(layout, i, (i + 9 >> 0)) === "Z07:00:00") {
					_tmp$69 = $substring(layout, 0, i);
					_tmp$70 = 26;
					_tmp$71 = $substring(layout, (i + 9 >> 0));
					prefix = _tmp$69;
					std = _tmp$70;
					suffix = _tmp$71;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 5 >> 0) && $substring(layout, i, (i + 5 >> 0)) === "Z0700") {
					_tmp$72 = $substring(layout, 0, i);
					_tmp$73 = 22;
					_tmp$74 = $substring(layout, (i + 5 >> 0));
					prefix = _tmp$72;
					std = _tmp$73;
					suffix = _tmp$74;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 6 >> 0) && $substring(layout, i, (i + 6 >> 0)) === "Z07:00") {
					_tmp$75 = $substring(layout, 0, i);
					_tmp$76 = 25;
					_tmp$77 = $substring(layout, (i + 6 >> 0));
					prefix = _tmp$75;
					std = _tmp$76;
					suffix = _tmp$77;
					return [prefix, std, suffix];
				}
				if (layout.length >= (i + 3 >> 0) && $substring(layout, i, (i + 3 >> 0)) === "Z07") {
					_tmp$78 = $substring(layout, 0, i);
					_tmp$79 = 24;
					_tmp$80 = $substring(layout, (i + 3 >> 0));
					prefix = _tmp$78;
					std = _tmp$79;
					suffix = _tmp$80;
					return [prefix, std, suffix];
				}
			} else if (_1 === (46)) {
				if ((i + 1 >> 0) < layout.length && ((layout.charCodeAt((i + 1 >> 0)) === 48) || (layout.charCodeAt((i + 1 >> 0)) === 57))) {
					ch = layout.charCodeAt((i + 1 >> 0));
					j = i + 1 >> 0;
					while (true) {
						if (!(j < layout.length && (layout.charCodeAt(j) === ch))) { break; }
						j = j + (1) >> 0;
					}
					if (!isDigit(layout, j)) {
						std$1 = 32;
						if (layout.charCodeAt((i + 1 >> 0)) === 57) {
							std$1 = 33;
						}
						std$1 = std$1 | ((((j - ((i + 1 >> 0)) >> 0)) << 16 >> 0));
						_tmp$81 = $substring(layout, 0, i);
						_tmp$82 = std$1;
						_tmp$83 = $substring(layout, j);
						prefix = _tmp$81;
						std = _tmp$82;
						suffix = _tmp$83;
						return [prefix, std, suffix];
					}
				}
			}
			i = i + (1) >> 0;
		}
		_tmp$84 = layout;
		_tmp$85 = 0;
		_tmp$86 = "";
		prefix = _tmp$84;
		std = _tmp$85;
		suffix = _tmp$86;
		return [prefix, std, suffix];
	};
	match = function(s1, s2) {
		var c1, c2, i, s1, s2;
		i = 0;
		while (true) {
			if (!(i < s1.length)) { break; }
			c1 = s1.charCodeAt(i);
			c2 = s2.charCodeAt(i);
			if (!((c1 === c2))) {
				c1 = (c1 | (32)) >>> 0;
				c2 = (c2 | (32)) >>> 0;
				if (!((c1 === c2)) || c1 < 97 || c1 > 122) {
					return false;
				}
			}
			i = i + (1) >> 0;
		}
		return true;
	};
	lookup = function(tab, val) {
		var _i, _ref, i, tab, v, val;
		_ref = tab;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			v = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (val.length >= v.length && match($substring(val, 0, v.length), v)) {
				return [i, $substring(val, v.length), $ifaceNil];
			}
			_i++;
		}
		return [-1, val, errBad];
	};
	appendInt = function(b, x$1, width) {
		var _q, b, buf, i, q, u, w, width, x$1;
		u = ((x$1 >>> 0));
		if (x$1 < 0) {
			b = $append(b, 45);
			u = ((-x$1 >>> 0));
		}
		buf = arrayType.zero();
		i = 20;
		while (true) {
			if (!(u >= 10)) { break; }
			i = i - (1) >> 0;
			q = (_q = u / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
			((i < 0 || i >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[i] = ((((48 + u >>> 0) - (q * 10 >>> 0) >>> 0) << 24 >>> 24)));
			u = q;
		}
		i = i - (1) >> 0;
		((i < 0 || i >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[i] = (((48 + u >>> 0) << 24 >>> 24)));
		w = 20 - i >> 0;
		while (true) {
			if (!(w < width)) { break; }
			b = $append(b, 48);
			w = w + (1) >> 0;
		}
		return $appendSlice(b, $subslice(new sliceType$3(buf), i));
	};
	atoi = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, err, neg, q, rem, s, x$1;
		x$1 = 0;
		err = $ifaceNil;
		neg = false;
		if (!(s === "") && ((s.charCodeAt(0) === 45) || (s.charCodeAt(0) === 43))) {
			neg = s.charCodeAt(0) === 45;
			s = $substring(s, 1);
		}
		_tuple = leadingInt(s);
		q = _tuple[0];
		rem = _tuple[1];
		err = _tuple[2];
		x$1 = (((q.$low + ((q.$high >> 31) * 4294967296)) >> 0));
		if (!($interfaceIsEqual(err, $ifaceNil)) || !(rem === "")) {
			_tmp = 0;
			_tmp$1 = atoiError;
			x$1 = _tmp;
			err = _tmp$1;
			return [x$1, err];
		}
		if (neg) {
			x$1 = -x$1;
		}
		_tmp$2 = x$1;
		_tmp$3 = $ifaceNil;
		x$1 = _tmp$2;
		err = _tmp$3;
		return [x$1, err];
	};
	formatNano = function(b, nanosec, n, trim) {
		var _q, _r, b, buf, n, nanosec, start, trim, u, x$1;
		u = nanosec;
		buf = arrayType$1.zero();
		start = 9;
		while (true) {
			if (!(start > 0)) { break; }
			start = start - (1) >> 0;
			((start < 0 || start >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[start] = ((((_r = u % 10, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) + 48 >>> 0) << 24 >>> 24)));
			u = (_q = u / (10), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		}
		if (n > 9) {
			n = 9;
		}
		if (trim) {
			while (true) {
				if (!(n > 0 && ((x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[x$1])) === 48))) { break; }
				n = n - (1) >> 0;
			}
			if (n === 0) {
				return b;
			}
		}
		b = $append(b, 46);
		return $appendSlice(b, $subslice(new sliceType$3(buf), 0, n));
	};
	Time.ptr.prototype.String = function() {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, buf, m0, m1, m2, s, sign, t, wid, x$1, x$2, x$3, x$4, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; buf = $f.buf; m0 = $f.m0; m1 = $f.m1; m2 = $f.m2; s = $f.s; sign = $f.sign; t = $f.t; wid = $f.wid; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).Format("2006-01-02 15:04:05.999999999 -0700 MST"); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		s = _r;
		if (!((x$1 = (x$2 = t.wall, new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0)), (x$1.$high === 0 && x$1.$low === 0)))) {
			m2 = ((x$3 = t.ext, new $Uint64(x$3.$high, x$3.$low)));
			sign = 43;
			if ((x$4 = t.ext, (x$4.$high < 0 || (x$4.$high === 0 && x$4.$low < 0)))) {
				sign = 45;
				m2 = new $Uint64(-m2.$high, -m2.$low);
			}
			_tmp = $div64(m2, new $Uint64(0, 1000000000), false);
			_tmp$1 = $div64(m2, new $Uint64(0, 1000000000), true);
			m1 = _tmp;
			m2 = _tmp$1;
			_tmp$2 = $div64(m1, new $Uint64(0, 1000000000), false);
			_tmp$3 = $div64(m1, new $Uint64(0, 1000000000), true);
			m0 = _tmp$2;
			m1 = _tmp$3;
			buf = sliceType$3.nil;
			buf = $appendSlice(buf, " m=");
			buf = $append(buf, sign);
			wid = 0;
			if (!((m0.$high === 0 && m0.$low === 0))) {
				buf = appendInt(buf, ((m0.$low >> 0)), 0);
				wid = 9;
			}
			buf = appendInt(buf, ((m1.$low >> 0)), wid);
			buf = $append(buf, 46);
			buf = appendInt(buf, ((m2.$low >> 0)), 9);
			s = s + (($bytesToString(buf)));
		}
		$s = -1; return s;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.String }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.buf = buf; $f.m0 = m0; $f.m1 = m1; $f.m2 = m2; $f.s = s; $f.sign = sign; $f.t = t; $f.wid = wid; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.String = function() { return this.$val.String(); };
	Time.ptr.prototype.Format = function(layout) {
		var _r, b, buf, layout, max, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; buf = $f.buf; layout = $f.layout; max = $f.max; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		b = sliceType$3.nil;
		max = layout.length + 10 >> 0;
		if (max < 64) {
			buf = arrayType$2.zero();
			b = $subslice(new sliceType$3(buf), 0, 0);
		} else {
			b = $makeSlice(sliceType$3, 0, max);
		}
		_r = $clone(t, Time).AppendFormat(b, layout); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		b = _r;
		$s = -1; return ($bytesToString(b));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Format }; } $f._r = _r; $f.b = b; $f.buf = buf; $f.layout = layout; $f.max = max; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Format = function(layout) { return this.$val.Format(layout); };
	Time.ptr.prototype.AppendFormat = function(b, layout) {
		var _1, _q, _q$1, _q$2, _q$3, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _tuple, _tuple$1, _tuple$2, _tuple$3, abs, absoffset, b, day, hour, hr, hr$1, layout, m, min, month, name, offset, prefix, s, sec, std, suffix, t, y, year, zone$1, zone$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _q$3 = $f._q$3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; abs = $f.abs; absoffset = $f.absoffset; b = $f.b; day = $f.day; hour = $f.hour; hr = $f.hr; hr$1 = $f.hr$1; layout = $f.layout; m = $f.m; min = $f.min; month = $f.month; name = $f.name; offset = $f.offset; prefix = $f.prefix; s = $f.s; sec = $f.sec; std = $f.std; suffix = $f.suffix; t = $f.t; y = $f.y; year = $f.year; zone$1 = $f.zone$1; zone$2 = $f.zone$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).locabs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		name = _tuple[0];
		offset = _tuple[1];
		abs = _tuple[2];
		year = -1;
		month = 0;
		day = 0;
		hour = -1;
		min = 0;
		sec = 0;
		while (true) {
			if (!(!(layout === ""))) { break; }
			_tuple$1 = nextStdChunk(layout);
			prefix = _tuple$1[0];
			std = _tuple$1[1];
			suffix = _tuple$1[2];
			if (!(prefix === "")) {
				b = $appendSlice(b, prefix);
			}
			if (std === 0) {
				break;
			}
			layout = suffix;
			if (year < 0 && !(((std & 256) === 0))) {
				_tuple$2 = absDate(abs, true);
				year = _tuple$2[0];
				month = _tuple$2[1];
				day = _tuple$2[2];
			}
			if (hour < 0 && !(((std & 512) === 0))) {
				_tuple$3 = absClock(abs);
				hour = _tuple$3[0];
				min = _tuple$3[1];
				sec = _tuple$3[2];
			}
			switch (0) { default:
				_1 = std & 65535;
				if (_1 === (274)) {
					y = year;
					if (y < 0) {
						y = -y;
					}
					b = appendInt(b, (_r$1 = y % 100, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")), 2);
				} else if (_1 === (273)) {
					b = appendInt(b, year, 4);
				} else if (_1 === (258)) {
					b = $appendSlice(b, $substring(new Month(month).String(), 0, 3));
				} else if (_1 === (257)) {
					m = new Month(month).String();
					b = $appendSlice(b, m);
				} else if (_1 === (259)) {
					b = appendInt(b, ((month >> 0)), 0);
				} else if (_1 === (260)) {
					b = appendInt(b, ((month >> 0)), 2);
				} else if (_1 === (262)) {
					b = $appendSlice(b, $substring(new Weekday(absWeekday(abs)).String(), 0, 3));
				} else if (_1 === (261)) {
					s = new Weekday(absWeekday(abs)).String();
					b = $appendSlice(b, s);
				} else if (_1 === (263)) {
					b = appendInt(b, day, 0);
				} else if (_1 === (264)) {
					if (day < 10) {
						b = $append(b, 32);
					}
					b = appendInt(b, day, 0);
				} else if (_1 === (265)) {
					b = appendInt(b, day, 2);
				} else if (_1 === (522)) {
					b = appendInt(b, hour, 2);
				} else if (_1 === (523)) {
					hr = (_r$2 = hour % 12, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero"));
					if (hr === 0) {
						hr = 12;
					}
					b = appendInt(b, hr, 0);
				} else if (_1 === (524)) {
					hr$1 = (_r$3 = hour % 12, _r$3 === _r$3 ? _r$3 : $throwRuntimeError("integer divide by zero"));
					if (hr$1 === 0) {
						hr$1 = 12;
					}
					b = appendInt(b, hr$1, 2);
				} else if (_1 === (525)) {
					b = appendInt(b, min, 0);
				} else if (_1 === (526)) {
					b = appendInt(b, min, 2);
				} else if (_1 === (527)) {
					b = appendInt(b, sec, 0);
				} else if (_1 === (528)) {
					b = appendInt(b, sec, 2);
				} else if (_1 === (531)) {
					if (hour >= 12) {
						b = $appendSlice(b, "PM");
					} else {
						b = $appendSlice(b, "AM");
					}
				} else if (_1 === (532)) {
					if (hour >= 12) {
						b = $appendSlice(b, "pm");
					} else {
						b = $appendSlice(b, "am");
					}
				} else if ((_1 === (22)) || (_1 === (25)) || (_1 === (23)) || (_1 === (24)) || (_1 === (26)) || (_1 === (27)) || (_1 === (30)) || (_1 === (28)) || (_1 === (29)) || (_1 === (31))) {
					if ((offset === 0) && ((std === 22) || (std === 25) || (std === 23) || (std === 24) || (std === 26))) {
						b = $append(b, 90);
						break;
					}
					zone$1 = (_q = offset / 60, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
					absoffset = offset;
					if (zone$1 < 0) {
						b = $append(b, 45);
						zone$1 = -zone$1;
						absoffset = -absoffset;
					} else {
						b = $append(b, 43);
					}
					b = appendInt(b, (_q$1 = zone$1 / 60, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")), 2);
					if ((std === 25) || (std === 30) || (std === 26) || (std === 31)) {
						b = $append(b, 58);
					}
					if (!((std === 29)) && !((std === 24))) {
						b = appendInt(b, (_r$4 = zone$1 % 60, _r$4 === _r$4 ? _r$4 : $throwRuntimeError("integer divide by zero")), 2);
					}
					if ((std === 23) || (std === 28) || (std === 31) || (std === 26)) {
						if ((std === 31) || (std === 26)) {
							b = $append(b, 58);
						}
						b = appendInt(b, (_r$5 = absoffset % 60, _r$5 === _r$5 ? _r$5 : $throwRuntimeError("integer divide by zero")), 2);
					}
				} else if (_1 === (21)) {
					if (!(name === "")) {
						b = $appendSlice(b, name);
						break;
					}
					zone$2 = (_q$2 = offset / 60, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero"));
					if (zone$2 < 0) {
						b = $append(b, 45);
						zone$2 = -zone$2;
					} else {
						b = $append(b, 43);
					}
					b = appendInt(b, (_q$3 = zone$2 / 60, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : $throwRuntimeError("integer divide by zero")), 2);
					b = appendInt(b, (_r$6 = zone$2 % 60, _r$6 === _r$6 ? _r$6 : $throwRuntimeError("integer divide by zero")), 2);
				} else if ((_1 === (32)) || (_1 === (33))) {
					b = formatNano(b, (($clone(t, Time).Nanosecond() >>> 0)), std >> 16 >> 0, (std & 65535) === 33);
				}
			}
		}
		$s = -1; return b;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.AppendFormat }; } $f._1 = _1; $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._q$3 = _q$3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.abs = abs; $f.absoffset = absoffset; $f.b = b; $f.day = day; $f.hour = hour; $f.hr = hr; $f.hr$1 = hr$1; $f.layout = layout; $f.m = m; $f.min = min; $f.month = month; $f.name = name; $f.offset = offset; $f.prefix = prefix; $f.s = s; $f.sec = sec; $f.std = std; $f.suffix = suffix; $f.t = t; $f.y = y; $f.year = year; $f.zone$1 = zone$1; $f.zone$2 = zone$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.AppendFormat = function(b, layout) { return this.$val.AppendFormat(b, layout); };
	quote = function(s) {
		var s;
		return "\"" + s + "\"";
	};
	ParseError.ptr.prototype.Error = function() {
		var e;
		e = this;
		if (e.Message === "") {
			return "parsing time " + quote(e.Value) + " as " + quote(e.Layout) + ": cannot parse " + quote(e.ValueElem) + " as " + quote(e.LayoutElem);
		}
		return "parsing time " + quote(e.Value) + e.Message;
	};
	ParseError.prototype.Error = function() { return this.$val.Error(); };
	isDigit = function(s, i) {
		var c, i, s;
		if (s.length <= i) {
			return false;
		}
		c = s.charCodeAt(i);
		return 48 <= c && c <= 57;
	};
	getnum = function(s, fixed) {
		var fixed, s;
		if (!isDigit(s, 0)) {
			return [0, s, errBad];
		}
		if (!isDigit(s, 1)) {
			if (fixed) {
				return [0, s, errBad];
			}
			return [(((s.charCodeAt(0) - 48 << 24 >>> 24) >> 0)), $substring(s, 1), $ifaceNil];
		}
		return [($imul((((s.charCodeAt(0) - 48 << 24 >>> 24) >> 0)), 10)) + (((s.charCodeAt(1) - 48 << 24 >>> 24) >> 0)) >> 0, $substring(s, 2), $ifaceNil];
	};
	cutspace = function(s) {
		var s;
		while (true) {
			if (!(s.length > 0 && (s.charCodeAt(0) === 32))) { break; }
			s = $substring(s, 1);
		}
		return s;
	};
	skip = function(value, prefix) {
		var prefix, value;
		while (true) {
			if (!(prefix.length > 0)) { break; }
			if (prefix.charCodeAt(0) === 32) {
				if (value.length > 0 && !((value.charCodeAt(0) === 32))) {
					return [value, errBad];
				}
				prefix = cutspace(prefix);
				value = cutspace(value);
				continue;
			}
			if ((value.length === 0) || !((value.charCodeAt(0) === prefix.charCodeAt(0)))) {
				return [value, errBad];
			}
			prefix = $substring(prefix, 1);
			value = $substring(value, 1);
		}
		return [value, $ifaceNil];
	};
	Parse = function(layout, value) {
		var _r, layout, value, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; layout = $f.layout; value = $f.value; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = parse(layout, value, $pkg.UTC, $pkg.Local); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Parse }; } $f._r = _r; $f.layout = layout; $f.value = value; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Parse = Parse;
	parse = function(layout, value, defaultLocation, local) {
		var _1, _2, _3, _4, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$29, _tmp$3, _tmp$30, _tmp$31, _tmp$32, _tmp$33, _tmp$34, _tmp$35, _tmp$36, _tmp$37, _tmp$38, _tmp$39, _tmp$4, _tmp$40, _tmp$41, _tmp$42, _tmp$43, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$10, _tuple$11, _tuple$12, _tuple$13, _tuple$14, _tuple$15, _tuple$16, _tuple$17, _tuple$18, _tuple$19, _tuple$2, _tuple$20, _tuple$21, _tuple$22, _tuple$23, _tuple$24, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, alayout, amSet, avalue, day, defaultLocation, err, hour, hour$1, hr, i, layout, local, min, min$1, mm, month, n, n$1, name, ndigit, nsec, offset, offset$1, ok, ok$1, p, pmSet, prefix, rangeErrString, sec, seconds, sign, ss, std, stdstr, suffix, t, t$1, value, x$1, x$2, year, z, zoneName, zoneOffset, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$18 = $f._tmp$18; _tmp$19 = $f._tmp$19; _tmp$2 = $f._tmp$2; _tmp$20 = $f._tmp$20; _tmp$21 = $f._tmp$21; _tmp$22 = $f._tmp$22; _tmp$23 = $f._tmp$23; _tmp$24 = $f._tmp$24; _tmp$25 = $f._tmp$25; _tmp$26 = $f._tmp$26; _tmp$27 = $f._tmp$27; _tmp$28 = $f._tmp$28; _tmp$29 = $f._tmp$29; _tmp$3 = $f._tmp$3; _tmp$30 = $f._tmp$30; _tmp$31 = $f._tmp$31; _tmp$32 = $f._tmp$32; _tmp$33 = $f._tmp$33; _tmp$34 = $f._tmp$34; _tmp$35 = $f._tmp$35; _tmp$36 = $f._tmp$36; _tmp$37 = $f._tmp$37; _tmp$38 = $f._tmp$38; _tmp$39 = $f._tmp$39; _tmp$4 = $f._tmp$4; _tmp$40 = $f._tmp$40; _tmp$41 = $f._tmp$41; _tmp$42 = $f._tmp$42; _tmp$43 = $f._tmp$43; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$10 = $f._tuple$10; _tuple$11 = $f._tuple$11; _tuple$12 = $f._tuple$12; _tuple$13 = $f._tuple$13; _tuple$14 = $f._tuple$14; _tuple$15 = $f._tuple$15; _tuple$16 = $f._tuple$16; _tuple$17 = $f._tuple$17; _tuple$18 = $f._tuple$18; _tuple$19 = $f._tuple$19; _tuple$2 = $f._tuple$2; _tuple$20 = $f._tuple$20; _tuple$21 = $f._tuple$21; _tuple$22 = $f._tuple$22; _tuple$23 = $f._tuple$23; _tuple$24 = $f._tuple$24; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; _tuple$9 = $f._tuple$9; alayout = $f.alayout; amSet = $f.amSet; avalue = $f.avalue; day = $f.day; defaultLocation = $f.defaultLocation; err = $f.err; hour = $f.hour; hour$1 = $f.hour$1; hr = $f.hr; i = $f.i; layout = $f.layout; local = $f.local; min = $f.min; min$1 = $f.min$1; mm = $f.mm; month = $f.month; n = $f.n; n$1 = $f.n$1; name = $f.name; ndigit = $f.ndigit; nsec = $f.nsec; offset = $f.offset; offset$1 = $f.offset$1; ok = $f.ok; ok$1 = $f.ok$1; p = $f.p; pmSet = $f.pmSet; prefix = $f.prefix; rangeErrString = $f.rangeErrString; sec = $f.sec; seconds = $f.seconds; sign = $f.sign; ss = $f.ss; std = $f.std; stdstr = $f.stdstr; suffix = $f.suffix; t = $f.t; t$1 = $f.t$1; value = $f.value; x$1 = $f.x$1; x$2 = $f.x$2; year = $f.year; z = $f.z; zoneName = $f.zoneName; zoneOffset = $f.zoneOffset; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tmp = layout;
		_tmp$1 = value;
		alayout = _tmp;
		avalue = _tmp$1;
		rangeErrString = "";
		amSet = false;
		pmSet = false;
		year = 0;
		month = 1;
		day = 1;
		hour = 0;
		min = 0;
		sec = 0;
		nsec = 0;
		z = ptrType$2.nil;
		zoneOffset = -1;
		zoneName = "";
		while (true) {
			err = $ifaceNil;
			_tuple = nextStdChunk(layout);
			prefix = _tuple[0];
			std = _tuple[1];
			suffix = _tuple[2];
			stdstr = $substring(layout, prefix.length, (layout.length - suffix.length >> 0));
			_tuple$1 = skip(value, prefix);
			value = _tuple$1[0];
			err = _tuple$1[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return [new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil), new ParseError.ptr(alayout, avalue, prefix, value, "")];
			}
			if (std === 0) {
				if (!((value.length === 0))) {
					$s = -1; return [new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil), new ParseError.ptr(alayout, avalue, "", value, ": extra text: " + value)];
				}
				break;
			}
			layout = suffix;
			p = "";
			switch (0) { default:
				_1 = std & 65535;
				if (_1 === (274)) {
					if (value.length < 2) {
						err = errBad;
						break;
					}
					_tmp$2 = $substring(value, 0, 2);
					_tmp$3 = $substring(value, 2);
					p = _tmp$2;
					value = _tmp$3;
					_tuple$2 = atoi(p);
					year = _tuple$2[0];
					err = _tuple$2[1];
					if (year >= 69) {
						year = year + (1900) >> 0;
					} else {
						year = year + (2000) >> 0;
					}
				} else if (_1 === (273)) {
					if (value.length < 4 || !isDigit(value, 0)) {
						err = errBad;
						break;
					}
					_tmp$4 = $substring(value, 0, 4);
					_tmp$5 = $substring(value, 4);
					p = _tmp$4;
					value = _tmp$5;
					_tuple$3 = atoi(p);
					year = _tuple$3[0];
					err = _tuple$3[1];
				} else if (_1 === (258)) {
					_tuple$4 = lookup(shortMonthNames, value);
					month = _tuple$4[0];
					value = _tuple$4[1];
					err = _tuple$4[2];
					month = month + (1) >> 0;
				} else if (_1 === (257)) {
					_tuple$5 = lookup(longMonthNames, value);
					month = _tuple$5[0];
					value = _tuple$5[1];
					err = _tuple$5[2];
					month = month + (1) >> 0;
				} else if ((_1 === (259)) || (_1 === (260))) {
					_tuple$6 = getnum(value, std === 260);
					month = _tuple$6[0];
					value = _tuple$6[1];
					err = _tuple$6[2];
					if (month <= 0 || 12 < month) {
						rangeErrString = "month";
					}
				} else if (_1 === (262)) {
					_tuple$7 = lookup(shortDayNames, value);
					value = _tuple$7[1];
					err = _tuple$7[2];
				} else if (_1 === (261)) {
					_tuple$8 = lookup(longDayNames, value);
					value = _tuple$8[1];
					err = _tuple$8[2];
				} else if ((_1 === (263)) || (_1 === (264)) || (_1 === (265))) {
					if ((std === 264) && value.length > 0 && (value.charCodeAt(0) === 32)) {
						value = $substring(value, 1);
					}
					_tuple$9 = getnum(value, std === 265);
					day = _tuple$9[0];
					value = _tuple$9[1];
					err = _tuple$9[2];
					if (day < 0) {
						rangeErrString = "day";
					}
				} else if (_1 === (522)) {
					_tuple$10 = getnum(value, false);
					hour = _tuple$10[0];
					value = _tuple$10[1];
					err = _tuple$10[2];
					if (hour < 0 || 24 <= hour) {
						rangeErrString = "hour";
					}
				} else if ((_1 === (523)) || (_1 === (524))) {
					_tuple$11 = getnum(value, std === 524);
					hour = _tuple$11[0];
					value = _tuple$11[1];
					err = _tuple$11[2];
					if (hour < 0 || 12 < hour) {
						rangeErrString = "hour";
					}
				} else if ((_1 === (525)) || (_1 === (526))) {
					_tuple$12 = getnum(value, std === 526);
					min = _tuple$12[0];
					value = _tuple$12[1];
					err = _tuple$12[2];
					if (min < 0 || 60 <= min) {
						rangeErrString = "minute";
					}
				} else if ((_1 === (527)) || (_1 === (528))) {
					_tuple$13 = getnum(value, std === 528);
					sec = _tuple$13[0];
					value = _tuple$13[1];
					err = _tuple$13[2];
					if (sec < 0 || 60 <= sec) {
						rangeErrString = "second";
						break;
					}
					if (value.length >= 2 && (value.charCodeAt(0) === 46) && isDigit(value, 1)) {
						_tuple$14 = nextStdChunk(layout);
						std = _tuple$14[1];
						std = std & (65535);
						if ((std === 32) || (std === 33)) {
							break;
						}
						n = 2;
						while (true) {
							if (!(n < value.length && isDigit(value, n))) { break; }
							n = n + (1) >> 0;
						}
						_tuple$15 = parseNanoseconds(value, n);
						nsec = _tuple$15[0];
						rangeErrString = _tuple$15[1];
						err = _tuple$15[2];
						value = $substring(value, n);
					}
				} else if (_1 === (531)) {
					if (value.length < 2) {
						err = errBad;
						break;
					}
					_tmp$6 = $substring(value, 0, 2);
					_tmp$7 = $substring(value, 2);
					p = _tmp$6;
					value = _tmp$7;
					_2 = p;
					if (_2 === ("PM")) {
						pmSet = true;
					} else if (_2 === ("AM")) {
						amSet = true;
					} else {
						err = errBad;
					}
				} else if (_1 === (532)) {
					if (value.length < 2) {
						err = errBad;
						break;
					}
					_tmp$8 = $substring(value, 0, 2);
					_tmp$9 = $substring(value, 2);
					p = _tmp$8;
					value = _tmp$9;
					_3 = p;
					if (_3 === ("pm")) {
						pmSet = true;
					} else if (_3 === ("am")) {
						amSet = true;
					} else {
						err = errBad;
					}
				} else if ((_1 === (22)) || (_1 === (25)) || (_1 === (23)) || (_1 === (24)) || (_1 === (26)) || (_1 === (27)) || (_1 === (29)) || (_1 === (30)) || (_1 === (28)) || (_1 === (31))) {
					if (((std === 22) || (std === 24) || (std === 25)) && value.length >= 1 && (value.charCodeAt(0) === 90)) {
						value = $substring(value, 1);
						z = $pkg.UTC;
						break;
					}
					_tmp$10 = "";
					_tmp$11 = "";
					_tmp$12 = "";
					_tmp$13 = "";
					sign = _tmp$10;
					hour$1 = _tmp$11;
					min$1 = _tmp$12;
					seconds = _tmp$13;
					if ((std === 25) || (std === 30)) {
						if (value.length < 6) {
							err = errBad;
							break;
						}
						if (!((value.charCodeAt(3) === 58))) {
							err = errBad;
							break;
						}
						_tmp$14 = $substring(value, 0, 1);
						_tmp$15 = $substring(value, 1, 3);
						_tmp$16 = $substring(value, 4, 6);
						_tmp$17 = "00";
						_tmp$18 = $substring(value, 6);
						sign = _tmp$14;
						hour$1 = _tmp$15;
						min$1 = _tmp$16;
						seconds = _tmp$17;
						value = _tmp$18;
					} else if ((std === 29) || (std === 24)) {
						if (value.length < 3) {
							err = errBad;
							break;
						}
						_tmp$19 = $substring(value, 0, 1);
						_tmp$20 = $substring(value, 1, 3);
						_tmp$21 = "00";
						_tmp$22 = "00";
						_tmp$23 = $substring(value, 3);
						sign = _tmp$19;
						hour$1 = _tmp$20;
						min$1 = _tmp$21;
						seconds = _tmp$22;
						value = _tmp$23;
					} else if ((std === 26) || (std === 31)) {
						if (value.length < 9) {
							err = errBad;
							break;
						}
						if (!((value.charCodeAt(3) === 58)) || !((value.charCodeAt(6) === 58))) {
							err = errBad;
							break;
						}
						_tmp$24 = $substring(value, 0, 1);
						_tmp$25 = $substring(value, 1, 3);
						_tmp$26 = $substring(value, 4, 6);
						_tmp$27 = $substring(value, 7, 9);
						_tmp$28 = $substring(value, 9);
						sign = _tmp$24;
						hour$1 = _tmp$25;
						min$1 = _tmp$26;
						seconds = _tmp$27;
						value = _tmp$28;
					} else if ((std === 23) || (std === 28)) {
						if (value.length < 7) {
							err = errBad;
							break;
						}
						_tmp$29 = $substring(value, 0, 1);
						_tmp$30 = $substring(value, 1, 3);
						_tmp$31 = $substring(value, 3, 5);
						_tmp$32 = $substring(value, 5, 7);
						_tmp$33 = $substring(value, 7);
						sign = _tmp$29;
						hour$1 = _tmp$30;
						min$1 = _tmp$31;
						seconds = _tmp$32;
						value = _tmp$33;
					} else {
						if (value.length < 5) {
							err = errBad;
							break;
						}
						_tmp$34 = $substring(value, 0, 1);
						_tmp$35 = $substring(value, 1, 3);
						_tmp$36 = $substring(value, 3, 5);
						_tmp$37 = "00";
						_tmp$38 = $substring(value, 5);
						sign = _tmp$34;
						hour$1 = _tmp$35;
						min$1 = _tmp$36;
						seconds = _tmp$37;
						value = _tmp$38;
					}
					_tmp$39 = 0;
					_tmp$40 = 0;
					_tmp$41 = 0;
					hr = _tmp$39;
					mm = _tmp$40;
					ss = _tmp$41;
					_tuple$16 = atoi(hour$1);
					hr = _tuple$16[0];
					err = _tuple$16[1];
					if ($interfaceIsEqual(err, $ifaceNil)) {
						_tuple$17 = atoi(min$1);
						mm = _tuple$17[0];
						err = _tuple$17[1];
					}
					if ($interfaceIsEqual(err, $ifaceNil)) {
						_tuple$18 = atoi(seconds);
						ss = _tuple$18[0];
						err = _tuple$18[1];
					}
					zoneOffset = ($imul(((($imul(hr, 60)) + mm >> 0)), 60)) + ss >> 0;
					_4 = sign.charCodeAt(0);
					if (_4 === (43)) {
					} else if (_4 === (45)) {
						zoneOffset = -zoneOffset;
					} else {
						err = errBad;
					}
				} else if (_1 === (21)) {
					if (value.length >= 3 && $substring(value, 0, 3) === "UTC") {
						z = $pkg.UTC;
						value = $substring(value, 3);
						break;
					}
					_tuple$19 = parseTimeZone(value);
					n$1 = _tuple$19[0];
					ok = _tuple$19[1];
					if (!ok) {
						err = errBad;
						break;
					}
					_tmp$42 = $substring(value, 0, n$1);
					_tmp$43 = $substring(value, n$1);
					zoneName = _tmp$42;
					value = _tmp$43;
				} else if (_1 === (32)) {
					ndigit = 1 + ((std >> 16 >> 0)) >> 0;
					if (value.length < ndigit) {
						err = errBad;
						break;
					}
					_tuple$20 = parseNanoseconds(value, ndigit);
					nsec = _tuple$20[0];
					rangeErrString = _tuple$20[1];
					err = _tuple$20[2];
					value = $substring(value, ndigit);
				} else if (_1 === (33)) {
					if (value.length < 2 || !((value.charCodeAt(0) === 46)) || value.charCodeAt(1) < 48 || 57 < value.charCodeAt(1)) {
						break;
					}
					i = 0;
					while (true) {
						if (!(i < 9 && (i + 1 >> 0) < value.length && 48 <= value.charCodeAt((i + 1 >> 0)) && value.charCodeAt((i + 1 >> 0)) <= 57)) { break; }
						i = i + (1) >> 0;
					}
					_tuple$21 = parseNanoseconds(value, 1 + i >> 0);
					nsec = _tuple$21[0];
					rangeErrString = _tuple$21[1];
					err = _tuple$21[2];
					value = $substring(value, (1 + i >> 0));
				}
			}
			if (!(rangeErrString === "")) {
				$s = -1; return [new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil), new ParseError.ptr(alayout, avalue, stdstr, value, ": " + rangeErrString + " out of range")];
			}
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return [new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil), new ParseError.ptr(alayout, avalue, stdstr, value, "")];
			}
		}
		if (pmSet && hour < 12) {
			hour = hour + (12) >> 0;
		} else if (amSet && (hour === 12)) {
			hour = 0;
		}
		if (day < 1 || day > daysIn(((month >> 0)), year)) {
			$s = -1; return [new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil), new ParseError.ptr(alayout, avalue, "", value, ": day out of range")];
		}
		/* */ if (!(z === ptrType$2.nil)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(z === ptrType$2.nil)) { */ case 1:
			_r = Date(year, ((month >> 0)), day, hour, min, sec, nsec, z); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return [_r, $ifaceNil];
		/* } */ case 2:
		/* */ if (!((zoneOffset === -1))) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!((zoneOffset === -1))) { */ case 4:
			_r$1 = Date(year, ((month >> 0)), day, hour, min, sec, nsec, $pkg.UTC); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			t = $clone(_r$1, Time);
			t.addSec((x$1 = (new $Int64(0, zoneOffset)), new $Int64(-x$1.$high, -x$1.$low)));
			_r$2 = local.lookup(t.unixSec()); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple$22 = _r$2;
			name = _tuple$22[0];
			offset = _tuple$22[1];
			if ((offset === zoneOffset) && (zoneName === "" || name === zoneName)) {
				t.setLoc(local);
				$s = -1; return [t, $ifaceNil];
			}
			t.setLoc(FixedZone(zoneName, zoneOffset));
			$s = -1; return [t, $ifaceNil];
		/* } */ case 5:
		/* */ if (!(zoneName === "")) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if (!(zoneName === "")) { */ case 8:
			_r$3 = Date(year, ((month >> 0)), day, hour, min, sec, nsec, $pkg.UTC); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			t$1 = $clone(_r$3, Time);
			_r$4 = local.lookupName(zoneName, t$1.unixSec()); /* */ $s = 11; case 11: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			_tuple$23 = _r$4;
			offset$1 = _tuple$23[0];
			ok$1 = _tuple$23[1];
			if (ok$1) {
				t$1.addSec((x$2 = (new $Int64(0, offset$1)), new $Int64(-x$2.$high, -x$2.$low)));
				t$1.setLoc(local);
				$s = -1; return [t$1, $ifaceNil];
			}
			if (zoneName.length > 3 && $substring(zoneName, 0, 3) === "GMT") {
				_tuple$24 = atoi($substring(zoneName, 3));
				offset$1 = _tuple$24[0];
				offset$1 = $imul(offset$1, (3600));
			}
			t$1.setLoc(FixedZone(zoneName, offset$1));
			$s = -1; return [t$1, $ifaceNil];
		/* } */ case 9:
		_r$5 = Date(year, ((month >> 0)), day, hour, min, sec, nsec, defaultLocation); /* */ $s = 12; case 12: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		$s = -1; return [_r$5, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: parse }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$18 = _tmp$18; $f._tmp$19 = _tmp$19; $f._tmp$2 = _tmp$2; $f._tmp$20 = _tmp$20; $f._tmp$21 = _tmp$21; $f._tmp$22 = _tmp$22; $f._tmp$23 = _tmp$23; $f._tmp$24 = _tmp$24; $f._tmp$25 = _tmp$25; $f._tmp$26 = _tmp$26; $f._tmp$27 = _tmp$27; $f._tmp$28 = _tmp$28; $f._tmp$29 = _tmp$29; $f._tmp$3 = _tmp$3; $f._tmp$30 = _tmp$30; $f._tmp$31 = _tmp$31; $f._tmp$32 = _tmp$32; $f._tmp$33 = _tmp$33; $f._tmp$34 = _tmp$34; $f._tmp$35 = _tmp$35; $f._tmp$36 = _tmp$36; $f._tmp$37 = _tmp$37; $f._tmp$38 = _tmp$38; $f._tmp$39 = _tmp$39; $f._tmp$4 = _tmp$4; $f._tmp$40 = _tmp$40; $f._tmp$41 = _tmp$41; $f._tmp$42 = _tmp$42; $f._tmp$43 = _tmp$43; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$10 = _tuple$10; $f._tuple$11 = _tuple$11; $f._tuple$12 = _tuple$12; $f._tuple$13 = _tuple$13; $f._tuple$14 = _tuple$14; $f._tuple$15 = _tuple$15; $f._tuple$16 = _tuple$16; $f._tuple$17 = _tuple$17; $f._tuple$18 = _tuple$18; $f._tuple$19 = _tuple$19; $f._tuple$2 = _tuple$2; $f._tuple$20 = _tuple$20; $f._tuple$21 = _tuple$21; $f._tuple$22 = _tuple$22; $f._tuple$23 = _tuple$23; $f._tuple$24 = _tuple$24; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f._tuple$9 = _tuple$9; $f.alayout = alayout; $f.amSet = amSet; $f.avalue = avalue; $f.day = day; $f.defaultLocation = defaultLocation; $f.err = err; $f.hour = hour; $f.hour$1 = hour$1; $f.hr = hr; $f.i = i; $f.layout = layout; $f.local = local; $f.min = min; $f.min$1 = min$1; $f.mm = mm; $f.month = month; $f.n = n; $f.n$1 = n$1; $f.name = name; $f.ndigit = ndigit; $f.nsec = nsec; $f.offset = offset; $f.offset$1 = offset$1; $f.ok = ok; $f.ok$1 = ok$1; $f.p = p; $f.pmSet = pmSet; $f.prefix = prefix; $f.rangeErrString = rangeErrString; $f.sec = sec; $f.seconds = seconds; $f.sign = sign; $f.ss = ss; $f.std = std; $f.stdstr = stdstr; $f.suffix = suffix; $f.t = t; $f.t$1 = t$1; $f.value = value; $f.x$1 = x$1; $f.x$2 = x$2; $f.year = year; $f.z = z; $f.zoneName = zoneName; $f.zoneOffset = zoneOffset; $f.$s = $s; $f.$r = $r; return $f;
	};
	parseTimeZone = function(value) {
		var _1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, c, length, nUpper, ok, ok$1, value;
		length = 0;
		ok = false;
		if (value.length < 3) {
			_tmp = 0;
			_tmp$1 = false;
			length = _tmp;
			ok = _tmp$1;
			return [length, ok];
		}
		if (value.length >= 4 && ($substring(value, 0, 4) === "ChST" || $substring(value, 0, 4) === "MeST")) {
			_tmp$2 = 4;
			_tmp$3 = true;
			length = _tmp$2;
			ok = _tmp$3;
			return [length, ok];
		}
		if ($substring(value, 0, 3) === "GMT") {
			length = parseGMT(value);
			_tmp$4 = length;
			_tmp$5 = true;
			length = _tmp$4;
			ok = _tmp$5;
			return [length, ok];
		}
		if ((value.charCodeAt(0) === 43) || (value.charCodeAt(0) === 45)) {
			length = parseSignedOffset(value);
			ok$1 = length > 0;
			_tmp$6 = length;
			_tmp$7 = ok$1;
			length = _tmp$6;
			ok = _tmp$7;
			return [length, ok];
		}
		nUpper = 0;
		nUpper = 0;
		while (true) {
			if (!(nUpper < 6)) { break; }
			if (nUpper >= value.length) {
				break;
			}
			c = value.charCodeAt(nUpper);
			if (c < 65 || 90 < c) {
				break;
			}
			nUpper = nUpper + (1) >> 0;
		}
		_1 = nUpper;
		if ((_1 === (0)) || (_1 === (1)) || (_1 === (2)) || (_1 === (6))) {
			_tmp$8 = 0;
			_tmp$9 = false;
			length = _tmp$8;
			ok = _tmp$9;
			return [length, ok];
		} else if (_1 === (5)) {
			if (value.charCodeAt(4) === 84) {
				_tmp$10 = 5;
				_tmp$11 = true;
				length = _tmp$10;
				ok = _tmp$11;
				return [length, ok];
			}
		} else if (_1 === (4)) {
			if ((value.charCodeAt(3) === 84) || $substring(value, 0, 4) === "WITA") {
				_tmp$12 = 4;
				_tmp$13 = true;
				length = _tmp$12;
				ok = _tmp$13;
				return [length, ok];
			}
		} else if (_1 === (3)) {
			_tmp$14 = 3;
			_tmp$15 = true;
			length = _tmp$14;
			ok = _tmp$15;
			return [length, ok];
		}
		_tmp$16 = 0;
		_tmp$17 = false;
		length = _tmp$16;
		ok = _tmp$17;
		return [length, ok];
	};
	parseGMT = function(value) {
		var value;
		value = $substring(value, 3);
		if (value.length === 0) {
			return 3;
		}
		return 3 + parseSignedOffset(value) >> 0;
	};
	parseSignedOffset = function(value) {
		var _tuple, err, rem, sign, value, x$1;
		sign = value.charCodeAt(0);
		if (!((sign === 45)) && !((sign === 43))) {
			return 0;
		}
		_tuple = leadingInt($substring(value, 1));
		x$1 = _tuple[0];
		rem = _tuple[1];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil)) || $substring(value, 1) === rem) {
			return 0;
		}
		if (sign === 45) {
			x$1 = new $Int64(-x$1.$high, -x$1.$low);
		}
		if ((x$1.$high < -1 || (x$1.$high === -1 && x$1.$low < 4294967273)) || (0 < x$1.$high || (0 === x$1.$high && 23 < x$1.$low))) {
			return 0;
		}
		return value.length - rem.length >> 0;
	};
	parseNanoseconds = function(value, nbytes) {
		var _tuple, err, i, nbytes, ns, rangeErrString, scaleDigits, value;
		ns = 0;
		rangeErrString = "";
		err = $ifaceNil;
		if (!((value.charCodeAt(0) === 46))) {
			err = errBad;
			return [ns, rangeErrString, err];
		}
		_tuple = atoi($substring(value, 1, nbytes));
		ns = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [ns, rangeErrString, err];
		}
		if (ns < 0 || 1000000000 <= ns) {
			rangeErrString = "fractional second";
			return [ns, rangeErrString, err];
		}
		scaleDigits = 10 - nbytes >> 0;
		i = 0;
		while (true) {
			if (!(i < scaleDigits)) { break; }
			ns = $imul(ns, (10));
			i = i + (1) >> 0;
		}
		return [ns, rangeErrString, err];
	};
	leadingInt = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, c, err, i, rem, s, x$1, x$2, x$3, x$4;
		x$1 = new $Int64(0, 0);
		rem = "";
		err = $ifaceNil;
		i = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			c = s.charCodeAt(i);
			if (c < 48 || c > 57) {
				break;
			}
			if ((x$1.$high > 214748364 || (x$1.$high === 214748364 && x$1.$low > 3435973836))) {
				_tmp = new $Int64(0, 0);
				_tmp$1 = "";
				_tmp$2 = errLeadingInt;
				x$1 = _tmp;
				rem = _tmp$1;
				err = _tmp$2;
				return [x$1, rem, err];
			}
			x$1 = (x$2 = (x$3 = $mul64(x$1, new $Int64(0, 10)), x$4 = (new $Int64(0, c)), new $Int64(x$3.$high + x$4.$high, x$3.$low + x$4.$low)), new $Int64(x$2.$high - 0, x$2.$low - 48));
			if ((x$1.$high < 0 || (x$1.$high === 0 && x$1.$low < 0))) {
				_tmp$3 = new $Int64(0, 0);
				_tmp$4 = "";
				_tmp$5 = errLeadingInt;
				x$1 = _tmp$3;
				rem = _tmp$4;
				err = _tmp$5;
				return [x$1, rem, err];
			}
			i = i + (1) >> 0;
		}
		_tmp$6 = x$1;
		_tmp$7 = $substring(s, i);
		_tmp$8 = $ifaceNil;
		x$1 = _tmp$6;
		rem = _tmp$7;
		err = _tmp$8;
		return [x$1, rem, err];
	};
	Time.ptr.prototype.nsec = function() {
		var t, x$1;
		t = this;
		return (((x$1 = t.wall, new $Uint64(x$1.$high & 0, (x$1.$low & 1073741823) >>> 0)).$low >> 0));
	};
	Time.prototype.nsec = function() { return this.$val.nsec(); };
	Time.ptr.prototype.sec = function() {
		var t, x$1, x$2, x$3, x$4;
		t = this;
		if (!((x$1 = (x$2 = t.wall, new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0)), (x$1.$high === 0 && x$1.$low === 0)))) {
			return (x$3 = ((x$4 = $shiftRightUint64($shiftLeft64(t.wall, 1), 31), new $Int64(x$4.$high, x$4.$low))), new $Int64(13 + x$3.$high, 3618733952 + x$3.$low));
		}
		return t.ext;
	};
	Time.prototype.sec = function() { return this.$val.sec(); };
	Time.ptr.prototype.unixSec = function() {
		var t, x$1;
		t = this;
		return (x$1 = t.sec(), new $Int64(x$1.$high + -15, x$1.$low + 2288912640));
	};
	Time.prototype.unixSec = function() { return this.$val.unixSec(); };
	Time.ptr.prototype.addSec = function(d) {
		var d, dsec, sec, t, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		t = this;
		if (!((x$1 = (x$2 = t.wall, new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0)), (x$1.$high === 0 && x$1.$low === 0)))) {
			sec = ((x$3 = $shiftRightUint64($shiftLeft64(t.wall, 1), 31), new $Int64(x$3.$high, x$3.$low)));
			dsec = new $Int64(sec.$high + d.$high, sec.$low + d.$low);
			if ((0 < dsec.$high || (0 === dsec.$high && 0 <= dsec.$low)) && (dsec.$high < 1 || (dsec.$high === 1 && dsec.$low <= 4294967295))) {
				t.wall = (x$4 = (x$5 = (x$6 = t.wall, new $Uint64(x$6.$high & 0, (x$6.$low & 1073741823) >>> 0)), x$7 = $shiftLeft64((new $Uint64(dsec.$high, dsec.$low)), 30), new $Uint64(x$5.$high | x$7.$high, (x$5.$low | x$7.$low) >>> 0)), new $Uint64(x$4.$high | 2147483648, (x$4.$low | 0) >>> 0));
				return;
			}
			t.stripMono();
		}
		t.ext = (x$8 = t.ext, x$9 = d, new $Int64(x$8.$high + x$9.$high, x$8.$low + x$9.$low));
	};
	Time.prototype.addSec = function(d) { return this.$val.addSec(d); };
	Time.ptr.prototype.setLoc = function(loc) {
		var loc, t;
		t = this;
		if (loc === utcLoc) {
			loc = ptrType$2.nil;
		}
		t.stripMono();
		t.loc = loc;
	};
	Time.prototype.setLoc = function(loc) { return this.$val.setLoc(loc); };
	Time.ptr.prototype.stripMono = function() {
		var t, x$1, x$2, x$3, x$4;
		t = this;
		if (!((x$1 = (x$2 = t.wall, new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0)), (x$1.$high === 0 && x$1.$low === 0)))) {
			t.ext = t.sec();
			t.wall = (x$3 = t.wall, x$4 = new $Uint64(0, 1073741823), new $Uint64(x$3.$high & x$4.$high, (x$3.$low & x$4.$low) >>> 0));
		}
	};
	Time.prototype.stripMono = function() { return this.$val.stripMono(); };
	Time.ptr.prototype.After = function(u) {
		var t, ts, u, us, x$1, x$2, x$3, x$4, x$5, x$6;
		t = this;
		if (!((x$1 = (x$2 = (x$3 = t.wall, x$4 = u.wall, new $Uint64(x$3.$high & x$4.$high, (x$3.$low & x$4.$low) >>> 0)), new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0)), (x$1.$high === 0 && x$1.$low === 0)))) {
			return (x$5 = t.ext, x$6 = u.ext, (x$5.$high > x$6.$high || (x$5.$high === x$6.$high && x$5.$low > x$6.$low)));
		}
		ts = t.sec();
		us = u.sec();
		return (ts.$high > us.$high || (ts.$high === us.$high && ts.$low > us.$low)) || (ts.$high === us.$high && ts.$low === us.$low) && t.nsec() > u.nsec();
	};
	Time.prototype.After = function(u) { return this.$val.After(u); };
	Time.ptr.prototype.Before = function(u) {
		var t, u, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		t = this;
		if (!((x$1 = (x$2 = (x$3 = t.wall, x$4 = u.wall, new $Uint64(x$3.$high & x$4.$high, (x$3.$low & x$4.$low) >>> 0)), new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0)), (x$1.$high === 0 && x$1.$low === 0)))) {
			return (x$5 = t.ext, x$6 = u.ext, (x$5.$high < x$6.$high || (x$5.$high === x$6.$high && x$5.$low < x$6.$low)));
		}
		return (x$7 = t.sec(), x$8 = u.sec(), (x$7.$high < x$8.$high || (x$7.$high === x$8.$high && x$7.$low < x$8.$low))) || (x$9 = t.sec(), x$10 = u.sec(), (x$9.$high === x$10.$high && x$9.$low === x$10.$low)) && t.nsec() < u.nsec();
	};
	Time.prototype.Before = function(u) { return this.$val.Before(u); };
	Time.ptr.prototype.Equal = function(u) {
		var t, u, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8;
		t = this;
		if (!((x$1 = (x$2 = (x$3 = t.wall, x$4 = u.wall, new $Uint64(x$3.$high & x$4.$high, (x$3.$low & x$4.$low) >>> 0)), new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0)), (x$1.$high === 0 && x$1.$low === 0)))) {
			return (x$5 = t.ext, x$6 = u.ext, (x$5.$high === x$6.$high && x$5.$low === x$6.$low));
		}
		return (x$7 = t.sec(), x$8 = u.sec(), (x$7.$high === x$8.$high && x$7.$low === x$8.$low)) && (t.nsec() === u.nsec());
	};
	Time.prototype.Equal = function(u) { return this.$val.Equal(u); };
	Month.prototype.String = function() {
		var buf, m, n, x$1;
		m = this.$val;
		if (1 <= m && m <= 12) {
			return (x$1 = m - 1 >> 0, ((x$1 < 0 || x$1 >= months.length) ? ($throwRuntimeError("index out of range"), undefined) : months[x$1]));
		}
		buf = $makeSlice(sliceType$3, 20);
		n = fmtInt(buf, (new $Uint64(0, m)));
		return "%!Month(" + ($bytesToString($subslice(buf, n))) + ")";
	};
	$ptrType(Month).prototype.String = function() { return new Month(this.$get()).String(); };
	Weekday.prototype.String = function() {
		var buf, d, n;
		d = this.$val;
		if (0 <= d && d <= 6) {
			return ((d < 0 || d >= days.length) ? ($throwRuntimeError("index out of range"), undefined) : days[d]);
		}
		buf = $makeSlice(sliceType$3, 20);
		n = fmtInt(buf, (new $Uint64(0, d)));
		return "%!Weekday(" + ($bytesToString($subslice(buf, n))) + ")";
	};
	$ptrType(Weekday).prototype.String = function() { return new Weekday(this.$get()).String(); };
	Time.ptr.prototype.IsZero = function() {
		var t, x$1;
		t = this;
		return (x$1 = t.sec(), (x$1.$high === 0 && x$1.$low === 0)) && (t.nsec() === 0);
	};
	Time.prototype.IsZero = function() { return this.$val.IsZero(); };
	Time.ptr.prototype.abs = function() {
		var _r, _r$1, _tuple, l, offset, sec, t, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; l = $f.l; offset = $f.offset; sec = $f.sec; t = $f.t; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		l = t.loc;
		/* */ if (l === ptrType$2.nil || l === localLoc) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (l === ptrType$2.nil || l === localLoc) { */ case 1:
			_r = l.get(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			l = _r;
		/* } */ case 2:
		sec = t.unixSec();
		/* */ if (!(l === utcLoc)) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!(l === utcLoc)) { */ case 4:
			/* */ if (!(l.cacheZone === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (!(l.cacheZone === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) { */ case 6:
				sec = (x$3 = (new $Int64(0, l.cacheZone.offset)), new $Int64(sec.$high + x$3.$high, sec.$low + x$3.$low));
				$s = 8; continue;
			/* } else { */ case 7:
				_r$1 = l.lookup(sec); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple = _r$1;
				offset = _tuple[1];
				sec = (x$4 = (new $Int64(0, offset)), new $Int64(sec.$high + x$4.$high, sec.$low + x$4.$low));
			/* } */ case 8:
		/* } */ case 5:
		$s = -1; return ((x$5 = new $Int64(sec.$high + 2147483646, sec.$low + 450480384), new $Uint64(x$5.$high, x$5.$low)));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.abs }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.l = l; $f.offset = offset; $f.sec = sec; $f.t = t; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.abs = function() { return this.$val.abs(); };
	Time.ptr.prototype.locabs = function() {
		var _r, _r$1, _tuple, abs, l, name, offset, sec, t, x$1, x$2, x$3, x$4, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; abs = $f.abs; l = $f.l; name = $f.name; offset = $f.offset; sec = $f.sec; t = $f.t; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		name = "";
		offset = 0;
		abs = new $Uint64(0, 0);
		t = this;
		l = t.loc;
		/* */ if (l === ptrType$2.nil || l === localLoc) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (l === ptrType$2.nil || l === localLoc) { */ case 1:
			_r = l.get(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			l = _r;
		/* } */ case 2:
		sec = t.unixSec();
		/* */ if (!(l === utcLoc)) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!(l === utcLoc)) { */ case 4:
			/* */ if (!(l.cacheZone === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!(l.cacheZone === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) { */ case 7:
				name = l.cacheZone.name;
				offset = l.cacheZone.offset;
				$s = 9; continue;
			/* } else { */ case 8:
				_r$1 = l.lookup(sec); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple = _r$1;
				name = _tuple[0];
				offset = _tuple[1];
			/* } */ case 9:
			sec = (x$3 = (new $Int64(0, offset)), new $Int64(sec.$high + x$3.$high, sec.$low + x$3.$low));
			$s = 6; continue;
		/* } else { */ case 5:
			name = "UTC";
		/* } */ case 6:
		abs = ((x$4 = new $Int64(sec.$high + 2147483646, sec.$low + 450480384), new $Uint64(x$4.$high, x$4.$low)));
		$s = -1; return [name, offset, abs];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.locabs }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.abs = abs; $f.l = l; $f.name = name; $f.offset = offset; $f.sec = sec; $f.t = t; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.locabs = function() { return this.$val.locabs(); };
	Time.ptr.prototype.Date = function() {
		var _r, _tuple, day, month, t, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; day = $f.day; month = $f.month; t = $f.t; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		year = 0;
		month = 0;
		day = 0;
		t = this;
		_r = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		year = _tuple[0];
		month = _tuple[1];
		day = _tuple[2];
		$s = -1; return [year, month, day];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Date }; } $f._r = _r; $f._tuple = _tuple; $f.day = day; $f.month = month; $f.t = t; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Date = function() { return this.$val.Date(); };
	Time.ptr.prototype.Year = function() {
		var _r, _tuple, t, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; t = $f.t; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).date(false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		year = _tuple[0];
		$s = -1; return year;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Year }; } $f._r = _r; $f._tuple = _tuple; $f.t = t; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Year = function() { return this.$val.Year(); };
	Time.ptr.prototype.Month = function() {
		var _r, _tuple, month, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; month = $f.month; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		month = _tuple[1];
		$s = -1; return month;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Month }; } $f._r = _r; $f._tuple = _tuple; $f.month = month; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Month = function() { return this.$val.Month(); };
	Time.ptr.prototype.Day = function() {
		var _r, _tuple, day, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; day = $f.day; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		day = _tuple[2];
		$s = -1; return day;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Day }; } $f._r = _r; $f._tuple = _tuple; $f.day = day; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Day = function() { return this.$val.Day(); };
	Time.ptr.prototype.Weekday = function() {
		var _r, _r$1, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = absWeekday(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Weekday }; } $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Weekday = function() { return this.$val.Weekday(); };
	absWeekday = function(abs) {
		var _q, abs, sec;
		sec = $div64((new $Uint64(abs.$high + 0, abs.$low + 86400)), new $Uint64(0, 604800), true);
		return (((_q = ((sec.$low >> 0)) / 86400, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0));
	};
	Time.ptr.prototype.ISOWeek = function() {
		var _q, _r, _r$1, _r$2, _r$3, _r$4, _tuple, day, dec31wday, jan1wday, month, t, wday, week, yday, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _tuple = $f._tuple; day = $f.day; dec31wday = $f.dec31wday; jan1wday = $f.jan1wday; month = $f.month; t = $f.t; wday = $f.wday; week = $f.week; yday = $f.yday; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		year = 0;
		week = 0;
		t = this;
		_r = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		year = _tuple[0];
		month = _tuple[1];
		day = _tuple[2];
		yday = _tuple[3];
		_r$2 = $clone(t, Time).Weekday(); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		wday = (_r$1 = (((_r$2 + 6 >> 0) >> 0)) % 7, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"));
		week = (_q = (((yday - wday >> 0) + 7 >> 0)) / 7, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		jan1wday = (_r$3 = (((wday - yday >> 0) + 371 >> 0)) % 7, _r$3 === _r$3 ? _r$3 : $throwRuntimeError("integer divide by zero"));
		if (1 <= jan1wday && jan1wday <= 3) {
			week = week + (1) >> 0;
		}
		if (week === 0) {
			year = year - (1) >> 0;
			week = 52;
			if ((jan1wday === 4) || ((jan1wday === 5) && isLeap(year))) {
				week = week + (1) >> 0;
			}
		}
		if ((month === 12) && day >= 29 && wday < 3) {
			dec31wday = (_r$4 = (((wday + 31 >> 0) - day >> 0)) % 7, _r$4 === _r$4 ? _r$4 : $throwRuntimeError("integer divide by zero"));
			if (0 <= dec31wday && dec31wday <= 2) {
				year = year + (1) >> 0;
				week = 1;
			}
		}
		$s = -1; return [year, week];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.ISOWeek }; } $f._q = _q; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tuple = _tuple; $f.day = day; $f.dec31wday = dec31wday; $f.jan1wday = jan1wday; $f.month = month; $f.t = t; $f.wday = wday; $f.week = week; $f.yday = yday; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.ISOWeek = function() { return this.$val.ISOWeek(); };
	Time.ptr.prototype.Clock = function() {
		var _r, _r$1, _tuple, hour, min, sec, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; hour = $f.hour; min = $f.min; sec = $f.sec; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		hour = 0;
		min = 0;
		sec = 0;
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = absClock(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		hour = _tuple[0];
		min = _tuple[1];
		sec = _tuple[2];
		$s = -1; return [hour, min, sec];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Clock }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.hour = hour; $f.min = min; $f.sec = sec; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Clock = function() { return this.$val.Clock(); };
	absClock = function(abs) {
		var _q, _q$1, abs, hour, min, sec;
		hour = 0;
		min = 0;
		sec = 0;
		sec = (($div64(abs, new $Uint64(0, 86400), true).$low >> 0));
		hour = (_q = sec / 3600, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		sec = sec - (($imul(hour, 3600))) >> 0;
		min = (_q$1 = sec / 60, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"));
		sec = sec - (($imul(min, 60))) >> 0;
		return [hour, min, sec];
	};
	Time.ptr.prototype.Hour = function() {
		var _q, _r, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (_q = (($div64(_r, new $Uint64(0, 86400), true).$low >> 0)) / 3600, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Hour }; } $f._q = _q; $f._r = _r; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Hour = function() { return this.$val.Hour(); };
	Time.ptr.prototype.Minute = function() {
		var _q, _r, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (_q = (($div64(_r, new $Uint64(0, 3600), true).$low >> 0)) / 60, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Minute }; } $f._q = _q; $f._r = _r; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Minute = function() { return this.$val.Minute(); };
	Time.ptr.prototype.Second = function() {
		var _r, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (($div64(_r, new $Uint64(0, 60), true).$low >> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Second }; } $f._r = _r; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Second = function() { return this.$val.Second(); };
	Time.ptr.prototype.Nanosecond = function() {
		var t;
		t = this;
		return ((t.nsec() >> 0));
	};
	Time.prototype.Nanosecond = function() { return this.$val.Nanosecond(); };
	Time.ptr.prototype.YearDay = function() {
		var _r, _tuple, t, yday, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; t = $f.t; yday = $f.yday; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).date(false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		yday = _tuple[3];
		$s = -1; return yday + 1 >> 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.YearDay }; } $f._r = _r; $f._tuple = _tuple; $f.t = t; $f.yday = yday; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.YearDay = function() { return this.$val.YearDay(); };
	Duration.prototype.String = function() {
		var _tuple, _tuple$1, buf, d, neg, prec, u, w;
		d = this;
		buf = arrayType$3.zero();
		w = 32;
		u = (new $Uint64(d.$high, d.$low));
		neg = (d.$high < 0 || (d.$high === 0 && d.$low < 0));
		if (neg) {
			u = new $Uint64(-u.$high, -u.$low);
		}
		if ((u.$high < 0 || (u.$high === 0 && u.$low < 1000000000))) {
			prec = 0;
			w = w - (1) >> 0;
			((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 115);
			w = w - (1) >> 0;
			if ((u.$high === 0 && u.$low === 0)) {
				return "0s";
			} else if ((u.$high < 0 || (u.$high === 0 && u.$low < 1000))) {
				prec = 0;
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 110);
			} else if ((u.$high < 0 || (u.$high === 0 && u.$low < 1000000))) {
				prec = 3;
				w = w - (1) >> 0;
				$copyString($subslice(new sliceType$3(buf), w), "\xC2\xB5");
			} else {
				prec = 6;
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 109);
			}
			_tuple = fmtFrac($subslice(new sliceType$3(buf), 0, w), u, prec);
			w = _tuple[0];
			u = _tuple[1];
			w = fmtInt($subslice(new sliceType$3(buf), 0, w), u);
		} else {
			w = w - (1) >> 0;
			((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 115);
			_tuple$1 = fmtFrac($subslice(new sliceType$3(buf), 0, w), u, 9);
			w = _tuple$1[0];
			u = _tuple$1[1];
			w = fmtInt($subslice(new sliceType$3(buf), 0, w), $div64(u, new $Uint64(0, 60), true));
			u = $div64(u, (new $Uint64(0, 60)), false);
			if ((u.$high > 0 || (u.$high === 0 && u.$low > 0))) {
				w = w - (1) >> 0;
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 109);
				w = fmtInt($subslice(new sliceType$3(buf), 0, w), $div64(u, new $Uint64(0, 60), true));
				u = $div64(u, (new $Uint64(0, 60)), false);
				if ((u.$high > 0 || (u.$high === 0 && u.$low > 0))) {
					w = w - (1) >> 0;
					((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 104);
					w = fmtInt($subslice(new sliceType$3(buf), 0, w), u);
				}
			}
		}
		if (neg) {
			w = w - (1) >> 0;
			((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 45);
		}
		return ($bytesToString($subslice(new sliceType$3(buf), w)));
	};
	$ptrType(Duration).prototype.String = function() { return this.$get().String(); };
	fmtFrac = function(buf, v, prec) {
		var _tmp, _tmp$1, buf, digit, i, nv, nw, prec, print, v, w;
		nw = 0;
		nv = new $Uint64(0, 0);
		w = buf.$length;
		print = false;
		i = 0;
		while (true) {
			if (!(i < prec)) { break; }
			digit = $div64(v, new $Uint64(0, 10), true);
			print = print || !((digit.$high === 0 && digit.$low === 0));
			if (print) {
				w = w - (1) >> 0;
				((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = (((digit.$low << 24 >>> 24)) + 48 << 24 >>> 24));
			}
			v = $div64(v, (new $Uint64(0, 10)), false);
			i = i + (1) >> 0;
		}
		if (print) {
			w = w - (1) >> 0;
			((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = 46);
		}
		_tmp = w;
		_tmp$1 = v;
		nw = _tmp;
		nv = _tmp$1;
		return [nw, nv];
	};
	fmtInt = function(buf, v) {
		var buf, v, w;
		w = buf.$length;
		if ((v.$high === 0 && v.$low === 0)) {
			w = w - (1) >> 0;
			((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = 48);
		} else {
			while (true) {
				if (!((v.$high > 0 || (v.$high === 0 && v.$low > 0)))) { break; }
				w = w - (1) >> 0;
				((w < 0 || w >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + w] = ((($div64(v, new $Uint64(0, 10), true).$low << 24 >>> 24)) + 48 << 24 >>> 24));
				v = $div64(v, (new $Uint64(0, 10)), false);
			}
		}
		return w;
	};
	Duration.prototype.Nanoseconds = function() {
		var d;
		d = this;
		return (new $Int64(d.$high, d.$low));
	};
	$ptrType(Duration).prototype.Nanoseconds = function() { return this.$get().Nanoseconds(); };
	Duration.prototype.Seconds = function() {
		var d, nsec, sec;
		d = this;
		sec = $div64(d, new Duration(0, 1000000000), false);
		nsec = $div64(d, new Duration(0, 1000000000), true);
		return ($flatten64(sec)) + ($flatten64(nsec)) / 1e+09;
	};
	$ptrType(Duration).prototype.Seconds = function() { return this.$get().Seconds(); };
	Duration.prototype.Minutes = function() {
		var d, min, nsec;
		d = this;
		min = $div64(d, new Duration(13, 4165425152), false);
		nsec = $div64(d, new Duration(13, 4165425152), true);
		return ($flatten64(min)) + ($flatten64(nsec)) / 6e+10;
	};
	$ptrType(Duration).prototype.Minutes = function() { return this.$get().Minutes(); };
	Duration.prototype.Hours = function() {
		var d, hour, nsec;
		d = this;
		hour = $div64(d, new Duration(838, 817405952), false);
		nsec = $div64(d, new Duration(838, 817405952), true);
		return ($flatten64(hour)) + ($flatten64(nsec)) / 3.6e+12;
	};
	$ptrType(Duration).prototype.Hours = function() { return this.$get().Hours(); };
	Duration.prototype.Truncate = function(m) {
		var d, m, x$1;
		d = this;
		if ((m.$high < 0 || (m.$high === 0 && m.$low <= 0))) {
			return d;
		}
		return (x$1 = $div64(d, m, true), new Duration(d.$high - x$1.$high, d.$low - x$1.$low));
	};
	$ptrType(Duration).prototype.Truncate = function(m) { return this.$get().Truncate(m); };
	lessThanHalf = function(x$1, y) {
		var x$1, x$2, x$3, x$4, x$5, y;
		return (x$2 = (x$3 = (new $Uint64(x$1.$high, x$1.$low)), x$4 = (new $Uint64(x$1.$high, x$1.$low)), new $Uint64(x$3.$high + x$4.$high, x$3.$low + x$4.$low)), x$5 = (new $Uint64(y.$high, y.$low)), (x$2.$high < x$5.$high || (x$2.$high === x$5.$high && x$2.$low < x$5.$low)));
	};
	Duration.prototype.Round = function(m) {
		var d, d1, d1$1, m, r, x$1, x$2;
		d = this;
		if ((m.$high < 0 || (m.$high === 0 && m.$low <= 0))) {
			return d;
		}
		r = $div64(d, m, true);
		if ((d.$high < 0 || (d.$high === 0 && d.$low < 0))) {
			r = new Duration(-r.$high, -r.$low);
			if (lessThanHalf(r, m)) {
				return new Duration(d.$high + r.$high, d.$low + r.$low);
			}
			d1 = (x$1 = new Duration(d.$high - m.$high, d.$low - m.$low), new Duration(x$1.$high + r.$high, x$1.$low + r.$low));
			if ((d1.$high < d.$high || (d1.$high === d.$high && d1.$low < d.$low))) {
				return d1;
			}
			return new Duration(-2147483648, 0);
		}
		if (lessThanHalf(r, m)) {
			return new Duration(d.$high - r.$high, d.$low - r.$low);
		}
		d1$1 = (x$2 = new Duration(d.$high + m.$high, d.$low + m.$low), new Duration(x$2.$high - r.$high, x$2.$low - r.$low));
		if ((d1$1.$high > d.$high || (d1$1.$high === d.$high && d1$1.$low > d.$low))) {
			return d1$1;
		}
		return new Duration(2147483647, 4294967295);
	};
	$ptrType(Duration).prototype.Round = function(m) { return this.$get().Round(m); };
	Time.ptr.prototype.Add = function(d) {
		var d, dsec, nsec, t, te, x$1, x$10, x$11, x$12, x$13, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		t = this;
		dsec = ((x$1 = $div64(d, new Duration(0, 1000000000), false), new $Int64(x$1.$high, x$1.$low)));
		nsec = t.nsec() + (((x$2 = $div64(d, new Duration(0, 1000000000), true), x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0)) >> 0;
		if (nsec >= 1000000000) {
			dsec = (x$3 = new $Int64(0, 1), new $Int64(dsec.$high + x$3.$high, dsec.$low + x$3.$low));
			nsec = nsec - (1000000000) >> 0;
		} else if (nsec < 0) {
			dsec = (x$4 = new $Int64(0, 1), new $Int64(dsec.$high - x$4.$high, dsec.$low - x$4.$low));
			nsec = nsec + (1000000000) >> 0;
		}
		t.wall = (x$5 = (x$6 = t.wall, new $Uint64(x$6.$high & ~0, (x$6.$low & ~1073741823) >>> 0)), x$7 = (new $Uint64(0, nsec)), new $Uint64(x$5.$high | x$7.$high, (x$5.$low | x$7.$low) >>> 0));
		t.addSec(dsec);
		if (!((x$8 = (x$9 = t.wall, new $Uint64(x$9.$high & 2147483648, (x$9.$low & 0) >>> 0)), (x$8.$high === 0 && x$8.$low === 0)))) {
			te = (x$10 = t.ext, x$11 = (new $Int64(d.$high, d.$low)), new $Int64(x$10.$high + x$11.$high, x$10.$low + x$11.$low));
			if ((d.$high < 0 || (d.$high === 0 && d.$low < 0)) && (x$12 = t.ext, (te.$high > x$12.$high || (te.$high === x$12.$high && te.$low > x$12.$low))) || (d.$high > 0 || (d.$high === 0 && d.$low > 0)) && (x$13 = t.ext, (te.$high < x$13.$high || (te.$high === x$13.$high && te.$low < x$13.$low)))) {
				t.stripMono();
			} else {
				t.ext = te;
			}
		}
		return t;
	};
	Time.prototype.Add = function(d) { return this.$val.Add(d); };
	Time.ptr.prototype.Sub = function(u) {
		var d, d$1, t, te, u, ue, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		t = this;
		if (!((x$1 = (x$2 = (x$3 = t.wall, x$4 = u.wall, new $Uint64(x$3.$high & x$4.$high, (x$3.$low & x$4.$low) >>> 0)), new $Uint64(x$2.$high & 2147483648, (x$2.$low & 0) >>> 0)), (x$1.$high === 0 && x$1.$low === 0)))) {
			te = t.ext;
			ue = u.ext;
			d = ((x$5 = new $Int64(te.$high - ue.$high, te.$low - ue.$low), new Duration(x$5.$high, x$5.$low)));
			if ((d.$high < 0 || (d.$high === 0 && d.$low < 0)) && (te.$high > ue.$high || (te.$high === ue.$high && te.$low > ue.$low))) {
				return new Duration(2147483647, 4294967295);
			}
			if ((d.$high > 0 || (d.$high === 0 && d.$low > 0)) && (te.$high < ue.$high || (te.$high === ue.$high && te.$low < ue.$low))) {
				return new Duration(-2147483648, 0);
			}
			return d;
		}
		d$1 = (x$6 = $mul64(((x$7 = (x$8 = t.sec(), x$9 = u.sec(), new $Int64(x$8.$high - x$9.$high, x$8.$low - x$9.$low)), new Duration(x$7.$high, x$7.$low))), new Duration(0, 1000000000)), x$10 = (new Duration(0, (t.nsec() - u.nsec() >> 0))), new Duration(x$6.$high + x$10.$high, x$6.$low + x$10.$low));
		if ($clone($clone(u, Time).Add(d$1), Time).Equal($clone(t, Time))) {
			return d$1;
		} else if ($clone(t, Time).Before($clone(u, Time))) {
			return new Duration(-2147483648, 0);
		} else {
			return new Duration(2147483647, 4294967295);
		}
	};
	Time.prototype.Sub = function(u) { return this.$val.Sub(u); };
	Time.ptr.prototype.AddDate = function(years, months$1, days$1) {
		var _r, _r$1, _r$2, _tuple, _tuple$1, day, days$1, hour, min, month, months$1, sec, t, year, years, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; day = $f.day; days$1 = $f.days$1; hour = $f.hour; min = $f.min; month = $f.month; months$1 = $f.months$1; sec = $f.sec; t = $f.t; year = $f.year; years = $f.years; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).Date(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		year = _tuple[0];
		month = _tuple[1];
		day = _tuple[2];
		_r$1 = $clone(t, Time).Clock(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		hour = _tuple$1[0];
		min = _tuple$1[1];
		sec = _tuple$1[2];
		_r$2 = Date(year + years >> 0, month + ((months$1 >> 0)) >> 0, day + days$1 >> 0, hour, min, sec, ((t.nsec() >> 0)), $clone(t, Time).Location()); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.AddDate }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.day = day; $f.days$1 = days$1; $f.hour = hour; $f.min = min; $f.month = month; $f.months$1 = months$1; $f.sec = sec; $f.t = t; $f.year = year; $f.years = years; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.AddDate = function(years, months$1, days$1) { return this.$val.AddDate(years, months$1, days$1); };
	Time.ptr.prototype.date = function(full) {
		var _r, _r$1, _tuple, day, full, month, t, yday, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; day = $f.day; full = $f.full; month = $f.month; t = $f.t; yday = $f.yday; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		year = 0;
		month = 0;
		day = 0;
		yday = 0;
		t = this;
		_r = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = absDate(_r, full); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		year = _tuple[0];
		month = _tuple[1];
		day = _tuple[2];
		yday = _tuple[3];
		$s = -1; return [year, month, day, yday];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.date }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.day = day; $f.full = full; $f.month = month; $f.t = t; $f.yday = yday; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.date = function(full) { return this.$val.date(full); };
	absDate = function(abs, full) {
		var _q, abs, begin, d, day, end, full, month, n, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y, yday, year;
		year = 0;
		month = 0;
		day = 0;
		yday = 0;
		d = $div64(abs, new $Uint64(0, 86400), false);
		n = $div64(d, new $Uint64(0, 146097), false);
		y = $mul64(new $Uint64(0, 400), n);
		d = (x$1 = $mul64(new $Uint64(0, 146097), n), new $Uint64(d.$high - x$1.$high, d.$low - x$1.$low));
		n = $div64(d, new $Uint64(0, 36524), false);
		n = (x$2 = $shiftRightUint64(n, 2), new $Uint64(n.$high - x$2.$high, n.$low - x$2.$low));
		y = (x$3 = $mul64(new $Uint64(0, 100), n), new $Uint64(y.$high + x$3.$high, y.$low + x$3.$low));
		d = (x$4 = $mul64(new $Uint64(0, 36524), n), new $Uint64(d.$high - x$4.$high, d.$low - x$4.$low));
		n = $div64(d, new $Uint64(0, 1461), false);
		y = (x$5 = $mul64(new $Uint64(0, 4), n), new $Uint64(y.$high + x$5.$high, y.$low + x$5.$low));
		d = (x$6 = $mul64(new $Uint64(0, 1461), n), new $Uint64(d.$high - x$6.$high, d.$low - x$6.$low));
		n = $div64(d, new $Uint64(0, 365), false);
		n = (x$7 = $shiftRightUint64(n, 2), new $Uint64(n.$high - x$7.$high, n.$low - x$7.$low));
		y = (x$8 = n, new $Uint64(y.$high + x$8.$high, y.$low + x$8.$low));
		d = (x$9 = $mul64(new $Uint64(0, 365), n), new $Uint64(d.$high - x$9.$high, d.$low - x$9.$low));
		year = (((x$10 = (x$11 = (new $Int64(y.$high, y.$low)), new $Int64(x$11.$high + -69, x$11.$low + 4075721025)), x$10.$low + ((x$10.$high >> 31) * 4294967296)) >> 0));
		yday = ((d.$low >> 0));
		if (!full) {
			return [year, month, day, yday];
		}
		day = yday;
		if (isLeap(year)) {
			if (day > 59) {
				day = day - (1) >> 0;
			} else if ((day === 59)) {
				month = 2;
				day = 29;
				return [year, month, day, yday];
			}
		}
		month = (((_q = day / 31, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0));
		end = (((x$12 = month + 1 >> 0, ((x$12 < 0 || x$12 >= daysBefore.length) ? ($throwRuntimeError("index out of range"), undefined) : daysBefore[x$12])) >> 0));
		begin = 0;
		if (day >= end) {
			month = month + (1) >> 0;
			begin = end;
		} else {
			begin = ((((month < 0 || month >= daysBefore.length) ? ($throwRuntimeError("index out of range"), undefined) : daysBefore[month]) >> 0));
		}
		month = month + (1) >> 0;
		day = (day - begin >> 0) + 1 >> 0;
		return [year, month, day, yday];
	};
	daysIn = function(m, year) {
		var m, x$1, year;
		if ((m === 2) && isLeap(year)) {
			return 29;
		}
		return (((((m < 0 || m >= daysBefore.length) ? ($throwRuntimeError("index out of range"), undefined) : daysBefore[m]) - (x$1 = m - 1 >> 0, ((x$1 < 0 || x$1 >= daysBefore.length) ? ($throwRuntimeError("index out of range"), undefined) : daysBefore[x$1])) >> 0) >> 0));
	};
	Now = function() {
		var _tuple, mono, nsec, sec, x$1, x$2, x$3, x$4, x$5, x$6;
		_tuple = now();
		sec = _tuple[0];
		nsec = _tuple[1];
		mono = _tuple[2];
		mono = (x$1 = startNano, new $Int64(mono.$high - x$1.$high, mono.$low - x$1.$low));
		sec = (x$2 = new $Int64(0, 2682288000), new $Int64(sec.$high + x$2.$high, sec.$low + x$2.$low));
		if (!((x$3 = $shiftRightUint64((new $Uint64(sec.$high, sec.$low)), 33), (x$3.$high === 0 && x$3.$low === 0)))) {
			return new Time.ptr((new $Uint64(0, nsec)), new $Int64(sec.$high + 13, sec.$low + 3618733952), $pkg.Local);
		}
		return new Time.ptr((x$4 = (x$5 = $shiftLeft64((new $Uint64(sec.$high, sec.$low)), 30), new $Uint64(2147483648 | x$5.$high, (0 | x$5.$low) >>> 0)), x$6 = (new $Uint64(0, nsec)), new $Uint64(x$4.$high | x$6.$high, (x$4.$low | x$6.$low) >>> 0)), mono, $pkg.Local);
	};
	$pkg.Now = Now;
	unixTime = function(sec, nsec) {
		var nsec, sec;
		return new Time.ptr((new $Uint64(0, nsec)), new $Int64(sec.$high + 14, sec.$low + 2006054656), $pkg.Local);
	};
	Time.ptr.prototype.UTC = function() {
		var t;
		t = this;
		t.setLoc(utcLoc);
		return t;
	};
	Time.prototype.UTC = function() { return this.$val.UTC(); };
	Time.ptr.prototype.Local = function() {
		var t;
		t = this;
		t.setLoc($pkg.Local);
		return t;
	};
	Time.prototype.Local = function() { return this.$val.Local(); };
	Time.ptr.prototype.In = function(loc) {
		var loc, t;
		t = this;
		if (loc === ptrType$2.nil) {
			$panic(new $String("time: missing Location in call to Time.In"));
		}
		t.setLoc(loc);
		return t;
	};
	Time.prototype.In = function(loc) { return this.$val.In(loc); };
	Time.ptr.prototype.Location = function() {
		var l, t;
		t = this;
		l = t.loc;
		if (l === ptrType$2.nil) {
			l = $pkg.UTC;
		}
		return l;
	};
	Time.prototype.Location = function() { return this.$val.Location(); };
	Time.ptr.prototype.Zone = function() {
		var _r, _tuple, name, offset, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; name = $f.name; offset = $f.offset; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		name = "";
		offset = 0;
		t = this;
		_r = t.loc.lookup(t.unixSec()); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		name = _tuple[0];
		offset = _tuple[1];
		$s = -1; return [name, offset];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Zone }; } $f._r = _r; $f._tuple = _tuple; $f.name = name; $f.offset = offset; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.Zone = function() { return this.$val.Zone(); };
	Time.ptr.prototype.Unix = function() {
		var t;
		t = this;
		return t.unixSec();
	};
	Time.prototype.Unix = function() { return this.$val.Unix(); };
	Time.ptr.prototype.UnixNano = function() {
		var t, x$1, x$2;
		t = this;
		return (x$1 = $mul64((t.unixSec()), new $Int64(0, 1000000000)), x$2 = (new $Int64(0, t.nsec())), new $Int64(x$1.$high + x$2.$high, x$1.$low + x$2.$low));
	};
	Time.prototype.UnixNano = function() { return this.$val.UnixNano(); };
	Time.ptr.prototype.MarshalBinary = function() {
		var _q, _r, _r$1, _tuple, enc, nsec, offset, offsetMin, sec, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; enc = $f.enc; nsec = $f.nsec; offset = $f.offset; offsetMin = $f.offsetMin; sec = $f.sec; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		offsetMin = 0;
		/* */ if ($clone(t, Time).Location() === $pkg.UTC) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($clone(t, Time).Location() === $pkg.UTC) { */ case 1:
			offsetMin = -1;
			$s = 3; continue;
		/* } else { */ case 2:
			_r = $clone(t, Time).Zone(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			offset = _tuple[1];
			if (!(((_r$1 = offset % 60, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0))) {
				$s = -1; return [sliceType$3.nil, errors.New("Time.MarshalBinary: zone offset has fractional minute")];
			}
			offset = (_q = offset / (60), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			if (offset < -32768 || (offset === -1) || offset > 32767) {
				$s = -1; return [sliceType$3.nil, errors.New("Time.MarshalBinary: unexpected zone offset")];
			}
			offsetMin = ((offset << 16 >> 16));
		/* } */ case 3:
		sec = t.sec();
		nsec = t.nsec();
		enc = new sliceType$3([1, (($shiftRightInt64(sec, 56).$low << 24 >>> 24)), (($shiftRightInt64(sec, 48).$low << 24 >>> 24)), (($shiftRightInt64(sec, 40).$low << 24 >>> 24)), (($shiftRightInt64(sec, 32).$low << 24 >>> 24)), (($shiftRightInt64(sec, 24).$low << 24 >>> 24)), (($shiftRightInt64(sec, 16).$low << 24 >>> 24)), (($shiftRightInt64(sec, 8).$low << 24 >>> 24)), ((sec.$low << 24 >>> 24)), (((nsec >> 24 >> 0) << 24 >>> 24)), (((nsec >> 16 >> 0) << 24 >>> 24)), (((nsec >> 8 >> 0) << 24 >>> 24)), ((nsec << 24 >>> 24)), (((offsetMin >> 8 << 16 >> 16) << 24 >>> 24)), ((offsetMin << 24 >>> 24))]);
		$s = -1; return [enc, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.MarshalBinary }; } $f._q = _q; $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.enc = enc; $f.nsec = nsec; $f.offset = offset; $f.offsetMin = offsetMin; $f.sec = sec; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.MarshalBinary = function() { return this.$val.MarshalBinary(); };
	Time.ptr.prototype.UnmarshalBinary = function(data) {
		var _r, _tuple, buf, data, localoff, nsec, offset, sec, t, x$1, x$10, x$11, x$12, x$13, x$14, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; buf = $f.buf; data = $f.data; localoff = $f.localoff; nsec = $f.nsec; offset = $f.offset; sec = $f.sec; t = $f.t; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		buf = data;
		if (buf.$length === 0) {
			$s = -1; return errors.New("Time.UnmarshalBinary: no data");
		}
		if (!(((0 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 0]) === 1))) {
			$s = -1; return errors.New("Time.UnmarshalBinary: unsupported version");
		}
		if (!((buf.$length === 15))) {
			$s = -1; return errors.New("Time.UnmarshalBinary: invalid length");
		}
		buf = $subslice(buf, 1);
		sec = (x$1 = (x$2 = (x$3 = (x$4 = (x$5 = (x$6 = (x$7 = (new $Int64(0, (7 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 7]))), x$8 = $shiftLeft64((new $Int64(0, (6 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 6]))), 8), new $Int64(x$7.$high | x$8.$high, (x$7.$low | x$8.$low) >>> 0)), x$9 = $shiftLeft64((new $Int64(0, (5 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 5]))), 16), new $Int64(x$6.$high | x$9.$high, (x$6.$low | x$9.$low) >>> 0)), x$10 = $shiftLeft64((new $Int64(0, (4 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 4]))), 24), new $Int64(x$5.$high | x$10.$high, (x$5.$low | x$10.$low) >>> 0)), x$11 = $shiftLeft64((new $Int64(0, (3 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 3]))), 32), new $Int64(x$4.$high | x$11.$high, (x$4.$low | x$11.$low) >>> 0)), x$12 = $shiftLeft64((new $Int64(0, (2 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 2]))), 40), new $Int64(x$3.$high | x$12.$high, (x$3.$low | x$12.$low) >>> 0)), x$13 = $shiftLeft64((new $Int64(0, (1 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 1]))), 48), new $Int64(x$2.$high | x$13.$high, (x$2.$low | x$13.$low) >>> 0)), x$14 = $shiftLeft64((new $Int64(0, (0 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 0]))), 56), new $Int64(x$1.$high | x$14.$high, (x$1.$low | x$14.$low) >>> 0));
		buf = $subslice(buf, 8);
		nsec = (((((3 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 3]) >> 0)) | ((((2 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 2]) >> 0)) << 8 >> 0)) | ((((1 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 1]) >> 0)) << 16 >> 0)) | ((((0 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 0]) >> 0)) << 24 >> 0);
		buf = $subslice(buf, 4);
		offset = $imul(((((((1 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 1]) << 16 >> 16)) | ((((0 >= buf.$length ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + 0]) << 16 >> 16)) << 8 << 16 >> 16)) >> 0)), 60);
		Time.copy(t, new Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$2.nil));
		t.wall = (new $Uint64(0, nsec));
		t.ext = sec;
		/* */ if (offset === -60) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (offset === -60) { */ case 1:
			t.setLoc(utcLoc);
			$s = 3; continue;
		/* } else { */ case 2:
			_r = $pkg.Local.lookup(t.unixSec()); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			localoff = _tuple[1];
			if (offset === localoff) {
				t.setLoc($pkg.Local);
			} else {
				t.setLoc(FixedZone("", offset));
			}
		/* } */ case 3:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.UnmarshalBinary }; } $f._r = _r; $f._tuple = _tuple; $f.buf = buf; $f.data = data; $f.localoff = localoff; $f.nsec = nsec; $f.offset = offset; $f.sec = sec; $f.t = t; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.UnmarshalBinary = function(data) { return this.$val.UnmarshalBinary(data); };
	Time.ptr.prototype.GobEncode = function() {
		var _r, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).MarshalBinary(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.GobEncode }; } $f._r = _r; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.GobEncode = function() { return this.$val.GobEncode(); };
	Time.ptr.prototype.GobDecode = function(data) {
		var _r, data, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; data = $f.data; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = t.UnmarshalBinary(data); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.GobDecode }; } $f._r = _r; $f.data = data; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.GobDecode = function(data) { return this.$val.GobDecode(data); };
	Time.ptr.prototype.MarshalJSON = function() {
		var _r, _r$1, b, t, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; b = $f.b; t = $f.t; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).Year(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		y = _r;
		if (y < 0 || y >= 10000) {
			$s = -1; return [sliceType$3.nil, errors.New("Time.MarshalJSON: year outside of range [0,9999]")];
		}
		b = $makeSlice(sliceType$3, 0, 37);
		b = $append(b, 34);
		_r$1 = $clone(t, Time).AppendFormat(b, "2006-01-02T15:04:05.999999999Z07:00"); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		b = _r$1;
		b = $append(b, 34);
		$s = -1; return [b, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.MarshalJSON }; } $f._r = _r; $f._r$1 = _r$1; $f.b = b; $f.t = t; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.MarshalJSON = function() { return this.$val.MarshalJSON(); };
	Time.ptr.prototype.UnmarshalJSON = function(data) {
		var _r, _tuple, data, err, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; data = $f.data; err = $f.err; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (($bytesToString(data)) === "null") {
			$s = -1; return $ifaceNil;
		}
		err = $ifaceNil;
		_r = Parse("\"2006-01-02T15:04:05Z07:00\"", ($bytesToString(data))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		Time.copy(t, _tuple[0]);
		err = _tuple[1];
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.UnmarshalJSON }; } $f._r = _r; $f._tuple = _tuple; $f.data = data; $f.err = err; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.UnmarshalJSON = function(data) { return this.$val.UnmarshalJSON(data); };
	Time.ptr.prototype.MarshalText = function() {
		var _r, _r$1, b, t, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; b = $f.b; t = $f.t; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		_r = $clone(t, Time).Year(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		y = _r;
		if (y < 0 || y >= 10000) {
			$s = -1; return [sliceType$3.nil, errors.New("Time.MarshalText: year outside of range [0,9999]")];
		}
		b = $makeSlice(sliceType$3, 0, 35);
		_r$1 = $clone(t, Time).AppendFormat(b, "2006-01-02T15:04:05.999999999Z07:00"); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return [_r$1, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.MarshalText }; } $f._r = _r; $f._r$1 = _r$1; $f.b = b; $f.t = t; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.MarshalText = function() { return this.$val.MarshalText(); };
	Time.ptr.prototype.UnmarshalText = function(data) {
		var _r, _tuple, data, err, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; data = $f.data; err = $f.err; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		err = $ifaceNil;
		_r = Parse("2006-01-02T15:04:05Z07:00", ($bytesToString(data))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		Time.copy(t, _tuple[0]);
		err = _tuple[1];
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.UnmarshalText }; } $f._r = _r; $f._tuple = _tuple; $f.data = data; $f.err = err; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Time.prototype.UnmarshalText = function(data) { return this.$val.UnmarshalText(data); };
	Unix = function(sec, nsec) {
		var n, nsec, sec, x$1, x$2, x$3, x$4;
		if ((nsec.$high < 0 || (nsec.$high === 0 && nsec.$low < 0)) || (nsec.$high > 0 || (nsec.$high === 0 && nsec.$low >= 1000000000))) {
			n = $div64(nsec, new $Int64(0, 1000000000), false);
			sec = (x$1 = n, new $Int64(sec.$high + x$1.$high, sec.$low + x$1.$low));
			nsec = (x$2 = $mul64(n, new $Int64(0, 1000000000)), new $Int64(nsec.$high - x$2.$high, nsec.$low - x$2.$low));
			if ((nsec.$high < 0 || (nsec.$high === 0 && nsec.$low < 0))) {
				nsec = (x$3 = new $Int64(0, 1000000000), new $Int64(nsec.$high + x$3.$high, nsec.$low + x$3.$low));
				sec = (x$4 = new $Int64(0, 1), new $Int64(sec.$high - x$4.$high, sec.$low - x$4.$low));
			}
		}
		return unixTime(sec, (((nsec.$low + ((nsec.$high >> 31) * 4294967296)) >> 0)));
	};
	$pkg.Unix = Unix;
	isLeap = function(year) {
		var _r, _r$1, _r$2, year;
		return ((_r = year % 4, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0) && (!(((_r$1 = year % 100, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0)) || ((_r$2 = year % 400, _r$2 === _r$2 ? _r$2 : $throwRuntimeError("integer divide by zero")) === 0));
	};
	norm = function(hi, lo, base) {
		var _q, _q$1, _tmp, _tmp$1, base, hi, lo, n, n$1, nhi, nlo;
		nhi = 0;
		nlo = 0;
		if (lo < 0) {
			n = (_q = ((-lo - 1 >> 0)) / base, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0;
			hi = hi - (n) >> 0;
			lo = lo + (($imul(n, base))) >> 0;
		}
		if (lo >= base) {
			n$1 = (_q$1 = lo / base, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"));
			hi = hi + (n$1) >> 0;
			lo = lo - (($imul(n$1, base))) >> 0;
		}
		_tmp = hi;
		_tmp$1 = lo;
		nhi = _tmp;
		nlo = _tmp$1;
		return [nhi, nlo];
	};
	Date = function(year, month, day, hour, min, sec, nsec, loc) {
		var _r, _r$1, _r$2, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, abs, d, day, end, hour, loc, m, min, month, n, nsec, offset, sec, start, t, unix, utc, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; abs = $f.abs; d = $f.d; day = $f.day; end = $f.end; hour = $f.hour; loc = $f.loc; m = $f.m; min = $f.min; month = $f.month; n = $f.n; nsec = $f.nsec; offset = $f.offset; sec = $f.sec; start = $f.start; t = $f.t; unix = $f.unix; utc = $f.utc; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$16 = $f.x$16; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; y = $f.y; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (loc === ptrType$2.nil) {
			$panic(new $String("time: missing Location in call to Date"));
		}
		m = ((month >> 0)) - 1 >> 0;
		_tuple = norm(year, m, 12);
		year = _tuple[0];
		m = _tuple[1];
		month = ((m >> 0)) + 1 >> 0;
		_tuple$1 = norm(sec, nsec, 1000000000);
		sec = _tuple$1[0];
		nsec = _tuple$1[1];
		_tuple$2 = norm(min, sec, 60);
		min = _tuple$2[0];
		sec = _tuple$2[1];
		_tuple$3 = norm(hour, min, 60);
		hour = _tuple$3[0];
		min = _tuple$3[1];
		_tuple$4 = norm(day, hour, 24);
		day = _tuple$4[0];
		hour = _tuple$4[1];
		y = ((x$1 = (x$2 = (new $Int64(0, year)), new $Int64(x$2.$high - -69, x$2.$low - 4075721025)), new $Uint64(x$1.$high, x$1.$low)));
		n = $div64(y, new $Uint64(0, 400), false);
		y = (x$3 = $mul64(new $Uint64(0, 400), n), new $Uint64(y.$high - x$3.$high, y.$low - x$3.$low));
		d = $mul64(new $Uint64(0, 146097), n);
		n = $div64(y, new $Uint64(0, 100), false);
		y = (x$4 = $mul64(new $Uint64(0, 100), n), new $Uint64(y.$high - x$4.$high, y.$low - x$4.$low));
		d = (x$5 = $mul64(new $Uint64(0, 36524), n), new $Uint64(d.$high + x$5.$high, d.$low + x$5.$low));
		n = $div64(y, new $Uint64(0, 4), false);
		y = (x$6 = $mul64(new $Uint64(0, 4), n), new $Uint64(y.$high - x$6.$high, y.$low - x$6.$low));
		d = (x$7 = $mul64(new $Uint64(0, 1461), n), new $Uint64(d.$high + x$7.$high, d.$low + x$7.$low));
		n = y;
		d = (x$8 = $mul64(new $Uint64(0, 365), n), new $Uint64(d.$high + x$8.$high, d.$low + x$8.$low));
		d = (x$9 = (new $Uint64(0, (x$10 = month - 1 >> 0, ((x$10 < 0 || x$10 >= daysBefore.length) ? ($throwRuntimeError("index out of range"), undefined) : daysBefore[x$10])))), new $Uint64(d.$high + x$9.$high, d.$low + x$9.$low));
		if (isLeap(year) && month >= 3) {
			d = (x$11 = new $Uint64(0, 1), new $Uint64(d.$high + x$11.$high, d.$low + x$11.$low));
		}
		d = (x$12 = (new $Uint64(0, (day - 1 >> 0))), new $Uint64(d.$high + x$12.$high, d.$low + x$12.$low));
		abs = $mul64(d, new $Uint64(0, 86400));
		abs = (x$13 = (new $Uint64(0, ((($imul(hour, 3600)) + ($imul(min, 60)) >> 0) + sec >> 0))), new $Uint64(abs.$high + x$13.$high, abs.$low + x$13.$low));
		unix = (x$14 = (new $Int64(abs.$high, abs.$low)), new $Int64(x$14.$high + -2147483647, x$14.$low + 3844486912));
		_r = loc.lookup(unix); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$5 = _r;
		offset = _tuple$5[1];
		start = _tuple$5[2];
		end = _tuple$5[3];
		/* */ if (!((offset === 0))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((offset === 0))) { */ case 2:
				utc = (x$15 = (new $Int64(0, offset)), new $Int64(unix.$high - x$15.$high, unix.$low - x$15.$low));
				/* */ if ((utc.$high < start.$high || (utc.$high === start.$high && utc.$low < start.$low))) { $s = 5; continue; }
				/* */ if ((utc.$high > end.$high || (utc.$high === end.$high && utc.$low >= end.$low))) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if ((utc.$high < start.$high || (utc.$high === start.$high && utc.$low < start.$low))) { */ case 5:
					_r$1 = loc.lookup(new $Int64(start.$high - 0, start.$low - 1)); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_tuple$6 = _r$1;
					offset = _tuple$6[1];
					$s = 7; continue;
				/* } else if ((utc.$high > end.$high || (utc.$high === end.$high && utc.$low >= end.$low))) { */ case 6:
					_r$2 = loc.lookup(end); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_tuple$7 = _r$2;
					offset = _tuple$7[1];
				/* } */ case 7:
			case 4:
			unix = (x$16 = (new $Int64(0, offset)), new $Int64(unix.$high - x$16.$high, unix.$low - x$16.$low));
		/* } */ case 3:
		t = $clone(unixTime(unix, ((nsec >> 0))), Time);
		t.setLoc(loc);
		$s = -1; return t;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Date }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f.abs = abs; $f.d = d; $f.day = day; $f.end = end; $f.hour = hour; $f.loc = loc; $f.m = m; $f.min = min; $f.month = month; $f.n = n; $f.nsec = nsec; $f.offset = offset; $f.sec = sec; $f.start = start; $f.t = t; $f.unix = unix; $f.utc = utc; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$16 = x$16; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.y = y; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Date = Date;
	Time.ptr.prototype.Truncate = function(d) {
		var _tuple, d, r, t;
		t = this;
		t.stripMono();
		if ((d.$high < 0 || (d.$high === 0 && d.$low <= 0))) {
			return t;
		}
		_tuple = div($clone(t, Time), d);
		r = _tuple[1];
		return $clone(t, Time).Add(new Duration(-r.$high, -r.$low));
	};
	Time.prototype.Truncate = function(d) { return this.$val.Truncate(d); };
	Time.ptr.prototype.Round = function(d) {
		var _tuple, d, r, t;
		t = this;
		t.stripMono();
		if ((d.$high < 0 || (d.$high === 0 && d.$low <= 0))) {
			return t;
		}
		_tuple = div($clone(t, Time), d);
		r = _tuple[1];
		if (lessThanHalf(r, d)) {
			return $clone(t, Time).Add(new Duration(-r.$high, -r.$low));
		}
		return $clone(t, Time).Add(new Duration(d.$high - r.$high, d.$low - r.$low));
	};
	Time.prototype.Round = function(d) { return this.$val.Round(d); };
	div = function(t, d) {
		var _q, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, d, d0, d1, d1$1, neg, nsec, qmod2, r, sec, sec$1, t, tmp, u0, u0x, u1, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		qmod2 = 0;
		r = new Duration(0, 0);
		neg = false;
		nsec = t.nsec();
		sec = t.sec();
		if ((sec.$high < 0 || (sec.$high === 0 && sec.$low < 0))) {
			neg = true;
			sec = new $Int64(-sec.$high, -sec.$low);
			nsec = -nsec;
			if (nsec < 0) {
				nsec = nsec + (1000000000) >> 0;
				sec = (x$1 = new $Int64(0, 1), new $Int64(sec.$high - x$1.$high, sec.$low - x$1.$low));
			}
		}
		if ((d.$high < 0 || (d.$high === 0 && d.$low < 1000000000)) && (x$2 = $div64(new Duration(0, 1000000000), (new Duration(d.$high + d.$high, d.$low + d.$low)), true), (x$2.$high === 0 && x$2.$low === 0))) {
			qmod2 = (((_q = nsec / (((d.$low + ((d.$high >> 31) * 4294967296)) >> 0)), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)) & 1;
			r = (new Duration(0, (_r = nsec % (((d.$low + ((d.$high >> 31) * 4294967296)) >> 0)), _r === _r ? _r : $throwRuntimeError("integer divide by zero"))));
		} else if ((x$3 = $div64(d, new Duration(0, 1000000000), true), (x$3.$high === 0 && x$3.$low === 0))) {
			d1 = ((x$4 = $div64(d, new Duration(0, 1000000000), false), new $Int64(x$4.$high, x$4.$low)));
			qmod2 = (((x$5 = $div64(sec, d1, false), x$5.$low + ((x$5.$high >> 31) * 4294967296)) >> 0)) & 1;
			r = (x$6 = $mul64(((x$7 = $div64(sec, d1, true), new Duration(x$7.$high, x$7.$low))), new Duration(0, 1000000000)), x$8 = (new Duration(0, nsec)), new Duration(x$6.$high + x$8.$high, x$6.$low + x$8.$low));
		} else {
			sec$1 = (new $Uint64(sec.$high, sec.$low));
			tmp = $mul64(($shiftRightUint64(sec$1, 32)), new $Uint64(0, 1000000000));
			u1 = $shiftRightUint64(tmp, 32);
			u0 = $shiftLeft64(tmp, 32);
			tmp = $mul64((new $Uint64(sec$1.$high & 0, (sec$1.$low & 4294967295) >>> 0)), new $Uint64(0, 1000000000));
			_tmp = u0;
			_tmp$1 = new $Uint64(u0.$high + tmp.$high, u0.$low + tmp.$low);
			u0x = _tmp;
			u0 = _tmp$1;
			if ((u0.$high < u0x.$high || (u0.$high === u0x.$high && u0.$low < u0x.$low))) {
				u1 = (x$9 = new $Uint64(0, 1), new $Uint64(u1.$high + x$9.$high, u1.$low + x$9.$low));
			}
			_tmp$2 = u0;
			_tmp$3 = (x$10 = (new $Uint64(0, nsec)), new $Uint64(u0.$high + x$10.$high, u0.$low + x$10.$low));
			u0x = _tmp$2;
			u0 = _tmp$3;
			if ((u0.$high < u0x.$high || (u0.$high === u0x.$high && u0.$low < u0x.$low))) {
				u1 = (x$11 = new $Uint64(0, 1), new $Uint64(u1.$high + x$11.$high, u1.$low + x$11.$low));
			}
			d1$1 = (new $Uint64(d.$high, d.$low));
			while (true) {
				if (!(!((x$12 = $shiftRightUint64(d1$1, 63), (x$12.$high === 0 && x$12.$low === 1))))) { break; }
				d1$1 = $shiftLeft64(d1$1, (1));
			}
			d0 = new $Uint64(0, 0);
			while (true) {
				qmod2 = 0;
				if ((u1.$high > d1$1.$high || (u1.$high === d1$1.$high && u1.$low > d1$1.$low)) || (u1.$high === d1$1.$high && u1.$low === d1$1.$low) && (u0.$high > d0.$high || (u0.$high === d0.$high && u0.$low >= d0.$low))) {
					qmod2 = 1;
					_tmp$4 = u0;
					_tmp$5 = new $Uint64(u0.$high - d0.$high, u0.$low - d0.$low);
					u0x = _tmp$4;
					u0 = _tmp$5;
					if ((u0.$high > u0x.$high || (u0.$high === u0x.$high && u0.$low > u0x.$low))) {
						u1 = (x$13 = new $Uint64(0, 1), new $Uint64(u1.$high - x$13.$high, u1.$low - x$13.$low));
					}
					u1 = (x$14 = d1$1, new $Uint64(u1.$high - x$14.$high, u1.$low - x$14.$low));
				}
				if ((d1$1.$high === 0 && d1$1.$low === 0) && (x$15 = (new $Uint64(d.$high, d.$low)), (d0.$high === x$15.$high && d0.$low === x$15.$low))) {
					break;
				}
				d0 = $shiftRightUint64(d0, (1));
				d0 = (x$16 = $shiftLeft64((new $Uint64(d1$1.$high & 0, (d1$1.$low & 1) >>> 0)), 63), new $Uint64(d0.$high | x$16.$high, (d0.$low | x$16.$low) >>> 0));
				d1$1 = $shiftRightUint64(d1$1, (1));
			}
			r = (new Duration(u0.$high, u0.$low));
		}
		if (neg && !((r.$high === 0 && r.$low === 0))) {
			qmod2 = (qmod2 ^ (1)) >> 0;
			r = new Duration(d.$high - r.$high, d.$low - r.$low);
		}
		return [qmod2, r];
	};
	Location.ptr.prototype.get = function() {
		var l, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; l = $f.l; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		if (l === ptrType$2.nil) {
			$s = -1; return utcLoc;
		}
		/* */ if (l === localLoc) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (l === localLoc) { */ case 1:
			$r = localOnce.Do(initLocal); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		$s = -1; return l;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.get }; } $f.l = l; $f.$s = $s; $f.$r = $r; return $f;
	};
	Location.prototype.get = function() { return this.$val.get(); };
	Location.ptr.prototype.String = function() {
		var _r, l, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; l = $f.l; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = l.get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r.name;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.String }; } $f._r = _r; $f.l = l; $f.$s = $s; $f.$r = $r; return $f;
	};
	Location.prototype.String = function() { return this.$val.String(); };
	FixedZone = function(name, offset) {
		var l, name, offset, x$1;
		l = new Location.ptr(name, new sliceType([new zone.ptr(name, offset, false)]), new sliceType$1([new zoneTrans.ptr(new $Int64(-2147483648, 0), 0, false, false)]), new $Int64(-2147483648, 0), new $Int64(2147483647, 4294967295), ptrType.nil);
		l.cacheZone = (x$1 = l.zone, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0]));
		return l;
	};
	$pkg.FixedZone = FixedZone;
	Location.ptr.prototype.lookup = function(sec) {
		var _q, _r, end, hi, l, lim, lo, m, name, offset, sec, start, tx, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, zone$1, zone$2, zone$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; end = $f.end; hi = $f.hi; l = $f.l; lim = $f.lim; lo = $f.lo; m = $f.m; name = $f.name; offset = $f.offset; sec = $f.sec; start = $f.start; tx = $f.tx; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; zone$1 = $f.zone$1; zone$2 = $f.zone$2; zone$3 = $f.zone$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		name = "";
		offset = 0;
		start = new $Int64(0, 0);
		end = new $Int64(0, 0);
		l = this;
		_r = l.get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		l = _r;
		if (l.zone.$length === 0) {
			name = "UTC";
			offset = 0;
			start = new $Int64(-2147483648, 0);
			end = new $Int64(2147483647, 4294967295);
			$s = -1; return [name, offset, start, end];
		}
		zone$1 = l.cacheZone;
		if (!(zone$1 === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) {
			name = zone$1.name;
			offset = zone$1.offset;
			start = l.cacheStart;
			end = l.cacheEnd;
			$s = -1; return [name, offset, start, end];
		}
		if ((l.tx.$length === 0) || (x$3 = (x$4 = l.tx, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])).when, (sec.$high < x$3.$high || (sec.$high === x$3.$high && sec.$low < x$3.$low)))) {
			zone$2 = (x$5 = l.zone, x$6 = l.lookupFirstZone(), ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6]));
			name = zone$2.name;
			offset = zone$2.offset;
			start = new $Int64(-2147483648, 0);
			if (l.tx.$length > 0) {
				end = (x$7 = l.tx, (0 >= x$7.$length ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + 0])).when;
			} else {
				end = new $Int64(2147483647, 4294967295);
			}
			$s = -1; return [name, offset, start, end];
		}
		tx = l.tx;
		end = new $Int64(2147483647, 4294967295);
		lo = 0;
		hi = tx.$length;
		while (true) {
			if (!((hi - lo >> 0) > 1)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			lim = ((m < 0 || m >= tx.$length) ? ($throwRuntimeError("index out of range"), undefined) : tx.$array[tx.$offset + m]).when;
			if ((sec.$high < lim.$high || (sec.$high === lim.$high && sec.$low < lim.$low))) {
				end = lim;
				hi = m;
			} else {
				lo = m;
			}
		}
		zone$3 = (x$8 = l.zone, x$9 = ((lo < 0 || lo >= tx.$length) ? ($throwRuntimeError("index out of range"), undefined) : tx.$array[tx.$offset + lo]).index, ((x$9 < 0 || x$9 >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + x$9]));
		name = zone$3.name;
		offset = zone$3.offset;
		start = ((lo < 0 || lo >= tx.$length) ? ($throwRuntimeError("index out of range"), undefined) : tx.$array[tx.$offset + lo]).when;
		$s = -1; return [name, offset, start, end];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.lookup }; } $f._q = _q; $f._r = _r; $f.end = end; $f.hi = hi; $f.l = l; $f.lim = lim; $f.lo = lo; $f.m = m; $f.name = name; $f.offset = offset; $f.sec = sec; $f.start = start; $f.tx = tx; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.zone$1 = zone$1; $f.zone$2 = zone$2; $f.zone$3 = zone$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Location.prototype.lookup = function(sec) { return this.$val.lookup(sec); };
	Location.ptr.prototype.lookupFirstZone = function() {
		var _i, _ref, l, x$1, x$2, x$3, x$4, x$5, x$6, zi, zi$1;
		l = this;
		if (!l.firstZoneUsed()) {
			return 0;
		}
		if (l.tx.$length > 0 && (x$1 = l.zone, x$2 = (x$3 = l.tx, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])).index, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2])).isDST) {
			zi = (((x$4 = l.tx, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])).index >> 0)) - 1 >> 0;
			while (true) {
				if (!(zi >= 0)) { break; }
				if (!(x$5 = l.zone, ((zi < 0 || zi >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + zi])).isDST) {
					return zi;
				}
				zi = zi - (1) >> 0;
			}
		}
		_ref = l.zone;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			zi$1 = _i;
			if (!(x$6 = l.zone, ((zi$1 < 0 || zi$1 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + zi$1])).isDST) {
				return zi$1;
			}
			_i++;
		}
		return 0;
	};
	Location.prototype.lookupFirstZone = function() { return this.$val.lookupFirstZone(); };
	Location.ptr.prototype.firstZoneUsed = function() {
		var _i, _ref, l, tx;
		l = this;
		_ref = l.tx;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			tx = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), zoneTrans);
			if (tx.index === 0) {
				return true;
			}
			_i++;
		}
		return false;
	};
	Location.prototype.firstZoneUsed = function() { return this.$val.firstZoneUsed(); };
	Location.ptr.prototype.lookupName = function(name, unix) {
		var _i, _i$1, _r, _r$1, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, i, i$1, l, nam, name, offset, offset$1, ok, unix, x$1, x$2, x$3, zone$1, zone$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; i = $f.i; i$1 = $f.i$1; l = $f.l; nam = $f.nam; name = $f.name; offset = $f.offset; offset$1 = $f.offset$1; ok = $f.ok; unix = $f.unix; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; zone$1 = $f.zone$1; zone$2 = $f.zone$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		offset = 0;
		ok = false;
		l = this;
		_r = l.get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		l = _r;
		_ref = l.zone;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			i = _i;
			zone$1 = (x$1 = l.zone, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]));
			/* */ if (zone$1.name === name) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (zone$1.name === name) { */ case 4:
				_r$1 = l.lookup((x$2 = (new $Int64(0, zone$1.offset)), new $Int64(unix.$high - x$2.$high, unix.$low - x$2.$low))); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple = _r$1;
				nam = _tuple[0];
				offset$1 = _tuple[1];
				if (nam === zone$1.name) {
					_tmp = offset$1;
					_tmp$1 = true;
					offset = _tmp;
					ok = _tmp$1;
					$s = -1; return [offset, ok];
				}
			/* } */ case 5:
			_i++;
		/* } */ $s = 2; continue; case 3:
		_ref$1 = l.zone;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			zone$2 = (x$3 = l.zone, ((i$1 < 0 || i$1 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i$1]));
			if (zone$2.name === name) {
				_tmp$2 = zone$2.offset;
				_tmp$3 = true;
				offset = _tmp$2;
				ok = _tmp$3;
				$s = -1; return [offset, ok];
			}
			_i$1++;
		}
		$s = -1; return [offset, ok];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.lookupName }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.i = i; $f.i$1 = i$1; $f.l = l; $f.nam = nam; $f.name = name; $f.offset = offset; $f.offset$1 = offset$1; $f.ok = ok; $f.unix = unix; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.zone$1 = zone$1; $f.zone$2 = zone$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Location.prototype.lookupName = function(name, unix) { return this.$val.lookupName(name, unix); };
	ptrType$4.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	Time.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Format", name: "Format", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "AppendFormat", name: "AppendFormat", pkg: "", typ: $funcType([sliceType$3, $String], [sliceType$3], false)}, {prop: "After", name: "After", pkg: "", typ: $funcType([Time], [$Bool], false)}, {prop: "Before", name: "Before", pkg: "", typ: $funcType([Time], [$Bool], false)}, {prop: "Equal", name: "Equal", pkg: "", typ: $funcType([Time], [$Bool], false)}, {prop: "IsZero", name: "IsZero", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "abs", name: "abs", pkg: "time", typ: $funcType([], [$Uint64], false)}, {prop: "locabs", name: "locabs", pkg: "time", typ: $funcType([], [$String, $Int, $Uint64], false)}, {prop: "Date", name: "Date", pkg: "", typ: $funcType([], [$Int, Month, $Int], false)}, {prop: "Year", name: "Year", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Month", name: "Month", pkg: "", typ: $funcType([], [Month], false)}, {prop: "Day", name: "Day", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Weekday", name: "Weekday", pkg: "", typ: $funcType([], [Weekday], false)}, {prop: "ISOWeek", name: "ISOWeek", pkg: "", typ: $funcType([], [$Int, $Int], false)}, {prop: "Clock", name: "Clock", pkg: "", typ: $funcType([], [$Int, $Int, $Int], false)}, {prop: "Hour", name: "Hour", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Minute", name: "Minute", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Second", name: "Second", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Nanosecond", name: "Nanosecond", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "YearDay", name: "YearDay", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Add", name: "Add", pkg: "", typ: $funcType([Duration], [Time], false)}, {prop: "Sub", name: "Sub", pkg: "", typ: $funcType([Time], [Duration], false)}, {prop: "AddDate", name: "AddDate", pkg: "", typ: $funcType([$Int, $Int, $Int], [Time], false)}, {prop: "date", name: "date", pkg: "time", typ: $funcType([$Bool], [$Int, Month, $Int, $Int], false)}, {prop: "UTC", name: "UTC", pkg: "", typ: $funcType([], [Time], false)}, {prop: "Local", name: "Local", pkg: "", typ: $funcType([], [Time], false)}, {prop: "In", name: "In", pkg: "", typ: $funcType([ptrType$2], [Time], false)}, {prop: "Location", name: "Location", pkg: "", typ: $funcType([], [ptrType$2], false)}, {prop: "Zone", name: "Zone", pkg: "", typ: $funcType([], [$String, $Int], false)}, {prop: "Unix", name: "Unix", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "UnixNano", name: "UnixNano", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "MarshalBinary", name: "MarshalBinary", pkg: "", typ: $funcType([], [sliceType$3, $error], false)}, {prop: "GobEncode", name: "GobEncode", pkg: "", typ: $funcType([], [sliceType$3, $error], false)}, {prop: "MarshalJSON", name: "MarshalJSON", pkg: "", typ: $funcType([], [sliceType$3, $error], false)}, {prop: "MarshalText", name: "MarshalText", pkg: "", typ: $funcType([], [sliceType$3, $error], false)}, {prop: "Truncate", name: "Truncate", pkg: "", typ: $funcType([Duration], [Time], false)}, {prop: "Round", name: "Round", pkg: "", typ: $funcType([Duration], [Time], false)}];
	ptrType$7.methods = [{prop: "nsec", name: "nsec", pkg: "time", typ: $funcType([], [$Int32], false)}, {prop: "sec", name: "sec", pkg: "time", typ: $funcType([], [$Int64], false)}, {prop: "unixSec", name: "unixSec", pkg: "time", typ: $funcType([], [$Int64], false)}, {prop: "addSec", name: "addSec", pkg: "time", typ: $funcType([$Int64], [], false)}, {prop: "setLoc", name: "setLoc", pkg: "time", typ: $funcType([ptrType$2], [], false)}, {prop: "stripMono", name: "stripMono", pkg: "time", typ: $funcType([], [], false)}, {prop: "setMono", name: "setMono", pkg: "time", typ: $funcType([$Int64], [], false)}, {prop: "mono", name: "mono", pkg: "time", typ: $funcType([], [$Int64], false)}, {prop: "UnmarshalBinary", name: "UnmarshalBinary", pkg: "", typ: $funcType([sliceType$3], [$error], false)}, {prop: "GobDecode", name: "GobDecode", pkg: "", typ: $funcType([sliceType$3], [$error], false)}, {prop: "UnmarshalJSON", name: "UnmarshalJSON", pkg: "", typ: $funcType([sliceType$3], [$error], false)}, {prop: "UnmarshalText", name: "UnmarshalText", pkg: "", typ: $funcType([sliceType$3], [$error], false)}];
	Month.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	Weekday.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	Duration.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Nanoseconds", name: "Nanoseconds", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Seconds", name: "Seconds", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Minutes", name: "Minutes", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Hours", name: "Hours", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Truncate", name: "Truncate", pkg: "", typ: $funcType([Duration], [Duration], false)}, {prop: "Round", name: "Round", pkg: "", typ: $funcType([Duration], [Duration], false)}];
	ptrType$2.methods = [{prop: "get", name: "get", pkg: "time", typ: $funcType([], [ptrType$2], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "lookup", name: "lookup", pkg: "time", typ: $funcType([$Int64], [$String, $Int, $Int64, $Int64], false)}, {prop: "lookupFirstZone", name: "lookupFirstZone", pkg: "time", typ: $funcType([], [$Int], false)}, {prop: "firstZoneUsed", name: "firstZoneUsed", pkg: "time", typ: $funcType([], [$Bool], false)}, {prop: "lookupName", name: "lookupName", pkg: "time", typ: $funcType([$String, $Int64], [$Int, $Bool], false)}];
	ParseError.init("", [{prop: "Layout", name: "Layout", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Value", name: "Value", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "LayoutElem", name: "LayoutElem", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "ValueElem", name: "ValueElem", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Message", name: "Message", embedded: false, exported: true, typ: $String, tag: ""}]);
	Time.init("time", [{prop: "wall", name: "wall", embedded: false, exported: false, typ: $Uint64, tag: ""}, {prop: "ext", name: "ext", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "loc", name: "loc", embedded: false, exported: false, typ: ptrType$2, tag: ""}]);
	Location.init("time", [{prop: "name", name: "name", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "zone", name: "zone", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "tx", name: "tx", embedded: false, exported: false, typ: sliceType$1, tag: ""}, {prop: "cacheStart", name: "cacheStart", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "cacheEnd", name: "cacheEnd", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "cacheZone", name: "cacheZone", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	zone.init("time", [{prop: "name", name: "name", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "offset", name: "offset", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "isDST", name: "isDST", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	zoneTrans.init("time", [{prop: "when", name: "when", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "index", name: "index", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "isstd", name: "isstd", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "isutc", name: "isutc", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = nosync.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = syscall.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		localLoc = new Location.ptr("", sliceType.nil, sliceType$1.nil, new $Int64(0, 0), new $Int64(0, 0), ptrType.nil);
		localOnce = new nosync.Once.ptr(false, false);
		zoneSources = new sliceType$2([runtime.GOROOT() + "/lib/time/zoneinfo.zip"]);
		std0x = $toNativeArray($kindInt, [260, 265, 524, 526, 528, 274]);
		longDayNames = new sliceType$2(["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]);
		shortDayNames = new sliceType$2(["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]);
		shortMonthNames = new sliceType$2(["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]);
		longMonthNames = new sliceType$2(["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]);
		atoiError = errors.New("time: invalid number");
		errBad = errors.New("bad value for field");
		errLeadingInt = errors.New("time: bad [0-9]*");
		months = $toNativeArray($kindString, ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]);
		days = $toNativeArray($kindString, ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]);
		daysBefore = $toNativeArray($kindInt32, [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]);
		startNano = (x = runtimeNano(), new $Int64(x.$high - 0, x.$low - 1));
		utcLoc = new Location.ptr("UTC", sliceType.nil, sliceType$1.nil, new $Int64(0, 0), new $Int64(0, 0), ptrType.nil);
		$pkg.UTC = utcLoc;
		$pkg.Local = localLoc;
		errLocation = errors.New("time: invalid location name");
		badData = errors.New("malformed time zone information");
		$unused(new sliceType$2(["/usr/share/zoneinfo/", "/usr/share/lib/zoneinfo/", "/usr/lib/locale/TZ/", runtime.GOROOT() + "/lib/time/zoneinfo.zip"]));
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/poll"] = (function() {
	var $pkg = {}, $init, errors, io, runtime, atomic, syscall, time, pollDesc, TimeoutError, fdMutex, FD, ptrType, chanType, sliceType, ptrType$1, ptrType$2, arrayType, sliceType$2, ptrType$6, ptrType$7, ptrType$8, ptrType$9, ptrType$10, ptrType$11, sliceType$3, ptrType$12, funcType, funcType$1, ptrType$13, ptrType$14, ptrType$15, ptrType$16, sliceType$4, ptrType$17, semWaiters, tryDupCloexec, tryDupCloexec$24ptr, runtime_Semacquire, runtime_Semrelease, errClosing, consume, fcntl, DupCloseOnExec, dupCloseOnExecOld, writev, accept;
	errors = $packages["errors"];
	io = $packages["io"];
	runtime = $packages["runtime"];
	atomic = $packages["sync/atomic"];
	syscall = $packages["syscall"];
	time = $packages["time"];
	pollDesc = $pkg.pollDesc = $newType(0, $kindStruct, "poll.pollDesc", true, "internal/poll", false, function(closing_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.closing = false;
			return;
		}
		this.closing = closing_;
	});
	TimeoutError = $pkg.TimeoutError = $newType(0, $kindStruct, "poll.TimeoutError", true, "internal/poll", true, function() {
		this.$val = this;
		if (arguments.length === 0) {
			return;
		}
	});
	fdMutex = $pkg.fdMutex = $newType(0, $kindStruct, "poll.fdMutex", true, "internal/poll", false, function(state_, rsema_, wsema_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.state = new $Uint64(0, 0);
			this.rsema = 0;
			this.wsema = 0;
			return;
		}
		this.state = state_;
		this.rsema = rsema_;
		this.wsema = wsema_;
	});
	FD = $pkg.FD = $newType(0, $kindStruct, "poll.FD", true, "internal/poll", true, function(fdmu_, Sysfd_, pd_, iovecs_, csema_, isBlocking_, IsStream_, ZeroReadIsEOF_, isFile_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.fdmu = new fdMutex.ptr(new $Uint64(0, 0), 0, 0);
			this.Sysfd = 0;
			this.pd = new pollDesc.ptr(false);
			this.iovecs = ptrType$6.nil;
			this.csema = 0;
			this.isBlocking = 0;
			this.IsStream = false;
			this.ZeroReadIsEOF = false;
			this.isFile = false;
			return;
		}
		this.fdmu = fdmu_;
		this.Sysfd = Sysfd_;
		this.pd = pd_;
		this.iovecs = iovecs_;
		this.csema = csema_;
		this.isBlocking = isBlocking_;
		this.IsStream = IsStream_;
		this.ZeroReadIsEOF = ZeroReadIsEOF_;
		this.isFile = isFile_;
	});
	ptrType = $ptrType($Uint32);
	chanType = $chanType($Bool, false, false);
	sliceType = $sliceType(chanType);
	ptrType$1 = $ptrType($Uint64);
	ptrType$2 = $ptrType($Int32);
	arrayType = $arrayType($Uint8, 4);
	sliceType$2 = $sliceType(syscall.Iovec);
	ptrType$6 = $ptrType(sliceType$2);
	ptrType$7 = $ptrType($Uint8);
	ptrType$8 = $ptrType(FD);
	ptrType$9 = $ptrType(pollDesc);
	ptrType$10 = $ptrType(TimeoutError);
	ptrType$11 = $ptrType(fdMutex);
	sliceType$3 = $sliceType($Uint8);
	ptrType$12 = $ptrType(syscall.Stat_t);
	funcType = $funcType([$Uintptr], [], false);
	funcType$1 = $funcType([$Uintptr], [$Bool], false);
	ptrType$13 = $ptrType(syscall.Linger);
	ptrType$14 = $ptrType(syscall.IPMreqn);
	ptrType$15 = $ptrType(syscall.IPMreq);
	ptrType$16 = $ptrType(syscall.IPv6Mreq);
	sliceType$4 = $sliceType(sliceType$3);
	ptrType$17 = $ptrType(sliceType$4);
	pollDesc.ptr.prototype.init = function(fd) {
		var fd, pd;
		pd = this;
		return $ifaceNil;
	};
	pollDesc.prototype.init = function(fd) { return this.$val.init(fd); };
	pollDesc.ptr.prototype.close = function() {
		var pd;
		pd = this;
	};
	pollDesc.prototype.close = function() { return this.$val.close(); };
	pollDesc.ptr.prototype.evict = function() {
		var pd;
		pd = this;
		pd.closing = true;
	};
	pollDesc.prototype.evict = function() { return this.$val.evict(); };
	pollDesc.ptr.prototype.prepare = function(mode, isFile) {
		var isFile, mode, pd;
		pd = this;
		if (pd.closing) {
			return errClosing(isFile);
		}
		return $ifaceNil;
	};
	pollDesc.prototype.prepare = function(mode, isFile) { return this.$val.prepare(mode, isFile); };
	pollDesc.ptr.prototype.prepareRead = function(isFile) {
		var isFile, pd;
		pd = this;
		return pd.prepare(114, isFile);
	};
	pollDesc.prototype.prepareRead = function(isFile) { return this.$val.prepareRead(isFile); };
	pollDesc.ptr.prototype.prepareWrite = function(isFile) {
		var isFile, pd;
		pd = this;
		return pd.prepare(119, isFile);
	};
	pollDesc.prototype.prepareWrite = function(isFile) { return this.$val.prepareWrite(isFile); };
	pollDesc.ptr.prototype.wait = function(mode, isFile) {
		var isFile, mode, pd;
		pd = this;
		if (pd.closing) {
			return errClosing(isFile);
		}
		return $pkg.ErrTimeout;
	};
	pollDesc.prototype.wait = function(mode, isFile) { return this.$val.wait(mode, isFile); };
	pollDesc.ptr.prototype.waitRead = function(isFile) {
		var isFile, pd;
		pd = this;
		return pd.wait(114, isFile);
	};
	pollDesc.prototype.waitRead = function(isFile) { return this.$val.waitRead(isFile); };
	pollDesc.ptr.prototype.waitWrite = function(isFile) {
		var isFile, pd;
		pd = this;
		return pd.wait(119, isFile);
	};
	pollDesc.prototype.waitWrite = function(isFile) { return this.$val.waitWrite(isFile); };
	pollDesc.ptr.prototype.pollable = function() {
		return true;
	};
	pollDesc.prototype.pollable = function() { return this.$val.pollable(); };
	FD.ptr.prototype.SetDeadline = function(t) {
		var t;
		return $ifaceNil;
	};
	FD.prototype.SetDeadline = function(t) { return this.$val.SetDeadline(t); };
	FD.ptr.prototype.SetReadDeadline = function(t) {
		var t;
		return $ifaceNil;
	};
	FD.prototype.SetReadDeadline = function(t) { return this.$val.SetReadDeadline(t); };
	FD.ptr.prototype.SetWriteDeadline = function(t) {
		var t;
		return $ifaceNil;
	};
	FD.prototype.SetWriteDeadline = function(t) { return this.$val.SetWriteDeadline(t); };
	runtime_Semacquire = function(s) {
		var _entry, _key, _r, ch, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _key = $f._key; _r = $f._r; ch = $f.ch; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if (s.$get() === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (s.$get() === 0) { */ case 1:
			ch = new $Chan($Bool, 0);
			_key = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType.keyFor(_key)] = { k: _key, v: $append((_entry = semWaiters[ptrType.keyFor(s)], _entry !== undefined ? _entry.v : sliceType.nil), ch) };
			_r = $recv(ch); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r[0];
		/* } */ case 2:
		s.$set(s.$get() - (1) >>> 0);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_Semacquire }; } $f._entry = _entry; $f._key = _key; $f._r = _r; $f.ch = ch; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	runtime_Semrelease = function(s) {
		var _entry, _key, ch, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _key = $f._key; ch = $f.ch; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s.$set(s.$get() + (1) >>> 0);
		w = (_entry = semWaiters[ptrType.keyFor(s)], _entry !== undefined ? _entry.v : sliceType.nil);
		if (w.$length === 0) {
			$s = -1; return;
		}
		ch = (0 >= w.$length ? ($throwRuntimeError("index out of range"), undefined) : w.$array[w.$offset + 0]);
		w = $subslice(w, 1);
		_key = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType.keyFor(_key)] = { k: _key, v: w };
		if (w.$length === 0) {
			delete semWaiters[ptrType.keyFor(s)];
		}
		$r = $send(ch, true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_Semrelease }; } $f._entry = _entry; $f._key = _key; $f.ch = ch; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	errClosing = function(isFile) {
		var isFile;
		if (isFile) {
			return $pkg.ErrFileClosing;
		}
		return $pkg.ErrNetClosing;
	};
	TimeoutError.ptr.prototype.Error = function() {
		var e;
		e = this;
		return "i/o timeout";
	};
	TimeoutError.prototype.Error = function() { return this.$val.Error(); };
	TimeoutError.ptr.prototype.Timeout = function() {
		var e;
		e = this;
		return true;
	};
	TimeoutError.prototype.Timeout = function() { return this.$val.Timeout(); };
	TimeoutError.ptr.prototype.Temporary = function() {
		var e;
		e = this;
		return true;
	};
	TimeoutError.prototype.Temporary = function() { return this.$val.Temporary(); };
	consume = function(v, n) {
		var ln0, n, v, x, x$1, x$2, x$3;
		while (true) {
			if (!(v.$get().$length > 0)) { break; }
			ln0 = (new $Int64(0, (x = v.$get(), (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])).$length));
			if ((ln0.$high > n.$high || (ln0.$high === n.$high && ln0.$low > n.$low))) {
				(x$2 = v.$get(), (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0] = $subslice((x$1 = v.$get(), (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])), $flatten64(n))));
				return;
			}
			n = (x$3 = ln0, new $Int64(n.$high - x$3.$high, n.$low - x$3.$low));
			v.$set($subslice((v.$get()), 1));
		}
	};
	FD.ptr.prototype.Fsync = function() {
		var err, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Fsync(fd.Sysfd);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Fsync }; } $f.err = err; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Fsync = function() { return this.$val.Fsync(); };
	fcntl = function(fd, cmd, arg) {
		var _tuple, arg, cmd, e, fd, r;
		_tuple = syscall.Syscall(72, ((fd >>> 0)), ((cmd >>> 0)), ((arg >>> 0)));
		r = _tuple[0];
		e = _tuple[2];
		if (!((e === 0))) {
			return [((r >> 0)), new syscall.Errno((e))];
		}
		return [((r >> 0)), $ifaceNil];
	};
	fdMutex.ptr.prototype.incref = function() {
		var mu, new$1, old, x, x$1;
		mu = this;
		while (true) {
			old = atomic.LoadUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))));
			if (!((x = new $Uint64(old.$high & 0, (old.$low & 1) >>> 0), (x.$high === 0 && x.$low === 0)))) {
				return false;
			}
			new$1 = new $Uint64(old.$high + 0, old.$low + 8);
			if ((x$1 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388600) >>> 0), (x$1.$high === 0 && x$1.$low === 0))) {
				$panic(new $String("too many concurrent operations on a single file or socket (max 1048575)"));
			}
			if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) {
				return true;
			}
		}
	};
	fdMutex.prototype.incref = function() { return this.$val.incref(); };
	fdMutex.ptr.prototype.increfAndClose = function() {
		var mu, new$1, old, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; mu = $f.mu; new$1 = $f.new$1; old = $f.old; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		mu = this;
		/* while (true) { */ case 1:
			old = atomic.LoadUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))));
			if (!((x = new $Uint64(old.$high & 0, (old.$low & 1) >>> 0), (x.$high === 0 && x.$low === 0)))) {
				$s = -1; return false;
			}
			new$1 = (x$1 = new $Uint64(old.$high | 0, (old.$low | 1) >>> 0), new $Uint64(x$1.$high + 0, x$1.$low + 8));
			if ((x$2 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388600) >>> 0), (x$2.$high === 0 && x$2.$low === 0))) {
				$panic(new $String("too many concurrent operations on a single file or socket (max 1048575)"));
			}
			new$1 = (x$3 = new $Uint64(2147483647, 4286578688), new $Uint64(new$1.$high & ~x$3.$high, (new$1.$low & ~x$3.$low) >>> 0));
			/* */ if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) { */ case 3:
				/* while (true) { */ case 5:
					/* if (!(!((x$4 = new $Uint64(old.$high & 2047, (old.$low & 4286578688) >>> 0), (x$4.$high === 0 && x$4.$low === 0))))) { break; } */ if(!(!((x$4 = new $Uint64(old.$high & 2047, (old.$low & 4286578688) >>> 0), (x$4.$high === 0 && x$4.$low === 0))))) { $s = 6; continue; }
					old = (x$5 = new $Uint64(0, 8388608), new $Uint64(old.$high - x$5.$high, old.$low - x$5.$low));
					$r = runtime_Semrelease((mu.$ptr_rsema || (mu.$ptr_rsema = new ptrType(function() { return this.$target.rsema; }, function($v) { this.$target.rsema = $v; }, mu)))); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ $s = 5; continue; case 6:
				/* while (true) { */ case 8:
					/* if (!(!((x$6 = new $Uint64(old.$high & 2147481600, (old.$low & 0) >>> 0), (x$6.$high === 0 && x$6.$low === 0))))) { break; } */ if(!(!((x$6 = new $Uint64(old.$high & 2147481600, (old.$low & 0) >>> 0), (x$6.$high === 0 && x$6.$low === 0))))) { $s = 9; continue; }
					old = (x$7 = new $Uint64(2048, 0), new $Uint64(old.$high - x$7.$high, old.$low - x$7.$low));
					$r = runtime_Semrelease((mu.$ptr_wsema || (mu.$ptr_wsema = new ptrType(function() { return this.$target.wsema; }, function($v) { this.$target.wsema = $v; }, mu)))); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ $s = 8; continue; case 9:
				$s = -1; return true;
			/* } */ case 4:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: fdMutex.ptr.prototype.increfAndClose }; } $f.mu = mu; $f.new$1 = new$1; $f.old = old; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.$s = $s; $f.$r = $r; return $f;
	};
	fdMutex.prototype.increfAndClose = function() { return this.$val.increfAndClose(); };
	fdMutex.ptr.prototype.decref = function() {
		var mu, new$1, old, x, x$1;
		mu = this;
		while (true) {
			old = atomic.LoadUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))));
			if ((x = new $Uint64(old.$high & 0, (old.$low & 8388600) >>> 0), (x.$high === 0 && x.$low === 0))) {
				$panic(new $String("inconsistent poll.fdMutex"));
			}
			new$1 = new $Uint64(old.$high - 0, old.$low - 8);
			if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) {
				return (x$1 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388601) >>> 0), (x$1.$high === 0 && x$1.$low === 1));
			}
		}
	};
	fdMutex.prototype.decref = function() { return this.$val.decref(); };
	fdMutex.ptr.prototype.rwlock = function(read) {
		var _tmp, _tmp$1, _tmp$2, mu, mutexBit, mutexMask, mutexSema, mutexWait, new$1, old, read, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; mu = $f.mu; mutexBit = $f.mutexBit; mutexMask = $f.mutexMask; mutexSema = $f.mutexSema; mutexWait = $f.mutexWait; new$1 = $f.new$1; old = $f.old; read = $f.read; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		mu = this;
		_tmp = new $Uint64(0, 0);
		_tmp$1 = new $Uint64(0, 0);
		_tmp$2 = new $Uint64(0, 0);
		mutexBit = _tmp;
		mutexWait = _tmp$1;
		mutexMask = _tmp$2;
		mutexSema = ptrType.nil;
		if (read) {
			mutexBit = new $Uint64(0, 2);
			mutexWait = new $Uint64(0, 8388608);
			mutexMask = new $Uint64(2047, 4286578688);
			mutexSema = (mu.$ptr_rsema || (mu.$ptr_rsema = new ptrType(function() { return this.$target.rsema; }, function($v) { this.$target.rsema = $v; }, mu)));
		} else {
			mutexBit = new $Uint64(0, 4);
			mutexWait = new $Uint64(2048, 0);
			mutexMask = new $Uint64(2147481600, 0);
			mutexSema = (mu.$ptr_wsema || (mu.$ptr_wsema = new ptrType(function() { return this.$target.wsema; }, function($v) { this.$target.wsema = $v; }, mu)));
		}
		/* while (true) { */ case 1:
			old = atomic.LoadUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))));
			if (!((x = new $Uint64(old.$high & 0, (old.$low & 1) >>> 0), (x.$high === 0 && x.$low === 0)))) {
				$s = -1; return false;
			}
			new$1 = new $Uint64(0, 0);
			if ((x$1 = new $Uint64(old.$high & mutexBit.$high, (old.$low & mutexBit.$low) >>> 0), (x$1.$high === 0 && x$1.$low === 0))) {
				new$1 = (x$2 = new $Uint64(old.$high | mutexBit.$high, (old.$low | mutexBit.$low) >>> 0), new $Uint64(x$2.$high + 0, x$2.$low + 8));
				if ((x$3 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388600) >>> 0), (x$3.$high === 0 && x$3.$low === 0))) {
					$panic(new $String("too many concurrent operations on a single file or socket (max 1048575)"));
				}
			} else {
				new$1 = new $Uint64(old.$high + mutexWait.$high, old.$low + mutexWait.$low);
				if ((x$4 = new $Uint64(new$1.$high & mutexMask.$high, (new$1.$low & mutexMask.$low) >>> 0), (x$4.$high === 0 && x$4.$low === 0))) {
					$panic(new $String("too many concurrent operations on a single file or socket (max 1048575)"));
				}
			}
			/* */ if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) { */ case 3:
				if ((x$5 = new $Uint64(old.$high & mutexBit.$high, (old.$low & mutexBit.$low) >>> 0), (x$5.$high === 0 && x$5.$low === 0))) {
					$s = -1; return true;
				}
				$r = runtime_Semacquire(mutexSema); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 4:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: fdMutex.ptr.prototype.rwlock }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f.mu = mu; $f.mutexBit = mutexBit; $f.mutexMask = mutexMask; $f.mutexSema = mutexSema; $f.mutexWait = mutexWait; $f.new$1 = new$1; $f.old = old; $f.read = read; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	fdMutex.prototype.rwlock = function(read) { return this.$val.rwlock(read); };
	fdMutex.ptr.prototype.rwunlock = function(read) {
		var _tmp, _tmp$1, _tmp$2, mu, mutexBit, mutexMask, mutexSema, mutexWait, new$1, old, read, x, x$1, x$2, x$3, x$4, x$5, x$6, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; mu = $f.mu; mutexBit = $f.mutexBit; mutexMask = $f.mutexMask; mutexSema = $f.mutexSema; mutexWait = $f.mutexWait; new$1 = $f.new$1; old = $f.old; read = $f.read; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		mu = this;
		_tmp = new $Uint64(0, 0);
		_tmp$1 = new $Uint64(0, 0);
		_tmp$2 = new $Uint64(0, 0);
		mutexBit = _tmp;
		mutexWait = _tmp$1;
		mutexMask = _tmp$2;
		mutexSema = ptrType.nil;
		if (read) {
			mutexBit = new $Uint64(0, 2);
			mutexWait = new $Uint64(0, 8388608);
			mutexMask = new $Uint64(2047, 4286578688);
			mutexSema = (mu.$ptr_rsema || (mu.$ptr_rsema = new ptrType(function() { return this.$target.rsema; }, function($v) { this.$target.rsema = $v; }, mu)));
		} else {
			mutexBit = new $Uint64(0, 4);
			mutexWait = new $Uint64(2048, 0);
			mutexMask = new $Uint64(2147481600, 0);
			mutexSema = (mu.$ptr_wsema || (mu.$ptr_wsema = new ptrType(function() { return this.$target.wsema; }, function($v) { this.$target.wsema = $v; }, mu)));
		}
		/* while (true) { */ case 1:
			old = atomic.LoadUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))));
			if ((x = new $Uint64(old.$high & mutexBit.$high, (old.$low & mutexBit.$low) >>> 0), (x.$high === 0 && x.$low === 0)) || (x$1 = new $Uint64(old.$high & 0, (old.$low & 8388600) >>> 0), (x$1.$high === 0 && x$1.$low === 0))) {
				$panic(new $String("inconsistent poll.fdMutex"));
			}
			new$1 = (x$2 = new $Uint64(old.$high & ~mutexBit.$high, (old.$low & ~mutexBit.$low) >>> 0), new $Uint64(x$2.$high - 0, x$2.$low - 8));
			if (!((x$3 = new $Uint64(old.$high & mutexMask.$high, (old.$low & mutexMask.$low) >>> 0), (x$3.$high === 0 && x$3.$low === 0)))) {
				new$1 = (x$4 = mutexWait, new $Uint64(new$1.$high - x$4.$high, new$1.$low - x$4.$low));
			}
			/* */ if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (atomic.CompareAndSwapUint64((mu.$ptr_state || (mu.$ptr_state = new ptrType$1(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, mu))), old, new$1)) { */ case 3:
				/* */ if (!((x$5 = new $Uint64(old.$high & mutexMask.$high, (old.$low & mutexMask.$low) >>> 0), (x$5.$high === 0 && x$5.$low === 0)))) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (!((x$5 = new $Uint64(old.$high & mutexMask.$high, (old.$low & mutexMask.$low) >>> 0), (x$5.$high === 0 && x$5.$low === 0)))) { */ case 5:
					$r = runtime_Semrelease(mutexSema); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 6:
				$s = -1; return (x$6 = new $Uint64(new$1.$high & 0, (new$1.$low & 8388601) >>> 0), (x$6.$high === 0 && x$6.$low === 1));
			/* } */ case 4:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: fdMutex.ptr.prototype.rwunlock }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f.mu = mu; $f.mutexBit = mutexBit; $f.mutexMask = mutexMask; $f.mutexSema = mutexSema; $f.mutexWait = mutexWait; $f.new$1 = new$1; $f.old = old; $f.read = read; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.$s = $s; $f.$r = $r; return $f;
	};
	fdMutex.prototype.rwunlock = function(read) { return this.$val.rwunlock(read); };
	FD.ptr.prototype.incref = function() {
		var fd;
		fd = this;
		if (!fd.fdmu.incref()) {
			return errClosing(fd.isFile);
		}
		return $ifaceNil;
	};
	FD.prototype.incref = function() { return this.$val.incref(); };
	FD.ptr.prototype.decref = function() {
		var _r, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		/* */ if (fd.fdmu.decref()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (fd.fdmu.decref()) { */ case 1:
			_r = fd.destroy(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.decref }; } $f._r = _r; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.decref = function() { return this.$val.decref(); };
	FD.ptr.prototype.readLock = function() {
		var _r, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		_r = fd.fdmu.rwlock(true); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!_r) { */ case 1:
			$s = -1; return errClosing(fd.isFile);
		/* } */ case 2:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.readLock }; } $f._r = _r; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.readLock = function() { return this.$val.readLock(); };
	FD.ptr.prototype.readUnlock = function() {
		var _r, _r$1, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		_r = fd.fdmu.rwunlock(true); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r) { */ case 1:
			_r$1 = fd.destroy(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$1;
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.readUnlock }; } $f._r = _r; $f._r$1 = _r$1; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.readUnlock = function() { return this.$val.readUnlock(); };
	FD.ptr.prototype.writeLock = function() {
		var _r, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		_r = fd.fdmu.rwlock(false); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!_r) { */ case 1:
			$s = -1; return errClosing(fd.isFile);
		/* } */ case 2:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.writeLock }; } $f._r = _r; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.writeLock = function() { return this.$val.writeLock(); };
	FD.ptr.prototype.writeUnlock = function() {
		var _r, _r$1, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		_r = fd.fdmu.rwunlock(false); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r) { */ case 1:
			_r$1 = fd.destroy(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$1;
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.writeUnlock }; } $f._r = _r; $f._r$1 = _r$1; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.writeUnlock = function() { return this.$val.writeUnlock(); };
	FD.ptr.prototype.eofError = function(n, err) {
		var err, fd, n;
		fd = this;
		if ((n === 0) && $interfaceIsEqual(err, $ifaceNil) && fd.ZeroReadIsEOF) {
			return io.EOF;
		}
		return err;
	};
	FD.prototype.eofError = function(n, err) { return this.$val.eofError(n, err); };
	FD.ptr.prototype.Fchmod = function(mode) {
		var err, fd, mode, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; mode = $f.mode; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Fchmod(fd.Sysfd, mode);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Fchmod }; } $f.err = err; $f.fd = fd; $f.mode = mode; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Fchmod = function(mode) { return this.$val.Fchmod(mode); };
	FD.ptr.prototype.Fchown = function(uid, gid) {
		var err, fd, gid, uid, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; gid = $f.gid; uid = $f.uid; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Fchown(fd.Sysfd, uid, gid);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Fchown }; } $f.err = err; $f.fd = fd; $f.gid = gid; $f.uid = uid; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Fchown = function(uid, gid) { return this.$val.Fchown(uid, gid); };
	FD.ptr.prototype.Ftruncate = function(size) {
		var err, fd, size, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; size = $f.size; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Ftruncate(fd.Sysfd, size);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Ftruncate }; } $f.err = err; $f.fd = fd; $f.size = size; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Ftruncate = function(size) { return this.$val.Ftruncate(size); };
	FD.ptr.prototype.Init = function(net, pollable) {
		var err, fd, net, pollable;
		fd = this;
		if (net === "file") {
			fd.isFile = true;
		}
		if (!pollable) {
			fd.isBlocking = 1;
			return $ifaceNil;
		}
		err = fd.pd.init(fd);
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			fd.isBlocking = 1;
		}
		return err;
	};
	FD.prototype.Init = function(net, pollable) { return this.$val.Init(net, pollable); };
	FD.ptr.prototype.destroy = function() {
		var _r, err, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		fd.pd.close();
		_r = $pkg.CloseFunc(fd.Sysfd); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		fd.Sysfd = -1;
		$r = runtime_Semrelease((fd.$ptr_csema || (fd.$ptr_csema = new ptrType(function() { return this.$target.csema; }, function($v) { this.$target.csema = $v; }, fd)))); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.destroy }; } $f._r = _r; $f.err = err; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.destroy = function() { return this.$val.destroy(); };
	FD.ptr.prototype.Close = function() {
		var _r, _r$1, err, fd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; err = $f.err; fd = $f.fd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		_r = fd.fdmu.increfAndClose(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!_r) { */ case 1:
			$s = -1; return errClosing(fd.isFile);
		/* } */ case 2:
		fd.pd.evict();
		_r$1 = fd.decref(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err = _r$1;
		/* */ if (fd.isBlocking === 0) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (fd.isBlocking === 0) { */ case 5:
			$r = runtime_Semacquire((fd.$ptr_csema || (fd.$ptr_csema = new ptrType(function() { return this.$target.csema; }, function($v) { this.$target.csema = $v; }, fd)))); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 6:
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Close }; } $f._r = _r; $f._r$1 = _r$1; $f.err = err; $f.fd = fd; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.Close = function() { return this.$val.Close(); };
	FD.ptr.prototype.Shutdown = function(how) {
		var err, fd, how, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; how = $f.how; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Shutdown(fd.Sysfd, how);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Shutdown }; } $f.err = err; $f.fd = fd; $f.how = how; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Shutdown = function(how) { return this.$val.Shutdown(how); };
	FD.ptr.prototype.SetBlocking = function() {
		var err, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		atomic.StoreUint32((fd.$ptr_isBlocking || (fd.$ptr_isBlocking = new ptrType(function() { return this.$target.isBlocking; }, function($v) { this.$target.isBlocking = $v; }, fd))), 1);
		$s = -1; return syscall.SetNonblock(fd.Sysfd, false);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetBlocking }; } $f.err = err; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetBlocking = function() { return this.$val.SetBlocking(); };
	FD.ptr.prototype.Read = function(p) {
		var _r, _tuple, err, err$1, err$2, fd, n, p, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; n = $f.n; p = $f.p; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		_r = fd.readLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "readUnlock"), []]);
		if (p.$length === 0) {
			$s = -1; return [0, $ifaceNil];
		}
		err$1 = fd.pd.prepareRead(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, err$1];
		}
		if (fd.IsStream && p.$length > 1073741824) {
			p = $subslice(p, 0, 1073741824);
		}
		while (true) {
			_tuple = syscall.Read(fd.Sysfd, p);
			n = _tuple[0];
			err$2 = _tuple[1];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				n = 0;
				if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
					err$2 = fd.pd.waitRead(fd.isFile);
					if ($interfaceIsEqual(err$2, $ifaceNil)) {
						continue;
					}
				}
				if (false && $interfaceIsEqual(err$2, new syscall.Errno(4))) {
					continue;
				}
			}
			err$2 = fd.eofError(n, err$2);
			$s = -1; return [n, err$2];
		}
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Read }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.n = n; $f.p = p; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Read = function(p) { return this.$val.Read(p); };
	FD.ptr.prototype.Pread = function(p, off) {
		var _r, _tuple, err, err$1, fd, n, off, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; fd = $f.fd; n = $f.n; off = $f.off; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		if (fd.IsStream && p.$length > 1073741824) {
			p = $subslice(p, 0, 1073741824);
		}
		_tuple = syscall.Pread(fd.Sysfd, p, off);
		n = _tuple[0];
		err$1 = _tuple[1];
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			n = 0;
		}
		_r = fd.decref(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		err$1 = fd.eofError(n, err$1);
		$s = -1; return [n, err$1];
		/* */ } return; } if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Pread }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.fd = fd; $f.n = n; $f.off = off; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.prototype.Pread = function(p, off) { return this.$val.Pread(p, off); };
	FD.ptr.prototype.ReadFrom = function(p) {
		var _r, _tuple, err, err$1, err$2, fd, n, p, sa, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; n = $f.n; p = $f.p; sa = $f.sa; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		_r = fd.readLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, $ifaceNil, err];
		}
		$deferred.push([$methodVal(fd, "readUnlock"), []]);
		err$1 = fd.pd.prepareRead(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, $ifaceNil, err$1];
		}
		while (true) {
			_tuple = syscall.Recvfrom(fd.Sysfd, p, 0);
			n = _tuple[0];
			sa = _tuple[1];
			err$2 = _tuple[2];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				n = 0;
				if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
					err$2 = fd.pd.waitRead(fd.isFile);
					if ($interfaceIsEqual(err$2, $ifaceNil)) {
						continue;
					}
				}
			}
			err$2 = fd.eofError(n, err$2);
			$s = -1; return [n, sa, err$2];
		}
		$s = -1; return [0, $ifaceNil, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.ReadFrom }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.n = n; $f.p = p; $f.sa = sa; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.ReadFrom = function(p) { return this.$val.ReadFrom(p); };
	FD.ptr.prototype.ReadMsg = function(p, oob) {
		var _r, _tuple, err, err$1, err$2, fd, flags, n, oob, oobn, p, sa, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; flags = $f.flags; n = $f.n; oob = $f.oob; oobn = $f.oobn; p = $f.p; sa = $f.sa; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		_r = fd.readLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, 0, 0, $ifaceNil, err];
		}
		$deferred.push([$methodVal(fd, "readUnlock"), []]);
		err$1 = fd.pd.prepareRead(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, 0, 0, $ifaceNil, err$1];
		}
		while (true) {
			_tuple = syscall.Recvmsg(fd.Sysfd, p, oob, 0);
			n = _tuple[0];
			oobn = _tuple[1];
			flags = _tuple[2];
			sa = _tuple[3];
			err$2 = _tuple[4];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
					err$2 = fd.pd.waitRead(fd.isFile);
					if ($interfaceIsEqual(err$2, $ifaceNil)) {
						continue;
					}
				}
			}
			err$2 = fd.eofError(n, err$2);
			$s = -1; return [n, oobn, flags, sa, err$2];
		}
		$s = -1; return [0, 0, 0, $ifaceNil, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, 0, 0, $ifaceNil, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.ReadMsg }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.flags = flags; $f.n = n; $f.oob = oob; $f.oobn = oobn; $f.p = p; $f.sa = sa; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.ReadMsg = function(p, oob) { return this.$val.ReadMsg(p, oob); };
	FD.ptr.prototype.Write = function(p) {
		var _r, _tuple, err, err$1, err$2, fd, max, n, nn, p, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; max = $f.max; n = $f.n; nn = $f.nn; p = $f.p; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		_r = fd.writeLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		err$1 = fd.pd.prepareWrite(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, err$1];
		}
		nn = 0;
		while (true) {
			max = p.$length;
			if (fd.IsStream && (max - nn >> 0) > 1073741824) {
				max = nn + 1073741824 >> 0;
			}
			_tuple = syscall.Write(fd.Sysfd, $subslice(p, nn, max));
			n = _tuple[0];
			err$2 = _tuple[1];
			if (n > 0) {
				nn = nn + (n) >> 0;
			}
			if (nn === p.$length) {
				$s = -1; return [nn, err$2];
			}
			if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
				err$2 = fd.pd.waitWrite(fd.isFile);
				if ($interfaceIsEqual(err$2, $ifaceNil)) {
					continue;
				}
			}
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return [nn, err$2];
			}
			if (n === 0) {
				$s = -1; return [nn, io.ErrUnexpectedEOF];
			}
		}
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Write }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.max = max; $f.n = n; $f.nn = nn; $f.p = p; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Write = function(p) { return this.$val.Write(p); };
	FD.ptr.prototype.Pwrite = function(p, off) {
		var _tuple, err, err$1, fd, max, n, nn, off, p, x, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; fd = $f.fd; max = $f.max; n = $f.n; nn = $f.nn; off = $f.off; p = $f.p; x = $f.x; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		nn = 0;
		while (true) {
			max = p.$length;
			if (fd.IsStream && (max - nn >> 0) > 1073741824) {
				max = nn + 1073741824 >> 0;
			}
			_tuple = syscall.Pwrite(fd.Sysfd, $subslice(p, nn, max), (x = (new $Int64(0, nn)), new $Int64(off.$high + x.$high, off.$low + x.$low)));
			n = _tuple[0];
			err$1 = _tuple[1];
			if (n > 0) {
				nn = nn + (n) >> 0;
			}
			if (nn === p.$length) {
				$s = -1; return [nn, err$1];
			}
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				$s = -1; return [nn, err$1];
			}
			if (n === 0) {
				$s = -1; return [nn, io.ErrUnexpectedEOF];
			}
		}
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Pwrite }; } $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.fd = fd; $f.max = max; $f.n = n; $f.nn = nn; $f.off = off; $f.p = p; $f.x = x; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Pwrite = function(p, off) { return this.$val.Pwrite(p, off); };
	FD.ptr.prototype.WriteTo = function(p, sa) {
		var _r, _r$1, err, err$1, err$2, fd, p, sa, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; p = $f.p; sa = $f.sa; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		_r = fd.writeLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		err$1 = fd.pd.prepareWrite(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, err$1];
		}
		/* while (true) { */ case 2:
			_r$1 = syscall.Sendto(fd.Sysfd, p, 0, sa); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			err$2 = _r$1;
			if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
				err$2 = fd.pd.waitWrite(fd.isFile);
				if ($interfaceIsEqual(err$2, $ifaceNil)) {
					/* continue; */ $s = 2; continue;
				}
			}
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return [0, err$2];
			}
			$s = -1; return [p.$length, $ifaceNil];
		/* } */ $s = 2; continue; case 3:
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.WriteTo }; } $f._r = _r; $f._r$1 = _r$1; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.p = p; $f.sa = sa; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.WriteTo = function(p, sa) { return this.$val.WriteTo(p, sa); };
	FD.ptr.prototype.WriteMsg = function(p, oob, sa) {
		var _r, _r$1, _tuple, err, err$1, err$2, fd, n, oob, p, sa, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; n = $f.n; oob = $f.oob; p = $f.p; sa = $f.sa; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		_r = fd.writeLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, 0, err];
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		err$1 = fd.pd.prepareWrite(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [0, 0, err$1];
		}
		/* while (true) { */ case 2:
			_r$1 = syscall.SendmsgN(fd.Sysfd, p, oob, sa, 0); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple = _r$1;
			n = _tuple[0];
			err$2 = _tuple[1];
			if ($interfaceIsEqual(err$2, new syscall.Errno(11)) && fd.pd.pollable()) {
				err$2 = fd.pd.waitWrite(fd.isFile);
				if ($interfaceIsEqual(err$2, $ifaceNil)) {
					/* continue; */ $s = 2; continue;
				}
			}
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return [n, 0, err$2];
			}
			$s = -1; return [n, oob.$length, err$2];
		/* } */ $s = 2; continue; case 3:
		$s = -1; return [0, 0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, 0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.WriteMsg }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.n = n; $f.oob = oob; $f.p = p; $f.sa = sa; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.WriteMsg = function(p, oob, sa) { return this.$val.WriteMsg(p, oob, sa); };
	FD.ptr.prototype.Accept = function() {
		var _1, _r, _r$1, _tuple, err, err$1, err$2, errcall, fd, rsa, s, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; errcall = $f.errcall; fd = $f.fd; rsa = $f.rsa; s = $f.s; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		_r = fd.readLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [-1, $ifaceNil, "", err];
		}
		$deferred.push([$methodVal(fd, "readUnlock"), []]);
		err$1 = fd.pd.prepareRead(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [-1, $ifaceNil, "", err$1];
		}
		/* while (true) { */ case 2:
			_r$1 = accept(fd.Sysfd); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple = _r$1;
			s = _tuple[0];
			rsa = _tuple[1];
			errcall = _tuple[2];
			err$2 = _tuple[3];
			if ($interfaceIsEqual(err$2, $ifaceNil)) {
				$s = -1; return [s, rsa, "", err$2];
			}
			_1 = err$2;
			if ($interfaceIsEqual(_1, new syscall.Errno((11)))) {
				if (fd.pd.pollable()) {
					err$2 = fd.pd.waitRead(fd.isFile);
					if ($interfaceIsEqual(err$2, $ifaceNil)) {
						/* continue; */ $s = 2; continue;
					}
				}
			} else if ($interfaceIsEqual(_1, new syscall.Errno((103)))) {
				/* continue; */ $s = 2; continue;
			}
			$s = -1; return [-1, $ifaceNil, errcall, err$2];
		/* } */ $s = 2; continue; case 3:
		$s = -1; return [0, $ifaceNil, "", $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil, "", $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Accept }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.errcall = errcall; $f.fd = fd; $f.rsa = rsa; $f.s = s; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Accept = function() { return this.$val.Accept(); };
	FD.ptr.prototype.Seek = function(offset, whence) {
		var err, fd, offset, whence, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; offset = $f.offset; whence = $f.whence; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [new $Int64(0, 0), err];
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Seek(fd.Sysfd, offset, whence);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [new $Int64(0, 0), $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Seek }; } $f.err = err; $f.fd = fd; $f.offset = offset; $f.whence = whence; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Seek = function(offset, whence) { return this.$val.Seek(offset, whence); };
	FD.ptr.prototype.ReadDirent = function(buf) {
		var _tuple, buf, err, err$1, fd, n, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; buf = $f.buf; err = $f.err; err$1 = $f.err$1; fd = $f.fd; n = $f.n; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		while (true) {
			_tuple = syscall.ReadDirent(fd.Sysfd, buf);
			n = _tuple[0];
			err$1 = _tuple[1];
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				n = 0;
				if ($interfaceIsEqual(err$1, new syscall.Errno(11)) && fd.pd.pollable()) {
					err$1 = fd.pd.waitRead(fd.isFile);
					if ($interfaceIsEqual(err$1, $ifaceNil)) {
						continue;
					}
				}
			}
			$s = -1; return [n, err$1];
		}
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.ReadDirent }; } $f._tuple = _tuple; $f.buf = buf; $f.err = err; $f.err$1 = err$1; $f.fd = fd; $f.n = n; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.ReadDirent = function(buf) { return this.$val.ReadDirent(buf); };
	FD.ptr.prototype.Fchdir = function() {
		var err, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Fchdir(fd.Sysfd);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Fchdir }; } $f.err = err; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Fchdir = function() { return this.$val.Fchdir(); };
	FD.ptr.prototype.Fstat = function(s) {
		var err, fd, s, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; s = $f.s; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.Fstat(fd.Sysfd, s);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Fstat }; } $f.err = err; $f.fd = fd; $f.s = s; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Fstat = function(s) { return this.$val.Fstat(s); };
	DupCloseOnExec = function(fd) {
		var _1, _r, _tuple, e1, fd, r0, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _tuple = $f._tuple; e1 = $f.e1; fd = $f.fd; r0 = $f.r0; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (atomic.LoadInt32((tryDupCloexec$24ptr || (tryDupCloexec$24ptr = new ptrType$2(function() { return tryDupCloexec; }, function($v) { tryDupCloexec = $v; })))) === 1) {
			_tuple = fcntl(fd, 1030, 0);
			r0 = _tuple[0];
			e1 = _tuple[1];
			if ($interfaceIsEqual(e1, $ifaceNil)) {
				$s = -1; return [r0, "", $ifaceNil];
			}
			_1 = $assertType(e1, syscall.Errno);
			if ((_1 === (22)) || (_1 === (38))) {
				atomic.StoreInt32((tryDupCloexec$24ptr || (tryDupCloexec$24ptr = new ptrType$2(function() { return tryDupCloexec; }, function($v) { tryDupCloexec = $v; }))), 0);
			} else {
				$s = -1; return [-1, "fcntl", e1];
			}
		}
		_r = dupCloseOnExecOld(fd); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: DupCloseOnExec }; } $f._1 = _1; $f._r = _r; $f._tuple = _tuple; $f.e1 = e1; $f.fd = fd; $f.r0 = r0; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.DupCloseOnExec = DupCloseOnExec;
	dupCloseOnExecOld = function(fd) {
		var _tuple, err, fd, newfd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; err = $f.err; fd = $f.fd; newfd = $f.newfd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = syscall.ForkLock.RLock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(syscall.ForkLock, "RUnlock"), []]);
		_tuple = syscall.Dup(fd);
		newfd = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [-1, "dup", err];
		}
		syscall.CloseOnExec(newfd);
		$s = -1; return [newfd, "", $ifaceNil];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, "", $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: dupCloseOnExecOld }; } $f._tuple = _tuple; $f.err = err; $f.fd = fd; $f.newfd = newfd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.ptr.prototype.Dup = function() {
		var _r, err, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [-1, "", err];
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		_r = DupCloseOnExec(fd.Sysfd); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, "", $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Dup }; } $f._r = _r; $f.err = err; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Dup = function() { return this.$val.Dup(); };
	FD.ptr.prototype.WaitWrite = function() {
		var fd;
		fd = this;
		return fd.pd.waitWrite(fd.isFile);
	};
	FD.prototype.WaitWrite = function() { return this.$val.WaitWrite(); };
	FD.ptr.prototype.WriteOnce = function(p) {
		var _r, err, fd, p, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; fd = $f.fd; p = $f.p; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		_r = fd.writeLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [0, err];
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		$s = -1; return syscall.Write(fd.Sysfd, p);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.WriteOnce }; } $f._r = _r; $f.err = err; $f.fd = fd; $f.p = p; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.WriteOnce = function(p) { return this.$val.WriteOnce(p); };
	FD.ptr.prototype.RawControl = function(f) {
		var err, f, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; f = $f.f; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$r = f(((fd.Sysfd >>> 0))); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.RawControl }; } $f.err = err; $f.f = f; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.RawControl = function(f) { return this.$val.RawControl(f); };
	FD.ptr.prototype.RawRead = function(f) {
		var _r, _r$1, err, err$1, err$2, f, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; f = $f.f; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		_r = fd.readLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "readUnlock"), []]);
		err$1 = fd.pd.prepareRead(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return err$1;
		}
		/* while (true) { */ case 2:
			_r$1 = f(((fd.Sysfd >>> 0))); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (_r$1) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_r$1) { */ case 4:
				$s = -1; return $ifaceNil;
			/* } */ case 5:
			err$2 = fd.pd.waitRead(fd.isFile);
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return err$2;
			}
		/* } */ $s = 2; continue; case 3:
		$s = -1; return $ifaceNil;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.RawRead }; } $f._r = _r; $f._r$1 = _r$1; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.f = f; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.RawRead = function(f) { return this.$val.RawRead(f); };
	FD.ptr.prototype.RawWrite = function(f) {
		var _r, _r$1, err, err$1, err$2, f, fd, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; f = $f.f; fd = $f.fd; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		_r = fd.writeLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		err$1 = fd.pd.prepareWrite(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return err$1;
		}
		/* while (true) { */ case 2:
			_r$1 = f(((fd.Sysfd >>> 0))); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (_r$1) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_r$1) { */ case 4:
				$s = -1; return $ifaceNil;
			/* } */ case 5:
			err$2 = fd.pd.waitWrite(fd.isFile);
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return err$2;
			}
		/* } */ $s = 2; continue; case 3:
		$s = -1; return $ifaceNil;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.RawWrite }; } $f._r = _r; $f._r$1 = _r$1; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.f = f; $f.fd = fd; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.RawWrite = function(f) { return this.$val.RawWrite(f); };
	writev = function(fd, iovecs) {
		var _tuple, e, fd, iovecs, r;
		_tuple = syscall.Syscall(20, ((fd >>> 0)), (($sliceToArray(iovecs))), ((iovecs.$length >>> 0)));
		r = _tuple[0];
		e = _tuple[2];
		if (!((e === 0))) {
			return [r, new syscall.Errno((e))];
		}
		return [r, $ifaceNil];
	};
	accept = function(s) {
		var _1, _r, _r$1, _r$2, _tuple, _tuple$1, err, ns, s, sa, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; err = $f.err; ns = $f.ns; s = $f.s; sa = $f.sa; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = $pkg.Accept4Func(s, 526336); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		ns = _tuple[0];
		sa = _tuple[1];
		err = _tuple[2];
		_1 = err;
		if ($interfaceIsEqual(_1, $ifaceNil)) {
			$s = -1; return [ns, sa, "", $ifaceNil];
		} else if ($interfaceIsEqual(_1, new syscall.Errno((38)))) {
		} else if ($interfaceIsEqual(_1, new syscall.Errno((22)))) {
		} else if ($interfaceIsEqual(_1, new syscall.Errno((13)))) {
		} else if ($interfaceIsEqual(_1, new syscall.Errno((14)))) {
		} else {
			$s = -1; return [-1, sa, "accept4", err];
		}
		_r$1 = $pkg.AcceptFunc(s); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		ns = _tuple$1[0];
		sa = _tuple$1[1];
		err = _tuple$1[2];
		if ($interfaceIsEqual(err, $ifaceNil)) {
			syscall.CloseOnExec(ns);
		}
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [-1, $ifaceNil, "accept", err];
		}
		err = syscall.SetNonblock(ns, true);
		/* */ if (!($interfaceIsEqual(err, $ifaceNil))) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 3:
			_r$2 = $pkg.CloseFunc(ns); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_r$2;
			$s = -1; return [-1, $ifaceNil, "setnonblock", err];
		/* } */ case 4:
		$s = -1; return [ns, sa, "", $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: accept }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.err = err; $f.ns = ns; $f.s = s; $f.sa = sa; $f.$s = $s; $f.$r = $r; return $f;
	};
	FD.ptr.prototype.SetsockoptInt = function(level, name, arg) {
		var arg, err, fd, level, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; arg = $f.arg; err = $f.err; fd = $f.fd; level = $f.level; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptInt(fd.Sysfd, level, name, arg);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptInt }; } $f.arg = arg; $f.err = err; $f.fd = fd; $f.level = level; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptInt = function(level, name, arg) { return this.$val.SetsockoptInt(level, name, arg); };
	FD.ptr.prototype.SetsockoptInet4Addr = function(level, name, arg) {
		var arg, err, fd, level, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; arg = $f.arg; err = $f.err; fd = $f.fd; level = $f.level; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptInet4Addr(fd.Sysfd, level, name, $clone(arg, arrayType));
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptInet4Addr }; } $f.arg = arg; $f.err = err; $f.fd = fd; $f.level = level; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptInet4Addr = function(level, name, arg) { return this.$val.SetsockoptInet4Addr(level, name, arg); };
	FD.ptr.prototype.SetsockoptLinger = function(level, name, l) {
		var err, fd, l, level, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; l = $f.l; level = $f.level; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptLinger(fd.Sysfd, level, name, l);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptLinger }; } $f.err = err; $f.fd = fd; $f.l = l; $f.level = level; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptLinger = function(level, name, l) { return this.$val.SetsockoptLinger(level, name, l); };
	FD.ptr.prototype.SetsockoptIPMreqn = function(level, name, mreq) {
		var err, fd, level, mreq, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; level = $f.level; mreq = $f.mreq; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptIPMreqn(fd.Sysfd, level, name, mreq);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptIPMreqn }; } $f.err = err; $f.fd = fd; $f.level = level; $f.mreq = mreq; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptIPMreqn = function(level, name, mreq) { return this.$val.SetsockoptIPMreqn(level, name, mreq); };
	FD.ptr.prototype.SetsockoptByte = function(level, name, arg) {
		var arg, err, fd, level, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; arg = $f.arg; err = $f.err; fd = $f.fd; level = $f.level; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptByte(fd.Sysfd, level, name, arg);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptByte }; } $f.arg = arg; $f.err = err; $f.fd = fd; $f.level = level; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptByte = function(level, name, arg) { return this.$val.SetsockoptByte(level, name, arg); };
	FD.ptr.prototype.SetsockoptIPMreq = function(level, name, mreq) {
		var err, fd, level, mreq, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; level = $f.level; mreq = $f.mreq; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptIPMreq(fd.Sysfd, level, name, mreq);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptIPMreq }; } $f.err = err; $f.fd = fd; $f.level = level; $f.mreq = mreq; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptIPMreq = function(level, name, mreq) { return this.$val.SetsockoptIPMreq(level, name, mreq); };
	FD.ptr.prototype.SetsockoptIPv6Mreq = function(level, name, mreq) {
		var err, fd, level, mreq, name, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; err = $f.err; fd = $f.fd; level = $f.level; mreq = $f.mreq; name = $f.name; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		fd = this;
		err = fd.incref();
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$deferred.push([$methodVal(fd, "decref"), []]);
		$s = -1; return syscall.SetsockoptIPv6Mreq(fd.Sysfd, level, name, mreq);
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.SetsockoptIPv6Mreq }; } $f.err = err; $f.fd = fd; $f.level = level; $f.mreq = mreq; $f.name = name; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.SetsockoptIPv6Mreq = function(level, name, mreq) { return this.$val.SetsockoptIPv6Mreq(level, name, mreq); };
	FD.ptr.prototype.Writev = function(v) {
		var _i, _r, _ref, _tuple, chunk, err, err$1, err$2, fd, iovecs, maxVec, n, v, wrote, x, x$1, x$2, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _tuple = $f._tuple; chunk = $f.chunk; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; fd = $f.fd; iovecs = $f.iovecs; maxVec = $f.maxVec; n = $f.n; v = $f.v; wrote = $f.wrote; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		iovecs = [iovecs];
		fd = this;
		_r = fd.writeLock(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [new $Int64(0, 0), err];
		}
		$deferred.push([$methodVal(fd, "writeUnlock"), []]);
		err$1 = fd.pd.prepareWrite(fd.isFile);
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [new $Int64(0, 0), err$1];
		}
		iovecs[0] = sliceType$2.nil;
		if (!(fd.iovecs === ptrType$6.nil)) {
			iovecs[0] = fd.iovecs.$get();
		}
		maxVec = 1024;
		n = new $Int64(0, 0);
		err$2 = $ifaceNil;
		/* while (true) { */ case 2:
			/* if (!(v.$get().$length > 0)) { break; } */ if(!(v.$get().$length > 0)) { $s = 3; continue; }
			iovecs[0] = $subslice(iovecs[0], 0, 0);
			_ref = v.$get();
			_i = 0;
			/* while (true) { */ case 4:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
				chunk = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (chunk.$length === 0) {
					_i++;
					/* continue; */ $s = 4; continue;
				}
				iovecs[0] = $append(iovecs[0], new syscall.Iovec.ptr($indexPtr(chunk.$array, chunk.$offset + 0, ptrType$7), new $Uint64(0, 0)));
				if (fd.IsStream && chunk.$length > 1073741824) {
					(x = iovecs[0].$length - 1 >> 0, ((x < 0 || x >= iovecs[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : iovecs[0].$array[iovecs[0].$offset + x])).SetLen(1073741824);
					/* break; */ $s = 5; continue;
				}
				(x$1 = iovecs[0].$length - 1 >> 0, ((x$1 < 0 || x$1 >= iovecs[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : iovecs[0].$array[iovecs[0].$offset + x$1])).SetLen(chunk.$length);
				if (iovecs[0].$length === maxVec) {
					/* break; */ $s = 5; continue;
				}
				_i++;
			/* } */ $s = 4; continue; case 5:
			if (iovecs[0].$length === 0) {
				/* break; */ $s = 3; continue;
			}
			fd.iovecs = (iovecs.$ptr || (iovecs.$ptr = new ptrType$6(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, iovecs)));
			wrote = 0;
			_tuple = writev(fd.Sysfd, iovecs[0]);
			wrote = _tuple[0];
			err$2 = _tuple[1];
			if (wrote === 4294967295) {
				wrote = 0;
			}
			$r = $pkg.TestHookDidWritev(((wrote >> 0))); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			n = (x$2 = (new $Int64(0, wrote.constructor === Number ? wrote : 1)), new $Int64(n.$high + x$2.$high, n.$low + x$2.$low));
			consume(v, (new $Int64(0, wrote.constructor === Number ? wrote : 1)));
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				if ($assertType(err$2, syscall.Errno) === 11) {
					err$2 = fd.pd.waitWrite(fd.isFile);
					if ($interfaceIsEqual(err$2, $ifaceNil)) {
						/* continue; */ $s = 2; continue;
					}
				}
				/* break; */ $s = 3; continue;
			}
			if ((n.$high === 0 && n.$low === 0)) {
				err$2 = io.ErrUnexpectedEOF;
				/* break; */ $s = 3; continue;
			}
		/* } */ $s = 2; continue; case 3:
		$s = -1; return [n, err$2];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [new $Int64(0, 0), $ifaceNil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: FD.ptr.prototype.Writev }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._tuple = _tuple; $f.chunk = chunk; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.fd = fd; $f.iovecs = iovecs; $f.maxVec = maxVec; $f.n = n; $f.v = v; $f.wrote = wrote; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	FD.prototype.Writev = function(v) { return this.$val.Writev(v); };
	ptrType$9.methods = [{prop: "init", name: "init", pkg: "internal/poll", typ: $funcType([ptrType$8], [$error], false)}, {prop: "close", name: "close", pkg: "internal/poll", typ: $funcType([], [], false)}, {prop: "evict", name: "evict", pkg: "internal/poll", typ: $funcType([], [], false)}, {prop: "prepare", name: "prepare", pkg: "internal/poll", typ: $funcType([$Int, $Bool], [$error], false)}, {prop: "prepareRead", name: "prepareRead", pkg: "internal/poll", typ: $funcType([$Bool], [$error], false)}, {prop: "prepareWrite", name: "prepareWrite", pkg: "internal/poll", typ: $funcType([$Bool], [$error], false)}, {prop: "wait", name: "wait", pkg: "internal/poll", typ: $funcType([$Int, $Bool], [$error], false)}, {prop: "waitRead", name: "waitRead", pkg: "internal/poll", typ: $funcType([$Bool], [$error], false)}, {prop: "waitWrite", name: "waitWrite", pkg: "internal/poll", typ: $funcType([$Bool], [$error], false)}, {prop: "waitCanceled", name: "waitCanceled", pkg: "internal/poll", typ: $funcType([$Int], [], false)}, {prop: "pollable", name: "pollable", pkg: "internal/poll", typ: $funcType([], [$Bool], false)}];
	ptrType$10.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Timeout", name: "Timeout", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Temporary", name: "Temporary", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$11.methods = [{prop: "incref", name: "incref", pkg: "internal/poll", typ: $funcType([], [$Bool], false)}, {prop: "increfAndClose", name: "increfAndClose", pkg: "internal/poll", typ: $funcType([], [$Bool], false)}, {prop: "decref", name: "decref", pkg: "internal/poll", typ: $funcType([], [$Bool], false)}, {prop: "rwlock", name: "rwlock", pkg: "internal/poll", typ: $funcType([$Bool], [$Bool], false)}, {prop: "rwunlock", name: "rwunlock", pkg: "internal/poll", typ: $funcType([$Bool], [$Bool], false)}];
	ptrType$8.methods = [{prop: "SetDeadline", name: "SetDeadline", pkg: "", typ: $funcType([time.Time], [$error], false)}, {prop: "SetReadDeadline", name: "SetReadDeadline", pkg: "", typ: $funcType([time.Time], [$error], false)}, {prop: "SetWriteDeadline", name: "SetWriteDeadline", pkg: "", typ: $funcType([time.Time], [$error], false)}, {prop: "Fsync", name: "Fsync", pkg: "", typ: $funcType([], [$error], false)}, {prop: "incref", name: "incref", pkg: "internal/poll", typ: $funcType([], [$error], false)}, {prop: "decref", name: "decref", pkg: "internal/poll", typ: $funcType([], [$error], false)}, {prop: "readLock", name: "readLock", pkg: "internal/poll", typ: $funcType([], [$error], false)}, {prop: "readUnlock", name: "readUnlock", pkg: "internal/poll", typ: $funcType([], [], false)}, {prop: "writeLock", name: "writeLock", pkg: "internal/poll", typ: $funcType([], [$error], false)}, {prop: "writeUnlock", name: "writeUnlock", pkg: "internal/poll", typ: $funcType([], [], false)}, {prop: "eofError", name: "eofError", pkg: "internal/poll", typ: $funcType([$Int, $error], [$error], false)}, {prop: "Fchmod", name: "Fchmod", pkg: "", typ: $funcType([$Uint32], [$error], false)}, {prop: "Fchown", name: "Fchown", pkg: "", typ: $funcType([$Int, $Int], [$error], false)}, {prop: "Ftruncate", name: "Ftruncate", pkg: "", typ: $funcType([$Int64], [$error], false)}, {prop: "Init", name: "Init", pkg: "", typ: $funcType([$String, $Bool], [$error], false)}, {prop: "destroy", name: "destroy", pkg: "internal/poll", typ: $funcType([], [$error], false)}, {prop: "Close", name: "Close", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Shutdown", name: "Shutdown", pkg: "", typ: $funcType([$Int], [$error], false)}, {prop: "SetBlocking", name: "SetBlocking", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$3], [$Int, $error], false)}, {prop: "Pread", name: "Pread", pkg: "", typ: $funcType([sliceType$3, $Int64], [$Int, $error], false)}, {prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([sliceType$3], [$Int, syscall.Sockaddr, $error], false)}, {prop: "ReadMsg", name: "ReadMsg", pkg: "", typ: $funcType([sliceType$3, sliceType$3], [$Int, $Int, $Int, syscall.Sockaddr, $error], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$3], [$Int, $error], false)}, {prop: "Pwrite", name: "Pwrite", pkg: "", typ: $funcType([sliceType$3, $Int64], [$Int, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([sliceType$3, syscall.Sockaddr], [$Int, $error], false)}, {prop: "WriteMsg", name: "WriteMsg", pkg: "", typ: $funcType([sliceType$3, sliceType$3, syscall.Sockaddr], [$Int, $Int, $error], false)}, {prop: "Accept", name: "Accept", pkg: "", typ: $funcType([], [$Int, syscall.Sockaddr, $String, $error], false)}, {prop: "Seek", name: "Seek", pkg: "", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "ReadDirent", name: "ReadDirent", pkg: "", typ: $funcType([sliceType$3], [$Int, $error], false)}, {prop: "Fchdir", name: "Fchdir", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Fstat", name: "Fstat", pkg: "", typ: $funcType([ptrType$12], [$error], false)}, {prop: "Dup", name: "Dup", pkg: "", typ: $funcType([], [$Int, $String, $error], false)}, {prop: "WaitWrite", name: "WaitWrite", pkg: "", typ: $funcType([], [$error], false)}, {prop: "WriteOnce", name: "WriteOnce", pkg: "", typ: $funcType([sliceType$3], [$Int, $error], false)}, {prop: "RawControl", name: "RawControl", pkg: "", typ: $funcType([funcType], [$error], false)}, {prop: "RawRead", name: "RawRead", pkg: "", typ: $funcType([funcType$1], [$error], false)}, {prop: "RawWrite", name: "RawWrite", pkg: "", typ: $funcType([funcType$1], [$error], false)}, {prop: "SetsockoptInt", name: "SetsockoptInt", pkg: "", typ: $funcType([$Int, $Int, $Int], [$error], false)}, {prop: "SetsockoptInet4Addr", name: "SetsockoptInet4Addr", pkg: "", typ: $funcType([$Int, $Int, arrayType], [$error], false)}, {prop: "SetsockoptLinger", name: "SetsockoptLinger", pkg: "", typ: $funcType([$Int, $Int, ptrType$13], [$error], false)}, {prop: "SetsockoptIPMreqn", name: "SetsockoptIPMreqn", pkg: "", typ: $funcType([$Int, $Int, ptrType$14], [$error], false)}, {prop: "SetsockoptByte", name: "SetsockoptByte", pkg: "", typ: $funcType([$Int, $Int, $Uint8], [$error], false)}, {prop: "SetsockoptIPMreq", name: "SetsockoptIPMreq", pkg: "", typ: $funcType([$Int, $Int, ptrType$15], [$error], false)}, {prop: "SetsockoptIPv6Mreq", name: "SetsockoptIPv6Mreq", pkg: "", typ: $funcType([$Int, $Int, ptrType$16], [$error], false)}, {prop: "Writev", name: "Writev", pkg: "", typ: $funcType([ptrType$17], [$Int64, $error], false)}];
	pollDesc.init("internal/poll", [{prop: "closing", name: "closing", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	TimeoutError.init("", []);
	fdMutex.init("internal/poll", [{prop: "state", name: "state", embedded: false, exported: false, typ: $Uint64, tag: ""}, {prop: "rsema", name: "rsema", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "wsema", name: "wsema", embedded: false, exported: false, typ: $Uint32, tag: ""}]);
	FD.init("internal/poll", [{prop: "fdmu", name: "fdmu", embedded: false, exported: false, typ: fdMutex, tag: ""}, {prop: "Sysfd", name: "Sysfd", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "pd", name: "pd", embedded: false, exported: false, typ: pollDesc, tag: ""}, {prop: "iovecs", name: "iovecs", embedded: false, exported: false, typ: ptrType$6, tag: ""}, {prop: "csema", name: "csema", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "isBlocking", name: "isBlocking", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "IsStream", name: "IsStream", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "ZeroReadIsEOF", name: "ZeroReadIsEOF", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "isFile", name: "isFile", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = syscall.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		semWaiters = {};
		$pkg.ErrNetClosing = errors.New("use of closed network connection");
		$pkg.ErrFileClosing = errors.New("use of closed file");
		$pkg.ErrNoDeadline = errors.New("file type does not support deadline");
		$pkg.ErrTimeout = new TimeoutError.ptr();
		$pkg.TestHookDidWritev = (function(wrote) {
			var wrote;
		});
		tryDupCloexec = 1;
		$pkg.Accept4Func = syscall.Accept4;
		$pkg.CloseFunc = syscall.Close;
		$pkg.AcceptFunc = syscall.Accept;
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/syscall/unix"] = (function() {
	var $pkg = {}, $init, atomic, syscall, IsNonblock;
	atomic = $packages["sync/atomic"];
	syscall = $packages["syscall"];
	IsNonblock = function(fd) {
		var _tmp, _tmp$1, err, fd, nonblocking;
		nonblocking = false;
		err = $ifaceNil;
		_tmp = false;
		_tmp$1 = $ifaceNil;
		nonblocking = _tmp;
		err = _tmp$1;
		return [nonblocking, err];
	};
	$pkg.IsNonblock = IsNonblock;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = atomic.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = syscall.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/testlog"] = (function() {
	var $pkg = {}, $init, atomic, Interface, ptrType, logger, Logger, Stat;
	atomic = $packages["sync/atomic"];
	Interface = $pkg.Interface = $newType(8, $kindInterface, "testlog.Interface", true, "internal/testlog", true, null);
	ptrType = $ptrType(Interface);
	Logger = function() {
		var impl;
		impl = logger.Load();
		if ($interfaceIsEqual(impl, $ifaceNil)) {
			return $ifaceNil;
		}
		return $assertType(impl, ptrType).$get();
	};
	$pkg.Logger = Logger;
	Stat = function(name) {
		var log, name, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; log = $f.log; name = $f.name; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		log = Logger();
		/* */ if (!($interfaceIsEqual(log, $ifaceNil))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!($interfaceIsEqual(log, $ifaceNil))) { */ case 1:
			$r = log.Stat(name); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Stat }; } $f.log = log; $f.name = name; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Stat = Stat;
	Interface.init([{prop: "Chdir", name: "Chdir", pkg: "", typ: $funcType([$String], [], false)}, {prop: "Getenv", name: "Getenv", pkg: "", typ: $funcType([$String], [], false)}, {prop: "Open", name: "Open", pkg: "", typ: $funcType([$String], [], false)}, {prop: "Stat", name: "Stat", pkg: "", typ: $funcType([$String], [], false)}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = atomic.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		logger = new atomic.Value.ptr($ifaceNil);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["os"] = (function() {
	var $pkg = {}, $init, errors, js, poll, unix, testlog, io, runtime, sync, atomic, syscall, time, dirInfo, timeout, PathError, SyscallError, LinkError, file, rawConn, File, FileInfo, FileMode, fileStat, sliceType, ptrType, sliceType$1, ptrType$1, sliceType$2, ptrType$2, ptrType$3, ptrType$4, sliceType$5, ptrType$12, arrayType$1, ptrType$13, funcType$1, ptrType$15, arrayType$6, ptrType$16, funcType$2, funcType$3, ptrType$18, errFinished, lstat, runtime_args, init, runtime_beforeExit, NewSyscallError, IsNotExist, underlyingError, wrapSyscallError, isNotExist, sigpipe, syscallMode, NewFile, newFile, epipecheck, basename, init$1, Exit, newRawConn, Lstat, fillFileStatFromSys, timespecToTime, lstatNolog;
	errors = $packages["errors"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	poll = $packages["internal/poll"];
	unix = $packages["internal/syscall/unix"];
	testlog = $packages["internal/testlog"];
	io = $packages["io"];
	runtime = $packages["runtime"];
	sync = $packages["sync"];
	atomic = $packages["sync/atomic"];
	syscall = $packages["syscall"];
	time = $packages["time"];
	dirInfo = $pkg.dirInfo = $newType(0, $kindStruct, "os.dirInfo", true, "os", false, function(buf_, nbuf_, bufp_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = sliceType$2.nil;
			this.nbuf = 0;
			this.bufp = 0;
			return;
		}
		this.buf = buf_;
		this.nbuf = nbuf_;
		this.bufp = bufp_;
	});
	timeout = $pkg.timeout = $newType(8, $kindInterface, "os.timeout", true, "os", false, null);
	PathError = $pkg.PathError = $newType(0, $kindStruct, "os.PathError", true, "os", true, function(Op_, Path_, Err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Op = "";
			this.Path = "";
			this.Err = $ifaceNil;
			return;
		}
		this.Op = Op_;
		this.Path = Path_;
		this.Err = Err_;
	});
	SyscallError = $pkg.SyscallError = $newType(0, $kindStruct, "os.SyscallError", true, "os", true, function(Syscall_, Err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Syscall = "";
			this.Err = $ifaceNil;
			return;
		}
		this.Syscall = Syscall_;
		this.Err = Err_;
	});
	LinkError = $pkg.LinkError = $newType(0, $kindStruct, "os.LinkError", true, "os", true, function(Op_, Old_, New_, Err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Op = "";
			this.Old = "";
			this.New = "";
			this.Err = $ifaceNil;
			return;
		}
		this.Op = Op_;
		this.Old = Old_;
		this.New = New_;
		this.Err = Err_;
	});
	file = $pkg.file = $newType(0, $kindStruct, "os.file", true, "os", false, function(pfd_, name_, dirinfo_, nonblock_, stdoutOrErr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.pfd = new poll.FD.ptr(new poll.fdMutex.ptr(new $Uint64(0, 0), 0, 0), 0, new poll.pollDesc.ptr(false), ptrType$12.nil, 0, 0, false, false, false);
			this.name = "";
			this.dirinfo = ptrType$1.nil;
			this.nonblock = false;
			this.stdoutOrErr = false;
			return;
		}
		this.pfd = pfd_;
		this.name = name_;
		this.dirinfo = dirinfo_;
		this.nonblock = nonblock_;
		this.stdoutOrErr = stdoutOrErr_;
	});
	rawConn = $pkg.rawConn = $newType(0, $kindStruct, "os.rawConn", true, "os", false, function(file_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.file = ptrType.nil;
			return;
		}
		this.file = file_;
	});
	File = $pkg.File = $newType(0, $kindStruct, "os.File", true, "os", true, function(file_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.file = ptrType$13.nil;
			return;
		}
		this.file = file_;
	});
	FileInfo = $pkg.FileInfo = $newType(8, $kindInterface, "os.FileInfo", true, "os", true, null);
	FileMode = $pkg.FileMode = $newType(4, $kindUint32, "os.FileMode", true, "os", true, null);
	fileStat = $pkg.fileStat = $newType(0, $kindStruct, "os.fileStat", true, "os", false, function(name_, size_, mode_, modTime_, sys_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = "";
			this.size = new $Int64(0, 0);
			this.mode = 0;
			this.modTime = new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$15.nil);
			this.sys = new syscall.Stat_t.ptr(new $Uint64(0, 0), new $Uint64(0, 0), new $Uint64(0, 0), 0, 0, 0, 0, new $Uint64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), arrayType$1.zero());
			return;
		}
		this.name = name_;
		this.size = size_;
		this.mode = mode_;
		this.modTime = modTime_;
		this.sys = sys_;
	});
	sliceType = $sliceType($String);
	ptrType = $ptrType(File);
	sliceType$1 = $sliceType(FileInfo);
	ptrType$1 = $ptrType(dirInfo);
	sliceType$2 = $sliceType($Uint8);
	ptrType$2 = $ptrType(PathError);
	ptrType$3 = $ptrType(LinkError);
	ptrType$4 = $ptrType(SyscallError);
	sliceType$5 = $sliceType(syscall.Iovec);
	ptrType$12 = $ptrType(sliceType$5);
	arrayType$1 = $arrayType($Int64, 3);
	ptrType$13 = $ptrType(file);
	funcType$1 = $funcType([ptrType$13], [$error], false);
	ptrType$15 = $ptrType(time.Location);
	arrayType$6 = $arrayType($Uint8, 32);
	ptrType$16 = $ptrType(fileStat);
	funcType$2 = $funcType([$Uintptr], [], false);
	funcType$3 = $funcType([$Uintptr], [$Bool], false);
	ptrType$18 = $ptrType(rawConn);
	runtime_args = function() {
		return $pkg.Args;
	};
	init = function() {
		var argv, i, process;
		process = $global.process;
		if (!(process === undefined)) {
			argv = process.argv;
			$pkg.Args = $makeSlice(sliceType, ($parseInt(argv.length) - 1 >> 0));
			i = 0;
			while (true) {
				if (!(i < ($parseInt(argv.length) - 1 >> 0))) { break; }
				((i < 0 || i >= $pkg.Args.$length) ? ($throwRuntimeError("index out of range"), undefined) : $pkg.Args.$array[$pkg.Args.$offset + i] = $internalize(argv[(i + 1 >> 0)], $String));
				i = i + (1) >> 0;
			}
		}
		if ($pkg.Args.$length === 0) {
			$pkg.Args = new sliceType(["?"]);
		}
	};
	runtime_beforeExit = function() {
	};
	File.ptr.prototype.Readdir = function(n) {
		var _r, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		if (f === ptrType.nil) {
			$s = -1; return [sliceType$1.nil, $pkg.ErrInvalid];
		}
		_r = f.readdir(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Readdir }; } $f._r = _r; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Readdir = function(n) { return this.$val.Readdir(n); };
	File.ptr.prototype.Readdirnames = function(n) {
		var _r, _tmp, _tmp$1, _tuple, err, f, n, names, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; err = $f.err; f = $f.f; n = $f.n; names = $f.names; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		names = sliceType.nil;
		err = $ifaceNil;
		f = this;
		if (f === ptrType.nil) {
			_tmp = sliceType.nil;
			_tmp$1 = $pkg.ErrInvalid;
			names = _tmp;
			err = _tmp$1;
			$s = -1; return [names, err];
		}
		_r = f.readdirnames(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		names = _tuple[0];
		err = _tuple[1];
		$s = -1; return [names, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Readdirnames }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.err = err; $f.f = f; $f.n = n; $f.names = names; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Readdirnames = function(n) { return this.$val.Readdirnames(n); };
	dirInfo.ptr.prototype.close = function() {
		var d;
		d = this;
	};
	dirInfo.prototype.close = function() { return this.$val.close(); };
	File.ptr.prototype.readdirnames = function(n) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, d, err, errno, f, n, names, nb, nc, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; d = $f.d; err = $f.err; errno = $f.errno; f = $f.f; n = $f.n; names = $f.names; nb = $f.nb; nc = $f.nc; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		names = sliceType.nil;
		err = $ifaceNil;
		f = this;
		if (f.file.dirinfo === ptrType$1.nil) {
			f.file.dirinfo = new dirInfo.ptr(sliceType$2.nil, 0, 0);
			f.file.dirinfo.buf = $makeSlice(sliceType$2, 8192);
		}
		d = f.file.dirinfo;
		size = n;
		if (size <= 0) {
			size = 100;
			n = -1;
		}
		names = $makeSlice(sliceType, 0, size);
		/* while (true) { */ case 1:
			/* if (!(!((n === 0)))) { break; } */ if(!(!((n === 0)))) { $s = 2; continue; }
			/* */ if (d.bufp >= d.nbuf) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (d.bufp >= d.nbuf) { */ case 3:
				d.bufp = 0;
				errno = $ifaceNil;
				_r = f.file.pfd.ReadDirent(d.buf); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				d.nbuf = _tuple[0];
				errno = _tuple[1];
				runtime.KeepAlive(f);
				if (!($interfaceIsEqual(errno, $ifaceNil))) {
					_tmp = names;
					_tmp$1 = wrapSyscallError("readdirent", errno);
					names = _tmp;
					err = _tmp$1;
					$s = -1; return [names, err];
				}
				if (d.nbuf <= 0) {
					/* break; */ $s = 2; continue;
				}
			/* } */ case 4:
			_tmp$2 = 0;
			_tmp$3 = 0;
			nb = _tmp$2;
			nc = _tmp$3;
			_tuple$1 = syscall.ParseDirent($subslice(d.buf, d.bufp, d.nbuf), n, names);
			nb = _tuple$1[0];
			nc = _tuple$1[1];
			names = _tuple$1[2];
			d.bufp = d.bufp + (nb) >> 0;
			n = n - (nc) >> 0;
		/* } */ $s = 1; continue; case 2:
		if (n >= 0 && (names.$length === 0)) {
			_tmp$4 = names;
			_tmp$5 = io.EOF;
			names = _tmp$4;
			err = _tmp$5;
			$s = -1; return [names, err];
		}
		_tmp$6 = names;
		_tmp$7 = $ifaceNil;
		names = _tmp$6;
		err = _tmp$7;
		$s = -1; return [names, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.readdirnames }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.d = d; $f.err = err; $f.errno = errno; $f.f = f; $f.n = n; $f.names = names; $f.nb = nb; $f.nc = nc; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.readdirnames = function(n) { return this.$val.readdirnames(n); };
	PathError.ptr.prototype.Error = function() {
		var _r, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return e.Op + " " + e.Path + ": " + _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: PathError.ptr.prototype.Error }; } $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	PathError.prototype.Error = function() { return this.$val.Error(); };
	PathError.ptr.prototype.Timeout = function() {
		var _r, _tuple, _v, e, ok, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _v = $f._v; e = $f.e; ok = $f.ok; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_tuple = $assertType(e.Err, timeout, true);
		t = _tuple[0];
		ok = _tuple[1];
		if (!(ok)) { _v = false; $s = 1; continue s; }
		_r = t.Timeout(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_v = _r; case 1:
		$s = -1; return _v;
		/* */ } return; } if ($f === undefined) { $f = { $blk: PathError.ptr.prototype.Timeout }; } $f._r = _r; $f._tuple = _tuple; $f._v = _v; $f.e = e; $f.ok = ok; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	PathError.prototype.Timeout = function() { return this.$val.Timeout(); };
	SyscallError.ptr.prototype.Error = function() {
		var _r, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return e.Syscall + ": " + _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: SyscallError.ptr.prototype.Error }; } $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	SyscallError.prototype.Error = function() { return this.$val.Error(); };
	SyscallError.ptr.prototype.Timeout = function() {
		var _r, _tuple, _v, e, ok, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _v = $f._v; e = $f.e; ok = $f.ok; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_tuple = $assertType(e.Err, timeout, true);
		t = _tuple[0];
		ok = _tuple[1];
		if (!(ok)) { _v = false; $s = 1; continue s; }
		_r = t.Timeout(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_v = _r; case 1:
		$s = -1; return _v;
		/* */ } return; } if ($f === undefined) { $f = { $blk: SyscallError.ptr.prototype.Timeout }; } $f._r = _r; $f._tuple = _tuple; $f._v = _v; $f.e = e; $f.ok = ok; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	SyscallError.prototype.Timeout = function() { return this.$val.Timeout(); };
	NewSyscallError = function(syscall$1, err) {
		var err, syscall$1;
		if ($interfaceIsEqual(err, $ifaceNil)) {
			return $ifaceNil;
		}
		return new SyscallError.ptr(syscall$1, err);
	};
	$pkg.NewSyscallError = NewSyscallError;
	IsNotExist = function(err) {
		var err;
		return isNotExist(err);
	};
	$pkg.IsNotExist = IsNotExist;
	underlyingError = function(err) {
		var _ref, err, err$1, err$2, err$3;
		_ref = err;
		if ($assertType(_ref, ptrType$2, true)[1]) {
			err$1 = _ref.$val;
			return err$1.Err;
		} else if ($assertType(_ref, ptrType$3, true)[1]) {
			err$2 = _ref.$val;
			return err$2.Err;
		} else if ($assertType(_ref, ptrType$4, true)[1]) {
			err$3 = _ref.$val;
			return err$3.Err;
		}
		return err;
	};
	wrapSyscallError = function(name, err) {
		var _tuple, err, name, ok;
		_tuple = $assertType(err, syscall.Errno, true);
		ok = _tuple[1];
		if (ok) {
			err = NewSyscallError(name, err);
		}
		return err;
	};
	isNotExist = function(err) {
		var err;
		err = underlyingError(err);
		return $interfaceIsEqual(err, new syscall.Errno(2)) || $interfaceIsEqual(err, $pkg.ErrNotExist);
	};
	File.ptr.prototype.Name = function() {
		var f;
		f = this;
		return f.file.name;
	};
	File.prototype.Name = function() { return this.$val.Name(); };
	LinkError.ptr.prototype.Error = function() {
		var _r, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return e.Op + " " + e.Old + " " + e.New + ": " + _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: LinkError.ptr.prototype.Error }; } $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	LinkError.prototype.Error = function() { return this.$val.Error(); };
	File.ptr.prototype.Read = function(b) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, err$1, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; err$1 = $f.err$1; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		err$1 = f.checkValid("read");
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = err$1;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		_r = f.read(b); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		e = _tuple[1];
		_tmp$2 = n;
		_tmp$3 = f.wrapErr("read", e);
		n = _tmp$2;
		err = _tmp$3;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Read }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Read = function(b) { return this.$val.Read(b); };
	File.ptr.prototype.ReadAt = function(b, off) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, err$1, f, m, n, off, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; err$1 = $f.err$1; f = $f.f; m = $f.m; n = $f.n; off = $f.off; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		err$1 = f.checkValid("read");
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = err$1;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		if ((off.$high < 0 || (off.$high === 0 && off.$low < 0))) {
			_tmp$2 = 0;
			_tmp$3 = new PathError.ptr("readat", f.file.name, errors.New("negative offset"));
			n = _tmp$2;
			err = _tmp$3;
			$s = -1; return [n, err];
		}
		/* while (true) { */ case 1:
			/* if (!(b.$length > 0)) { break; } */ if(!(b.$length > 0)) { $s = 2; continue; }
			_r = f.pread(b, off); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				err = f.wrapErr("read", e);
				/* break; */ $s = 2; continue;
			}
			n = n + (m) >> 0;
			b = $subslice(b, m);
			off = (x = (new $Int64(0, m)), new $Int64(off.$high + x.$high, off.$low + x.$low));
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.ReadAt }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.m = m; $f.n = n; $f.off = off; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.ReadAt = function(b, off) { return this.$val.ReadAt(b, off); };
	File.ptr.prototype.Write = function(b) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, err$1, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; err$1 = $f.err$1; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		err$1 = f.checkValid("write");
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = err$1;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		_r = f.write(b); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		e = _tuple[1];
		if (n < 0) {
			n = 0;
		}
		if (!((n === b.$length))) {
			err = io.ErrShortWrite;
		}
		epipecheck(f, e);
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			err = f.wrapErr("write", e);
		}
		_tmp$2 = n;
		_tmp$3 = err;
		n = _tmp$2;
		err = _tmp$3;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Write }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Write = function(b) { return this.$val.Write(b); };
	File.ptr.prototype.WriteAt = function(b, off) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, err$1, f, m, n, off, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; err$1 = $f.err$1; f = $f.f; m = $f.m; n = $f.n; off = $f.off; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		err$1 = f.checkValid("write");
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = err$1;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		if ((off.$high < 0 || (off.$high === 0 && off.$low < 0))) {
			_tmp$2 = 0;
			_tmp$3 = new PathError.ptr("writeat", f.file.name, errors.New("negative offset"));
			n = _tmp$2;
			err = _tmp$3;
			$s = -1; return [n, err];
		}
		/* while (true) { */ case 1:
			/* if (!(b.$length > 0)) { break; } */ if(!(b.$length > 0)) { $s = 2; continue; }
			_r = f.pwrite(b, off); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				err = f.wrapErr("write", e);
				/* break; */ $s = 2; continue;
			}
			n = n + (m) >> 0;
			b = $subslice(b, m);
			off = (x = (new $Int64(0, m)), new $Int64(off.$high + x.$high, off.$low + x.$low));
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.WriteAt }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.m = m; $f.n = n; $f.off = off; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.WriteAt = function(b, off) { return this.$val.WriteAt(b, off); };
	File.ptr.prototype.Seek = function(offset, whence) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, e, err, err$1, f, offset, r, ret, whence, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; e = $f.e; err = $f.err; err$1 = $f.err$1; f = $f.f; offset = $f.offset; r = $f.r; ret = $f.ret; whence = $f.whence; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = new $Int64(0, 0);
		err = $ifaceNil;
		f = this;
		err$1 = f.checkValid("seek");
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			_tmp = new $Int64(0, 0);
			_tmp$1 = err$1;
			ret = _tmp;
			err = _tmp$1;
			$s = -1; return [ret, err];
		}
		_r = f.seek(offset, whence); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		e = _tuple[1];
		if ($interfaceIsEqual(e, $ifaceNil) && !(f.file.dirinfo === ptrType$1.nil) && !((r.$high === 0 && r.$low === 0))) {
			e = new syscall.Errno(21);
		}
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			_tmp$2 = new $Int64(0, 0);
			_tmp$3 = f.wrapErr("seek", e);
			ret = _tmp$2;
			err = _tmp$3;
			$s = -1; return [ret, err];
		}
		_tmp$4 = r;
		_tmp$5 = $ifaceNil;
		ret = _tmp$4;
		err = _tmp$5;
		$s = -1; return [ret, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Seek }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.e = e; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.offset = offset; $f.r = r; $f.ret = ret; $f.whence = whence; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Seek = function(offset, whence) { return this.$val.Seek(offset, whence); };
	File.ptr.prototype.WriteString = function(s) {
		var _r, _tuple, err, f, n, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; f = $f.f; n = $f.n; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		_r = f.Write((new sliceType$2($stringToBytes(s)))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.WriteString }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.f = f; $f.n = n; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	File.ptr.prototype.wrapErr = function(op, err) {
		var err, f, op;
		f = this;
		if ($interfaceIsEqual(err, $ifaceNil) || $interfaceIsEqual(err, io.EOF)) {
			return err;
		}
		if ($interfaceIsEqual(err, poll.ErrFileClosing)) {
			err = $pkg.ErrClosed;
		}
		return new PathError.ptr(op, f.file.name, err);
	};
	File.prototype.wrapErr = function(op, err) { return this.$val.wrapErr(op, err); };
	File.ptr.prototype.Chmod = function(mode) {
		var _r, f, mode, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; mode = $f.mode; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		_r = f.chmod(mode); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Chmod }; } $f._r = _r; $f.f = f; $f.mode = mode; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Chmod = function(mode) { return this.$val.Chmod(mode); };
	File.ptr.prototype.SetDeadline = function(t) {
		var f, t;
		f = this;
		return f.setDeadline($clone(t, time.Time));
	};
	File.prototype.SetDeadline = function(t) { return this.$val.SetDeadline(t); };
	File.ptr.prototype.SetReadDeadline = function(t) {
		var f, t;
		f = this;
		return f.setReadDeadline($clone(t, time.Time));
	};
	File.prototype.SetReadDeadline = function(t) { return this.$val.SetReadDeadline(t); };
	File.ptr.prototype.SetWriteDeadline = function(t) {
		var f, t;
		f = this;
		return f.setWriteDeadline($clone(t, time.Time));
	};
	File.prototype.SetWriteDeadline = function(t) { return this.$val.SetWriteDeadline(t); };
	File.ptr.prototype.SyscallConn = function() {
		var _returncast, err, f;
		f = this;
		err = f.checkValid("SyscallConn");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [$ifaceNil, err];
		}
		_returncast = newRawConn(f);
		return [_returncast[0], _returncast[1]];
	};
	File.prototype.SyscallConn = function() { return this.$val.SyscallConn(); };
	sigpipe = function() {
		$throwRuntimeError("native function not implemented: os.sigpipe");
	};
	syscallMode = function(i) {
		var i, o;
		o = 0;
		o = (o | (((new FileMode(i).Perm() >>> 0)))) >>> 0;
		if (!((((i & 8388608) >>> 0) === 0))) {
			o = (o | (2048)) >>> 0;
		}
		if (!((((i & 4194304) >>> 0) === 0))) {
			o = (o | (1024)) >>> 0;
		}
		if (!((((i & 1048576) >>> 0) === 0))) {
			o = (o | (512)) >>> 0;
		}
		return o;
	};
	File.ptr.prototype.chmod = function(mode) {
		var _r, e, err, f, mode, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; f = $f.f; mode = $f.mode; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		err = f.checkValid("chmod");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = f.file.pfd.Fchmod(syscallMode(mode)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			$s = -1; return f.wrapErr("chmod", e);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.chmod }; } $f._r = _r; $f.e = e; $f.err = err; $f.f = f; $f.mode = mode; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.chmod = function(mode) { return this.$val.chmod(mode); };
	File.ptr.prototype.Chown = function(uid, gid) {
		var _r, e, err, f, gid, uid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; f = $f.f; gid = $f.gid; uid = $f.uid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		err = f.checkValid("chown");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = f.file.pfd.Fchown(uid, gid); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			$s = -1; return f.wrapErr("chown", e);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Chown }; } $f._r = _r; $f.e = e; $f.err = err; $f.f = f; $f.gid = gid; $f.uid = uid; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Chown = function(uid, gid) { return this.$val.Chown(uid, gid); };
	File.ptr.prototype.Truncate = function(size) {
		var _r, e, err, f, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; f = $f.f; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		err = f.checkValid("truncate");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = f.file.pfd.Ftruncate(size); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			$s = -1; return f.wrapErr("truncate", e);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Truncate }; } $f._r = _r; $f.e = e; $f.err = err; $f.f = f; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Truncate = function(size) { return this.$val.Truncate(size); };
	File.ptr.prototype.Sync = function() {
		var _r, e, err, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		err = f.checkValid("sync");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = f.file.pfd.Fsync(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			$s = -1; return f.wrapErr("sync", e);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Sync }; } $f._r = _r; $f.e = e; $f.err = err; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Sync = function() { return this.$val.Sync(); };
	File.ptr.prototype.Chdir = function() {
		var _r, e, err, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		err = f.checkValid("chdir");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = f.file.pfd.Fchdir(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			$s = -1; return f.wrapErr("chdir", e);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Chdir }; } $f._r = _r; $f.e = e; $f.err = err; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Chdir = function() { return this.$val.Chdir(); };
	File.ptr.prototype.setDeadline = function(t) {
		var err, f, t;
		f = this;
		err = f.checkValid("SetDeadline");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return err;
		}
		return f.file.pfd.SetDeadline($clone(t, time.Time));
	};
	File.prototype.setDeadline = function(t) { return this.$val.setDeadline(t); };
	File.ptr.prototype.setReadDeadline = function(t) {
		var err, f, t;
		f = this;
		err = f.checkValid("SetReadDeadline");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return err;
		}
		return f.file.pfd.SetReadDeadline($clone(t, time.Time));
	};
	File.prototype.setReadDeadline = function(t) { return this.$val.setReadDeadline(t); };
	File.ptr.prototype.setWriteDeadline = function(t) {
		var err, f, t;
		f = this;
		err = f.checkValid("SetWriteDeadline");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return err;
		}
		return f.file.pfd.SetWriteDeadline($clone(t, time.Time));
	};
	File.prototype.setWriteDeadline = function(t) { return this.$val.setWriteDeadline(t); };
	File.ptr.prototype.checkValid = function(op) {
		var f, op;
		f = this;
		if (f === ptrType.nil) {
			return $pkg.ErrInvalid;
		}
		return $ifaceNil;
	};
	File.prototype.checkValid = function(op) { return this.$val.checkValid(op); };
	File.ptr.prototype.Fd = function() {
		var _r, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		if (f === ptrType.nil) {
			$s = -1; return 4294967295;
		}
		/* */ if (f.file.nonblock) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (f.file.nonblock) { */ case 1:
			_r = f.file.pfd.SetBlocking(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
		/* } */ case 2:
		$s = -1; return ((f.file.pfd.Sysfd >>> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Fd }; } $f._r = _r; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Fd = function() { return this.$val.Fd(); };
	NewFile = function(fd, name) {
		var _tuple, err, fd, kind, name, nb;
		kind = 0;
		_tuple = unix.IsNonblock(((fd >> 0)));
		nb = _tuple[0];
		err = _tuple[1];
		if ($interfaceIsEqual(err, $ifaceNil) && nb) {
			kind = 3;
		}
		return newFile(fd, name, kind);
	};
	$pkg.NewFile = NewFile;
	newFile = function(fd, name, kind) {
		var _1, err, err$1, err$2, err$3, f, fd, fdi, kind, name, pollable, st;
		fdi = ((fd >> 0));
		if (fdi < 0) {
			return ptrType.nil;
		}
		f = new File.ptr(new file.ptr(new poll.FD.ptr(new poll.fdMutex.ptr(new $Uint64(0, 0), 0, 0), fdi, new poll.pollDesc.ptr(false), ptrType$12.nil, 0, 0, true, true, false), name, ptrType$1.nil, false, (fdi === 1) || (fdi === 2)));
		pollable = (kind === 1) || (kind === 2) || (kind === 3);
		if (kind === 1) {
			st = new syscall.Stat_t.ptr(new $Uint64(0, 0), new $Uint64(0, 0), new $Uint64(0, 0), 0, 0, 0, 0, new $Uint64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), arrayType$1.zero());
			_1 = "linux";
			if (_1 === ("freebsd")) {
				pollable = false;
			} else if (_1 === ("dragonfly") || _1 === ("netbsd") || _1 === ("openbsd")) {
				err = syscall.Fstat(fdi, st);
				if ($interfaceIsEqual(err, $ifaceNil) && (((st.Mode & 61440) >>> 0) === 32768)) {
					pollable = false;
				}
			} else if (_1 === ("darwin")) {
				err$1 = syscall.Fstat(fdi, st);
				if ($interfaceIsEqual(err$1, $ifaceNil) && ((((st.Mode & 61440) >>> 0) === 4096) || (((st.Mode & 61440) >>> 0) === 32768))) {
					pollable = false;
				}
			}
		}
		err$2 = f.file.pfd.Init("file", pollable);
		if (!($interfaceIsEqual(err$2, $ifaceNil))) {
		} else if (pollable) {
			err$3 = syscall.SetNonblock(fdi, true);
			if ($interfaceIsEqual(err$3, $ifaceNil)) {
				f.file.nonblock = true;
			}
		}
		runtime.SetFinalizer(f.file, new funcType$1($methodExpr(ptrType$13, "close")));
		return f;
	};
	epipecheck = function(file$1, e) {
		var e, file$1;
		if ($interfaceIsEqual(e, new syscall.Errno(32)) && file$1.file.stdoutOrErr) {
			sigpipe();
		}
	};
	File.ptr.prototype.Close = function() {
		var _r, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		if (f === ptrType.nil) {
			$s = -1; return $pkg.ErrInvalid;
		}
		_r = f.file.close(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Close }; } $f._r = _r; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Close = function() { return this.$val.Close(); };
	file.ptr.prototype.close = function() {
		var _r, e, err, file$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; err = $f.err; file$1 = $f.file$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		file$1 = this;
		if (file$1 === ptrType$13.nil) {
			$s = -1; return new syscall.Errno(22);
		}
		if (!(file$1.dirinfo === ptrType$1.nil)) {
			file$1.dirinfo.close();
		}
		err = $ifaceNil;
		_r = file$1.pfd.Close(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		e = _r;
		if (!($interfaceIsEqual(e, $ifaceNil))) {
			if ($interfaceIsEqual(e, poll.ErrFileClosing)) {
				e = $pkg.ErrClosed;
			}
			err = new PathError.ptr("close", file$1.name, e);
		}
		runtime.SetFinalizer(file$1, $ifaceNil);
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: file.ptr.prototype.close }; } $f._r = _r; $f.e = e; $f.err = err; $f.file$1 = file$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	file.prototype.close = function() { return this.$val.close(); };
	File.ptr.prototype.read = function(b) {
		var _r, _tmp, _tmp$1, _tuple, b, err, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		_r = f.file.pfd.Read(b); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		runtime.KeepAlive(f);
		_tmp = n;
		_tmp$1 = err;
		n = _tmp;
		err = _tmp$1;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.read }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.read = function(b) { return this.$val.read(b); };
	File.ptr.prototype.pread = function(b, off) {
		var _r, _tmp, _tmp$1, _tuple, b, err, f, n, off, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; f = $f.f; n = $f.n; off = $f.off; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		_r = f.file.pfd.Pread(b, off); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		runtime.KeepAlive(f);
		_tmp = n;
		_tmp$1 = err;
		n = _tmp;
		err = _tmp$1;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.pread }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.f = f; $f.n = n; $f.off = off; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.pread = function(b, off) { return this.$val.pread(b, off); };
	File.ptr.prototype.write = function(b) {
		var _r, _tmp, _tmp$1, _tuple, b, err, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		_r = f.file.pfd.Write(b); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		runtime.KeepAlive(f);
		_tmp = n;
		_tmp$1 = err;
		n = _tmp;
		err = _tmp$1;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.write }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.write = function(b) { return this.$val.write(b); };
	File.ptr.prototype.pwrite = function(b, off) {
		var _r, _tmp, _tmp$1, _tuple, b, err, f, n, off, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; f = $f.f; n = $f.n; off = $f.off; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		f = this;
		_r = f.file.pfd.Pwrite(b, off); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		runtime.KeepAlive(f);
		_tmp = n;
		_tmp$1 = err;
		n = _tmp;
		err = _tmp$1;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.pwrite }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.f = f; $f.n = n; $f.off = off; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.pwrite = function(b, off) { return this.$val.pwrite(b, off); };
	File.ptr.prototype.seek = function(offset, whence) {
		var _r, _tmp, _tmp$1, _tuple, err, f, offset, ret, whence, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; err = $f.err; f = $f.f; offset = $f.offset; ret = $f.ret; whence = $f.whence; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = new $Int64(0, 0);
		err = $ifaceNil;
		f = this;
		_r = f.file.pfd.Seek(offset, whence); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		ret = _tuple[0];
		err = _tuple[1];
		runtime.KeepAlive(f);
		_tmp = ret;
		_tmp$1 = err;
		ret = _tmp;
		err = _tmp$1;
		$s = -1; return [ret, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.seek }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.err = err; $f.f = f; $f.offset = offset; $f.ret = ret; $f.whence = whence; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.seek = function(offset, whence) { return this.$val.seek(offset, whence); };
	File.ptr.prototype.readdir = function(n) {
		var _i, _r, _r$1, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _tuple$1, dirname, err, f, fi, filename, fip, lerr, n, names, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; dirname = $f.dirname; err = $f.err; f = $f.f; fi = $f.fi; filename = $f.filename; fip = $f.fip; lerr = $f.lerr; n = $f.n; names = $f.names; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fi = sliceType$1.nil;
		err = $ifaceNil;
		f = this;
		dirname = f.file.name;
		if (dirname === "") {
			dirname = ".";
		}
		_r = f.Readdirnames(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		names = _tuple[0];
		err = _tuple[1];
		fi = $makeSlice(sliceType$1, 0, names.$length);
		_ref = names;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			filename = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r$1 = lstat(dirname + "/" + filename); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			fip = _tuple$1[0];
			lerr = _tuple$1[1];
			if (IsNotExist(lerr)) {
				_i++;
				/* continue; */ $s = 2; continue;
			}
			if (!($interfaceIsEqual(lerr, $ifaceNil))) {
				_tmp = fi;
				_tmp$1 = lerr;
				fi = _tmp;
				err = _tmp$1;
				$s = -1; return [fi, err];
			}
			fi = $append(fi, fip);
			_i++;
		/* } */ $s = 2; continue; case 3:
		if ((fi.$length === 0) && $interfaceIsEqual(err, $ifaceNil) && n > 0) {
			err = io.EOF;
		}
		_tmp$2 = fi;
		_tmp$3 = err;
		fi = _tmp$2;
		err = _tmp$3;
		$s = -1; return [fi, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.readdir }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.dirname = dirname; $f.err = err; $f.f = f; $f.fi = fi; $f.filename = filename; $f.fip = fip; $f.lerr = lerr; $f.n = n; $f.names = names; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.readdir = function(n) { return this.$val.readdir(n); };
	basename = function(name) {
		var i, name;
		i = name.length - 1 >> 0;
		while (true) {
			if (!(i > 0 && (name.charCodeAt(i) === 47))) { break; }
			name = $substring(name, 0, i);
			i = i - (1) >> 0;
		}
		i = i - (1) >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if (name.charCodeAt(i) === 47) {
				name = $substring(name, (i + 1 >> 0));
				break;
			}
			i = i - (1) >> 0;
		}
		return name;
	};
	init$1 = function() {
		if (false) {
			return;
		}
		$pkg.Args = runtime_args();
	};
	Exit = function(code) {
		var code;
		if (code === 0) {
			runtime_beforeExit();
		}
		syscall.Exit(code);
	};
	$pkg.Exit = Exit;
	rawConn.ptr.prototype.Control = function(f) {
		var _r, c, err, err$1, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; err = $f.err; err$1 = $f.err$1; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		err = c.file.checkValid("SyscallConn.Control");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = c.file.file.pfd.RawControl(f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err$1 = _r;
		runtime.KeepAlive(c.file);
		$s = -1; return err$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rawConn.ptr.prototype.Control }; } $f._r = _r; $f.c = c; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	rawConn.prototype.Control = function(f) { return this.$val.Control(f); };
	rawConn.ptr.prototype.Read = function(f) {
		var _r, c, err, err$1, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; err = $f.err; err$1 = $f.err$1; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		err = c.file.checkValid("SyscallConn.Read");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = c.file.file.pfd.RawRead(f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err$1 = _r;
		runtime.KeepAlive(c.file);
		$s = -1; return err$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rawConn.ptr.prototype.Read }; } $f._r = _r; $f.c = c; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	rawConn.prototype.Read = function(f) { return this.$val.Read(f); };
	rawConn.ptr.prototype.Write = function(f) {
		var _r, c, err, err$1, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; err = $f.err; err$1 = $f.err$1; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		err = c.file.checkValid("SyscallConn.Write");
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r = c.file.file.pfd.RawWrite(f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err$1 = _r;
		runtime.KeepAlive(c.file);
		$s = -1; return err$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: rawConn.ptr.prototype.Write }; } $f._r = _r; $f.c = c; $f.err = err; $f.err$1 = err$1; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	rawConn.prototype.Write = function(f) { return this.$val.Write(f); };
	newRawConn = function(file$1) {
		var file$1;
		return [new rawConn.ptr(file$1), $ifaceNil];
	};
	Lstat = function(name) {
		var name, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; name = $f.name; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = testlog.Stat(name); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return lstatNolog(name);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lstat }; } $f.name = name; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Lstat = Lstat;
	fillFileStatFromSys = function(fs, name) {
		var _1, fs, name;
		fs.name = basename(name);
		fs.size = fs.sys.Size;
		time.Time.copy(fs.modTime, timespecToTime($clone(fs.sys.Mtim, syscall.Timespec)));
		fs.mode = ((((fs.sys.Mode & 511) >>> 0) >>> 0));
		_1 = (fs.sys.Mode & 61440) >>> 0;
		if (_1 === (24576)) {
			fs.mode = (fs.mode | (67108864)) >>> 0;
		} else if (_1 === (8192)) {
			fs.mode = (fs.mode | (69206016)) >>> 0;
		} else if (_1 === (16384)) {
			fs.mode = (fs.mode | (2147483648)) >>> 0;
		} else if (_1 === (4096)) {
			fs.mode = (fs.mode | (33554432)) >>> 0;
		} else if (_1 === (40960)) {
			fs.mode = (fs.mode | (134217728)) >>> 0;
		} else if (_1 === (32768)) {
		} else if (_1 === (49152)) {
			fs.mode = (fs.mode | (16777216)) >>> 0;
		}
		if (!((((fs.sys.Mode & 1024) >>> 0) === 0))) {
			fs.mode = (fs.mode | (4194304)) >>> 0;
		}
		if (!((((fs.sys.Mode & 2048) >>> 0) === 0))) {
			fs.mode = (fs.mode | (8388608)) >>> 0;
		}
		if (!((((fs.sys.Mode & 512) >>> 0) === 0))) {
			fs.mode = (fs.mode | (1048576)) >>> 0;
		}
	};
	timespecToTime = function(ts) {
		var ts;
		return time.Unix((ts.Sec), (ts.Nsec));
	};
	File.ptr.prototype.Stat = function() {
		var _r, err, f, fs, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; f = $f.f; fs = $f.fs; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		fs = [fs];
		f = this;
		if (f === ptrType.nil) {
			$s = -1; return [$ifaceNil, $pkg.ErrInvalid];
		}
		fs[0] = new fileStat.ptr("", new $Int64(0, 0), 0, new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$15.nil), new syscall.Stat_t.ptr(new $Uint64(0, 0), new $Uint64(0, 0), new $Uint64(0, 0), 0, 0, 0, 0, new $Uint64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), arrayType$1.zero()));
		_r = f.file.pfd.Fstat(fs[0].sys); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [$ifaceNil, new PathError.ptr("stat", f.file.name, err)];
		}
		fillFileStatFromSys(fs[0], f.file.name);
		$s = -1; return [fs[0], $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Stat }; } $f._r = _r; $f.err = err; $f.f = f; $f.fs = fs; $f.$s = $s; $f.$r = $r; return $f;
	};
	File.prototype.Stat = function() { return this.$val.Stat(); };
	lstatNolog = function(name) {
		var err, fs, name;
		fs = new fileStat.ptr("", new $Int64(0, 0), 0, new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$15.nil), new syscall.Stat_t.ptr(new $Uint64(0, 0), new $Uint64(0, 0), new $Uint64(0, 0), 0, 0, 0, 0, new $Uint64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new $Int64(0, 0), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), arrayType$1.zero()));
		err = syscall.Lstat(name, fs.sys);
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			return [$ifaceNil, new PathError.ptr("lstat", name, err)];
		}
		fillFileStatFromSys(fs, name);
		return [fs, $ifaceNil];
	};
	FileMode.prototype.String = function() {
		var _i, _i$1, _ref, _ref$1, _rune, _rune$1, buf, c, c$1, i, i$1, m, w, y, y$1;
		m = this.$val;
		buf = arrayType$6.zero();
		w = 0;
		_ref = "dalTLDpSugct?";
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			c = _rune[0];
			if (!((((m & (((y = (((31 - i >> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0) === 0))) {
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = ((c << 24 >>> 24)));
				w = w + (1) >> 0;
			}
			_i += _rune[1];
		}
		if (w === 0) {
			((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 45);
			w = w + (1) >> 0;
		}
		_ref$1 = "rwxrwxrwx";
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.length)) { break; }
			_rune$1 = $decodeRune(_ref$1, _i$1);
			i$1 = _i$1;
			c$1 = _rune$1[0];
			if (!((((m & (((y$1 = (((8 - i$1 >> 0) >>> 0)), y$1 < 32 ? (1 << y$1) : 0) >>> 0))) >>> 0) === 0))) {
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = ((c$1 << 24 >>> 24)));
			} else {
				((w < 0 || w >= buf.length) ? ($throwRuntimeError("index out of range"), undefined) : buf[w] = 45);
			}
			w = w + (1) >> 0;
			_i$1 += _rune$1[1];
		}
		return ($bytesToString($subslice(new sliceType$2(buf), 0, w)));
	};
	$ptrType(FileMode).prototype.String = function() { return new FileMode(this.$get()).String(); };
	FileMode.prototype.IsDir = function() {
		var m;
		m = this.$val;
		return !((((m & 2147483648) >>> 0) === 0));
	};
	$ptrType(FileMode).prototype.IsDir = function() { return new FileMode(this.$get()).IsDir(); };
	FileMode.prototype.IsRegular = function() {
		var m;
		m = this.$val;
		return ((m & 2401763328) >>> 0) === 0;
	};
	$ptrType(FileMode).prototype.IsRegular = function() { return new FileMode(this.$get()).IsRegular(); };
	FileMode.prototype.Perm = function() {
		var m;
		m = this.$val;
		return (m & 511) >>> 0;
	};
	$ptrType(FileMode).prototype.Perm = function() { return new FileMode(this.$get()).Perm(); };
	fileStat.ptr.prototype.Name = function() {
		var fs;
		fs = this;
		return fs.name;
	};
	fileStat.prototype.Name = function() { return this.$val.Name(); };
	fileStat.ptr.prototype.IsDir = function() {
		var fs;
		fs = this;
		return new FileMode(fs.Mode()).IsDir();
	};
	fileStat.prototype.IsDir = function() { return this.$val.IsDir(); };
	fileStat.ptr.prototype.Size = function() {
		var fs;
		fs = this;
		return fs.size;
	};
	fileStat.prototype.Size = function() { return this.$val.Size(); };
	fileStat.ptr.prototype.Mode = function() {
		var fs;
		fs = this;
		return fs.mode;
	};
	fileStat.prototype.Mode = function() { return this.$val.Mode(); };
	fileStat.ptr.prototype.ModTime = function() {
		var fs;
		fs = this;
		return fs.modTime;
	};
	fileStat.prototype.ModTime = function() { return this.$val.ModTime(); };
	fileStat.ptr.prototype.Sys = function() {
		var fs;
		fs = this;
		return fs.sys;
	};
	fileStat.prototype.Sys = function() { return this.$val.Sys(); };
	ptrType$1.methods = [{prop: "close", name: "close", pkg: "os", typ: $funcType([], [], false)}];
	ptrType$2.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Timeout", name: "Timeout", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$4.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Timeout", name: "Timeout", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$3.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$13.methods = [{prop: "close", name: "close", pkg: "os", typ: $funcType([], [$error], false)}];
	ptrType$18.methods = [{prop: "Control", name: "Control", pkg: "", typ: $funcType([funcType$2], [$error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([funcType$3], [$error], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([funcType$3], [$error], false)}];
	ptrType.methods = [{prop: "Readdir", name: "Readdir", pkg: "", typ: $funcType([$Int], [sliceType$1, $error], false)}, {prop: "Readdirnames", name: "Readdirnames", pkg: "", typ: $funcType([$Int], [sliceType, $error], false)}, {prop: "readdirnames", name: "readdirnames", pkg: "os", typ: $funcType([$Int], [sliceType, $error], false)}, {prop: "Name", name: "Name", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "ReadAt", name: "ReadAt", pkg: "", typ: $funcType([sliceType$2, $Int64], [$Int, $error], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "WriteAt", name: "WriteAt", pkg: "", typ: $funcType([sliceType$2, $Int64], [$Int, $error], false)}, {prop: "Seek", name: "Seek", pkg: "", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}, {prop: "wrapErr", name: "wrapErr", pkg: "os", typ: $funcType([$String, $error], [$error], false)}, {prop: "Chmod", name: "Chmod", pkg: "", typ: $funcType([FileMode], [$error], false)}, {prop: "SetDeadline", name: "SetDeadline", pkg: "", typ: $funcType([time.Time], [$error], false)}, {prop: "SetReadDeadline", name: "SetReadDeadline", pkg: "", typ: $funcType([time.Time], [$error], false)}, {prop: "SetWriteDeadline", name: "SetWriteDeadline", pkg: "", typ: $funcType([time.Time], [$error], false)}, {prop: "SyscallConn", name: "SyscallConn", pkg: "", typ: $funcType([], [syscall.RawConn, $error], false)}, {prop: "chmod", name: "chmod", pkg: "os", typ: $funcType([FileMode], [$error], false)}, {prop: "Chown", name: "Chown", pkg: "", typ: $funcType([$Int, $Int], [$error], false)}, {prop: "Truncate", name: "Truncate", pkg: "", typ: $funcType([$Int64], [$error], false)}, {prop: "Sync", name: "Sync", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Chdir", name: "Chdir", pkg: "", typ: $funcType([], [$error], false)}, {prop: "setDeadline", name: "setDeadline", pkg: "os", typ: $funcType([time.Time], [$error], false)}, {prop: "setReadDeadline", name: "setReadDeadline", pkg: "os", typ: $funcType([time.Time], [$error], false)}, {prop: "setWriteDeadline", name: "setWriteDeadline", pkg: "os", typ: $funcType([time.Time], [$error], false)}, {prop: "checkValid", name: "checkValid", pkg: "os", typ: $funcType([$String], [$error], false)}, {prop: "Fd", name: "Fd", pkg: "", typ: $funcType([], [$Uintptr], false)}, {prop: "Close", name: "Close", pkg: "", typ: $funcType([], [$error], false)}, {prop: "read", name: "read", pkg: "os", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "pread", name: "pread", pkg: "os", typ: $funcType([sliceType$2, $Int64], [$Int, $error], false)}, {prop: "write", name: "write", pkg: "os", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "pwrite", name: "pwrite", pkg: "os", typ: $funcType([sliceType$2, $Int64], [$Int, $error], false)}, {prop: "seek", name: "seek", pkg: "os", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "readdir", name: "readdir", pkg: "os", typ: $funcType([$Int], [sliceType$1, $error], false)}, {prop: "Stat", name: "Stat", pkg: "", typ: $funcType([], [FileInfo, $error], false)}];
	FileMode.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "IsDir", name: "IsDir", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "IsRegular", name: "IsRegular", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Perm", name: "Perm", pkg: "", typ: $funcType([], [FileMode], false)}];
	ptrType$16.methods = [{prop: "Name", name: "Name", pkg: "", typ: $funcType([], [$String], false)}, {prop: "IsDir", name: "IsDir", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Mode", name: "Mode", pkg: "", typ: $funcType([], [FileMode], false)}, {prop: "ModTime", name: "ModTime", pkg: "", typ: $funcType([], [time.Time], false)}, {prop: "Sys", name: "Sys", pkg: "", typ: $funcType([], [$emptyInterface], false)}];
	dirInfo.init("os", [{prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "nbuf", name: "nbuf", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "bufp", name: "bufp", embedded: false, exported: false, typ: $Int, tag: ""}]);
	timeout.init([{prop: "Timeout", name: "Timeout", pkg: "", typ: $funcType([], [$Bool], false)}]);
	PathError.init("", [{prop: "Op", name: "Op", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Path", name: "Path", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Err", name: "Err", embedded: false, exported: true, typ: $error, tag: ""}]);
	SyscallError.init("", [{prop: "Syscall", name: "Syscall", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Err", name: "Err", embedded: false, exported: true, typ: $error, tag: ""}]);
	LinkError.init("", [{prop: "Op", name: "Op", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Old", name: "Old", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "New", name: "New", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Err", name: "Err", embedded: false, exported: true, typ: $error, tag: ""}]);
	file.init("os", [{prop: "pfd", name: "pfd", embedded: false, exported: false, typ: poll.FD, tag: ""}, {prop: "name", name: "name", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "dirinfo", name: "dirinfo", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "nonblock", name: "nonblock", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "stdoutOrErr", name: "stdoutOrErr", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	rawConn.init("os", [{prop: "file", name: "file", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	File.init("os", [{prop: "file", name: "file", embedded: true, exported: false, typ: ptrType$13, tag: ""}]);
	FileInfo.init([{prop: "IsDir", name: "IsDir", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "ModTime", name: "ModTime", pkg: "", typ: $funcType([], [time.Time], false)}, {prop: "Mode", name: "Mode", pkg: "", typ: $funcType([], [FileMode], false)}, {prop: "Name", name: "Name", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Sys", name: "Sys", pkg: "", typ: $funcType([], [$emptyInterface], false)}]);
	fileStat.init("os", [{prop: "name", name: "name", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "size", name: "size", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "mode", name: "mode", embedded: false, exported: false, typ: FileMode, tag: ""}, {prop: "modTime", name: "modTime", embedded: false, exported: false, typ: time.Time, tag: ""}, {prop: "sys", name: "sys", embedded: false, exported: false, typ: syscall.Stat_t, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = poll.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unix.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = testlog.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = syscall.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.Args = sliceType.nil;
		$pkg.ErrInvalid = errors.New("invalid argument");
		$pkg.ErrPermission = errors.New("permission denied");
		$pkg.ErrExist = errors.New("file already exists");
		$pkg.ErrNotExist = errors.New("file does not exist");
		$pkg.ErrClosed = errors.New("file already closed");
		errFinished = errors.New("os: process already finished");
		$pkg.Stdin = NewFile(((syscall.Stdin >>> 0)), "/dev/stdin");
		$pkg.Stdout = NewFile(((syscall.Stdout >>> 0)), "/dev/stdout");
		$pkg.Stderr = NewFile(((syscall.Stderr >>> 0)), "/dev/stderr");
		lstat = Lstat;
		init();
		init$1();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["fmt"] = (function() {
	var $pkg = {}, $init, errors, fmtsort, io, math, os, reflect, strconv, sync, utf8, fmtFlags, fmt, State, Formatter, Stringer, GoStringer, buffer, pp, scanError, ss, ssave, sliceType, ptrType, ptrType$1, arrayType, arrayType$1, sliceType$1, sliceType$2, arrayType$2, ptrType$2, ptrType$5, ptrType$25, funcType, ppFree, space, ssFree, complexError, boolError, newPrinter, Fprintf, Printf, Sprintf, Errorf, Sprint, Fprintln, Println, Sprintln, getField, tooLarge, parsenum, intFromArg, parseArgNumber, isSpace, notSpace, indexRune;
	errors = $packages["errors"];
	fmtsort = $packages["internal/fmtsort"];
	io = $packages["io"];
	math = $packages["math"];
	os = $packages["os"];
	reflect = $packages["reflect"];
	strconv = $packages["strconv"];
	sync = $packages["sync"];
	utf8 = $packages["unicode/utf8"];
	fmtFlags = $pkg.fmtFlags = $newType(0, $kindStruct, "fmt.fmtFlags", true, "fmt", false, function(widPresent_, precPresent_, minus_, plus_, sharp_, space_, zero_, plusV_, sharpV_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.widPresent = false;
			this.precPresent = false;
			this.minus = false;
			this.plus = false;
			this.sharp = false;
			this.space = false;
			this.zero = false;
			this.plusV = false;
			this.sharpV = false;
			return;
		}
		this.widPresent = widPresent_;
		this.precPresent = precPresent_;
		this.minus = minus_;
		this.plus = plus_;
		this.sharp = sharp_;
		this.space = space_;
		this.zero = zero_;
		this.plusV = plusV_;
		this.sharpV = sharpV_;
	});
	fmt = $pkg.fmt = $newType(0, $kindStruct, "fmt.fmt", true, "fmt", false, function(buf_, fmtFlags_, wid_, prec_, intbuf_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = ptrType$1.nil;
			this.fmtFlags = new fmtFlags.ptr(false, false, false, false, false, false, false, false, false);
			this.wid = 0;
			this.prec = 0;
			this.intbuf = arrayType.zero();
			return;
		}
		this.buf = buf_;
		this.fmtFlags = fmtFlags_;
		this.wid = wid_;
		this.prec = prec_;
		this.intbuf = intbuf_;
	});
	State = $pkg.State = $newType(8, $kindInterface, "fmt.State", true, "fmt", true, null);
	Formatter = $pkg.Formatter = $newType(8, $kindInterface, "fmt.Formatter", true, "fmt", true, null);
	Stringer = $pkg.Stringer = $newType(8, $kindInterface, "fmt.Stringer", true, "fmt", true, null);
	GoStringer = $pkg.GoStringer = $newType(8, $kindInterface, "fmt.GoStringer", true, "fmt", true, null);
	buffer = $pkg.buffer = $newType(12, $kindSlice, "fmt.buffer", true, "fmt", false, null);
	pp = $pkg.pp = $newType(0, $kindStruct, "fmt.pp", true, "fmt", false, function(buf_, arg_, value_, fmt_, reordered_, goodArgNum_, panicking_, erroring_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = buffer.nil;
			this.arg = $ifaceNil;
			this.value = new reflect.Value.ptr(ptrType.nil, 0, 0);
			this.fmt = new fmt.ptr(ptrType$1.nil, new fmtFlags.ptr(false, false, false, false, false, false, false, false, false), 0, 0, arrayType.zero());
			this.reordered = false;
			this.goodArgNum = false;
			this.panicking = false;
			this.erroring = false;
			return;
		}
		this.buf = buf_;
		this.arg = arg_;
		this.value = value_;
		this.fmt = fmt_;
		this.reordered = reordered_;
		this.goodArgNum = goodArgNum_;
		this.panicking = panicking_;
		this.erroring = erroring_;
	});
	scanError = $pkg.scanError = $newType(0, $kindStruct, "fmt.scanError", true, "fmt", false, function(err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.err = $ifaceNil;
			return;
		}
		this.err = err_;
	});
	ss = $pkg.ss = $newType(0, $kindStruct, "fmt.ss", true, "fmt", false, function(rs_, buf_, count_, atEOF_, ssave_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.rs = $ifaceNil;
			this.buf = buffer.nil;
			this.count = 0;
			this.atEOF = false;
			this.ssave = new ssave.ptr(false, false, false, 0, 0, 0);
			return;
		}
		this.rs = rs_;
		this.buf = buf_;
		this.count = count_;
		this.atEOF = atEOF_;
		this.ssave = ssave_;
	});
	ssave = $pkg.ssave = $newType(0, $kindStruct, "fmt.ssave", true, "fmt", false, function(validSave_, nlIsEnd_, nlIsSpace_, argLimit_, limit_, maxWid_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.validSave = false;
			this.nlIsEnd = false;
			this.nlIsSpace = false;
			this.argLimit = 0;
			this.limit = 0;
			this.maxWid = 0;
			return;
		}
		this.validSave = validSave_;
		this.nlIsEnd = nlIsEnd_;
		this.nlIsSpace = nlIsSpace_;
		this.argLimit = argLimit_;
		this.limit = limit_;
		this.maxWid = maxWid_;
	});
	sliceType = $sliceType($emptyInterface);
	ptrType = $ptrType(reflect.rtype);
	ptrType$1 = $ptrType(buffer);
	arrayType = $arrayType($Uint8, 68);
	arrayType$1 = $arrayType($Uint16, 2);
	sliceType$1 = $sliceType(arrayType$1);
	sliceType$2 = $sliceType($Uint8);
	arrayType$2 = $arrayType($Uint8, 5);
	ptrType$2 = $ptrType(pp);
	ptrType$5 = $ptrType(ss);
	ptrType$25 = $ptrType(fmt);
	funcType = $funcType([$Int32], [$Bool], false);
	fmt.ptr.prototype.clearflags = function() {
		var f;
		f = this;
		fmtFlags.copy(f.fmtFlags, new fmtFlags.ptr(false, false, false, false, false, false, false, false, false));
	};
	fmt.prototype.clearflags = function() { return this.$val.clearflags(); };
	fmt.ptr.prototype.init = function(buf) {
		var buf, f;
		f = this;
		f.buf = buf;
		f.clearflags();
	};
	fmt.prototype.init = function(buf) { return this.$val.init(buf); };
	fmt.ptr.prototype.writePadding = function(n) {
		var _i, _ref, buf, f, i, n, newLen, oldLen, padByte, padding;
		f = this;
		if (n <= 0) {
			return;
		}
		buf = f.buf.$get();
		oldLen = buf.$length;
		newLen = oldLen + n >> 0;
		if (newLen > buf.$capacity) {
			buf = $makeSlice(buffer, (($imul(buf.$capacity, 2)) + n >> 0));
			$copySlice(buf, f.buf.$get());
		}
		padByte = 32;
		if (f.fmtFlags.zero) {
			padByte = 48;
		}
		padding = $subslice(buf, oldLen, newLen);
		_ref = padding;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			((i < 0 || i >= padding.$length) ? ($throwRuntimeError("index out of range"), undefined) : padding.$array[padding.$offset + i] = padByte);
			_i++;
		}
		f.buf.$set($subslice(buf, 0, newLen));
	};
	fmt.prototype.writePadding = function(n) { return this.$val.writePadding(n); };
	fmt.ptr.prototype.pad = function(b) {
		var b, f, width;
		f = this;
		if (!f.fmtFlags.widPresent || (f.wid === 0)) {
			f.buf.Write(b);
			return;
		}
		width = f.wid - utf8.RuneCount(b) >> 0;
		if (!f.fmtFlags.minus) {
			f.writePadding(width);
			f.buf.Write(b);
		} else {
			f.buf.Write(b);
			f.writePadding(width);
		}
	};
	fmt.prototype.pad = function(b) { return this.$val.pad(b); };
	fmt.ptr.prototype.padString = function(s) {
		var f, s, width;
		f = this;
		if (!f.fmtFlags.widPresent || (f.wid === 0)) {
			f.buf.WriteString(s);
			return;
		}
		width = f.wid - utf8.RuneCountInString(s) >> 0;
		if (!f.fmtFlags.minus) {
			f.writePadding(width);
			f.buf.WriteString(s);
		} else {
			f.buf.WriteString(s);
			f.writePadding(width);
		}
	};
	fmt.prototype.padString = function(s) { return this.$val.padString(s); };
	fmt.ptr.prototype.fmtBoolean = function(v) {
		var f, v;
		f = this;
		if (v) {
			f.padString("true");
		} else {
			f.padString("false");
		}
	};
	fmt.prototype.fmtBoolean = function(v) { return this.$val.fmtBoolean(v); };
	fmt.ptr.prototype.fmtUnicode = function(u) {
		var buf, f, i, oldZero, prec, u, width;
		f = this;
		buf = $subslice(new sliceType$2(f.intbuf), 0);
		prec = 4;
		if (f.fmtFlags.precPresent && f.prec > 4) {
			prec = f.prec;
			width = (((2 + prec >> 0) + 2 >> 0) + 4 >> 0) + 1 >> 0;
			if (width > buf.$length) {
				buf = $makeSlice(sliceType$2, width);
			}
		}
		i = buf.$length;
		if (f.fmtFlags.sharp && (u.$high < 0 || (u.$high === 0 && u.$low <= 1114111)) && strconv.IsPrint(((u.$low >> 0)))) {
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 39);
			i = i - (utf8.RuneLen(((u.$low >> 0)))) >> 0;
			utf8.EncodeRune($subslice(buf, i), ((u.$low >> 0)));
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 39);
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 32);
		}
		while (true) {
			if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 16)))) { break; }
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = "0123456789ABCDEFX".charCodeAt($flatten64(new $Uint64(u.$high & 0, (u.$low & 15) >>> 0))));
			prec = prec - (1) >> 0;
			u = $shiftRightUint64(u, (4));
		}
		i = i - (1) >> 0;
		((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = "0123456789ABCDEFX".charCodeAt($flatten64(u)));
		prec = prec - (1) >> 0;
		while (true) {
			if (!(prec > 0)) { break; }
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 48);
			prec = prec - (1) >> 0;
		}
		i = i - (1) >> 0;
		((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 43);
		i = i - (1) >> 0;
		((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 85);
		oldZero = f.fmtFlags.zero;
		f.fmtFlags.zero = false;
		f.pad($subslice(buf, i));
		f.fmtFlags.zero = oldZero;
	};
	fmt.prototype.fmtUnicode = function(u) { return this.$val.fmtUnicode(u); };
	fmt.ptr.prototype.fmtInteger = function(u, base, isSigned, digits) {
		var _1, _2, base, buf, digits, f, i, isSigned, negative, next, oldZero, oldZero$1, prec, u, width, x, x$1, x$2, x$3, x$4;
		f = this;
		negative = isSigned && (x = (new $Int64(u.$high, u.$low)), (x.$high < 0 || (x.$high === 0 && x.$low < 0)));
		if (negative) {
			u = new $Uint64(-u.$high, -u.$low);
		}
		buf = $subslice(new sliceType$2(f.intbuf), 0);
		if (f.fmtFlags.widPresent || f.fmtFlags.precPresent) {
			width = (3 + f.wid >> 0) + f.prec >> 0;
			if (width > buf.$length) {
				buf = $makeSlice(sliceType$2, width);
			}
		}
		prec = 0;
		if (f.fmtFlags.precPresent) {
			prec = f.prec;
			if ((prec === 0) && (u.$high === 0 && u.$low === 0)) {
				oldZero = f.fmtFlags.zero;
				f.fmtFlags.zero = false;
				f.writePadding(f.wid);
				f.fmtFlags.zero = oldZero;
				return;
			}
		} else if (f.fmtFlags.zero && f.fmtFlags.widPresent) {
			prec = f.wid;
			if (negative || f.fmtFlags.plus || f.fmtFlags.space) {
				prec = prec - (1) >> 0;
			}
		}
		i = buf.$length;
		_1 = base;
		if (_1 === (10)) {
			while (true) {
				if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 10)))) { break; }
				i = i - (1) >> 0;
				next = $div64(u, new $Uint64(0, 10), false);
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = (((x$1 = new $Uint64(0 + u.$high, 48 + u.$low), x$2 = $mul64(next, new $Uint64(0, 10)), new $Uint64(x$1.$high - x$2.$high, x$1.$low - x$2.$low)).$low << 24 >>> 24)));
				u = next;
			}
		} else if (_1 === (16)) {
			while (true) {
				if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 16)))) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = digits.charCodeAt($flatten64(new $Uint64(u.$high & 0, (u.$low & 15) >>> 0))));
				u = $shiftRightUint64(u, (4));
			}
		} else if (_1 === (8)) {
			while (true) {
				if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 8)))) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = (((x$3 = new $Uint64(u.$high & 0, (u.$low & 7) >>> 0), new $Uint64(0 + x$3.$high, 48 + x$3.$low)).$low << 24 >>> 24)));
				u = $shiftRightUint64(u, (3));
			}
		} else if (_1 === (2)) {
			while (true) {
				if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 2)))) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = (((x$4 = new $Uint64(u.$high & 0, (u.$low & 1) >>> 0), new $Uint64(0 + x$4.$high, 48 + x$4.$low)).$low << 24 >>> 24)));
				u = $shiftRightUint64(u, (1));
			}
		} else {
			$panic(new $String("fmt: unknown base; can't happen"));
		}
		i = i - (1) >> 0;
		((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = digits.charCodeAt($flatten64(u)));
		while (true) {
			if (!(i > 0 && prec > (buf.$length - i >> 0))) { break; }
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 48);
		}
		if (f.fmtFlags.sharp) {
			_2 = base;
			if (_2 === (8)) {
				if (!((((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i]) === 48))) {
					i = i - (1) >> 0;
					((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 48);
				}
			} else if (_2 === (16)) {
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = digits.charCodeAt(16));
				i = i - (1) >> 0;
				((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 48);
			}
		}
		if (negative) {
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 45);
		} else if (f.fmtFlags.plus) {
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 43);
		} else if (f.fmtFlags.space) {
			i = i - (1) >> 0;
			((i < 0 || i >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + i] = 32);
		}
		oldZero$1 = f.fmtFlags.zero;
		f.fmtFlags.zero = false;
		f.pad($subslice(buf, i));
		f.fmtFlags.zero = oldZero$1;
	};
	fmt.prototype.fmtInteger = function(u, base, isSigned, digits) { return this.$val.fmtInteger(u, base, isSigned, digits); };
	fmt.ptr.prototype.truncateString = function(s) {
		var _i, _ref, _rune, f, i, n, s;
		f = this;
		if (f.fmtFlags.precPresent) {
			n = f.prec;
			_ref = s;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				i = _i;
				n = n - (1) >> 0;
				if (n < 0) {
					return $substring(s, 0, i);
				}
				_i += _rune[1];
			}
		}
		return s;
	};
	fmt.prototype.truncateString = function(s) { return this.$val.truncateString(s); };
	fmt.ptr.prototype.truncate = function(b) {
		var _tuple, b, f, i, n, wid;
		f = this;
		if (f.fmtFlags.precPresent) {
			n = f.prec;
			i = 0;
			while (true) {
				if (!(i < b.$length)) { break; }
				n = n - (1) >> 0;
				if (n < 0) {
					return $subslice(b, 0, i);
				}
				wid = 1;
				if (((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i]) >= 128) {
					_tuple = utf8.DecodeRune($subslice(b, i));
					wid = _tuple[1];
				}
				i = i + (wid) >> 0;
			}
		}
		return b;
	};
	fmt.prototype.truncate = function(b) { return this.$val.truncate(b); };
	fmt.ptr.prototype.fmtS = function(s) {
		var f, s;
		f = this;
		s = f.truncateString(s);
		f.padString(s);
	};
	fmt.prototype.fmtS = function(s) { return this.$val.fmtS(s); };
	fmt.ptr.prototype.fmtBs = function(b) {
		var b, f;
		f = this;
		b = f.truncate(b);
		f.pad(b);
	};
	fmt.prototype.fmtBs = function(b) { return this.$val.fmtBs(b); };
	fmt.ptr.prototype.fmtSbx = function(s, b, digits) {
		var b, buf, c, digits, f, i, length, s, width;
		f = this;
		length = b.$length;
		if (b === sliceType$2.nil) {
			length = s.length;
		}
		if (f.fmtFlags.precPresent && f.prec < length) {
			length = f.prec;
		}
		width = $imul(2, length);
		if (width > 0) {
			if (f.fmtFlags.space) {
				if (f.fmtFlags.sharp) {
					width = $imul(width, (2));
				}
				width = width + ((length - 1 >> 0)) >> 0;
			} else if (f.fmtFlags.sharp) {
				width = width + (2) >> 0;
			}
		} else {
			if (f.fmtFlags.widPresent) {
				f.writePadding(f.wid);
			}
			return;
		}
		if (f.fmtFlags.widPresent && f.wid > width && !f.fmtFlags.minus) {
			f.writePadding(f.wid - width >> 0);
		}
		buf = f.buf.$get();
		if (f.fmtFlags.sharp) {
			buf = $append(buf, 48, digits.charCodeAt(16));
		}
		c = 0;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			if (f.fmtFlags.space && i > 0) {
				buf = $append(buf, 32);
				if (f.fmtFlags.sharp) {
					buf = $append(buf, 48, digits.charCodeAt(16));
				}
			}
			if (!(b === sliceType$2.nil)) {
				c = ((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i]);
			} else {
				c = s.charCodeAt(i);
			}
			buf = $append(buf, digits.charCodeAt((c >>> 4 << 24 >>> 24)), digits.charCodeAt(((c & 15) >>> 0)));
			i = i + (1) >> 0;
		}
		f.buf.$set(buf);
		if (f.fmtFlags.widPresent && f.wid > width && f.fmtFlags.minus) {
			f.writePadding(f.wid - width >> 0);
		}
	};
	fmt.prototype.fmtSbx = function(s, b, digits) { return this.$val.fmtSbx(s, b, digits); };
	fmt.ptr.prototype.fmtSx = function(s, digits) {
		var digits, f, s;
		f = this;
		f.fmtSbx(s, sliceType$2.nil, digits);
	};
	fmt.prototype.fmtSx = function(s, digits) { return this.$val.fmtSx(s, digits); };
	fmt.ptr.prototype.fmtBx = function(b, digits) {
		var b, digits, f;
		f = this;
		f.fmtSbx("", b, digits);
	};
	fmt.prototype.fmtBx = function(b, digits) { return this.$val.fmtBx(b, digits); };
	fmt.ptr.prototype.fmtQ = function(s) {
		var buf, f, s;
		f = this;
		s = f.truncateString(s);
		if (f.fmtFlags.sharp && strconv.CanBackquote(s)) {
			f.padString("`" + s + "`");
			return;
		}
		buf = $subslice(new sliceType$2(f.intbuf), 0, 0);
		if (f.fmtFlags.plus) {
			f.pad(strconv.AppendQuoteToASCII(buf, s));
		} else {
			f.pad(strconv.AppendQuote(buf, s));
		}
	};
	fmt.prototype.fmtQ = function(s) { return this.$val.fmtQ(s); };
	fmt.ptr.prototype.fmtC = function(c) {
		var buf, c, f, r, w;
		f = this;
		r = ((c.$low >> 0));
		if ((c.$high > 0 || (c.$high === 0 && c.$low > 1114111))) {
			r = 65533;
		}
		buf = $subslice(new sliceType$2(f.intbuf), 0, 0);
		w = utf8.EncodeRune($subslice(buf, 0, 4), r);
		f.pad($subslice(buf, 0, w));
	};
	fmt.prototype.fmtC = function(c) { return this.$val.fmtC(c); };
	fmt.ptr.prototype.fmtQc = function(c) {
		var buf, c, f, r;
		f = this;
		r = ((c.$low >> 0));
		if ((c.$high > 0 || (c.$high === 0 && c.$low > 1114111))) {
			r = 65533;
		}
		buf = $subslice(new sliceType$2(f.intbuf), 0, 0);
		if (f.fmtFlags.plus) {
			f.pad(strconv.AppendQuoteRuneToASCII(buf, r));
		} else {
			f.pad(strconv.AppendQuoteRune(buf, r));
		}
	};
	fmt.prototype.fmtQc = function(c) { return this.$val.fmtQc(c); };
	fmt.ptr.prototype.fmtFloat = function(v, size, verb, prec) {
		var _1, _2, digits, f, hasDecimalPoint, i, num, oldZero, prec, size, tail, tailBuf, v, verb;
		f = this;
		if (f.fmtFlags.precPresent) {
			prec = f.prec;
		}
		num = strconv.AppendFloat($subslice(new sliceType$2(f.intbuf), 0, 1), v, ((verb << 24 >>> 24)), prec, size);
		if (((1 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 1]) === 45) || ((1 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 1]) === 43)) {
			num = $subslice(num, 1);
		} else {
			(0 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 0] = 43);
		}
		if (f.fmtFlags.space && ((0 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 0]) === 43) && !f.fmtFlags.plus) {
			(0 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 0] = 32);
		}
		if (((1 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 1]) === 73) || ((1 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 1]) === 78)) {
			oldZero = f.fmtFlags.zero;
			f.fmtFlags.zero = false;
			if (((1 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 1]) === 78) && !f.fmtFlags.space && !f.fmtFlags.plus) {
				num = $subslice(num, 1);
			}
			f.pad(num);
			f.fmtFlags.zero = oldZero;
			return;
		}
		if (f.fmtFlags.sharp && !((verb === 98))) {
			digits = 0;
			_1 = verb;
			if ((_1 === (118)) || (_1 === (103)) || (_1 === (71))) {
				digits = prec;
				if (digits === -1) {
					digits = 6;
				}
			}
			tailBuf = arrayType$2.zero();
			tail = $subslice(new sliceType$2(tailBuf), 0, 0);
			hasDecimalPoint = false;
			i = 1;
			while (true) {
				if (!(i < num.$length)) { break; }
				_2 = ((i < 0 || i >= num.$length) ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + i]);
				if (_2 === (46)) {
					hasDecimalPoint = true;
				} else if ((_2 === (101)) || (_2 === (69))) {
					tail = $appendSlice(tail, $subslice(num, i));
					num = $subslice(num, 0, i);
				} else {
					digits = digits - (1) >> 0;
				}
				i = i + (1) >> 0;
			}
			if (!hasDecimalPoint) {
				num = $append(num, 46);
			}
			while (true) {
				if (!(digits > 0)) { break; }
				num = $append(num, 48);
				digits = digits - (1) >> 0;
			}
			num = $appendSlice(num, tail);
		}
		if (f.fmtFlags.plus || !(((0 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 0]) === 43))) {
			if (f.fmtFlags.zero && f.fmtFlags.widPresent && f.wid > num.$length) {
				f.buf.WriteByte((0 >= num.$length ? ($throwRuntimeError("index out of range"), undefined) : num.$array[num.$offset + 0]));
				f.writePadding(f.wid - num.$length >> 0);
				f.buf.Write($subslice(num, 1));
				return;
			}
			f.pad(num);
			return;
		}
		f.pad($subslice(num, 1));
	};
	fmt.prototype.fmtFloat = function(v, size, verb, prec) { return this.$val.fmtFloat(v, size, verb, prec); };
	$ptrType(buffer).prototype.Write = function(p) {
		var b, p;
		b = this;
		b.$set($appendSlice(b.$get(), p));
	};
	$ptrType(buffer).prototype.WriteString = function(s) {
		var b, s;
		b = this;
		b.$set($appendSlice(b.$get(), s));
	};
	$ptrType(buffer).prototype.WriteByte = function(c) {
		var b, c;
		b = this;
		b.$set($append(b.$get(), c));
	};
	$ptrType(buffer).prototype.WriteRune = function(r) {
		var b, bp, n, r, w, x;
		bp = this;
		if (r < 128) {
			bp.$set($append(bp.$get(), ((r << 24 >>> 24))));
			return;
		}
		b = bp.$get();
		n = b.$length;
		while (true) {
			if (!((n + 4 >> 0) > b.$capacity)) { break; }
			b = $append(b, 0);
		}
		w = utf8.EncodeRune((x = $subslice(b, n, (n + 4 >> 0)), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length)), r);
		bp.$set($subslice(b, 0, (n + w >> 0)));
	};
	newPrinter = function() {
		var _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = ppFree.Get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = $assertType(_r, ptrType$2);
		p.panicking = false;
		p.erroring = false;
		p.fmt.init((p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))));
		$s = -1; return p;
		/* */ } return; } if ($f === undefined) { $f = { $blk: newPrinter }; } $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.ptr.prototype.free = function() {
		var p;
		p = this;
		if (p.buf.$capacity > 65536) {
			return;
		}
		p.buf = $subslice(p.buf, 0, 0);
		p.arg = $ifaceNil;
		p.value = new reflect.Value.ptr(ptrType.nil, 0, 0);
		ppFree.Put(p);
	};
	pp.prototype.free = function() { return this.$val.free(); };
	pp.ptr.prototype.Width = function() {
		var _tmp, _tmp$1, ok, p, wid;
		wid = 0;
		ok = false;
		p = this;
		_tmp = p.fmt.wid;
		_tmp$1 = p.fmt.fmtFlags.widPresent;
		wid = _tmp;
		ok = _tmp$1;
		return [wid, ok];
	};
	pp.prototype.Width = function() { return this.$val.Width(); };
	pp.ptr.prototype.Precision = function() {
		var _tmp, _tmp$1, ok, p, prec;
		prec = 0;
		ok = false;
		p = this;
		_tmp = p.fmt.prec;
		_tmp$1 = p.fmt.fmtFlags.precPresent;
		prec = _tmp;
		ok = _tmp$1;
		return [prec, ok];
	};
	pp.prototype.Precision = function() { return this.$val.Precision(); };
	pp.ptr.prototype.Flag = function(b) {
		var _1, b, p;
		p = this;
		_1 = b;
		if (_1 === (45)) {
			return p.fmt.fmtFlags.minus;
		} else if (_1 === (43)) {
			return p.fmt.fmtFlags.plus || p.fmt.fmtFlags.plusV;
		} else if (_1 === (35)) {
			return p.fmt.fmtFlags.sharp || p.fmt.fmtFlags.sharpV;
		} else if (_1 === (32)) {
			return p.fmt.fmtFlags.space;
		} else if (_1 === (48)) {
			return p.fmt.fmtFlags.zero;
		}
		return false;
	};
	pp.prototype.Flag = function(b) { return this.$val.Flag(b); };
	pp.ptr.prototype.Write = function(b) {
		var _tmp, _tmp$1, b, err, p, ret;
		ret = 0;
		err = $ifaceNil;
		p = this;
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).Write(b);
		_tmp = b.$length;
		_tmp$1 = $ifaceNil;
		ret = _tmp;
		err = _tmp$1;
		return [ret, err];
	};
	pp.prototype.Write = function(b) { return this.$val.Write(b); };
	pp.ptr.prototype.WriteString = function(s) {
		var _tmp, _tmp$1, err, p, ret, s;
		ret = 0;
		err = $ifaceNil;
		p = this;
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(s);
		_tmp = s.length;
		_tmp$1 = $ifaceNil;
		ret = _tmp;
		err = _tmp$1;
		return [ret, err];
	};
	pp.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	Fprintf = function(w, format, a) {
		var _r, _r$1, _tuple, a, err, format, n, p, w, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; a = $f.a; err = $f.err; format = $f.format; n = $f.n; p = $f.p; w = $f.w; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_r = newPrinter(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		$r = p.doPrintf(format, a); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$1 = w.Write((x = p.buf, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length))); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		n = _tuple[0];
		err = _tuple[1];
		p.free();
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Fprintf }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.a = a; $f.err = err; $f.format = format; $f.n = n; $f.p = p; $f.w = w; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Fprintf = Fprintf;
	Printf = function(format, a) {
		var _r, _tuple, a, err, format, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; a = $f.a; err = $f.err; format = $f.format; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_r = Fprintf(os.Stdout, format, a); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Printf }; } $f._r = _r; $f._tuple = _tuple; $f.a = a; $f.err = err; $f.format = format; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Printf = Printf;
	Sprintf = function(format, a) {
		var _r, a, format, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; format = $f.format; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = newPrinter(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		$r = p.doPrintf(format, a); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		s = ($bytesToString(p.buf));
		p.free();
		$s = -1; return s;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Sprintf }; } $f._r = _r; $f.a = a; $f.format = format; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Sprintf = Sprintf;
	Errorf = function(format, a) {
		var _r, _r$1, a, format, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; a = $f.a; format = $f.format; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = Sprintf(format, a); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = errors.New(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Errorf }; } $f._r = _r; $f._r$1 = _r$1; $f.a = a; $f.format = format; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Errorf = Errorf;
	Sprint = function(a) {
		var _r, a, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = newPrinter(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		$r = p.doPrint(a); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		s = ($bytesToString(p.buf));
		p.free();
		$s = -1; return s;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Sprint }; } $f._r = _r; $f.a = a; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Sprint = Sprint;
	Fprintln = function(w, a) {
		var _r, _r$1, _tuple, a, err, n, p, w, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; a = $f.a; err = $f.err; n = $f.n; p = $f.p; w = $f.w; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_r = newPrinter(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		$r = p.doPrintln(a); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$1 = w.Write((x = p.buf, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length))); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		n = _tuple[0];
		err = _tuple[1];
		p.free();
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Fprintln }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.a = a; $f.err = err; $f.n = n; $f.p = p; $f.w = w; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Fprintln = Fprintln;
	Println = function(a) {
		var _r, _tuple, a, err, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; a = $f.a; err = $f.err; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_r = Fprintln(os.Stdout, a); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Println }; } $f._r = _r; $f._tuple = _tuple; $f.a = a; $f.err = err; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Println = Println;
	Sprintln = function(a) {
		var _r, a, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = newPrinter(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		$r = p.doPrintln(a); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		s = ($bytesToString(p.buf));
		p.free();
		$s = -1; return s;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Sprintln }; } $f._r = _r; $f.a = a; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Sprintln = Sprintln;
	getField = function(v, i) {
		var _r, _r$1, i, v, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; i = $f.i; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = $clone(v, reflect.Value).Field(i); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		val = _r;
		/* */ if (($clone(val, reflect.Value).Kind() === 20) && !$clone(val, reflect.Value).IsNil()) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (($clone(val, reflect.Value).Kind() === 20) && !$clone(val, reflect.Value).IsNil()) { */ case 2:
			_r$1 = $clone(val, reflect.Value).Elem(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			val = _r$1;
		/* } */ case 3:
		$s = -1; return val;
		/* */ } return; } if ($f === undefined) { $f = { $blk: getField }; } $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	tooLarge = function(x) {
		var x;
		return x > 1000000 || x < -1000000;
	};
	parsenum = function(s, start, end) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, end, isnum, newi, num, s, start;
		num = 0;
		isnum = false;
		newi = 0;
		if (start >= end) {
			_tmp = 0;
			_tmp$1 = false;
			_tmp$2 = end;
			num = _tmp;
			isnum = _tmp$1;
			newi = _tmp$2;
			return [num, isnum, newi];
		}
		newi = start;
		while (true) {
			if (!(newi < end && 48 <= s.charCodeAt(newi) && s.charCodeAt(newi) <= 57)) { break; }
			if (tooLarge(num)) {
				_tmp$3 = 0;
				_tmp$4 = false;
				_tmp$5 = end;
				num = _tmp$3;
				isnum = _tmp$4;
				newi = _tmp$5;
				return [num, isnum, newi];
			}
			num = ($imul(num, 10)) + (((s.charCodeAt(newi) - 48 << 24 >>> 24) >> 0)) >> 0;
			isnum = true;
			newi = newi + (1) >> 0;
		}
		return [num, isnum, newi];
	};
	pp.ptr.prototype.unknownType = function(v) {
		var _r, p, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!$clone(v, reflect.Value).IsValid()) {
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
			$s = -1; return;
		}
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(63);
		_r = $clone(v, reflect.Value).Type().String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(63);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.unknownType }; } $f._r = _r; $f.p = p; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.unknownType = function(v) { return this.$val.unknownType(v); };
	pp.ptr.prototype.badVerb = function(verb) {
		var _r, _r$1, p, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; p = $f.p; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		p.erroring = true;
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!");
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteRune(verb);
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(40);
			/* */ if (!($interfaceIsEqual(p.arg, $ifaceNil))) { $s = 2; continue; }
			/* */ if ($clone(p.value, reflect.Value).IsValid()) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!($interfaceIsEqual(p.arg, $ifaceNil))) { */ case 2:
				_r = reflect.TypeOf(p.arg).String(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(61);
				$r = p.printArg(p.arg, 118); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 5; continue;
			/* } else if ($clone(p.value, reflect.Value).IsValid()) { */ case 3:
				_r$1 = $clone(p.value, reflect.Value).Type().String(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$1); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(61);
				$r = p.printValue($clone(p.value, reflect.Value), 118, 0); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 5; continue;
			/* } else { */ case 4:
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
			/* } */ case 5:
		case 1:
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);
		p.erroring = false;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.badVerb }; } $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.badVerb = function(verb) { return this.$val.badVerb(verb); };
	pp.ptr.prototype.fmtBool = function(v, verb) {
		var _1, p, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if ((_1 === (116)) || (_1 === (118))) { $s = 2; continue; }
			/* */ $s = 3; continue;
			/* if ((_1 === (116)) || (_1 === (118))) { */ case 2:
				p.fmt.fmtBoolean(v);
				$s = 4; continue;
			/* } else { */ case 3:
				$r = p.badVerb(verb); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 4:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtBool }; } $f._1 = _1; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtBool = function(v, verb) { return this.$val.fmtBool(v, verb); };
	pp.ptr.prototype.fmt0x64 = function(v, leading0x) {
		var leading0x, p, sharp, v;
		p = this;
		sharp = p.fmt.fmtFlags.sharp;
		p.fmt.fmtFlags.sharp = leading0x;
		p.fmt.fmtInteger(v, 16, false, "0123456789abcdefx");
		p.fmt.fmtFlags.sharp = sharp;
	};
	pp.prototype.fmt0x64 = function(v, leading0x) { return this.$val.fmt0x64(v, leading0x); };
	pp.ptr.prototype.fmtInteger = function(v, isSigned, verb) {
		var _1, isSigned, p, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; isSigned = $f.isSigned; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if (_1 === (118)) { $s = 2; continue; }
			/* */ if (_1 === (100)) { $s = 3; continue; }
			/* */ if (_1 === (98)) { $s = 4; continue; }
			/* */ if (_1 === (111)) { $s = 5; continue; }
			/* */ if (_1 === (120)) { $s = 6; continue; }
			/* */ if (_1 === (88)) { $s = 7; continue; }
			/* */ if (_1 === (99)) { $s = 8; continue; }
			/* */ if (_1 === (113)) { $s = 9; continue; }
			/* */ if (_1 === (85)) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (_1 === (118)) { */ case 2:
				if (p.fmt.fmtFlags.sharpV && !isSigned) {
					p.fmt0x64(v, true);
				} else {
					p.fmt.fmtInteger(v, 10, isSigned, "0123456789abcdefx");
				}
				$s = 12; continue;
			/* } else if (_1 === (100)) { */ case 3:
				p.fmt.fmtInteger(v, 10, isSigned, "0123456789abcdefx");
				$s = 12; continue;
			/* } else if (_1 === (98)) { */ case 4:
				p.fmt.fmtInteger(v, 2, isSigned, "0123456789abcdefx");
				$s = 12; continue;
			/* } else if (_1 === (111)) { */ case 5:
				p.fmt.fmtInteger(v, 8, isSigned, "0123456789abcdefx");
				$s = 12; continue;
			/* } else if (_1 === (120)) { */ case 6:
				p.fmt.fmtInteger(v, 16, isSigned, "0123456789abcdefx");
				$s = 12; continue;
			/* } else if (_1 === (88)) { */ case 7:
				p.fmt.fmtInteger(v, 16, isSigned, "0123456789ABCDEFX");
				$s = 12; continue;
			/* } else if (_1 === (99)) { */ case 8:
				p.fmt.fmtC(v);
				$s = 12; continue;
			/* } else if (_1 === (113)) { */ case 9:
				/* */ if ((v.$high < 0 || (v.$high === 0 && v.$low <= 1114111))) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if ((v.$high < 0 || (v.$high === 0 && v.$low <= 1114111))) { */ case 13:
					p.fmt.fmtQc(v);
					$s = 15; continue;
				/* } else { */ case 14:
					$r = p.badVerb(verb); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 15:
				$s = 12; continue;
			/* } else if (_1 === (85)) { */ case 10:
				p.fmt.fmtUnicode(v);
				$s = 12; continue;
			/* } else { */ case 11:
				$r = p.badVerb(verb); /* */ $s = 17; case 17: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 12:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtInteger }; } $f._1 = _1; $f.isSigned = isSigned; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtInteger = function(v, isSigned, verb) { return this.$val.fmtInteger(v, isSigned, verb); };
	pp.ptr.prototype.fmtFloat = function(v, size, verb) {
		var _1, p, size, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; p = $f.p; size = $f.size; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if (_1 === (118)) { $s = 2; continue; }
			/* */ if ((_1 === (98)) || (_1 === (103)) || (_1 === (71))) { $s = 3; continue; }
			/* */ if ((_1 === (102)) || (_1 === (101)) || (_1 === (69))) { $s = 4; continue; }
			/* */ if (_1 === (70)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (118)) { */ case 2:
				p.fmt.fmtFloat(v, size, 103, -1);
				$s = 7; continue;
			/* } else if ((_1 === (98)) || (_1 === (103)) || (_1 === (71))) { */ case 3:
				p.fmt.fmtFloat(v, size, verb, -1);
				$s = 7; continue;
			/* } else if ((_1 === (102)) || (_1 === (101)) || (_1 === (69))) { */ case 4:
				p.fmt.fmtFloat(v, size, verb, 6);
				$s = 7; continue;
			/* } else if (_1 === (70)) { */ case 5:
				p.fmt.fmtFloat(v, size, 102, 6);
				$s = 7; continue;
			/* } else { */ case 6:
				$r = p.badVerb(verb); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 7:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtFloat }; } $f._1 = _1; $f.p = p; $f.size = size; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtFloat = function(v, size, verb) { return this.$val.fmtFloat(v, size, verb); };
	pp.ptr.prototype.fmtComplex = function(v, size, verb) {
		var _1, _q, _q$1, oldPlus, p, size, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _q = $f._q; _q$1 = $f._q$1; oldPlus = $f.oldPlus; p = $f.p; size = $f.size; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if ((_1 === (118)) || (_1 === (98)) || (_1 === (103)) || (_1 === (71)) || (_1 === (102)) || (_1 === (70)) || (_1 === (101)) || (_1 === (69))) { $s = 2; continue; }
			/* */ $s = 3; continue;
			/* if ((_1 === (118)) || (_1 === (98)) || (_1 === (103)) || (_1 === (71)) || (_1 === (102)) || (_1 === (70)) || (_1 === (101)) || (_1 === (69))) { */ case 2:
				oldPlus = p.fmt.fmtFlags.plus;
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(40);
				$r = p.fmtFloat(v.$real, (_q = size / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")), verb); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				p.fmt.fmtFlags.plus = true;
				$r = p.fmtFloat(v.$imag, (_q$1 = size / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")), verb); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("i)");
				p.fmt.fmtFlags.plus = oldPlus;
				$s = 4; continue;
			/* } else { */ case 3:
				$r = p.badVerb(verb); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 4:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtComplex }; } $f._1 = _1; $f._q = _q; $f._q$1 = _q$1; $f.oldPlus = oldPlus; $f.p = p; $f.size = size; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtComplex = function(v, size, verb) { return this.$val.fmtComplex(v, size, verb); };
	pp.ptr.prototype.fmtString = function(v, verb) {
		var _1, p, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if (_1 === (118)) { $s = 2; continue; }
			/* */ if (_1 === (115)) { $s = 3; continue; }
			/* */ if (_1 === (120)) { $s = 4; continue; }
			/* */ if (_1 === (88)) { $s = 5; continue; }
			/* */ if (_1 === (113)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (118)) { */ case 2:
				if (p.fmt.fmtFlags.sharpV) {
					p.fmt.fmtQ(v);
				} else {
					p.fmt.fmtS(v);
				}
				$s = 8; continue;
			/* } else if (_1 === (115)) { */ case 3:
				p.fmt.fmtS(v);
				$s = 8; continue;
			/* } else if (_1 === (120)) { */ case 4:
				p.fmt.fmtSx(v, "0123456789abcdefx");
				$s = 8; continue;
			/* } else if (_1 === (88)) { */ case 5:
				p.fmt.fmtSx(v, "0123456789ABCDEFX");
				$s = 8; continue;
			/* } else if (_1 === (113)) { */ case 6:
				p.fmt.fmtQ(v);
				$s = 8; continue;
			/* } else { */ case 7:
				$r = p.badVerb(verb); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 8:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtString }; } $f._1 = _1; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtString = function(v, verb) { return this.$val.fmtString(v, verb); };
	pp.ptr.prototype.fmtBytes = function(v, verb, typeString) {
		var _1, _i, _i$1, _r, _ref, _ref$1, c, c$1, i, i$1, p, typeString, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; c = $f.c; c$1 = $f.c$1; i = $f.i; i$1 = $f.i$1; p = $f.p; typeString = $f.typeString; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
			_1 = verb;
			/* */ if ((_1 === (118)) || (_1 === (100))) { $s = 2; continue; }
			/* */ if (_1 === (115)) { $s = 3; continue; }
			/* */ if (_1 === (120)) { $s = 4; continue; }
			/* */ if (_1 === (88)) { $s = 5; continue; }
			/* */ if (_1 === (113)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if ((_1 === (118)) || (_1 === (100))) { */ case 2:
				if (p.fmt.fmtFlags.sharpV) {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(typeString);
					if (v === sliceType$2.nil) {
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(nil)");
						$s = -1; return;
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);
					_ref = v;
					_i = 0;
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						i = _i;
						c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
						if (i > 0) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(", ");
						}
						p.fmt0x64((new $Uint64(0, c)), true);
						_i++;
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);
				} else {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(91);
					_ref$1 = v;
					_i$1 = 0;
					while (true) {
						if (!(_i$1 < _ref$1.$length)) { break; }
						i$1 = _i$1;
						c$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
						if (i$1 > 0) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
						}
						p.fmt.fmtInteger((new $Uint64(0, c$1)), 10, false, "0123456789abcdefx");
						_i$1++;
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(93);
				}
				$s = 8; continue;
			/* } else if (_1 === (115)) { */ case 3:
				p.fmt.fmtBs(v);
				$s = 8; continue;
			/* } else if (_1 === (120)) { */ case 4:
				p.fmt.fmtBx(v, "0123456789abcdefx");
				$s = 8; continue;
			/* } else if (_1 === (88)) { */ case 5:
				p.fmt.fmtBx(v, "0123456789ABCDEFX");
				$s = 8; continue;
			/* } else if (_1 === (113)) { */ case 6:
				p.fmt.fmtQ(($bytesToString(v)));
				$s = 8; continue;
			/* } else { */ case 7:
				_r = reflect.ValueOf(v); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$r = p.printValue($clone(_r, reflect.Value), verb, 0); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 8:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtBytes }; } $f._1 = _1; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.i$1 = i$1; $f.p = p; $f.typeString = typeString; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtBytes = function(v, verb, typeString) { return this.$val.fmtBytes(v, verb, typeString); };
	pp.ptr.prototype.fmtPointer = function(value, verb) {
		var _1, _2, _r, p, u, value, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _r = $f._r; p = $f.p; u = $f.u; value = $f.value; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		u = 0;
			_1 = $clone(value, reflect.Value).Kind();
			/* */ if ((_1 === (18)) || (_1 === (19)) || (_1 === (21)) || (_1 === (22)) || (_1 === (23)) || (_1 === (26))) { $s = 2; continue; }
			/* */ $s = 3; continue;
			/* if ((_1 === (18)) || (_1 === (19)) || (_1 === (21)) || (_1 === (22)) || (_1 === (23)) || (_1 === (26))) { */ case 2:
				u = $clone(value, reflect.Value).Pointer();
				$s = 4; continue;
			/* } else { */ case 3:
				$r = p.badVerb(verb); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } */ case 4:
		case 1:
			_2 = verb;
			/* */ if (_2 === (118)) { $s = 7; continue; }
			/* */ if (_2 === (112)) { $s = 8; continue; }
			/* */ if ((_2 === (98)) || (_2 === (111)) || (_2 === (100)) || (_2 === (120)) || (_2 === (88))) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_2 === (118)) { */ case 7:
				/* */ if (p.fmt.fmtFlags.sharpV) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (p.fmt.fmtFlags.sharpV) { */ case 12:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(40);
					_r = $clone(value, reflect.Value).Type().String(); /* */ $s = 15; case 15: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(")(");
					if (u === 0) {
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("nil");
					} else {
						p.fmt0x64((new $Uint64(0, u.constructor === Number ? u : 1)), true);
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);
					$s = 14; continue;
				/* } else { */ case 13:
					if (u === 0) {
						p.fmt.padString("<nil>");
					} else {
						p.fmt0x64((new $Uint64(0, u.constructor === Number ? u : 1)), !p.fmt.fmtFlags.sharp);
					}
				/* } */ case 14:
				$s = 11; continue;
			/* } else if (_2 === (112)) { */ case 8:
				p.fmt0x64((new $Uint64(0, u.constructor === Number ? u : 1)), !p.fmt.fmtFlags.sharp);
				$s = 11; continue;
			/* } else if ((_2 === (98)) || (_2 === (111)) || (_2 === (100)) || (_2 === (120)) || (_2 === (88))) { */ case 9:
				$r = p.fmtInteger((new $Uint64(0, u.constructor === Number ? u : 1)), false, verb); /* */ $s = 17; case 17: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 11; continue;
			/* } else { */ case 10:
				$r = p.badVerb(verb); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 11:
		case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtPointer }; } $f._1 = _1; $f._2 = _2; $f._r = _r; $f.p = p; $f.u = u; $f.value = value; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.fmtPointer = function(value, verb) { return this.$val.fmtPointer(value, verb); };
	pp.ptr.prototype.catchPanic = function(arg, verb, method) {
		var _r, arg, err, method, oldFlags, p, v, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; arg = $f.arg; err = $f.err; method = $f.method; oldFlags = $f.oldFlags; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		err = $recover();
		/* */ if (!($interfaceIsEqual(err, $ifaceNil))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:
			_r = reflect.ValueOf(arg); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			v = _r;
			if (($clone(v, reflect.Value).Kind() === 22) && $clone(v, reflect.Value).IsNil()) {
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
				$s = -1; return;
			}
			if (p.panicking) {
				$panic(err);
			}
			oldFlags = $clone(p.fmt.fmtFlags, fmtFlags);
			p.fmt.clearflags();
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!");
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteRune(verb);
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(PANIC=");
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(method);
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(" method: ");
			p.panicking = true;
			$r = p.printArg(err, 118); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			p.panicking = false;
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);
			fmtFlags.copy(p.fmt.fmtFlags, oldFlags);
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.catchPanic }; } $f._r = _r; $f.arg = arg; $f.err = err; $f.method = method; $f.oldFlags = oldFlags; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.catchPanic = function(arg, verb, method) { return this.$val.catchPanic(arg, verb, method); };
	pp.ptr.prototype.handleMethods = function(verb) {
		var _1, _r, _r$1, _r$2, _ref, _tuple, _tuple$1, formatter, handled, ok, ok$1, p, stringer, v, v$1, verb, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; formatter = $f.formatter; handled = $f.handled; ok = $f.ok; ok$1 = $f.ok$1; p = $f.p; stringer = $f.stringer; v = $f.v; v$1 = $f.v$1; verb = $f.verb; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		handled = false;
		p = this;
		if (p.erroring) {
			$s = -1; return handled;
		}
		_tuple = $assertType(p.arg, Formatter, true);
		formatter = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			handled = true;
			$deferred.push([$methodVal(p, "catchPanic"), [p.arg, verb, "Format"]]);
			$r = formatter.Format(p, verb); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return handled;
		/* } */ case 2:
		/* */ if (p.fmt.fmtFlags.sharpV) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (p.fmt.fmtFlags.sharpV) { */ case 4:
			_tuple$1 = $assertType(p.arg, GoStringer, true);
			stringer = _tuple$1[0];
			ok$1 = _tuple$1[1];
			/* */ if (ok$1) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (ok$1) { */ case 7:
				handled = true;
				$deferred.push([$methodVal(p, "catchPanic"), [p.arg, verb, "GoString"]]);
				_r = stringer.GoString(); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$r = p.fmt.fmtS(_r); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return handled;
			/* } */ case 8:
			$s = 6; continue;
		/* } else { */ case 5:
				_1 = verb;
				/* */ if ((_1 === (118)) || (_1 === (115)) || (_1 === (120)) || (_1 === (88)) || (_1 === (113))) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if ((_1 === (118)) || (_1 === (115)) || (_1 === (120)) || (_1 === (88)) || (_1 === (113))) { */ case 12:
					_ref = p.arg;
					/* */ if ($assertType(_ref, $error, true)[1]) { $s = 14; continue; }
					/* */ if ($assertType(_ref, Stringer, true)[1]) { $s = 15; continue; }
					/* */ $s = 16; continue;
					/* if ($assertType(_ref, $error, true)[1]) { */ case 14:
						v = _ref;
						handled = true;
						$deferred.push([$methodVal(p, "catchPanic"), [p.arg, verb, "Error"]]);
						_r$1 = v.Error(); /* */ $s = 17; case 17: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$r = p.fmtString(_r$1, verb); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return handled;
					/* } else if ($assertType(_ref, Stringer, true)[1]) { */ case 15:
						v$1 = _ref;
						handled = true;
						$deferred.push([$methodVal(p, "catchPanic"), [p.arg, verb, "String"]]);
						_r$2 = v$1.String(); /* */ $s = 19; case 19: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$r = p.fmtString(_r$2, verb); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return handled;
					/* } */ case 16:
				/* } */ case 13:
			case 11:
		/* } */ case 6:
		handled = false;
		$s = -1; return handled;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  handled; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: pp.ptr.prototype.handleMethods }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.formatter = formatter; $f.handled = handled; $f.ok = ok; $f.ok$1 = ok$1; $f.p = p; $f.stringer = stringer; $f.v = v; $f.v$1 = v$1; $f.verb = verb; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	pp.prototype.handleMethods = function(verb) { return this.$val.handleMethods(verb); };
	pp.ptr.prototype.printArg = function(arg, verb) {
		var _1, _2, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _ref, arg, f, f$1, f$10, f$11, f$12, f$13, f$14, f$15, f$16, f$17, f$18, f$19, f$2, f$3, f$4, f$5, f$6, f$7, f$8, f$9, p, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _ref = $f._ref; arg = $f.arg; f = $f.f; f$1 = $f.f$1; f$10 = $f.f$10; f$11 = $f.f$11; f$12 = $f.f$12; f$13 = $f.f$13; f$14 = $f.f$14; f$15 = $f.f$15; f$16 = $f.f$16; f$17 = $f.f$17; f$18 = $f.f$18; f$19 = $f.f$19; f$2 = $f.f$2; f$3 = $f.f$3; f$4 = $f.f$4; f$5 = $f.f$5; f$6 = $f.f$6; f$7 = $f.f$7; f$8 = $f.f$8; f$9 = $f.f$9; p = $f.p; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		p.arg = arg;
		p.value = new reflect.Value.ptr(ptrType.nil, 0, 0);
		/* */ if ($interfaceIsEqual(arg, $ifaceNil)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($interfaceIsEqual(arg, $ifaceNil)) { */ case 1:
				_1 = verb;
				/* */ if ((_1 === (84)) || (_1 === (118))) { $s = 4; continue; }
				/* */ $s = 5; continue;
				/* if ((_1 === (84)) || (_1 === (118))) { */ case 4:
					p.fmt.padString("<nil>");
					$s = 6; continue;
				/* } else { */ case 5:
					$r = p.badVerb(verb); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 6:
			case 3:
			$s = -1; return;
		/* } */ case 2:
			_2 = verb;
			/* */ if (_2 === (84)) { $s = 9; continue; }
			/* */ if (_2 === (112)) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (_2 === (84)) { */ case 9:
				_r = reflect.TypeOf(arg).String(); /* */ $s = 12; case 12: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$r = p.fmt.fmtS(_r); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } else if (_2 === (112)) { */ case 10:
				_r$1 = reflect.ValueOf(arg); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$r = p.fmtPointer($clone(_r$1, reflect.Value), 112); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } */ case 11:
		case 8:
		_ref = arg;
		/* */ if ($assertType(_ref, $Bool, true)[1]) { $s = 16; continue; }
		/* */ if ($assertType(_ref, $Float32, true)[1]) { $s = 17; continue; }
		/* */ if ($assertType(_ref, $Float64, true)[1]) { $s = 18; continue; }
		/* */ if ($assertType(_ref, $Complex64, true)[1]) { $s = 19; continue; }
		/* */ if ($assertType(_ref, $Complex128, true)[1]) { $s = 20; continue; }
		/* */ if ($assertType(_ref, $Int, true)[1]) { $s = 21; continue; }
		/* */ if ($assertType(_ref, $Int8, true)[1]) { $s = 22; continue; }
		/* */ if ($assertType(_ref, $Int16, true)[1]) { $s = 23; continue; }
		/* */ if ($assertType(_ref, $Int32, true)[1]) { $s = 24; continue; }
		/* */ if ($assertType(_ref, $Int64, true)[1]) { $s = 25; continue; }
		/* */ if ($assertType(_ref, $Uint, true)[1]) { $s = 26; continue; }
		/* */ if ($assertType(_ref, $Uint8, true)[1]) { $s = 27; continue; }
		/* */ if ($assertType(_ref, $Uint16, true)[1]) { $s = 28; continue; }
		/* */ if ($assertType(_ref, $Uint32, true)[1]) { $s = 29; continue; }
		/* */ if ($assertType(_ref, $Uint64, true)[1]) { $s = 30; continue; }
		/* */ if ($assertType(_ref, $Uintptr, true)[1]) { $s = 31; continue; }
		/* */ if ($assertType(_ref, $String, true)[1]) { $s = 32; continue; }
		/* */ if ($assertType(_ref, sliceType$2, true)[1]) { $s = 33; continue; }
		/* */ if ($assertType(_ref, reflect.Value, true)[1]) { $s = 34; continue; }
		/* */ $s = 35; continue;
		/* if ($assertType(_ref, $Bool, true)[1]) { */ case 16:
			f = _ref.$val;
			$r = p.fmtBool(f, verb); /* */ $s = 37; case 37: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Float32, true)[1]) { */ case 17:
			f$1 = _ref.$val;
			$r = p.fmtFloat((f$1), 32, verb); /* */ $s = 38; case 38: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Float64, true)[1]) { */ case 18:
			f$2 = _ref.$val;
			$r = p.fmtFloat(f$2, 64, verb); /* */ $s = 39; case 39: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Complex64, true)[1]) { */ case 19:
			f$3 = _ref.$val;
			$r = p.fmtComplex((new $Complex128(f$3.$real, f$3.$imag)), 64, verb); /* */ $s = 40; case 40: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Complex128, true)[1]) { */ case 20:
			f$4 = _ref.$val;
			$r = p.fmtComplex(f$4, 128, verb); /* */ $s = 41; case 41: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Int, true)[1]) { */ case 21:
			f$5 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$5)), true, verb); /* */ $s = 42; case 42: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Int8, true)[1]) { */ case 22:
			f$6 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$6)), true, verb); /* */ $s = 43; case 43: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Int16, true)[1]) { */ case 23:
			f$7 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$7)), true, verb); /* */ $s = 44; case 44: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Int32, true)[1]) { */ case 24:
			f$8 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$8)), true, verb); /* */ $s = 45; case 45: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Int64, true)[1]) { */ case 25:
			f$9 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(f$9.$high, f$9.$low)), true, verb); /* */ $s = 46; case 46: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uint, true)[1]) { */ case 26:
			f$10 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$10)), false, verb); /* */ $s = 47; case 47: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uint8, true)[1]) { */ case 27:
			f$11 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$11)), false, verb); /* */ $s = 48; case 48: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uint16, true)[1]) { */ case 28:
			f$12 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$12)), false, verb); /* */ $s = 49; case 49: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uint32, true)[1]) { */ case 29:
			f$13 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$13)), false, verb); /* */ $s = 50; case 50: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uint64, true)[1]) { */ case 30:
			f$14 = _ref.$val;
			$r = p.fmtInteger(f$14, false, verb); /* */ $s = 51; case 51: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $Uintptr, true)[1]) { */ case 31:
			f$15 = _ref.$val;
			$r = p.fmtInteger((new $Uint64(0, f$15.constructor === Number ? f$15 : 1)), false, verb); /* */ $s = 52; case 52: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, $String, true)[1]) { */ case 32:
			f$16 = _ref.$val;
			$r = p.fmtString(f$16, verb); /* */ $s = 53; case 53: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, sliceType$2, true)[1]) { */ case 33:
			f$17 = _ref.$val;
			$r = p.fmtBytes(f$17, verb, "[]byte"); /* */ $s = 54; case 54: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else if ($assertType(_ref, reflect.Value, true)[1]) { */ case 34:
			f$18 = _ref.$val;
			/* */ if ($clone(f$18, reflect.Value).IsValid() && $clone(f$18, reflect.Value).CanInterface()) { $s = 55; continue; }
			/* */ $s = 56; continue;
			/* if ($clone(f$18, reflect.Value).IsValid() && $clone(f$18, reflect.Value).CanInterface()) { */ case 55:
				_r$2 = $clone(f$18, reflect.Value).Interface(); /* */ $s = 57; case 57: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				p.arg = _r$2;
				_r$3 = p.handleMethods(verb); /* */ $s = 60; case 60: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				/* */ if (_r$3) { $s = 58; continue; }
				/* */ $s = 59; continue;
				/* if (_r$3) { */ case 58:
					$s = -1; return;
				/* } */ case 59:
			/* } */ case 56:
			$r = p.printValue($clone(f$18, reflect.Value), verb, 0); /* */ $s = 61; case 61: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 36; continue;
		/* } else { */ case 35:
			f$19 = _ref;
			_r$4 = p.handleMethods(verb); /* */ $s = 64; case 64: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			/* */ if (!_r$4) { $s = 62; continue; }
			/* */ $s = 63; continue;
			/* if (!_r$4) { */ case 62:
				_r$5 = reflect.ValueOf(f$19); /* */ $s = 65; case 65: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				$r = p.printValue($clone(_r$5, reflect.Value), verb, 0); /* */ $s = 66; case 66: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 63:
		/* } */ case 36:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.printArg }; } $f._1 = _1; $f._2 = _2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._ref = _ref; $f.arg = arg; $f.f = f; $f.f$1 = f$1; $f.f$10 = f$10; $f.f$11 = f$11; $f.f$12 = f$12; $f.f$13 = f$13; $f.f$14 = f$14; $f.f$15 = f$15; $f.f$16 = f$16; $f.f$17 = f$17; $f.f$18 = f$18; $f.f$19 = f$19; $f.f$2 = f$2; $f.f$3 = f$3; $f.f$4 = f$4; $f.f$5 = f$5; $f.f$6 = f$6; $f.f$7 = f$7; $f.f$8 = f$8; $f.f$9 = f$9; $f.p = p; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.printArg = function(arg, verb) { return this.$val.printArg(arg, verb); };
	pp.ptr.prototype.printValue = function(value, verb, depth) {
		var _1, _2, _3, _4, _arg, _arg$1, _arg$2, _i, _i$1, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$2, _r$20, _r$21, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, a, bytes, depth, f, i, i$1, i$2, i$3, i$4, key, name, p, sorted, t, value, value$1, verb, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$2 = $f._r$2; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; a = $f.a; bytes = $f.bytes; depth = $f.depth; f = $f.f; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; i$4 = $f.i$4; key = $f.key; name = $f.name; p = $f.p; sorted = $f.sorted; t = $f.t; value = $f.value; value$1 = $f.value$1; verb = $f.verb; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (depth > 0 && $clone(value, reflect.Value).IsValid() && $clone(value, reflect.Value).CanInterface()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (depth > 0 && $clone(value, reflect.Value).IsValid() && $clone(value, reflect.Value).CanInterface()) { */ case 1:
			_r = $clone(value, reflect.Value).Interface(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			p.arg = _r;
			_r$1 = p.handleMethods(verb); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (_r$1) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_r$1) { */ case 4:
				$s = -1; return;
			/* } */ case 5:
		/* } */ case 2:
		p.arg = $ifaceNil;
		p.value = value;
			f = value;
			_1 = $clone(value, reflect.Value).Kind();
			/* */ if (_1 === (0)) { $s = 8; continue; }
			/* */ if (_1 === (1)) { $s = 9; continue; }
			/* */ if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { $s = 10; continue; }
			/* */ if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 11; continue; }
			/* */ if (_1 === (13)) { $s = 12; continue; }
			/* */ if (_1 === (14)) { $s = 13; continue; }
			/* */ if (_1 === (15)) { $s = 14; continue; }
			/* */ if (_1 === (16)) { $s = 15; continue; }
			/* */ if (_1 === (24)) { $s = 16; continue; }
			/* */ if (_1 === (21)) { $s = 17; continue; }
			/* */ if (_1 === (25)) { $s = 18; continue; }
			/* */ if (_1 === (20)) { $s = 19; continue; }
			/* */ if ((_1 === (17)) || (_1 === (23))) { $s = 20; continue; }
			/* */ if (_1 === (22)) { $s = 21; continue; }
			/* */ if ((_1 === (18)) || (_1 === (19)) || (_1 === (26))) { $s = 22; continue; }
			/* */ $s = 23; continue;
			/* if (_1 === (0)) { */ case 8:
				/* */ if (depth === 0) { $s = 25; continue; }
				/* */ $s = 26; continue;
				/* if (depth === 0) { */ case 25:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<invalid reflect.Value>");
					$s = 27; continue;
				/* } else { */ case 26:
						_2 = verb;
						/* */ if (_2 === (118)) { $s = 29; continue; }
						/* */ $s = 30; continue;
						/* if (_2 === (118)) { */ case 29:
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
							$s = 31; continue;
						/* } else { */ case 30:
							$r = p.badVerb(verb); /* */ $s = 32; case 32: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						/* } */ case 31:
					case 28:
				/* } */ case 27:
				$s = 24; continue;
			/* } else if (_1 === (1)) { */ case 9:
				$r = p.fmtBool($clone(f, reflect.Value).Bool(), verb); /* */ $s = 33; case 33: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 10:
				$r = p.fmtInteger(((x = $clone(f, reflect.Value).Int(), new $Uint64(x.$high, x.$low))), true, verb); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 11:
				$r = p.fmtInteger($clone(f, reflect.Value).Uint(), false, verb); /* */ $s = 35; case 35: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (13)) { */ case 12:
				$r = p.fmtFloat($clone(f, reflect.Value).Float(), 32, verb); /* */ $s = 36; case 36: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (14)) { */ case 13:
				$r = p.fmtFloat($clone(f, reflect.Value).Float(), 64, verb); /* */ $s = 37; case 37: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (15)) { */ case 14:
				$r = p.fmtComplex($clone(f, reflect.Value).Complex(), 64, verb); /* */ $s = 38; case 38: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (16)) { */ case 15:
				$r = p.fmtComplex($clone(f, reflect.Value).Complex(), 128, verb); /* */ $s = 39; case 39: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (24)) { */ case 16:
				_r$2 = $clone(f, reflect.Value).String(); /* */ $s = 40; case 40: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				$r = p.fmtString(_r$2, verb); /* */ $s = 41; case 41: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if (_1 === (21)) { */ case 17:
				/* */ if (p.fmt.fmtFlags.sharpV) { $s = 42; continue; }
				/* */ $s = 43; continue;
				/* if (p.fmt.fmtFlags.sharpV) { */ case 42:
					_r$3 = $clone(f, reflect.Value).Type().String(); /* */ $s = 45; case 45: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$3); /* */ $s = 46; case 46: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					if ($clone(f, reflect.Value).IsNil()) {
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(nil)");
						$s = -1; return;
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);
					$s = 44; continue;
				/* } else { */ case 43:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("map[");
				/* } */ case 44:
				_r$4 = fmtsort.Sort($clone(f, reflect.Value)); /* */ $s = 47; case 47: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				sorted = _r$4;
				_ref = sorted.Key;
				_i = 0;
				/* while (true) { */ case 48:
					/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 49; continue; }
					i = _i;
					key = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
					if (i > 0) {
						if (p.fmt.fmtFlags.sharpV) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(", ");
						} else {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
						}
					}
					$r = p.printValue($clone(key, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 50; case 50: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(58);
					$r = p.printValue($clone((x$1 = sorted.Value, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])), reflect.Value), verb, depth + 1 >> 0); /* */ $s = 51; case 51: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_i++;
				/* } */ $s = 48; continue; case 49:
				if (p.fmt.fmtFlags.sharpV) {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);
				} else {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(93);
				}
				$s = 24; continue;
			/* } else if (_1 === (25)) { */ case 18:
				/* */ if (p.fmt.fmtFlags.sharpV) { $s = 52; continue; }
				/* */ $s = 53; continue;
				/* if (p.fmt.fmtFlags.sharpV) { */ case 52:
					_r$5 = $clone(f, reflect.Value).Type().String(); /* */ $s = 54; case 54: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$5); /* */ $s = 55; case 55: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 53:
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);
				i$1 = 0;
				/* while (true) { */ case 56:
					/* if (!(i$1 < $clone(f, reflect.Value).NumField())) { break; } */ if(!(i$1 < $clone(f, reflect.Value).NumField())) { $s = 57; continue; }
					if (i$1 > 0) {
						if (p.fmt.fmtFlags.sharpV) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(", ");
						} else {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
						}
					}
					/* */ if (p.fmt.fmtFlags.plusV || p.fmt.fmtFlags.sharpV) { $s = 58; continue; }
					/* */ $s = 59; continue;
					/* if (p.fmt.fmtFlags.plusV || p.fmt.fmtFlags.sharpV) { */ case 58:
						_r$6 = $clone(f, reflect.Value).Type().Field(i$1); /* */ $s = 60; case 60: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
						name = _r$6.Name;
						if (!(name === "")) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(name);
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(58);
						}
					/* } */ case 59:
					_r$7 = getField($clone(f, reflect.Value), i$1); /* */ $s = 61; case 61: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
					$r = p.printValue($clone(_r$7, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 62; case 62: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					i$1 = i$1 + (1) >> 0;
				/* } */ $s = 56; continue; case 57:
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);
				$s = 24; continue;
			/* } else if (_1 === (20)) { */ case 19:
				_r$8 = $clone(f, reflect.Value).Elem(); /* */ $s = 63; case 63: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				value$1 = _r$8;
				/* */ if (!$clone(value$1, reflect.Value).IsValid()) { $s = 64; continue; }
				/* */ $s = 65; continue;
				/* if (!$clone(value$1, reflect.Value).IsValid()) { */ case 64:
					/* */ if (p.fmt.fmtFlags.sharpV) { $s = 67; continue; }
					/* */ $s = 68; continue;
					/* if (p.fmt.fmtFlags.sharpV) { */ case 67:
						_r$9 = $clone(f, reflect.Value).Type().String(); /* */ $s = 70; case 70: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
						$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$9); /* */ $s = 71; case 71: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(nil)");
						$s = 69; continue;
					/* } else { */ case 68:
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
					/* } */ case 69:
					$s = 66; continue;
				/* } else { */ case 65:
					$r = p.printValue($clone(value$1, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 72; case 72: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 66:
				$s = 24; continue;
			/* } else if ((_1 === (17)) || (_1 === (23))) { */ case 20:
					_3 = verb;
					/* */ if ((_3 === (115)) || (_3 === (113)) || (_3 === (120)) || (_3 === (88))) { $s = 74; continue; }
					/* */ $s = 75; continue;
					/* if ((_3 === (115)) || (_3 === (113)) || (_3 === (120)) || (_3 === (88))) { */ case 74:
						t = $clone(f, reflect.Value).Type();
						_r$10 = t.Elem(); /* */ $s = 78; case 78: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
						_r$11 = _r$10.Kind(); /* */ $s = 79; case 79: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
						/* */ if (_r$11 === 8) { $s = 76; continue; }
						/* */ $s = 77; continue;
						/* if (_r$11 === 8) { */ case 76:
							bytes = sliceType$2.nil;
							/* */ if ($clone(f, reflect.Value).Kind() === 23) { $s = 80; continue; }
							/* */ if ($clone(f, reflect.Value).CanAddr()) { $s = 81; continue; }
							/* */ $s = 82; continue;
							/* if ($clone(f, reflect.Value).Kind() === 23) { */ case 80:
								_r$12 = $clone(f, reflect.Value).Bytes(); /* */ $s = 84; case 84: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
								bytes = _r$12;
								$s = 83; continue;
							/* } else if ($clone(f, reflect.Value).CanAddr()) { */ case 81:
								_r$13 = $clone(f, reflect.Value).Slice(0, $clone(f, reflect.Value).Len()); /* */ $s = 85; case 85: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
								_r$14 = $clone(_r$13, reflect.Value).Bytes(); /* */ $s = 86; case 86: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
								bytes = _r$14;
								$s = 83; continue;
							/* } else { */ case 82:
								bytes = $makeSlice(sliceType$2, $clone(f, reflect.Value).Len());
								_ref$1 = bytes;
								_i$1 = 0;
								/* while (true) { */ case 87:
									/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 88; continue; }
									i$2 = _i$1;
									_r$15 = $clone(f, reflect.Value).Index(i$2); /* */ $s = 89; case 89: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
									_r$16 = $clone(_r$15, reflect.Value).Uint(); /* */ $s = 90; case 90: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
									((i$2 < 0 || i$2 >= bytes.$length) ? ($throwRuntimeError("index out of range"), undefined) : bytes.$array[bytes.$offset + i$2] = ((_r$16.$low << 24 >>> 24)));
									_i$1++;
								/* } */ $s = 87; continue; case 88:
							/* } */ case 83:
							_arg = bytes;
							_arg$1 = verb;
							_r$17 = t.String(); /* */ $s = 91; case 91: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
							_arg$2 = _r$17;
							$r = p.fmtBytes(_arg, _arg$1, _arg$2); /* */ $s = 92; case 92: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return;
						/* } */ case 77:
					/* } */ case 75:
				case 73:
				/* */ if (p.fmt.fmtFlags.sharpV) { $s = 93; continue; }
				/* */ $s = 94; continue;
				/* if (p.fmt.fmtFlags.sharpV) { */ case 93:
					_r$18 = $clone(f, reflect.Value).Type().String(); /* */ $s = 96; case 96: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
					$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$18); /* */ $s = 97; case 97: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					if (($clone(f, reflect.Value).Kind() === 23) && $clone(f, reflect.Value).IsNil()) {
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(nil)");
						$s = -1; return;
					}
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);
					i$3 = 0;
					/* while (true) { */ case 98:
						/* if (!(i$3 < $clone(f, reflect.Value).Len())) { break; } */ if(!(i$3 < $clone(f, reflect.Value).Len())) { $s = 99; continue; }
						if (i$3 > 0) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(", ");
						}
						_r$19 = $clone(f, reflect.Value).Index(i$3); /* */ $s = 100; case 100: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
						$r = p.printValue($clone(_r$19, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 101; case 101: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						i$3 = i$3 + (1) >> 0;
					/* } */ $s = 98; continue; case 99:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);
					$s = 95; continue;
				/* } else { */ case 94:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(91);
					i$4 = 0;
					/* while (true) { */ case 102:
						/* if (!(i$4 < $clone(f, reflect.Value).Len())) { break; } */ if(!(i$4 < $clone(f, reflect.Value).Len())) { $s = 103; continue; }
						if (i$4 > 0) {
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
						}
						_r$20 = $clone(f, reflect.Value).Index(i$4); /* */ $s = 104; case 104: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
						$r = p.printValue($clone(_r$20, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 105; case 105: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						i$4 = i$4 + (1) >> 0;
					/* } */ $s = 102; continue; case 103:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(93);
				/* } */ case 95:
				$s = 24; continue;
			/* } else if (_1 === (22)) { */ case 21:
				/* */ if ((depth === 0) && !(($clone(f, reflect.Value).Pointer() === 0))) { $s = 106; continue; }
				/* */ $s = 107; continue;
				/* if ((depth === 0) && !(($clone(f, reflect.Value).Pointer() === 0))) { */ case 106:
						_r$21 = $clone(f, reflect.Value).Elem(); /* */ $s = 109; case 109: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
						a = _r$21;
						_4 = $clone(a, reflect.Value).Kind();
						/* */ if ((_4 === (17)) || (_4 === (23)) || (_4 === (25)) || (_4 === (21))) { $s = 110; continue; }
						/* */ $s = 111; continue;
						/* if ((_4 === (17)) || (_4 === (23)) || (_4 === (25)) || (_4 === (21))) { */ case 110:
							(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(38);
							$r = p.printValue($clone(a, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 112; case 112: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return;
						/* } */ case 111:
					case 108:
				/* } */ case 107:
				$r = p.fmtPointer($clone(f, reflect.Value), verb); /* */ $s = 113; case 113: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else if ((_1 === (18)) || (_1 === (19)) || (_1 === (26))) { */ case 22:
				$r = p.fmtPointer($clone(f, reflect.Value), verb); /* */ $s = 114; case 114: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 24; continue;
			/* } else { */ case 23:
				$r = p.unknownType($clone(f, reflect.Value)); /* */ $s = 115; case 115: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 24:
		case 7:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.printValue }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$2 = _r$2; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f.a = a; $f.bytes = bytes; $f.depth = depth; $f.f = f; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.i$4 = i$4; $f.key = key; $f.name = name; $f.p = p; $f.sorted = sorted; $f.t = t; $f.value = value; $f.value$1 = value$1; $f.verb = verb; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.printValue = function(value, verb, depth) { return this.$val.printValue(value, verb, depth); };
	intFromArg = function(a, argNum) {
		var _1, _r, _tuple, a, argNum, isInt, n, n$1, newArgNum, num, v, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _tuple = $f._tuple; a = $f.a; argNum = $f.argNum; isInt = $f.isInt; n = $f.n; n$1 = $f.n$1; newArgNum = $f.newArgNum; num = $f.num; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		num = 0;
		isInt = false;
		newArgNum = 0;
		newArgNum = argNum;
		/* */ if (argNum < a.$length) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (argNum < a.$length) { */ case 1:
			_tuple = $assertType(((argNum < 0 || argNum >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + argNum]), $Int, true);
			num = _tuple[0];
			isInt = _tuple[1];
			/* */ if (!isInt) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!isInt) { */ case 3:
					_r = reflect.ValueOf(((argNum < 0 || argNum >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + argNum])); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					v = _r;
					_1 = $clone(v, reflect.Value).Kind();
					if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) {
						n = $clone(v, reflect.Value).Int();
						if ((x = (new $Int64(0, (((n.$low + ((n.$high >> 31) * 4294967296)) >> 0)))), (x.$high === n.$high && x.$low === n.$low))) {
							num = (((n.$low + ((n.$high >> 31) * 4294967296)) >> 0));
							isInt = true;
						}
					} else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) {
						n$1 = $clone(v, reflect.Value).Uint();
						if ((x$1 = (new $Int64(n$1.$high, n$1.$low)), (x$1.$high > 0 || (x$1.$high === 0 && x$1.$low >= 0))) && (x$2 = (new $Uint64(0, ((n$1.$low >> 0)))), (x$2.$high === n$1.$high && x$2.$low === n$1.$low))) {
							num = ((n$1.$low >> 0));
							isInt = true;
						}
					}
				case 5:
			/* } */ case 4:
			newArgNum = argNum + 1 >> 0;
			if (tooLarge(num)) {
				num = 0;
				isInt = false;
			}
		/* } */ case 2:
		$s = -1; return [num, isInt, newArgNum];
		/* */ } return; } if ($f === undefined) { $f = { $blk: intFromArg }; } $f._1 = _1; $f._r = _r; $f._tuple = _tuple; $f.a = a; $f.argNum = argNum; $f.isInt = isInt; $f.n = n; $f.n$1 = n$1; $f.newArgNum = newArgNum; $f.num = num; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	parseArgNumber = function(format) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, format, i, index, newi, ok, ok$1, wid, width;
		index = 0;
		wid = 0;
		ok = false;
		if (format.length < 3) {
			_tmp = 0;
			_tmp$1 = 1;
			_tmp$2 = false;
			index = _tmp;
			wid = _tmp$1;
			ok = _tmp$2;
			return [index, wid, ok];
		}
		i = 1;
		while (true) {
			if (!(i < format.length)) { break; }
			if (format.charCodeAt(i) === 93) {
				_tuple = parsenum(format, 1, i);
				width = _tuple[0];
				ok$1 = _tuple[1];
				newi = _tuple[2];
				if (!ok$1 || !((newi === i))) {
					_tmp$3 = 0;
					_tmp$4 = i + 1 >> 0;
					_tmp$5 = false;
					index = _tmp$3;
					wid = _tmp$4;
					ok = _tmp$5;
					return [index, wid, ok];
				}
				_tmp$6 = width - 1 >> 0;
				_tmp$7 = i + 1 >> 0;
				_tmp$8 = true;
				index = _tmp$6;
				wid = _tmp$7;
				ok = _tmp$8;
				return [index, wid, ok];
			}
			i = i + (1) >> 0;
		}
		_tmp$9 = 0;
		_tmp$10 = 1;
		_tmp$11 = false;
		index = _tmp$9;
		wid = _tmp$10;
		ok = _tmp$11;
		return [index, wid, ok];
	};
	pp.ptr.prototype.argNumber = function(argNum, format, i, numArgs) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tuple, argNum, format, found, i, index, newArgNum, newi, numArgs, ok, p, wid;
		newArgNum = 0;
		newi = 0;
		found = false;
		p = this;
		if (format.length <= i || !((format.charCodeAt(i) === 91))) {
			_tmp = argNum;
			_tmp$1 = i;
			_tmp$2 = false;
			newArgNum = _tmp;
			newi = _tmp$1;
			found = _tmp$2;
			return [newArgNum, newi, found];
		}
		p.reordered = true;
		_tuple = parseArgNumber($substring(format, i));
		index = _tuple[0];
		wid = _tuple[1];
		ok = _tuple[2];
		if (ok && 0 <= index && index < numArgs) {
			_tmp$3 = index;
			_tmp$4 = i + wid >> 0;
			_tmp$5 = true;
			newArgNum = _tmp$3;
			newi = _tmp$4;
			found = _tmp$5;
			return [newArgNum, newi, found];
		}
		p.goodArgNum = false;
		_tmp$6 = argNum;
		_tmp$7 = i + wid >> 0;
		_tmp$8 = ok;
		newArgNum = _tmp$6;
		newi = _tmp$7;
		found = _tmp$8;
		return [newArgNum, newi, found];
	};
	pp.prototype.argNumber = function(argNum, format, i, numArgs) { return this.$val.argNumber(argNum, format, i, numArgs); };
	pp.ptr.prototype.badArgNum = function(verb) {
		var p, verb;
		p = this;
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!");
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteRune(verb);
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(BADINDEX)");
	};
	pp.prototype.badArgNum = function(verb) { return this.$val.badArgNum(verb); };
	pp.ptr.prototype.missingArg = function(verb) {
		var p, verb;
		p = this;
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!");
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteRune(verb);
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("(MISSING)");
	};
	pp.prototype.missingArg = function(verb) { return this.$val.missingArg(verb); };
	pp.ptr.prototype.doPrintf = function(format, a) {
		var _1, _i, _r, _r$1, _r$2, _ref, _tmp, _tmp$1, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, a, afterIndex, arg, argNum, c, end, format, i, i$1, lasti, p, size, verb, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; a = $f.a; afterIndex = $f.afterIndex; arg = $f.arg; argNum = $f.argNum; c = $f.c; end = $f.end; format = $f.format; i = $f.i; i$1 = $f.i$1; lasti = $f.lasti; p = $f.p; size = $f.size; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		end = format.length;
		argNum = 0;
		afterIndex = false;
		p.reordered = false;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < end)) { break; } */ if(!(i < end)) { $s = 2; continue; }
			p.goodArgNum = true;
			lasti = i;
			while (true) {
				if (!(i < end && !((format.charCodeAt(i) === 37)))) { break; }
				i = i + (1) >> 0;
			}
			if (i > lasti) {
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString($substring(format, lasti, i));
			}
			if (i >= end) {
				/* break; */ $s = 2; continue;
			}
			i = i + (1) >> 0;
			p.fmt.clearflags();
			/* while (true) { */ case 3:
				/* if (!(i < end)) { break; } */ if(!(i < end)) { $s = 4; continue; }
				c = format.charCodeAt(i);
					_1 = c;
					/* */ if (_1 === (35)) { $s = 6; continue; }
					/* */ if (_1 === (48)) { $s = 7; continue; }
					/* */ if (_1 === (43)) { $s = 8; continue; }
					/* */ if (_1 === (45)) { $s = 9; continue; }
					/* */ if (_1 === (32)) { $s = 10; continue; }
					/* */ $s = 11; continue;
					/* if (_1 === (35)) { */ case 6:
						p.fmt.fmtFlags.sharp = true;
						$s = 12; continue;
					/* } else if (_1 === (48)) { */ case 7:
						p.fmt.fmtFlags.zero = !p.fmt.fmtFlags.minus;
						$s = 12; continue;
					/* } else if (_1 === (43)) { */ case 8:
						p.fmt.fmtFlags.plus = true;
						$s = 12; continue;
					/* } else if (_1 === (45)) { */ case 9:
						p.fmt.fmtFlags.minus = true;
						p.fmt.fmtFlags.zero = false;
						$s = 12; continue;
					/* } else if (_1 === (32)) { */ case 10:
						p.fmt.fmtFlags.space = true;
						$s = 12; continue;
					/* } else { */ case 11:
						/* */ if (97 <= c && c <= 122 && argNum < a.$length) { $s = 13; continue; }
						/* */ $s = 14; continue;
						/* if (97 <= c && c <= 122 && argNum < a.$length) { */ case 13:
							if (c === 118) {
								p.fmt.fmtFlags.sharpV = p.fmt.fmtFlags.sharp;
								p.fmt.fmtFlags.sharp = false;
								p.fmt.fmtFlags.plusV = p.fmt.fmtFlags.plus;
								p.fmt.fmtFlags.plus = false;
							}
							$r = p.printArg(((argNum < 0 || argNum >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + argNum]), ((c >> 0))); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							argNum = argNum + (1) >> 0;
							i = i + (1) >> 0;
							/* continue formatLoop; */ $s = 1; continue s;
						/* } */ case 14:
						/* break simpleFormat; */ $s = 4; continue s;
					/* } */ case 12:
				case 5:
				i = i + (1) >> 0;
			/* } */ $s = 3; continue; case 4:
			_tuple = p.argNumber(argNum, format, i, a.$length);
			argNum = _tuple[0];
			i = _tuple[1];
			afterIndex = _tuple[2];
			/* */ if (i < end && (format.charCodeAt(i) === 42)) { $s = 16; continue; }
			/* */ $s = 17; continue;
			/* if (i < end && (format.charCodeAt(i) === 42)) { */ case 16:
				i = i + (1) >> 0;
				_r = intFromArg(a, argNum); /* */ $s = 19; case 19: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple$1 = _r;
				p.fmt.wid = _tuple$1[0];
				p.fmt.fmtFlags.widPresent = _tuple$1[1];
				argNum = _tuple$1[2];
				if (!p.fmt.fmtFlags.widPresent) {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!(BADWIDTH)");
				}
				if (p.fmt.wid < 0) {
					p.fmt.wid = -p.fmt.wid;
					p.fmt.fmtFlags.minus = true;
					p.fmt.fmtFlags.zero = false;
				}
				afterIndex = false;
				$s = 18; continue;
			/* } else { */ case 17:
				_tuple$2 = parsenum(format, i, end);
				p.fmt.wid = _tuple$2[0];
				p.fmt.fmtFlags.widPresent = _tuple$2[1];
				i = _tuple$2[2];
				if (afterIndex && p.fmt.fmtFlags.widPresent) {
					p.goodArgNum = false;
				}
			/* } */ case 18:
			/* */ if ((i + 1 >> 0) < end && (format.charCodeAt(i) === 46)) { $s = 20; continue; }
			/* */ $s = 21; continue;
			/* if ((i + 1 >> 0) < end && (format.charCodeAt(i) === 46)) { */ case 20:
				i = i + (1) >> 0;
				if (afterIndex) {
					p.goodArgNum = false;
				}
				_tuple$3 = p.argNumber(argNum, format, i, a.$length);
				argNum = _tuple$3[0];
				i = _tuple$3[1];
				afterIndex = _tuple$3[2];
				/* */ if (i < end && (format.charCodeAt(i) === 42)) { $s = 22; continue; }
				/* */ $s = 23; continue;
				/* if (i < end && (format.charCodeAt(i) === 42)) { */ case 22:
					i = i + (1) >> 0;
					_r$1 = intFromArg(a, argNum); /* */ $s = 25; case 25: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_tuple$4 = _r$1;
					p.fmt.prec = _tuple$4[0];
					p.fmt.fmtFlags.precPresent = _tuple$4[1];
					argNum = _tuple$4[2];
					if (p.fmt.prec < 0) {
						p.fmt.prec = 0;
						p.fmt.fmtFlags.precPresent = false;
					}
					if (!p.fmt.fmtFlags.precPresent) {
						(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!(BADPREC)");
					}
					afterIndex = false;
					$s = 24; continue;
				/* } else { */ case 23:
					_tuple$5 = parsenum(format, i, end);
					p.fmt.prec = _tuple$5[0];
					p.fmt.fmtFlags.precPresent = _tuple$5[1];
					i = _tuple$5[2];
					if (!p.fmt.fmtFlags.precPresent) {
						p.fmt.prec = 0;
						p.fmt.fmtFlags.precPresent = true;
					}
				/* } */ case 24:
			/* } */ case 21:
			if (!afterIndex) {
				_tuple$6 = p.argNumber(argNum, format, i, a.$length);
				argNum = _tuple$6[0];
				i = _tuple$6[1];
				afterIndex = _tuple$6[2];
			}
			if (i >= end) {
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!(NOVERB)");
				/* break; */ $s = 2; continue;
			}
			_tmp = ((format.charCodeAt(i) >> 0));
			_tmp$1 = 1;
			verb = _tmp;
			size = _tmp$1;
			if (verb >= 128) {
				_tuple$7 = utf8.DecodeRuneInString($substring(format, i));
				verb = _tuple$7[0];
				size = _tuple$7[1];
			}
			i = i + (size) >> 0;
				/* */ if ((verb === 37)) { $s = 27; continue; }
				/* */ if (!p.goodArgNum) { $s = 28; continue; }
				/* */ if (argNum >= a.$length) { $s = 29; continue; }
				/* */ if ((verb === 118)) { $s = 30; continue; }
				/* */ $s = 31; continue;
				/* if ((verb === 37)) { */ case 27:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(37);
					$s = 32; continue;
				/* } else if (!p.goodArgNum) { */ case 28:
					p.badArgNum(verb);
					$s = 32; continue;
				/* } else if (argNum >= a.$length) { */ case 29:
					p.missingArg(verb);
					$s = 32; continue;
				/* } else if ((verb === 118)) { */ case 30:
					p.fmt.fmtFlags.sharpV = p.fmt.fmtFlags.sharp;
					p.fmt.fmtFlags.sharp = false;
					p.fmt.fmtFlags.plusV = p.fmt.fmtFlags.plus;
					p.fmt.fmtFlags.plus = false;
					$r = p.printArg(((argNum < 0 || argNum >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + argNum]), verb); /* */ $s = 33; case 33: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					argNum = argNum + (1) >> 0;
					$s = 32; continue;
				/* } else { */ case 31:
					$r = p.printArg(((argNum < 0 || argNum >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + argNum]), verb); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					argNum = argNum + (1) >> 0;
				/* } */ case 32:
			case 26:
		/* } */ $s = 1; continue; case 2:
		/* */ if (!p.reordered && argNum < a.$length) { $s = 35; continue; }
		/* */ $s = 36; continue;
		/* if (!p.reordered && argNum < a.$length) { */ case 35:
			p.fmt.clearflags();
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("%!(EXTRA ");
			_ref = $subslice(a, argNum);
			_i = 0;
			/* while (true) { */ case 37:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 38; continue; }
				i$1 = _i;
				arg = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (i$1 > 0) {
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(", ");
				}
				/* */ if ($interfaceIsEqual(arg, $ifaceNil)) { $s = 39; continue; }
				/* */ $s = 40; continue;
				/* if ($interfaceIsEqual(arg, $ifaceNil)) { */ case 39:
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString("<nil>");
					$s = 41; continue;
				/* } else { */ case 40:
					_r$2 = reflect.TypeOf(arg).String(); /* */ $s = 42; case 42: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$2); /* */ $s = 43; case 43: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(61);
					$r = p.printArg(arg, 118); /* */ $s = 44; case 44: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 41:
				_i++;
			/* } */ $s = 37; continue; case 38:
			(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);
		/* } */ case 36:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.doPrintf }; } $f._1 = _1; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f.a = a; $f.afterIndex = afterIndex; $f.arg = arg; $f.argNum = argNum; $f.c = c; $f.end = end; $f.format = format; $f.i = i; $f.i$1 = i$1; $f.lasti = lasti; $f.p = p; $f.size = size; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.doPrintf = function(format, a) { return this.$val.doPrintf(format, a); };
	pp.ptr.prototype.doPrint = function(a) {
		var _i, _r, _ref, _v, a, arg, argNum, isString, p, prevString, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _v = $f._v; a = $f.a; arg = $f.arg; argNum = $f.argNum; isString = $f.isString; p = $f.p; prevString = $f.prevString; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		prevString = false;
		_ref = a;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			argNum = _i;
			arg = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!(!($interfaceIsEqual(arg, $ifaceNil)))) { _v = false; $s = 3; continue s; }
			_r = reflect.TypeOf(arg).Kind(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_v = _r === 24; case 3:
			isString = _v;
			if (argNum > 0 && !isString && !prevString) {
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
			}
			$r = p.printArg(arg, 118); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			prevString = isString;
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.doPrint }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._v = _v; $f.a = a; $f.arg = arg; $f.argNum = argNum; $f.isString = isString; $f.p = p; $f.prevString = prevString; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.doPrint = function(a) { return this.$val.doPrint(a); };
	pp.ptr.prototype.doPrintln = function(a) {
		var _i, _ref, a, arg, argNum, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _ref = $f._ref; a = $f.a; arg = $f.arg; argNum = $f.argNum; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_ref = a;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			argNum = _i;
			arg = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (argNum > 0) {
				(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);
			}
			$r = p.printArg(arg, 118); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 1; continue; case 2:
		(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(10);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.doPrintln }; } $f._i = _i; $f._ref = _ref; $f.a = a; $f.arg = arg; $f.argNum = argNum; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	pp.prototype.doPrintln = function(a) { return this.$val.doPrintln(a); };
	ss.ptr.prototype.Read = function(buf) {
		var _tmp, _tmp$1, buf, err, n, s;
		n = 0;
		err = $ifaceNil;
		s = this;
		_tmp = 0;
		_tmp$1 = errors.New("ScanState's Read should not be called. Use ReadRune");
		n = _tmp;
		err = _tmp$1;
		return [n, err];
	};
	ss.prototype.Read = function(buf) { return this.$val.Read(buf); };
	ss.ptr.prototype.ReadRune = function() {
		var _r, _tuple, err, r, s, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; r = $f.r; s = $f.s; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = 0;
		size = 0;
		err = $ifaceNil;
		s = this;
		if (s.atEOF || s.count >= s.ssave.argLimit) {
			err = io.EOF;
			$s = -1; return [r, size, err];
		}
		_r = s.rs.ReadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		size = _tuple[1];
		err = _tuple[2];
		if ($interfaceIsEqual(err, $ifaceNil)) {
			s.count = s.count + (1) >> 0;
			if (s.ssave.nlIsEnd && (r === 10)) {
				s.atEOF = true;
			}
		} else if ($interfaceIsEqual(err, io.EOF)) {
			s.atEOF = true;
		}
		$s = -1; return [r, size, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.ReadRune }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.r = r; $f.s = s; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	ss.ptr.prototype.Width = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, ok, s, wid;
		wid = 0;
		ok = false;
		s = this;
		if (s.ssave.maxWid === 1073741824) {
			_tmp = 0;
			_tmp$1 = false;
			wid = _tmp;
			ok = _tmp$1;
			return [wid, ok];
		}
		_tmp$2 = s.ssave.maxWid;
		_tmp$3 = true;
		wid = _tmp$2;
		ok = _tmp$3;
		return [wid, ok];
	};
	ss.prototype.Width = function() { return this.$val.Width(); };
	ss.ptr.prototype.getRune = function() {
		var _r, _tuple, err, r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; r = $f.r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = 0;
		s = this;
		_r = s.ReadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			if ($interfaceIsEqual(err, io.EOF)) {
				r = -1;
				$s = -1; return r;
			}
			s.error(err);
		}
		$s = -1; return r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.getRune }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.r = r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.getRune = function() { return this.$val.getRune(); };
	ss.ptr.prototype.UnreadRune = function() {
		var _r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		_r = s.rs.UnreadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		s.atEOF = false;
		s.count = s.count - (1) >> 0;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.UnreadRune }; } $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	ss.ptr.prototype.error = function(err) {
		var err, s, x;
		s = this;
		$panic((x = new scanError.ptr(err), new x.constructor.elem(x)));
	};
	ss.prototype.error = function(err) { return this.$val.error(err); };
	ss.ptr.prototype.errorString = function(err) {
		var err, s, x;
		s = this;
		$panic((x = new scanError.ptr(errors.New(err)), new x.constructor.elem(x)));
	};
	ss.prototype.errorString = function(err) { return this.$val.errorString(err); };
	ss.ptr.prototype.Token = function(skipSpace, f) {
		var _r, err, f, s, skipSpace, tok, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; f = $f.f; s = $f.s; skipSpace = $f.skipSpace; tok = $f.tok; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		err = [err];
		tok = sliceType$2.nil;
		err[0] = $ifaceNil;
		s = this;
		$deferred.push([(function(err) { return function() {
			var _tuple, e, ok, se;
			e = $recover();
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				_tuple = $assertType(e, scanError, true);
				se = $clone(_tuple[0], scanError);
				ok = _tuple[1];
				if (ok) {
					err[0] = se.err;
				} else {
					$panic(e);
				}
			}
		}; })(err), []]);
		if (f === $throwNilPointerError) {
			f = notSpace;
		}
		s.buf = $subslice(s.buf, 0, 0);
		_r = s.token(skipSpace, f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tok = _r;
		$s = -1; return [tok, err[0]];
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  [tok, err[0]]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: ss.ptr.prototype.Token }; } $f._r = _r; $f.err = err; $f.f = f; $f.s = s; $f.skipSpace = skipSpace; $f.tok = tok; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	ss.prototype.Token = function(skipSpace, f) { return this.$val.Token(skipSpace, f); };
	isSpace = function(r) {
		var _i, _ref, r, rng, rx;
		if (r >= 65536) {
			return false;
		}
		rx = ((r << 16 >>> 16));
		_ref = space;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			rng = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), arrayType$1);
			if (rx < rng[0]) {
				return false;
			}
			if (rx <= rng[1]) {
				return true;
			}
			_i++;
		}
		return false;
	};
	notSpace = function(r) {
		var r;
		return !isSpace(r);
	};
	ss.ptr.prototype.free = function(old) {
		var old, s;
		s = this;
		if (old.validSave) {
			ssave.copy(s.ssave, old);
			return;
		}
		if (s.buf.$capacity > 1024) {
			return;
		}
		s.buf = $subslice(s.buf, 0, 0);
		s.rs = $ifaceNil;
		ssFree.Put(s);
	};
	ss.prototype.free = function(old) { return this.$val.free(old); };
	ss.ptr.prototype.SkipSpace = function() {
		var _r, _r$1, _r$2, _v, r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _v = $f._v; r = $f.r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		/* while (true) { */ case 1:
			_r = s.getRune(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			r = _r;
			if (r === -1) {
				$s = -1; return;
			}
			if (!(r === 13)) { _v = false; $s = 6; continue s; }
			_r$1 = s.peek("\n"); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_v = _r$1; case 6:
			/* */ if (_v) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_v) { */ case 4:
				/* continue; */ $s = 1; continue;
			/* } */ case 5:
			/* */ if (r === 10) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (r === 10) { */ case 8:
				if (s.ssave.nlIsSpace) {
					/* continue; */ $s = 1; continue;
				}
				s.errorString("unexpected newline");
				$s = -1; return;
			/* } */ case 9:
			/* */ if (!isSpace(r)) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (!isSpace(r)) { */ case 10:
				_r$2 = s.UnreadRune(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$2;
				/* break; */ $s = 2; continue;
			/* } */ case 11:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.SkipSpace }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._v = _v; $f.r = r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.SkipSpace = function() { return this.$val.SkipSpace(); };
	ss.ptr.prototype.token = function(skipSpace, f) {
		var _r, _r$1, _r$2, f, r, s, skipSpace, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; f = $f.f; r = $f.r; s = $f.s; skipSpace = $f.skipSpace; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		/* */ if (skipSpace) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (skipSpace) { */ case 1:
			$r = s.SkipSpace(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		/* while (true) { */ case 4:
			_r = s.getRune(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			r = _r;
			if (r === -1) {
				/* break; */ $s = 5; continue;
			}
			_r$1 = f(r); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (!_r$1) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!_r$1) { */ case 7:
				_r$2 = s.UnreadRune(); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$2;
				/* break; */ $s = 5; continue;
			/* } */ case 8:
			(s.$ptr_buf || (s.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, s))).WriteRune(r);
		/* } */ $s = 4; continue; case 5:
		$s = -1; return (x = s.buf, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length));
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.token }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.f = f; $f.r = r; $f.s = s; $f.skipSpace = skipSpace; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.token = function(skipSpace, f) { return this.$val.token(skipSpace, f); };
	indexRune = function(s, r) {
		var _i, _ref, _rune, c, i, r, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			c = _rune[0];
			if (c === r) {
				return i;
			}
			_i += _rune[1];
		}
		return -1;
	};
	ss.ptr.prototype.peek = function(ok) {
		var _r, _r$1, ok, r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; ok = $f.ok; r = $f.r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		_r = s.getRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		r = _r;
		/* */ if (!((r === -1))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((r === -1))) { */ case 2:
			_r$1 = s.UnreadRune(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$1;
		/* } */ case 3:
		$s = -1; return indexRune(ok, r) >= 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.peek }; } $f._r = _r; $f._r$1 = _r$1; $f.ok = ok; $f.r = r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	ss.prototype.peek = function(ok) { return this.$val.peek(ok); };
	ptrType$25.methods = [{prop: "clearflags", name: "clearflags", pkg: "fmt", typ: $funcType([], [], false)}, {prop: "init", name: "init", pkg: "fmt", typ: $funcType([ptrType$1], [], false)}, {prop: "writePadding", name: "writePadding", pkg: "fmt", typ: $funcType([$Int], [], false)}, {prop: "pad", name: "pad", pkg: "fmt", typ: $funcType([sliceType$2], [], false)}, {prop: "padString", name: "padString", pkg: "fmt", typ: $funcType([$String], [], false)}, {prop: "fmtBoolean", name: "fmtBoolean", pkg: "fmt", typ: $funcType([$Bool], [], false)}, {prop: "fmtUnicode", name: "fmtUnicode", pkg: "fmt", typ: $funcType([$Uint64], [], false)}, {prop: "fmtInteger", name: "fmtInteger", pkg: "fmt", typ: $funcType([$Uint64, $Int, $Bool, $String], [], false)}, {prop: "truncateString", name: "truncateString", pkg: "fmt", typ: $funcType([$String], [$String], false)}, {prop: "truncate", name: "truncate", pkg: "fmt", typ: $funcType([sliceType$2], [sliceType$2], false)}, {prop: "fmtS", name: "fmtS", pkg: "fmt", typ: $funcType([$String], [], false)}, {prop: "fmtBs", name: "fmtBs", pkg: "fmt", typ: $funcType([sliceType$2], [], false)}, {prop: "fmtSbx", name: "fmtSbx", pkg: "fmt", typ: $funcType([$String, sliceType$2, $String], [], false)}, {prop: "fmtSx", name: "fmtSx", pkg: "fmt", typ: $funcType([$String, $String], [], false)}, {prop: "fmtBx", name: "fmtBx", pkg: "fmt", typ: $funcType([sliceType$2, $String], [], false)}, {prop: "fmtQ", name: "fmtQ", pkg: "fmt", typ: $funcType([$String], [], false)}, {prop: "fmtC", name: "fmtC", pkg: "fmt", typ: $funcType([$Uint64], [], false)}, {prop: "fmtQc", name: "fmtQc", pkg: "fmt", typ: $funcType([$Uint64], [], false)}, {prop: "fmtFloat", name: "fmtFloat", pkg: "fmt", typ: $funcType([$Float64, $Int, $Int32, $Int], [], false)}];
	ptrType$1.methods = [{prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$2], [], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [], false)}];
	ptrType$2.methods = [{prop: "free", name: "free", pkg: "fmt", typ: $funcType([], [], false)}, {prop: "Width", name: "Width", pkg: "", typ: $funcType([], [$Int, $Bool], false)}, {prop: "Precision", name: "Precision", pkg: "", typ: $funcType([], [$Int, $Bool], false)}, {prop: "Flag", name: "Flag", pkg: "", typ: $funcType([$Int], [$Bool], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}, {prop: "unknownType", name: "unknownType", pkg: "fmt", typ: $funcType([reflect.Value], [], false)}, {prop: "badVerb", name: "badVerb", pkg: "fmt", typ: $funcType([$Int32], [], false)}, {prop: "fmtBool", name: "fmtBool", pkg: "fmt", typ: $funcType([$Bool, $Int32], [], false)}, {prop: "fmt0x64", name: "fmt0x64", pkg: "fmt", typ: $funcType([$Uint64, $Bool], [], false)}, {prop: "fmtInteger", name: "fmtInteger", pkg: "fmt", typ: $funcType([$Uint64, $Bool, $Int32], [], false)}, {prop: "fmtFloat", name: "fmtFloat", pkg: "fmt", typ: $funcType([$Float64, $Int, $Int32], [], false)}, {prop: "fmtComplex", name: "fmtComplex", pkg: "fmt", typ: $funcType([$Complex128, $Int, $Int32], [], false)}, {prop: "fmtString", name: "fmtString", pkg: "fmt", typ: $funcType([$String, $Int32], [], false)}, {prop: "fmtBytes", name: "fmtBytes", pkg: "fmt", typ: $funcType([sliceType$2, $Int32, $String], [], false)}, {prop: "fmtPointer", name: "fmtPointer", pkg: "fmt", typ: $funcType([reflect.Value, $Int32], [], false)}, {prop: "catchPanic", name: "catchPanic", pkg: "fmt", typ: $funcType([$emptyInterface, $Int32, $String], [], false)}, {prop: "handleMethods", name: "handleMethods", pkg: "fmt", typ: $funcType([$Int32], [$Bool], false)}, {prop: "printArg", name: "printArg", pkg: "fmt", typ: $funcType([$emptyInterface, $Int32], [], false)}, {prop: "printValue", name: "printValue", pkg: "fmt", typ: $funcType([reflect.Value, $Int32, $Int], [], false)}, {prop: "argNumber", name: "argNumber", pkg: "fmt", typ: $funcType([$Int, $String, $Int, $Int], [$Int, $Int, $Bool], false)}, {prop: "badArgNum", name: "badArgNum", pkg: "fmt", typ: $funcType([$Int32], [], false)}, {prop: "missingArg", name: "missingArg", pkg: "fmt", typ: $funcType([$Int32], [], false)}, {prop: "doPrintf", name: "doPrintf", pkg: "fmt", typ: $funcType([$String, sliceType], [], false)}, {prop: "doPrint", name: "doPrint", pkg: "fmt", typ: $funcType([sliceType], [], false)}, {prop: "doPrintln", name: "doPrintln", pkg: "fmt", typ: $funcType([sliceType], [], false)}];
	ptrType$5.methods = [{prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "Width", name: "Width", pkg: "", typ: $funcType([], [$Int, $Bool], false)}, {prop: "getRune", name: "getRune", pkg: "fmt", typ: $funcType([], [$Int32], false)}, {prop: "mustReadRune", name: "mustReadRune", pkg: "fmt", typ: $funcType([], [$Int32], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "error", name: "error", pkg: "fmt", typ: $funcType([$error], [], false)}, {prop: "errorString", name: "errorString", pkg: "fmt", typ: $funcType([$String], [], false)}, {prop: "Token", name: "Token", pkg: "", typ: $funcType([$Bool, funcType], [sliceType$2, $error], false)}, {prop: "free", name: "free", pkg: "fmt", typ: $funcType([ssave], [], false)}, {prop: "SkipSpace", name: "SkipSpace", pkg: "", typ: $funcType([], [], false)}, {prop: "token", name: "token", pkg: "fmt", typ: $funcType([$Bool, funcType], [sliceType$2], false)}, {prop: "consume", name: "consume", pkg: "fmt", typ: $funcType([$String, $Bool], [$Bool], false)}, {prop: "peek", name: "peek", pkg: "fmt", typ: $funcType([$String], [$Bool], false)}, {prop: "notEOF", name: "notEOF", pkg: "fmt", typ: $funcType([], [], false)}, {prop: "accept", name: "accept", pkg: "fmt", typ: $funcType([$String], [$Bool], false)}, {prop: "okVerb", name: "okVerb", pkg: "fmt", typ: $funcType([$Int32, $String, $String], [$Bool], false)}, {prop: "scanBool", name: "scanBool", pkg: "fmt", typ: $funcType([$Int32], [$Bool], false)}, {prop: "getBase", name: "getBase", pkg: "fmt", typ: $funcType([$Int32], [$Int, $String], false)}, {prop: "scanNumber", name: "scanNumber", pkg: "fmt", typ: $funcType([$String, $Bool], [$String], false)}, {prop: "scanRune", name: "scanRune", pkg: "fmt", typ: $funcType([$Int], [$Int64], false)}, {prop: "scanBasePrefix", name: "scanBasePrefix", pkg: "fmt", typ: $funcType([], [$Int, $String, $Bool], false)}, {prop: "scanInt", name: "scanInt", pkg: "fmt", typ: $funcType([$Int32, $Int], [$Int64], false)}, {prop: "scanUint", name: "scanUint", pkg: "fmt", typ: $funcType([$Int32, $Int], [$Uint64], false)}, {prop: "floatToken", name: "floatToken", pkg: "fmt", typ: $funcType([], [$String], false)}, {prop: "complexTokens", name: "complexTokens", pkg: "fmt", typ: $funcType([], [$String, $String], false)}, {prop: "convertFloat", name: "convertFloat", pkg: "fmt", typ: $funcType([$String, $Int], [$Float64], false)}, {prop: "scanComplex", name: "scanComplex", pkg: "fmt", typ: $funcType([$Int32, $Int], [$Complex128], false)}, {prop: "convertString", name: "convertString", pkg: "fmt", typ: $funcType([$Int32], [$String], false)}, {prop: "quotedString", name: "quotedString", pkg: "fmt", typ: $funcType([], [$String], false)}, {prop: "hexByte", name: "hexByte", pkg: "fmt", typ: $funcType([], [$Uint8, $Bool], false)}, {prop: "hexString", name: "hexString", pkg: "fmt", typ: $funcType([], [$String], false)}, {prop: "scanOne", name: "scanOne", pkg: "fmt", typ: $funcType([$Int32, $emptyInterface], [], false)}, {prop: "doScan", name: "doScan", pkg: "fmt", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "advance", name: "advance", pkg: "fmt", typ: $funcType([$String], [$Int], false)}, {prop: "doScanf", name: "doScanf", pkg: "fmt", typ: $funcType([$String, sliceType], [$Int, $error], false)}];
	fmtFlags.init("fmt", [{prop: "widPresent", name: "widPresent", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "precPresent", name: "precPresent", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "minus", name: "minus", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "plus", name: "plus", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "sharp", name: "sharp", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "space", name: "space", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "zero", name: "zero", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "plusV", name: "plusV", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "sharpV", name: "sharpV", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	fmt.init("fmt", [{prop: "buf", name: "buf", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "fmtFlags", name: "fmtFlags", embedded: true, exported: false, typ: fmtFlags, tag: ""}, {prop: "wid", name: "wid", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "prec", name: "prec", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "intbuf", name: "intbuf", embedded: false, exported: false, typ: arrayType, tag: ""}]);
	State.init([{prop: "Flag", name: "Flag", pkg: "", typ: $funcType([$Int], [$Bool], false)}, {prop: "Precision", name: "Precision", pkg: "", typ: $funcType([], [$Int, $Bool], false)}, {prop: "Width", name: "Width", pkg: "", typ: $funcType([], [$Int, $Bool], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$2], [$Int, $error], false)}]);
	Formatter.init([{prop: "Format", name: "Format", pkg: "", typ: $funcType([State, $Int32], [], false)}]);
	Stringer.init([{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}]);
	GoStringer.init([{prop: "GoString", name: "GoString", pkg: "", typ: $funcType([], [$String], false)}]);
	buffer.init($Uint8);
	pp.init("fmt", [{prop: "buf", name: "buf", embedded: false, exported: false, typ: buffer, tag: ""}, {prop: "arg", name: "arg", embedded: false, exported: false, typ: $emptyInterface, tag: ""}, {prop: "value", name: "value", embedded: false, exported: false, typ: reflect.Value, tag: ""}, {prop: "fmt", name: "fmt", embedded: false, exported: false, typ: fmt, tag: ""}, {prop: "reordered", name: "reordered", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "goodArgNum", name: "goodArgNum", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "panicking", name: "panicking", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "erroring", name: "erroring", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	scanError.init("fmt", [{prop: "err", name: "err", embedded: false, exported: false, typ: $error, tag: ""}]);
	ss.init("fmt", [{prop: "rs", name: "rs", embedded: false, exported: false, typ: io.RuneScanner, tag: ""}, {prop: "buf", name: "buf", embedded: false, exported: false, typ: buffer, tag: ""}, {prop: "count", name: "count", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "atEOF", name: "atEOF", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "ssave", name: "ssave", embedded: true, exported: false, typ: ssave, tag: ""}]);
	ssave.init("fmt", [{prop: "validSave", name: "validSave", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "nlIsEnd", name: "nlIsEnd", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "nlIsSpace", name: "nlIsSpace", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "argLimit", name: "argLimit", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "limit", name: "limit", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "maxWid", name: "maxWid", embedded: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmtsort.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = os.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = reflect.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		ppFree = new sync.Pool.ptr(0, 0, sliceType.nil, (function() {
			return new pp.ptr(buffer.nil, $ifaceNil, new reflect.Value.ptr(ptrType.nil, 0, 0), new fmt.ptr(ptrType$1.nil, new fmtFlags.ptr(false, false, false, false, false, false, false, false, false), 0, 0, arrayType.zero()), false, false, false, false);
		}));
		space = new sliceType$1([$toNativeArray($kindUint16, [9, 13]), $toNativeArray($kindUint16, [32, 32]), $toNativeArray($kindUint16, [133, 133]), $toNativeArray($kindUint16, [160, 160]), $toNativeArray($kindUint16, [5760, 5760]), $toNativeArray($kindUint16, [8192, 8202]), $toNativeArray($kindUint16, [8232, 8233]), $toNativeArray($kindUint16, [8239, 8239]), $toNativeArray($kindUint16, [8287, 8287]), $toNativeArray($kindUint16, [12288, 12288])]);
		ssFree = new sync.Pool.ptr(0, 0, sliceType.nil, (function() {
			return new ss.ptr($ifaceNil, buffer.nil, 0, false, new ssave.ptr(false, false, false, 0, 0, 0));
		}));
		complexError = errors.New("syntax error scanning complex number");
		boolError = errors.New("syntax error scanning boolean");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["compress/flate"] = (function() {
	var $pkg = {}, $init, bufio, fmt, io, math, bits, sort, strconv, sync, dictDecoder, huffmanBitWriter, hcode, huffmanEncoder, literalNode, levelInfo, byLiteral, byFreq, CorruptInputError, InternalError, Resetter, huffmanDecoder, Reader, decompressor, token, ptrType, arrayType, sliceType, sliceType$1, sliceType$4, sliceType$5, ptrType$3, arrayType$5, arrayType$6, sliceType$7, sliceType$8, sliceType$9, arrayType$7, arrayType$8, arrayType$9, arrayType$10, ptrType$7, ptrType$8, arrayType$11, ptrType$9, sliceType$10, ptrType$10, arrayType$12, arrayType$13, ptrType$11, arrayType$14, ptrType$12, arrayType$15, ptrType$13, ptrType$14, funcType$3, huffOffset, fixedLiteralEncoding, fixedOffsetEncoding, fixedOnce, fixedHuffmanDecoder, fixedHuffmanDecoder$24ptr, codeOrder, newHuffmanBitWriter, init, maxNode, newHuffmanEncoder, generateFixedLiteralEncoding, generateFixedOffsetEncoding, reverseBits, noEOF, makeReader, fixedHuffmanDecoderInit, NewReader;
	bufio = $packages["bufio"];
	fmt = $packages["fmt"];
	io = $packages["io"];
	math = $packages["math"];
	bits = $packages["math/bits"];
	sort = $packages["sort"];
	strconv = $packages["strconv"];
	sync = $packages["sync"];
	dictDecoder = $pkg.dictDecoder = $newType(0, $kindStruct, "flate.dictDecoder", true, "compress/flate", false, function(hist_, wrPos_, rdPos_, full_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.hist = sliceType$4.nil;
			this.wrPos = 0;
			this.rdPos = 0;
			this.full = false;
			return;
		}
		this.hist = hist_;
		this.wrPos = wrPos_;
		this.rdPos = rdPos_;
		this.full = full_;
	});
	huffmanBitWriter = $pkg.huffmanBitWriter = $newType(0, $kindStruct, "flate.huffmanBitWriter", true, "compress/flate", false, function(writer_, bits_, nbits_, bytes_, codegenFreq_, nbytes_, literalFreq_, offsetFreq_, codegen_, literalEncoding_, offsetEncoding_, codegenEncoding_, err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.writer = $ifaceNil;
			this.bits = new $Uint64(0, 0);
			this.nbits = 0;
			this.bytes = arrayType$5.zero();
			this.codegenFreq = arrayType$6.zero();
			this.nbytes = 0;
			this.literalFreq = sliceType$7.nil;
			this.offsetFreq = sliceType$7.nil;
			this.codegen = sliceType$4.nil;
			this.literalEncoding = ptrType.nil;
			this.offsetEncoding = ptrType.nil;
			this.codegenEncoding = ptrType.nil;
			this.err = $ifaceNil;
			return;
		}
		this.writer = writer_;
		this.bits = bits_;
		this.nbits = nbits_;
		this.bytes = bytes_;
		this.codegenFreq = codegenFreq_;
		this.nbytes = nbytes_;
		this.literalFreq = literalFreq_;
		this.offsetFreq = offsetFreq_;
		this.codegen = codegen_;
		this.literalEncoding = literalEncoding_;
		this.offsetEncoding = offsetEncoding_;
		this.codegenEncoding = codegenEncoding_;
		this.err = err_;
	});
	hcode = $pkg.hcode = $newType(0, $kindStruct, "flate.hcode", true, "compress/flate", false, function(code_, len_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.code = 0;
			this.len = 0;
			return;
		}
		this.code = code_;
		this.len = len_;
	});
	huffmanEncoder = $pkg.huffmanEncoder = $newType(0, $kindStruct, "flate.huffmanEncoder", true, "compress/flate", false, function(codes_, freqcache_, bitCount_, lns_, lfs_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.codes = sliceType$8.nil;
			this.freqcache = sliceType$9.nil;
			this.bitCount = arrayType$7.zero();
			this.lns = byLiteral.nil;
			this.lfs = byFreq.nil;
			return;
		}
		this.codes = codes_;
		this.freqcache = freqcache_;
		this.bitCount = bitCount_;
		this.lns = lns_;
		this.lfs = lfs_;
	});
	literalNode = $pkg.literalNode = $newType(0, $kindStruct, "flate.literalNode", true, "compress/flate", false, function(literal_, freq_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.literal = 0;
			this.freq = 0;
			return;
		}
		this.literal = literal_;
		this.freq = freq_;
	});
	levelInfo = $pkg.levelInfo = $newType(0, $kindStruct, "flate.levelInfo", true, "compress/flate", false, function(level_, lastFreq_, nextCharFreq_, nextPairFreq_, needed_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.level = 0;
			this.lastFreq = 0;
			this.nextCharFreq = 0;
			this.nextPairFreq = 0;
			this.needed = 0;
			return;
		}
		this.level = level_;
		this.lastFreq = lastFreq_;
		this.nextCharFreq = nextCharFreq_;
		this.nextPairFreq = nextPairFreq_;
		this.needed = needed_;
	});
	byLiteral = $pkg.byLiteral = $newType(12, $kindSlice, "flate.byLiteral", true, "compress/flate", false, null);
	byFreq = $pkg.byFreq = $newType(12, $kindSlice, "flate.byFreq", true, "compress/flate", false, null);
	CorruptInputError = $pkg.CorruptInputError = $newType(8, $kindInt64, "flate.CorruptInputError", true, "compress/flate", true, null);
	InternalError = $pkg.InternalError = $newType(8, $kindString, "flate.InternalError", true, "compress/flate", true, null);
	Resetter = $pkg.Resetter = $newType(8, $kindInterface, "flate.Resetter", true, "compress/flate", true, null);
	huffmanDecoder = $pkg.huffmanDecoder = $newType(0, $kindStruct, "flate.huffmanDecoder", true, "compress/flate", false, function(min_, chunks_, links_, linkMask_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.min = 0;
			this.chunks = arrayType.zero();
			this.links = sliceType$1.nil;
			this.linkMask = 0;
			return;
		}
		this.min = min_;
		this.chunks = chunks_;
		this.links = links_;
		this.linkMask = linkMask_;
	});
	Reader = $pkg.Reader = $newType(8, $kindInterface, "flate.Reader", true, "compress/flate", true, null);
	decompressor = $pkg.decompressor = $newType(0, $kindStruct, "flate.decompressor", true, "compress/flate", false, function(r_, roffset_, b_, nb_, h1_, h2_, bits_, codebits_, dict_, buf_, step_, stepState_, final$12_, err_, toRead_, hl_, hd_, copyLen_, copyDist_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.r = $ifaceNil;
			this.roffset = new $Int64(0, 0);
			this.b = 0;
			this.nb = 0;
			this.h1 = new huffmanDecoder.ptr(0, arrayType.zero(), sliceType$1.nil, 0);
			this.h2 = new huffmanDecoder.ptr(0, arrayType.zero(), sliceType$1.nil, 0);
			this.bits = ptrType$11.nil;
			this.codebits = ptrType$12.nil;
			this.dict = new dictDecoder.ptr(sliceType$4.nil, 0, 0, false);
			this.buf = arrayType$15.zero();
			this.step = $throwNilPointerError;
			this.stepState = 0;
			this.final$12 = false;
			this.err = $ifaceNil;
			this.toRead = sliceType$4.nil;
			this.hl = ptrType$9.nil;
			this.hd = ptrType$9.nil;
			this.copyLen = 0;
			this.copyDist = 0;
			return;
		}
		this.r = r_;
		this.roffset = roffset_;
		this.b = b_;
		this.nb = nb_;
		this.h1 = h1_;
		this.h2 = h2_;
		this.bits = bits_;
		this.codebits = codebits_;
		this.dict = dict_;
		this.buf = buf_;
		this.step = step_;
		this.stepState = stepState_;
		this.final$12 = final$12_;
		this.err = err_;
		this.toRead = toRead_;
		this.hl = hl_;
		this.hd = hd_;
		this.copyLen = copyLen_;
		this.copyDist = copyDist_;
	});
	token = $pkg.token = $newType(4, $kindUint32, "flate.token", true, "compress/flate", false, null);
	ptrType = $ptrType(huffmanEncoder);
	arrayType = $arrayType($Uint32, 512);
	sliceType = $sliceType($Uint32);
	sliceType$1 = $sliceType(sliceType);
	sliceType$4 = $sliceType($Uint8);
	sliceType$5 = $sliceType(token);
	ptrType$3 = $ptrType(huffmanBitWriter);
	arrayType$5 = $arrayType($Uint8, 248);
	arrayType$6 = $arrayType($Int32, 19);
	sliceType$7 = $sliceType($Int32);
	sliceType$8 = $sliceType(hcode);
	sliceType$9 = $sliceType(literalNode);
	arrayType$7 = $arrayType($Int32, 17);
	arrayType$8 = $arrayType(levelInfo, 16);
	arrayType$9 = $arrayType($Int32, 16);
	arrayType$10 = $arrayType(arrayType$9, 16);
	ptrType$7 = $ptrType(byLiteral);
	ptrType$8 = $ptrType(byFreq);
	arrayType$11 = $arrayType($Int, 16);
	ptrType$9 = $ptrType(huffmanDecoder);
	sliceType$10 = $sliceType($Int);
	ptrType$10 = $ptrType(decompressor);
	arrayType$12 = $arrayType($Int, 288);
	arrayType$13 = $arrayType($Int, 316);
	ptrType$11 = $ptrType(arrayType$13);
	arrayType$14 = $arrayType($Int, 19);
	ptrType$12 = $ptrType(arrayType$14);
	arrayType$15 = $arrayType($Uint8, 4);
	ptrType$13 = $ptrType(dictDecoder);
	ptrType$14 = $ptrType(hcode);
	funcType$3 = $funcType([ptrType$10], [], false);
	dictDecoder.ptr.prototype.init = function(size, dict) {
		var dd, dict, size;
		dd = this;
		dictDecoder.copy(dd, new dictDecoder.ptr(dd.hist, 0, 0, false));
		if (dd.hist.$capacity < size) {
			dd.hist = $makeSlice(sliceType$4, size);
		}
		dd.hist = $subslice(dd.hist, 0, size);
		if (dict.$length > dd.hist.$length) {
			dict = $subslice(dict, (dict.$length - dd.hist.$length >> 0));
		}
		dd.wrPos = $copySlice(dd.hist, dict);
		if (dd.wrPos === dd.hist.$length) {
			dd.wrPos = 0;
			dd.full = true;
		}
		dd.rdPos = dd.wrPos;
	};
	dictDecoder.prototype.init = function(size, dict) { return this.$val.init(size, dict); };
	dictDecoder.ptr.prototype.histSize = function() {
		var dd;
		dd = this;
		if (dd.full) {
			return dd.hist.$length;
		}
		return dd.wrPos;
	};
	dictDecoder.prototype.histSize = function() { return this.$val.histSize(); };
	dictDecoder.ptr.prototype.availRead = function() {
		var dd;
		dd = this;
		return dd.wrPos - dd.rdPos >> 0;
	};
	dictDecoder.prototype.availRead = function() { return this.$val.availRead(); };
	dictDecoder.ptr.prototype.availWrite = function() {
		var dd;
		dd = this;
		return dd.hist.$length - dd.wrPos >> 0;
	};
	dictDecoder.prototype.availWrite = function() { return this.$val.availWrite(); };
	dictDecoder.ptr.prototype.writeSlice = function() {
		var dd;
		dd = this;
		return $subslice(dd.hist, dd.wrPos);
	};
	dictDecoder.prototype.writeSlice = function() { return this.$val.writeSlice(); };
	dictDecoder.ptr.prototype.writeMark = function(cnt) {
		var cnt, dd;
		dd = this;
		dd.wrPos = dd.wrPos + (cnt) >> 0;
	};
	dictDecoder.prototype.writeMark = function(cnt) { return this.$val.writeMark(cnt); };
	dictDecoder.ptr.prototype.writeByte = function(c) {
		var c, dd, x, x$1;
		dd = this;
		(x = dd.hist, x$1 = dd.wrPos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1] = c));
		dd.wrPos = dd.wrPos + (1) >> 0;
	};
	dictDecoder.prototype.writeByte = function(c) { return this.$val.writeByte(c); };
	dictDecoder.ptr.prototype.writeCopy = function(dist, length) {
		var dd, dist, dstBase, dstPos, endPos, length, srcPos;
		dd = this;
		dstBase = dd.wrPos;
		dstPos = dstBase;
		srcPos = dstPos - dist >> 0;
		endPos = dstPos + length >> 0;
		if (endPos > dd.hist.$length) {
			endPos = dd.hist.$length;
		}
		if (srcPos < 0) {
			srcPos = srcPos + (dd.hist.$length) >> 0;
			dstPos = dstPos + ($copySlice($subslice(dd.hist, dstPos, endPos), $subslice(dd.hist, srcPos))) >> 0;
			srcPos = 0;
		}
		while (true) {
			if (!(dstPos < endPos)) { break; }
			dstPos = dstPos + ($copySlice($subslice(dd.hist, dstPos, endPos), $subslice(dd.hist, srcPos, dstPos))) >> 0;
		}
		dd.wrPos = dstPos;
		return dstPos - dstBase >> 0;
	};
	dictDecoder.prototype.writeCopy = function(dist, length) { return this.$val.writeCopy(dist, length); };
	dictDecoder.ptr.prototype.tryWriteCopy = function(dist, length) {
		var dd, dist, dstBase, dstPos, endPos, length, srcPos, $s;
		/* */ $s = 0; s: while (true) { switch ($s) { case 0:
		dd = this;
		dstPos = dd.wrPos;
		endPos = dstPos + length >> 0;
		if (dstPos < dist || endPos > dd.hist.$length) {
			$s = -1; return 0;
		}
		dstBase = dstPos;
		srcPos = dstPos - dist >> 0;
		/* loop: */ case 1:
		dstPos = dstPos + ($copySlice($subslice(dd.hist, dstPos, endPos), $subslice(dd.hist, srcPos, dstPos))) >> 0;
		/* */ if (dstPos < endPos) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (dstPos < endPos) { */ case 2:
			/* goto loop */ $s = 1; continue;
		/* } */ case 3:
		dd.wrPos = dstPos;
		$s = -1; return dstPos - dstBase >> 0;
		/* */ } return; }
	};
	dictDecoder.prototype.tryWriteCopy = function(dist, length) { return this.$val.tryWriteCopy(dist, length); };
	dictDecoder.ptr.prototype.readFlush = function() {
		var _tmp, _tmp$1, dd, toRead;
		dd = this;
		toRead = $subslice(dd.hist, dd.rdPos, dd.wrPos);
		dd.rdPos = dd.wrPos;
		if (dd.wrPos === dd.hist.$length) {
			_tmp = 0;
			_tmp$1 = 0;
			dd.wrPos = _tmp;
			dd.rdPos = _tmp$1;
			dd.full = true;
		}
		return toRead;
	};
	dictDecoder.prototype.readFlush = function() { return this.$val.readFlush(); };
	newHuffmanBitWriter = function(w) {
		var w;
		return new huffmanBitWriter.ptr(w, new $Uint64(0, 0), 0, arrayType$5.zero(), arrayType$6.zero(), 0, $makeSlice(sliceType$7, 286), $makeSlice(sliceType$7, 30), $makeSlice(sliceType$4, 317), newHuffmanEncoder(286), newHuffmanEncoder(30), newHuffmanEncoder(19), $ifaceNil);
	};
	init = function() {
		var w, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; w = $f.w; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		w = newHuffmanBitWriter($ifaceNil);
		(x = w.offsetFreq, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0] = 1));
		huffOffset = newHuffmanEncoder(30);
		$r = huffOffset.generate(w.offsetFreq, 15); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f.w = w; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	hcode.ptr.prototype.set = function(code, length) {
		var code, h, length;
		h = this;
		h.len = length;
		h.code = code;
	};
	hcode.prototype.set = function(code, length) { return this.$val.set(code, length); };
	maxNode = function() {
		return new literalNode.ptr(65535, 2147483647);
	};
	newHuffmanEncoder = function(size) {
		var size;
		return new huffmanEncoder.ptr($makeSlice(sliceType$8, size), sliceType$9.nil, arrayType$7.zero(), byLiteral.nil, byFreq.nil);
	};
	generateFixedLiteralEncoding = function() {
		var bits$1, ch, codes, h, size;
		h = newHuffmanEncoder(286);
		codes = h.codes;
		ch = 0;
		ch = 0;
		while (true) {
			if (!(ch < 286)) { break; }
			bits$1 = 0;
			size = 0;
			switch (0) { default:
				if (ch < 144) {
					bits$1 = ch + 48 << 16 >>> 16;
					size = 8;
					break;
				} else if (ch < 256) {
					bits$1 = (ch + 400 << 16 >>> 16) - 144 << 16 >>> 16;
					size = 9;
					break;
				} else if (ch < 280) {
					bits$1 = ch - 256 << 16 >>> 16;
					size = 7;
					break;
				} else {
					bits$1 = (ch + 192 << 16 >>> 16) - 280 << 16 >>> 16;
					size = 8;
				}
			}
			hcode.copy(((ch < 0 || ch >= codes.$length) ? ($throwRuntimeError("index out of range"), undefined) : codes.$array[codes.$offset + ch]), new hcode.ptr(reverseBits(bits$1, ((size << 24 >>> 24))), size));
			ch = ch + (1) << 16 >>> 16;
		}
		return h;
	};
	generateFixedOffsetEncoding = function() {
		var _i, _ref, ch, codes, h;
		h = newHuffmanEncoder(30);
		codes = h.codes;
		_ref = codes;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			ch = _i;
			hcode.copy(((ch < 0 || ch >= codes.$length) ? ($throwRuntimeError("index out of range"), undefined) : codes.$array[codes.$offset + ch]), new hcode.ptr(reverseBits(((ch << 16 >>> 16)), 5), 5));
			_i++;
		}
		return h;
	};
	huffmanEncoder.ptr.prototype.bitCounts = function(list, maxBits) {
		var bitCount, bits$1, counts, h, l, leafCounts, level, level$1, level$2, levels$1, list, maxBits, n, n$1, prevFreq, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		h = this;
		if (maxBits >= 16) {
			$panic(new $String("flate: maxBits too large"));
		}
		n = ((list.$length >> 0));
		list = $subslice(list, 0, (n + 1 >> 0));
		literalNode.copy(((n < 0 || n >= list.$length) ? ($throwRuntimeError("index out of range"), undefined) : list.$array[list.$offset + n]), maxNode());
		if (maxBits > (n - 1 >> 0)) {
			maxBits = n - 1 >> 0;
		}
		levels$1 = arrayType$8.zero();
		leafCounts = arrayType$10.zero();
		level = 1;
		while (true) {
			if (!(level <= maxBits)) { break; }
			levelInfo.copy(((level < 0 || level >= levels$1.length) ? ($throwRuntimeError("index out of range"), undefined) : levels$1[level]), new levelInfo.ptr(level, (1 >= list.$length ? ($throwRuntimeError("index out of range"), undefined) : list.$array[list.$offset + 1]).freq, (2 >= list.$length ? ($throwRuntimeError("index out of range"), undefined) : list.$array[list.$offset + 2]).freq, (0 >= list.$length ? ($throwRuntimeError("index out of range"), undefined) : list.$array[list.$offset + 0]).freq + (1 >= list.$length ? ($throwRuntimeError("index out of range"), undefined) : list.$array[list.$offset + 1]).freq >> 0, 0));
			(x = ((level < 0 || level >= leafCounts.length) ? ($throwRuntimeError("index out of range"), undefined) : leafCounts[level]), ((level < 0 || level >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[level] = 2));
			if (level === 1) {
				((level < 0 || level >= levels$1.length) ? ($throwRuntimeError("index out of range"), undefined) : levels$1[level]).nextPairFreq = 2147483647;
			}
			level = level + (1) >> 0;
		}
		((maxBits < 0 || maxBits >= levels$1.length) ? ($throwRuntimeError("index out of range"), undefined) : levels$1[maxBits]).needed = ($imul(2, n)) - 4 >> 0;
		level$1 = maxBits;
		while (true) {
			l = ((level$1 < 0 || level$1 >= levels$1.length) ? ($throwRuntimeError("index out of range"), undefined) : levels$1[level$1]);
			if ((l.nextPairFreq === 2147483647) && (l.nextCharFreq === 2147483647)) {
				l.needed = 0;
				(x$1 = level$1 + 1 >> 0, ((x$1 < 0 || x$1 >= levels$1.length) ? ($throwRuntimeError("index out of range"), undefined) : levels$1[x$1])).nextPairFreq = 2147483647;
				level$1 = level$1 + (1) >> 0;
				continue;
			}
			prevFreq = l.lastFreq;
			if (l.nextCharFreq < l.nextPairFreq) {
				n$1 = (x$2 = ((level$1 < 0 || level$1 >= leafCounts.length) ? ($throwRuntimeError("index out of range"), undefined) : leafCounts[level$1]), ((level$1 < 0 || level$1 >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[level$1])) + 1 >> 0;
				l.lastFreq = l.nextCharFreq;
				(x$3 = ((level$1 < 0 || level$1 >= leafCounts.length) ? ($throwRuntimeError("index out of range"), undefined) : leafCounts[level$1]), ((level$1 < 0 || level$1 >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[level$1] = n$1));
				l.nextCharFreq = ((n$1 < 0 || n$1 >= list.$length) ? ($throwRuntimeError("index out of range"), undefined) : list.$array[list.$offset + n$1]).freq;
			} else {
				l.lastFreq = l.nextPairFreq;
				$copySlice($subslice(new sliceType$7(((level$1 < 0 || level$1 >= leafCounts.length) ? ($throwRuntimeError("index out of range"), undefined) : leafCounts[level$1])), 0, level$1), $subslice(new sliceType$7((x$4 = level$1 - 1 >> 0, ((x$4 < 0 || x$4 >= leafCounts.length) ? ($throwRuntimeError("index out of range"), undefined) : leafCounts[x$4]))), 0, level$1));
				(x$5 = l.level - 1 >> 0, ((x$5 < 0 || x$5 >= levels$1.length) ? ($throwRuntimeError("index out of range"), undefined) : levels$1[x$5])).needed = 2;
			}
			l.needed = l.needed - (1) >> 0;
			if (l.needed === 0) {
				if (l.level === maxBits) {
					break;
				}
				(x$6 = l.level + 1 >> 0, ((x$6 < 0 || x$6 >= levels$1.length) ? ($throwRuntimeError("index out of range"), undefined) : levels$1[x$6])).nextPairFreq = prevFreq + l.lastFreq >> 0;
				level$1 = level$1 + (1) >> 0;
			} else {
				while (true) {
					if (!((x$7 = level$1 - 1 >> 0, ((x$7 < 0 || x$7 >= levels$1.length) ? ($throwRuntimeError("index out of range"), undefined) : levels$1[x$7])).needed > 0)) { break; }
					level$1 = level$1 - (1) >> 0;
				}
			}
		}
		if (!(((x$8 = ((maxBits < 0 || maxBits >= leafCounts.length) ? ($throwRuntimeError("index out of range"), undefined) : leafCounts[maxBits]), ((maxBits < 0 || maxBits >= x$8.length) ? ($throwRuntimeError("index out of range"), undefined) : x$8[maxBits])) === n))) {
			$panic(new $String("leafCounts[maxBits][maxBits] != n"));
		}
		bitCount = $subslice(new sliceType$7(h.bitCount), 0, (maxBits + 1 >> 0));
		bits$1 = 1;
		counts = ((maxBits < 0 || maxBits >= leafCounts.length) ? ($throwRuntimeError("index out of range"), undefined) : leafCounts[maxBits]);
		level$2 = maxBits;
		while (true) {
			if (!(level$2 > 0)) { break; }
			((bits$1 < 0 || bits$1 >= bitCount.$length) ? ($throwRuntimeError("index out of range"), undefined) : bitCount.$array[bitCount.$offset + bits$1] = ((counts.nilCheck, ((level$2 < 0 || level$2 >= counts.length) ? ($throwRuntimeError("index out of range"), undefined) : counts[level$2])) - (x$9 = level$2 - 1 >> 0, (counts.nilCheck, ((x$9 < 0 || x$9 >= counts.length) ? ($throwRuntimeError("index out of range"), undefined) : counts[x$9]))) >> 0));
			bits$1 = bits$1 + (1) >> 0;
			level$2 = level$2 - (1) >> 0;
		}
		return bitCount;
	};
	huffmanEncoder.prototype.bitCounts = function(list, maxBits) { return this.$val.bitCounts(list, maxBits); };
	huffmanEncoder.ptr.prototype.assignEncodingAndSize = function(bitCount, list) {
		var _i, _i$1, _ref, _ref$1, bitCount, bits$1, chunk, code, h, list, n, node, x, x$1, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _ref = $f._ref; _ref$1 = $f._ref$1; bitCount = $f.bitCount; bits$1 = $f.bits$1; chunk = $f.chunk; code = $f.code; h = $f.h; list = $f.list; n = $f.n; node = $f.node; x = $f.x; x$1 = $f.x$1; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		h = this;
		code = 0;
		_ref = bitCount;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			n = _i;
			bits$1 = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			code = (y = (1), y < 32 ? (code << y) : 0) << 16 >>> 16;
			/* */ if ((n === 0) || (bits$1 === 0)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if ((n === 0) || (bits$1 === 0)) { */ case 3:
				_i++;
				/* continue; */ $s = 1; continue;
			/* } */ case 4:
			chunk = $subslice(list, (list.$length - ((bits$1 >> 0)) >> 0));
			$r = (h.$ptr_lns || (h.$ptr_lns = new ptrType$7(function() { return this.$target.lns; }, function($v) { this.$target.lns = $v; }, h))).sort(chunk); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_ref$1 = chunk;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.$length)) { break; }
				node = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), literalNode);
				hcode.copy((x = h.codes, x$1 = node.literal, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])), new hcode.ptr(reverseBits(code, ((n << 24 >>> 24))), ((n << 16 >>> 16))));
				code = code + (1) << 16 >>> 16;
				_i$1++;
			}
			list = $subslice(list, 0, (list.$length - ((bits$1 >> 0)) >> 0));
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: huffmanEncoder.ptr.prototype.assignEncodingAndSize }; } $f._i = _i; $f._i$1 = _i$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f.bitCount = bitCount; $f.bits$1 = bits$1; $f.chunk = chunk; $f.code = code; $f.h = h; $f.list = list; $f.n = n; $f.node = node; $f.x = x; $f.x$1 = x$1; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	huffmanEncoder.prototype.assignEncodingAndSize = function(bitCount, list) { return this.$val.assignEncodingAndSize(bitCount, list); };
	huffmanEncoder.ptr.prototype.generate = function(freq, maxBits) {
		var _i, _i$1, _ref, _ref$1, bitCount, count, f, freq, h, i, i$1, list, maxBits, node, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _ref = $f._ref; _ref$1 = $f._ref$1; bitCount = $f.bitCount; count = $f.count; f = $f.f; freq = $f.freq; h = $f.h; i = $f.i; i$1 = $f.i$1; list = $f.list; maxBits = $f.maxBits; node = $f.node; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		h = this;
		if (h.freqcache === sliceType$9.nil) {
			h.freqcache = $makeSlice(sliceType$9, 287);
		}
		list = $subslice(h.freqcache, 0, (freq.$length + 1 >> 0));
		count = 0;
		_ref = freq;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			f = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((f === 0))) {
				literalNode.copy(((count < 0 || count >= list.$length) ? ($throwRuntimeError("index out of range"), undefined) : list.$array[list.$offset + count]), new literalNode.ptr(((i << 16 >>> 16)), f));
				count = count + (1) >> 0;
			} else {
				literalNode.copy(((count < 0 || count >= list.$length) ? ($throwRuntimeError("index out of range"), undefined) : list.$array[list.$offset + count]), new literalNode.ptr(0, 0));
				(x = h.codes, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).len = 0;
			}
			_i++;
		}
		literalNode.copy((x$1 = freq.$length, ((x$1 < 0 || x$1 >= list.$length) ? ($throwRuntimeError("index out of range"), undefined) : list.$array[list.$offset + x$1])), new literalNode.ptr(0, 0));
		list = $subslice(list, 0, count);
		if (count <= 2) {
			_ref$1 = list;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.$length)) { break; }
				i$1 = _i$1;
				node = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), literalNode);
				(x$2 = h.codes, x$3 = node.literal, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])).set(((i$1 << 16 >>> 16)), 1);
				_i$1++;
			}
			$s = -1; return;
		}
		$r = (h.$ptr_lfs || (h.$ptr_lfs = new ptrType$8(function() { return this.$target.lfs; }, function($v) { this.$target.lfs = $v; }, h))).sort(list); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		bitCount = h.bitCounts(list, maxBits);
		$r = h.assignEncodingAndSize(bitCount, list); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: huffmanEncoder.ptr.prototype.generate }; } $f._i = _i; $f._i$1 = _i$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f.bitCount = bitCount; $f.count = count; $f.f = f; $f.freq = freq; $f.h = h; $f.i = i; $f.i$1 = i$1; $f.list = list; $f.maxBits = maxBits; $f.node = node; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	huffmanEncoder.prototype.generate = function(freq, maxBits) { return this.$val.generate(freq, maxBits); };
	$ptrType(byLiteral).prototype.sort = function(a) {
		var a, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; a = $f.a; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		s.$set(($subslice(new byLiteral(a.$array), a.$offset, a.$offset + a.$length)));
		$r = sort.Sort(s); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: $ptrType(byLiteral).prototype.sort }; } $f.a = a; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	byLiteral.prototype.Len = function() {
		var s;
		s = this;
		return s.$length;
	};
	$ptrType(byLiteral).prototype.Len = function() { return this.$get().Len(); };
	byLiteral.prototype.Less = function(i, j) {
		var i, j, s;
		s = this;
		return ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]).literal < ((j < 0 || j >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + j]).literal;
	};
	$ptrType(byLiteral).prototype.Less = function(i, j) { return this.$get().Less(i, j); };
	byLiteral.prototype.Swap = function(i, j) {
		var _tmp, _tmp$1, i, j, s;
		s = this;
		_tmp = $clone(((j < 0 || j >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + j]), literalNode);
		_tmp$1 = $clone(((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]), literalNode);
		literalNode.copy(((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]), _tmp);
		literalNode.copy(((j < 0 || j >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + j]), _tmp$1);
	};
	$ptrType(byLiteral).prototype.Swap = function(i, j) { return this.$get().Swap(i, j); };
	$ptrType(byFreq).prototype.sort = function(a) {
		var a, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; a = $f.a; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		s.$set(($subslice(new byFreq(a.$array), a.$offset, a.$offset + a.$length)));
		$r = sort.Sort(s); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: $ptrType(byFreq).prototype.sort }; } $f.a = a; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	byFreq.prototype.Len = function() {
		var s;
		s = this;
		return s.$length;
	};
	$ptrType(byFreq).prototype.Len = function() { return this.$get().Len(); };
	byFreq.prototype.Less = function(i, j) {
		var i, j, s;
		s = this;
		if (((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]).freq === ((j < 0 || j >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + j]).freq) {
			return ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]).literal < ((j < 0 || j >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + j]).literal;
		}
		return ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]).freq < ((j < 0 || j >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + j]).freq;
	};
	$ptrType(byFreq).prototype.Less = function(i, j) { return this.$get().Less(i, j); };
	byFreq.prototype.Swap = function(i, j) {
		var _tmp, _tmp$1, i, j, s;
		s = this;
		_tmp = $clone(((j < 0 || j >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + j]), literalNode);
		_tmp$1 = $clone(((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]), literalNode);
		literalNode.copy(((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]), _tmp);
		literalNode.copy(((j < 0 || j >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + j]), _tmp$1);
	};
	$ptrType(byFreq).prototype.Swap = function(i, j) { return this.$get().Swap(i, j); };
	reverseBits = function(number, bitLength) {
		var bitLength, number, y;
		return bits.Reverse16((y = ((16 - bitLength << 24 >>> 24)), y < 32 ? (number << y) : 0) << 16 >>> 16);
	};
	CorruptInputError.prototype.Error = function() {
		var e;
		e = this;
		return "flate: corrupt input before offset " + strconv.FormatInt((new $Int64(e.$high, e.$low)), 10);
	};
	$ptrType(CorruptInputError).prototype.Error = function() { return this.$get().Error(); };
	InternalError.prototype.Error = function() {
		var e;
		e = this.$val;
		return "flate: internal error: " + (e);
	};
	$ptrType(InternalError).prototype.Error = function() { return new InternalError(this.$get()).Error(); };
	huffmanDecoder.ptr.prototype.init = function(lengths) {
		var _i, _i$1, _i$2, _i$3, _i$4, _r, _ref, _ref$1, _ref$2, _ref$3, _ref$4, _tmp, _tmp$1, chunk, chunk$1, chunk$2, code, code$1, count, h, i, i$1, i$2, j, j$1, lengths, link, linktab, linktab$1, max, min, n, n$1, nextcode, numLinks, off, off$1, off$2, reverse, reverse$1, value, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, y, y$1, y$2, y$3, y$4;
		h = this;
		if (!((h.min === 0))) {
			huffmanDecoder.copy(h, new huffmanDecoder.ptr(0, arrayType.zero(), sliceType$1.nil, 0));
		}
		count = arrayType$11.zero();
		_tmp = 0;
		_tmp$1 = 0;
		min = _tmp;
		max = _tmp$1;
		_ref = lengths;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			n = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (n === 0) {
				_i++;
				continue;
			}
			if ((min === 0) || n < min) {
				min = n;
			}
			if (n > max) {
				max = n;
			}
			((n < 0 || n >= count.length) ? ($throwRuntimeError("index out of range"), undefined) : count[n] = (((n < 0 || n >= count.length) ? ($throwRuntimeError("index out of range"), undefined) : count[n]) + (1) >> 0));
			_i++;
		}
		if (max === 0) {
			return true;
		}
		code = 0;
		nextcode = arrayType$11.zero();
		i = min;
		while (true) {
			if (!(i <= max)) { break; }
			code = (y = (1), y < 32 ? (code << y) : 0) >> 0;
			((i < 0 || i >= nextcode.length) ? ($throwRuntimeError("index out of range"), undefined) : nextcode[i] = code);
			code = code + (((i < 0 || i >= count.length) ? ($throwRuntimeError("index out of range"), undefined) : count[i])) >> 0;
			i = i + (1) >> 0;
		}
		if (!((code === ((y$1 = ((max >>> 0)), y$1 < 32 ? (1 << y$1) : 0) >> 0))) && !((code === 1) && (max === 1))) {
			return false;
		}
		h.min = min;
		if (max > 9) {
			numLinks = (y$2 = ((((max >>> 0)) - 9 >>> 0)), y$2 < 32 ? (1 << y$2) : 0) >> 0;
			h.linkMask = (((numLinks - 1 >> 0) >>> 0));
			link = nextcode[10] >> 1 >> 0;
			h.links = $makeSlice(sliceType$1, (512 - link >> 0));
			j = ((link >>> 0));
			while (true) {
				if (!(j < 512)) { break; }
				reverse = ((bits.Reverse16(((j << 16 >>> 16))) >> 0));
				reverse = (reverse >> $min((7), 31)) >> 0;
				off = j - ((link >>> 0)) >>> 0;
				if (false && !(((x = h.chunks, ((reverse < 0 || reverse >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[reverse])) === 0))) {
					$panic(new $String("impossible: overwriting existing chunk"));
				}
				(x$1 = h.chunks, ((reverse < 0 || reverse >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[reverse] = (((((off << 4 >>> 0) | 10) >>> 0) >>> 0))));
				(x$2 = h.links, ((off < 0 || off >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + off] = $makeSlice(sliceType, numLinks)));
				j = j + (1) >>> 0;
			}
		}
		_ref$1 = lengths;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			n$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			if (n$1 === 0) {
				_i$1++;
				continue;
			}
			code$1 = ((n$1 < 0 || n$1 >= nextcode.length) ? ($throwRuntimeError("index out of range"), undefined) : nextcode[n$1]);
			((n$1 < 0 || n$1 >= nextcode.length) ? ($throwRuntimeError("index out of range"), undefined) : nextcode[n$1] = (((n$1 < 0 || n$1 >= nextcode.length) ? ($throwRuntimeError("index out of range"), undefined) : nextcode[n$1]) + (1) >> 0));
			chunk = ((((i$1 << 4 >> 0) | n$1) >>> 0));
			reverse$1 = ((bits.Reverse16(((code$1 << 16 >>> 16))) >> 0));
			reverse$1 = (reverse$1 >> $min(((((16 - n$1 >> 0) >>> 0))), 31)) >> 0;
			if (n$1 <= 9) {
				off$1 = reverse$1;
				while (true) {
					if (!(off$1 < 512)) { break; }
					if (false && !(((x$3 = h.chunks, ((off$1 < 0 || off$1 >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[off$1])) === 0))) {
						$panic(new $String("impossible: overwriting existing chunk"));
					}
					(x$4 = h.chunks, ((off$1 < 0 || off$1 >= x$4.length) ? ($throwRuntimeError("index out of range"), undefined) : x$4[off$1] = chunk));
					off$1 = off$1 + (((y$3 = ((n$1 >>> 0)), y$3 < 32 ? (1 << y$3) : 0) >> 0)) >> 0;
				}
			} else {
				j$1 = reverse$1 & 511;
				if (false && !(((((x$5 = h.chunks, ((j$1 < 0 || j$1 >= x$5.length) ? ($throwRuntimeError("index out of range"), undefined) : x$5[j$1])) & 15) >>> 0) === 10))) {
					$panic(new $String("impossible: not an indirect chunk"));
				}
				value = (x$6 = h.chunks, ((j$1 < 0 || j$1 >= x$6.length) ? ($throwRuntimeError("index out of range"), undefined) : x$6[j$1])) >>> 4 >>> 0;
				linktab = (x$7 = h.links, ((value < 0 || value >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + value]));
				reverse$1 = (reverse$1 >> $min((9), 31)) >> 0;
				off$2 = reverse$1;
				while (true) {
					if (!(off$2 < linktab.$length)) { break; }
					if (false && !((((off$2 < 0 || off$2 >= linktab.$length) ? ($throwRuntimeError("index out of range"), undefined) : linktab.$array[linktab.$offset + off$2]) === 0))) {
						$panic(new $String("impossible: overwriting existing chunk"));
					}
					((off$2 < 0 || off$2 >= linktab.$length) ? ($throwRuntimeError("index out of range"), undefined) : linktab.$array[linktab.$offset + off$2] = chunk);
					off$2 = off$2 + (((y$4 = (((n$1 - 9 >> 0) >>> 0)), y$4 < 32 ? (1 << y$4) : 0) >> 0)) >> 0;
				}
			}
			_i$1++;
		}
		if (false) {
			_ref$2 = h.chunks;
			_i$2 = 0;
			while (true) {
				if (!(_i$2 < 512)) { break; }
				i$2 = _i$2;
				chunk$1 = ((_i$2 < 0 || _i$2 >= _ref$2.length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2[_i$2]);
				if (chunk$1 === 0) {
					if ((code === 1) && ((_r = i$2 % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 1)) {
						_i$2++;
						continue;
					}
					$panic(new $String("impossible: missing chunk"));
				}
				_i$2++;
			}
			_ref$3 = h.links;
			_i$3 = 0;
			while (true) {
				if (!(_i$3 < _ref$3.$length)) { break; }
				linktab$1 = ((_i$3 < 0 || _i$3 >= _ref$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$3.$array[_ref$3.$offset + _i$3]);
				_ref$4 = linktab$1;
				_i$4 = 0;
				while (true) {
					if (!(_i$4 < _ref$4.$length)) { break; }
					chunk$2 = ((_i$4 < 0 || _i$4 >= _ref$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$4.$array[_ref$4.$offset + _i$4]);
					if (chunk$2 === 0) {
						$panic(new $String("impossible: missing chunk"));
					}
					_i$4++;
				}
				_i$3++;
			}
		}
		return true;
	};
	huffmanDecoder.prototype.init = function(lengths) { return this.$val.init(lengths); };
	decompressor.ptr.prototype.nextBlock = function() {
		var _1, _r, _r$1, f, typ, x, y, y$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; f = $f.f; typ = $f.typ; x = $f.x; y = $f.y; y$1 = $f.y$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		/* while (true) { */ case 1:
			/* if (!(f.nb < 3)) { break; } */ if(!(f.nb < 3)) { $s = 2; continue; }
			_r = f.moreBits(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			f.err = _r;
			if (!($interfaceIsEqual(f.err, $ifaceNil))) {
				$s = -1; return;
			}
		/* } */ $s = 1; continue; case 2:
		f.final$12 = ((f.b & 1) >>> 0) === 1;
		f.b = (y = (1), y < 32 ? (f.b >>> y) : 0) >>> 0;
		typ = (f.b & 3) >>> 0;
		f.b = (y$1 = (2), y$1 < 32 ? (f.b >>> y$1) : 0) >>> 0;
		f.nb = f.nb - (3) >>> 0;
			_1 = typ;
			/* */ if (_1 === (0)) { $s = 5; continue; }
			/* */ if (_1 === (1)) { $s = 6; continue; }
			/* */ if (_1 === (2)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (0)) { */ case 5:
				$r = f.dataBlock(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 9; continue;
			/* } else if (_1 === (1)) { */ case 6:
				f.hl = fixedHuffmanDecoder;
				f.hd = ptrType$9.nil;
				$r = f.huffmanBlock(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 9; continue;
			/* } else if (_1 === (2)) { */ case 7:
				_r$1 = f.readHuffman(); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				f.err = _r$1;
				if (!($interfaceIsEqual(f.err, $ifaceNil))) {
					/* break; */ $s = 4; continue;
				}
				f.hl = f.h1;
				f.hd = f.h2;
				$r = f.huffmanBlock(); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 9; continue;
			/* } else { */ case 8:
				f.err = ((x = f.roffset, new CorruptInputError(x.$high, x.$low)));
			/* } */ case 9:
		case 4:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: decompressor.ptr.prototype.nextBlock }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.typ = typ; $f.x = x; $f.y = y; $f.y$1 = y$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	decompressor.prototype.nextBlock = function() { return this.$val.nextBlock(); };
	decompressor.ptr.prototype.Read = function(b) {
		var b, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		/* while (true) { */ case 1:
			if (f.toRead.$length > 0) {
				n = $copySlice(b, f.toRead);
				f.toRead = $subslice(f.toRead, n);
				if (f.toRead.$length === 0) {
					$s = -1; return [n, f.err];
				}
				$s = -1; return [n, $ifaceNil];
			}
			if (!($interfaceIsEqual(f.err, $ifaceNil))) {
				$s = -1; return [0, f.err];
			}
			$r = f.step(f); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			if (!($interfaceIsEqual(f.err, $ifaceNil)) && (f.toRead.$length === 0)) {
				f.toRead = f.dict.readFlush();
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: decompressor.ptr.prototype.Read }; } $f.b = b; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	decompressor.prototype.Read = function(b) { return this.$val.Read(b); };
	decompressor.ptr.prototype.Close = function() {
		var f;
		f = this;
		if ($interfaceIsEqual(f.err, io.EOF)) {
			return $ifaceNil;
		}
		return f.err;
	};
	decompressor.prototype.Close = function() { return this.$val.Close(); };
	decompressor.ptr.prototype.readHuffman = function() {
		var _1, _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, _tuple, b, err, err$1, err$2, err$3, f, i, i$1, i$2, j, n, nb, nclen, ndist, nlit, rep, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y, y$1, y$2, y$3, y$4, y$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; f = $f.f; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; j = $f.j; n = $f.n; nb = $f.nb; nclen = $f.nclen; ndist = $f.ndist; nlit = $f.nlit; rep = $f.rep; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$16 = $f.x$16; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; y = $f.y; y$1 = $f.y$1; y$2 = $f.y$2; y$3 = $f.y$3; y$4 = $f.y$4; y$5 = $f.y$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		/* while (true) { */ case 1:
			/* if (!(f.nb < 14)) { break; } */ if(!(f.nb < 14)) { $s = 2; continue; }
			_r = f.moreBits(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			err = _r;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
		/* } */ $s = 1; continue; case 2:
		nlit = ((((f.b & 31) >>> 0) >> 0)) + 257 >> 0;
		if (nlit > 286) {
			$s = -1; return ((x = f.roffset, new CorruptInputError(x.$high, x.$low)));
		}
		f.b = (y = (5), y < 32 ? (f.b >>> y) : 0) >>> 0;
		ndist = ((((f.b & 31) >>> 0) >> 0)) + 1 >> 0;
		if (ndist > 30) {
			$s = -1; return ((x$1 = f.roffset, new CorruptInputError(x$1.$high, x$1.$low)));
		}
		f.b = (y$1 = (5), y$1 < 32 ? (f.b >>> y$1) : 0) >>> 0;
		nclen = ((((f.b & 15) >>> 0) >> 0)) + 4 >> 0;
		f.b = (y$2 = (4), y$2 < 32 ? (f.b >>> y$2) : 0) >>> 0;
		f.nb = f.nb - (14) >>> 0;
		i = 0;
		/* while (true) { */ case 4:
			/* if (!(i < nclen)) { break; } */ if(!(i < nclen)) { $s = 5; continue; }
			/* while (true) { */ case 6:
				/* if (!(f.nb < 3)) { break; } */ if(!(f.nb < 3)) { $s = 7; continue; }
				_r$1 = f.moreBits(); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				err$1 = _r$1;
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					$s = -1; return err$1;
				}
			/* } */ $s = 6; continue; case 7:
			(x$2 = f.codebits, x$3 = ((i < 0 || i >= codeOrder.length) ? ($throwRuntimeError("index out of range"), undefined) : codeOrder[i]), x$2.nilCheck, ((x$3 < 0 || x$3 >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[x$3] = ((((f.b & 7) >>> 0) >> 0))));
			f.b = (y$3 = (3), y$3 < 32 ? (f.b >>> y$3) : 0) >>> 0;
			f.nb = f.nb - (3) >>> 0;
			i = i + (1) >> 0;
		/* } */ $s = 4; continue; case 5:
		i$1 = nclen;
		while (true) {
			if (!(i$1 < 19)) { break; }
			(x$4 = f.codebits, x$5 = ((i$1 < 0 || i$1 >= codeOrder.length) ? ($throwRuntimeError("index out of range"), undefined) : codeOrder[i$1]), x$4.nilCheck, ((x$5 < 0 || x$5 >= x$4.length) ? ($throwRuntimeError("index out of range"), undefined) : x$4[x$5] = 0));
			i$1 = i$1 + (1) >> 0;
		}
		if (!f.h1.init($subslice(new sliceType$10(f.codebits), 0))) {
			$s = -1; return ((x$6 = f.roffset, new CorruptInputError(x$6.$high, x$6.$low)));
		}
		_tmp = 0;
		_tmp$1 = nlit + ndist >> 0;
		i$2 = _tmp;
		n = _tmp$1;
		/* while (true) { */ case 9:
			/* if (!(i$2 < n)) { break; } */ if(!(i$2 < n)) { $s = 10; continue; }
			_r$2 = f.huffSym(f.h1); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple = _r$2;
			x$7 = _tuple[0];
			err$2 = _tuple[1];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return err$2;
			}
			/* */ if (x$7 < 16) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (x$7 < 16) { */ case 12:
				(x$8 = f.bits, x$8.nilCheck, ((i$2 < 0 || i$2 >= x$8.length) ? ($throwRuntimeError("index out of range"), undefined) : x$8[i$2] = x$7));
				i$2 = i$2 + (1) >> 0;
				/* continue; */ $s = 9; continue;
			/* } */ case 13:
			rep = 0;
			nb = 0;
			b = 0;
			_1 = x$7;
			if (_1 === (16)) {
				rep = 3;
				nb = 2;
				if (i$2 === 0) {
					$s = -1; return ((x$9 = f.roffset, new CorruptInputError(x$9.$high, x$9.$low)));
				}
				b = (x$10 = f.bits, x$11 = i$2 - 1 >> 0, (x$10.nilCheck, ((x$11 < 0 || x$11 >= x$10.length) ? ($throwRuntimeError("index out of range"), undefined) : x$10[x$11])));
			} else if (_1 === (17)) {
				rep = 3;
				nb = 3;
				b = 0;
			} else if (_1 === (18)) {
				rep = 11;
				nb = 7;
				b = 0;
			} else {
				$s = -1; return new InternalError("unexpected length code");
			}
			/* while (true) { */ case 14:
				/* if (!(f.nb < nb)) { break; } */ if(!(f.nb < nb)) { $s = 15; continue; }
				_r$3 = f.moreBits(); /* */ $s = 16; case 16: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				err$3 = _r$3;
				if (!($interfaceIsEqual(err$3, $ifaceNil))) {
					$s = -1; return err$3;
				}
			/* } */ $s = 14; continue; case 15:
			rep = rep + (((((f.b & ((((y$4 = nb, y$4 < 32 ? (1 << y$4) : 0) >>> 0) - 1 >>> 0))) >>> 0) >> 0))) >> 0;
			f.b = (y$5 = (nb), y$5 < 32 ? (f.b >>> y$5) : 0) >>> 0;
			f.nb = f.nb - (nb) >>> 0;
			if ((i$2 + rep >> 0) > n) {
				$s = -1; return ((x$12 = f.roffset, new CorruptInputError(x$12.$high, x$12.$low)));
			}
			j = 0;
			while (true) {
				if (!(j < rep)) { break; }
				(x$13 = f.bits, x$13.nilCheck, ((i$2 < 0 || i$2 >= x$13.length) ? ($throwRuntimeError("index out of range"), undefined) : x$13[i$2] = b));
				i$2 = i$2 + (1) >> 0;
				j = j + (1) >> 0;
			}
		/* } */ $s = 9; continue; case 10:
		if (!f.h1.init($subslice(new sliceType$10(f.bits), 0, nlit)) || !f.h2.init($subslice(new sliceType$10(f.bits), nlit, (nlit + ndist >> 0)))) {
			$s = -1; return ((x$14 = f.roffset, new CorruptInputError(x$14.$high, x$14.$low)));
		}
		if (f.h1.min < (x$15 = f.bits, (x$15.nilCheck, x$15[256]))) {
			f.h1.min = (x$16 = f.bits, (x$16.nilCheck, x$16[256]));
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: decompressor.ptr.prototype.readHuffman }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.f = f; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.j = j; $f.n = n; $f.nb = nb; $f.nclen = nclen; $f.ndist = ndist; $f.nlit = nlit; $f.rep = rep; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$16 = x$16; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.y = y; $f.y$1 = y$1; $f.y$2 = y$2; $f.y$3 = y$3; $f.y$4 = y$4; $f.y$5 = y$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	decompressor.prototype.readHuffman = function() { return this.$val.readHuffman(); };
	decompressor.ptr.prototype.huffmanBlock = function() {
		var _1, _r, _r$1, _r$2, _r$3, _r$4, _tmp, _tmp$1, _tuple, _tuple$1, cnt, dist, err, extra, f, length, n, nb, v, x, x$1, x$2, y, y$1, y$2, y$3, y$4, y$5, y$6, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; cnt = $f.cnt; dist = $f.dist; err = $f.err; extra = $f.extra; f = $f.f; length = $f.length; n = $f.n; nb = $f.nb; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; y = $f.y; y$1 = $f.y$1; y$2 = $f.y$2; y$3 = $f.y$3; y$4 = $f.y$4; y$5 = $f.y$5; y$6 = $f.y$6; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
			_1 = f.stepState;
			/* */ if (_1 === (0)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_1 === (0)) { */ case 2:
				/* goto readLiteral */ $s = 5; continue;
				$s = 4; continue;
			/* } else if (_1 === (1)) { */ case 3:
				/* goto copyHistory */ $s = 6; continue;
			/* } */ case 4:
		case 1:
		/* readLiteral: */ case 5:
		_r = f.huffSym(f.hl); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		v = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			f.err = err;
			$s = -1; return;
		}
		n = 0;
		length = 0;
			/* */ if (v < 256) { $s = 9; continue; }
			/* */ if ((v === 256)) { $s = 10; continue; }
			/* */ if (v < 265) { $s = 11; continue; }
			/* */ if (v < 269) { $s = 12; continue; }
			/* */ if (v < 273) { $s = 13; continue; }
			/* */ if (v < 277) { $s = 14; continue; }
			/* */ if (v < 281) { $s = 15; continue; }
			/* */ if (v < 285) { $s = 16; continue; }
			/* */ if (v < 286) { $s = 17; continue; }
			/* */ $s = 18; continue;
			/* if (v < 256) { */ case 9:
				f.dict.writeByte(((v << 24 >>> 24)));
				if (f.dict.availWrite() === 0) {
					f.toRead = f.dict.readFlush();
					f.step = $methodExpr(ptrType$10, "huffmanBlock");
					f.stepState = 0;
					$s = -1; return;
				}
				/* goto readLiteral */ $s = 5; continue;
				$s = 19; continue;
			/* } else if ((v === 256)) { */ case 10:
				f.finishBlock();
				$s = -1; return;
			/* } else if (v < 265) { */ case 11:
				length = v - 254 >> 0;
				n = 0;
				$s = 19; continue;
			/* } else if (v < 269) { */ case 12:
				length = ($imul(v, 2)) - 519 >> 0;
				n = 1;
				$s = 19; continue;
			/* } else if (v < 273) { */ case 13:
				length = ($imul(v, 4)) - 1057 >> 0;
				n = 2;
				$s = 19; continue;
			/* } else if (v < 277) { */ case 14:
				length = ($imul(v, 8)) - 2149 >> 0;
				n = 3;
				$s = 19; continue;
			/* } else if (v < 281) { */ case 15:
				length = ($imul(v, 16)) - 4365 >> 0;
				n = 4;
				$s = 19; continue;
			/* } else if (v < 285) { */ case 16:
				length = ($imul(v, 32)) - 8861 >> 0;
				n = 5;
				$s = 19; continue;
			/* } else if (v < 286) { */ case 17:
				length = 258;
				n = 0;
				$s = 19; continue;
			/* } else { */ case 18:
				f.err = ((x = f.roffset, new CorruptInputError(x.$high, x.$low)));
				$s = -1; return;
			/* } */ case 19:
		case 8:
		/* */ if (n > 0) { $s = 20; continue; }
		/* */ $s = 21; continue;
		/* if (n > 0) { */ case 20:
			/* while (true) { */ case 22:
				/* if (!(f.nb < n)) { break; } */ if(!(f.nb < n)) { $s = 23; continue; }
				_r$1 = f.moreBits(); /* */ $s = 24; case 24: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				err = _r$1;
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					f.err = err;
					$s = -1; return;
				}
			/* } */ $s = 22; continue; case 23:
			length = length + (((((f.b & ((((y = n, y < 32 ? (1 << y) : 0) >>> 0) - 1 >>> 0))) >>> 0) >> 0))) >> 0;
			f.b = (y$1 = (n), y$1 < 32 ? (f.b >>> y$1) : 0) >>> 0;
			f.nb = f.nb - (n) >>> 0;
		/* } */ case 21:
		dist = 0;
		/* */ if (f.hd === ptrType$9.nil) { $s = 25; continue; }
		/* */ $s = 26; continue;
		/* if (f.hd === ptrType$9.nil) { */ case 25:
			/* while (true) { */ case 28:
				/* if (!(f.nb < 5)) { break; } */ if(!(f.nb < 5)) { $s = 29; continue; }
				_r$2 = f.moreBits(); /* */ $s = 30; case 30: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				err = _r$2;
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					f.err = err;
					$s = -1; return;
				}
			/* } */ $s = 28; continue; case 29:
			dist = ((bits.Reverse8((((((f.b & 31) >>> 0) << 3 >>> 0) << 24 >>> 24))) >> 0));
			f.b = (y$2 = (5), y$2 < 32 ? (f.b >>> y$2) : 0) >>> 0;
			f.nb = f.nb - (5) >>> 0;
			$s = 27; continue;
		/* } else { */ case 26:
			_r$3 = f.huffSym(f.hd); /* */ $s = 31; case 31: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			_tuple$1 = _r$3;
			dist = _tuple$1[0];
			err = _tuple$1[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				f.err = err;
				$s = -1; return;
			}
		/* } */ case 27:
			/* */ if (dist < 4) { $s = 33; continue; }
			/* */ if (dist < 30) { $s = 34; continue; }
			/* */ $s = 35; continue;
			/* if (dist < 4) { */ case 33:
				dist = dist + (1) >> 0;
				$s = 36; continue;
			/* } else if (dist < 30) { */ case 34:
				nb = (((dist - 2 >> 0) >>> 0)) >>> 1 >>> 0;
				extra = (y$3 = nb, y$3 < 32 ? (((dist & 1)) << y$3) : 0) >> 0;
				/* while (true) { */ case 37:
					/* if (!(f.nb < nb)) { break; } */ if(!(f.nb < nb)) { $s = 38; continue; }
					_r$4 = f.moreBits(); /* */ $s = 39; case 39: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					err = _r$4;
					if (!($interfaceIsEqual(err, $ifaceNil))) {
						f.err = err;
						$s = -1; return;
					}
				/* } */ $s = 37; continue; case 38:
				extra = extra | (((((f.b & ((((y$4 = nb, y$4 < 32 ? (1 << y$4) : 0) >>> 0) - 1 >>> 0))) >>> 0) >> 0)));
				f.b = (y$5 = (nb), y$5 < 32 ? (f.b >>> y$5) : 0) >>> 0;
				f.nb = f.nb - (nb) >>> 0;
				dist = (((y$6 = ((nb + 1 >>> 0)), y$6 < 32 ? (1 << y$6) : 0) >> 0) + 1 >> 0) + extra >> 0;
				$s = 36; continue;
			/* } else { */ case 35:
				f.err = ((x$1 = f.roffset, new CorruptInputError(x$1.$high, x$1.$low)));
				$s = -1; return;
			/* } */ case 36:
		case 32:
		if (dist > f.dict.histSize()) {
			f.err = ((x$2 = f.roffset, new CorruptInputError(x$2.$high, x$2.$low)));
			$s = -1; return;
		}
		_tmp = length;
		_tmp$1 = dist;
		f.copyLen = _tmp;
		f.copyDist = _tmp$1;
		/* goto copyHistory */ $s = 6; continue;
		/* copyHistory: */ case 6:
		cnt = f.dict.tryWriteCopy(f.copyDist, f.copyLen);
		if (cnt === 0) {
			cnt = f.dict.writeCopy(f.copyDist, f.copyLen);
		}
		f.copyLen = f.copyLen - (cnt) >> 0;
		if ((f.dict.availWrite() === 0) || f.copyLen > 0) {
			f.toRead = f.dict.readFlush();
			f.step = $methodExpr(ptrType$10, "huffmanBlock");
			f.stepState = 1;
			$s = -1; return;
		}
		/* goto readLiteral */ $s = 5; continue;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: decompressor.ptr.prototype.huffmanBlock }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.cnt = cnt; $f.dist = dist; $f.err = err; $f.extra = extra; $f.f = f; $f.length = length; $f.n = n; $f.nb = nb; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.y = y; $f.y$1 = y$1; $f.y$2 = y$2; $f.y$3 = y$3; $f.y$4 = y$4; $f.y$5 = y$5; $f.y$6 = y$6; $f.$s = $s; $f.$r = $r; return $f;
	};
	decompressor.prototype.huffmanBlock = function() { return this.$val.huffmanBlock(); };
	decompressor.ptr.prototype.dataBlock = function() {
		var _r, _tuple, err, f, n, nn, nr, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; f = $f.f; n = $f.n; nn = $f.nn; nr = $f.nr; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		f.nb = 0;
		f.b = 0;
		_r = io.ReadFull(f.r, $subslice(new sliceType$4(f.buf), 0, 4)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		nr = _tuple[0];
		err = _tuple[1];
		f.roffset = (x = f.roffset, x$1 = (new $Int64(0, nr)), new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			f.err = noEOF(err);
			$s = -1; return;
		}
		n = ((f.buf[0] >> 0)) | (((f.buf[1] >> 0)) << 8 >> 0);
		nn = ((f.buf[2] >> 0)) | (((f.buf[3] >> 0)) << 8 >> 0);
		if (!((((nn << 16 >>> 16)) === (((~n >> 0) << 16 >>> 16))))) {
			f.err = ((x$2 = f.roffset, new CorruptInputError(x$2.$high, x$2.$low)));
			$s = -1; return;
		}
		if (n === 0) {
			f.toRead = f.dict.readFlush();
			f.finishBlock();
			$s = -1; return;
		}
		f.copyLen = n;
		$r = f.copyData(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: decompressor.ptr.prototype.dataBlock }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.f = f; $f.n = n; $f.nn = nn; $f.nr = nr; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	decompressor.prototype.dataBlock = function() { return this.$val.dataBlock(); };
	decompressor.ptr.prototype.copyData = function() {
		var _r, _tuple, buf, cnt, err, f, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; buf = $f.buf; cnt = $f.cnt; err = $f.err; f = $f.f; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		buf = f.dict.writeSlice();
		if (buf.$length > f.copyLen) {
			buf = $subslice(buf, 0, f.copyLen);
		}
		_r = io.ReadFull(f.r, buf); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		cnt = _tuple[0];
		err = _tuple[1];
		f.roffset = (x = f.roffset, x$1 = (new $Int64(0, cnt)), new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
		f.copyLen = f.copyLen - (cnt) >> 0;
		f.dict.writeMark(cnt);
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			f.err = noEOF(err);
			$s = -1; return;
		}
		if ((f.dict.availWrite() === 0) || f.copyLen > 0) {
			f.toRead = f.dict.readFlush();
			f.step = $methodExpr(ptrType$10, "copyData");
			$s = -1; return;
		}
		f.finishBlock();
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: decompressor.ptr.prototype.copyData }; } $f._r = _r; $f._tuple = _tuple; $f.buf = buf; $f.cnt = cnt; $f.err = err; $f.f = f; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	decompressor.prototype.copyData = function() { return this.$val.copyData(); };
	decompressor.ptr.prototype.finishBlock = function() {
		var f;
		f = this;
		if (f.final$12) {
			if (f.dict.availRead() > 0) {
				f.toRead = f.dict.readFlush();
			}
			f.err = io.EOF;
		}
		f.step = $methodExpr(ptrType$10, "nextBlock");
	};
	decompressor.prototype.finishBlock = function() { return this.$val.finishBlock(); };
	noEOF = function(e) {
		var e;
		if ($interfaceIsEqual(e, io.EOF)) {
			return io.ErrUnexpectedEOF;
		}
		return e;
	};
	decompressor.ptr.prototype.moreBits = function() {
		var _r, _tuple, c, err, f, x, x$1, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; c = $f.c; err = $f.err; f = $f.f; x = $f.x; x$1 = $f.x$1; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		_r = f.r.ReadByte(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		c = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return noEOF(err);
		}
		f.roffset = (x = f.roffset, x$1 = new $Int64(0, 1), new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
		f.b = (f.b | (((y = f.nb, y < 32 ? (((c >>> 0)) << y) : 0) >>> 0))) >>> 0;
		f.nb = f.nb + (8) >>> 0;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: decompressor.ptr.prototype.moreBits }; } $f._r = _r; $f._tuple = _tuple; $f.c = c; $f.err = err; $f.f = f; $f.x = x; $f.x$1 = x$1; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	decompressor.prototype.moreBits = function() { return this.$val.moreBits(); };
	decompressor.ptr.prototype.huffSym = function(h) {
		var _r, _tmp, _tmp$1, _tuple, b, c, chunk, err, f, h, n, nb, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, y, y$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; c = $f.c; chunk = $f.chunk; err = $f.err; f = $f.f; h = $f.h; n = $f.n; nb = $f.nb; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; y = $f.y; y$1 = $f.y$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		n = ((h.min >>> 0));
		_tmp = f.nb;
		_tmp$1 = f.b;
		nb = _tmp;
		b = _tmp$1;
		/* while (true) { */ case 1:
			/* while (true) { */ case 3:
				/* if (!(nb < n)) { break; } */ if(!(nb < n)) { $s = 4; continue; }
				_r = f.r.ReadByte(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				c = _tuple[0];
				err = _tuple[1];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					f.b = b;
					f.nb = nb;
					$s = -1; return [0, noEOF(err)];
				}
				f.roffset = (x = f.roffset, x$1 = new $Int64(0, 1), new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));
				b = (b | (((y = (((nb & 31) >>> 0)), y < 32 ? (((c >>> 0)) << y) : 0) >>> 0))) >>> 0;
				nb = nb + (8) >>> 0;
			/* } */ $s = 3; continue; case 4:
			chunk = (x$2 = h.chunks, x$3 = (b & 511) >>> 0, ((x$3 < 0 || x$3 >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[x$3]));
			n = ((((chunk & 15) >>> 0) >>> 0));
			if (n > 9) {
				chunk = (x$4 = (x$5 = h.links, x$6 = chunk >>> 4 >>> 0, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6])), x$7 = (((b >>> 9 >>> 0)) & h.linkMask) >>> 0, ((x$7 < 0 || x$7 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$7]));
				n = ((((chunk & 15) >>> 0) >>> 0));
			}
			if (n <= nb) {
				if (n === 0) {
					f.b = b;
					f.nb = nb;
					f.err = ((x$8 = f.roffset, new CorruptInputError(x$8.$high, x$8.$low)));
					$s = -1; return [0, f.err];
				}
				f.b = (y$1 = (((n & 31) >>> 0)), y$1 < 32 ? (b >>> y$1) : 0) >>> 0;
				f.nb = nb - n >>> 0;
				$s = -1; return [(((chunk >>> 4 >>> 0) >> 0)), $ifaceNil];
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [0, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: decompressor.ptr.prototype.huffSym }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.c = c; $f.chunk = chunk; $f.err = err; $f.f = f; $f.h = h; $f.n = n; $f.nb = nb; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.y = y; $f.y$1 = y$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	decompressor.prototype.huffSym = function(h) { return this.$val.huffSym(h); };
	makeReader = function(r) {
		var _tuple, ok, r, rr;
		_tuple = $assertType(r, Reader, true);
		rr = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			return rr;
		}
		return bufio.NewReader(r);
	};
	fixedHuffmanDecoderInit = function() {
		var $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = fixedOnce.Do((function() {
			var bits$1, i, i$1, i$2, i$3;
			bits$1 = arrayType$12.zero();
			i = 0;
			while (true) {
				if (!(i < 144)) { break; }
				((i < 0 || i >= bits$1.length) ? ($throwRuntimeError("index out of range"), undefined) : bits$1[i] = 8);
				i = i + (1) >> 0;
			}
			i$1 = 144;
			while (true) {
				if (!(i$1 < 256)) { break; }
				((i$1 < 0 || i$1 >= bits$1.length) ? ($throwRuntimeError("index out of range"), undefined) : bits$1[i$1] = 9);
				i$1 = i$1 + (1) >> 0;
			}
			i$2 = 256;
			while (true) {
				if (!(i$2 < 280)) { break; }
				((i$2 < 0 || i$2 >= bits$1.length) ? ($throwRuntimeError("index out of range"), undefined) : bits$1[i$2] = 7);
				i$2 = i$2 + (1) >> 0;
			}
			i$3 = 280;
			while (true) {
				if (!(i$3 < 288)) { break; }
				((i$3 < 0 || i$3 >= bits$1.length) ? ($throwRuntimeError("index out of range"), undefined) : bits$1[i$3] = 8);
				i$3 = i$3 + (1) >> 0;
			}
			fixedHuffmanDecoder.init(new sliceType$10(bits$1));
		})); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: fixedHuffmanDecoderInit }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	decompressor.ptr.prototype.Reset = function(r, dict) {
		var dict, f, r;
		f = this;
		decompressor.copy(f, new decompressor.ptr(makeReader(r), new $Int64(0, 0), 0, 0, new huffmanDecoder.ptr(0, arrayType.zero(), sliceType$1.nil, 0), new huffmanDecoder.ptr(0, arrayType.zero(), sliceType$1.nil, 0), f.bits, f.codebits, $clone(f.dict, dictDecoder), arrayType$15.zero(), $methodExpr(ptrType$10, "nextBlock"), 0, false, $ifaceNil, sliceType$4.nil, ptrType$9.nil, ptrType$9.nil, 0, 0));
		f.dict.init(32768, dict);
		return $ifaceNil;
	};
	decompressor.prototype.Reset = function(r, dict) { return this.$val.Reset(r, dict); };
	NewReader = function(r) {
		var f, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; f = $f.f; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = [f];
		$r = fixedHuffmanDecoderInit(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		f[0] = new decompressor.ptr($ifaceNil, new $Int64(0, 0), 0, 0, new huffmanDecoder.ptr(0, arrayType.zero(), sliceType$1.nil, 0), new huffmanDecoder.ptr(0, arrayType.zero(), sliceType$1.nil, 0), ptrType$11.nil, ptrType$12.nil, new dictDecoder.ptr(sliceType$4.nil, 0, 0, false), arrayType$15.zero(), $throwNilPointerError, 0, false, $ifaceNil, sliceType$4.nil, ptrType$9.nil, ptrType$9.nil, 0, 0);
		f[0].r = makeReader(r);
		f[0].bits = arrayType$13.zero();
		f[0].codebits = arrayType$14.zero();
		f[0].step = $methodExpr(ptrType$10, "nextBlock");
		f[0].dict.init(32768, sliceType$4.nil);
		$s = -1; return f[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: NewReader }; } $f.f = f; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.NewReader = NewReader;
	ptrType$13.methods = [{prop: "init", name: "init", pkg: "compress/flate", typ: $funcType([$Int, sliceType$4], [], false)}, {prop: "histSize", name: "histSize", pkg: "compress/flate", typ: $funcType([], [$Int], false)}, {prop: "availRead", name: "availRead", pkg: "compress/flate", typ: $funcType([], [$Int], false)}, {prop: "availWrite", name: "availWrite", pkg: "compress/flate", typ: $funcType([], [$Int], false)}, {prop: "writeSlice", name: "writeSlice", pkg: "compress/flate", typ: $funcType([], [sliceType$4], false)}, {prop: "writeMark", name: "writeMark", pkg: "compress/flate", typ: $funcType([$Int], [], false)}, {prop: "writeByte", name: "writeByte", pkg: "compress/flate", typ: $funcType([$Uint8], [], false)}, {prop: "writeCopy", name: "writeCopy", pkg: "compress/flate", typ: $funcType([$Int, $Int], [$Int], false)}, {prop: "tryWriteCopy", name: "tryWriteCopy", pkg: "compress/flate", typ: $funcType([$Int, $Int], [$Int], false)}, {prop: "readFlush", name: "readFlush", pkg: "compress/flate", typ: $funcType([], [sliceType$4], false)}];
	ptrType$3.methods = [{prop: "reset", name: "reset", pkg: "compress/flate", typ: $funcType([io.Writer], [], false)}, {prop: "flush", name: "flush", pkg: "compress/flate", typ: $funcType([], [], false)}, {prop: "write", name: "write", pkg: "compress/flate", typ: $funcType([sliceType$4], [], false)}, {prop: "writeBits", name: "writeBits", pkg: "compress/flate", typ: $funcType([$Int32, $Uint], [], false)}, {prop: "writeBytes", name: "writeBytes", pkg: "compress/flate", typ: $funcType([sliceType$4], [], false)}, {prop: "generateCodegen", name: "generateCodegen", pkg: "compress/flate", typ: $funcType([$Int, $Int, ptrType, ptrType], [], false)}, {prop: "dynamicSize", name: "dynamicSize", pkg: "compress/flate", typ: $funcType([ptrType, ptrType, $Int], [$Int, $Int], false)}, {prop: "fixedSize", name: "fixedSize", pkg: "compress/flate", typ: $funcType([$Int], [$Int], false)}, {prop: "storedSize", name: "storedSize", pkg: "compress/flate", typ: $funcType([sliceType$4], [$Int, $Bool], false)}, {prop: "writeCode", name: "writeCode", pkg: "compress/flate", typ: $funcType([hcode], [], false)}, {prop: "writeDynamicHeader", name: "writeDynamicHeader", pkg: "compress/flate", typ: $funcType([$Int, $Int, $Int, $Bool], [], false)}, {prop: "writeStoredHeader", name: "writeStoredHeader", pkg: "compress/flate", typ: $funcType([$Int, $Bool], [], false)}, {prop: "writeFixedHeader", name: "writeFixedHeader", pkg: "compress/flate", typ: $funcType([$Bool], [], false)}, {prop: "writeBlock", name: "writeBlock", pkg: "compress/flate", typ: $funcType([sliceType$5, $Bool, sliceType$4], [], false)}, {prop: "writeBlockDynamic", name: "writeBlockDynamic", pkg: "compress/flate", typ: $funcType([sliceType$5, $Bool, sliceType$4], [], false)}, {prop: "indexTokens", name: "indexTokens", pkg: "compress/flate", typ: $funcType([sliceType$5], [$Int, $Int], false)}, {prop: "writeTokens", name: "writeTokens", pkg: "compress/flate", typ: $funcType([sliceType$5, sliceType$8, sliceType$8], [], false)}, {prop: "writeBlockHuff", name: "writeBlockHuff", pkg: "compress/flate", typ: $funcType([$Bool, sliceType$4], [], false)}];
	ptrType$14.methods = [{prop: "set", name: "set", pkg: "compress/flate", typ: $funcType([$Uint16, $Uint16], [], false)}];
	ptrType.methods = [{prop: "bitLength", name: "bitLength", pkg: "compress/flate", typ: $funcType([sliceType$7], [$Int], false)}, {prop: "bitCounts", name: "bitCounts", pkg: "compress/flate", typ: $funcType([sliceType$9, $Int32], [sliceType$7], false)}, {prop: "assignEncodingAndSize", name: "assignEncodingAndSize", pkg: "compress/flate", typ: $funcType([sliceType$7, sliceType$9], [], false)}, {prop: "generate", name: "generate", pkg: "compress/flate", typ: $funcType([sliceType$7, $Int32], [], false)}];
	byLiteral.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Less", name: "Less", pkg: "", typ: $funcType([$Int, $Int], [$Bool], false)}, {prop: "Swap", name: "Swap", pkg: "", typ: $funcType([$Int, $Int], [], false)}];
	ptrType$7.methods = [{prop: "sort", name: "sort", pkg: "compress/flate", typ: $funcType([sliceType$9], [], false)}];
	byFreq.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Less", name: "Less", pkg: "", typ: $funcType([$Int, $Int], [$Bool], false)}, {prop: "Swap", name: "Swap", pkg: "", typ: $funcType([$Int, $Int], [], false)}];
	ptrType$8.methods = [{prop: "sort", name: "sort", pkg: "compress/flate", typ: $funcType([sliceType$9], [], false)}];
	CorruptInputError.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	InternalError.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$9.methods = [{prop: "init", name: "init", pkg: "compress/flate", typ: $funcType([sliceType$10], [$Bool], false)}];
	ptrType$10.methods = [{prop: "nextBlock", name: "nextBlock", pkg: "compress/flate", typ: $funcType([], [], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$4], [$Int, $error], false)}, {prop: "Close", name: "Close", pkg: "", typ: $funcType([], [$error], false)}, {prop: "readHuffman", name: "readHuffman", pkg: "compress/flate", typ: $funcType([], [$error], false)}, {prop: "huffmanBlock", name: "huffmanBlock", pkg: "compress/flate", typ: $funcType([], [], false)}, {prop: "dataBlock", name: "dataBlock", pkg: "compress/flate", typ: $funcType([], [], false)}, {prop: "copyData", name: "copyData", pkg: "compress/flate", typ: $funcType([], [], false)}, {prop: "finishBlock", name: "finishBlock", pkg: "compress/flate", typ: $funcType([], [], false)}, {prop: "moreBits", name: "moreBits", pkg: "compress/flate", typ: $funcType([], [$error], false)}, {prop: "huffSym", name: "huffSym", pkg: "compress/flate", typ: $funcType([ptrType$9], [$Int, $error], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([io.Reader, sliceType$4], [$error], false)}];
	token.methods = [{prop: "literal", name: "literal", pkg: "compress/flate", typ: $funcType([], [$Uint32], false)}, {prop: "offset", name: "offset", pkg: "compress/flate", typ: $funcType([], [$Uint32], false)}, {prop: "length", name: "length", pkg: "compress/flate", typ: $funcType([], [$Uint32], false)}];
	dictDecoder.init("compress/flate", [{prop: "hist", name: "hist", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "wrPos", name: "wrPos", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "rdPos", name: "rdPos", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "full", name: "full", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	huffmanBitWriter.init("compress/flate", [{prop: "writer", name: "writer", embedded: false, exported: false, typ: io.Writer, tag: ""}, {prop: "bits", name: "bits", embedded: false, exported: false, typ: $Uint64, tag: ""}, {prop: "nbits", name: "nbits", embedded: false, exported: false, typ: $Uint, tag: ""}, {prop: "bytes", name: "bytes", embedded: false, exported: false, typ: arrayType$5, tag: ""}, {prop: "codegenFreq", name: "codegenFreq", embedded: false, exported: false, typ: arrayType$6, tag: ""}, {prop: "nbytes", name: "nbytes", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "literalFreq", name: "literalFreq", embedded: false, exported: false, typ: sliceType$7, tag: ""}, {prop: "offsetFreq", name: "offsetFreq", embedded: false, exported: false, typ: sliceType$7, tag: ""}, {prop: "codegen", name: "codegen", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "literalEncoding", name: "literalEncoding", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "offsetEncoding", name: "offsetEncoding", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "codegenEncoding", name: "codegenEncoding", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "err", name: "err", embedded: false, exported: false, typ: $error, tag: ""}]);
	hcode.init("compress/flate", [{prop: "code", name: "code", embedded: false, exported: false, typ: $Uint16, tag: ""}, {prop: "len", name: "len", embedded: false, exported: false, typ: $Uint16, tag: ""}]);
	huffmanEncoder.init("compress/flate", [{prop: "codes", name: "codes", embedded: false, exported: false, typ: sliceType$8, tag: ""}, {prop: "freqcache", name: "freqcache", embedded: false, exported: false, typ: sliceType$9, tag: ""}, {prop: "bitCount", name: "bitCount", embedded: false, exported: false, typ: arrayType$7, tag: ""}, {prop: "lns", name: "lns", embedded: false, exported: false, typ: byLiteral, tag: ""}, {prop: "lfs", name: "lfs", embedded: false, exported: false, typ: byFreq, tag: ""}]);
	literalNode.init("compress/flate", [{prop: "literal", name: "literal", embedded: false, exported: false, typ: $Uint16, tag: ""}, {prop: "freq", name: "freq", embedded: false, exported: false, typ: $Int32, tag: ""}]);
	levelInfo.init("compress/flate", [{prop: "level", name: "level", embedded: false, exported: false, typ: $Int32, tag: ""}, {prop: "lastFreq", name: "lastFreq", embedded: false, exported: false, typ: $Int32, tag: ""}, {prop: "nextCharFreq", name: "nextCharFreq", embedded: false, exported: false, typ: $Int32, tag: ""}, {prop: "nextPairFreq", name: "nextPairFreq", embedded: false, exported: false, typ: $Int32, tag: ""}, {prop: "needed", name: "needed", embedded: false, exported: false, typ: $Int32, tag: ""}]);
	byLiteral.init(literalNode);
	byFreq.init(literalNode);
	Resetter.init([{prop: "Reset", name: "Reset", pkg: "", typ: $funcType([io.Reader, sliceType$4], [$error], false)}]);
	huffmanDecoder.init("compress/flate", [{prop: "min", name: "min", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "chunks", name: "chunks", embedded: false, exported: false, typ: arrayType, tag: ""}, {prop: "links", name: "links", embedded: false, exported: false, typ: sliceType$1, tag: ""}, {prop: "linkMask", name: "linkMask", embedded: false, exported: false, typ: $Uint32, tag: ""}]);
	Reader.init([{prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$4], [$Int, $error], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}]);
	decompressor.init("compress/flate", [{prop: "r", name: "r", embedded: false, exported: false, typ: Reader, tag: ""}, {prop: "roffset", name: "roffset", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "b", name: "b", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "nb", name: "nb", embedded: false, exported: false, typ: $Uint, tag: ""}, {prop: "h1", name: "h1", embedded: false, exported: false, typ: huffmanDecoder, tag: ""}, {prop: "h2", name: "h2", embedded: false, exported: false, typ: huffmanDecoder, tag: ""}, {prop: "bits", name: "bits", embedded: false, exported: false, typ: ptrType$11, tag: ""}, {prop: "codebits", name: "codebits", embedded: false, exported: false, typ: ptrType$12, tag: ""}, {prop: "dict", name: "dict", embedded: false, exported: false, typ: dictDecoder, tag: ""}, {prop: "buf", name: "buf", embedded: false, exported: false, typ: arrayType$15, tag: ""}, {prop: "step", name: "step", embedded: false, exported: false, typ: funcType$3, tag: ""}, {prop: "stepState", name: "stepState", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "final$12", name: "final", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "err", name: "err", embedded: false, exported: false, typ: $error, tag: ""}, {prop: "toRead", name: "toRead", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "hl", name: "hl", embedded: false, exported: false, typ: ptrType$9, tag: ""}, {prop: "hd", name: "hd", embedded: false, exported: false, typ: ptrType$9, tag: ""}, {prop: "copyLen", name: "copyLen", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "copyDist", name: "copyDist", embedded: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bufio.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bits.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sort.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		huffOffset = ptrType.nil;
		fixedOnce = new sync.Once.ptr(new sync.Mutex.ptr(0, 0), 0);
		fixedHuffmanDecoder = new huffmanDecoder.ptr(0, arrayType.zero(), sliceType$1.nil, 0);
		fixedOffsetEncoding = generateFixedOffsetEncoding();
		fixedLiteralEncoding = generateFixedLiteralEncoding();
		codeOrder = $toNativeArray($kindInt, [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
		$r = init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["encoding/binary"] = (function() {
	var $pkg = {}, $init, errors, io, math, reflect, littleEndian, sliceType, overflow;
	errors = $packages["errors"];
	io = $packages["io"];
	math = $packages["math"];
	reflect = $packages["reflect"];
	littleEndian = $pkg.littleEndian = $newType(0, $kindStruct, "binary.littleEndian", true, "encoding/binary", false, function() {
		this.$val = this;
		if (arguments.length === 0) {
			return;
		}
	});
	sliceType = $sliceType($Uint8);
	littleEndian.ptr.prototype.Uint16 = function(b) {
		var b;
		$unused((1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]));
		return ((((0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]) << 16 >>> 16)) | ((((1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]) << 16 >>> 16)) << 8 << 16 >>> 16)) >>> 0;
	};
	littleEndian.prototype.Uint16 = function(b) { return this.$val.Uint16(b); };
	littleEndian.ptr.prototype.PutUint16 = function(b, v) {
		var b, v;
		$unused((1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]));
		(0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0] = ((v << 24 >>> 24)));
		(1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1] = (((v >>> 8 << 16 >>> 16) << 24 >>> 24)));
	};
	littleEndian.prototype.PutUint16 = function(b, v) { return this.$val.PutUint16(b, v); };
	littleEndian.ptr.prototype.Uint32 = function(b) {
		var b;
		$unused((3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]));
		return ((((((((0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]) >>> 0)) | ((((1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]) >>> 0)) << 8 >>> 0)) >>> 0) | ((((2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2]) >>> 0)) << 16 >>> 0)) >>> 0) | ((((3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]) >>> 0)) << 24 >>> 0)) >>> 0;
	};
	littleEndian.prototype.Uint32 = function(b) { return this.$val.Uint32(b); };
	littleEndian.ptr.prototype.PutUint32 = function(b, v) {
		var b, v;
		$unused((3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]));
		(0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0] = ((v << 24 >>> 24)));
		(1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1] = (((v >>> 8 >>> 0) << 24 >>> 24)));
		(2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2] = (((v >>> 16 >>> 0) << 24 >>> 24)));
		(3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3] = (((v >>> 24 >>> 0) << 24 >>> 24)));
	};
	littleEndian.prototype.PutUint32 = function(b, v) { return this.$val.PutUint32(b, v); };
	littleEndian.ptr.prototype.Uint64 = function(b) {
		var b, x, x$1, x$10, x$11, x$12, x$13, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		$unused((7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]));
		return (x = (x$1 = (x$2 = (x$3 = (x$4 = (x$5 = (x$6 = (new $Uint64(0, (0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0]))), x$7 = $shiftLeft64((new $Uint64(0, (1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1]))), 8), new $Uint64(x$6.$high | x$7.$high, (x$6.$low | x$7.$low) >>> 0)), x$8 = $shiftLeft64((new $Uint64(0, (2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2]))), 16), new $Uint64(x$5.$high | x$8.$high, (x$5.$low | x$8.$low) >>> 0)), x$9 = $shiftLeft64((new $Uint64(0, (3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3]))), 24), new $Uint64(x$4.$high | x$9.$high, (x$4.$low | x$9.$low) >>> 0)), x$10 = $shiftLeft64((new $Uint64(0, (4 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 4]))), 32), new $Uint64(x$3.$high | x$10.$high, (x$3.$low | x$10.$low) >>> 0)), x$11 = $shiftLeft64((new $Uint64(0, (5 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 5]))), 40), new $Uint64(x$2.$high | x$11.$high, (x$2.$low | x$11.$low) >>> 0)), x$12 = $shiftLeft64((new $Uint64(0, (6 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 6]))), 48), new $Uint64(x$1.$high | x$12.$high, (x$1.$low | x$12.$low) >>> 0)), x$13 = $shiftLeft64((new $Uint64(0, (7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]))), 56), new $Uint64(x.$high | x$13.$high, (x.$low | x$13.$low) >>> 0));
	};
	littleEndian.prototype.Uint64 = function(b) { return this.$val.Uint64(b); };
	littleEndian.ptr.prototype.PutUint64 = function(b, v) {
		var b, v;
		$unused((7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7]));
		(0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0] = ((v.$low << 24 >>> 24)));
		(1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1] = (($shiftRightUint64(v, 8).$low << 24 >>> 24)));
		(2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2] = (($shiftRightUint64(v, 16).$low << 24 >>> 24)));
		(3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3] = (($shiftRightUint64(v, 24).$low << 24 >>> 24)));
		(4 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 4] = (($shiftRightUint64(v, 32).$low << 24 >>> 24)));
		(5 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 5] = (($shiftRightUint64(v, 40).$low << 24 >>> 24)));
		(6 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 6] = (($shiftRightUint64(v, 48).$low << 24 >>> 24)));
		(7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7] = (($shiftRightUint64(v, 56).$low << 24 >>> 24)));
	};
	littleEndian.prototype.PutUint64 = function(b, v) { return this.$val.PutUint64(b, v); };
	littleEndian.ptr.prototype.String = function() {
		return "LittleEndian";
	};
	littleEndian.prototype.String = function() { return this.$val.String(); };
	littleEndian.ptr.prototype.GoString = function() {
		return "binary.LittleEndian";
	};
	littleEndian.prototype.GoString = function() { return this.$val.GoString(); };
	littleEndian.methods = [{prop: "Uint16", name: "Uint16", pkg: "", typ: $funcType([sliceType], [$Uint16], false)}, {prop: "PutUint16", name: "PutUint16", pkg: "", typ: $funcType([sliceType, $Uint16], [], false)}, {prop: "Uint32", name: "Uint32", pkg: "", typ: $funcType([sliceType], [$Uint32], false)}, {prop: "PutUint32", name: "PutUint32", pkg: "", typ: $funcType([sliceType, $Uint32], [], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([sliceType], [$Uint64], false)}, {prop: "PutUint64", name: "PutUint64", pkg: "", typ: $funcType([sliceType, $Uint64], [], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "GoString", name: "GoString", pkg: "", typ: $funcType([], [$String], false)}];
	littleEndian.init("", []);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = reflect.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.LittleEndian = new littleEndian.ptr();
		overflow = errors.New("binary: varint overflows a 64-bit integer");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["hash"] = (function() {
	var $pkg = {}, $init, io;
	io = $packages["io"];
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = io.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["hash/crc32"] = (function() {
	var $pkg = {}, $init, errors, hash, sync, Table, slicing8Table, ptrType, ptrType$1, arrayType$1, arrayType$2, castagnoliTable, updateCastagnoli, ieeeTable8, ieeeArchImpl, updateIEEE, ieeeOnce, ieeeInit, Update, ChecksumIEEE, simpleMakeTable, simplePopulateTable, simpleUpdate, slicingMakeTable, slicingUpdate, archAvailableIEEE, archInitIEEE, archUpdateIEEE;
	errors = $packages["errors"];
	hash = $packages["hash"];
	sync = $packages["sync"];
	Table = $pkg.Table = $newType(1024, $kindArray, "crc32.Table", true, "hash/crc32", true, null);
	slicing8Table = $pkg.slicing8Table = $newType(8192, $kindArray, "crc32.slicing8Table", true, "hash/crc32", false, null);
	ptrType = $ptrType(Table);
	ptrType$1 = $ptrType(slicing8Table);
	arrayType$1 = $arrayType($Uint32, 256);
	arrayType$2 = $arrayType(Table, 8);
	ieeeInit = function() {
		ieeeArchImpl = archAvailableIEEE();
		if (ieeeArchImpl) {
			archInitIEEE();
			updateIEEE = archUpdateIEEE;
		} else {
			ieeeTable8 = slicingMakeTable(3988292384);
			updateIEEE = (function(crc, p) {
				var crc, p;
				return slicingUpdate(crc, ieeeTable8, p);
			});
		}
	};
	Update = function(crc, tab, p) {
		var _1, _r, _r$1, crc, p, tab, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; crc = $f.crc; p = $f.p; tab = $f.tab; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = tab;
			/* */ if ($equal(_1, (castagnoliTable), Table)) { $s = 2; continue; }
			/* */ if ($equal(_1, ($pkg.IEEETable), Table)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if ($equal(_1, (castagnoliTable), Table)) { */ case 2:
				_r = updateCastagnoli(crc, p); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if ($equal(_1, ($pkg.IEEETable), Table)) { */ case 3:
				$r = ieeeOnce.Do(ieeeInit); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				_r$1 = updateIEEE(crc, p); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$s = -1; return _r$1;
			/* } else { */ case 4:
				$s = -1; return simpleUpdate(crc, tab, p);
			/* } */ case 5:
		case 1:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Update }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.crc = crc; $f.p = p; $f.tab = tab; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Update = Update;
	ChecksumIEEE = function(data) {
		var _r, data, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; data = $f.data; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = ieeeOnce.Do(ieeeInit); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r = updateIEEE(0, data); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ChecksumIEEE }; } $f._r = _r; $f.data = data; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ChecksumIEEE = ChecksumIEEE;
	simpleMakeTable = function(poly) {
		var poly, t;
		t = arrayType$1.zero();
		simplePopulateTable(poly, t);
		return t;
	};
	simplePopulateTable = function(poly, t) {
		var crc, i, j, poly, t, y;
		i = 0;
		while (true) {
			if (!(i < 256)) { break; }
			crc = ((i >>> 0));
			j = 0;
			while (true) {
				if (!(j < 8)) { break; }
				if (((crc & 1) >>> 0) === 1) {
					crc = (((crc >>> 1 >>> 0)) ^ poly) >>> 0;
				} else {
					crc = (y = (1), y < 32 ? (crc >>> y) : 0) >>> 0;
				}
				j = j + (1) >> 0;
			}
			t.nilCheck, ((i < 0 || i >= t.length) ? ($throwRuntimeError("index out of range"), undefined) : t[i] = crc);
			i = i + (1) >> 0;
		}
	};
	simpleUpdate = function(crc, tab, p) {
		var _i, _ref, crc, p, tab, v, x;
		crc = ~crc >>> 0;
		_ref = p;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			v = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			crc = ((x = (((crc << 24 >>> 24)) ^ v) << 24 >>> 24, (tab.nilCheck, ((x < 0 || x >= tab.length) ? ($throwRuntimeError("index out of range"), undefined) : tab[x]))) ^ ((crc >>> 8 >>> 0))) >>> 0;
			_i++;
		}
		return ~crc >>> 0;
	};
	slicingMakeTable = function(poly) {
		var crc, i, j, poly, t, x, x$1, x$2, x$3;
		t = arrayType$2.zero();
		simplePopulateTable(poly, (t.nilCheck, t[0]));
		i = 0;
		while (true) {
			if (!(i < 256)) { break; }
			crc = (x = (t.nilCheck, t[0]), ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i]));
			j = 1;
			while (true) {
				if (!(j < 8)) { break; }
				crc = ((x$1 = (t.nilCheck, t[0]), x$2 = (crc & 255) >>> 0, ((x$2 < 0 || x$2 >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[x$2])) ^ ((crc >>> 8 >>> 0))) >>> 0;
				(x$3 = (t.nilCheck, ((j < 0 || j >= t.length) ? ($throwRuntimeError("index out of range"), undefined) : t[j])), ((i < 0 || i >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[i] = crc));
				j = j + (1) >> 0;
			}
			i = i + (1) >> 0;
		}
		return t;
	};
	slicingUpdate = function(crc, tab, p) {
		var crc, p, tab, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		if (p.$length >= 16) {
			crc = ~crc >>> 0;
			while (true) {
				if (!(p.$length > 8)) { break; }
				crc = (crc ^ ((((((((((0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]) >>> 0)) | ((((1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]) >>> 0)) << 8 >>> 0)) >>> 0) | ((((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]) >>> 0)) << 16 >>> 0)) >>> 0) | ((((3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3]) >>> 0)) << 24 >>> 0)) >>> 0))) >>> 0;
				crc = ((((((((((((((x = (tab.nilCheck, tab[0]), x$1 = (7 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 7]), ((x$1 < 0 || x$1 >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[x$1])) ^ (x$2 = (tab.nilCheck, tab[1]), x$3 = (6 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 6]), ((x$3 < 0 || x$3 >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[x$3]))) >>> 0) ^ (x$4 = (tab.nilCheck, tab[2]), x$5 = (5 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 5]), ((x$5 < 0 || x$5 >= x$4.length) ? ($throwRuntimeError("index out of range"), undefined) : x$4[x$5]))) >>> 0) ^ (x$6 = (tab.nilCheck, tab[3]), x$7 = (4 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 4]), ((x$7 < 0 || x$7 >= x$6.length) ? ($throwRuntimeError("index out of range"), undefined) : x$6[x$7]))) >>> 0) ^ (x$8 = (tab.nilCheck, tab[4]), x$9 = crc >>> 24 >>> 0, ((x$9 < 0 || x$9 >= x$8.length) ? ($throwRuntimeError("index out of range"), undefined) : x$8[x$9]))) >>> 0) ^ (x$10 = (tab.nilCheck, tab[5]), x$11 = (((crc >>> 16 >>> 0)) & 255) >>> 0, ((x$11 < 0 || x$11 >= x$10.length) ? ($throwRuntimeError("index out of range"), undefined) : x$10[x$11]))) >>> 0) ^ (x$12 = (tab.nilCheck, tab[6]), x$13 = (((crc >>> 8 >>> 0)) & 255) >>> 0, ((x$13 < 0 || x$13 >= x$12.length) ? ($throwRuntimeError("index out of range"), undefined) : x$12[x$13]))) >>> 0) ^ (x$14 = (tab.nilCheck, tab[7]), x$15 = (crc & 255) >>> 0, ((x$15 < 0 || x$15 >= x$14.length) ? ($throwRuntimeError("index out of range"), undefined) : x$14[x$15]))) >>> 0;
				p = $subslice(p, 8);
			}
			crc = ~crc >>> 0;
		}
		if (p.$length === 0) {
			return crc;
		}
		return simpleUpdate(crc, (tab.nilCheck, tab[0]), p);
	};
	archAvailableIEEE = function() {
		return false;
	};
	archInitIEEE = function() {
		$panic(new $String("not available"));
	};
	archUpdateIEEE = function(crc, p) {
		var crc, p;
		$panic(new $String("not available"));
	};
	Table.init($Uint32, 256);
	slicing8Table.init(Table, 8);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = hash.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		castagnoliTable = ptrType.nil;
		updateCastagnoli = $throwNilPointerError;
		ieeeTable8 = ptrType$1.nil;
		ieeeArchImpl = false;
		updateIEEE = $throwNilPointerError;
		ieeeOnce = new sync.Once.ptr(new sync.Mutex.ptr(0, 0), 0);
		$pkg.IEEETable = simpleMakeTable(3988292384);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["compress/gzip"] = (function() {
	var $pkg = {}, $init, bufio, flate, binary, errors, fmt, crc32, io, time, Header, Reader, sliceType, ptrType, arrayType, ptrType$1, sliceType$1, le, noEOF, NewReader;
	bufio = $packages["bufio"];
	flate = $packages["compress/flate"];
	binary = $packages["encoding/binary"];
	errors = $packages["errors"];
	fmt = $packages["fmt"];
	crc32 = $packages["hash/crc32"];
	io = $packages["io"];
	time = $packages["time"];
	Header = $pkg.Header = $newType(0, $kindStruct, "gzip.Header", true, "compress/gzip", true, function(Comment_, Extra_, ModTime_, Name_, OS_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Comment = "";
			this.Extra = sliceType.nil;
			this.ModTime = new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType.nil);
			this.Name = "";
			this.OS = 0;
			return;
		}
		this.Comment = Comment_;
		this.Extra = Extra_;
		this.ModTime = ModTime_;
		this.Name = Name_;
		this.OS = OS_;
	});
	Reader = $pkg.Reader = $newType(0, $kindStruct, "gzip.Reader", true, "compress/gzip", true, function(Header_, r_, decompressor_, digest_, size_, buf_, err_, multistream_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Header = new Header.ptr("", sliceType.nil, new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType.nil), "", 0);
			this.r = $ifaceNil;
			this.decompressor = $ifaceNil;
			this.digest = 0;
			this.size = 0;
			this.buf = arrayType.zero();
			this.err = $ifaceNil;
			this.multistream = false;
			return;
		}
		this.Header = Header_;
		this.r = r_;
		this.decompressor = decompressor_;
		this.digest = digest_;
		this.size = size_;
		this.buf = buf_;
		this.err = err_;
		this.multistream = multistream_;
	});
	sliceType = $sliceType($Uint8);
	ptrType = $ptrType(time.Location);
	arrayType = $arrayType($Uint8, 512);
	ptrType$1 = $ptrType(Reader);
	sliceType$1 = $sliceType($Int32);
	noEOF = function(err) {
		var err;
		if ($interfaceIsEqual(err, io.EOF)) {
			return io.ErrUnexpectedEOF;
		}
		return err;
	};
	NewReader = function(r) {
		var _r, err, r, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; r = $f.r; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = new Reader.ptr(new Header.ptr("", sliceType.nil, new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType.nil), "", 0), $ifaceNil, $ifaceNil, 0, 0, arrayType.zero(), $ifaceNil, false);
		_r = z.Reset(r); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [ptrType$1.nil, err];
		}
		$s = -1; return [z, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: NewReader }; } $f._r = _r; $f.err = err; $f.r = r; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.NewReader = NewReader;
	Reader.ptr.prototype.Reset = function(r) {
		var _r, _tuple, _tuple$1, ok, r, rr, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; ok = $f.ok; r = $f.r; rr = $f.rr; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		Reader.copy(z, new Reader.ptr(new Header.ptr("", sliceType.nil, new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType.nil), "", 0), $ifaceNil, z.decompressor, 0, 0, arrayType.zero(), $ifaceNil, true));
		_tuple = $assertType(r, flate.Reader, true);
		rr = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			z.r = rr;
		} else {
			z.r = bufio.NewReader(r);
		}
		_r = z.readHeader(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		Header.copy(z.Header, _tuple$1[0]);
		z.err = _tuple$1[1];
		$s = -1; return z.err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.Reset }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.ok = ok; $f.r = r; $f.rr = rr; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.Reset = function(r) { return this.$val.Reset(r); };
	Reader.ptr.prototype.Multistream = function(ok) {
		var ok, z;
		z = this;
		z.multistream = ok;
	};
	Reader.prototype.Multistream = function(ok) { return this.$val.Multistream(ok); };
	Reader.ptr.prototype.readString = function() {
		var _i, _r, _r$1, _ref, _tuple, err, i, needConv, s, v, x, x$1, x$2, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _tuple = $f._tuple; err = $f.err; i = $f.i; needConv = $f.needConv; s = $f.s; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		err = $ifaceNil;
		needConv = false;
		i = 0;
		/* while (true) { */ case 1:
			if (i >= 512) {
				$s = -1; return ["", $pkg.ErrHeader];
			}
			_r = z.r.ReadByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			(x = z.buf, ((i < 0 || i >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[i] = _tuple[0]));
			err = _tuple[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return ["", err];
			}
			if ((x$1 = z.buf, ((i < 0 || i >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[i])) > 127) {
				needConv = true;
			}
			/* */ if ((x$2 = z.buf, ((i < 0 || i >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i])) === 0) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if ((x$2 = z.buf, ((i < 0 || i >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[i])) === 0) { */ case 4:
				_r$1 = crc32.Update(z.digest, crc32.IEEETable, $subslice(new sliceType(z.buf), 0, (i + 1 >> 0))); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				z.digest = _r$1;
				if (needConv) {
					s = $makeSlice(sliceType$1, 0, i);
					_ref = $subslice(new sliceType(z.buf), 0, i);
					_i = 0;
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						v = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
						s = $append(s, ((v >> 0)));
						_i++;
					}
					$s = -1; return [($runesToString(s)), $ifaceNil];
				}
				$s = -1; return [($bytesToString($subslice(new sliceType(z.buf), 0, i))), $ifaceNil];
			/* } */ case 5:
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return ["", $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.readString }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._tuple = _tuple; $f.err = err; $f.i = i; $f.needConv = needConv; $f.s = s; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.readString = function() { return this.$val.readString(); };
	Reader.ptr.prototype.readHeader = function() {
		var _r, _r$1, _r$10, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, data, digest, err, flg, hdr, s, t, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; data = $f.data; digest = $f.digest; err = $f.err; flg = $f.flg; hdr = $f.hdr; s = $f.s; t = $f.t; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		hdr = new Header.ptr("", sliceType.nil, new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType.nil), "", 0);
		err = $ifaceNil;
		z = this;
		_r = io.ReadFull(z.r, $subslice(new sliceType(z.buf), 0, 10)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			_tmp = $clone(hdr, Header);
			_tmp$1 = err;
			Header.copy(hdr, _tmp);
			err = _tmp$1;
			$s = -1; return [hdr, err];
		}
		if (!((z.buf[0] === 31)) || !((z.buf[1] === 139)) || !((z.buf[2] === 8))) {
			_tmp$2 = $clone(hdr, Header);
			_tmp$3 = $pkg.ErrHeader;
			Header.copy(hdr, _tmp$2);
			err = _tmp$3;
			$s = -1; return [hdr, err];
		}
		flg = z.buf[3];
		t = (new $Int64(0, $clone(le, binary.littleEndian).Uint32($subslice(new sliceType(z.buf), 4, 8))));
		if ((t.$high > 0 || (t.$high === 0 && t.$low > 0))) {
			time.Time.copy(hdr.ModTime, time.Unix(t, new $Int64(0, 0)));
		}
		hdr.OS = z.buf[9];
		_r$1 = crc32.ChecksumIEEE($subslice(new sliceType(z.buf), 0, 10)); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		z.digest = _r$1;
		/* */ if (!((((flg & 4) >>> 0) === 0))) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (!((((flg & 4) >>> 0) === 0))) { */ case 3:
			_r$2 = io.ReadFull(z.r, $subslice(new sliceType(z.buf), 0, 2)); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple$1 = _r$2;
			err = _tuple$1[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp$4 = $clone(hdr, Header);
				_tmp$5 = noEOF(err);
				Header.copy(hdr, _tmp$4);
				err = _tmp$5;
				$s = -1; return [hdr, err];
			}
			_r$3 = crc32.Update(z.digest, crc32.IEEETable, $subslice(new sliceType(z.buf), 0, 2)); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			z.digest = _r$3;
			data = $makeSlice(sliceType, $clone(le, binary.littleEndian).Uint16($subslice(new sliceType(z.buf), 0, 2)));
			_r$4 = io.ReadFull(z.r, data); /* */ $s = 7; case 7: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			_tuple$2 = _r$4;
			err = _tuple$2[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp$6 = $clone(hdr, Header);
				_tmp$7 = noEOF(err);
				Header.copy(hdr, _tmp$6);
				err = _tmp$7;
				$s = -1; return [hdr, err];
			}
			_r$5 = crc32.Update(z.digest, crc32.IEEETable, data); /* */ $s = 8; case 8: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			z.digest = _r$5;
			hdr.Extra = data;
		/* } */ case 4:
		s = "";
		/* */ if (!((((flg & 8) >>> 0) === 0))) { $s = 9; continue; }
		/* */ $s = 10; continue;
		/* if (!((((flg & 8) >>> 0) === 0))) { */ case 9:
			_r$6 = z.readString(); /* */ $s = 11; case 11: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple$3 = _r$6;
			s = _tuple$3[0];
			err = _tuple$3[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp$8 = $clone(hdr, Header);
				_tmp$9 = err;
				Header.copy(hdr, _tmp$8);
				err = _tmp$9;
				$s = -1; return [hdr, err];
			}
			hdr.Name = s;
		/* } */ case 10:
		/* */ if (!((((flg & 16) >>> 0) === 0))) { $s = 12; continue; }
		/* */ $s = 13; continue;
		/* if (!((((flg & 16) >>> 0) === 0))) { */ case 12:
			_r$7 = z.readString(); /* */ $s = 14; case 14: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_tuple$4 = _r$7;
			s = _tuple$4[0];
			err = _tuple$4[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp$10 = $clone(hdr, Header);
				_tmp$11 = err;
				Header.copy(hdr, _tmp$10);
				err = _tmp$11;
				$s = -1; return [hdr, err];
			}
			hdr.Comment = s;
		/* } */ case 13:
		/* */ if (!((((flg & 2) >>> 0) === 0))) { $s = 15; continue; }
		/* */ $s = 16; continue;
		/* if (!((((flg & 2) >>> 0) === 0))) { */ case 15:
			_r$8 = io.ReadFull(z.r, $subslice(new sliceType(z.buf), 0, 2)); /* */ $s = 17; case 17: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			_tuple$5 = _r$8;
			err = _tuple$5[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp$12 = $clone(hdr, Header);
				_tmp$13 = noEOF(err);
				Header.copy(hdr, _tmp$12);
				err = _tmp$13;
				$s = -1; return [hdr, err];
			}
			digest = $clone(le, binary.littleEndian).Uint16($subslice(new sliceType(z.buf), 0, 2));
			if (!((digest === ((z.digest << 16 >>> 16))))) {
				_tmp$14 = $clone(hdr, Header);
				_tmp$15 = $pkg.ErrHeader;
				Header.copy(hdr, _tmp$14);
				err = _tmp$15;
				$s = -1; return [hdr, err];
			}
		/* } */ case 16:
		z.digest = 0;
		/* */ if ($interfaceIsEqual(z.decompressor, $ifaceNil)) { $s = 18; continue; }
		/* */ $s = 19; continue;
		/* if ($interfaceIsEqual(z.decompressor, $ifaceNil)) { */ case 18:
			_r$9 = flate.NewReader(z.r); /* */ $s = 21; case 21: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
			z.decompressor = _r$9;
			$s = 20; continue;
		/* } else { */ case 19:
			_r$10 = $assertType(z.decompressor, flate.Resetter).Reset(z.r, sliceType.nil); /* */ $s = 22; case 22: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			_r$10;
		/* } */ case 20:
		_tmp$16 = $clone(hdr, Header);
		_tmp$17 = $ifaceNil;
		Header.copy(hdr, _tmp$16);
		err = _tmp$17;
		$s = -1; return [hdr, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.readHeader }; } $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.data = data; $f.digest = digest; $f.err = err; $f.flg = flg; $f.hdr = hdr; $f.s = s; $f.t = t; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.readHeader = function() { return this.$val.readHeader(); };
	Reader.ptr.prototype.Read = function(p) {
		var _r, _r$1, _r$2, _r$3, _r$4, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, digest, err, err$1, n, p, size, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; digest = $f.digest; err = $f.err; err$1 = $f.err$1; n = $f.n; p = $f.p; size = $f.size; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		z = this;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			_tmp = 0;
			_tmp$1 = z.err;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		_r = z.decompressor.Read(p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		z.err = _tuple[1];
		_r$1 = crc32.Update(z.digest, crc32.IEEETable, $subslice(p, 0, n)); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		z.digest = _r$1;
		z.size = z.size + (((n >>> 0))) >>> 0;
		if (!($interfaceIsEqual(z.err, io.EOF))) {
			_tmp$2 = n;
			_tmp$3 = z.err;
			n = _tmp$2;
			err = _tmp$3;
			$s = -1; return [n, err];
		}
		_r$2 = io.ReadFull(z.r, $subslice(new sliceType(z.buf), 0, 8)); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_tuple$1 = _r$2;
		err$1 = _tuple$1[1];
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			z.err = noEOF(err$1);
			_tmp$4 = n;
			_tmp$5 = z.err;
			n = _tmp$4;
			err = _tmp$5;
			$s = -1; return [n, err];
		}
		digest = $clone(le, binary.littleEndian).Uint32($subslice(new sliceType(z.buf), 0, 4));
		size = $clone(le, binary.littleEndian).Uint32($subslice(new sliceType(z.buf), 4, 8));
		if (!((digest === z.digest)) || !((size === z.size))) {
			z.err = $pkg.ErrChecksum;
			_tmp$6 = n;
			_tmp$7 = z.err;
			n = _tmp$6;
			err = _tmp$7;
			$s = -1; return [n, err];
		}
		_tmp$8 = 0;
		_tmp$9 = 0;
		z.digest = _tmp$8;
		z.size = _tmp$9;
		if (!z.multistream) {
			_tmp$10 = n;
			_tmp$11 = io.EOF;
			n = _tmp$10;
			err = _tmp$11;
			$s = -1; return [n, err];
		}
		z.err = $ifaceNil;
		_r$3 = z.readHeader(); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_tuple$2 = _r$3;
		z.err = _tuple$2[1];
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			_tmp$12 = n;
			_tmp$13 = z.err;
			n = _tmp$12;
			err = _tmp$13;
			$s = -1; return [n, err];
		}
		if (n > 0) {
			_tmp$14 = n;
			_tmp$15 = $ifaceNil;
			n = _tmp$14;
			err = _tmp$15;
			$s = -1; return [n, err];
		}
		_r$4 = z.Read(p); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_tuple$3 = _r$4;
		n = _tuple$3[0];
		err = _tuple$3[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.Read }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.digest = digest; $f.err = err; $f.err$1 = err$1; $f.n = n; $f.p = p; $f.size = size; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.Read = function(p) { return this.$val.Read(p); };
	Reader.ptr.prototype.Close = function() {
		var _r, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		_r = z.decompressor.Close(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.Close }; } $f._r = _r; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.Close = function() { return this.$val.Close(); };
	ptrType$1.methods = [{prop: "Reset", name: "Reset", pkg: "", typ: $funcType([io.Reader], [$error], false)}, {prop: "Multistream", name: "Multistream", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "readString", name: "readString", pkg: "compress/gzip", typ: $funcType([], [$String, $error], false)}, {prop: "readHeader", name: "readHeader", pkg: "compress/gzip", typ: $funcType([], [Header, $error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "Close", name: "Close", pkg: "", typ: $funcType([], [$error], false)}];
	Header.init("", [{prop: "Comment", name: "Comment", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Extra", name: "Extra", embedded: false, exported: true, typ: sliceType, tag: ""}, {prop: "ModTime", name: "ModTime", embedded: false, exported: true, typ: time.Time, tag: ""}, {prop: "Name", name: "Name", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "OS", name: "OS", embedded: false, exported: true, typ: $Uint8, tag: ""}]);
	Reader.init("compress/gzip", [{prop: "Header", name: "Header", embedded: true, exported: true, typ: Header, tag: ""}, {prop: "r", name: "r", embedded: false, exported: false, typ: flate.Reader, tag: ""}, {prop: "decompressor", name: "decompressor", embedded: false, exported: false, typ: io.ReadCloser, tag: ""}, {prop: "digest", name: "digest", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "size", name: "size", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "buf", name: "buf", embedded: false, exported: false, typ: arrayType, tag: ""}, {prop: "err", name: "err", embedded: false, exported: false, typ: $error, tag: ""}, {prop: "multistream", name: "multistream", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bufio.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = flate.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = binary.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = crc32.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrChecksum = errors.New("gzip: invalid checksum");
		$pkg.ErrHeader = errors.New("gzip: invalid header");
		le = $clone(binary.LittleEndian, binary.littleEndian);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/bitmapfont/internal/unicode"] = (function() {
	var $pkg = {}, $init, IsLatin, IsGreek, IsCyrillic, IsArmenian, IsGeorgian, IsOgham, IsRunic, IsEuropian;
	IsLatin = function(r) {
		var r;
		if (r <= 767) {
			return true;
		}
		if (7424 <= r && r <= 7615) {
			return true;
		}
		if (7680 <= r && r <= 7935) {
			return true;
		}
		if (8304 <= r && r <= 8351) {
			return true;
		}
		if (11360 <= r && r <= 11391) {
			return true;
		}
		if (42784 <= r && r <= 43007) {
			return true;
		}
		if (43824 <= r && r <= 43887) {
			return true;
		}
		if (64256 <= r && r <= 64335) {
			return true;
		}
		return false;
	};
	$pkg.IsLatin = IsLatin;
	IsGreek = function(r) {
		var r;
		if (880 <= r && r <= 1023) {
			return true;
		}
		if (7424 <= r && r <= 7615) {
			return true;
		}
		if (7936 <= r && r <= 8191) {
			return true;
		}
		if (43824 <= r && r <= 43887) {
			return true;
		}
		return false;
	};
	$pkg.IsGreek = IsGreek;
	IsCyrillic = function(r) {
		var r;
		if (1024 <= r && r <= 1327) {
			return true;
		}
		if (7296 <= r && r <= 7311) {
			return true;
		}
		if (7424 <= r && r <= 7551) {
			return true;
		}
		if (11744 <= r && r <= 11775) {
			return true;
		}
		if (42560 <= r && r <= 42655) {
			return true;
		}
		if (65056 <= r && r <= 65071) {
			return true;
		}
		return false;
	};
	$pkg.IsCyrillic = IsCyrillic;
	IsArmenian = function(r) {
		var r;
		if (1328 <= r && r <= 1423) {
			return true;
		}
		if (64256 <= r && r <= 64335) {
			return true;
		}
		return false;
	};
	$pkg.IsArmenian = IsArmenian;
	IsGeorgian = function(r) {
		var r;
		if (4256 <= r && r <= 4351) {
			return true;
		}
		if (7312 <= r && r <= 7359) {
			return true;
		}
		if (11520 <= r && r <= 11567) {
			return true;
		}
		return false;
	};
	$pkg.IsGeorgian = IsGeorgian;
	IsOgham = function(r) {
		var r;
		if (5760 <= r && r <= 5791) {
			return true;
		}
		return false;
	};
	$pkg.IsOgham = IsOgham;
	IsRunic = function(r) {
		var r;
		if (5792 <= r && r <= 5887) {
			return true;
		}
		return false;
	};
	$pkg.IsRunic = IsRunic;
	IsEuropian = function(r) {
		var r;
		if (IsLatin(r)) {
			return true;
		}
		if (IsGreek(r)) {
			return true;
		}
		if (IsCyrillic(r)) {
			return true;
		}
		if (IsArmenian(r)) {
			return true;
		}
		if (IsGeorgian(r)) {
			return true;
		}
		if (IsOgham(r)) {
			return true;
		}
		if (IsRunic(r)) {
			return true;
		}
		if (768 <= r && r <= 879) {
			return true;
		}
		if (8192 <= r && r <= 8303) {
			return true;
		}
		if (8352 <= r && r <= 8399) {
			return true;
		}
		if (8400 <= r && r <= 8447) {
			return true;
		}
		if (11776 <= r && r <= 11903) {
			return true;
		}
		return false;
	};
	$pkg.IsEuropian = IsEuropian;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["golang.org/x/image/math/fixed"] = (function() {
	var $pkg = {}, $init, fmt, Int26_6, Point26_6, Rectangle26_6, sliceType, I;
	fmt = $packages["fmt"];
	Int26_6 = $pkg.Int26_6 = $newType(4, $kindInt32, "fixed.Int26_6", true, "golang.org/x/image/math/fixed", true, null);
	Point26_6 = $pkg.Point26_6 = $newType(0, $kindStruct, "fixed.Point26_6", true, "golang.org/x/image/math/fixed", true, function(X_, Y_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.X = 0;
			this.Y = 0;
			return;
		}
		this.X = X_;
		this.Y = Y_;
	});
	Rectangle26_6 = $pkg.Rectangle26_6 = $newType(0, $kindStruct, "fixed.Rectangle26_6", true, "golang.org/x/image/math/fixed", true, function(Min_, Max_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Min = new Point26_6.ptr(0, 0);
			this.Max = new Point26_6.ptr(0, 0);
			return;
		}
		this.Min = Min_;
		this.Max = Max_;
	});
	sliceType = $sliceType($emptyInterface);
	I = function(i) {
		var i;
		return (((i << 6 >> 0) >> 0));
	};
	$pkg.I = I;
	Int26_6.prototype.String = function() {
		var _r, _r$1, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = this.$val;
		/* */ if (x >= 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (x >= 0) { */ case 1:
			_r = fmt.Sprintf("%d:%02d", new sliceType([new $Int32((((x >> 6 >> 0) >> 0))), new $Int32((((x & 63) >> 0)))])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		x = -x;
		/* */ if (x >= 0) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (x >= 0) { */ case 4:
			_r$1 = fmt.Sprintf("-%d:%02d", new sliceType([new $Int32((((x >> 6 >> 0) >> 0))), new $Int32((((x & 63) >> 0)))])); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
		/* } */ case 5:
		$s = -1; return "-33554432:00";
		/* */ } return; } if ($f === undefined) { $f = { $blk: Int26_6.prototype.String }; } $f._r = _r; $f._r$1 = _r$1; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(Int26_6).prototype.String = function() { return new Int26_6(this.$get()).String(); };
	Int26_6.prototype.Floor = function() {
		var x;
		x = this.$val;
		return (((((x + 0 >> 0)) >> 6 >> 0) >> 0));
	};
	$ptrType(Int26_6).prototype.Floor = function() { return new Int26_6(this.$get()).Floor(); };
	Int26_6.prototype.Round = function() {
		var x;
		x = this.$val;
		return (((((x + 32 >> 0)) >> 6 >> 0) >> 0));
	};
	$ptrType(Int26_6).prototype.Round = function() { return new Int26_6(this.$get()).Round(); };
	Int26_6.prototype.Ceil = function() {
		var x;
		x = this.$val;
		return (((((x + 63 >> 0)) >> 6 >> 0) >> 0));
	};
	$ptrType(Int26_6).prototype.Ceil = function() { return new Int26_6(this.$get()).Ceil(); };
	Int26_6.prototype.Mul = function(y) {
		var x, x$1, x$2, y;
		x = this.$val;
		return (((x$1 = $shiftRightInt64(((x$2 = $mul64((new $Int64(0, x)), (new $Int64(0, y))), new $Int64(x$2.$high + 0, x$2.$low + 32))), 6), x$1.$low + ((x$1.$high >> 31) * 4294967296)) >> 0));
	};
	$ptrType(Int26_6).prototype.Mul = function(y) { return new Int26_6(this.$get()).Mul(y); };
	Point26_6.ptr.prototype.Add = function(q) {
		var p, q;
		p = this;
		return new Point26_6.ptr(p.X + q.X >> 0, p.Y + q.Y >> 0);
	};
	Point26_6.prototype.Add = function(q) { return this.$val.Add(q); };
	Point26_6.ptr.prototype.Sub = function(q) {
		var p, q;
		p = this;
		return new Point26_6.ptr(p.X - q.X >> 0, p.Y - q.Y >> 0);
	};
	Point26_6.prototype.Sub = function(q) { return this.$val.Sub(q); };
	Point26_6.ptr.prototype.Mul = function(k) {
		var _q, _q$1, k, p;
		p = this;
		return new Point26_6.ptr((_q = ($imul(p.X, k)) / 64, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")), (_q$1 = ($imul(p.Y, k)) / 64, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")));
	};
	Point26_6.prototype.Mul = function(k) { return this.$val.Mul(k); };
	Point26_6.ptr.prototype.Div = function(k) {
		var _q, _q$1, k, p;
		p = this;
		return new Point26_6.ptr((_q = ($imul(p.X, 64)) / k, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")), (_q$1 = ($imul(p.Y, 64)) / k, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")));
	};
	Point26_6.prototype.Div = function(k) { return this.$val.Div(k); };
	Point26_6.ptr.prototype.In = function(r) {
		var p, r;
		p = this;
		return r.Min.X <= p.X && p.X < r.Max.X && r.Min.Y <= p.Y && p.Y < r.Max.Y;
	};
	Point26_6.prototype.In = function(r) { return this.$val.In(r); };
	Rectangle26_6.ptr.prototype.Add = function(p) {
		var p, r;
		r = this;
		return new Rectangle26_6.ptr(new Point26_6.ptr(r.Min.X + p.X >> 0, r.Min.Y + p.Y >> 0), new Point26_6.ptr(r.Max.X + p.X >> 0, r.Max.Y + p.Y >> 0));
	};
	Rectangle26_6.prototype.Add = function(p) { return this.$val.Add(p); };
	Rectangle26_6.ptr.prototype.Sub = function(p) {
		var p, r;
		r = this;
		return new Rectangle26_6.ptr(new Point26_6.ptr(r.Min.X - p.X >> 0, r.Min.Y - p.Y >> 0), new Point26_6.ptr(r.Max.X - p.X >> 0, r.Max.Y - p.Y >> 0));
	};
	Rectangle26_6.prototype.Sub = function(p) { return this.$val.Sub(p); };
	Rectangle26_6.ptr.prototype.Intersect = function(s) {
		var r, s;
		r = this;
		if (r.Min.X < s.Min.X) {
			r.Min.X = s.Min.X;
		}
		if (r.Min.Y < s.Min.Y) {
			r.Min.Y = s.Min.Y;
		}
		if (r.Max.X > s.Max.X) {
			r.Max.X = s.Max.X;
		}
		if (r.Max.Y > s.Max.Y) {
			r.Max.Y = s.Max.Y;
		}
		if ($clone(r, Rectangle26_6).Empty()) {
			return new Rectangle26_6.ptr(new Point26_6.ptr(0, 0), new Point26_6.ptr(0, 0));
		}
		return r;
	};
	Rectangle26_6.prototype.Intersect = function(s) { return this.$val.Intersect(s); };
	Rectangle26_6.ptr.prototype.Union = function(s) {
		var r, s;
		r = this;
		if ($clone(r, Rectangle26_6).Empty()) {
			return s;
		}
		if ($clone(s, Rectangle26_6).Empty()) {
			return r;
		}
		if (r.Min.X > s.Min.X) {
			r.Min.X = s.Min.X;
		}
		if (r.Min.Y > s.Min.Y) {
			r.Min.Y = s.Min.Y;
		}
		if (r.Max.X < s.Max.X) {
			r.Max.X = s.Max.X;
		}
		if (r.Max.Y < s.Max.Y) {
			r.Max.Y = s.Max.Y;
		}
		return r;
	};
	Rectangle26_6.prototype.Union = function(s) { return this.$val.Union(s); };
	Rectangle26_6.ptr.prototype.Empty = function() {
		var r;
		r = this;
		return r.Min.X >= r.Max.X || r.Min.Y >= r.Max.Y;
	};
	Rectangle26_6.prototype.Empty = function() { return this.$val.Empty(); };
	Rectangle26_6.ptr.prototype.In = function(s) {
		var r, s;
		r = this;
		if ($clone(r, Rectangle26_6).Empty()) {
			return true;
		}
		return s.Min.X <= r.Min.X && r.Max.X <= s.Max.X && s.Min.Y <= r.Min.Y && r.Max.Y <= s.Max.Y;
	};
	Rectangle26_6.prototype.In = function(s) { return this.$val.In(s); };
	Int26_6.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Floor", name: "Floor", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Round", name: "Round", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Ceil", name: "Ceil", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Mul", name: "Mul", pkg: "", typ: $funcType([Int26_6], [Int26_6], false)}];
	Point26_6.methods = [{prop: "Add", name: "Add", pkg: "", typ: $funcType([Point26_6], [Point26_6], false)}, {prop: "Sub", name: "Sub", pkg: "", typ: $funcType([Point26_6], [Point26_6], false)}, {prop: "Mul", name: "Mul", pkg: "", typ: $funcType([Int26_6], [Point26_6], false)}, {prop: "Div", name: "Div", pkg: "", typ: $funcType([Int26_6], [Point26_6], false)}, {prop: "In", name: "In", pkg: "", typ: $funcType([Rectangle26_6], [$Bool], false)}];
	Rectangle26_6.methods = [{prop: "Add", name: "Add", pkg: "", typ: $funcType([Point26_6], [Rectangle26_6], false)}, {prop: "Sub", name: "Sub", pkg: "", typ: $funcType([Point26_6], [Rectangle26_6], false)}, {prop: "Intersect", name: "Intersect", pkg: "", typ: $funcType([Rectangle26_6], [Rectangle26_6], false)}, {prop: "Union", name: "Union", pkg: "", typ: $funcType([Rectangle26_6], [Rectangle26_6], false)}, {prop: "Empty", name: "Empty", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "In", name: "In", pkg: "", typ: $funcType([Rectangle26_6], [$Bool], false)}];
	Point26_6.init("", [{prop: "X", name: "X", embedded: false, exported: true, typ: Int26_6, tag: ""}, {prop: "Y", name: "Y", embedded: false, exported: true, typ: Int26_6, tag: ""}]);
	Rectangle26_6.init("", [{prop: "Min", name: "Min", embedded: false, exported: true, typ: Point26_6, tag: ""}, {prop: "Max", name: "Max", embedded: false, exported: true, typ: Point26_6, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = fmt.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["image/color"] = (function() {
	var $pkg = {}, $init, Color, RGBA, RGBA64, NRGBA, NRGBA64, Alpha, Alpha16, Gray, Gray16, Model, modelFunc, Palette, YCbCr, NYCbCrA, CMYK, ptrType, funcType, ModelFunc, rgbaModel, rgba64Model, nrgbaModel, nrgba64Model, alphaModel, alpha16Model, grayModel, gray16Model, sqDiff, RGBToYCbCr, yCbCrModel, nYCbCrAModel, RGBToCMYK, CMYKToRGB, cmykModel;
	Color = $pkg.Color = $newType(8, $kindInterface, "color.Color", true, "image/color", true, null);
	RGBA = $pkg.RGBA = $newType(0, $kindStruct, "color.RGBA", true, "image/color", true, function(R_, G_, B_, A_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.R = 0;
			this.G = 0;
			this.B = 0;
			this.A = 0;
			return;
		}
		this.R = R_;
		this.G = G_;
		this.B = B_;
		this.A = A_;
	});
	RGBA64 = $pkg.RGBA64 = $newType(0, $kindStruct, "color.RGBA64", true, "image/color", true, function(R_, G_, B_, A_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.R = 0;
			this.G = 0;
			this.B = 0;
			this.A = 0;
			return;
		}
		this.R = R_;
		this.G = G_;
		this.B = B_;
		this.A = A_;
	});
	NRGBA = $pkg.NRGBA = $newType(0, $kindStruct, "color.NRGBA", true, "image/color", true, function(R_, G_, B_, A_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.R = 0;
			this.G = 0;
			this.B = 0;
			this.A = 0;
			return;
		}
		this.R = R_;
		this.G = G_;
		this.B = B_;
		this.A = A_;
	});
	NRGBA64 = $pkg.NRGBA64 = $newType(0, $kindStruct, "color.NRGBA64", true, "image/color", true, function(R_, G_, B_, A_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.R = 0;
			this.G = 0;
			this.B = 0;
			this.A = 0;
			return;
		}
		this.R = R_;
		this.G = G_;
		this.B = B_;
		this.A = A_;
	});
	Alpha = $pkg.Alpha = $newType(0, $kindStruct, "color.Alpha", true, "image/color", true, function(A_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.A = 0;
			return;
		}
		this.A = A_;
	});
	Alpha16 = $pkg.Alpha16 = $newType(0, $kindStruct, "color.Alpha16", true, "image/color", true, function(A_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.A = 0;
			return;
		}
		this.A = A_;
	});
	Gray = $pkg.Gray = $newType(0, $kindStruct, "color.Gray", true, "image/color", true, function(Y_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Y = 0;
			return;
		}
		this.Y = Y_;
	});
	Gray16 = $pkg.Gray16 = $newType(0, $kindStruct, "color.Gray16", true, "image/color", true, function(Y_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Y = 0;
			return;
		}
		this.Y = Y_;
	});
	Model = $pkg.Model = $newType(8, $kindInterface, "color.Model", true, "image/color", true, null);
	modelFunc = $pkg.modelFunc = $newType(0, $kindStruct, "color.modelFunc", true, "image/color", false, function(f_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.f = $throwNilPointerError;
			return;
		}
		this.f = f_;
	});
	Palette = $pkg.Palette = $newType(12, $kindSlice, "color.Palette", true, "image/color", true, null);
	YCbCr = $pkg.YCbCr = $newType(0, $kindStruct, "color.YCbCr", true, "image/color", true, function(Y_, Cb_, Cr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Y = 0;
			this.Cb = 0;
			this.Cr = 0;
			return;
		}
		this.Y = Y_;
		this.Cb = Cb_;
		this.Cr = Cr_;
	});
	NYCbCrA = $pkg.NYCbCrA = $newType(0, $kindStruct, "color.NYCbCrA", true, "image/color", true, function(YCbCr_, A_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.YCbCr = new YCbCr.ptr(0, 0, 0);
			this.A = 0;
			return;
		}
		this.YCbCr = YCbCr_;
		this.A = A_;
	});
	CMYK = $pkg.CMYK = $newType(0, $kindStruct, "color.CMYK", true, "image/color", true, function(C_, M_, Y_, K_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.C = 0;
			this.M = 0;
			this.Y = 0;
			this.K = 0;
			return;
		}
		this.C = C_;
		this.M = M_;
		this.Y = Y_;
		this.K = K_;
	});
	ptrType = $ptrType(modelFunc);
	funcType = $funcType([Color], [Color], false);
	RGBA.ptr.prototype.RGBA = function() {
		var a, b, c, g, r;
		r = 0;
		g = 0;
		b = 0;
		a = 0;
		c = this;
		r = ((c.R >>> 0));
		r = (r | ((r << 8 >>> 0))) >>> 0;
		g = ((c.G >>> 0));
		g = (g | ((g << 8 >>> 0))) >>> 0;
		b = ((c.B >>> 0));
		b = (b | ((b << 8 >>> 0))) >>> 0;
		a = ((c.A >>> 0));
		a = (a | ((a << 8 >>> 0))) >>> 0;
		return [r, g, b, a];
	};
	RGBA.prototype.RGBA = function() { return this.$val.RGBA(); };
	RGBA64.ptr.prototype.RGBA = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, a, b, c, g, r;
		r = 0;
		g = 0;
		b = 0;
		a = 0;
		c = this;
		_tmp = ((c.R >>> 0));
		_tmp$1 = ((c.G >>> 0));
		_tmp$2 = ((c.B >>> 0));
		_tmp$3 = ((c.A >>> 0));
		r = _tmp;
		g = _tmp$1;
		b = _tmp$2;
		a = _tmp$3;
		return [r, g, b, a];
	};
	RGBA64.prototype.RGBA = function() { return this.$val.RGBA(); };
	NRGBA.ptr.prototype.RGBA = function() {
		var _q, _q$1, _q$2, a, b, c, g, r;
		r = 0;
		g = 0;
		b = 0;
		a = 0;
		c = this;
		r = ((c.R >>> 0));
		r = (r | ((r << 8 >>> 0))) >>> 0;
		r = $imul(r, (((c.A >>> 0)))) >>> 0;
		r = (_q = r / (255), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		g = ((c.G >>> 0));
		g = (g | ((g << 8 >>> 0))) >>> 0;
		g = $imul(g, (((c.A >>> 0)))) >>> 0;
		g = (_q$1 = g / (255), (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
		b = ((c.B >>> 0));
		b = (b | ((b << 8 >>> 0))) >>> 0;
		b = $imul(b, (((c.A >>> 0)))) >>> 0;
		b = (_q$2 = b / (255), (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero"));
		a = ((c.A >>> 0));
		a = (a | ((a << 8 >>> 0))) >>> 0;
		return [r, g, b, a];
	};
	NRGBA.prototype.RGBA = function() { return this.$val.RGBA(); };
	NRGBA64.ptr.prototype.RGBA = function() {
		var _q, _q$1, _q$2, a, b, c, g, r;
		r = 0;
		g = 0;
		b = 0;
		a = 0;
		c = this;
		r = ((c.R >>> 0));
		r = $imul(r, (((c.A >>> 0)))) >>> 0;
		r = (_q = r / (65535), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		g = ((c.G >>> 0));
		g = $imul(g, (((c.A >>> 0)))) >>> 0;
		g = (_q$1 = g / (65535), (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
		b = ((c.B >>> 0));
		b = $imul(b, (((c.A >>> 0)))) >>> 0;
		b = (_q$2 = b / (65535), (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero"));
		a = ((c.A >>> 0));
		return [r, g, b, a];
	};
	NRGBA64.prototype.RGBA = function() { return this.$val.RGBA(); };
	Alpha.ptr.prototype.RGBA = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, a, b, c, g, r;
		r = 0;
		g = 0;
		b = 0;
		a = 0;
		c = this;
		a = ((c.A >>> 0));
		a = (a | ((a << 8 >>> 0))) >>> 0;
		_tmp = a;
		_tmp$1 = a;
		_tmp$2 = a;
		_tmp$3 = a;
		r = _tmp;
		g = _tmp$1;
		b = _tmp$2;
		a = _tmp$3;
		return [r, g, b, a];
	};
	Alpha.prototype.RGBA = function() { return this.$val.RGBA(); };
	Alpha16.ptr.prototype.RGBA = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, a, b, c, g, r;
		r = 0;
		g = 0;
		b = 0;
		a = 0;
		c = this;
		a = ((c.A >>> 0));
		_tmp = a;
		_tmp$1 = a;
		_tmp$2 = a;
		_tmp$3 = a;
		r = _tmp;
		g = _tmp$1;
		b = _tmp$2;
		a = _tmp$3;
		return [r, g, b, a];
	};
	Alpha16.prototype.RGBA = function() { return this.$val.RGBA(); };
	Gray.ptr.prototype.RGBA = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, a, b, c, g, r, y;
		r = 0;
		g = 0;
		b = 0;
		a = 0;
		c = this;
		y = ((c.Y >>> 0));
		y = (y | ((y << 8 >>> 0))) >>> 0;
		_tmp = y;
		_tmp$1 = y;
		_tmp$2 = y;
		_tmp$3 = 65535;
		r = _tmp;
		g = _tmp$1;
		b = _tmp$2;
		a = _tmp$3;
		return [r, g, b, a];
	};
	Gray.prototype.RGBA = function() { return this.$val.RGBA(); };
	Gray16.ptr.prototype.RGBA = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, a, b, c, g, r, y;
		r = 0;
		g = 0;
		b = 0;
		a = 0;
		c = this;
		y = ((c.Y >>> 0));
		_tmp = y;
		_tmp$1 = y;
		_tmp$2 = y;
		_tmp$3 = 65535;
		r = _tmp;
		g = _tmp$1;
		b = _tmp$2;
		a = _tmp$3;
		return [r, g, b, a];
	};
	Gray16.prototype.RGBA = function() { return this.$val.RGBA(); };
	ModelFunc = function(f) {
		var f;
		return new modelFunc.ptr(f);
	};
	$pkg.ModelFunc = ModelFunc;
	modelFunc.ptr.prototype.Convert = function(c) {
		var _r, c, m, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; m = $f.m; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		_r = m.f(c); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: modelFunc.ptr.prototype.Convert }; } $f._r = _r; $f.c = c; $f.m = m; $f.$s = $s; $f.$r = $r; return $f;
	};
	modelFunc.prototype.Convert = function(c) { return this.$val.Convert(c); };
	rgbaModel = function(c) {
		var _r, _tuple, _tuple$1, a, b, c, g, ok, r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; b = $f.b; c = $f.c; g = $f.g; ok = $f.ok; r = $f.r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(c, RGBA, true);
		ok = _tuple[1];
		if (ok) {
			$s = -1; return c;
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		r = _tuple$1[0];
		g = _tuple$1[1];
		b = _tuple$1[2];
		a = _tuple$1[3];
		$s = -1; return (x = new RGBA.ptr((((r >>> 8 >>> 0) << 24 >>> 24)), (((g >>> 8 >>> 0) << 24 >>> 24)), (((b >>> 8 >>> 0) << 24 >>> 24)), (((a >>> 8 >>> 0) << 24 >>> 24))), new x.constructor.elem(x));
		/* */ } return; } if ($f === undefined) { $f = { $blk: rgbaModel }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.b = b; $f.c = c; $f.g = g; $f.ok = ok; $f.r = r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	rgba64Model = function(c) {
		var _r, _tuple, _tuple$1, a, b, c, g, ok, r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; b = $f.b; c = $f.c; g = $f.g; ok = $f.ok; r = $f.r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(c, RGBA64, true);
		ok = _tuple[1];
		if (ok) {
			$s = -1; return c;
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		r = _tuple$1[0];
		g = _tuple$1[1];
		b = _tuple$1[2];
		a = _tuple$1[3];
		$s = -1; return (x = new RGBA64.ptr(((r << 16 >>> 16)), ((g << 16 >>> 16)), ((b << 16 >>> 16)), ((a << 16 >>> 16))), new x.constructor.elem(x));
		/* */ } return; } if ($f === undefined) { $f = { $blk: rgba64Model }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.b = b; $f.c = c; $f.g = g; $f.ok = ok; $f.r = r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	nrgbaModel = function(c) {
		var _q, _q$1, _q$2, _r, _tuple, _tuple$1, a, b, c, g, ok, r, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; b = $f.b; c = $f.c; g = $f.g; ok = $f.ok; r = $f.r; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(c, NRGBA, true);
		ok = _tuple[1];
		if (ok) {
			$s = -1; return c;
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		r = _tuple$1[0];
		g = _tuple$1[1];
		b = _tuple$1[2];
		a = _tuple$1[3];
		if (a === 65535) {
			$s = -1; return (x = new NRGBA.ptr((((r >>> 8 >>> 0) << 24 >>> 24)), (((g >>> 8 >>> 0) << 24 >>> 24)), (((b >>> 8 >>> 0) << 24 >>> 24)), 255), new x.constructor.elem(x));
		}
		if (a === 0) {
			$s = -1; return (x$1 = new NRGBA.ptr(0, 0, 0, 0), new x$1.constructor.elem(x$1));
		}
		r = (_q = (($imul(r, 65535) >>> 0)) / a, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		g = (_q$1 = (($imul(g, 65535) >>> 0)) / a, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
		b = (_q$2 = (($imul(b, 65535) >>> 0)) / a, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero"));
		$s = -1; return (x$2 = new NRGBA.ptr((((r >>> 8 >>> 0) << 24 >>> 24)), (((g >>> 8 >>> 0) << 24 >>> 24)), (((b >>> 8 >>> 0) << 24 >>> 24)), (((a >>> 8 >>> 0) << 24 >>> 24))), new x$2.constructor.elem(x$2));
		/* */ } return; } if ($f === undefined) { $f = { $blk: nrgbaModel }; } $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.b = b; $f.c = c; $f.g = g; $f.ok = ok; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	nrgba64Model = function(c) {
		var _q, _q$1, _q$2, _r, _tuple, _tuple$1, a, b, c, g, ok, r, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; b = $f.b; c = $f.c; g = $f.g; ok = $f.ok; r = $f.r; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(c, NRGBA64, true);
		ok = _tuple[1];
		if (ok) {
			$s = -1; return c;
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		r = _tuple$1[0];
		g = _tuple$1[1];
		b = _tuple$1[2];
		a = _tuple$1[3];
		if (a === 65535) {
			$s = -1; return (x = new NRGBA64.ptr(((r << 16 >>> 16)), ((g << 16 >>> 16)), ((b << 16 >>> 16)), 65535), new x.constructor.elem(x));
		}
		if (a === 0) {
			$s = -1; return (x$1 = new NRGBA64.ptr(0, 0, 0, 0), new x$1.constructor.elem(x$1));
		}
		r = (_q = (($imul(r, 65535) >>> 0)) / a, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		g = (_q$1 = (($imul(g, 65535) >>> 0)) / a, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
		b = (_q$2 = (($imul(b, 65535) >>> 0)) / a, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero"));
		$s = -1; return (x$2 = new NRGBA64.ptr(((r << 16 >>> 16)), ((g << 16 >>> 16)), ((b << 16 >>> 16)), ((a << 16 >>> 16))), new x$2.constructor.elem(x$2));
		/* */ } return; } if ($f === undefined) { $f = { $blk: nrgba64Model }; } $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.b = b; $f.c = c; $f.g = g; $f.ok = ok; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	alphaModel = function(c) {
		var _r, _tuple, _tuple$1, a, c, ok, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; c = $f.c; ok = $f.ok; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(c, Alpha, true);
		ok = _tuple[1];
		if (ok) {
			$s = -1; return c;
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		a = _tuple$1[3];
		$s = -1; return (x = new Alpha.ptr((((a >>> 8 >>> 0) << 24 >>> 24))), new x.constructor.elem(x));
		/* */ } return; } if ($f === undefined) { $f = { $blk: alphaModel }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.c = c; $f.ok = ok; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	alpha16Model = function(c) {
		var _r, _tuple, _tuple$1, a, c, ok, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; c = $f.c; ok = $f.ok; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(c, Alpha16, true);
		ok = _tuple[1];
		if (ok) {
			$s = -1; return c;
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		a = _tuple$1[3];
		$s = -1; return (x = new Alpha16.ptr(((a << 16 >>> 16))), new x.constructor.elem(x));
		/* */ } return; } if ($f === undefined) { $f = { $blk: alpha16Model }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.c = c; $f.ok = ok; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	grayModel = function(c) {
		var _r, _tuple, _tuple$1, b, c, g, ok, r, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; b = $f.b; c = $f.c; g = $f.g; ok = $f.ok; r = $f.r; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(c, Gray, true);
		ok = _tuple[1];
		if (ok) {
			$s = -1; return c;
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		r = _tuple$1[0];
		g = _tuple$1[1];
		b = _tuple$1[2];
		y = ((((($imul(19595, r) >>> 0) + ($imul(38470, g) >>> 0) >>> 0) + ($imul(7471, b) >>> 0) >>> 0) + 32768 >>> 0)) >>> 24 >>> 0;
		$s = -1; return (x = new Gray.ptr(((y << 24 >>> 24))), new x.constructor.elem(x));
		/* */ } return; } if ($f === undefined) { $f = { $blk: grayModel }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.b = b; $f.c = c; $f.g = g; $f.ok = ok; $f.r = r; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	gray16Model = function(c) {
		var _r, _tuple, _tuple$1, b, c, g, ok, r, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; b = $f.b; c = $f.c; g = $f.g; ok = $f.ok; r = $f.r; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(c, Gray16, true);
		ok = _tuple[1];
		if (ok) {
			$s = -1; return c;
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		r = _tuple$1[0];
		g = _tuple$1[1];
		b = _tuple$1[2];
		y = ((((($imul(19595, r) >>> 0) + ($imul(38470, g) >>> 0) >>> 0) + ($imul(7471, b) >>> 0) >>> 0) + 32768 >>> 0)) >>> 16 >>> 0;
		$s = -1; return (x = new Gray16.ptr(((y << 16 >>> 16))), new x.constructor.elem(x));
		/* */ } return; } if ($f === undefined) { $f = { $blk: gray16Model }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.b = b; $f.c = c; $f.g = g; $f.ok = ok; $f.r = r; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Palette.prototype.Convert = function(c) {
		var _r, c, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (p.$length === 0) {
			$s = -1; return $ifaceNil;
		}
		_r = p.Index(c); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (x = _r, ((x < 0 || x >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x]));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Palette.prototype.Convert }; } $f._r = _r; $f.c = c; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(Palette).prototype.Convert = function(c) { return this.$get().Convert(c); };
	Palette.prototype.Index = function(c) {
		var _i, _r, _r$1, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _tuple$1, bestSum, c, ca, cb, cg, cr, i, p, ret, sum, v, va, vb, vg, vr, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; bestSum = $f.bestSum; c = $f.c; ca = $f.ca; cb = $f.cb; cg = $f.cg; cr = $f.cr; i = $f.i; p = $f.p; ret = $f.ret; sum = $f.sum; v = $f.v; va = $f.va; vb = $f.vb; vg = $f.vg; vr = $f.vr; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		cr = _tuple[0];
		cg = _tuple[1];
		cb = _tuple[2];
		ca = _tuple[3];
		_tmp = 0;
		_tmp$1 = 4294967295;
		ret = _tmp;
		bestSum = _tmp$1;
		_ref = p;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			i = _i;
			v = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r$1 = v.RGBA(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			vr = _tuple$1[0];
			vg = _tuple$1[1];
			vb = _tuple$1[2];
			va = _tuple$1[3];
			sum = ((sqDiff(cr, vr) + sqDiff(cg, vg) >>> 0) + sqDiff(cb, vb) >>> 0) + sqDiff(ca, va) >>> 0;
			if (sum < bestSum) {
				if (sum === 0) {
					$s = -1; return i;
				}
				_tmp$2 = i;
				_tmp$3 = sum;
				ret = _tmp$2;
				bestSum = _tmp$3;
			}
			_i++;
		/* } */ $s = 2; continue; case 3:
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Palette.prototype.Index }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.bestSum = bestSum; $f.c = c; $f.ca = ca; $f.cb = cb; $f.cg = cg; $f.cr = cr; $f.i = i; $f.p = p; $f.ret = ret; $f.sum = sum; $f.v = v; $f.va = va; $f.vb = vb; $f.vg = vg; $f.vr = vr; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(Palette).prototype.Index = function(c) { return this.$get().Index(c); };
	sqDiff = function(x, y) {
		var d, x, y;
		d = x - y >>> 0;
		return (($imul(d, d) >>> 0)) >>> 2 >>> 0;
	};
	RGBToYCbCr = function(r, g, b) {
		var b, b1, cb, cr, g, g1, r, r1, yy;
		r1 = ((r >> 0));
		g1 = ((g >> 0));
		b1 = ((b >> 0));
		yy = ((((($imul(19595, r1)) + ($imul(38470, g1)) >> 0) + ($imul(7471, b1)) >> 0) + 32768 >> 0)) >> 16 >> 0;
		cb = ((($imul(-11056, r1)) - ($imul(21712, g1)) >> 0) + ($imul(32768, b1)) >> 0) + 8421376 >> 0;
		if (((((cb >>> 0)) & 4278190080) >>> 0) === 0) {
			cb = (cb >> $min((16), 31)) >> 0;
		} else {
			cb = ~((cb >> 31 >> 0)) >> 0;
		}
		cr = ((($imul(32768, r1)) - ($imul(27440, g1)) >> 0) - ($imul(5328, b1)) >> 0) + 8421376 >> 0;
		if (((((cr >>> 0)) & 4278190080) >>> 0) === 0) {
			cr = (cr >> $min((16), 31)) >> 0;
		} else {
			cr = ~((cr >> 31 >> 0)) >> 0;
		}
		return [((yy << 24 >>> 24)), ((cb << 24 >>> 24)), ((cr << 24 >>> 24))];
	};
	$pkg.RGBToYCbCr = RGBToYCbCr;
	YCbCr.ptr.prototype.RGBA = function() {
		var b, c, cb1, cr1, g, r, yy1;
		c = this;
		yy1 = $imul(((c.Y >> 0)), 65793);
		cb1 = ((c.Cb >> 0)) - 128 >> 0;
		cr1 = ((c.Cr >> 0)) - 128 >> 0;
		r = yy1 + ($imul(91881, cr1)) >> 0;
		if (((((r >>> 0)) & 4278190080) >>> 0) === 0) {
			r = (r >> $min((8), 31)) >> 0;
		} else {
			r = (~((r >> 31 >> 0)) >> 0) & 65535;
		}
		g = (yy1 - ($imul(22554, cb1)) >> 0) - ($imul(46802, cr1)) >> 0;
		if (((((g >>> 0)) & 4278190080) >>> 0) === 0) {
			g = (g >> $min((8), 31)) >> 0;
		} else {
			g = (~((g >> 31 >> 0)) >> 0) & 65535;
		}
		b = yy1 + ($imul(116130, cb1)) >> 0;
		if (((((b >>> 0)) & 4278190080) >>> 0) === 0) {
			b = (b >> $min((8), 31)) >> 0;
		} else {
			b = (~((b >> 31 >> 0)) >> 0) & 65535;
		}
		return [((r >>> 0)), ((g >>> 0)), ((b >>> 0)), 65535];
	};
	YCbCr.prototype.RGBA = function() { return this.$val.RGBA(); };
	yCbCrModel = function(c) {
		var _r, _tuple, _tuple$1, _tuple$2, b, c, g, ok, r, u, v, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; b = $f.b; c = $f.c; g = $f.g; ok = $f.ok; r = $f.r; u = $f.u; v = $f.v; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(c, YCbCr, true);
		ok = _tuple[1];
		if (ok) {
			$s = -1; return c;
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		r = _tuple$1[0];
		g = _tuple$1[1];
		b = _tuple$1[2];
		_tuple$2 = RGBToYCbCr((((r >>> 8 >>> 0) << 24 >>> 24)), (((g >>> 8 >>> 0) << 24 >>> 24)), (((b >>> 8 >>> 0) << 24 >>> 24)));
		y = _tuple$2[0];
		u = _tuple$2[1];
		v = _tuple$2[2];
		$s = -1; return (x = new YCbCr.ptr(y, u, v), new x.constructor.elem(x));
		/* */ } return; } if ($f === undefined) { $f = { $blk: yCbCrModel }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.b = b; $f.c = c; $f.g = g; $f.ok = ok; $f.r = r; $f.u = u; $f.v = v; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	NYCbCrA.ptr.prototype.RGBA = function() {
		var _q, _q$1, _q$2, a, b, c, cb1, cr1, g, r, yy1;
		c = this;
		yy1 = $imul(((c.YCbCr.Y >> 0)), 65793);
		cb1 = ((c.YCbCr.Cb >> 0)) - 128 >> 0;
		cr1 = ((c.YCbCr.Cr >> 0)) - 128 >> 0;
		r = yy1 + ($imul(91881, cr1)) >> 0;
		if (((((r >>> 0)) & 4278190080) >>> 0) === 0) {
			r = (r >> $min((8), 31)) >> 0;
		} else {
			r = (~((r >> 31 >> 0)) >> 0) & 65535;
		}
		g = (yy1 - ($imul(22554, cb1)) >> 0) - ($imul(46802, cr1)) >> 0;
		if (((((g >>> 0)) & 4278190080) >>> 0) === 0) {
			g = (g >> $min((8), 31)) >> 0;
		} else {
			g = (~((g >> 31 >> 0)) >> 0) & 65535;
		}
		b = yy1 + ($imul(116130, cb1)) >> 0;
		if (((((b >>> 0)) & 4278190080) >>> 0) === 0) {
			b = (b >> $min((8), 31)) >> 0;
		} else {
			b = (~((b >> 31 >> 0)) >> 0) & 65535;
		}
		a = $imul(((c.A >>> 0)), 257) >>> 0;
		return [(_q = ($imul(((r >>> 0)), a) >>> 0) / 65535, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero")), (_q$1 = ($imul(((g >>> 0)), a) >>> 0) / 65535, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero")), (_q$2 = ($imul(((b >>> 0)), a) >>> 0) / 65535, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero")), a];
	};
	NYCbCrA.prototype.RGBA = function() { return this.$val.RGBA(); };
	nYCbCrAModel = function(c) {
		var _q, _q$1, _q$2, _r, _ref, _tuple, _tuple$1, a, b, c, c$1, c$2, g, r, u, v, x, x$1, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _r = $f._r; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; b = $f.b; c = $f.c; c$1 = $f.c$1; c$2 = $f.c$2; g = $f.g; r = $f.r; u = $f.u; v = $f.v; x = $f.x; x$1 = $f.x$1; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_ref = c;
		if ($assertType(_ref, NYCbCrA, true)[1]) {
			c$1 = $clone(_ref.$val, NYCbCrA);
			$s = -1; return new c$1.constructor.elem(c$1);
		} else if ($assertType(_ref, YCbCr, true)[1]) {
			c$2 = $clone(_ref.$val, YCbCr);
			$s = -1; return (x = new NYCbCrA.ptr($clone(c$2, YCbCr), 255), new x.constructor.elem(x));
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		g = _tuple[1];
		b = _tuple[2];
		a = _tuple[3];
		if (!((a === 0))) {
			r = (_q = (($imul(r, 65535) >>> 0)) / a, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
			g = (_q$1 = (($imul(g, 65535) >>> 0)) / a, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
			b = (_q$2 = (($imul(b, 65535) >>> 0)) / a, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero"));
		}
		_tuple$1 = RGBToYCbCr((((r >>> 8 >>> 0) << 24 >>> 24)), (((g >>> 8 >>> 0) << 24 >>> 24)), (((b >>> 8 >>> 0) << 24 >>> 24)));
		y = _tuple$1[0];
		u = _tuple$1[1];
		v = _tuple$1[2];
		$s = -1; return (x$1 = new NYCbCrA.ptr(new YCbCr.ptr(y, u, v), (((a >>> 8 >>> 0) << 24 >>> 24))), new x$1.constructor.elem(x$1));
		/* */ } return; } if ($f === undefined) { $f = { $blk: nYCbCrAModel }; } $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._r = _r; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.b = b; $f.c = c; $f.c$1 = c$1; $f.c$2 = c$2; $f.g = g; $f.r = r; $f.u = u; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	RGBToCMYK = function(r, g, b) {
		var _q, _q$1, _q$2, b, bb, c, g, gg, m, r, rr, w, y;
		rr = ((r >>> 0));
		gg = ((g >>> 0));
		bb = ((b >>> 0));
		w = rr;
		if (w < gg) {
			w = gg;
		}
		if (w < bb) {
			w = bb;
		}
		if (w === 0) {
			return [0, 0, 0, 255];
		}
		c = (_q = ($imul(((w - rr >>> 0)), 255) >>> 0) / w, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		m = (_q$1 = ($imul(((w - gg >>> 0)), 255) >>> 0) / w, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
		y = (_q$2 = ($imul(((w - bb >>> 0)), 255) >>> 0) / w, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero"));
		return [((c << 24 >>> 24)), ((m << 24 >>> 24)), ((y << 24 >>> 24)), (((255 - w >>> 0) << 24 >>> 24))];
	};
	$pkg.RGBToCMYK = RGBToCMYK;
	CMYKToRGB = function(c, m, y, k) {
		var _q, _q$1, _q$2, b, c, g, k, m, r, w, y;
		w = 65535 - ($imul(((k >>> 0)), 257) >>> 0) >>> 0;
		r = (_q = ($imul(((65535 - ($imul(((c >>> 0)), 257) >>> 0) >>> 0)), w) >>> 0) / 65535, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		g = (_q$1 = ($imul(((65535 - ($imul(((m >>> 0)), 257) >>> 0) >>> 0)), w) >>> 0) / 65535, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
		b = (_q$2 = ($imul(((65535 - ($imul(((y >>> 0)), 257) >>> 0) >>> 0)), w) >>> 0) / 65535, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero"));
		return [(((r >>> 8 >>> 0) << 24 >>> 24)), (((g >>> 8 >>> 0) << 24 >>> 24)), (((b >>> 8 >>> 0) << 24 >>> 24))];
	};
	$pkg.CMYKToRGB = CMYKToRGB;
	CMYK.ptr.prototype.RGBA = function() {
		var _q, _q$1, _q$2, b, c, g, r, w;
		c = this;
		w = 65535 - ($imul(((c.K >>> 0)), 257) >>> 0) >>> 0;
		r = (_q = ($imul(((65535 - ($imul(((c.C >>> 0)), 257) >>> 0) >>> 0)), w) >>> 0) / 65535, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
		g = (_q$1 = ($imul(((65535 - ($imul(((c.M >>> 0)), 257) >>> 0) >>> 0)), w) >>> 0) / 65535, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
		b = (_q$2 = ($imul(((65535 - ($imul(((c.Y >>> 0)), 257) >>> 0) >>> 0)), w) >>> 0) / 65535, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero"));
		return [r, g, b, 65535];
	};
	CMYK.prototype.RGBA = function() { return this.$val.RGBA(); };
	cmykModel = function(c) {
		var _r, _tuple, _tuple$1, _tuple$2, b, c, cc, g, kk, mm, ok, r, x, yy, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; b = $f.b; c = $f.c; cc = $f.cc; g = $f.g; kk = $f.kk; mm = $f.mm; ok = $f.ok; r = $f.r; x = $f.x; yy = $f.yy; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(c, CMYK, true);
		ok = _tuple[1];
		if (ok) {
			$s = -1; return c;
		}
		_r = c.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		r = _tuple$1[0];
		g = _tuple$1[1];
		b = _tuple$1[2];
		_tuple$2 = RGBToCMYK((((r >>> 8 >>> 0) << 24 >>> 24)), (((g >>> 8 >>> 0) << 24 >>> 24)), (((b >>> 8 >>> 0) << 24 >>> 24)));
		cc = _tuple$2[0];
		mm = _tuple$2[1];
		yy = _tuple$2[2];
		kk = _tuple$2[3];
		$s = -1; return (x = new CMYK.ptr(cc, mm, yy, kk), new x.constructor.elem(x));
		/* */ } return; } if ($f === undefined) { $f = { $blk: cmykModel }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.b = b; $f.c = c; $f.cc = cc; $f.g = g; $f.kk = kk; $f.mm = mm; $f.ok = ok; $f.r = r; $f.x = x; $f.yy = yy; $f.$s = $s; $f.$r = $r; return $f;
	};
	RGBA.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	RGBA64.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	NRGBA.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	NRGBA64.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	Alpha.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	Alpha16.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	Gray.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	Gray16.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	ptrType.methods = [{prop: "Convert", name: "Convert", pkg: "", typ: $funcType([Color], [Color], false)}];
	Palette.methods = [{prop: "Convert", name: "Convert", pkg: "", typ: $funcType([Color], [Color], false)}, {prop: "Index", name: "Index", pkg: "", typ: $funcType([Color], [$Int], false)}];
	YCbCr.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	NYCbCrA.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	CMYK.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}];
	Color.init([{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}]);
	RGBA.init("", [{prop: "R", name: "R", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "G", name: "G", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "B", name: "B", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "A", name: "A", embedded: false, exported: true, typ: $Uint8, tag: ""}]);
	RGBA64.init("", [{prop: "R", name: "R", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "G", name: "G", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "B", name: "B", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "A", name: "A", embedded: false, exported: true, typ: $Uint16, tag: ""}]);
	NRGBA.init("", [{prop: "R", name: "R", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "G", name: "G", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "B", name: "B", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "A", name: "A", embedded: false, exported: true, typ: $Uint8, tag: ""}]);
	NRGBA64.init("", [{prop: "R", name: "R", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "G", name: "G", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "B", name: "B", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "A", name: "A", embedded: false, exported: true, typ: $Uint16, tag: ""}]);
	Alpha.init("", [{prop: "A", name: "A", embedded: false, exported: true, typ: $Uint8, tag: ""}]);
	Alpha16.init("", [{prop: "A", name: "A", embedded: false, exported: true, typ: $Uint16, tag: ""}]);
	Gray.init("", [{prop: "Y", name: "Y", embedded: false, exported: true, typ: $Uint8, tag: ""}]);
	Gray16.init("", [{prop: "Y", name: "Y", embedded: false, exported: true, typ: $Uint16, tag: ""}]);
	Model.init([{prop: "Convert", name: "Convert", pkg: "", typ: $funcType([Color], [Color], false)}]);
	modelFunc.init("image/color", [{prop: "f", name: "f", embedded: false, exported: false, typ: funcType, tag: ""}]);
	Palette.init(Color);
	YCbCr.init("", [{prop: "Y", name: "Y", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Cb", name: "Cb", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Cr", name: "Cr", embedded: false, exported: true, typ: $Uint8, tag: ""}]);
	NYCbCrA.init("", [{prop: "YCbCr", name: "YCbCr", embedded: true, exported: true, typ: YCbCr, tag: ""}, {prop: "A", name: "A", embedded: false, exported: true, typ: $Uint8, tag: ""}]);
	CMYK.init("", [{prop: "C", name: "C", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "M", name: "M", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Y", name: "Y", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "K", name: "K", embedded: false, exported: true, typ: $Uint8, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$pkg.RGBAModel = ModelFunc(rgbaModel);
		$pkg.RGBA64Model = ModelFunc(rgba64Model);
		$pkg.NRGBAModel = ModelFunc(nrgbaModel);
		$pkg.NRGBA64Model = ModelFunc(nrgba64Model);
		$pkg.AlphaModel = ModelFunc(alphaModel);
		$pkg.Alpha16Model = ModelFunc(alpha16Model);
		$pkg.GrayModel = ModelFunc(grayModel);
		$pkg.Gray16Model = ModelFunc(gray16Model);
		$pkg.Black = new Gray16.ptr(0);
		$pkg.White = new Gray16.ptr(65535);
		$pkg.Transparent = new Alpha16.ptr(0);
		$pkg.Opaque = new Alpha16.ptr(65535);
		$pkg.YCbCrModel = ModelFunc(yCbCrModel);
		$pkg.NYCbCrAModel = ModelFunc(nYCbCrAModel);
		$pkg.CMYKModel = ModelFunc(cmykModel);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["image"] = (function() {
	var $pkg = {}, $init, bufio, errors, color, io, strconv, sync, atomic, Point, Rectangle, Image, RGBA, NRGBA, Alpha, Gray, CMYK, Paletted, Uniform, YCbCrSubsampleRatio, YCbCr, sliceType$1, arrayType, ptrType, ptrType$2, ptrType$4, ptrType$6, ptrType$8, ptrType$9, ptrType$10, ptrType$11, x, x$1, x$2, x$3, Pt, Rect, NewRGBA, NewUniform;
	bufio = $packages["bufio"];
	errors = $packages["errors"];
	color = $packages["image/color"];
	io = $packages["io"];
	strconv = $packages["strconv"];
	sync = $packages["sync"];
	atomic = $packages["sync/atomic"];
	Point = $pkg.Point = $newType(0, $kindStruct, "image.Point", true, "image", true, function(X_, Y_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.X = 0;
			this.Y = 0;
			return;
		}
		this.X = X_;
		this.Y = Y_;
	});
	Rectangle = $pkg.Rectangle = $newType(0, $kindStruct, "image.Rectangle", true, "image", true, function(Min_, Max_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Min = new Point.ptr(0, 0);
			this.Max = new Point.ptr(0, 0);
			return;
		}
		this.Min = Min_;
		this.Max = Max_;
	});
	Image = $pkg.Image = $newType(8, $kindInterface, "image.Image", true, "image", true, null);
	RGBA = $pkg.RGBA = $newType(0, $kindStruct, "image.RGBA", true, "image", true, function(Pix_, Stride_, Rect_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Pix = sliceType$1.nil;
			this.Stride = 0;
			this.Rect = new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0));
			return;
		}
		this.Pix = Pix_;
		this.Stride = Stride_;
		this.Rect = Rect_;
	});
	NRGBA = $pkg.NRGBA = $newType(0, $kindStruct, "image.NRGBA", true, "image", true, function(Pix_, Stride_, Rect_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Pix = sliceType$1.nil;
			this.Stride = 0;
			this.Rect = new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0));
			return;
		}
		this.Pix = Pix_;
		this.Stride = Stride_;
		this.Rect = Rect_;
	});
	Alpha = $pkg.Alpha = $newType(0, $kindStruct, "image.Alpha", true, "image", true, function(Pix_, Stride_, Rect_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Pix = sliceType$1.nil;
			this.Stride = 0;
			this.Rect = new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0));
			return;
		}
		this.Pix = Pix_;
		this.Stride = Stride_;
		this.Rect = Rect_;
	});
	Gray = $pkg.Gray = $newType(0, $kindStruct, "image.Gray", true, "image", true, function(Pix_, Stride_, Rect_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Pix = sliceType$1.nil;
			this.Stride = 0;
			this.Rect = new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0));
			return;
		}
		this.Pix = Pix_;
		this.Stride = Stride_;
		this.Rect = Rect_;
	});
	CMYK = $pkg.CMYK = $newType(0, $kindStruct, "image.CMYK", true, "image", true, function(Pix_, Stride_, Rect_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Pix = sliceType$1.nil;
			this.Stride = 0;
			this.Rect = new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0));
			return;
		}
		this.Pix = Pix_;
		this.Stride = Stride_;
		this.Rect = Rect_;
	});
	Paletted = $pkg.Paletted = $newType(0, $kindStruct, "image.Paletted", true, "image", true, function(Pix_, Stride_, Rect_, Palette_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Pix = sliceType$1.nil;
			this.Stride = 0;
			this.Rect = new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0));
			this.Palette = color.Palette.nil;
			return;
		}
		this.Pix = Pix_;
		this.Stride = Stride_;
		this.Rect = Rect_;
		this.Palette = Palette_;
	});
	Uniform = $pkg.Uniform = $newType(0, $kindStruct, "image.Uniform", true, "image", true, function(C_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.C = $ifaceNil;
			return;
		}
		this.C = C_;
	});
	YCbCrSubsampleRatio = $pkg.YCbCrSubsampleRatio = $newType(4, $kindInt, "image.YCbCrSubsampleRatio", true, "image", true, null);
	YCbCr = $pkg.YCbCr = $newType(0, $kindStruct, "image.YCbCr", true, "image", true, function(Y_, Cb_, Cr_, YStride_, CStride_, SubsampleRatio_, Rect_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Y = sliceType$1.nil;
			this.Cb = sliceType$1.nil;
			this.Cr = sliceType$1.nil;
			this.YStride = 0;
			this.CStride = 0;
			this.SubsampleRatio = 0;
			this.Rect = new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0));
			return;
		}
		this.Y = Y_;
		this.Cb = Cb_;
		this.Cr = Cr_;
		this.YStride = YStride_;
		this.CStride = CStride_;
		this.SubsampleRatio = SubsampleRatio_;
		this.Rect = Rect_;
	});
	sliceType$1 = $sliceType($Uint8);
	arrayType = $arrayType($Bool, 256);
	ptrType = $ptrType(RGBA);
	ptrType$2 = $ptrType(NRGBA);
	ptrType$4 = $ptrType(Alpha);
	ptrType$6 = $ptrType(Gray);
	ptrType$8 = $ptrType(CMYK);
	ptrType$9 = $ptrType(Paletted);
	ptrType$10 = $ptrType(Uniform);
	ptrType$11 = $ptrType(YCbCr);
	Point.ptr.prototype.String = function() {
		var p;
		p = this;
		return "(" + strconv.Itoa(p.X) + "," + strconv.Itoa(p.Y) + ")";
	};
	Point.prototype.String = function() { return this.$val.String(); };
	Point.ptr.prototype.Add = function(q) {
		var p, q;
		p = this;
		return new Point.ptr(p.X + q.X >> 0, p.Y + q.Y >> 0);
	};
	Point.prototype.Add = function(q) { return this.$val.Add(q); };
	Point.ptr.prototype.Sub = function(q) {
		var p, q;
		p = this;
		return new Point.ptr(p.X - q.X >> 0, p.Y - q.Y >> 0);
	};
	Point.prototype.Sub = function(q) { return this.$val.Sub(q); };
	Point.ptr.prototype.Mul = function(k) {
		var k, p;
		p = this;
		return new Point.ptr($imul(p.X, k), $imul(p.Y, k));
	};
	Point.prototype.Mul = function(k) { return this.$val.Mul(k); };
	Point.ptr.prototype.Div = function(k) {
		var _q, _q$1, k, p;
		p = this;
		return new Point.ptr((_q = p.X / k, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")), (_q$1 = p.Y / k, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")));
	};
	Point.prototype.Div = function(k) { return this.$val.Div(k); };
	Point.ptr.prototype.In = function(r) {
		var p, r;
		p = this;
		return r.Min.X <= p.X && p.X < r.Max.X && r.Min.Y <= p.Y && p.Y < r.Max.Y;
	};
	Point.prototype.In = function(r) { return this.$val.In(r); };
	Point.ptr.prototype.Mod = function(r) {
		var _r, _r$1, _tmp, _tmp$1, h, p, r, w;
		p = this;
		_tmp = $clone(r, Rectangle).Dx();
		_tmp$1 = $clone(r, Rectangle).Dy();
		w = _tmp;
		h = _tmp$1;
		Point.copy(p, $clone(p, Point).Sub($clone(r.Min, Point)));
		p.X = (_r = p.X % w, _r === _r ? _r : $throwRuntimeError("integer divide by zero"));
		if (p.X < 0) {
			p.X = p.X + (w) >> 0;
		}
		p.Y = (_r$1 = p.Y % h, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"));
		if (p.Y < 0) {
			p.Y = p.Y + (h) >> 0;
		}
		return $clone(p, Point).Add($clone(r.Min, Point));
	};
	Point.prototype.Mod = function(r) { return this.$val.Mod(r); };
	Point.ptr.prototype.Eq = function(q) {
		var p, q;
		p = this;
		return $equal(p, q, Point);
	};
	Point.prototype.Eq = function(q) { return this.$val.Eq(q); };
	Pt = function(X, Y) {
		var X, Y;
		return new Point.ptr(X, Y);
	};
	$pkg.Pt = Pt;
	Rectangle.ptr.prototype.String = function() {
		var r;
		r = this;
		return $clone(r.Min, Point).String() + "-" + $clone(r.Max, Point).String();
	};
	Rectangle.prototype.String = function() { return this.$val.String(); };
	Rectangle.ptr.prototype.Dx = function() {
		var r;
		r = this;
		return r.Max.X - r.Min.X >> 0;
	};
	Rectangle.prototype.Dx = function() { return this.$val.Dx(); };
	Rectangle.ptr.prototype.Dy = function() {
		var r;
		r = this;
		return r.Max.Y - r.Min.Y >> 0;
	};
	Rectangle.prototype.Dy = function() { return this.$val.Dy(); };
	Rectangle.ptr.prototype.Size = function() {
		var r;
		r = this;
		return new Point.ptr(r.Max.X - r.Min.X >> 0, r.Max.Y - r.Min.Y >> 0);
	};
	Rectangle.prototype.Size = function() { return this.$val.Size(); };
	Rectangle.ptr.prototype.Add = function(p) {
		var p, r;
		r = this;
		return new Rectangle.ptr(new Point.ptr(r.Min.X + p.X >> 0, r.Min.Y + p.Y >> 0), new Point.ptr(r.Max.X + p.X >> 0, r.Max.Y + p.Y >> 0));
	};
	Rectangle.prototype.Add = function(p) { return this.$val.Add(p); };
	Rectangle.ptr.prototype.Sub = function(p) {
		var p, r;
		r = this;
		return new Rectangle.ptr(new Point.ptr(r.Min.X - p.X >> 0, r.Min.Y - p.Y >> 0), new Point.ptr(r.Max.X - p.X >> 0, r.Max.Y - p.Y >> 0));
	};
	Rectangle.prototype.Sub = function(p) { return this.$val.Sub(p); };
	Rectangle.ptr.prototype.Inset = function(n) {
		var _q, _q$1, n, r;
		r = this;
		if ($clone(r, Rectangle).Dx() < ($imul(2, n))) {
			r.Min.X = (_q = ((r.Min.X + r.Max.X >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			r.Max.X = r.Min.X;
		} else {
			r.Min.X = r.Min.X + (n) >> 0;
			r.Max.X = r.Max.X - (n) >> 0;
		}
		if ($clone(r, Rectangle).Dy() < ($imul(2, n))) {
			r.Min.Y = (_q$1 = ((r.Min.Y + r.Max.Y >> 0)) / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"));
			r.Max.Y = r.Min.Y;
		} else {
			r.Min.Y = r.Min.Y + (n) >> 0;
			r.Max.Y = r.Max.Y - (n) >> 0;
		}
		return r;
	};
	Rectangle.prototype.Inset = function(n) { return this.$val.Inset(n); };
	Rectangle.ptr.prototype.Intersect = function(s) {
		var r, s;
		r = this;
		if (r.Min.X < s.Min.X) {
			r.Min.X = s.Min.X;
		}
		if (r.Min.Y < s.Min.Y) {
			r.Min.Y = s.Min.Y;
		}
		if (r.Max.X > s.Max.X) {
			r.Max.X = s.Max.X;
		}
		if (r.Max.Y > s.Max.Y) {
			r.Max.Y = s.Max.Y;
		}
		if ($clone(r, Rectangle).Empty()) {
			return $pkg.ZR;
		}
		return r;
	};
	Rectangle.prototype.Intersect = function(s) { return this.$val.Intersect(s); };
	Rectangle.ptr.prototype.Union = function(s) {
		var r, s;
		r = this;
		if ($clone(r, Rectangle).Empty()) {
			return s;
		}
		if ($clone(s, Rectangle).Empty()) {
			return r;
		}
		if (r.Min.X > s.Min.X) {
			r.Min.X = s.Min.X;
		}
		if (r.Min.Y > s.Min.Y) {
			r.Min.Y = s.Min.Y;
		}
		if (r.Max.X < s.Max.X) {
			r.Max.X = s.Max.X;
		}
		if (r.Max.Y < s.Max.Y) {
			r.Max.Y = s.Max.Y;
		}
		return r;
	};
	Rectangle.prototype.Union = function(s) { return this.$val.Union(s); };
	Rectangle.ptr.prototype.Empty = function() {
		var r;
		r = this;
		return r.Min.X >= r.Max.X || r.Min.Y >= r.Max.Y;
	};
	Rectangle.prototype.Empty = function() { return this.$val.Empty(); };
	Rectangle.ptr.prototype.Eq = function(s) {
		var r, s;
		r = this;
		return $equal(r, s, Rectangle) || $clone(r, Rectangle).Empty() && $clone(s, Rectangle).Empty();
	};
	Rectangle.prototype.Eq = function(s) { return this.$val.Eq(s); };
	Rectangle.ptr.prototype.Overlaps = function(s) {
		var r, s;
		r = this;
		return !$clone(r, Rectangle).Empty() && !$clone(s, Rectangle).Empty() && r.Min.X < s.Max.X && s.Min.X < r.Max.X && r.Min.Y < s.Max.Y && s.Min.Y < r.Max.Y;
	};
	Rectangle.prototype.Overlaps = function(s) { return this.$val.Overlaps(s); };
	Rectangle.ptr.prototype.In = function(s) {
		var r, s;
		r = this;
		if ($clone(r, Rectangle).Empty()) {
			return true;
		}
		return s.Min.X <= r.Min.X && r.Max.X <= s.Max.X && s.Min.Y <= r.Min.Y && r.Max.Y <= s.Max.Y;
	};
	Rectangle.prototype.In = function(s) { return this.$val.In(s); };
	Rectangle.ptr.prototype.Canon = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, r;
		r = this;
		if (r.Max.X < r.Min.X) {
			_tmp = r.Max.X;
			_tmp$1 = r.Min.X;
			r.Min.X = _tmp;
			r.Max.X = _tmp$1;
		}
		if (r.Max.Y < r.Min.Y) {
			_tmp$2 = r.Max.Y;
			_tmp$3 = r.Min.Y;
			r.Min.Y = _tmp$2;
			r.Max.Y = _tmp$3;
		}
		return r;
	};
	Rectangle.prototype.Canon = function() { return this.$val.Canon(); };
	Rectangle.ptr.prototype.At = function(x$4, y) {
		var r, x$4, x$5, x$6, y;
		r = this;
		if ($clone((new Point.ptr(x$4, y)), Point).In($clone(r, Rectangle))) {
			return (x$5 = color.Opaque, new x$5.constructor.elem(x$5));
		}
		return (x$6 = color.Transparent, new x$6.constructor.elem(x$6));
	};
	Rectangle.prototype.At = function(x$4, y) { return this.$val.At(x$4, y); };
	Rectangle.ptr.prototype.Bounds = function() {
		var r;
		r = this;
		return r;
	};
	Rectangle.prototype.Bounds = function() { return this.$val.Bounds(); };
	Rectangle.ptr.prototype.ColorModel = function() {
		var r;
		r = this;
		return color.Alpha16Model;
	};
	Rectangle.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	Rect = function(x0, y0, x1, y1) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, x0, x1, y0, y1;
		if (x0 > x1) {
			_tmp = x1;
			_tmp$1 = x0;
			x0 = _tmp;
			x1 = _tmp$1;
		}
		if (y0 > y1) {
			_tmp$2 = y1;
			_tmp$3 = y0;
			y0 = _tmp$2;
			y1 = _tmp$3;
		}
		return new Rectangle.ptr(new Point.ptr(x0, y0), new Point.ptr(x1, y1));
	};
	$pkg.Rect = Rect;
	RGBA.ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.RGBAModel;
	};
	RGBA.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	RGBA.ptr.prototype.Bounds = function() {
		var p;
		p = this;
		return p.Rect;
	};
	RGBA.prototype.Bounds = function() { return this.$val.Bounds(); };
	RGBA.ptr.prototype.At = function(x$4, y) {
		var p, x$4, x$5, y;
		p = this;
		return (x$5 = p.RGBAAt(x$4, y), new x$5.constructor.elem(x$5));
	};
	RGBA.prototype.At = function(x$4, y) { return this.$val.At(x$4, y); };
	RGBA.ptr.prototype.RGBAAt = function(x$4, y) {
		var i, p, s, x$4, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return new color.RGBA.ptr(0, 0, 0, 0);
		}
		i = p.PixOffset(x$4, y);
		s = $subslice(p.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
		return new color.RGBA.ptr((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]), (1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1]), (2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2]), (3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3]));
	};
	RGBA.prototype.RGBAAt = function(x$4, y) { return this.$val.RGBAAt(x$4, y); };
	RGBA.ptr.prototype.PixOffset = function(x$4, y) {
		var p, x$4, y;
		p = this;
		return ($imul(((y - p.Rect.Min.Y >> 0)), p.Stride)) + ($imul(((x$4 - p.Rect.Min.X >> 0)), 4)) >> 0;
	};
	RGBA.prototype.PixOffset = function(x$4, y) { return this.$val.PixOffset(x$4, y); };
	RGBA.ptr.prototype.Set = function(x$4, y, c) {
		var _r, c, c1, i, p, s, x$4, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; c1 = $f.c1; i = $f.i; p = $f.p; s = $f.s; x$4 = $f.x$4; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			$s = -1; return;
		}
		i = p.PixOffset(x$4, y);
		_r = color.RGBAModel.Convert(c); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		c1 = $clone($assertType(_r, color.RGBA), color.RGBA);
		s = $subslice(p.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
		(0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0] = c1.R);
		(1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1] = c1.G);
		(2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2] = c1.B);
		(3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3] = c1.A);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: RGBA.ptr.prototype.Set }; } $f._r = _r; $f.c = c; $f.c1 = c1; $f.i = i; $f.p = p; $f.s = s; $f.x$4 = x$4; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	RGBA.prototype.Set = function(x$4, y, c) { return this.$val.Set(x$4, y, c); };
	RGBA.ptr.prototype.SetRGBA = function(x$4, y, c) {
		var c, i, p, s, x$4, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return;
		}
		i = p.PixOffset(x$4, y);
		s = $subslice(p.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
		(0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0] = c.R);
		(1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1] = c.G);
		(2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2] = c.B);
		(3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3] = c.A);
	};
	RGBA.prototype.SetRGBA = function(x$4, y, c) { return this.$val.SetRGBA(x$4, y, c); };
	RGBA.ptr.prototype.SubImage = function(r) {
		var i, p, r;
		p = this;
		Rectangle.copy(r, $clone(r, Rectangle).Intersect($clone(p.Rect, Rectangle)));
		if ($clone(r, Rectangle).Empty()) {
			return new RGBA.ptr(sliceType$1.nil, 0, new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0)));
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new RGBA.ptr($subslice(p.Pix, i), p.Stride, $clone(r, Rectangle));
	};
	RGBA.prototype.SubImage = function(r) { return this.$val.SubImage(r); };
	RGBA.ptr.prototype.Opaque = function() {
		var _tmp, _tmp$1, i, i0, i1, p, x$4, y;
		p = this;
		if ($clone(p.Rect, Rectangle).Empty()) {
			return true;
		}
		_tmp = 3;
		_tmp$1 = $imul($clone(p.Rect, Rectangle).Dx(), 4);
		i0 = _tmp;
		i1 = _tmp$1;
		y = p.Rect.Min.Y;
		while (true) {
			if (!(y < p.Rect.Max.Y)) { break; }
			i = i0;
			while (true) {
				if (!(i < i1)) { break; }
				if (!(((x$4 = p.Pix, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i])) === 255))) {
					return false;
				}
				i = i + (4) >> 0;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + (1) >> 0;
		}
		return true;
	};
	RGBA.prototype.Opaque = function() { return this.$val.Opaque(); };
	NewRGBA = function(r) {
		var _tmp, _tmp$1, buf, h, r, w;
		_tmp = $clone(r, Rectangle).Dx();
		_tmp$1 = $clone(r, Rectangle).Dy();
		w = _tmp;
		h = _tmp$1;
		buf = $makeSlice(sliceType$1, ($imul(($imul(4, w)), h)));
		return new RGBA.ptr(buf, $imul(4, w), $clone(r, Rectangle));
	};
	$pkg.NewRGBA = NewRGBA;
	NRGBA.ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.NRGBAModel;
	};
	NRGBA.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	NRGBA.ptr.prototype.Bounds = function() {
		var p;
		p = this;
		return p.Rect;
	};
	NRGBA.prototype.Bounds = function() { return this.$val.Bounds(); };
	NRGBA.ptr.prototype.At = function(x$4, y) {
		var p, x$4, x$5, y;
		p = this;
		return (x$5 = p.NRGBAAt(x$4, y), new x$5.constructor.elem(x$5));
	};
	NRGBA.prototype.At = function(x$4, y) { return this.$val.At(x$4, y); };
	NRGBA.ptr.prototype.NRGBAAt = function(x$4, y) {
		var i, p, s, x$4, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return new color.NRGBA.ptr(0, 0, 0, 0);
		}
		i = p.PixOffset(x$4, y);
		s = $subslice(p.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
		return new color.NRGBA.ptr((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]), (1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1]), (2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2]), (3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3]));
	};
	NRGBA.prototype.NRGBAAt = function(x$4, y) { return this.$val.NRGBAAt(x$4, y); };
	NRGBA.ptr.prototype.PixOffset = function(x$4, y) {
		var p, x$4, y;
		p = this;
		return ($imul(((y - p.Rect.Min.Y >> 0)), p.Stride)) + ($imul(((x$4 - p.Rect.Min.X >> 0)), 4)) >> 0;
	};
	NRGBA.prototype.PixOffset = function(x$4, y) { return this.$val.PixOffset(x$4, y); };
	NRGBA.ptr.prototype.Set = function(x$4, y, c) {
		var _r, c, c1, i, p, s, x$4, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; c1 = $f.c1; i = $f.i; p = $f.p; s = $f.s; x$4 = $f.x$4; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			$s = -1; return;
		}
		i = p.PixOffset(x$4, y);
		_r = color.NRGBAModel.Convert(c); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		c1 = $clone($assertType(_r, color.NRGBA), color.NRGBA);
		s = $subslice(p.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
		(0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0] = c1.R);
		(1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1] = c1.G);
		(2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2] = c1.B);
		(3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3] = c1.A);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NRGBA.ptr.prototype.Set }; } $f._r = _r; $f.c = c; $f.c1 = c1; $f.i = i; $f.p = p; $f.s = s; $f.x$4 = x$4; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	NRGBA.prototype.Set = function(x$4, y, c) { return this.$val.Set(x$4, y, c); };
	NRGBA.ptr.prototype.SetNRGBA = function(x$4, y, c) {
		var c, i, p, s, x$4, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return;
		}
		i = p.PixOffset(x$4, y);
		s = $subslice(p.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
		(0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0] = c.R);
		(1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1] = c.G);
		(2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2] = c.B);
		(3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3] = c.A);
	};
	NRGBA.prototype.SetNRGBA = function(x$4, y, c) { return this.$val.SetNRGBA(x$4, y, c); };
	NRGBA.ptr.prototype.SubImage = function(r) {
		var i, p, r;
		p = this;
		Rectangle.copy(r, $clone(r, Rectangle).Intersect($clone(p.Rect, Rectangle)));
		if ($clone(r, Rectangle).Empty()) {
			return new NRGBA.ptr(sliceType$1.nil, 0, new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0)));
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new NRGBA.ptr($subslice(p.Pix, i), p.Stride, $clone(r, Rectangle));
	};
	NRGBA.prototype.SubImage = function(r) { return this.$val.SubImage(r); };
	NRGBA.ptr.prototype.Opaque = function() {
		var _tmp, _tmp$1, i, i0, i1, p, x$4, y;
		p = this;
		if ($clone(p.Rect, Rectangle).Empty()) {
			return true;
		}
		_tmp = 3;
		_tmp$1 = $imul($clone(p.Rect, Rectangle).Dx(), 4);
		i0 = _tmp;
		i1 = _tmp$1;
		y = p.Rect.Min.Y;
		while (true) {
			if (!(y < p.Rect.Max.Y)) { break; }
			i = i0;
			while (true) {
				if (!(i < i1)) { break; }
				if (!(((x$4 = p.Pix, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i])) === 255))) {
					return false;
				}
				i = i + (4) >> 0;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + (1) >> 0;
		}
		return true;
	};
	NRGBA.prototype.Opaque = function() { return this.$val.Opaque(); };
	Alpha.ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.AlphaModel;
	};
	Alpha.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	Alpha.ptr.prototype.Bounds = function() {
		var p;
		p = this;
		return p.Rect;
	};
	Alpha.prototype.Bounds = function() { return this.$val.Bounds(); };
	Alpha.ptr.prototype.At = function(x$4, y) {
		var p, x$4, x$5, y;
		p = this;
		return (x$5 = p.AlphaAt(x$4, y), new x$5.constructor.elem(x$5));
	};
	Alpha.prototype.At = function(x$4, y) { return this.$val.At(x$4, y); };
	Alpha.ptr.prototype.AlphaAt = function(x$4, y) {
		var i, p, x$4, x$5, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return new color.Alpha.ptr(0);
		}
		i = p.PixOffset(x$4, y);
		return new color.Alpha.ptr((x$5 = p.Pix, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i])));
	};
	Alpha.prototype.AlphaAt = function(x$4, y) { return this.$val.AlphaAt(x$4, y); };
	Alpha.ptr.prototype.PixOffset = function(x$4, y) {
		var p, x$4, y;
		p = this;
		return ($imul(((y - p.Rect.Min.Y >> 0)), p.Stride)) + ($imul(((x$4 - p.Rect.Min.X >> 0)), 1)) >> 0;
	};
	Alpha.prototype.PixOffset = function(x$4, y) { return this.$val.PixOffset(x$4, y); };
	Alpha.ptr.prototype.Set = function(x$4, y, c) {
		var _r, c, i, p, x$4, x$5, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; i = $f.i; p = $f.p; x$4 = $f.x$4; x$5 = $f.x$5; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			$s = -1; return;
		}
		i = p.PixOffset(x$4, y);
		_r = color.AlphaModel.Convert(c); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		(x$5 = p.Pix, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i] = $assertType(_r, color.Alpha).A));
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Alpha.ptr.prototype.Set }; } $f._r = _r; $f.c = c; $f.i = i; $f.p = p; $f.x$4 = x$4; $f.x$5 = x$5; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Alpha.prototype.Set = function(x$4, y, c) { return this.$val.Set(x$4, y, c); };
	Alpha.ptr.prototype.SetAlpha = function(x$4, y, c) {
		var c, i, p, x$4, x$5, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return;
		}
		i = p.PixOffset(x$4, y);
		(x$5 = p.Pix, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i] = c.A));
	};
	Alpha.prototype.SetAlpha = function(x$4, y, c) { return this.$val.SetAlpha(x$4, y, c); };
	Alpha.ptr.prototype.SubImage = function(r) {
		var i, p, r;
		p = this;
		Rectangle.copy(r, $clone(r, Rectangle).Intersect($clone(p.Rect, Rectangle)));
		if ($clone(r, Rectangle).Empty()) {
			return new Alpha.ptr(sliceType$1.nil, 0, new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0)));
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new Alpha.ptr($subslice(p.Pix, i), p.Stride, $clone(r, Rectangle));
	};
	Alpha.prototype.SubImage = function(r) { return this.$val.SubImage(r); };
	Alpha.ptr.prototype.Opaque = function() {
		var _tmp, _tmp$1, i, i0, i1, p, x$4, y;
		p = this;
		if ($clone(p.Rect, Rectangle).Empty()) {
			return true;
		}
		_tmp = 0;
		_tmp$1 = $clone(p.Rect, Rectangle).Dx();
		i0 = _tmp;
		i1 = _tmp$1;
		y = p.Rect.Min.Y;
		while (true) {
			if (!(y < p.Rect.Max.Y)) { break; }
			i = i0;
			while (true) {
				if (!(i < i1)) { break; }
				if (!(((x$4 = p.Pix, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i])) === 255))) {
					return false;
				}
				i = i + (1) >> 0;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + (1) >> 0;
		}
		return true;
	};
	Alpha.prototype.Opaque = function() { return this.$val.Opaque(); };
	Gray.ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.GrayModel;
	};
	Gray.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	Gray.ptr.prototype.Bounds = function() {
		var p;
		p = this;
		return p.Rect;
	};
	Gray.prototype.Bounds = function() { return this.$val.Bounds(); };
	Gray.ptr.prototype.At = function(x$4, y) {
		var p, x$4, x$5, y;
		p = this;
		return (x$5 = p.GrayAt(x$4, y), new x$5.constructor.elem(x$5));
	};
	Gray.prototype.At = function(x$4, y) { return this.$val.At(x$4, y); };
	Gray.ptr.prototype.GrayAt = function(x$4, y) {
		var i, p, x$4, x$5, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return new color.Gray.ptr(0);
		}
		i = p.PixOffset(x$4, y);
		return new color.Gray.ptr((x$5 = p.Pix, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i])));
	};
	Gray.prototype.GrayAt = function(x$4, y) { return this.$val.GrayAt(x$4, y); };
	Gray.ptr.prototype.PixOffset = function(x$4, y) {
		var p, x$4, y;
		p = this;
		return ($imul(((y - p.Rect.Min.Y >> 0)), p.Stride)) + ($imul(((x$4 - p.Rect.Min.X >> 0)), 1)) >> 0;
	};
	Gray.prototype.PixOffset = function(x$4, y) { return this.$val.PixOffset(x$4, y); };
	Gray.ptr.prototype.Set = function(x$4, y, c) {
		var _r, c, i, p, x$4, x$5, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; i = $f.i; p = $f.p; x$4 = $f.x$4; x$5 = $f.x$5; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			$s = -1; return;
		}
		i = p.PixOffset(x$4, y);
		_r = color.GrayModel.Convert(c); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		(x$5 = p.Pix, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i] = $assertType(_r, color.Gray).Y));
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Gray.ptr.prototype.Set }; } $f._r = _r; $f.c = c; $f.i = i; $f.p = p; $f.x$4 = x$4; $f.x$5 = x$5; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Gray.prototype.Set = function(x$4, y, c) { return this.$val.Set(x$4, y, c); };
	Gray.ptr.prototype.SetGray = function(x$4, y, c) {
		var c, i, p, x$4, x$5, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return;
		}
		i = p.PixOffset(x$4, y);
		(x$5 = p.Pix, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i] = c.Y));
	};
	Gray.prototype.SetGray = function(x$4, y, c) { return this.$val.SetGray(x$4, y, c); };
	Gray.ptr.prototype.SubImage = function(r) {
		var i, p, r;
		p = this;
		Rectangle.copy(r, $clone(r, Rectangle).Intersect($clone(p.Rect, Rectangle)));
		if ($clone(r, Rectangle).Empty()) {
			return new Gray.ptr(sliceType$1.nil, 0, new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0)));
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new Gray.ptr($subslice(p.Pix, i), p.Stride, $clone(r, Rectangle));
	};
	Gray.prototype.SubImage = function(r) { return this.$val.SubImage(r); };
	Gray.ptr.prototype.Opaque = function() {
		var p;
		p = this;
		return true;
	};
	Gray.prototype.Opaque = function() { return this.$val.Opaque(); };
	CMYK.ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.CMYKModel;
	};
	CMYK.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	CMYK.ptr.prototype.Bounds = function() {
		var p;
		p = this;
		return p.Rect;
	};
	CMYK.prototype.Bounds = function() { return this.$val.Bounds(); };
	CMYK.ptr.prototype.At = function(x$4, y) {
		var p, x$4, x$5, y;
		p = this;
		return (x$5 = p.CMYKAt(x$4, y), new x$5.constructor.elem(x$5));
	};
	CMYK.prototype.At = function(x$4, y) { return this.$val.At(x$4, y); };
	CMYK.ptr.prototype.CMYKAt = function(x$4, y) {
		var i, p, s, x$4, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return new color.CMYK.ptr(0, 0, 0, 0);
		}
		i = p.PixOffset(x$4, y);
		s = $subslice(p.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
		return new color.CMYK.ptr((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]), (1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1]), (2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2]), (3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3]));
	};
	CMYK.prototype.CMYKAt = function(x$4, y) { return this.$val.CMYKAt(x$4, y); };
	CMYK.ptr.prototype.PixOffset = function(x$4, y) {
		var p, x$4, y;
		p = this;
		return ($imul(((y - p.Rect.Min.Y >> 0)), p.Stride)) + ($imul(((x$4 - p.Rect.Min.X >> 0)), 4)) >> 0;
	};
	CMYK.prototype.PixOffset = function(x$4, y) { return this.$val.PixOffset(x$4, y); };
	CMYK.ptr.prototype.Set = function(x$4, y, c) {
		var _r, c, c1, i, p, s, x$4, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; c1 = $f.c1; i = $f.i; p = $f.p; s = $f.s; x$4 = $f.x$4; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			$s = -1; return;
		}
		i = p.PixOffset(x$4, y);
		_r = color.CMYKModel.Convert(c); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		c1 = $clone($assertType(_r, color.CMYK), color.CMYK);
		s = $subslice(p.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
		(0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0] = c1.C);
		(1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1] = c1.M);
		(2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2] = c1.Y);
		(3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3] = c1.K);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: CMYK.ptr.prototype.Set }; } $f._r = _r; $f.c = c; $f.c1 = c1; $f.i = i; $f.p = p; $f.s = s; $f.x$4 = x$4; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	CMYK.prototype.Set = function(x$4, y, c) { return this.$val.Set(x$4, y, c); };
	CMYK.ptr.prototype.SetCMYK = function(x$4, y, c) {
		var c, i, p, s, x$4, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return;
		}
		i = p.PixOffset(x$4, y);
		s = $subslice(p.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
		(0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0] = c.C);
		(1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1] = c.M);
		(2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2] = c.Y);
		(3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3] = c.K);
	};
	CMYK.prototype.SetCMYK = function(x$4, y, c) { return this.$val.SetCMYK(x$4, y, c); };
	CMYK.ptr.prototype.SubImage = function(r) {
		var i, p, r;
		p = this;
		Rectangle.copy(r, $clone(r, Rectangle).Intersect($clone(p.Rect, Rectangle)));
		if ($clone(r, Rectangle).Empty()) {
			return new CMYK.ptr(sliceType$1.nil, 0, new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0)));
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new CMYK.ptr($subslice(p.Pix, i), p.Stride, $clone(r, Rectangle));
	};
	CMYK.prototype.SubImage = function(r) { return this.$val.SubImage(r); };
	CMYK.ptr.prototype.Opaque = function() {
		var p;
		p = this;
		return true;
	};
	CMYK.prototype.Opaque = function() { return this.$val.Opaque(); };
	Paletted.ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return p.Palette;
	};
	Paletted.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	Paletted.ptr.prototype.Bounds = function() {
		var p;
		p = this;
		return p.Rect;
	};
	Paletted.prototype.Bounds = function() { return this.$val.Bounds(); };
	Paletted.ptr.prototype.At = function(x$4, y) {
		var i, p, x$4, x$5, x$6, x$7, x$8, y;
		p = this;
		if (p.Palette.$length === 0) {
			return $ifaceNil;
		}
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return (x$5 = p.Palette, (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0]));
		}
		i = p.PixOffset(x$4, y);
		return (x$6 = p.Palette, x$7 = (x$8 = p.Pix, ((i < 0 || i >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + i])), ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7]));
	};
	Paletted.prototype.At = function(x$4, y) { return this.$val.At(x$4, y); };
	Paletted.ptr.prototype.PixOffset = function(x$4, y) {
		var p, x$4, y;
		p = this;
		return ($imul(((y - p.Rect.Min.Y >> 0)), p.Stride)) + ($imul(((x$4 - p.Rect.Min.X >> 0)), 1)) >> 0;
	};
	Paletted.prototype.PixOffset = function(x$4, y) { return this.$val.PixOffset(x$4, y); };
	Paletted.ptr.prototype.Set = function(x$4, y, c) {
		var _r, c, i, p, x$4, x$5, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; i = $f.i; p = $f.p; x$4 = $f.x$4; x$5 = $f.x$5; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			$s = -1; return;
		}
		i = p.PixOffset(x$4, y);
		_r = p.Palette.Index(c); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		(x$5 = p.Pix, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i] = ((_r << 24 >>> 24))));
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Paletted.ptr.prototype.Set }; } $f._r = _r; $f.c = c; $f.i = i; $f.p = p; $f.x$4 = x$4; $f.x$5 = x$5; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Paletted.prototype.Set = function(x$4, y, c) { return this.$val.Set(x$4, y, c); };
	Paletted.ptr.prototype.ColorIndexAt = function(x$4, y) {
		var i, p, x$4, x$5, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return 0;
		}
		i = p.PixOffset(x$4, y);
		return (x$5 = p.Pix, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i]));
	};
	Paletted.prototype.ColorIndexAt = function(x$4, y) { return this.$val.ColorIndexAt(x$4, y); };
	Paletted.ptr.prototype.SetColorIndex = function(x$4, y, index) {
		var i, index, p, x$4, x$5, y;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return;
		}
		i = p.PixOffset(x$4, y);
		(x$5 = p.Pix, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i] = index));
	};
	Paletted.prototype.SetColorIndex = function(x$4, y, index) { return this.$val.SetColorIndex(x$4, y, index); };
	Paletted.ptr.prototype.SubImage = function(r) {
		var i, p, r;
		p = this;
		Rectangle.copy(r, $clone(r, Rectangle).Intersect($clone(p.Rect, Rectangle)));
		if ($clone(r, Rectangle).Empty()) {
			return new Paletted.ptr(sliceType$1.nil, 0, new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0)), p.Palette);
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new Paletted.ptr($subslice(p.Pix, i), p.Stride, $clone($clone(p.Rect, Rectangle).Intersect($clone(r, Rectangle)), Rectangle), p.Palette);
	};
	Paletted.prototype.SubImage = function(r) { return this.$val.SubImage(r); };
	Paletted.ptr.prototype.Opaque = function() {
		var _i, _i$1, _r, _ref, _ref$1, _tmp, _tmp$1, _tuple, a, c, c$1, i, i0, i1, p, present, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; a = $f.a; c = $f.c; c$1 = $f.c$1; i = $f.i; i0 = $f.i0; i1 = $f.i1; p = $f.p; present = $f.present; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		present = arrayType.zero();
		_tmp = 0;
		_tmp$1 = $clone(p.Rect, Rectangle).Dx();
		i0 = _tmp;
		i1 = _tmp$1;
		y = p.Rect.Min.Y;
		while (true) {
			if (!(y < p.Rect.Max.Y)) { break; }
			_ref = $subslice(p.Pix, i0, i1);
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				((c < 0 || c >= present.length) ? ($throwRuntimeError("index out of range"), undefined) : present[c] = true);
				_i++;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + (1) >> 0;
		}
		_ref$1 = p.Palette;
		_i$1 = 0;
		/* while (true) { */ case 1:
			/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 2; continue; }
			i = _i$1;
			c$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			/* */ if (!((i < 0 || i >= present.length) ? ($throwRuntimeError("index out of range"), undefined) : present[i])) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!((i < 0 || i >= present.length) ? ($throwRuntimeError("index out of range"), undefined) : present[i])) { */ case 3:
				_i$1++;
				/* continue; */ $s = 1; continue;
			/* } */ case 4:
			_r = c$1.RGBA(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			a = _tuple[3];
			if (!((a === 65535))) {
				$s = -1; return false;
			}
			_i$1++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Paletted.ptr.prototype.Opaque }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.a = a; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.i0 = i0; $f.i1 = i1; $f.p = p; $f.present = present; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Paletted.prototype.Opaque = function() { return this.$val.Opaque(); };
	Uniform.ptr.prototype.RGBA = function() {
		var _r, _tuple, a, b, c, g, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; a = $f.a; b = $f.b; c = $f.c; g = $f.g; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = 0;
		g = 0;
		b = 0;
		a = 0;
		c = this;
		_r = c.C.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		g = _tuple[1];
		b = _tuple[2];
		a = _tuple[3];
		$s = -1; return [r, g, b, a];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Uniform.ptr.prototype.RGBA }; } $f._r = _r; $f._tuple = _tuple; $f.a = a; $f.b = b; $f.c = c; $f.g = g; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Uniform.prototype.RGBA = function() { return this.$val.RGBA(); };
	Uniform.ptr.prototype.ColorModel = function() {
		var c;
		c = this;
		return c;
	};
	Uniform.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	Uniform.ptr.prototype.Convert = function(param) {
		var c, param;
		c = this;
		return c.C;
	};
	Uniform.prototype.Convert = function(param) { return this.$val.Convert(param); };
	Uniform.ptr.prototype.Bounds = function() {
		var c;
		c = this;
		return new Rectangle.ptr(new Point.ptr(-1000000000, -1000000000), new Point.ptr(1000000000, 1000000000));
	};
	Uniform.prototype.Bounds = function() { return this.$val.Bounds(); };
	Uniform.ptr.prototype.At = function(x$4, y) {
		var c, x$4, y;
		c = this;
		return c.C;
	};
	Uniform.prototype.At = function(x$4, y) { return this.$val.At(x$4, y); };
	Uniform.ptr.prototype.Opaque = function() {
		var _r, _tuple, a, c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; a = $f.a; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = c.C.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		a = _tuple[3];
		$s = -1; return a === 65535;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Uniform.ptr.prototype.Opaque }; } $f._r = _r; $f._tuple = _tuple; $f.a = a; $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	Uniform.prototype.Opaque = function() { return this.$val.Opaque(); };
	NewUniform = function(c) {
		var c;
		return new Uniform.ptr(c);
	};
	$pkg.NewUniform = NewUniform;
	YCbCrSubsampleRatio.prototype.String = function() {
		var _1, s;
		s = this.$val;
		_1 = s;
		if (_1 === (0)) {
			return "YCbCrSubsampleRatio444";
		} else if (_1 === (1)) {
			return "YCbCrSubsampleRatio422";
		} else if (_1 === (2)) {
			return "YCbCrSubsampleRatio420";
		} else if (_1 === (3)) {
			return "YCbCrSubsampleRatio440";
		} else if (_1 === (4)) {
			return "YCbCrSubsampleRatio411";
		} else if (_1 === (5)) {
			return "YCbCrSubsampleRatio410";
		}
		return "YCbCrSubsampleRatioUnknown";
	};
	$ptrType(YCbCrSubsampleRatio).prototype.String = function() { return new YCbCrSubsampleRatio(this.$get()).String(); };
	YCbCr.ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.YCbCrModel;
	};
	YCbCr.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	YCbCr.ptr.prototype.Bounds = function() {
		var p;
		p = this;
		return p.Rect;
	};
	YCbCr.prototype.Bounds = function() { return this.$val.Bounds(); };
	YCbCr.ptr.prototype.At = function(x$4, y) {
		var p, x$4, x$5, y;
		p = this;
		return (x$5 = p.YCbCrAt(x$4, y), new x$5.constructor.elem(x$5));
	};
	YCbCr.prototype.At = function(x$4, y) { return this.$val.At(x$4, y); };
	YCbCr.ptr.prototype.YCbCrAt = function(x$4, y) {
		var ci, p, x$4, x$5, x$6, x$7, y, yi;
		p = this;
		if (!(new Point.ptr(x$4, y).In($clone(p.Rect, Rectangle)))) {
			return new color.YCbCr.ptr(0, 0, 0);
		}
		yi = p.YOffset(x$4, y);
		ci = p.COffset(x$4, y);
		return new color.YCbCr.ptr((x$5 = p.Y, ((yi < 0 || yi >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + yi])), (x$6 = p.Cb, ((ci < 0 || ci >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + ci])), (x$7 = p.Cr, ((ci < 0 || ci >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + ci])));
	};
	YCbCr.prototype.YCbCrAt = function(x$4, y) { return this.$val.YCbCrAt(x$4, y); };
	YCbCr.ptr.prototype.YOffset = function(x$4, y) {
		var p, x$4, y;
		p = this;
		return ($imul(((y - p.Rect.Min.Y >> 0)), p.YStride)) + ((x$4 - p.Rect.Min.X >> 0)) >> 0;
	};
	YCbCr.prototype.YOffset = function(x$4, y) { return this.$val.YOffset(x$4, y); };
	YCbCr.ptr.prototype.COffset = function(x$4, y) {
		var _1, _q, _q$1, _q$10, _q$11, _q$12, _q$13, _q$2, _q$3, _q$4, _q$5, _q$6, _q$7, _q$8, _q$9, p, x$4, y;
		p = this;
		_1 = p.SubsampleRatio;
		if (_1 === (1)) {
			return ($imul(((y - p.Rect.Min.Y >> 0)), p.CStride)) + (((_q = x$4 / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) - (_q$1 = p.Rect.Min.X / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)) >> 0;
		} else if (_1 === (2)) {
			return ($imul((((_q$2 = y / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero")) - (_q$3 = p.Rect.Min.Y / 2, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)), p.CStride)) + (((_q$4 = x$4 / 2, (_q$4 === _q$4 && _q$4 !== 1/0 && _q$4 !== -1/0) ? _q$4 >> 0 : $throwRuntimeError("integer divide by zero")) - (_q$5 = p.Rect.Min.X / 2, (_q$5 === _q$5 && _q$5 !== 1/0 && _q$5 !== -1/0) ? _q$5 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)) >> 0;
		} else if (_1 === (3)) {
			return ($imul((((_q$6 = y / 2, (_q$6 === _q$6 && _q$6 !== 1/0 && _q$6 !== -1/0) ? _q$6 >> 0 : $throwRuntimeError("integer divide by zero")) - (_q$7 = p.Rect.Min.Y / 2, (_q$7 === _q$7 && _q$7 !== 1/0 && _q$7 !== -1/0) ? _q$7 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)), p.CStride)) + ((x$4 - p.Rect.Min.X >> 0)) >> 0;
		} else if (_1 === (4)) {
			return ($imul(((y - p.Rect.Min.Y >> 0)), p.CStride)) + (((_q$8 = x$4 / 4, (_q$8 === _q$8 && _q$8 !== 1/0 && _q$8 !== -1/0) ? _q$8 >> 0 : $throwRuntimeError("integer divide by zero")) - (_q$9 = p.Rect.Min.X / 4, (_q$9 === _q$9 && _q$9 !== 1/0 && _q$9 !== -1/0) ? _q$9 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)) >> 0;
		} else if (_1 === (5)) {
			return ($imul((((_q$10 = y / 2, (_q$10 === _q$10 && _q$10 !== 1/0 && _q$10 !== -1/0) ? _q$10 >> 0 : $throwRuntimeError("integer divide by zero")) - (_q$11 = p.Rect.Min.Y / 2, (_q$11 === _q$11 && _q$11 !== 1/0 && _q$11 !== -1/0) ? _q$11 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)), p.CStride)) + (((_q$12 = x$4 / 4, (_q$12 === _q$12 && _q$12 !== 1/0 && _q$12 !== -1/0) ? _q$12 >> 0 : $throwRuntimeError("integer divide by zero")) - (_q$13 = p.Rect.Min.X / 4, (_q$13 === _q$13 && _q$13 !== 1/0 && _q$13 !== -1/0) ? _q$13 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)) >> 0;
		}
		return ($imul(((y - p.Rect.Min.Y >> 0)), p.CStride)) + ((x$4 - p.Rect.Min.X >> 0)) >> 0;
	};
	YCbCr.prototype.COffset = function(x$4, y) { return this.$val.COffset(x$4, y); };
	YCbCr.ptr.prototype.SubImage = function(r) {
		var ci, p, r, yi;
		p = this;
		Rectangle.copy(r, $clone(r, Rectangle).Intersect($clone(p.Rect, Rectangle)));
		if ($clone(r, Rectangle).Empty()) {
			return new YCbCr.ptr(sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, 0, p.SubsampleRatio, new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0)));
		}
		yi = p.YOffset(r.Min.X, r.Min.Y);
		ci = p.COffset(r.Min.X, r.Min.Y);
		return new YCbCr.ptr($subslice(p.Y, yi), $subslice(p.Cb, ci), $subslice(p.Cr, ci), p.YStride, p.CStride, p.SubsampleRatio, $clone(r, Rectangle));
	};
	YCbCr.prototype.SubImage = function(r) { return this.$val.SubImage(r); };
	YCbCr.ptr.prototype.Opaque = function() {
		var p;
		p = this;
		return true;
	};
	YCbCr.prototype.Opaque = function() { return this.$val.Opaque(); };
	Point.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Add", name: "Add", pkg: "", typ: $funcType([Point], [Point], false)}, {prop: "Sub", name: "Sub", pkg: "", typ: $funcType([Point], [Point], false)}, {prop: "Mul", name: "Mul", pkg: "", typ: $funcType([$Int], [Point], false)}, {prop: "Div", name: "Div", pkg: "", typ: $funcType([$Int], [Point], false)}, {prop: "In", name: "In", pkg: "", typ: $funcType([Rectangle], [$Bool], false)}, {prop: "Mod", name: "Mod", pkg: "", typ: $funcType([Rectangle], [Point], false)}, {prop: "Eq", name: "Eq", pkg: "", typ: $funcType([Point], [$Bool], false)}];
	Rectangle.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Dx", name: "Dx", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Dy", name: "Dy", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [Point], false)}, {prop: "Add", name: "Add", pkg: "", typ: $funcType([Point], [Rectangle], false)}, {prop: "Sub", name: "Sub", pkg: "", typ: $funcType([Point], [Rectangle], false)}, {prop: "Inset", name: "Inset", pkg: "", typ: $funcType([$Int], [Rectangle], false)}, {prop: "Intersect", name: "Intersect", pkg: "", typ: $funcType([Rectangle], [Rectangle], false)}, {prop: "Union", name: "Union", pkg: "", typ: $funcType([Rectangle], [Rectangle], false)}, {prop: "Empty", name: "Empty", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Eq", name: "Eq", pkg: "", typ: $funcType([Rectangle], [$Bool], false)}, {prop: "Overlaps", name: "Overlaps", pkg: "", typ: $funcType([Rectangle], [$Bool], false)}, {prop: "In", name: "In", pkg: "", typ: $funcType([Rectangle], [$Bool], false)}, {prop: "Canon", name: "Canon", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}];
	ptrType.methods = [{prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "RGBAAt", name: "RGBAAt", pkg: "", typ: $funcType([$Int, $Int], [color.RGBA], false)}, {prop: "PixOffset", name: "PixOffset", pkg: "", typ: $funcType([$Int, $Int], [$Int], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$Int, $Int, color.Color], [], false)}, {prop: "SetRGBA", name: "SetRGBA", pkg: "", typ: $funcType([$Int, $Int, color.RGBA], [], false)}, {prop: "SubImage", name: "SubImage", pkg: "", typ: $funcType([Rectangle], [Image], false)}, {prop: "Opaque", name: "Opaque", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$2.methods = [{prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "NRGBAAt", name: "NRGBAAt", pkg: "", typ: $funcType([$Int, $Int], [color.NRGBA], false)}, {prop: "PixOffset", name: "PixOffset", pkg: "", typ: $funcType([$Int, $Int], [$Int], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$Int, $Int, color.Color], [], false)}, {prop: "SetNRGBA", name: "SetNRGBA", pkg: "", typ: $funcType([$Int, $Int, color.NRGBA], [], false)}, {prop: "SubImage", name: "SubImage", pkg: "", typ: $funcType([Rectangle], [Image], false)}, {prop: "Opaque", name: "Opaque", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$4.methods = [{prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "AlphaAt", name: "AlphaAt", pkg: "", typ: $funcType([$Int, $Int], [color.Alpha], false)}, {prop: "PixOffset", name: "PixOffset", pkg: "", typ: $funcType([$Int, $Int], [$Int], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$Int, $Int, color.Color], [], false)}, {prop: "SetAlpha", name: "SetAlpha", pkg: "", typ: $funcType([$Int, $Int, color.Alpha], [], false)}, {prop: "SubImage", name: "SubImage", pkg: "", typ: $funcType([Rectangle], [Image], false)}, {prop: "Opaque", name: "Opaque", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$6.methods = [{prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "GrayAt", name: "GrayAt", pkg: "", typ: $funcType([$Int, $Int], [color.Gray], false)}, {prop: "PixOffset", name: "PixOffset", pkg: "", typ: $funcType([$Int, $Int], [$Int], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$Int, $Int, color.Color], [], false)}, {prop: "SetGray", name: "SetGray", pkg: "", typ: $funcType([$Int, $Int, color.Gray], [], false)}, {prop: "SubImage", name: "SubImage", pkg: "", typ: $funcType([Rectangle], [Image], false)}, {prop: "Opaque", name: "Opaque", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$8.methods = [{prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "CMYKAt", name: "CMYKAt", pkg: "", typ: $funcType([$Int, $Int], [color.CMYK], false)}, {prop: "PixOffset", name: "PixOffset", pkg: "", typ: $funcType([$Int, $Int], [$Int], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$Int, $Int, color.Color], [], false)}, {prop: "SetCMYK", name: "SetCMYK", pkg: "", typ: $funcType([$Int, $Int, color.CMYK], [], false)}, {prop: "SubImage", name: "SubImage", pkg: "", typ: $funcType([Rectangle], [Image], false)}, {prop: "Opaque", name: "Opaque", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$9.methods = [{prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "PixOffset", name: "PixOffset", pkg: "", typ: $funcType([$Int, $Int], [$Int], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$Int, $Int, color.Color], [], false)}, {prop: "ColorIndexAt", name: "ColorIndexAt", pkg: "", typ: $funcType([$Int, $Int], [$Uint8], false)}, {prop: "SetColorIndex", name: "SetColorIndex", pkg: "", typ: $funcType([$Int, $Int, $Uint8], [], false)}, {prop: "SubImage", name: "SubImage", pkg: "", typ: $funcType([Rectangle], [Image], false)}, {prop: "Opaque", name: "Opaque", pkg: "", typ: $funcType([], [$Bool], false)}];
	ptrType$10.methods = [{prop: "RGBA", name: "RGBA", pkg: "", typ: $funcType([], [$Uint32, $Uint32, $Uint32, $Uint32], false)}, {prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "Convert", name: "Convert", pkg: "", typ: $funcType([color.Color], [color.Color], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "Opaque", name: "Opaque", pkg: "", typ: $funcType([], [$Bool], false)}];
	YCbCrSubsampleRatio.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$11.methods = [{prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "YCbCrAt", name: "YCbCrAt", pkg: "", typ: $funcType([$Int, $Int], [color.YCbCr], false)}, {prop: "YOffset", name: "YOffset", pkg: "", typ: $funcType([$Int, $Int], [$Int], false)}, {prop: "COffset", name: "COffset", pkg: "", typ: $funcType([$Int, $Int], [$Int], false)}, {prop: "SubImage", name: "SubImage", pkg: "", typ: $funcType([Rectangle], [Image], false)}, {prop: "Opaque", name: "Opaque", pkg: "", typ: $funcType([], [$Bool], false)}];
	Point.init("", [{prop: "X", name: "X", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Y", name: "Y", embedded: false, exported: true, typ: $Int, tag: ""}]);
	Rectangle.init("", [{prop: "Min", name: "Min", embedded: false, exported: true, typ: Point, tag: ""}, {prop: "Max", name: "Max", embedded: false, exported: true, typ: Point, tag: ""}]);
	Image.init([{prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [Rectangle], false)}, {prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}]);
	RGBA.init("", [{prop: "Pix", name: "Pix", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Rect", name: "Rect", embedded: false, exported: true, typ: Rectangle, tag: ""}]);
	NRGBA.init("", [{prop: "Pix", name: "Pix", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Rect", name: "Rect", embedded: false, exported: true, typ: Rectangle, tag: ""}]);
	Alpha.init("", [{prop: "Pix", name: "Pix", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Rect", name: "Rect", embedded: false, exported: true, typ: Rectangle, tag: ""}]);
	Gray.init("", [{prop: "Pix", name: "Pix", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Rect", name: "Rect", embedded: false, exported: true, typ: Rectangle, tag: ""}]);
	CMYK.init("", [{prop: "Pix", name: "Pix", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Rect", name: "Rect", embedded: false, exported: true, typ: Rectangle, tag: ""}]);
	Paletted.init("", [{prop: "Pix", name: "Pix", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Rect", name: "Rect", embedded: false, exported: true, typ: Rectangle, tag: ""}, {prop: "Palette", name: "Palette", embedded: false, exported: true, typ: color.Palette, tag: ""}]);
	Uniform.init("", [{prop: "C", name: "C", embedded: false, exported: true, typ: color.Color, tag: ""}]);
	YCbCr.init("", [{prop: "Y", name: "Y", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "Cb", name: "Cb", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "Cr", name: "Cr", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "YStride", name: "YStride", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "CStride", name: "CStride", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "SubsampleRatio", name: "SubsampleRatio", embedded: false, exported: true, typ: YCbCrSubsampleRatio, tag: ""}, {prop: "Rect", name: "Rect", embedded: false, exported: true, typ: Rectangle, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bufio.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = color.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ZR = new Rectangle.ptr(new Point.ptr(0, 0), new Point.ptr(0, 0));
		$pkg.ErrFormat = errors.New("image: unknown format");
		$pkg.Black = NewUniform((x = color.Black, new x.constructor.elem(x)));
		$pkg.White = NewUniform((x$1 = color.White, new x$1.constructor.elem(x$1)));
		$pkg.Transparent = NewUniform((x$2 = color.Transparent, new x$2.constructor.elem(x$2)));
		$pkg.Opaque = NewUniform((x$3 = color.Opaque, new x$3.constructor.elem(x$3)));
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["image/internal/imageutil"] = (function() {
	var $pkg = {}, $init, image, DrawYCbCr;
	image = $packages["image"];
	DrawYCbCr = function(dst, r, src, sp) {
		var _1, _q, _q$1, _q$2, _q$3, _q$4, _q$5, _q$6, _q$7, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$29, _tmp$3, _tmp$30, _tmp$31, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, b, b$1, b$2, b$3, cb1, cb1$1, cb1$2, cb1$3, ci, ci$1, ci$2, ci$3, ciBase, ciBase$1, cr1, cr1$1, cr1$2, cr1$3, dpix, dpix$1, dpix$2, dpix$3, dst, g, g$1, g$2, g$3, ok, r, r$1, r$2, r$3, r$4, rgba, rgba$1, rgba$2, rgba$3, sp, src, sx, sx$1, sy, sy$1, sy$2, sy$3, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, x0, x1, y, y$1, y$2, y$3, y0, y1, yi, yi$1, yi$2, yi$3, yy1, yy1$1, yy1$2, yy1$3;
		ok = false;
		x0 = $imul(((r.Min.X - dst.Rect.Min.X >> 0)), 4);
		x1 = $imul(((r.Max.X - dst.Rect.Min.X >> 0)), 4);
		y0 = r.Min.Y - dst.Rect.Min.Y >> 0;
		y1 = r.Max.Y - dst.Rect.Min.Y >> 0;
		_1 = src.SubsampleRatio;
		if (_1 === (0)) {
			_tmp = y0;
			_tmp$1 = sp.Y;
			y = _tmp;
			sy = _tmp$1;
			while (true) {
				if (!(!((y === y1)))) { break; }
				dpix = $subslice(dst.Pix, ($imul(y, dst.Stride)));
				yi = ($imul(((sy - src.Rect.Min.Y >> 0)), src.YStride)) + ((sp.X - src.Rect.Min.X >> 0)) >> 0;
				ci = ($imul(((sy - src.Rect.Min.Y >> 0)), src.CStride)) + ((sp.X - src.Rect.Min.X >> 0)) >> 0;
				x = x0;
				while (true) {
					if (!(!((x === x1)))) { break; }
					yy1 = $imul((((x$1 = src.Y, ((yi < 0 || yi >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + yi])) >> 0)), 65793);
					cb1 = (((x$2 = src.Cb, ((ci < 0 || ci >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + ci])) >> 0)) - 128 >> 0;
					cr1 = (((x$3 = src.Cr, ((ci < 0 || ci >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + ci])) >> 0)) - 128 >> 0;
					r$1 = yy1 + ($imul(91881, cr1)) >> 0;
					if (((((r$1 >>> 0)) & 4278190080) >>> 0) === 0) {
						r$1 = (r$1 >> $min((16), 31)) >> 0;
					} else {
						r$1 = ~((r$1 >> 31 >> 0)) >> 0;
					}
					g = (yy1 - ($imul(22554, cb1)) >> 0) - ($imul(46802, cr1)) >> 0;
					if (((((g >>> 0)) & 4278190080) >>> 0) === 0) {
						g = (g >> $min((16), 31)) >> 0;
					} else {
						g = ~((g >> 31 >> 0)) >> 0;
					}
					b = yy1 + ($imul(116130, cb1)) >> 0;
					if (((((b >>> 0)) & 4278190080) >>> 0) === 0) {
						b = (b >> $min((16), 31)) >> 0;
					} else {
						b = ~((b >> 31 >> 0)) >> 0;
					}
					rgba = $subslice(dpix, x, (x + 4 >> 0), dpix.$length);
					(0 >= rgba.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba.$array[rgba.$offset + 0] = ((r$1 << 24 >>> 24)));
					(1 >= rgba.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba.$array[rgba.$offset + 1] = ((g << 24 >>> 24)));
					(2 >= rgba.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba.$array[rgba.$offset + 2] = ((b << 24 >>> 24)));
					(3 >= rgba.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba.$array[rgba.$offset + 3] = 255);
					_tmp$2 = x + 4 >> 0;
					_tmp$3 = yi + 1 >> 0;
					_tmp$4 = ci + 1 >> 0;
					x = _tmp$2;
					yi = _tmp$3;
					ci = _tmp$4;
				}
				_tmp$5 = y + 1 >> 0;
				_tmp$6 = sy + 1 >> 0;
				y = _tmp$5;
				sy = _tmp$6;
			}
		} else if (_1 === (1)) {
			_tmp$7 = y0;
			_tmp$8 = sp.Y;
			y$1 = _tmp$7;
			sy$1 = _tmp$8;
			while (true) {
				if (!(!((y$1 === y1)))) { break; }
				dpix$1 = $subslice(dst.Pix, ($imul(y$1, dst.Stride)));
				yi$1 = ($imul(((sy$1 - src.Rect.Min.Y >> 0)), src.YStride)) + ((sp.X - src.Rect.Min.X >> 0)) >> 0;
				ciBase = ($imul(((sy$1 - src.Rect.Min.Y >> 0)), src.CStride)) - (_q = src.Rect.Min.X / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
				_tmp$9 = x0;
				_tmp$10 = sp.X;
				x$4 = _tmp$9;
				sx = _tmp$10;
				while (true) {
					if (!(!((x$4 === x1)))) { break; }
					ci$1 = ciBase + (_q$1 = sx / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
					yy1$1 = $imul((((x$5 = src.Y, ((yi$1 < 0 || yi$1 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + yi$1])) >> 0)), 65793);
					cb1$1 = (((x$6 = src.Cb, ((ci$1 < 0 || ci$1 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + ci$1])) >> 0)) - 128 >> 0;
					cr1$1 = (((x$7 = src.Cr, ((ci$1 < 0 || ci$1 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + ci$1])) >> 0)) - 128 >> 0;
					r$2 = yy1$1 + ($imul(91881, cr1$1)) >> 0;
					if (((((r$2 >>> 0)) & 4278190080) >>> 0) === 0) {
						r$2 = (r$2 >> $min((16), 31)) >> 0;
					} else {
						r$2 = ~((r$2 >> 31 >> 0)) >> 0;
					}
					g$1 = (yy1$1 - ($imul(22554, cb1$1)) >> 0) - ($imul(46802, cr1$1)) >> 0;
					if (((((g$1 >>> 0)) & 4278190080) >>> 0) === 0) {
						g$1 = (g$1 >> $min((16), 31)) >> 0;
					} else {
						g$1 = ~((g$1 >> 31 >> 0)) >> 0;
					}
					b$1 = yy1$1 + ($imul(116130, cb1$1)) >> 0;
					if (((((b$1 >>> 0)) & 4278190080) >>> 0) === 0) {
						b$1 = (b$1 >> $min((16), 31)) >> 0;
					} else {
						b$1 = ~((b$1 >> 31 >> 0)) >> 0;
					}
					rgba$1 = $subslice(dpix$1, x$4, (x$4 + 4 >> 0), dpix$1.$length);
					(0 >= rgba$1.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$1.$array[rgba$1.$offset + 0] = ((r$2 << 24 >>> 24)));
					(1 >= rgba$1.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$1.$array[rgba$1.$offset + 1] = ((g$1 << 24 >>> 24)));
					(2 >= rgba$1.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$1.$array[rgba$1.$offset + 2] = ((b$1 << 24 >>> 24)));
					(3 >= rgba$1.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$1.$array[rgba$1.$offset + 3] = 255);
					_tmp$11 = x$4 + 4 >> 0;
					_tmp$12 = sx + 1 >> 0;
					_tmp$13 = yi$1 + 1 >> 0;
					x$4 = _tmp$11;
					sx = _tmp$12;
					yi$1 = _tmp$13;
				}
				_tmp$14 = y$1 + 1 >> 0;
				_tmp$15 = sy$1 + 1 >> 0;
				y$1 = _tmp$14;
				sy$1 = _tmp$15;
			}
		} else if (_1 === (2)) {
			_tmp$16 = y0;
			_tmp$17 = sp.Y;
			y$2 = _tmp$16;
			sy$2 = _tmp$17;
			while (true) {
				if (!(!((y$2 === y1)))) { break; }
				dpix$2 = $subslice(dst.Pix, ($imul(y$2, dst.Stride)));
				yi$2 = ($imul(((sy$2 - src.Rect.Min.Y >> 0)), src.YStride)) + ((sp.X - src.Rect.Min.X >> 0)) >> 0;
				ciBase$1 = ($imul((((_q$2 = sy$2 / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero")) - (_q$3 = src.Rect.Min.Y / 2, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)), src.CStride)) - (_q$4 = src.Rect.Min.X / 2, (_q$4 === _q$4 && _q$4 !== 1/0 && _q$4 !== -1/0) ? _q$4 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
				_tmp$18 = x0;
				_tmp$19 = sp.X;
				x$8 = _tmp$18;
				sx$1 = _tmp$19;
				while (true) {
					if (!(!((x$8 === x1)))) { break; }
					ci$2 = ciBase$1 + (_q$5 = sx$1 / 2, (_q$5 === _q$5 && _q$5 !== 1/0 && _q$5 !== -1/0) ? _q$5 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
					yy1$2 = $imul((((x$9 = src.Y, ((yi$2 < 0 || yi$2 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + yi$2])) >> 0)), 65793);
					cb1$2 = (((x$10 = src.Cb, ((ci$2 < 0 || ci$2 >= x$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + ci$2])) >> 0)) - 128 >> 0;
					cr1$2 = (((x$11 = src.Cr, ((ci$2 < 0 || ci$2 >= x$11.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$11.$array[x$11.$offset + ci$2])) >> 0)) - 128 >> 0;
					r$3 = yy1$2 + ($imul(91881, cr1$2)) >> 0;
					if (((((r$3 >>> 0)) & 4278190080) >>> 0) === 0) {
						r$3 = (r$3 >> $min((16), 31)) >> 0;
					} else {
						r$3 = ~((r$3 >> 31 >> 0)) >> 0;
					}
					g$2 = (yy1$2 - ($imul(22554, cb1$2)) >> 0) - ($imul(46802, cr1$2)) >> 0;
					if (((((g$2 >>> 0)) & 4278190080) >>> 0) === 0) {
						g$2 = (g$2 >> $min((16), 31)) >> 0;
					} else {
						g$2 = ~((g$2 >> 31 >> 0)) >> 0;
					}
					b$2 = yy1$2 + ($imul(116130, cb1$2)) >> 0;
					if (((((b$2 >>> 0)) & 4278190080) >>> 0) === 0) {
						b$2 = (b$2 >> $min((16), 31)) >> 0;
					} else {
						b$2 = ~((b$2 >> 31 >> 0)) >> 0;
					}
					rgba$2 = $subslice(dpix$2, x$8, (x$8 + 4 >> 0), dpix$2.$length);
					(0 >= rgba$2.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$2.$array[rgba$2.$offset + 0] = ((r$3 << 24 >>> 24)));
					(1 >= rgba$2.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$2.$array[rgba$2.$offset + 1] = ((g$2 << 24 >>> 24)));
					(2 >= rgba$2.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$2.$array[rgba$2.$offset + 2] = ((b$2 << 24 >>> 24)));
					(3 >= rgba$2.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$2.$array[rgba$2.$offset + 3] = 255);
					_tmp$20 = x$8 + 4 >> 0;
					_tmp$21 = sx$1 + 1 >> 0;
					_tmp$22 = yi$2 + 1 >> 0;
					x$8 = _tmp$20;
					sx$1 = _tmp$21;
					yi$2 = _tmp$22;
				}
				_tmp$23 = y$2 + 1 >> 0;
				_tmp$24 = sy$2 + 1 >> 0;
				y$2 = _tmp$23;
				sy$2 = _tmp$24;
			}
		} else if (_1 === (3)) {
			_tmp$25 = y0;
			_tmp$26 = sp.Y;
			y$3 = _tmp$25;
			sy$3 = _tmp$26;
			while (true) {
				if (!(!((y$3 === y1)))) { break; }
				dpix$3 = $subslice(dst.Pix, ($imul(y$3, dst.Stride)));
				yi$3 = ($imul(((sy$3 - src.Rect.Min.Y >> 0)), src.YStride)) + ((sp.X - src.Rect.Min.X >> 0)) >> 0;
				ci$3 = ($imul((((_q$6 = sy$3 / 2, (_q$6 === _q$6 && _q$6 !== 1/0 && _q$6 !== -1/0) ? _q$6 >> 0 : $throwRuntimeError("integer divide by zero")) - (_q$7 = src.Rect.Min.Y / 2, (_q$7 === _q$7 && _q$7 !== 1/0 && _q$7 !== -1/0) ? _q$7 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0)), src.CStride)) + ((sp.X - src.Rect.Min.X >> 0)) >> 0;
				x$12 = x0;
				while (true) {
					if (!(!((x$12 === x1)))) { break; }
					yy1$3 = $imul((((x$13 = src.Y, ((yi$3 < 0 || yi$3 >= x$13.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$13.$array[x$13.$offset + yi$3])) >> 0)), 65793);
					cb1$3 = (((x$14 = src.Cb, ((ci$3 < 0 || ci$3 >= x$14.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$14.$array[x$14.$offset + ci$3])) >> 0)) - 128 >> 0;
					cr1$3 = (((x$15 = src.Cr, ((ci$3 < 0 || ci$3 >= x$15.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$15.$array[x$15.$offset + ci$3])) >> 0)) - 128 >> 0;
					r$4 = yy1$3 + ($imul(91881, cr1$3)) >> 0;
					if (((((r$4 >>> 0)) & 4278190080) >>> 0) === 0) {
						r$4 = (r$4 >> $min((16), 31)) >> 0;
					} else {
						r$4 = ~((r$4 >> 31 >> 0)) >> 0;
					}
					g$3 = (yy1$3 - ($imul(22554, cb1$3)) >> 0) - ($imul(46802, cr1$3)) >> 0;
					if (((((g$3 >>> 0)) & 4278190080) >>> 0) === 0) {
						g$3 = (g$3 >> $min((16), 31)) >> 0;
					} else {
						g$3 = ~((g$3 >> 31 >> 0)) >> 0;
					}
					b$3 = yy1$3 + ($imul(116130, cb1$3)) >> 0;
					if (((((b$3 >>> 0)) & 4278190080) >>> 0) === 0) {
						b$3 = (b$3 >> $min((16), 31)) >> 0;
					} else {
						b$3 = ~((b$3 >> 31 >> 0)) >> 0;
					}
					rgba$3 = $subslice(dpix$3, x$12, (x$12 + 4 >> 0), dpix$3.$length);
					(0 >= rgba$3.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$3.$array[rgba$3.$offset + 0] = ((r$4 << 24 >>> 24)));
					(1 >= rgba$3.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$3.$array[rgba$3.$offset + 1] = ((g$3 << 24 >>> 24)));
					(2 >= rgba$3.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$3.$array[rgba$3.$offset + 2] = ((b$3 << 24 >>> 24)));
					(3 >= rgba$3.$length ? ($throwRuntimeError("index out of range"), undefined) : rgba$3.$array[rgba$3.$offset + 3] = 255);
					_tmp$27 = x$12 + 4 >> 0;
					_tmp$28 = yi$3 + 1 >> 0;
					_tmp$29 = ci$3 + 1 >> 0;
					x$12 = _tmp$27;
					yi$3 = _tmp$28;
					ci$3 = _tmp$29;
				}
				_tmp$30 = y$3 + 1 >> 0;
				_tmp$31 = sy$3 + 1 >> 0;
				y$3 = _tmp$30;
				sy$3 = _tmp$31;
			}
		} else {
			ok = false;
			return ok;
		}
		ok = true;
		return ok;
	};
	$pkg.DrawYCbCr = DrawYCbCr;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = image.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["image/draw"] = (function() {
	var $pkg = {}, $init, image, color, imageutil, Image, ptrType, ptrType$1, ptrType$2, ptrType$3, ptrType$4, ptrType$5, ptrType$6, ptrType$7, ptrType$8, ptrType$9, arrayType, sliceType, sliceType$1, clip, processBackward, Draw, DrawMask, drawFillOver, drawFillSrc, drawCopyOver, drawCopySrc, drawNRGBAOver, drawNRGBASrc, drawGray, drawCMYK, drawGlyphOver, drawRGBA, clamp, sqDiff, drawPaletted;
	image = $packages["image"];
	color = $packages["image/color"];
	imageutil = $packages["image/internal/imageutil"];
	Image = $pkg.Image = $newType(8, $kindInterface, "draw.Image", true, "image/draw", true, null);
	ptrType = $ptrType(image.Point);
	ptrType$1 = $ptrType(image.RGBA);
	ptrType$2 = $ptrType(image.Paletted);
	ptrType$3 = $ptrType(image.Uniform);
	ptrType$4 = $ptrType(image.NRGBA);
	ptrType$5 = $ptrType(image.YCbCr);
	ptrType$6 = $ptrType(image.Gray);
	ptrType$7 = $ptrType(image.CMYK);
	ptrType$8 = $ptrType(image.Alpha);
	ptrType$9 = $ptrType($Uint8);
	arrayType = $arrayType($Int32, 4);
	sliceType = $sliceType(arrayType);
	sliceType$1 = $sliceType($Uint8);
	clip = function(dst, r, src, sp, mask, mp) {
		var _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, dst, dx, dy, mask, mp, orig, r, sp, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; dst = $f.dst; dx = $f.dx; dy = $f.dy; mask = $f.mask; mp = $f.mp; orig = $f.orig; r = $f.r; sp = $f.sp; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		orig = $clone(r.Min, image.Point);
		_r = dst.Bounds(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = $clone(r, image.Rectangle).Intersect($clone(_r, image.Rectangle)); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		image.Rectangle.copy(r, _r$1);
		_r$2 = src.Bounds(); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$3 = $clone(_r$2, image.Rectangle).Add($clone($clone(orig, image.Point).Sub($clone(sp, image.Point)), image.Point)); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$4 = $clone(r, image.Rectangle).Intersect($clone(_r$3, image.Rectangle)); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		image.Rectangle.copy(r, _r$4);
		/* */ if (!($interfaceIsEqual(mask, $ifaceNil))) { $s = 6; continue; }
		/* */ $s = 7; continue;
		/* if (!($interfaceIsEqual(mask, $ifaceNil))) { */ case 6:
			_r$5 = mask.Bounds(); /* */ $s = 8; case 8: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			_r$6 = $clone(_r$5, image.Rectangle).Add($clone($clone(orig, image.Point).Sub($clone(mp, image.Point)), image.Point)); /* */ $s = 9; case 9: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_r$7 = $clone(r, image.Rectangle).Intersect($clone(_r$6, image.Rectangle)); /* */ $s = 10; case 10: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			image.Rectangle.copy(r, _r$7);
		/* } */ case 7:
		dx = r.Min.X - orig.X >> 0;
		dy = r.Min.Y - orig.Y >> 0;
		if ((dx === 0) && (dy === 0)) {
			$s = -1; return;
		}
		sp.X = sp.X + (dx) >> 0;
		sp.Y = sp.Y + (dy) >> 0;
		if (!(mp === ptrType.nil)) {
			mp.X = mp.X + (dx) >> 0;
			mp.Y = mp.Y + (dy) >> 0;
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: clip }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f.dst = dst; $f.dx = dx; $f.dy = dy; $f.mask = mask; $f.mp = mp; $f.orig = orig; $f.r = r; $f.sp = sp; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	processBackward = function(dst, r, src, sp) {
		var dst, r, sp, src;
		return $interfaceIsEqual((dst), src) && $clone(r, image.Rectangle).Overlaps($clone($clone(r, image.Rectangle).Add($clone($clone(sp, image.Point).Sub($clone(r.Min, image.Point)), image.Point)), image.Rectangle)) && (sp.Y < r.Min.Y || ((sp.Y === r.Min.Y) && sp.X < r.Min.X));
	};
	Draw = function(dst, r, src, sp, op) {
		var dst, op, r, sp, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; dst = $f.dst; op = $f.op; r = $f.r; sp = $f.sp; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = DrawMask(dst, $clone(r, image.Rectangle), src, $clone(sp, image.Point), $ifaceNil, new image.Point.ptr(0, 0), op); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Draw }; } $f.dst = dst; $f.op = op; $f.r = r; $f.sp = sp; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Draw = Draw;
	DrawMask = function(dst, r, src, sp, mask, mp, op) {
		var _arg, _arg$1, _arg$2, _q, _q$1, _q$2, _q$3, _q$4, _q$5, _q$6, _q$7, _q$8, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _ref, _ref$1, _ref$2, _ref$3, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, a, da, db, dg, dr, dst, dst0, dst0$1, dx, dy, ma, mask, mask0, mp, mx, my, ok, op, out, r, sa, sa$1, sa$2, sb, sb$1, sb$2, sg, sg$1, sg$2, sp, sr, sr$1, sr$2, src, src0, src0$1, src0$10, src0$11, src0$12, src0$2, src0$3, src0$4, src0$5, src0$6, src0$7, src0$8, src0$9, sx, sy, x$1, x$2, x0, x1, y, y0, y1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _q$3 = $f._q$3; _q$4 = $f._q$4; _q$5 = $f._q$5; _q$6 = $f._q$6; _q$7 = $f._q$7; _q$8 = $f._q$8; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _ref$3 = $f._ref$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; a = $f.a; da = $f.da; db = $f.db; dg = $f.dg; dr = $f.dr; dst = $f.dst; dst0 = $f.dst0; dst0$1 = $f.dst0$1; dx = $f.dx; dy = $f.dy; ma = $f.ma; mask = $f.mask; mask0 = $f.mask0; mp = $f.mp; mx = $f.mx; my = $f.my; ok = $f.ok; op = $f.op; out = $f.out; r = $f.r; sa = $f.sa; sa$1 = $f.sa$1; sa$2 = $f.sa$2; sb = $f.sb; sb$1 = $f.sb$1; sb$2 = $f.sb$2; sg = $f.sg; sg$1 = $f.sg$1; sg$2 = $f.sg$2; sp = $f.sp; sr = $f.sr; sr$1 = $f.sr$1; sr$2 = $f.sr$2; src = $f.src; src0 = $f.src0; src0$1 = $f.src0$1; src0$10 = $f.src0$10; src0$11 = $f.src0$11; src0$12 = $f.src0$12; src0$2 = $f.src0$2; src0$3 = $f.src0$3; src0$4 = $f.src0$4; src0$5 = $f.src0$5; src0$6 = $f.src0$6; src0$7 = $f.src0$7; src0$8 = $f.src0$8; src0$9 = $f.src0$9; sx = $f.sx; sy = $f.sy; x$1 = $f.x$1; x$2 = $f.x$2; x0 = $f.x0; x1 = $f.x1; y = $f.y; y0 = $f.y0; y1 = $f.y1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		mp = [mp];
		out = [out];
		r = [r];
		sp = [sp];
		$r = clip(dst, r[0], src, sp[0], mask, mp[0]); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if ($clone(r[0], image.Rectangle).Empty()) {
			$s = -1; return;
		}
		_ref = dst;
		/* */ if ($assertType(_ref, ptrType$1, true)[1]) { $s = 2; continue; }
		/* */ if ($assertType(_ref, ptrType$2, true)[1]) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if ($assertType(_ref, ptrType$1, true)[1]) { */ case 2:
			dst0 = _ref.$val;
			/* */ if (op === 0) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (op === 0) { */ case 5:
				/* */ if ($interfaceIsEqual(mask, $ifaceNil)) { $s = 8; continue; }
				/* */ $s = 9; continue;
				/* if ($interfaceIsEqual(mask, $ifaceNil)) { */ case 8:
					_ref$1 = src;
					/* */ if ($assertType(_ref$1, ptrType$3, true)[1]) { $s = 11; continue; }
					/* */ if ($assertType(_ref$1, ptrType$1, true)[1]) { $s = 12; continue; }
					/* */ if ($assertType(_ref$1, ptrType$4, true)[1]) { $s = 13; continue; }
					/* */ if ($assertType(_ref$1, ptrType$5, true)[1]) { $s = 14; continue; }
					/* */ if ($assertType(_ref$1, ptrType$6, true)[1]) { $s = 15; continue; }
					/* */ if ($assertType(_ref$1, ptrType$7, true)[1]) { $s = 16; continue; }
					/* */ $s = 17; continue;
					/* if ($assertType(_ref$1, ptrType$3, true)[1]) { */ case 11:
						src0 = _ref$1.$val;
						_r = src0.RGBA(); /* */ $s = 18; case 18: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						_tuple = _r;
						sr = _tuple[0];
						sg = _tuple[1];
						sb = _tuple[2];
						sa = _tuple[3];
						if (sa === 65535) {
							drawFillSrc(dst0, $clone(r[0], image.Rectangle), sr, sg, sb, sa);
						} else {
							drawFillOver(dst0, $clone(r[0], image.Rectangle), sr, sg, sb, sa);
						}
						$s = -1; return;
					/* } else if ($assertType(_ref$1, ptrType$1, true)[1]) { */ case 12:
						src0$1 = _ref$1.$val;
						drawCopyOver(dst0, $clone(r[0], image.Rectangle), src0$1, $clone(sp[0], image.Point));
						$s = -1; return;
					/* } else if ($assertType(_ref$1, ptrType$4, true)[1]) { */ case 13:
						src0$2 = _ref$1.$val;
						drawNRGBAOver(dst0, $clone(r[0], image.Rectangle), src0$2, $clone(sp[0], image.Point));
						$s = -1; return;
					/* } else if ($assertType(_ref$1, ptrType$5, true)[1]) { */ case 14:
						src0$3 = _ref$1.$val;
						if (imageutil.DrawYCbCr(dst0, $clone(r[0], image.Rectangle), src0$3, $clone(sp[0], image.Point))) {
							$s = -1; return;
						}
						$s = 17; continue;
					/* } else if ($assertType(_ref$1, ptrType$6, true)[1]) { */ case 15:
						src0$4 = _ref$1.$val;
						drawGray(dst0, $clone(r[0], image.Rectangle), src0$4, $clone(sp[0], image.Point));
						$s = -1; return;
					/* } else if ($assertType(_ref$1, ptrType$7, true)[1]) { */ case 16:
						src0$5 = _ref$1.$val;
						drawCMYK(dst0, $clone(r[0], image.Rectangle), src0$5, $clone(sp[0], image.Point));
						$s = -1; return;
					/* } */ case 17:
					$s = 10; continue;
				/* } else { */ case 9:
					_tuple$1 = $assertType(mask, ptrType$8, true);
					mask0 = _tuple$1[0];
					ok = _tuple$1[1];
					/* */ if (ok) { $s = 19; continue; }
					/* */ $s = 20; continue;
					/* if (ok) { */ case 19:
						_ref$2 = src;
						/* */ if ($assertType(_ref$2, ptrType$3, true)[1]) { $s = 21; continue; }
						/* */ $s = 22; continue;
						/* if ($assertType(_ref$2, ptrType$3, true)[1]) { */ case 21:
							src0$6 = _ref$2.$val;
							$r = drawGlyphOver(dst0, $clone(r[0], image.Rectangle), src0$6, mask0, $clone(mp[0], image.Point)); /* */ $s = 23; case 23: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return;
						/* } */ case 22:
					/* } */ case 20:
				/* } */ case 10:
				$s = 7; continue;
			/* } else { */ case 6:
				/* */ if ($interfaceIsEqual(mask, $ifaceNil)) { $s = 24; continue; }
				/* */ $s = 25; continue;
				/* if ($interfaceIsEqual(mask, $ifaceNil)) { */ case 24:
					_ref$3 = src;
					/* */ if ($assertType(_ref$3, ptrType$3, true)[1]) { $s = 26; continue; }
					/* */ if ($assertType(_ref$3, ptrType$1, true)[1]) { $s = 27; continue; }
					/* */ if ($assertType(_ref$3, ptrType$4, true)[1]) { $s = 28; continue; }
					/* */ if ($assertType(_ref$3, ptrType$5, true)[1]) { $s = 29; continue; }
					/* */ if ($assertType(_ref$3, ptrType$6, true)[1]) { $s = 30; continue; }
					/* */ if ($assertType(_ref$3, ptrType$7, true)[1]) { $s = 31; continue; }
					/* */ $s = 32; continue;
					/* if ($assertType(_ref$3, ptrType$3, true)[1]) { */ case 26:
						src0$7 = _ref$3.$val;
						_r$1 = src0$7.RGBA(); /* */ $s = 33; case 33: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						_tuple$2 = _r$1;
						sr$1 = _tuple$2[0];
						sg$1 = _tuple$2[1];
						sb$1 = _tuple$2[2];
						sa$1 = _tuple$2[3];
						drawFillSrc(dst0, $clone(r[0], image.Rectangle), sr$1, sg$1, sb$1, sa$1);
						$s = -1; return;
					/* } else if ($assertType(_ref$3, ptrType$1, true)[1]) { */ case 27:
						src0$8 = _ref$3.$val;
						drawCopySrc(dst0, $clone(r[0], image.Rectangle), src0$8, $clone(sp[0], image.Point));
						$s = -1; return;
					/* } else if ($assertType(_ref$3, ptrType$4, true)[1]) { */ case 28:
						src0$9 = _ref$3.$val;
						drawNRGBASrc(dst0, $clone(r[0], image.Rectangle), src0$9, $clone(sp[0], image.Point));
						$s = -1; return;
					/* } else if ($assertType(_ref$3, ptrType$5, true)[1]) { */ case 29:
						src0$10 = _ref$3.$val;
						if (imageutil.DrawYCbCr(dst0, $clone(r[0], image.Rectangle), src0$10, $clone(sp[0], image.Point))) {
							$s = -1; return;
						}
						$s = 32; continue;
					/* } else if ($assertType(_ref$3, ptrType$6, true)[1]) { */ case 30:
						src0$11 = _ref$3.$val;
						drawGray(dst0, $clone(r[0], image.Rectangle), src0$11, $clone(sp[0], image.Point));
						$s = -1; return;
					/* } else if ($assertType(_ref$3, ptrType$7, true)[1]) { */ case 31:
						src0$12 = _ref$3.$val;
						drawCMYK(dst0, $clone(r[0], image.Rectangle), src0$12, $clone(sp[0], image.Point));
						$s = -1; return;
					/* } */ case 32:
				/* } */ case 25:
			/* } */ case 7:
			$r = drawRGBA(dst0, $clone(r[0], image.Rectangle), src, $clone(sp[0], image.Point), mask, $clone(mp[0], image.Point), op); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return;
		/* } else if ($assertType(_ref, ptrType$2, true)[1]) { */ case 3:
			dst0$1 = _ref.$val;
			/* */ if ((op === 1) && $interfaceIsEqual(mask, $ifaceNil) && !processBackward(dst, $clone(r[0], image.Rectangle), src, $clone(sp[0], image.Point))) { $s = 35; continue; }
			/* */ $s = 36; continue;
			/* if ((op === 1) && $interfaceIsEqual(mask, $ifaceNil) && !processBackward(dst, $clone(r[0], image.Rectangle), src, $clone(sp[0], image.Point))) { */ case 35:
				$r = drawPaletted(dst0$1, $clone(r[0], image.Rectangle), src, $clone(sp[0], image.Point), false); /* */ $s = 37; case 37: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } */ case 36:
		/* } */ case 4:
		_tmp = r[0].Min.X;
		_tmp$1 = r[0].Max.X;
		_tmp$2 = 1;
		x0 = _tmp;
		x1 = _tmp$1;
		dx = _tmp$2;
		_tmp$3 = r[0].Min.Y;
		_tmp$4 = r[0].Max.Y;
		_tmp$5 = 1;
		y0 = _tmp$3;
		y1 = _tmp$4;
		dy = _tmp$5;
		if (processBackward(dst, $clone(r[0], image.Rectangle), src, $clone(sp[0], image.Point))) {
			_tmp$6 = x1 - 1 >> 0;
			_tmp$7 = x0 - 1 >> 0;
			_tmp$8 = -1;
			x0 = _tmp$6;
			x1 = _tmp$7;
			dx = _tmp$8;
			_tmp$9 = y1 - 1 >> 0;
			_tmp$10 = y0 - 1 >> 0;
			_tmp$11 = -1;
			y0 = _tmp$9;
			y1 = _tmp$10;
			dy = _tmp$11;
		}
		out[0] = new color.RGBA64.ptr(0, 0, 0, 0);
		sy = (sp[0].Y + y0 >> 0) - r[0].Min.Y >> 0;
		my = (mp[0].Y + y0 >> 0) - r[0].Min.Y >> 0;
		y = y0;
		/* while (true) { */ case 38:
			/* if (!(!((y === y1)))) { break; } */ if(!(!((y === y1)))) { $s = 39; continue; }
			sx = (sp[0].X + x0 >> 0) - r[0].Min.X >> 0;
			mx = (mp[0].X + x0 >> 0) - r[0].Min.X >> 0;
			x$1 = x0;
			/* while (true) { */ case 40:
				/* if (!(!((x$1 === x1)))) { break; } */ if(!(!((x$1 === x1)))) { $s = 41; continue; }
				ma = 65535;
				/* */ if (!($interfaceIsEqual(mask, $ifaceNil))) { $s = 42; continue; }
				/* */ $s = 43; continue;
				/* if (!($interfaceIsEqual(mask, $ifaceNil))) { */ case 42:
					_r$2 = mask.At(mx, my); /* */ $s = 44; case 44: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_r$3 = _r$2.RGBA(); /* */ $s = 45; case 45: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					_tuple$3 = _r$3;
					ma = _tuple$3[3];
				/* } */ case 43:
					/* */ if ((ma === 0)) { $s = 47; continue; }
					/* */ if ((ma === 65535) && (op === 1)) { $s = 48; continue; }
					/* */ $s = 49; continue;
					/* if ((ma === 0)) { */ case 47:
						/* */ if (op === 0) { $s = 51; continue; }
						/* */ $s = 52; continue;
						/* if (op === 0) { */ case 51:
							$s = 53; continue;
						/* } else { */ case 52:
							$r = dst.Set(x$1, y, (x$2 = color.Transparent, new x$2.constructor.elem(x$2))); /* */ $s = 54; case 54: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						/* } */ case 53:
						$s = 50; continue;
					/* } else if ((ma === 65535) && (op === 1)) { */ case 48:
						_arg = x$1;
						_arg$1 = y;
						_r$4 = src.At(sx, sy); /* */ $s = 55; case 55: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
						_arg$2 = _r$4;
						$r = dst.Set(_arg, _arg$1, _arg$2); /* */ $s = 56; case 56: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = 50; continue;
					/* } else { */ case 49:
						_r$5 = src.At(sx, sy); /* */ $s = 57; case 57: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
						_r$6 = _r$5.RGBA(); /* */ $s = 58; case 58: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
						_tuple$4 = _r$6;
						sr$2 = _tuple$4[0];
						sg$2 = _tuple$4[1];
						sb$2 = _tuple$4[2];
						sa$2 = _tuple$4[3];
						/* */ if (op === 0) { $s = 59; continue; }
						/* */ $s = 60; continue;
						/* if (op === 0) { */ case 59:
							_r$7 = dst.At(x$1, y); /* */ $s = 62; case 62: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
							_r$8 = _r$7.RGBA(); /* */ $s = 63; case 63: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
							_tuple$5 = _r$8;
							dr = _tuple$5[0];
							dg = _tuple$5[1];
							db = _tuple$5[2];
							da = _tuple$5[3];
							a = 65535 - ((_q = ($imul(sa$2, ma) >>> 0) / 65535, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"))) >>> 0;
							out[0].R = (((_q$1 = ((($imul(dr, a) >>> 0) + ($imul(sr$2, ma) >>> 0) >>> 0)) / 65535, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero")) << 16 >>> 16));
							out[0].G = (((_q$2 = ((($imul(dg, a) >>> 0) + ($imul(sg$2, ma) >>> 0) >>> 0)) / 65535, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero")) << 16 >>> 16));
							out[0].B = (((_q$3 = ((($imul(db, a) >>> 0) + ($imul(sb$2, ma) >>> 0) >>> 0)) / 65535, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >>> 0 : $throwRuntimeError("integer divide by zero")) << 16 >>> 16));
							out[0].A = (((_q$4 = ((($imul(da, a) >>> 0) + ($imul(sa$2, ma) >>> 0) >>> 0)) / 65535, (_q$4 === _q$4 && _q$4 !== 1/0 && _q$4 !== -1/0) ? _q$4 >>> 0 : $throwRuntimeError("integer divide by zero")) << 16 >>> 16));
							$s = 61; continue;
						/* } else { */ case 60:
							out[0].R = (((_q$5 = ($imul(sr$2, ma) >>> 0) / 65535, (_q$5 === _q$5 && _q$5 !== 1/0 && _q$5 !== -1/0) ? _q$5 >>> 0 : $throwRuntimeError("integer divide by zero")) << 16 >>> 16));
							out[0].G = (((_q$6 = ($imul(sg$2, ma) >>> 0) / 65535, (_q$6 === _q$6 && _q$6 !== 1/0 && _q$6 !== -1/0) ? _q$6 >>> 0 : $throwRuntimeError("integer divide by zero")) << 16 >>> 16));
							out[0].B = (((_q$7 = ($imul(sb$2, ma) >>> 0) / 65535, (_q$7 === _q$7 && _q$7 !== 1/0 && _q$7 !== -1/0) ? _q$7 >>> 0 : $throwRuntimeError("integer divide by zero")) << 16 >>> 16));
							out[0].A = (((_q$8 = ($imul(sa$2, ma) >>> 0) / 65535, (_q$8 === _q$8 && _q$8 !== 1/0 && _q$8 !== -1/0) ? _q$8 >>> 0 : $throwRuntimeError("integer divide by zero")) << 16 >>> 16));
						/* } */ case 61:
						$r = dst.Set(x$1, y, out[0]); /* */ $s = 64; case 64: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					/* } */ case 50:
				case 46:
				_tmp$12 = x$1 + dx >> 0;
				_tmp$13 = sx + dx >> 0;
				_tmp$14 = mx + dx >> 0;
				x$1 = _tmp$12;
				sx = _tmp$13;
				mx = _tmp$14;
			/* } */ $s = 40; continue; case 41:
			_tmp$15 = y + dy >> 0;
			_tmp$16 = sy + dy >> 0;
			_tmp$17 = my + dy >> 0;
			y = _tmp$15;
			sy = _tmp$16;
			my = _tmp$17;
		/* } */ $s = 38; continue; case 39:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: DrawMask }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._q$3 = _q$3; $f._q$4 = _q$4; $f._q$5 = _q$5; $f._q$6 = _q$6; $f._q$7 = _q$7; $f._q$8 = _q$8; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._ref$3 = _ref$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.a = a; $f.da = da; $f.db = db; $f.dg = dg; $f.dr = dr; $f.dst = dst; $f.dst0 = dst0; $f.dst0$1 = dst0$1; $f.dx = dx; $f.dy = dy; $f.ma = ma; $f.mask = mask; $f.mask0 = mask0; $f.mp = mp; $f.mx = mx; $f.my = my; $f.ok = ok; $f.op = op; $f.out = out; $f.r = r; $f.sa = sa; $f.sa$1 = sa$1; $f.sa$2 = sa$2; $f.sb = sb; $f.sb$1 = sb$1; $f.sb$2 = sb$2; $f.sg = sg; $f.sg$1 = sg$1; $f.sg$2 = sg$2; $f.sp = sp; $f.sr = sr; $f.sr$1 = sr$1; $f.sr$2 = sr$2; $f.src = src; $f.src0 = src0; $f.src0$1 = src0$1; $f.src0$10 = src0$10; $f.src0$11 = src0$11; $f.src0$12 = src0$12; $f.src0$2 = src0$2; $f.src0$3 = src0$3; $f.src0$4 = src0$4; $f.src0$5 = src0$5; $f.src0$6 = src0$6; $f.src0$7 = src0$7; $f.src0$8 = src0$8; $f.src0$9 = src0$9; $f.sx = sx; $f.sy = sy; $f.x$1 = x$1; $f.x$2 = x$2; $f.x0 = x0; $f.x1 = x1; $f.y = y; $f.y0 = y0; $f.y1 = y1; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.DrawMask = DrawMask;
	drawFillOver = function(dst, r, sr, sg, sb, sa) {
		var _q, _q$1, _q$2, _q$3, a, da, db, dg, dr, dst, i, i0, i1, r, sa, sb, sg, sr, x$1, x$2, x$3, x$4, y;
		a = $imul(((65535 - sa >>> 0)), 257) >>> 0;
		i0 = dst.PixOffset(r.Min.X, r.Min.Y);
		i1 = i0 + ($imul($clone(r, image.Rectangle).Dx(), 4)) >> 0;
		y = r.Min.Y;
		while (true) {
			if (!(!((y === r.Max.Y)))) { break; }
			i = i0;
			while (true) {
				if (!(i < i1)) { break; }
				dr = (x$1 = dst.Pix, $indexPtr(x$1.$array, x$1.$offset + (i + 0 >> 0), ptrType$9));
				dg = (x$2 = dst.Pix, $indexPtr(x$2.$array, x$2.$offset + (i + 1 >> 0), ptrType$9));
				db = (x$3 = dst.Pix, $indexPtr(x$3.$array, x$3.$offset + (i + 2 >> 0), ptrType$9));
				da = (x$4 = dst.Pix, $indexPtr(x$4.$array, x$4.$offset + (i + 3 >> 0), ptrType$9));
				dr.$set(((((((_q = ($imul(((dr.$get() >>> 0)), a) >>> 0) / 65535, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero")) + sr >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				dg.$set(((((((_q$1 = ($imul(((dg.$get() >>> 0)), a) >>> 0) / 65535, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero")) + sg >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				db.$set(((((((_q$2 = ($imul(((db.$get() >>> 0)), a) >>> 0) / 65535, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero")) + sb >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				da.$set(((((((_q$3 = ($imul(((da.$get() >>> 0)), a) >>> 0) / 65535, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >>> 0 : $throwRuntimeError("integer divide by zero")) + sa >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				i = i + (4) >> 0;
			}
			i0 = i0 + (dst.Stride) >> 0;
			i1 = i1 + (dst.Stride) >> 0;
			y = y + (1) >> 0;
		}
	};
	drawFillSrc = function(dst, r, sr, sg, sb, sa) {
		var dst, firstRow, i, i0, i1, r, sa, sa8, sb, sb8, sg, sg8, sr, sr8, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, y;
		sr8 = (((sr >>> 8 >>> 0) << 24 >>> 24));
		sg8 = (((sg >>> 8 >>> 0) << 24 >>> 24));
		sb8 = (((sb >>> 8 >>> 0) << 24 >>> 24));
		sa8 = (((sa >>> 8 >>> 0) << 24 >>> 24));
		i0 = dst.PixOffset(r.Min.X, r.Min.Y);
		i1 = i0 + ($imul($clone(r, image.Rectangle).Dx(), 4)) >> 0;
		i = i0;
		while (true) {
			if (!(i < i1)) { break; }
			(x$1 = dst.Pix, x$2 = i + 0 >> 0, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2] = sr8));
			(x$3 = dst.Pix, x$4 = i + 1 >> 0, ((x$4 < 0 || x$4 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + x$4] = sg8));
			(x$5 = dst.Pix, x$6 = i + 2 >> 0, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6] = sb8));
			(x$7 = dst.Pix, x$8 = i + 3 >> 0, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8] = sa8));
			i = i + (4) >> 0;
		}
		firstRow = $subslice(dst.Pix, i0, i1);
		y = r.Min.Y + 1 >> 0;
		while (true) {
			if (!(y < r.Max.Y)) { break; }
			i0 = i0 + (dst.Stride) >> 0;
			i1 = i1 + (dst.Stride) >> 0;
			$copySlice($subslice(dst.Pix, i0, i1), firstRow);
			y = y + (1) >> 0;
		}
	};
	drawCopyOver = function(dst, r, src, sp) {
		var _q, _q$1, _q$2, _q$3, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, a, d, d0, ddelta, dpix, dst, dx, dy, i, i0, i1, idelta, r, s, s0, sa, sb, sdelta, sg, sp, spix, sr, src;
		_tmp = $clone(r, image.Rectangle).Dx();
		_tmp$1 = $clone(r, image.Rectangle).Dy();
		dx = _tmp;
		dy = _tmp$1;
		d0 = dst.PixOffset(r.Min.X, r.Min.Y);
		s0 = src.PixOffset(sp.X, sp.Y);
		_tmp$2 = 0;
		_tmp$3 = 0;
		ddelta = _tmp$2;
		sdelta = _tmp$3;
		_tmp$4 = 0;
		_tmp$5 = 0;
		_tmp$6 = 0;
		i0 = _tmp$4;
		i1 = _tmp$5;
		idelta = _tmp$6;
		if (r.Min.Y < sp.Y || (r.Min.Y === sp.Y) && r.Min.X <= sp.X) {
			ddelta = dst.Stride;
			sdelta = src.Stride;
			_tmp$7 = 0;
			_tmp$8 = $imul(dx, 4);
			_tmp$9 = 4;
			i0 = _tmp$7;
			i1 = _tmp$8;
			idelta = _tmp$9;
		} else {
			d0 = d0 + (($imul(((dy - 1 >> 0)), dst.Stride))) >> 0;
			s0 = s0 + (($imul(((dy - 1 >> 0)), src.Stride))) >> 0;
			ddelta = -dst.Stride;
			sdelta = -src.Stride;
			_tmp$10 = $imul(((dx - 1 >> 0)), 4);
			_tmp$11 = -4;
			_tmp$12 = -4;
			i0 = _tmp$10;
			i1 = _tmp$11;
			idelta = _tmp$12;
		}
		while (true) {
			if (!(dy > 0)) { break; }
			dpix = $subslice(dst.Pix, d0);
			spix = $subslice(src.Pix, s0);
			i = i0;
			while (true) {
				if (!(!((i === i1)))) { break; }
				s = $subslice(spix, i, (i + 4 >> 0), (i + 4 >> 0));
				sr = $imul((((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]) >>> 0)), 257) >>> 0;
				sg = $imul((((1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1]) >>> 0)), 257) >>> 0;
				sb = $imul((((2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2]) >>> 0)), 257) >>> 0;
				sa = $imul((((3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3]) >>> 0)), 257) >>> 0;
				a = $imul(((65535 - sa >>> 0)), 257) >>> 0;
				d = $subslice(dpix, i, (i + 4 >> 0), (i + 4 >> 0));
				(0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0] = ((((((_q = ($imul((((0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0]) >>> 0)), a) >>> 0) / 65535, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero")) + sr >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				(1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1] = ((((((_q$1 = ($imul((((1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1]) >>> 0)), a) >>> 0) / 65535, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero")) + sg >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				(2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2] = ((((((_q$2 = ($imul((((2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2]) >>> 0)), a) >>> 0) / 65535, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero")) + sb >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				(3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3] = ((((((_q$3 = ($imul((((3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3]) >>> 0)), a) >>> 0) / 65535, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >>> 0 : $throwRuntimeError("integer divide by zero")) + sa >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				i = i + (idelta) >> 0;
			}
			d0 = d0 + (ddelta) >> 0;
			s0 = s0 + (sdelta) >> 0;
			dy = dy - (1) >> 0;
		}
	};
	drawCopySrc = function(dst, r, src, sp) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, d0, ddelta, dst, dy, n, r, s0, sdelta, sp, src;
		_tmp = $imul(4, $clone(r, image.Rectangle).Dx());
		_tmp$1 = $clone(r, image.Rectangle).Dy();
		n = _tmp;
		dy = _tmp$1;
		d0 = dst.PixOffset(r.Min.X, r.Min.Y);
		s0 = src.PixOffset(sp.X, sp.Y);
		_tmp$2 = 0;
		_tmp$3 = 0;
		ddelta = _tmp$2;
		sdelta = _tmp$3;
		if (r.Min.Y <= sp.Y) {
			ddelta = dst.Stride;
			sdelta = src.Stride;
		} else {
			d0 = d0 + (($imul(((dy - 1 >> 0)), dst.Stride))) >> 0;
			s0 = s0 + (($imul(((dy - 1 >> 0)), src.Stride))) >> 0;
			ddelta = -dst.Stride;
			sdelta = -src.Stride;
		}
		while (true) {
			if (!(dy > 0)) { break; }
			$copySlice($subslice(dst.Pix, d0, (d0 + n >> 0)), $subslice(src.Pix, s0, (s0 + n >> 0)));
			d0 = d0 + (ddelta) >> 0;
			s0 = s0 + (sdelta) >> 0;
			dy = dy - (1) >> 0;
		}
	};
	drawNRGBAOver = function(dst, r, src, sp) {
		var _q, _q$1, _q$2, _q$3, _q$4, _q$5, _q$6, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, a, d, da, db, dg, dpix, dr, dst, i, i0, i1, r, s, sa, sb, sg, si, si0, sp, spix, sr, src, sy, y, yMax;
		i0 = $imul(((r.Min.X - dst.Rect.Min.X >> 0)), 4);
		i1 = $imul(((r.Max.X - dst.Rect.Min.X >> 0)), 4);
		si0 = $imul(((sp.X - src.Rect.Min.X >> 0)), 4);
		yMax = r.Max.Y - dst.Rect.Min.Y >> 0;
		y = r.Min.Y - dst.Rect.Min.Y >> 0;
		sy = sp.Y - src.Rect.Min.Y >> 0;
		while (true) {
			if (!(!((y === yMax)))) { break; }
			dpix = $subslice(dst.Pix, ($imul(y, dst.Stride)));
			spix = $subslice(src.Pix, ($imul(sy, src.Stride)));
			_tmp = i0;
			_tmp$1 = si0;
			i = _tmp;
			si = _tmp$1;
			while (true) {
				if (!(i < i1)) { break; }
				s = $subslice(spix, si, (si + 4 >> 0), (si + 4 >> 0));
				sa = $imul((((3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3]) >>> 0)), 257) >>> 0;
				sr = (_q = ($imul((((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]) >>> 0)), sa) >>> 0) / 255, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
				sg = (_q$1 = ($imul((((1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1]) >>> 0)), sa) >>> 0) / 255, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
				sb = (_q$2 = ($imul((((2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2]) >>> 0)), sa) >>> 0) / 255, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero"));
				d = $subslice(dpix, i, (i + 4 >> 0), (i + 4 >> 0));
				dr = (((0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0]) >>> 0));
				dg = (((1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1]) >>> 0));
				db = (((2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2]) >>> 0));
				da = (((3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3]) >>> 0));
				a = $imul(((65535 - sa >>> 0)), 257) >>> 0;
				(0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0] = ((((((_q$3 = ($imul(dr, a) >>> 0) / 65535, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >>> 0 : $throwRuntimeError("integer divide by zero")) + sr >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				(1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1] = ((((((_q$4 = ($imul(dg, a) >>> 0) / 65535, (_q$4 === _q$4 && _q$4 !== 1/0 && _q$4 !== -1/0) ? _q$4 >>> 0 : $throwRuntimeError("integer divide by zero")) + sg >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				(2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2] = ((((((_q$5 = ($imul(db, a) >>> 0) / 65535, (_q$5 === _q$5 && _q$5 !== 1/0 && _q$5 !== -1/0) ? _q$5 >>> 0 : $throwRuntimeError("integer divide by zero")) + sb >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				(3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3] = ((((((_q$6 = ($imul(da, a) >>> 0) / 65535, (_q$6 === _q$6 && _q$6 !== 1/0 && _q$6 !== -1/0) ? _q$6 >>> 0 : $throwRuntimeError("integer divide by zero")) + sa >>> 0)) >>> 8 >>> 0) << 24 >>> 24)));
				_tmp$2 = i + 4 >> 0;
				_tmp$3 = si + 4 >> 0;
				i = _tmp$2;
				si = _tmp$3;
			}
			_tmp$4 = y + 1 >> 0;
			_tmp$5 = sy + 1 >> 0;
			y = _tmp$4;
			sy = _tmp$5;
		}
	};
	drawNRGBASrc = function(dst, r, src, sp) {
		var _q, _q$1, _q$2, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, d, dpix, dst, i, i0, i1, r, s, sa, sb, sg, si, si0, sp, spix, sr, src, sy, y, yMax;
		i0 = $imul(((r.Min.X - dst.Rect.Min.X >> 0)), 4);
		i1 = $imul(((r.Max.X - dst.Rect.Min.X >> 0)), 4);
		si0 = $imul(((sp.X - src.Rect.Min.X >> 0)), 4);
		yMax = r.Max.Y - dst.Rect.Min.Y >> 0;
		y = r.Min.Y - dst.Rect.Min.Y >> 0;
		sy = sp.Y - src.Rect.Min.Y >> 0;
		while (true) {
			if (!(!((y === yMax)))) { break; }
			dpix = $subslice(dst.Pix, ($imul(y, dst.Stride)));
			spix = $subslice(src.Pix, ($imul(sy, src.Stride)));
			_tmp = i0;
			_tmp$1 = si0;
			i = _tmp;
			si = _tmp$1;
			while (true) {
				if (!(i < i1)) { break; }
				s = $subslice(spix, si, (si + 4 >> 0), (si + 4 >> 0));
				sa = $imul((((3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3]) >>> 0)), 257) >>> 0;
				sr = (_q = ($imul((((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]) >>> 0)), sa) >>> 0) / 255, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
				sg = (_q$1 = ($imul((((1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1]) >>> 0)), sa) >>> 0) / 255, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
				sb = (_q$2 = ($imul((((2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2]) >>> 0)), sa) >>> 0) / 255, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero"));
				d = $subslice(dpix, i, (i + 4 >> 0), (i + 4 >> 0));
				(0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0] = (((sr >>> 8 >>> 0) << 24 >>> 24)));
				(1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1] = (((sg >>> 8 >>> 0) << 24 >>> 24)));
				(2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2] = (((sb >>> 8 >>> 0) << 24 >>> 24)));
				(3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3] = (((sa >>> 8 >>> 0) << 24 >>> 24)));
				_tmp$2 = i + 4 >> 0;
				_tmp$3 = si + 4 >> 0;
				i = _tmp$2;
				si = _tmp$3;
			}
			_tmp$4 = y + 1 >> 0;
			_tmp$5 = sy + 1 >> 0;
			y = _tmp$4;
			sy = _tmp$5;
		}
	};
	drawGray = function(dst, r, src, sp) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, d, dpix, dst, i, i0, i1, p, r, si, si0, sp, spix, src, sy, y, yMax;
		i0 = $imul(((r.Min.X - dst.Rect.Min.X >> 0)), 4);
		i1 = $imul(((r.Max.X - dst.Rect.Min.X >> 0)), 4);
		si0 = $imul(((sp.X - src.Rect.Min.X >> 0)), 1);
		yMax = r.Max.Y - dst.Rect.Min.Y >> 0;
		y = r.Min.Y - dst.Rect.Min.Y >> 0;
		sy = sp.Y - src.Rect.Min.Y >> 0;
		while (true) {
			if (!(!((y === yMax)))) { break; }
			dpix = $subslice(dst.Pix, ($imul(y, dst.Stride)));
			spix = $subslice(src.Pix, ($imul(sy, src.Stride)));
			_tmp = i0;
			_tmp$1 = si0;
			i = _tmp;
			si = _tmp$1;
			while (true) {
				if (!(i < i1)) { break; }
				p = ((si < 0 || si >= spix.$length) ? ($throwRuntimeError("index out of range"), undefined) : spix.$array[spix.$offset + si]);
				d = $subslice(dpix, i, (i + 4 >> 0), (i + 4 >> 0));
				(0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0] = p);
				(1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1] = p);
				(2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2] = p);
				(3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3] = 255);
				_tmp$2 = i + 4 >> 0;
				_tmp$3 = si + 1 >> 0;
				i = _tmp$2;
				si = _tmp$3;
			}
			_tmp$4 = y + 1 >> 0;
			_tmp$5 = sy + 1 >> 0;
			y = _tmp$4;
			sy = _tmp$5;
		}
	};
	drawCMYK = function(dst, r, src, sp) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, d, dpix, dst, i, i0, i1, r, s, si, si0, sp, spix, src, sy, y, yMax;
		i0 = $imul(((r.Min.X - dst.Rect.Min.X >> 0)), 4);
		i1 = $imul(((r.Max.X - dst.Rect.Min.X >> 0)), 4);
		si0 = $imul(((sp.X - src.Rect.Min.X >> 0)), 4);
		yMax = r.Max.Y - dst.Rect.Min.Y >> 0;
		y = r.Min.Y - dst.Rect.Min.Y >> 0;
		sy = sp.Y - src.Rect.Min.Y >> 0;
		while (true) {
			if (!(!((y === yMax)))) { break; }
			dpix = $subslice(dst.Pix, ($imul(y, dst.Stride)));
			spix = $subslice(src.Pix, ($imul(sy, src.Stride)));
			_tmp = i0;
			_tmp$1 = si0;
			i = _tmp;
			si = _tmp$1;
			while (true) {
				if (!(i < i1)) { break; }
				s = $subslice(spix, si, (si + 4 >> 0), (si + 4 >> 0));
				d = $subslice(dpix, i, (i + 4 >> 0), (i + 4 >> 0));
				_tuple = color.CMYKToRGB((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]), (1 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 1]), (2 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 2]), (3 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 3]));
				(0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0] = _tuple[0]);
				(1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1] = _tuple[1]);
				(2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2] = _tuple[2]);
				(3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3] = 255);
				_tmp$2 = i + 4 >> 0;
				_tmp$3 = si + 4 >> 0;
				i = _tmp$2;
				si = _tmp$3;
			}
			_tmp$4 = y + 1 >> 0;
			_tmp$5 = sy + 1 >> 0;
			y = _tmp$4;
			sy = _tmp$5;
		}
	};
	drawGlyphOver = function(dst, r, src, mask, mp) {
		var _q, _q$1, _q$2, _q$3, _q$4, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, a, d, dst, i, i0, i1, ma, mask, mi, mi0, mp, my, r, sa, sb, sg, sr, src, x$1, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _q$3 = $f._q$3; _q$4 = $f._q$4; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; a = $f.a; d = $f.d; dst = $f.dst; i = $f.i; i0 = $f.i0; i1 = $f.i1; ma = $f.ma; mask = $f.mask; mi = $f.mi; mi0 = $f.mi0; mp = $f.mp; my = $f.my; r = $f.r; sa = $f.sa; sb = $f.sb; sg = $f.sg; sr = $f.sr; src = $f.src; x$1 = $f.x$1; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i0 = dst.PixOffset(r.Min.X, r.Min.Y);
		i1 = i0 + ($imul($clone(r, image.Rectangle).Dx(), 4)) >> 0;
		mi0 = mask.PixOffset(mp.X, mp.Y);
		_r = src.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		sr = _tuple[0];
		sg = _tuple[1];
		sb = _tuple[2];
		sa = _tuple[3];
		_tmp = r.Min.Y;
		_tmp$1 = mp.Y;
		y = _tmp;
		my = _tmp$1;
		while (true) {
			if (!(!((y === r.Max.Y)))) { break; }
			_tmp$2 = i0;
			_tmp$3 = mi0;
			i = _tmp$2;
			mi = _tmp$3;
			while (true) {
				if (!(i < i1)) { break; }
				ma = (((x$1 = mask.Pix, ((mi < 0 || mi >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + mi])) >>> 0));
				if (ma === 0) {
					_tmp$4 = i + 4 >> 0;
					_tmp$5 = mi + 1 >> 0;
					i = _tmp$4;
					mi = _tmp$5;
					continue;
				}
				ma = (ma | ((ma << 8 >>> 0))) >>> 0;
				a = $imul(((65535 - ((_q = ($imul(sa, ma) >>> 0) / 65535, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"))) >>> 0)), 257) >>> 0;
				d = $subslice(dst.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
				(0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0] = ((((_q$1 = ((($imul((((0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0]) >>> 0)), a) >>> 0) + ($imul(sr, ma) >>> 0) >>> 0)) / 65535, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
				(1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1] = ((((_q$2 = ((($imul((((1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1]) >>> 0)), a) >>> 0) + ($imul(sg, ma) >>> 0) >>> 0)) / 65535, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
				(2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2] = ((((_q$3 = ((($imul((((2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2]) >>> 0)), a) >>> 0) + ($imul(sb, ma) >>> 0) >>> 0)) / 65535, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
				(3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3] = ((((_q$4 = ((($imul((((3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3]) >>> 0)), a) >>> 0) + ($imul(sa, ma) >>> 0) >>> 0)) / 65535, (_q$4 === _q$4 && _q$4 !== 1/0 && _q$4 !== -1/0) ? _q$4 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
				_tmp$6 = i + 4 >> 0;
				_tmp$7 = mi + 1 >> 0;
				i = _tmp$6;
				mi = _tmp$7;
			}
			i0 = i0 + (dst.Stride) >> 0;
			i1 = i1 + (dst.Stride) >> 0;
			mi0 = mi0 + (mask.Stride) >> 0;
			_tmp$8 = y + 1 >> 0;
			_tmp$9 = my + 1 >> 0;
			y = _tmp$8;
			my = _tmp$9;
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: drawGlyphOver }; } $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._q$3 = _q$3; $f._q$4 = _q$4; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f.a = a; $f.d = d; $f.dst = dst; $f.i = i; $f.i0 = i0; $f.i1 = i1; $f.ma = ma; $f.mask = mask; $f.mi = mi; $f.mi0 = mi0; $f.mp = mp; $f.my = my; $f.r = r; $f.sa = sa; $f.sb = sb; $f.sg = sg; $f.sr = sr; $f.src = src; $f.x$1 = x$1; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	drawRGBA = function(dst, r, src, sp, mask, mp, op) {
		var _q, _q$1, _q$2, _q$3, _q$4, _q$5, _q$6, _q$7, _q$8, _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, a, d, da, db, dg, di, dr, dst, dx, dy, i, i0, ma, mask, mp, mx, mx0, my, op, r, sa, sb, sg, sp, sr, src, sx, sx0, sx1, sy, x0, x1, y, y0, y1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _q$3 = $f._q$3; _q$4 = $f._q$4; _q$5 = $f._q$5; _q$6 = $f._q$6; _q$7 = $f._q$7; _q$8 = $f._q$8; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$18 = $f._tmp$18; _tmp$19 = $f._tmp$19; _tmp$2 = $f._tmp$2; _tmp$20 = $f._tmp$20; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; d = $f.d; da = $f.da; db = $f.db; dg = $f.dg; di = $f.di; dr = $f.dr; dst = $f.dst; dx = $f.dx; dy = $f.dy; i = $f.i; i0 = $f.i0; ma = $f.ma; mask = $f.mask; mp = $f.mp; mx = $f.mx; mx0 = $f.mx0; my = $f.my; op = $f.op; r = $f.r; sa = $f.sa; sb = $f.sb; sg = $f.sg; sp = $f.sp; sr = $f.sr; src = $f.src; sx = $f.sx; sx0 = $f.sx0; sx1 = $f.sx1; sy = $f.sy; x0 = $f.x0; x1 = $f.x1; y = $f.y; y0 = $f.y0; y1 = $f.y1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tmp = r.Min.X;
		_tmp$1 = r.Max.X;
		_tmp$2 = 1;
		x0 = _tmp;
		x1 = _tmp$1;
		dx = _tmp$2;
		_tmp$3 = r.Min.Y;
		_tmp$4 = r.Max.Y;
		_tmp$5 = 1;
		y0 = _tmp$3;
		y1 = _tmp$4;
		dy = _tmp$5;
		if ($interfaceIsEqual((dst), src) && $clone(r, image.Rectangle).Overlaps($clone($clone(r, image.Rectangle).Add($clone($clone(sp, image.Point).Sub($clone(r.Min, image.Point)), image.Point)), image.Rectangle))) {
			if (sp.Y < r.Min.Y || (sp.Y === r.Min.Y) && sp.X < r.Min.X) {
				_tmp$6 = x1 - 1 >> 0;
				_tmp$7 = x0 - 1 >> 0;
				_tmp$8 = -1;
				x0 = _tmp$6;
				x1 = _tmp$7;
				dx = _tmp$8;
				_tmp$9 = y1 - 1 >> 0;
				_tmp$10 = y0 - 1 >> 0;
				_tmp$11 = -1;
				y0 = _tmp$9;
				y1 = _tmp$10;
				dy = _tmp$11;
			}
		}
		sy = (sp.Y + y0 >> 0) - r.Min.Y >> 0;
		my = (mp.Y + y0 >> 0) - r.Min.Y >> 0;
		sx0 = (sp.X + x0 >> 0) - r.Min.X >> 0;
		mx0 = (mp.X + x0 >> 0) - r.Min.X >> 0;
		sx1 = sx0 + ((x1 - x0 >> 0)) >> 0;
		i0 = dst.PixOffset(x0, y0);
		di = $imul(dx, 4);
		y = y0;
		/* while (true) { */ case 1:
			/* if (!(!((y === y1)))) { break; } */ if(!(!((y === y1)))) { $s = 2; continue; }
			_tmp$12 = i0;
			_tmp$13 = sx0;
			_tmp$14 = mx0;
			i = _tmp$12;
			sx = _tmp$13;
			mx = _tmp$14;
			/* while (true) { */ case 3:
				/* if (!(!((sx === sx1)))) { break; } */ if(!(!((sx === sx1)))) { $s = 4; continue; }
				ma = 65535;
				/* */ if (!($interfaceIsEqual(mask, $ifaceNil))) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (!($interfaceIsEqual(mask, $ifaceNil))) { */ case 5:
					_r = mask.At(mx, my); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					_r$1 = _r.RGBA(); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_tuple = _r$1;
					ma = _tuple[3];
				/* } */ case 6:
				_r$2 = src.At(sx, sy); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$3 = _r$2.RGBA(); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				_tuple$1 = _r$3;
				sr = _tuple$1[0];
				sg = _tuple$1[1];
				sb = _tuple$1[2];
				sa = _tuple$1[3];
				d = $subslice(dst.Pix, i, (i + 4 >> 0), (i + 4 >> 0));
				if (op === 0) {
					dr = (((0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0]) >>> 0));
					dg = (((1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1]) >>> 0));
					db = (((2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2]) >>> 0));
					da = (((3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3]) >>> 0));
					a = $imul(((65535 - ((_q = ($imul(sa, ma) >>> 0) / 65535, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"))) >>> 0)), 257) >>> 0;
					(0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0] = ((((_q$1 = ((($imul(dr, a) >>> 0) + ($imul(sr, ma) >>> 0) >>> 0)) / 65535, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
					(1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1] = ((((_q$2 = ((($imul(dg, a) >>> 0) + ($imul(sg, ma) >>> 0) >>> 0)) / 65535, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
					(2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2] = ((((_q$3 = ((($imul(db, a) >>> 0) + ($imul(sb, ma) >>> 0) >>> 0)) / 65535, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
					(3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3] = ((((_q$4 = ((($imul(da, a) >>> 0) + ($imul(sa, ma) >>> 0) >>> 0)) / 65535, (_q$4 === _q$4 && _q$4 !== 1/0 && _q$4 !== -1/0) ? _q$4 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
				} else {
					(0 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 0] = ((((_q$5 = ($imul(sr, ma) >>> 0) / 65535, (_q$5 === _q$5 && _q$5 !== 1/0 && _q$5 !== -1/0) ? _q$5 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
					(1 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 1] = ((((_q$6 = ($imul(sg, ma) >>> 0) / 65535, (_q$6 === _q$6 && _q$6 !== 1/0 && _q$6 !== -1/0) ? _q$6 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
					(2 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 2] = ((((_q$7 = ($imul(sb, ma) >>> 0) / 65535, (_q$7 === _q$7 && _q$7 !== 1/0 && _q$7 !== -1/0) ? _q$7 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
					(3 >= d.$length ? ($throwRuntimeError("index out of range"), undefined) : d.$array[d.$offset + 3] = ((((_q$8 = ($imul(sa, ma) >>> 0) / 65535, (_q$8 === _q$8 && _q$8 !== 1/0 && _q$8 !== -1/0) ? _q$8 >>> 0 : $throwRuntimeError("integer divide by zero")) >>> 8 >>> 0) << 24 >>> 24)));
				}
				_tmp$15 = i + di >> 0;
				_tmp$16 = sx + dx >> 0;
				_tmp$17 = mx + dx >> 0;
				i = _tmp$15;
				sx = _tmp$16;
				mx = _tmp$17;
			/* } */ $s = 3; continue; case 4:
			i0 = i0 + (($imul(dy, dst.Stride))) >> 0;
			_tmp$18 = y + dy >> 0;
			_tmp$19 = sy + dy >> 0;
			_tmp$20 = my + dy >> 0;
			y = _tmp$18;
			sy = _tmp$19;
			my = _tmp$20;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: drawRGBA }; } $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._q$3 = _q$3; $f._q$4 = _q$4; $f._q$5 = _q$5; $f._q$6 = _q$6; $f._q$7 = _q$7; $f._q$8 = _q$8; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$18 = _tmp$18; $f._tmp$19 = _tmp$19; $f._tmp$2 = _tmp$2; $f._tmp$20 = _tmp$20; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.d = d; $f.da = da; $f.db = db; $f.dg = dg; $f.di = di; $f.dr = dr; $f.dst = dst; $f.dx = dx; $f.dy = dy; $f.i = i; $f.i0 = i0; $f.ma = ma; $f.mask = mask; $f.mp = mp; $f.mx = mx; $f.mx0 = mx0; $f.my = my; $f.op = op; $f.r = r; $f.sa = sa; $f.sb = sb; $f.sg = sg; $f.sp = sp; $f.sr = sr; $f.src = src; $f.sx = sx; $f.sx0 = sx0; $f.sx1 = sx1; $f.sy = sy; $f.x0 = x0; $f.x1 = x1; $f.y = y; $f.y0 = y0; $f.y1 = y1; $f.$s = $s; $f.$r = $r; return $f;
	};
	clamp = function(i) {
		var i;
		if (i < 0) {
			return 0;
		}
		if (i > 65535) {
			return 65535;
		}
		return i;
	};
	sqDiff = function(x$1, y) {
		var d, x$1, y;
		d = (((x$1 - y >> 0) >>> 0));
		return (($imul(d, d) >>> 0)) >>> 2 >>> 0;
	};
	drawPaletted = function(dst, r, src, sp, floydSteinberg$1) {
		var _i, _i$1, _i$2, _index, _index$1, _index$10, _index$11, _index$12, _index$13, _index$14, _index$15, _index$2, _index$3, _index$4, _index$5, _index$6, _index$7, _index$8, _index$9, _q, _q$1, _q$2, _q$3, _r, _r$1, _r$2, _r$3, _ref, _ref$1, _ref$2, _ref$3, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, a, b, bestIndex, bestSum, col, dst, ea, eb, eg, er, floydSteinberg$1, g, i, i$1, index, ok, out, p, p$1, palette, pix, pxRGBA, quantErrorCurr, quantErrorNext, r, r$1, sa, sb, sg, sp, sr, src, src0, src0$1, src0$2, stride, sum, x$1, x$2, x$3, x$4, x$5, x$6, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _index = $f._index; _index$1 = $f._index$1; _index$10 = $f._index$10; _index$11 = $f._index$11; _index$12 = $f._index$12; _index$13 = $f._index$13; _index$14 = $f._index$14; _index$15 = $f._index$15; _index$2 = $f._index$2; _index$3 = $f._index$3; _index$4 = $f._index$4; _index$5 = $f._index$5; _index$6 = $f._index$6; _index$7 = $f._index$7; _index$8 = $f._index$8; _index$9 = $f._index$9; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _q$3 = $f._q$3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _ref$3 = $f._ref$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; a = $f.a; b = $f.b; bestIndex = $f.bestIndex; bestSum = $f.bestSum; col = $f.col; dst = $f.dst; ea = $f.ea; eb = $f.eb; eg = $f.eg; er = $f.er; floydSteinberg$1 = $f.floydSteinberg$1; g = $f.g; i = $f.i; i$1 = $f.i$1; index = $f.index; ok = $f.ok; out = $f.out; p = $f.p; p$1 = $f.p$1; palette = $f.palette; pix = $f.pix; pxRGBA = $f.pxRGBA; quantErrorCurr = $f.quantErrorCurr; quantErrorNext = $f.quantErrorNext; r = $f.r; r$1 = $f.r$1; sa = $f.sa; sb = $f.sb; sg = $f.sg; sp = $f.sp; sr = $f.sr; src = $f.src; src0 = $f.src0; src0$1 = $f.src0$1; src0$2 = $f.src0$2; stride = $f.stride; sum = $f.sum; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		out = [out];
		src = [src];
		src0 = [src0];
		src0$1 = [src0$1];
		src0$2 = [src0$2];
		_tmp = (sliceType.nil);
		_tmp$1 = (sliceType$1.nil);
		_tmp$2 = 0;
		palette = _tmp;
		pix = _tmp$1;
		stride = _tmp$2;
		_tuple = $assertType(dst, ptrType$2, true);
		p = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			palette = $makeSlice(sliceType, p.Palette.$length);
			_ref = p.Palette;
			_i = 0;
			/* while (true) { */ case 3:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }
				i = _i;
				col = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				_r = col.RGBA(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple$1 = _r;
				r$1 = _tuple$1[0];
				g = _tuple$1[1];
				b = _tuple$1[2];
				a = _tuple$1[3];
				((i < 0 || i >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + i])[0] = ((r$1 >> 0));
				((i < 0 || i >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + i])[1] = ((g >> 0));
				((i < 0 || i >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + i])[2] = ((b >> 0));
				((i < 0 || i >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + i])[3] = ((a >> 0));
				_i++;
			/* } */ $s = 3; continue; case 4:
			_tmp$3 = $subslice(p.Pix, p.PixOffset(r.Min.X, r.Min.Y));
			_tmp$4 = p.Stride;
			pix = _tmp$3;
			stride = _tmp$4;
		/* } */ case 2:
		_tmp$5 = sliceType.nil;
		_tmp$6 = sliceType.nil;
		quantErrorCurr = _tmp$5;
		quantErrorNext = _tmp$6;
		if (floydSteinberg$1) {
			quantErrorCurr = $makeSlice(sliceType, ($clone(r, image.Rectangle).Dx() + 2 >> 0));
			quantErrorNext = $makeSlice(sliceType, ($clone(r, image.Rectangle).Dx() + 2 >> 0));
		}
		pxRGBA = (function(out, src, src0, src0$1, src0$2) { return function $b(x$1, y) {
			var _r$1, _r$2, _tuple$2, a$1, b$1, g$1, r$2, x$1, y, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple$2 = $f._tuple$2; a$1 = $f.a$1; b$1 = $f.b$1; g$1 = $f.g$1; r$2 = $f.r$2; x$1 = $f.x$1; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			r$2 = 0;
			g$1 = 0;
			b$1 = 0;
			a$1 = 0;
			_r$1 = src[0].At(x$1, y); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$2 = _r$1.RGBA(); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple$2 = _r$2;
			r$2 = _tuple$2[0];
			g$1 = _tuple$2[1];
			b$1 = _tuple$2[2];
			a$1 = _tuple$2[3];
			$s = -1; return [r$2, g$1, b$1, a$1];
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple$2 = _tuple$2; $f.a$1 = a$1; $f.b$1 = b$1; $f.g$1 = g$1; $f.r$2 = r$2; $f.x$1 = x$1; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
		}; })(out, src, src0, src0$1, src0$2);
		_ref$1 = src[0];
		/* */ if ($assertType(_ref$1, ptrType$1, true)[1]) { $s = 6; continue; }
		/* */ if ($assertType(_ref$1, ptrType$4, true)[1]) { $s = 7; continue; }
		/* */ if ($assertType(_ref$1, ptrType$5, true)[1]) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if ($assertType(_ref$1, ptrType$1, true)[1]) { */ case 6:
			src0[0] = _ref$1.$val;
			pxRGBA = (function(out, src, src0, src0$1, src0$2) { return function(x$1, y) {
				var _tuple$2, a$1, b$1, g$1, r$2, x$1, y;
				r$2 = 0;
				g$1 = 0;
				b$1 = 0;
				a$1 = 0;
				_tuple$2 = $clone(src0[0].RGBAAt(x$1, y), color.RGBA).RGBA();
				r$2 = _tuple$2[0];
				g$1 = _tuple$2[1];
				b$1 = _tuple$2[2];
				a$1 = _tuple$2[3];
				return [r$2, g$1, b$1, a$1];
			}; })(out, src, src0, src0$1, src0$2);
			$s = 9; continue;
		/* } else if ($assertType(_ref$1, ptrType$4, true)[1]) { */ case 7:
			src0$1[0] = _ref$1.$val;
			pxRGBA = (function(out, src, src0, src0$1, src0$2) { return function(x$1, y) {
				var _tuple$2, a$1, b$1, g$1, r$2, x$1, y;
				r$2 = 0;
				g$1 = 0;
				b$1 = 0;
				a$1 = 0;
				_tuple$2 = $clone(src0$1[0].NRGBAAt(x$1, y), color.NRGBA).RGBA();
				r$2 = _tuple$2[0];
				g$1 = _tuple$2[1];
				b$1 = _tuple$2[2];
				a$1 = _tuple$2[3];
				return [r$2, g$1, b$1, a$1];
			}; })(out, src, src0, src0$1, src0$2);
			$s = 9; continue;
		/* } else if ($assertType(_ref$1, ptrType$5, true)[1]) { */ case 8:
			src0$2[0] = _ref$1.$val;
			pxRGBA = (function(out, src, src0, src0$1, src0$2) { return function(x$1, y) {
				var _tuple$2, a$1, b$1, g$1, r$2, x$1, y;
				r$2 = 0;
				g$1 = 0;
				b$1 = 0;
				a$1 = 0;
				_tuple$2 = $clone(src0$2[0].YCbCrAt(x$1, y), color.YCbCr).RGBA();
				r$2 = _tuple$2[0];
				g$1 = _tuple$2[1];
				b$1 = _tuple$2[2];
				a$1 = _tuple$2[3];
				return [r$2, g$1, b$1, a$1];
			}; })(out, src, src0, src0$1, src0$2);
		/* } */ case 9:
		out[0] = new color.RGBA64.ptr(0, 0, 0, 65535);
		y = 0;
		/* while (true) { */ case 10:
			/* if (!(!((y === $clone(r, image.Rectangle).Dy())))) { break; } */ if(!(!((y === $clone(r, image.Rectangle).Dy())))) { $s = 11; continue; }
			x$1 = 0;
			/* while (true) { */ case 12:
				/* if (!(!((x$1 === $clone(r, image.Rectangle).Dx())))) { break; } */ if(!(!((x$1 === $clone(r, image.Rectangle).Dx())))) { $s = 13; continue; }
				_r$1 = pxRGBA(sp.X + x$1 >> 0, sp.Y + y >> 0); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple$2 = _r$1;
				sr = _tuple$2[0];
				sg = _tuple$2[1];
				sb = _tuple$2[2];
				sa = _tuple$2[3];
				_tmp$7 = ((sr >> 0));
				_tmp$8 = ((sg >> 0));
				_tmp$9 = ((sb >> 0));
				_tmp$10 = ((sa >> 0));
				er = _tmp$7;
				eg = _tmp$8;
				eb = _tmp$9;
				ea = _tmp$10;
				if (floydSteinberg$1) {
					er = clamp(er + (_q = (x$2 = x$1 + 1 >> 0, ((x$2 < 0 || x$2 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + x$2]))[0] / 16, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0);
					eg = clamp(eg + (_q$1 = (x$3 = x$1 + 1 >> 0, ((x$3 < 0 || x$3 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + x$3]))[1] / 16, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0);
					eb = clamp(eb + (_q$2 = (x$4 = x$1 + 1 >> 0, ((x$4 < 0 || x$4 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + x$4]))[2] / 16, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0);
					ea = clamp(ea + (_q$3 = (x$5 = x$1 + 1 >> 0, ((x$5 < 0 || x$5 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + x$5]))[3] / 16, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0);
				}
				/* */ if (!(palette === sliceType.nil)) { $s = 15; continue; }
				/* */ $s = 16; continue;
				/* if (!(palette === sliceType.nil)) { */ case 15:
					_tmp$11 = 0;
					_tmp$12 = 4294967295;
					bestIndex = _tmp$11;
					bestSum = _tmp$12;
					_ref$2 = palette;
					_i$1 = 0;
					while (true) {
						if (!(_i$1 < _ref$2.$length)) { break; }
						index = _i$1;
						p$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$1]), arrayType);
						sum = ((sqDiff(er, p$1[0]) + sqDiff(eg, p$1[1]) >>> 0) + sqDiff(eb, p$1[2]) >>> 0) + sqDiff(ea, p$1[3]) >>> 0;
						if (sum < bestSum) {
							_tmp$13 = index;
							_tmp$14 = sum;
							bestIndex = _tmp$13;
							bestSum = _tmp$14;
							if (sum === 0) {
								break;
							}
						}
						_i$1++;
					}
					(x$6 = ($imul(y, stride)) + x$1 >> 0, ((x$6 < 0 || x$6 >= pix.$length) ? ($throwRuntimeError("index out of range"), undefined) : pix.$array[pix.$offset + x$6] = ((bestIndex << 24 >>> 24))));
					if (!floydSteinberg$1) {
						x$1 = x$1 + (1) >> 0;
						/* continue; */ $s = 12; continue;
					}
					er = er - (((bestIndex < 0 || bestIndex >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + bestIndex])[0]) >> 0;
					eg = eg - (((bestIndex < 0 || bestIndex >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + bestIndex])[1]) >> 0;
					eb = eb - (((bestIndex < 0 || bestIndex >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + bestIndex])[2]) >> 0;
					ea = ea - (((bestIndex < 0 || bestIndex >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + bestIndex])[3]) >> 0;
					$s = 17; continue;
				/* } else { */ case 16:
					out[0].R = ((er << 16 >>> 16));
					out[0].G = ((eg << 16 >>> 16));
					out[0].B = ((eb << 16 >>> 16));
					out[0].A = ((ea << 16 >>> 16));
					$r = dst.Set(r.Min.X + x$1 >> 0, r.Min.Y + y >> 0, out[0]); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					/* */ if (!floydSteinberg$1) { $s = 19; continue; }
					/* */ $s = 20; continue;
					/* if (!floydSteinberg$1) { */ case 19:
						x$1 = x$1 + (1) >> 0;
						/* continue; */ $s = 12; continue;
					/* } */ case 20:
					_r$2 = dst.At(r.Min.X + x$1 >> 0, r.Min.Y + y >> 0); /* */ $s = 21; case 21: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_r$3 = _r$2.RGBA(); /* */ $s = 22; case 22: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					_tuple$3 = _r$3;
					sr = _tuple$3[0];
					sg = _tuple$3[1];
					sb = _tuple$3[2];
					sa = _tuple$3[3];
					er = er - (((sr >> 0))) >> 0;
					eg = eg - (((sg >> 0))) >> 0;
					eb = eb - (((sb >> 0))) >> 0;
					ea = ea - (((sa >> 0))) >> 0;
				/* } */ case 17:
				_index = x$1 + 0 >> 0;
				((_index < 0 || _index >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index])[0] = (((_index < 0 || _index >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index])[0] + (($imul(er, 3))) >> 0);
				_index$1 = x$1 + 0 >> 0;
				((_index$1 < 0 || _index$1 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$1])[1] = (((_index$1 < 0 || _index$1 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$1])[1] + (($imul(eg, 3))) >> 0);
				_index$2 = x$1 + 0 >> 0;
				((_index$2 < 0 || _index$2 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$2])[2] = (((_index$2 < 0 || _index$2 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$2])[2] + (($imul(eb, 3))) >> 0);
				_index$3 = x$1 + 0 >> 0;
				((_index$3 < 0 || _index$3 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$3])[3] = (((_index$3 < 0 || _index$3 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$3])[3] + (($imul(ea, 3))) >> 0);
				_index$4 = x$1 + 1 >> 0;
				((_index$4 < 0 || _index$4 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$4])[0] = (((_index$4 < 0 || _index$4 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$4])[0] + (($imul(er, 5))) >> 0);
				_index$5 = x$1 + 1 >> 0;
				((_index$5 < 0 || _index$5 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$5])[1] = (((_index$5 < 0 || _index$5 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$5])[1] + (($imul(eg, 5))) >> 0);
				_index$6 = x$1 + 1 >> 0;
				((_index$6 < 0 || _index$6 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$6])[2] = (((_index$6 < 0 || _index$6 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$6])[2] + (($imul(eb, 5))) >> 0);
				_index$7 = x$1 + 1 >> 0;
				((_index$7 < 0 || _index$7 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$7])[3] = (((_index$7 < 0 || _index$7 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$7])[3] + (($imul(ea, 5))) >> 0);
				_index$8 = x$1 + 2 >> 0;
				((_index$8 < 0 || _index$8 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$8])[0] = (((_index$8 < 0 || _index$8 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$8])[0] + (($imul(er, 1))) >> 0);
				_index$9 = x$1 + 2 >> 0;
				((_index$9 < 0 || _index$9 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$9])[1] = (((_index$9 < 0 || _index$9 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$9])[1] + (($imul(eg, 1))) >> 0);
				_index$10 = x$1 + 2 >> 0;
				((_index$10 < 0 || _index$10 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$10])[2] = (((_index$10 < 0 || _index$10 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$10])[2] + (($imul(eb, 1))) >> 0);
				_index$11 = x$1 + 2 >> 0;
				((_index$11 < 0 || _index$11 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$11])[3] = (((_index$11 < 0 || _index$11 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + _index$11])[3] + (($imul(ea, 1))) >> 0);
				_index$12 = x$1 + 2 >> 0;
				((_index$12 < 0 || _index$12 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + _index$12])[0] = (((_index$12 < 0 || _index$12 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + _index$12])[0] + (($imul(er, 7))) >> 0);
				_index$13 = x$1 + 2 >> 0;
				((_index$13 < 0 || _index$13 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + _index$13])[1] = (((_index$13 < 0 || _index$13 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + _index$13])[1] + (($imul(eg, 7))) >> 0);
				_index$14 = x$1 + 2 >> 0;
				((_index$14 < 0 || _index$14 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + _index$14])[2] = (((_index$14 < 0 || _index$14 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + _index$14])[2] + (($imul(eb, 7))) >> 0);
				_index$15 = x$1 + 2 >> 0;
				((_index$15 < 0 || _index$15 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + _index$15])[3] = (((_index$15 < 0 || _index$15 >= quantErrorCurr.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorCurr.$array[quantErrorCurr.$offset + _index$15])[3] + (($imul(ea, 7))) >> 0);
				x$1 = x$1 + (1) >> 0;
			/* } */ $s = 12; continue; case 13:
			if (floydSteinberg$1) {
				_tmp$15 = quantErrorNext;
				_tmp$16 = quantErrorCurr;
				quantErrorCurr = _tmp$15;
				quantErrorNext = _tmp$16;
				_ref$3 = quantErrorNext;
				_i$2 = 0;
				while (true) {
					if (!(_i$2 < _ref$3.$length)) { break; }
					i$1 = _i$2;
					arrayType.copy(((i$1 < 0 || i$1 >= quantErrorNext.$length) ? ($throwRuntimeError("index out of range"), undefined) : quantErrorNext.$array[quantErrorNext.$offset + i$1]), arrayType.zero());
					_i$2++;
				}
			}
			y = y + (1) >> 0;
		/* } */ $s = 10; continue; case 11:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: drawPaletted }; } $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._index = _index; $f._index$1 = _index$1; $f._index$10 = _index$10; $f._index$11 = _index$11; $f._index$12 = _index$12; $f._index$13 = _index$13; $f._index$14 = _index$14; $f._index$15 = _index$15; $f._index$2 = _index$2; $f._index$3 = _index$3; $f._index$4 = _index$4; $f._index$5 = _index$5; $f._index$6 = _index$6; $f._index$7 = _index$7; $f._index$8 = _index$8; $f._index$9 = _index$9; $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._q$3 = _q$3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._ref$3 = _ref$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.a = a; $f.b = b; $f.bestIndex = bestIndex; $f.bestSum = bestSum; $f.col = col; $f.dst = dst; $f.ea = ea; $f.eb = eb; $f.eg = eg; $f.er = er; $f.floydSteinberg$1 = floydSteinberg$1; $f.g = g; $f.i = i; $f.i$1 = i$1; $f.index = index; $f.ok = ok; $f.out = out; $f.p = p; $f.p$1 = p$1; $f.palette = palette; $f.pix = pix; $f.pxRGBA = pxRGBA; $f.quantErrorCurr = quantErrorCurr; $f.quantErrorNext = quantErrorNext; $f.r = r; $f.r$1 = r$1; $f.sa = sa; $f.sb = sb; $f.sg = sg; $f.sp = sp; $f.sr = sr; $f.src = src; $f.src0 = src0; $f.src0$1 = src0$1; $f.src0$2 = src0$2; $f.stride = stride; $f.sum = sum; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.init([{prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [image.Rectangle], false)}, {prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$Int, $Int, color.Color], [], false)}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = image.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = color.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = imageutil.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["golang.org/x/image/font"] = (function() {
	var $pkg = {}, $init, fixed, image, draw, io, utf8, Face, Metrics, Drawer, sliceType, ptrType, BoundBytes, BoundString, MeasureBytes, MeasureString;
	fixed = $packages["golang.org/x/image/math/fixed"];
	image = $packages["image"];
	draw = $packages["image/draw"];
	io = $packages["io"];
	utf8 = $packages["unicode/utf8"];
	Face = $pkg.Face = $newType(8, $kindInterface, "font.Face", true, "golang.org/x/image/font", true, null);
	Metrics = $pkg.Metrics = $newType(0, $kindStruct, "font.Metrics", true, "golang.org/x/image/font", true, function(Height_, Ascent_, Descent_, XHeight_, CapHeight_, CaretSlope_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Height = 0;
			this.Ascent = 0;
			this.Descent = 0;
			this.XHeight = 0;
			this.CapHeight = 0;
			this.CaretSlope = new image.Point.ptr(0, 0);
			return;
		}
		this.Height = Height_;
		this.Ascent = Ascent_;
		this.Descent = Descent_;
		this.XHeight = XHeight_;
		this.CapHeight = CapHeight_;
		this.CaretSlope = CaretSlope_;
	});
	Drawer = $pkg.Drawer = $newType(0, $kindStruct, "font.Drawer", true, "golang.org/x/image/font", true, function(Dst_, Src_, Face_, Dot_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Dst = $ifaceNil;
			this.Src = $ifaceNil;
			this.Face = $ifaceNil;
			this.Dot = new fixed.Point26_6.ptr(0, 0);
			return;
		}
		this.Dst = Dst_;
		this.Src = Src_;
		this.Face = Face_;
		this.Dot = Dot_;
	});
	sliceType = $sliceType($Uint8);
	ptrType = $ptrType(Drawer);
	Drawer.ptr.prototype.DrawBytes = function(s) {
		var _r, _r$1, _tuple, _tuple$1, advance, c, d, dr, mask, maskp, ok, prevC, s, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; advance = $f.advance; c = $f.c; d = $f.d; dr = $f.dr; mask = $f.mask; maskp = $f.maskp; ok = $f.ok; prevC = $f.prevC; s = $f.s; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		prevC = -1;
		/* while (true) { */ case 1:
			/* if (!(s.$length > 0)) { break; } */ if(!(s.$length > 0)) { $s = 2; continue; }
			_tuple = utf8.DecodeRune(s);
			c = _tuple[0];
			size = _tuple[1];
			s = $subslice(s, size);
			/* */ if (prevC >= 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (prevC >= 0) { */ case 3:
				_r = d.Face.Kern(prevC, c); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				d.Dot.X = d.Dot.X + (_r) >> 0;
			/* } */ case 4:
			_r$1 = d.Face.Glyph($clone(d.Dot, fixed.Point26_6), c); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			dr = $clone(_tuple$1[0], image.Rectangle);
			mask = _tuple$1[1];
			maskp = $clone(_tuple$1[2], image.Point);
			advance = _tuple$1[3];
			ok = _tuple$1[4];
			/* */ if (!ok) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!ok) { */ case 7:
				/* continue; */ $s = 1; continue;
			/* } */ case 8:
			$r = draw.DrawMask(d.Dst, $clone(dr, image.Rectangle), d.Src, new image.Point.ptr(0, 0), mask, $clone(maskp, image.Point), 0); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			d.Dot.X = d.Dot.X + (advance) >> 0;
			prevC = c;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Drawer.ptr.prototype.DrawBytes }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.advance = advance; $f.c = c; $f.d = d; $f.dr = dr; $f.mask = mask; $f.maskp = maskp; $f.ok = ok; $f.prevC = prevC; $f.s = s; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	Drawer.prototype.DrawBytes = function(s) { return this.$val.DrawBytes(s); };
	Drawer.ptr.prototype.DrawString = function(s) {
		var _i, _r, _r$1, _ref, _rune, _tuple, advance, c, d, dr, mask, maskp, ok, prevC, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _rune = $f._rune; _tuple = $f._tuple; advance = $f.advance; c = $f.c; d = $f.d; dr = $f.dr; mask = $f.mask; maskp = $f.maskp; ok = $f.ok; prevC = $f.prevC; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		prevC = -1;
		_ref = s;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.length)) { break; } */ if(!(_i < _ref.length)) { $s = 2; continue; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			/* */ if (prevC >= 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (prevC >= 0) { */ case 3:
				_r = d.Face.Kern(prevC, c); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				d.Dot.X = d.Dot.X + (_r) >> 0;
			/* } */ case 4:
			_r$1 = d.Face.Glyph($clone(d.Dot, fixed.Point26_6), c); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple = _r$1;
			dr = $clone(_tuple[0], image.Rectangle);
			mask = _tuple[1];
			maskp = $clone(_tuple[2], image.Point);
			advance = _tuple[3];
			ok = _tuple[4];
			/* */ if (!ok) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!ok) { */ case 7:
				_i += _rune[1];
				/* continue; */ $s = 1; continue;
			/* } */ case 8:
			$r = draw.DrawMask(d.Dst, $clone(dr, image.Rectangle), d.Src, new image.Point.ptr(0, 0), mask, $clone(maskp, image.Point), 0); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			d.Dot.X = d.Dot.X + (advance) >> 0;
			prevC = c;
			_i += _rune[1];
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Drawer.ptr.prototype.DrawString }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._rune = _rune; $f._tuple = _tuple; $f.advance = advance; $f.c = c; $f.d = d; $f.dr = dr; $f.mask = mask; $f.maskp = maskp; $f.ok = ok; $f.prevC = prevC; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Drawer.prototype.DrawString = function(s) { return this.$val.DrawString(s); };
	Drawer.ptr.prototype.BoundBytes = function(s) {
		var _r, _tuple, advance, bounds, d, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; advance = $f.advance; bounds = $f.bounds; d = $f.d; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		bounds = new fixed.Rectangle26_6.ptr(new fixed.Point26_6.ptr(0, 0), new fixed.Point26_6.ptr(0, 0));
		advance = 0;
		d = this;
		_r = BoundBytes(d.Face, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		fixed.Rectangle26_6.copy(bounds, _tuple[0]);
		advance = _tuple[1];
		fixed.Point26_6.copy(bounds.Min, $clone(bounds.Min, fixed.Point26_6).Add($clone(d.Dot, fixed.Point26_6)));
		fixed.Point26_6.copy(bounds.Max, $clone(bounds.Max, fixed.Point26_6).Add($clone(d.Dot, fixed.Point26_6)));
		$s = -1; return [bounds, advance];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Drawer.ptr.prototype.BoundBytes }; } $f._r = _r; $f._tuple = _tuple; $f.advance = advance; $f.bounds = bounds; $f.d = d; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Drawer.prototype.BoundBytes = function(s) { return this.$val.BoundBytes(s); };
	Drawer.ptr.prototype.BoundString = function(s) {
		var _r, _tuple, advance, bounds, d, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; advance = $f.advance; bounds = $f.bounds; d = $f.d; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		bounds = new fixed.Rectangle26_6.ptr(new fixed.Point26_6.ptr(0, 0), new fixed.Point26_6.ptr(0, 0));
		advance = 0;
		d = this;
		_r = BoundString(d.Face, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		fixed.Rectangle26_6.copy(bounds, _tuple[0]);
		advance = _tuple[1];
		fixed.Point26_6.copy(bounds.Min, $clone(bounds.Min, fixed.Point26_6).Add($clone(d.Dot, fixed.Point26_6)));
		fixed.Point26_6.copy(bounds.Max, $clone(bounds.Max, fixed.Point26_6).Add($clone(d.Dot, fixed.Point26_6)));
		$s = -1; return [bounds, advance];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Drawer.ptr.prototype.BoundString }; } $f._r = _r; $f._tuple = _tuple; $f.advance = advance; $f.bounds = bounds; $f.d = d; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Drawer.prototype.BoundString = function(s) { return this.$val.BoundString(s); };
	Drawer.ptr.prototype.MeasureBytes = function(s) {
		var _r, advance, d, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; advance = $f.advance; d = $f.d; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		advance = 0;
		d = this;
		_r = MeasureBytes(d.Face, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		advance = _r;
		$s = -1; return advance;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Drawer.ptr.prototype.MeasureBytes }; } $f._r = _r; $f.advance = advance; $f.d = d; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Drawer.prototype.MeasureBytes = function(s) { return this.$val.MeasureBytes(s); };
	Drawer.ptr.prototype.MeasureString = function(s) {
		var _r, advance, d, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; advance = $f.advance; d = $f.d; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		advance = 0;
		d = this;
		_r = MeasureString(d.Face, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		advance = _r;
		$s = -1; return advance;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Drawer.ptr.prototype.MeasureString }; } $f._r = _r; $f.advance = advance; $f.d = d; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Drawer.prototype.MeasureString = function(s) { return this.$val.MeasureString(s); };
	BoundBytes = function(f, s) {
		var _r, _r$1, _tuple, _tuple$1, a, advance, b, bounds, c, f, ok, prevC, s, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; advance = $f.advance; b = $f.b; bounds = $f.bounds; c = $f.c; f = $f.f; ok = $f.ok; prevC = $f.prevC; s = $f.s; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		bounds = new fixed.Rectangle26_6.ptr(new fixed.Point26_6.ptr(0, 0), new fixed.Point26_6.ptr(0, 0));
		advance = 0;
		prevC = -1;
		/* while (true) { */ case 1:
			/* if (!(s.$length > 0)) { break; } */ if(!(s.$length > 0)) { $s = 2; continue; }
			_tuple = utf8.DecodeRune(s);
			c = _tuple[0];
			size = _tuple[1];
			s = $subslice(s, size);
			/* */ if (prevC >= 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (prevC >= 0) { */ case 3:
				_r = f.Kern(prevC, c); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				advance = advance + (_r) >> 0;
			/* } */ case 4:
			_r$1 = f.GlyphBounds(c); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			b = $clone(_tuple$1[0], fixed.Rectangle26_6);
			a = _tuple$1[1];
			ok = _tuple$1[2];
			if (!ok) {
				/* continue; */ $s = 1; continue;
			}
			b.Min.X = b.Min.X + (advance) >> 0;
			b.Max.X = b.Max.X + (advance) >> 0;
			fixed.Rectangle26_6.copy(bounds, $clone(bounds, fixed.Rectangle26_6).Union($clone(b, fixed.Rectangle26_6)));
			advance = advance + (a) >> 0;
			prevC = c;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [bounds, advance];
		/* */ } return; } if ($f === undefined) { $f = { $blk: BoundBytes }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.advance = advance; $f.b = b; $f.bounds = bounds; $f.c = c; $f.f = f; $f.ok = ok; $f.prevC = prevC; $f.s = s; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.BoundBytes = BoundBytes;
	BoundString = function(f, s) {
		var _i, _r, _r$1, _ref, _rune, _tuple, a, advance, b, bounds, c, f, ok, prevC, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _rune = $f._rune; _tuple = $f._tuple; a = $f.a; advance = $f.advance; b = $f.b; bounds = $f.bounds; c = $f.c; f = $f.f; ok = $f.ok; prevC = $f.prevC; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		bounds = new fixed.Rectangle26_6.ptr(new fixed.Point26_6.ptr(0, 0), new fixed.Point26_6.ptr(0, 0));
		advance = 0;
		prevC = -1;
		_ref = s;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.length)) { break; } */ if(!(_i < _ref.length)) { $s = 2; continue; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			/* */ if (prevC >= 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (prevC >= 0) { */ case 3:
				_r = f.Kern(prevC, c); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				advance = advance + (_r) >> 0;
			/* } */ case 4:
			_r$1 = f.GlyphBounds(c); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple = _r$1;
			b = $clone(_tuple[0], fixed.Rectangle26_6);
			a = _tuple[1];
			ok = _tuple[2];
			if (!ok) {
				_i += _rune[1];
				/* continue; */ $s = 1; continue;
			}
			b.Min.X = b.Min.X + (advance) >> 0;
			b.Max.X = b.Max.X + (advance) >> 0;
			fixed.Rectangle26_6.copy(bounds, $clone(bounds, fixed.Rectangle26_6).Union($clone(b, fixed.Rectangle26_6)));
			advance = advance + (a) >> 0;
			prevC = c;
			_i += _rune[1];
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [bounds, advance];
		/* */ } return; } if ($f === undefined) { $f = { $blk: BoundString }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._rune = _rune; $f._tuple = _tuple; $f.a = a; $f.advance = advance; $f.b = b; $f.bounds = bounds; $f.c = c; $f.f = f; $f.ok = ok; $f.prevC = prevC; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.BoundString = BoundString;
	MeasureBytes = function(f, s) {
		var _r, _r$1, _tuple, _tuple$1, a, advance, c, f, ok, prevC, s, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; advance = $f.advance; c = $f.c; f = $f.f; ok = $f.ok; prevC = $f.prevC; s = $f.s; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		advance = 0;
		prevC = -1;
		/* while (true) { */ case 1:
			/* if (!(s.$length > 0)) { break; } */ if(!(s.$length > 0)) { $s = 2; continue; }
			_tuple = utf8.DecodeRune(s);
			c = _tuple[0];
			size = _tuple[1];
			s = $subslice(s, size);
			/* */ if (prevC >= 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (prevC >= 0) { */ case 3:
				_r = f.Kern(prevC, c); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				advance = advance + (_r) >> 0;
			/* } */ case 4:
			_r$1 = f.GlyphAdvance(c); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			a = _tuple$1[0];
			ok = _tuple$1[1];
			if (!ok) {
				/* continue; */ $s = 1; continue;
			}
			advance = advance + (a) >> 0;
			prevC = c;
		/* } */ $s = 1; continue; case 2:
		advance = advance;
		$s = -1; return advance;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MeasureBytes }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.advance = advance; $f.c = c; $f.f = f; $f.ok = ok; $f.prevC = prevC; $f.s = s; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MeasureBytes = MeasureBytes;
	MeasureString = function(f, s) {
		var _i, _r, _r$1, _ref, _rune, _tuple, a, advance, c, f, ok, prevC, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _rune = $f._rune; _tuple = $f._tuple; a = $f.a; advance = $f.advance; c = $f.c; f = $f.f; ok = $f.ok; prevC = $f.prevC; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		advance = 0;
		prevC = -1;
		_ref = s;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.length)) { break; } */ if(!(_i < _ref.length)) { $s = 2; continue; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			/* */ if (prevC >= 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (prevC >= 0) { */ case 3:
				_r = f.Kern(prevC, c); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				advance = advance + (_r) >> 0;
			/* } */ case 4:
			_r$1 = f.GlyphAdvance(c); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple = _r$1;
			a = _tuple[0];
			ok = _tuple[1];
			if (!ok) {
				_i += _rune[1];
				/* continue; */ $s = 1; continue;
			}
			advance = advance + (a) >> 0;
			prevC = c;
			_i += _rune[1];
		/* } */ $s = 1; continue; case 2:
		advance = advance;
		$s = -1; return advance;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MeasureString }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._rune = _rune; $f._tuple = _tuple; $f.a = a; $f.advance = advance; $f.c = c; $f.f = f; $f.ok = ok; $f.prevC = prevC; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MeasureString = MeasureString;
	ptrType.methods = [{prop: "DrawBytes", name: "DrawBytes", pkg: "", typ: $funcType([sliceType], [], false)}, {prop: "DrawString", name: "DrawString", pkg: "", typ: $funcType([$String], [], false)}, {prop: "BoundBytes", name: "BoundBytes", pkg: "", typ: $funcType([sliceType], [fixed.Rectangle26_6, fixed.Int26_6], false)}, {prop: "BoundString", name: "BoundString", pkg: "", typ: $funcType([$String], [fixed.Rectangle26_6, fixed.Int26_6], false)}, {prop: "MeasureBytes", name: "MeasureBytes", pkg: "", typ: $funcType([sliceType], [fixed.Int26_6], false)}, {prop: "MeasureString", name: "MeasureString", pkg: "", typ: $funcType([$String], [fixed.Int26_6], false)}];
	Face.init([{prop: "Close", name: "Close", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Glyph", name: "Glyph", pkg: "", typ: $funcType([fixed.Point26_6, $Int32], [image.Rectangle, image.Image, image.Point, fixed.Int26_6, $Bool], false)}, {prop: "GlyphAdvance", name: "GlyphAdvance", pkg: "", typ: $funcType([$Int32], [fixed.Int26_6, $Bool], false)}, {prop: "GlyphBounds", name: "GlyphBounds", pkg: "", typ: $funcType([$Int32], [fixed.Rectangle26_6, fixed.Int26_6, $Bool], false)}, {prop: "Kern", name: "Kern", pkg: "", typ: $funcType([$Int32, $Int32], [fixed.Int26_6], false)}, {prop: "Metrics", name: "Metrics", pkg: "", typ: $funcType([], [Metrics], false)}]);
	Metrics.init("", [{prop: "Height", name: "Height", embedded: false, exported: true, typ: fixed.Int26_6, tag: ""}, {prop: "Ascent", name: "Ascent", embedded: false, exported: true, typ: fixed.Int26_6, tag: ""}, {prop: "Descent", name: "Descent", embedded: false, exported: true, typ: fixed.Int26_6, tag: ""}, {prop: "XHeight", name: "XHeight", embedded: false, exported: true, typ: fixed.Int26_6, tag: ""}, {prop: "CapHeight", name: "CapHeight", embedded: false, exported: true, typ: fixed.Int26_6, tag: ""}, {prop: "CaretSlope", name: "CaretSlope", embedded: false, exported: true, typ: image.Point, tag: ""}]);
	Drawer.init("", [{prop: "Dst", name: "Dst", embedded: false, exported: true, typ: draw.Image, tag: ""}, {prop: "Src", name: "Src", embedded: false, exported: true, typ: image.Image, tag: ""}, {prop: "Face", name: "Face", embedded: false, exported: true, typ: Face, tag: ""}, {prop: "Dot", name: "Dot", embedded: false, exported: true, typ: fixed.Point26_6, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = fixed.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = image.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = draw.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/bitmapfont/internal/bitmap"] = (function() {
	var $pkg = {}, $init, unicode, font, fixed, image, color, BinaryImage, Face, sliceType, ptrType, ptrType$1, NewBinaryImage, NewFace;
	unicode = $packages["github.com/hajimehoshi/bitmapfont/internal/unicode"];
	font = $packages["golang.org/x/image/font"];
	fixed = $packages["golang.org/x/image/math/fixed"];
	image = $packages["image"];
	color = $packages["image/color"];
	BinaryImage = $pkg.BinaryImage = $newType(0, $kindStruct, "bitmap.BinaryImage", true, "github.com/hajimehoshi/bitmapfont/internal/bitmap", true, function(bits_, width_, height_, bounds_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.bits = sliceType.nil;
			this.width = 0;
			this.height = 0;
			this.bounds = new image.Rectangle.ptr(new image.Point.ptr(0, 0), new image.Point.ptr(0, 0));
			return;
		}
		this.bits = bits_;
		this.width = width_;
		this.height = height_;
		this.bounds = bounds_;
	});
	Face = $pkg.Face = $newType(0, $kindStruct, "bitmap.Face", true, "github.com/hajimehoshi/bitmapfont/internal/bitmap", true, function(image_, dotX_, dotY_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.image = ptrType.nil;
			this.dotX = 0;
			this.dotY = 0;
			return;
		}
		this.image = image_;
		this.dotX = dotX_;
		this.dotY = dotY_;
	});
	sliceType = $sliceType($Uint8);
	ptrType = $ptrType(BinaryImage);
	ptrType$1 = $ptrType(Face);
	NewBinaryImage = function(bits, width, height) {
		var bits, height, width;
		return new BinaryImage.ptr(bits, width, height, $clone(image.Rect(0, 0, width, height), image.Rectangle));
	};
	$pkg.NewBinaryImage = NewBinaryImage;
	BinaryImage.ptr.prototype.At = function(i, j) {
		var _q, _r, b, i, idx, j, x, x$1, x$2, x$3, x$4, y;
		b = this;
		if (i < b.bounds.Min.X || j < b.bounds.Min.Y || i >= b.bounds.Max.X || j >= b.bounds.Max.Y) {
			return (x = new color.Alpha.ptr(0), new x.constructor.elem(x));
		}
		idx = ($imul(b.width, j)) + i >> 0;
		if (!(((((((y = (((7 - (_r = idx % 8, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) >> 0) >>> 0)), y < 32 ? ((x$1 = b.bits, x$2 = (_q = idx / 8, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")), ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2])) >>> y) : 0) << 24 >>> 24)) & 1) >>> 0) === 0))) {
			return (x$3 = new color.Alpha.ptr(255), new x$3.constructor.elem(x$3));
		}
		return (x$4 = new color.Alpha.ptr(0), new x$4.constructor.elem(x$4));
	};
	BinaryImage.prototype.At = function(i, j) { return this.$val.At(i, j); };
	BinaryImage.ptr.prototype.ColorModel = function() {
		var b;
		b = this;
		return color.AlphaModel;
	};
	BinaryImage.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	BinaryImage.ptr.prototype.Bounds = function() {
		var b;
		b = this;
		return b.bounds;
	};
	BinaryImage.prototype.Bounds = function() { return this.$val.Bounds(); };
	BinaryImage.ptr.prototype.SubImage = function(r) {
		var b, bounds, r;
		b = this;
		bounds = $clone($clone(r, image.Rectangle).Intersect($clone(b.bounds, image.Rectangle)), image.Rectangle);
		if ($clone(bounds, image.Rectangle).Empty()) {
			return new BinaryImage.ptr(sliceType.nil, 0, 0, new image.Rectangle.ptr(new image.Point.ptr(0, 0), new image.Point.ptr(0, 0)));
		}
		return new BinaryImage.ptr(b.bits, b.width, b.height, $clone(bounds, image.Rectangle));
	};
	BinaryImage.prototype.SubImage = function(r) { return this.$val.SubImage(r); };
	NewFace = function(image$1, dotX, dotY) {
		var dotX, dotY, image$1;
		return new Face.ptr(image$1, dotX, dotY);
	};
	$pkg.NewFace = NewFace;
	Face.ptr.prototype.runeWidth = function(r) {
		var f, r;
		f = this;
		if (unicode.IsEuropian(r)) {
			return f.charHalfWidth();
		}
		if (65377 <= r && r <= 65500) {
			return f.charHalfWidth();
		}
		if (65512 <= r && r <= 65518) {
			return f.charHalfWidth();
		}
		return f.charFullWidth();
	};
	Face.prototype.runeWidth = function(r) { return this.$val.runeWidth(r); };
	Face.ptr.prototype.charFullWidth = function() {
		var _q, f;
		f = this;
		return (_q = $clone(f.image.Bounds(), image.Rectangle).Dx() / 256, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
	};
	Face.prototype.charFullWidth = function() { return this.$val.charFullWidth(); };
	Face.ptr.prototype.charHalfWidth = function() {
		var _q, f;
		f = this;
		return (_q = f.charFullWidth() / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
	};
	Face.prototype.charHalfWidth = function() { return this.$val.charHalfWidth(); };
	Face.ptr.prototype.charHeight = function() {
		var _q, f;
		f = this;
		return (_q = $clone(f.image.Bounds(), image.Rectangle).Dy() / 256, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
	};
	Face.prototype.charHeight = function() { return this.$val.charHeight(); };
	Face.ptr.prototype.Close = function() {
		var f;
		f = this;
		return $ifaceNil;
	};
	Face.prototype.Close = function() { return this.$val.Close(); };
	Face.ptr.prototype.Glyph = function(dot, r) {
		var _q, _r, advance, dot, dr, dx, dy, f, mask, maskp, mx, my, ok, r, rw;
		dr = new image.Rectangle.ptr(new image.Point.ptr(0, 0), new image.Point.ptr(0, 0));
		mask = $ifaceNil;
		maskp = new image.Point.ptr(0, 0);
		advance = 0;
		ok = false;
		f = this;
		if (r >= 65536) {
			return [dr, mask, maskp, advance, ok];
		}
		rw = f.runeWidth(r);
		dx = new fixed.Int26_6(((dot.X - f.dotX >> 0))).Floor();
		dy = new fixed.Int26_6(((dot.Y - f.dotY >> 0))).Floor();
		image.Rectangle.copy(dr, image.Rect(dx, dy, dx + rw >> 0, dy + f.charHeight() >> 0));
		mx = $imul(((_r = ((r >> 0)) % 256, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))), f.charFullWidth());
		my = $imul(((_q = ((r >> 0)) / 256, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"))), f.charHeight());
		mask = f.image.SubImage($clone(image.Rect(mx, my, mx + rw >> 0, my + f.charHeight() >> 0), image.Rectangle));
		image.Point.copy(maskp, image.Pt(mx, my));
		advance = fixed.I(f.runeWidth(r));
		ok = true;
		return [dr, mask, maskp, advance, ok];
	};
	Face.prototype.Glyph = function(dot, r) { return this.$val.Glyph(dot, r); };
	Face.ptr.prototype.GlyphBounds = function(r) {
		var advance, bounds, f, ok, r;
		bounds = new fixed.Rectangle26_6.ptr(new fixed.Point26_6.ptr(0, 0), new fixed.Point26_6.ptr(0, 0));
		advance = 0;
		ok = false;
		f = this;
		if (r >= 65536) {
			return [bounds, advance, ok];
		}
		fixed.Rectangle26_6.copy(bounds, new fixed.Rectangle26_6.ptr(new fixed.Point26_6.ptr(-f.dotX, -f.dotY), new fixed.Point26_6.ptr(-f.dotX + fixed.I(f.runeWidth(r)) >> 0, -f.dotY + fixed.I(f.charHeight()) >> 0)));
		advance = fixed.I(f.runeWidth(r));
		ok = true;
		return [bounds, advance, ok];
	};
	Face.prototype.GlyphBounds = function(r) { return this.$val.GlyphBounds(r); };
	Face.ptr.prototype.GlyphAdvance = function(r) {
		var advance, f, ok, r;
		advance = 0;
		ok = false;
		f = this;
		if (r >= 65536) {
			return [advance, ok];
		}
		advance = fixed.I(f.runeWidth(r));
		ok = true;
		return [advance, ok];
	};
	Face.prototype.GlyphAdvance = function(r) { return this.$val.GlyphAdvance(r); };
	Face.ptr.prototype.Kern = function(r0, r1) {
		var f, r0, r1;
		f = this;
		return 0;
	};
	Face.prototype.Kern = function(r0, r1) { return this.$val.Kern(r0, r1); };
	Face.ptr.prototype.Metrics = function() {
		var f;
		f = this;
		return new font.Metrics.ptr(fixed.I(f.charHeight()), f.dotY, fixed.I(f.charHeight()) - f.dotY >> 0, 0, 0, new image.Point.ptr(0, 0));
	};
	Face.prototype.Metrics = function() { return this.$val.Metrics(); };
	ptrType.methods = [{prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [image.Rectangle], false)}, {prop: "SubImage", name: "SubImage", pkg: "", typ: $funcType([image.Rectangle], [image.Image], false)}];
	ptrType$1.methods = [{prop: "runeWidth", name: "runeWidth", pkg: "github.com/hajimehoshi/bitmapfont/internal/bitmap", typ: $funcType([$Int32], [$Int], false)}, {prop: "charFullWidth", name: "charFullWidth", pkg: "github.com/hajimehoshi/bitmapfont/internal/bitmap", typ: $funcType([], [$Int], false)}, {prop: "charHalfWidth", name: "charHalfWidth", pkg: "github.com/hajimehoshi/bitmapfont/internal/bitmap", typ: $funcType([], [$Int], false)}, {prop: "charHeight", name: "charHeight", pkg: "github.com/hajimehoshi/bitmapfont/internal/bitmap", typ: $funcType([], [$Int], false)}, {prop: "Close", name: "Close", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Glyph", name: "Glyph", pkg: "", typ: $funcType([fixed.Point26_6, $Int32], [image.Rectangle, image.Image, image.Point, fixed.Int26_6, $Bool], false)}, {prop: "GlyphBounds", name: "GlyphBounds", pkg: "", typ: $funcType([$Int32], [fixed.Rectangle26_6, fixed.Int26_6, $Bool], false)}, {prop: "GlyphAdvance", name: "GlyphAdvance", pkg: "", typ: $funcType([$Int32], [fixed.Int26_6, $Bool], false)}, {prop: "Kern", name: "Kern", pkg: "", typ: $funcType([$Int32, $Int32], [fixed.Int26_6], false)}, {prop: "Metrics", name: "Metrics", pkg: "", typ: $funcType([], [font.Metrics], false)}];
	BinaryImage.init("github.com/hajimehoshi/bitmapfont/internal/bitmap", [{prop: "bits", name: "bits", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "bounds", name: "bounds", embedded: false, exported: false, typ: image.Rectangle, tag: ""}]);
	Face.init("github.com/hajimehoshi/bitmapfont/internal/bitmap", [{prop: "image", name: "image", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "dotX", name: "dotX", embedded: false, exported: false, typ: fixed.Int26_6, tag: ""}, {prop: "dotY", name: "dotY", embedded: false, exported: false, typ: fixed.Int26_6, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = unicode.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = font.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fixed.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = image.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = color.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["strings"] = (function() {
	var $pkg = {}, $init, errors, js, bytealg, io, sync, unicode, utf8, Builder, ptrType, sliceType, sliceType$1, IndexByte, Index, Count, explode, Contains, ContainsRune, IndexRune, genSplit, Split, Join, HasPrefix, Replace;
	errors = $packages["errors"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	bytealg = $packages["internal/bytealg"];
	io = $packages["io"];
	sync = $packages["sync"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Builder = $pkg.Builder = $newType(0, $kindStruct, "strings.Builder", true, "strings", true, function(addr_, buf_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.addr = ptrType.nil;
			this.buf = sliceType.nil;
			return;
		}
		this.addr = addr_;
		this.buf = buf_;
	});
	ptrType = $ptrType(Builder);
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType($String);
	IndexByte = function(s, c) {
		var c, s;
		return $parseInt(s.indexOf($global.String.fromCharCode(c))) >> 0;
	};
	$pkg.IndexByte = IndexByte;
	Index = function(s, sep) {
		var s, sep;
		return $parseInt(s.indexOf(sep)) >> 0;
	};
	$pkg.Index = Index;
	Count = function(s, sep) {
		var n, pos, s, sep;
		n = 0;
		if ((sep.length === 0)) {
			return utf8.RuneCountInString(s) + 1 >> 0;
		} else if (sep.length > s.length) {
			return 0;
		} else if ((sep.length === s.length)) {
			if (sep === s) {
				return 1;
			}
			return 0;
		}
		while (true) {
			pos = Index(s, sep);
			if (pos === -1) {
				break;
			}
			n = n + (1) >> 0;
			s = $substring(s, (pos + sep.length >> 0));
		}
		return n;
	};
	$pkg.Count = Count;
	Builder.ptr.prototype.String = function() {
		var b;
		b = this;
		return ($bytesToString(b.buf));
	};
	Builder.prototype.String = function() { return this.$val.String(); };
	Builder.ptr.prototype.copyCheck = function() {
		var b;
		b = this;
		if (b.addr === ptrType.nil) {
			b.addr = b;
		} else if (!(b.addr === b)) {
			$panic(new $String("strings: illegal use of non-zero Builder copied by value"));
		}
	};
	Builder.prototype.copyCheck = function() { return this.$val.copyCheck(); };
	Builder.ptr.prototype.Len = function() {
		var b;
		b = this;
		return b.buf.$length;
	};
	Builder.prototype.Len = function() { return this.$val.Len(); };
	Builder.ptr.prototype.Cap = function() {
		var b;
		b = this;
		return b.buf.$capacity;
	};
	Builder.prototype.Cap = function() { return this.$val.Cap(); };
	Builder.ptr.prototype.Reset = function() {
		var b;
		b = this;
		b.addr = ptrType.nil;
		b.buf = sliceType.nil;
	};
	Builder.prototype.Reset = function() { return this.$val.Reset(); };
	Builder.ptr.prototype.grow = function(n) {
		var b, buf, n;
		b = this;
		buf = $makeSlice(sliceType, b.buf.$length, (($imul(2, b.buf.$capacity)) + n >> 0));
		$copySlice(buf, b.buf);
		b.buf = buf;
	};
	Builder.prototype.grow = function(n) { return this.$val.grow(n); };
	Builder.ptr.prototype.Grow = function(n) {
		var b, n;
		b = this;
		b.copyCheck();
		if (n < 0) {
			$panic(new $String("strings.Builder.Grow: negative count"));
		}
		if ((b.buf.$capacity - b.buf.$length >> 0) < n) {
			b.grow(n);
		}
	};
	Builder.prototype.Grow = function(n) { return this.$val.Grow(n); };
	Builder.ptr.prototype.Write = function(p) {
		var b, p;
		b = this;
		b.copyCheck();
		b.buf = $appendSlice(b.buf, p);
		return [p.$length, $ifaceNil];
	};
	Builder.prototype.Write = function(p) { return this.$val.Write(p); };
	Builder.ptr.prototype.WriteByte = function(c) {
		var b, c;
		b = this;
		b.copyCheck();
		b.buf = $append(b.buf, c);
		return $ifaceNil;
	};
	Builder.prototype.WriteByte = function(c) { return this.$val.WriteByte(c); };
	Builder.ptr.prototype.WriteRune = function(r) {
		var b, l, n, r;
		b = this;
		b.copyCheck();
		if (r < 128) {
			b.buf = $append(b.buf, ((r << 24 >>> 24)));
			return [1, $ifaceNil];
		}
		l = b.buf.$length;
		if ((b.buf.$capacity - l >> 0) < 4) {
			b.grow(4);
		}
		n = utf8.EncodeRune($subslice(b.buf, l, (l + 4 >> 0)), r);
		b.buf = $subslice(b.buf, 0, (l + n >> 0));
		return [n, $ifaceNil];
	};
	Builder.prototype.WriteRune = function(r) { return this.$val.WriteRune(r); };
	Builder.ptr.prototype.WriteString = function(s) {
		var b, s;
		b = this;
		b.copyCheck();
		b.buf = $appendSlice(b.buf, s);
		return [s.length, $ifaceNil];
	};
	Builder.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	explode = function(s, n) {
		var _tuple, a, ch, i, l, n, s, size, x;
		l = utf8.RuneCountInString(s);
		if (n < 0 || n > l) {
			n = l;
		}
		a = $makeSlice(sliceType$1, n);
		i = 0;
		while (true) {
			if (!(i < (n - 1 >> 0))) { break; }
			_tuple = utf8.DecodeRuneInString(s);
			ch = _tuple[0];
			size = _tuple[1];
			((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = $substring(s, 0, size));
			s = $substring(s, size);
			if (ch === 65533) {
				((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = "\xEF\xBF\xBD");
			}
			i = i + (1) >> 0;
		}
		if (n > 0) {
			(x = n - 1 >> 0, ((x < 0 || x >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x] = s));
		}
		return a;
	};
	Contains = function(s, substr) {
		var s, substr;
		return Index(s, substr) >= 0;
	};
	$pkg.Contains = Contains;
	ContainsRune = function(s, r) {
		var r, s;
		return IndexRune(s, r) >= 0;
	};
	$pkg.ContainsRune = ContainsRune;
	IndexRune = function(s, r) {
		var _i, _ref, _rune, i, r, r$1, s;
		if (0 <= r && r < 128) {
			return IndexByte(s, ((r << 24 >>> 24)));
		} else if ((r === 65533)) {
			_ref = s;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				i = _i;
				r$1 = _rune[0];
				if (r$1 === 65533) {
					return i;
				}
				_i += _rune[1];
			}
			return -1;
		} else if (!utf8.ValidRune(r)) {
			return -1;
		} else {
			return Index(s, ($encodeRune(r)));
		}
	};
	$pkg.IndexRune = IndexRune;
	genSplit = function(s, sep, sepSave, n) {
		var a, i, m, n, s, sep, sepSave;
		if (n === 0) {
			return sliceType$1.nil;
		}
		if (sep === "") {
			return explode(s, n);
		}
		if (n < 0) {
			n = Count(s, sep) + 1 >> 0;
		}
		a = $makeSlice(sliceType$1, n);
		n = n - (1) >> 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			m = Index(s, sep);
			if (m < 0) {
				break;
			}
			((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = $substring(s, 0, (m + sepSave >> 0)));
			s = $substring(s, (m + sep.length >> 0));
			i = i + (1) >> 0;
		}
		((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = s);
		return $subslice(a, 0, (i + 1 >> 0));
	};
	Split = function(s, sep) {
		var s, sep;
		return genSplit(s, sep, 0, -1);
	};
	$pkg.Split = Split;
	Join = function(a, sep) {
		var _1, _i, _ref, a, b, i, n, s, sep;
		_1 = a.$length;
		if (_1 === (0)) {
			return "";
		} else if (_1 === (1)) {
			return (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]);
		}
		n = $imul(sep.length, ((a.$length - 1 >> 0)));
		i = 0;
		while (true) {
			if (!(i < a.$length)) { break; }
			n = n + (((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i]).length) >> 0;
			i = i + (1) >> 0;
		}
		b = new Builder.ptr(ptrType.nil, sliceType.nil);
		b.Grow(n);
		b.WriteString((0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]));
		_ref = $subslice(a, 1);
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			s = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			b.WriteString(sep);
			b.WriteString(s);
			_i++;
		}
		return b.String();
	};
	$pkg.Join = Join;
	HasPrefix = function(s, prefix) {
		var prefix, s;
		return s.length >= prefix.length && $substring(s, 0, prefix.length) === prefix;
	};
	$pkg.HasPrefix = HasPrefix;
	Replace = function(s, old, new$1, n) {
		var _tuple, i, j, m, n, new$1, old, s, start, t, w, wid;
		if (old === new$1 || (n === 0)) {
			return s;
		}
		m = Count(s, old);
		if (m === 0) {
			return s;
		} else if (n < 0 || m < n) {
			n = m;
		}
		t = $makeSlice(sliceType, (s.length + ($imul(n, ((new$1.length - old.length >> 0)))) >> 0));
		w = 0;
		start = 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			j = start;
			if (old.length === 0) {
				if (i > 0) {
					_tuple = utf8.DecodeRuneInString($substring(s, start));
					wid = _tuple[1];
					j = j + (wid) >> 0;
				}
			} else {
				j = j + (Index($substring(s, start), old)) >> 0;
			}
			w = w + ($copyString($subslice(t, w), $substring(s, start, j))) >> 0;
			w = w + ($copyString($subslice(t, w), new$1)) >> 0;
			start = j + old.length >> 0;
			i = i + (1) >> 0;
		}
		w = w + ($copyString($subslice(t, w), $substring(s, start))) >> 0;
		return ($bytesToString($subslice(t, 0, w)));
	};
	$pkg.Replace = Replace;
	ptrType.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "copyCheck", name: "copyCheck", pkg: "strings", typ: $funcType([], [], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [], false)}, {prop: "grow", name: "grow", pkg: "strings", typ: $funcType([$Int], [], false)}, {prop: "Grow", name: "Grow", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [$error], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [$Int, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}];
	Builder.init("strings", [{prop: "addr", name: "addr", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["path/filepath"] = (function() {
	var $pkg = {}, $init, errors, os, runtime, sort, strings, syscall, utf8;
	errors = $packages["errors"];
	os = $packages["os"];
	runtime = $packages["runtime"];
	sort = $packages["sort"];
	strings = $packages["strings"];
	syscall = $packages["syscall"];
	utf8 = $packages["unicode/utf8"];
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = os.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sort.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = syscall.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrBadPattern = errors.New("syntax error in pattern");
		$pkg.SkipDir = errors.New("skip this directory");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["io/ioutil"] = (function() {
	var $pkg = {}, $init, bytes, io, os, filepath, sort, strconv, strings, sync, time, sliceType, sliceType$1, ptrType, blackHolePool, readAll, ReadAll;
	bytes = $packages["bytes"];
	io = $packages["io"];
	os = $packages["os"];
	filepath = $packages["path/filepath"];
	sort = $packages["sort"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	sync = $packages["sync"];
	time = $packages["time"];
	sliceType = $sliceType($emptyInterface);
	sliceType$1 = $sliceType($Uint8);
	ptrType = $ptrType(sliceType$1);
	readAll = function(r, capacity) {
		var _r, _tmp, _tmp$1, _tuple, b, buf, capacity, err, r, x, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; buf = $f.buf; capacity = $f.capacity; err = $f.err; r = $f.r; x = $f.x; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		err = [err];
		b = sliceType$1.nil;
		err[0] = $ifaceNil;
		buf = new bytes.Buffer.ptr(sliceType$1.nil, 0, 0);
		$deferred.push([(function(err) { return function() {
			var _tuple, e, ok, panicErr;
			e = $recover();
			if ($interfaceIsEqual(e, $ifaceNil)) {
				return;
			}
			_tuple = $assertType(e, $error, true);
			panicErr = _tuple[0];
			ok = _tuple[1];
			if (ok && $interfaceIsEqual(panicErr, bytes.ErrTooLarge)) {
				err[0] = panicErr;
			} else {
				$panic(e);
			}
		}; })(err), []]);
		if ((x = (new $Int64(0, (((capacity.$low + ((capacity.$high >> 31) * 4294967296)) >> 0)))), (x.$high === capacity.$high && x.$low === capacity.$low))) {
			buf.Grow((((capacity.$low + ((capacity.$high >> 31) * 4294967296)) >> 0)));
		}
		_r = buf.ReadFrom(r); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		err[0] = _tuple[1];
		_tmp = buf.Bytes();
		_tmp$1 = err[0];
		b = _tmp;
		err[0] = _tmp$1;
		$s = -1; return [b, err[0]];
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  [b, err[0]]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: readAll }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.buf = buf; $f.capacity = capacity; $f.err = err; $f.r = r; $f.x = x; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	ReadAll = function(r) {
		var _r, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = readAll(r, new $Int64(0, 512)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ReadAll }; } $f._r = _r; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ReadAll = ReadAll;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = os.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = filepath.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sort.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		blackHolePool = new sync.Pool.ptr(0, 0, sliceType.nil, (function() {
			var b, b$24ptr;
			b = $makeSlice(sliceType$1, 8192);
			return (b$24ptr || (b$24ptr = new ptrType(function() { return b; }, function($v) { b = $subslice(new sliceType$1($v.$array), $v.$offset, $v.$offset + $v.$length); })));
		}));
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/bitmapfont"] = (function() {
	var $pkg = {}, $init, bytes, gzip, bitmap, font, fixed, ioutil, sliceType, compressedFontAlpha10r, compressedFontAlpha12r, init, init$1;
	bytes = $packages["bytes"];
	gzip = $packages["compress/gzip"];
	bitmap = $packages["github.com/hajimehoshi/bitmapfont/internal/bitmap"];
	font = $packages["golang.org/x/image/font"];
	fixed = $packages["golang.org/x/image/math/fixed"];
	ioutil = $packages["io/ioutil"];
	sliceType = $sliceType($Uint8);
	init = function() {
		var _r, _r$1, _tuple, _tuple$1, bits, err, s, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; bits = $f.bits; err = $f.err; s = $f.s; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		_r = gzip.NewReader(bytes.NewReader(compressedFontAlpha10r)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		s = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$panic(err);
		}
		$deferred.push([$methodVal(s, "Close"), []]);
		_r$1 = ioutil.ReadAll(s); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		bits = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$panic(err);
		}
		$pkg.Gothic10r = bitmap.NewFace(bitmap.NewBinaryImage(bits, 2560, 3072), fixed.I(3), fixed.I(9));
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: init }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.bits = bits; $f.err = err; $f.s = s; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	init$1 = function() {
		var _r, _r$1, _tuple, _tuple$1, bits, err, s, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; bits = $f.bits; err = $f.err; s = $f.s; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		_r = gzip.NewReader(bytes.NewReader(compressedFontAlpha12r)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		s = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$panic(err);
		}
		$deferred.push([$methodVal(s, "Close"), []]);
		_r$1 = ioutil.ReadAll(s); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		bits = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$panic(err);
		}
		$pkg.Gothic12r = bitmap.NewFace(bitmap.NewBinaryImage(bits, 3072, 4096), fixed.I(4), fixed.I(12));
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: init$1 }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.bits = bits; $f.err = err; $f.s = s; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = gzip.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bitmap.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = font.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fixed.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = ioutil.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.Gothic10r = $ifaceNil;
		$pkg.Gothic12r = $ifaceNil;
		compressedFontAlpha10r = (new sliceType($stringToBytes("\x1F\x8B\b\x00\x00\x00\x00\x00\x02\xFF\xEC\xFD\x0Ft\x1C\xD5\x99\xE7\x8D\x7F\xEF\xED\xEA\xEE\xEA\xB6\xAC.\xB5\xDB\xB8C4\xA8\xD4\xB4\xA1\xD5\x90X8L\"2\x8ATjd\"\x8B\f4\x1A3a\xF3\xCB\xC4\x1D63K8\xF9\xCD(\xDE\xD9\x19&\xC3JWm9\xB4\x15\x0En\x1Be\xF1\xEC\xF0\x86F\xC8\xA1\xDDf0\x93\xC9\xEE\xB0lb\x1AB\x12\xE3\x99\xDD8\x99\xBC\xEF\xE6\xCD\xC9\x0E\x8D\x81\xC4q2\xA1!\x99\xB3m\xE3#\xBD\xE7\xDE\xAA\xFE'K\xB6d\f\x01\xF2|\xCE\xA1T]U}\xEB\xD6\xF7>\xF7\xB9\xCFS\xF7\xB6\x19\x85\x9B[\xE5^\x9D\tD}\x10\x00\x87\xA8@\xA2s\b\xE8\xA8\xE1\xB6\xFF\b\xC3\xC4\xEB\x81\x15\xD1\xC3\x01\xAB~D\xE7\x8B^X4\xBBW^:g\xA2\xFE!\x85\x16\x97\xB0odx\x00\xCBh\x05L\xC3\xC7E2\n\xB5\xC7,C\xF71\v1\xCE\x90\x8D\xB9\x01C\xD7\xB8\x954\xF4\xC5\xAF\x1B\xAD]\x07\xFB:0k\x14\xFE\xEDE\x11\xD5\xB9e]]\xD5\x0F\r\xFAq\x06\xE8.\xF9\xD1\xCD,\xB3[\x830\r\xA7zVJ\xF7\xB8\x8Af\xAF\xC7UL\x85e\x1D\xA1\xBBD*\xDC\xCAD\xA97\xC0\x8A\xD9v\xC6-\x11\xF51Q\n\xB7\xB2b%\xEA\xE3V6\x1A`\x10\xBA[\xEA\xA7\xCBo\xB8`\xDF3U{\xE8\xAA\xB0\f\xA6\xEE^\x81r:G\x11Q\xCE\xADd\xAFG\x16\"k`\xA8\x87\t\x00\xE8\xF6q\x14e\xED\xED\x8B\xA3\x81F\x9DK\r\x8A+Z\xABg\xC3\xCD-Z\xABZ\xF5\x9E\x80m\x7F\xA6\xD4\xEFJ\x7FU\xBF\xBE\xBA~\x9A\xBD\xB1\xF5\x1B\xED\xF6K\xFD\xDCv5\xACl\xD8\x07+e\xEA\xB0\xB2\xAA\xA1\xA0\xC9=)\x93\xA9sdu\xC6\x85\xB8r5W\xC7`\xDA\xFA1\xA9\x9F.`\xDA\xFAi\x8E~\xE6\xA2\xFA\xF9Wfz\xC8\xC68\x07\xA2L\x96\xE9\x03\xB2\x86&\x1Fu\xB5l[\x1F\x83ep \x15\xF60\x91\n\xFBe\xA7\v\xB8\x8A\xA3\xED^VLF\xD51\x0Fwj/7\x8B\xDD\xC1\xACU\xCD\xA8\xEB\x17\xF6\xA7-\xD1\x1B`\xA2\x1CmY\xC4\xFEtX\xE5^[?W1\xA7\xF9!,\xDD\xB9D<\x16c\x10\xB9\x9EV\x88l\x94CX\xBD\x1C\xD6cR\xAB\xAA~.\x88\xABW5\xEB\xC7\x19,\xE9\x14Li\xA7\xA3a\x8D\x15K\xB2\xE2f\xAF4\xDB\xF6U\xACX\xAE\xD9\xA9\xA9\xAFD>\xDD\xCB\x902d\xFF\r{\x99\x05x\x80T\xAF\x0E\x81\xA8\xD2\xCF\xC3\x85e\xB4\xC8\x9A\xAA\xE2\xFD\x1CBVR\xFE'\x92WWU{\xAC\xA6\x9F\xA3s@\t[\xDD\xF4\xD8{@\xCA\xBE\xAE\x95[\xA3\xBD\xEEz\xC3\xBBD\xA9\xD5\xB5\xBD\x04\x04\x04\xD0\xDA\xEA*U\xA4\xFD%\x8D\x80\xF2\x84\xCC*\x855\xC0\xD2\x03\xAE\"z\x01qT\xE7L\xE44\x1FDJ\xDA\x9F\x80\x94\xB3\xB7\x95#\xDB\xD3\xCA\x8Be\xA5\x9Fs#&\x94~\xA9\x98\xE6\xE8\x07\xCD\x96\x89[Y\x9Dsa\xC6\xD5\xC7\x16\x0E\xCB\xD1\x99\xC3\xD4V\xA4\x9F\xDFUL\xF5\x82[\x90\x9E\xAB\xDC.\xBFl\xB4\xBA \xF5\x13\x90\xAE\xAA\xBB\xDD\xC5\xE0\xE8\x17\xE0(\xF5\xB4\xBA\x94\x86\xA2|\xA5\xAD\x1A\x13G\xD5\xD9\x98\xCF%\xA4\xE9Z\x86\xC6\x1D9\xD5uU\xEBt\x15\xEBv:\x1A\xF6o/\x95{\x03\x80e\x06\x84j\xF3\xBA\xFD\xC9\xE6aH\xDA\xF6\x07Wq\xD4\\%\xF5\xB3\xED\x8F!\xABk\xB0\xCA\x9A\x8F!\xDB.\x1B\xA0\x973\xD4\xEC\xCF\xCA\xEA>.\x94~\xA5\xA8\x0F\x96\x19\xF5\xB9\xAC\xAC\xA1W\xED\xAA]^\xD7\xAB)\xFD\\p\xF4\xD3\x99\xB0\xE4u\xA9\xA8\xB6b\xFB\xF37\xDA\x9F\xF2\fv7\x8B*\x03\tp\x91\xD4\xDC\x1C\xAA\xD7\x96{\x9B\xED\xAF\xA6\x86\xBD1\xA4]\xC9\x8E=\xDA\xEEu\xBE\xD1\xA4\x1FP\xAE\xEB\x077\x84\x88\xAA.\xA5\x04\xB3\xF5s\x95\x1C\xFD\xA0\xDC\x88\xDD\xED\xADd\x8B_\x8EG\xEE\x9A~:\x97\xBA0d5Y\x1F\xE5\xCD\x9A\xF4\xB3\x94~\xC2\xD6\xCF\xCF\x8B\r\xFA\xD9\xD7i\xCD\xF6\xA7\xC3\xB2\xD4uQ\xFD|\xF4\xCBJ\x0F\x82\xA8\f\x12\xA4\xFF\xB3\xB9\xD2\xED8\xADQ\xDD\xCB\xB1h\xFF]\xA8\x9F^\xFB\xD8t]\xF5\x92\x9A\x15+\xFD\xFCB\x94{\x02@\xB9Q\xBF\x9A\xFD\x05\\\xC5\xAC\xB1J\xD9\x1F\xB3J-n\xA9\x9F=Vp\xA4\xF4\x00\x13f\xD8\xC3\x90\n+\xA7\xAA3\x8CF[Y\xB1\xD4\xAB\xCB\xF1\xD7\xC3\xAD\xB2\xEC\x15\"\xECs\t3\xDC\"\xAB\x16`0l\xFBk\x95\xED\xAB\xC9\xEB8\xB7\xBA\xE3r\x9Cn\xD7]\xA2\xBB]^\xD7~\x1E\xFE\x8F\x17apn\xA17\xA0\xC6_@:\x19\xE0j\xB72D\x0E\xA3\x9D\xB1j\xCF\x93\x8E\xB66~\x94\xA25\xBF\xA6\xDC\x9C\xA1\xBB\x84c\x7F\x01V\xACZ\"+\xA6\x9C\xEB\x18R\xF61\xF9\bu\xFB\xEBm\xD2\xAFR\xB3?4\x8F\x8D*\xFE\xB3d\x85\x96\x8D\xD1\x14\xFF\x19=p\x15\x1B\xCB\xAC\x96$\xEA\x0EO[y\xFC\xC7\xCF\x88\xFF\xEA\xA3\xE6\"!\xABX\xAC\f\xD1X\xD69\xAF\xD3tY{\x7F\xE3\x15g\xD8\x1F.\x04-g\t\xA7E\xFDt\x83~a\\0L4E\xEB\vc\xB8\xA5\xDB\xE2\x9C\xD7\x85u&@\x10\xC4\xDB\x962T\xB2\xC2a\xA5dp,\x87';e\xCCF=\xF2\xBC\n\xC5\xE5F\xBA*\x95\xE6&C^y\xB6\xEA\x95m\x17\xA9\x12\xA5P\xF5\x15\x83\tp+\xDB]-~(X\xBDN\xE6)VJ\xED\x85dQ10$C\x01\xFB\x84P\xD7\xA5dP\x9E\x94\x1BD}o\x92\bK\xDFh\x89LN\xFAEK\x85\xD8\xE8\x95c24\x19\xDD\x00jt\xB6Fe\xAC,C\x12Q\x86\x87\x89\xAC\x1C\xB6!\x87\xEDl\xD4\xCD\x90\x8B\x81\x15Sa\xAF\x1CgV1+\x19\xD2&\xE4`#\xC3\x19\xCEQ4<\fVT\x8Am\xC8Z\xF5\xAA\x02\xBC\xCE\xDB\x0F\xD9F\"\x1B\x92\x91\x82\xCC\xB7L\xC3\xEB\x12\xB9\x98\xBA\x9B\x9B\xD9\xA1)Bn\x99Ch*\x98Xl\xF4\x93>\xFBL\xAF~\xDB\x99c@\xCE\xFE\xDB{n\xFD\xC2\x9E\xA5\xCEx\x96\x1A!<\xCC\xCE]R2Q\xCC\xAAl\xD1\xDE\xB4\xC2\x1Aj\x97\xE1\xA04B!7\xA3\xF0\xCA\x8D|63\xB0\xBDX\xB2?r\xE7\xD8(\xDC\f0=\x1C\xA6\xDCXa\x19\x82]-\xF3(s\xB5Sh7\xFC@I^\\\xAA\x155*\xF3\xFDQ\x83K%|\xF6\x90\xE7$\xFD\xF2C\xA6\x17*Gd\x8B\xB4\xBE\xEA.g<U\xF6\xCC\xEB\x8A\xB5P\xE8\x9C\xFA-y\xC6{\x16\xC3T\xBAd\xDB}2\x84\xF5\xA1\x98\r\xDB\x1BV<\xAE\xEB2\xE8\xD5\x99(\x85\xAB{j\x93\xEDq3X\xDD\\F\xCDj\xE3c\x96\xA9{\x98\x994e\xBEjr.\x92\xDD.\x97U\xEAmuY\xA5\x96\x80K\xC8\xF2\xC4P\xCB*V\xCC\xC6|\xCC\xCA\xC6t\x14E\x8B&7\xDC%\xCC\x1E\xAFK\xD4c\xF9\xA1\xA0\xDC\x8B\xB8\xB9\x95\xD4\x03\x10e=\xB0h\xF4\xB0h\xEC\x99\xBD\xF8\f\xFDD\xDE\xB6\xBF\xC0\xB9\xFB\xEF\x92\xF6\xA7\x9F\xC5\xFEr\xBD\xEAuG@f\t:\x93y\x8A\xDC\xC8\xE7\b\xB7\xF2b\xE9\xCAV^\x14r\xF3Xt\x15\xB7\xD4\xA6\x1C\xF5\xB2\xA2e89\x8D0u\xA5\x9F\x9B\x15SU\xFD`\x19\x1E^\xCC^\xE9\xE3\xC5\xAC\x7FUM\x17?\xCF\x95\xAEne\xB9\xD2\xD5*\x82\xE7\xF6\x06\xA6\xB4\xBF\x05\xFA\x95\xE3nn\xA9\x13\xA6\xC1]\x8B\xD4\\\xC6\xDEg\x9A\x85r\xC8\v\xF4{\xCC\x0E\xDE\x03\xAF\xC3\xFF\xADZ\xCA\xFF\xF9X\xB1|\xF1j^l\xC8\xE9L{\xC3\xAD\xA1\x98\xEE\x82\xE8\xAEn\xAA&*\x93\x1F73\x1B\xF5[\xCD\xAC\x9C\xEEn\xB0?X2\x85\xCA\xAA\x17\x1AM\xFA\x15\x9D\xE2\x95\xDF\xF5\xA9W\x1B\xCC2C\x9CYg\xE8\xC7Y\xD145\x0E\xCB\xD4\x16\xB3?\xBE\xB8\xFD-\xA2\x9F\xED\x00\x97\xF1\x1A\xE7,\xE3\x07+.~\"\xC0\xAD\xDC\x95\xAB]\x96#\x8E\x07E\xE9\xAE\x8B\xA9\xB0\xCC\xE9\xC2\x01&\xCA\xB5MJ\xF3\xC0R\x1B\xA5_\xA9\xC7[K\n\xFD\xCC\xB2b\xDA\x84\x99\xEC\xF5\xBA\x8A\xA3rS\xBA\xC4[M\xBE\xFD\xD5\xD7h\xDD-^Vr\xF4k\x95N\xC1#7\xD5VH\xB5{XQm\xBA[=\xAC\x98\rqn\x99\xF6[\x92E\xFB\xAF\xECQg\xBEXM\x85\xCF\x1C!S\xCB\xED\xBFK\x8F\x1F^,m\x7F\x8F]\xD2\xEA\xB2{w\xF7Ri\x9A\x1D\x9C\xC8\x91\x18\xE1\x05\xA9%\xB3K\x160\x9C\xF9\v\xD1\x90d\xDAolx\xF3\xF0\xC9y==\x12N\xC8sF\xDE$\x1C\x85\xCE\x8E\xF6\xA6\xC5w\x94\xA1\x11\x04A\x10\x8D\x03\x15[t\\\xCD\xA8\xB10x\xC1n\x93\x82\x97\xBDS$\x13*\xF9v>\xB8!\xD0^=\xD3S\xBBf\x14n \x19\xBD`\xF7\xCC\x82\xBFS\xF4s\xB2\x9D\xC50\x9A\"(\xE4.\xDCM-\x99\xA5^\xC8\xA7\b\xFF\xFA\xF4\x13\x96\xAE\xE1M\x8E\xE6\xCC\xF0\x05\xB6\xBF\x96\xDF,7\x9B\xD5\x96p\xB4\xE7\xCB\xD5o\xC5\xA74\xDE\xB0\x92Sa\x8EwH\xFF=\v=\xCD~\xF2B\xF6_]c\xBFa\x91\r%\xBC\x04A\x10\xCB\x8B\x90u\xCE\xACr\x9F\x0F\"\x19\xF603\xA9\xBB\xB9\x95W\x13\x14\x9E\xF3,\xEF\xF5\x0EY\x8B\x1D\xD3\xD4Z\x1C&\xCF2X\xE7Z\xC0\xEEf\xF6zGs9\x03$\xAB\xA5Z\xE7W]\xC3\xCD\x85Z\xED\n]\xAD\xB3t3s4\xAAAX\xFC\xBC\"(\xF3\xF5\x06S\xD6\xA2\x8D\xA2\xC1^\xBEl\x81CX\xE1VW\xD1\xEC\rp+\xD5\xEEc\"\x1B\r0Q\xEE\x81\xAB8\x1A\xE1\xDC\xCA\xAB\xB5\x9C\x86\xC6p\xD4\x9E\x91\xB5\xD7\x85\xBB\x9C\x95\xE4\r\xF8\xB9\xA5\nE\xD8\xE7\xB2\x1A\x7Fj\xA0/\x1D\xB4Y\xA9\xA5\xAB^\xB78\x0F[\xD9\xEAY\xF3\x8D\xE9\x1C\xB5\xE9\xB7\x90\x07(G\xBDR\b}\xA2\x98S\xEB\xA9M\xC6\xAD\xAC\xEEg\xA2|5\xB8\x95\x8D\x82\xC3\x8Cx\xB9\x95\x8Fxk1\xBF\xCF\x99\xC2\xCE\xDA\r\xB3\xD4#E=\"\x97m\xAF\x7F\xF6\xB1\xB3\xBD\x12x#\xF2\xBC7X?\xF8 D\x94\xCB\xDA\xBB\xB9iE[9\x92=\xDCU,\xEB-\xDC*\xF7\xAA\x95\xF3`0C\xFE\t1\x1A\xE1\xCC\x1Am\xF73d\xDB[\x99\x95j\xD7\xB8(\x1B>V\xCC\x86<LT\xC2\x1EV,GW1+\x1F\xD1\xB8\x95\x8A\xEA\x02\xB8\x84sq[<P3\xBAU\xAE\xE2b1\x7F6\xECE\xB1\xDC\xFEFx\xD17\xDAM\x07\x80R\xAF\xD2\x8Fs\xD3\xEA\xF5q$\xED\xB5\xBF~ne\xAF\x94\xF6\xD7c\xFF\xE2aB\x98\x11\x0E\x91\xEDY\xADf\x96\x99\x95\xED\xD1]\xF6\x92\xE6lH\xE7VR\xFD\xD4%\xEA\x9F\xB0\xF2qM\xAD\xD0\x15\x80\xA6V\x10\xEB5\xFDV7=P\xEDuV2\xAAC\xDE\xE8m\xA3_\xA3\xFD\xC1\xB1?\xCE\xAC\xA4\xEC\xBF\x19{\x8DuM?S\xF6_\xDD\xCB-3$\xF53}jf\x99YYSZgH^\xA7{\xA4~j\xE3\x17b4\xEE\xAE\xEA\x17\x95\x83M\xBC\xBE\x90\xD4\xD7\xE4\xFFj\xF6\x97\xEA\x91\xFA\xBD\x11}\xEDB\xE6<\xB6\x1Fw&@\x1B\xF4s\xFC\x1Fw\xA5L\xD9\x7F+\xCE\xF8a\xFFXDdM\xA8U\xF2\xDC2\xDF\xEF\x85\x18m\xF7A\xA4\xDA[\xE5\x86q+%\xC7\xC6\x92\xCE\x98H\xF60&\xCC\xB0\xD7\x9E\xBC\x17\xA9\xB0[*$\xF5k\xAF\xFF\xDA\x89\xB1E\x9DS\xD6\xF4\xCA[\x9E\xBFJ\xC9\x05\x07z\x03\xE2\x8Dz\x1B\xE2\xC1\xEB\x9C\xE6e\xB5\x81\x94;\xDDC\xA8BMU2ggDAK\x06^\xED\r{\x94\x1D\x13\x04A,\x8F\xE8o\xEE\xA3{\xCF\x88@\x17\xA5\xB7\xD5UL\x85\xBD\xACh\x84\xFD.\x91\x95\xC9w\xAAG\x1E\xEB\xF5O\b{Mj\xD4\xE3*\x96\xC2*\xB4\xF23+\x1Fo\xE5\xA6\xD5\xE3c\xC5\x86\xB7\xF1\xCD:/\xCC\x11cj\xE2\x8B3\xCBP\xF3\x88\xF0\xBD\xDE\x11Z=\x9B\x8A\xD7\x96,J\x17\xC8\xA0\x1E\x92\xE8\xCBz\x8F\xDETqg\xE9_\xF5\x98k\xF1\x95\x80\xA6\xC6\xED\xD5\xEFF\xCC\xCF\x90\x93\xFA\xA9E\x949\xD3\x9F\x96\xE1%\xB3\xCA\xD5_\x94Z\xA3\xB6~2\x05\xD0\xFCi\xAB!m\v\x9F=\x9Dk\xAD\xD7\xDE%,x^\x9F~eM\xAB\xE9\xE7\xBF\xA0\xFAe\x17\xB1\xBFl-\x02]\x94\x1E\x0FG\xD1\x90\xFA]\x19`\xA2\xA8\xF4\xEBi\xE5\xC8\xF5x!\x1E\xBB\xB2\x85Y\xE5^\xF5\x93r\xCE\xAD\xBC\xAE\xF4s\xB9\xCCT{k\xDA\x1A\xEDQ\x8B-\xFD\x13\xC5l\xD4\x87bF\xD9i\x8BW\xFD&\x93[\xF9x\v\xB7D\xD8\x8F\"\xC2\x9A\xAB\xD8\xDD\xEEa\xC2\b\xCB\xB4\x14x}\x93z\xA2\xB7U\xDA\x86\x97\xE7\x80\x96\xA5\x16\xD8\xBA\xB9\x99\x8C\xF0\xDA\xD9\xD6eEnF\x83\x1DT\xD7;\x96\xEDcK\xFD\x92\xC1ts\b]\xEA\x17\xF7OXE\xD9\xCB\xA4\xC1!g\xFA\x85u\xF4j\xBF\xB3\xC0\xB6drV\xCC\xEB~\x14\xF3q\x9E\xCE%5\xA5Z+C\xF2J/\x8A\x8F]\xD9\xCA\xAC\x1F(\x9D\ri\xA7a\xA5\x9F\xC7e\x95ZV3\vWz8R\xDD\xF2\x1E\xEF\r0Q\x82\xEFu\xEAg/\xEC\xF5O\x14\x01\xFFR\xF3\xFB\x9CY\x95P}\xCD\xE7\xF2nYn\x98\x9F\xAE\xCE<f{\xCF\xA9\x9F\xEA\xBFY\xA9_\x0E\xCE\x8Ad8\xFD\xD7\xE7\xE8'\xB3O\xD9\x7FaU\xF5K;\xCB\xA6\xBB\xAB:\xE7\xED\x1F\xCF\xCA\x045\xECc\xC5|\xDC\xCD\x8BYm5\x8A\xE8vsX-\xD56R>\xE2u\xEA'U\xF3\xA7s\xF2\xB1\x96\xD2\x0F\xC2\xECs\xAFP\xBF\xEC\xD5\x8B\xE8\x17=\xAB~\xBD\x8CC\x8D\x1F\xA9+W1+\v\x8D\x15U\xFF-\xAB\xF1\xC3v}\x1E\xD9\x11\xB9K\x98\xA1\x00\xACJ\x9F\xEC\xBF=\xEA\xB7\xEB\xAD\f\xE5p\xF5\xBA\xBC\xBC\xAE$e\x1A\x8D\xAA\xEB\xA4\xFD\x85\xFD\xCCB\x98qt\xF7xY1i\xDF\x83/\xB5*{e\xF6'\xF5\xD3\xD3\xD6\xD2\xFA\xE9\xEE\xDAC/O\xBF\xC6U\xD4\xDE\xEA\xF8\x11v^\x89\x16\x97\xBA\xD1\xA2/\x03\xB2Kf\x95\xFCl\xEF\x13\x85=\xC2.\xB8\x8E7\x0F,\x17h\x1D\x8AzA\xBF\xF4[z!\xD3_\x93bP\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \x887\x19\x0EQ\xDDcK]\xC2\x97]\x9A\xB9\xF4)m\xA9\xEB\x96\xBC/\x00\xCB\xE0\xB0\xB2o\x15\xAD4\xB6\xA8\x80\xF5\xDA.\xF5E\xB1\xEC[\xE8K\x9Fb\xCB\xBC\xAEIg]\x83@\xE8-gkuZk\xFA\xB5.\xA5_\x80Y\xCB\xBD\xC3YL\xA5\xB5\xF1\xC3h\xC3\xBE\x97\x9D\xAD<\xDFY\v}s\xD1\x17\xB1#\x9F\xABz\xD0\xC7\x8AK|\x8D-\xFB\x0E\xE5\xAB\x97<U\xBF\x914\xE8\x96\x86Vu-m\xDE\xD9\x88\x8F\x9B\xD9\xC8[D?7\xB7\x16\xB1\xBF\xEA1\x1F_\xC2\xCCZ]\xCB\xEE\xBF\xE5\xF8\xD2\xF6\xD7X|*\xBC<\xFFW\x8E\x07x\xEE,\x85\xBE\xC9\xFDw\x11\x85|\xE7\xD6o\x05\xF6\x97]\xFAQ\xF5\xC6V0\xB4F\xFD\xAC\xB7\x8B~\x8B\xF4\xD0\xBAq\xB5^\x80\xFE{6\xFD\x1AG\xF1R\xF8\xEC^\xB9V^\xC8\xC7\xACl\xE8-l\x7Fo\xE6\xE8\xF5\xB6\x87\t\nx\t\x82 \b\x82 \b\x82 \b\x82 \x88w\f-\x1E\x00\xEF_-\x16\xBC\xFC\xAC#\x86H\xA4\xB3\xE0i\x01\x13\xEF~7\\\xA9\xC5\xF4\xFB$X\xC3\xD4\x98\t\x04^\xDF\xDBES\x07`\xB5\xBBXQ\xEDA\xD7\xCE\xBB\xA8\xEE\x05\xB3\xA5g\xC5\x92\x0FWj\xD7pa_\x8E\xBA\xD5VU\x83[}\x8Bh\xB3Gn\xF2\x86\xDF\xBENK\xD6\xA6t\x8D\xF3\xBBaR=\x8C\xA1\xC1J\x8680j\xAC\xEC\x85\xB5\xABh\x02\xF6\x14\x84e\x01+\x98\xF3\xEA\xE5\xC0\xD1+\x03\xAE\xE2\x1B\xA0\x9Fj\x14f.f\x7F\xD3\x8D\xFA!\x93lo0\xC5\xF3\xD2/\xAC&\xE6<\x10f\x8B\x97\x15a\xF0\x15\xBD.\xE7\xB2\x01\x98\xBAw\xA9\x040k%_\x15\xC0\x1Bc\x7F\x0E\xBA\xD7s\xC6\x05\xB7\xC9\xCDQ\xDDmw\xB5d\xB2\xE5\xF5\xEA'\rxTsC$5\xDB\xFE\x98e\xEA\x9C\x89\xE5\xF5iW\xB1\x04\xB8J\xB2\xB9\x8B\xD6y\xE8w\xC1ho\x0F\xB8\x8A\x95\xFE\x7Fm:\xE6\r\x00\b\xFF\x8F\xC7\x1A\x8E\xBD\xBB\xBEkp\x1E\xA9\xF7\xDF\xF3\x9C\xA42\xA5\x01\x9Ba\x0Ea\x86m\xAD\x98\x95\f\xBBa-\xAFOsQr\xFA/\xB7J\xBFN\xFD\xAA\xF6'\xDBRY\xDDj\x81v~\xA6~\xD1\xFAM\xA5\xFD58\xE4\vW\x89\xA4\xCE\x98h\xEA\xD3g\xD1/Ys\xD7\xD2\xFF\xFD\xDA\xF5Cu\xCEQ\x13\xD0\x03\x9F?\xE3\x82O5\xDD4S\xB7?q!\xF5\xE3\xB0\x9A\xFA\xF4Y\xF4\xCB9\xFA\xB1b\xF7J\xC6\x8F7H?\xE5K\x94\xBB\xF1-\x1E\xFF\xFDu\xE3\x07\xA6\xBD!\x11\x94\xD9\xEEe\xA2\xA9O/k$^\xE1]\xDE\x18\xFD\x9A\xC6\x8Fs\xC6\x12&\x85\xCB\x04\xF1\xE6\xB3h\x90\xBADotV\x18u\xAF\xF8\x1EZ\xB1\xB6Wz\xFC\xBD\xFA;I\xBF\xEA\x9A\"cA.\xD5\xBC\xD8\xB2\xEF\x86\x8C\xBC\xD6\xD6u\xC5o\r\x98\xDEY\xDB\xFBdO\xC2@{\xE0\xAEW~\xFE\xE7\xEF\xFE\x1F\xAF\x8D\xFD\xE5oU\xA55|\xEE\x019z\xE7\xE2\xE2\\\xEE\x1E&\xB4\xC0[E\xBF\x8F\xDB\x7F\xAF(6\xEB\xD7\xD2\xB4l\xD6\x18\xFC\x81\x8Cd\x8C\xF3\xD4\xCFH\xD4\xF6\"\xB1I\x13\xBA\x9B\xE7\xF2\x11\xFF\x8E\x9B\xE2\xF1Z;-7m6\xBC\xB0L\xB4\xB6\xE0\x0Eq\xA1\xC6M\xEBu,\xB1f3\xF6\xDF\xF8\x02\xFB\xF3\xE7\x1B\x0F\xAC\x1B\xCC\xD7\xF5[y\xFF5_\xAC\xEF]\xA3Y\x8D\xFA\xD5\xF2Di\x7F\xC9Xhj\xA60\xD3v\xD6\x91\xDE/L3\xBA\xD6\x8F\xB0\xC5.T\x98\x84\xC8\xEB\x11_\x11l<\x96\x02|M\xFA\x85\x1A\xF5[y\xACb\xE9\x8Do\x8B\x84\xAD_\xC8\xBF\xE3\xA6\xDB\xA3\xFCL\xFD\xA6\xFDg-+h\x19fB\xF3!f^\xA0%\x85\x812\xC6_\xB7~MQg\n\xD0\x17\xD8_\x83\xFFK\xAE\xF8\x1E\xF7\xAF\xAB\xED\xAD\xD9\xF1\xD4\xE89\xF4\xCB\x9C5J\x9EO\x07*\xE6\xBC\x061\x14\x8C^\xA8\xF0\x16B\xBC^\xFD\xF8\x82cz\x93\xFF\v\xA9\xAB|\xB6\xE7\x1B]q\xFFm\xB9\xB4\xBA\xD7~\xE9\xCE\xA7m\xFD\xB2!-\x9D,,\xD6\x7F\xCFa\x7F\x1Cm\xD1\xC4ZX\xC2\x1F{+\xD8_\xE4L\xFD\xD8c\v\xC7_[\xBF\xC0\x1Dv\xAE\xBB\xE21J\x1B\xA8\xEE\x85\x12\xBB\x07\x93\xB6~\xBA\xD2\xAF>~\xF8\xDC\x03\xA6\xA1O>\x18?\x87\xFF\xE30\xF3\xD1Vt\xC2\xD3\xFDV\xF0\x7F\xED\x8B\xD8\x9F\xB4\xE9\xC7\x9B\xFAo\xAA\xF1]\xC1\xCA\xEFqWmo\xFB\x83\x87GU\xFCrTw?]9\xD4\x10\xBF,w\xFC\xE5\xB0F\xA1\x81\xE3\x92^\xFC\xFA\xC7\xDF\xB7a\xC4J\xD96A\xAC\x1C7I\xB0\x80\x01\xE0\xA9\xD32\xF8\x9B[\xE2\x025\xE02g6\xD5\r\x98\x03^\xCD\xE8~\x1FP\\\x99\xC3Z\xF4\xB0\x81\xDF\x91\x83\xEF\xD49\xBD\x19;YY<\xF0X\xD6}\xEAh\x17^?fjJ\xBF\x0E\x01&+\xC9*\xE8(.\b\x0E\x99S3\xA5\x9F>i$o\xAEMO\xEB\xFA2\x02O\xEF\x99\x82\xC8MK\v+\x8E\x02\xAC\xCD8\x97t|\x89'7\xC4\xCA\xF4k\xB9\xD0\xFA\xF5\x01J?6iV\x9B'\xDB\xF4\xDBf\v\b\x7F\xEB*\xA7\xFAn \x191\x06\rk\xB0\xFA&\v\xED\xB5\xF0\x03\xE1\xE2\xF2\xED\x8F\xCB6\xEAv\xB5\xA2U&5\x99\xB3\xDA\xAE\x06\x15\xAC,\xC6e\xD6\xCA\xF4\xBB\xE0QJ\x04x\xFE\xB4\n\xE9\xAC\xEA\xFD\xB3\x8Dm\xAD\t`}\xD7fG\xD2\x06\xFDx\xEE\f\xFB\xEB\\\xB2\x1Bz\xCB\v\x8F\x8C\xDBm3!\xEDO\xB3\x06\xCF\xDA\xE5\xF8\xD2\xFAmX\xA1~\xD1\v\xAD_\xC8\xE9\xBF8<.\xC0\xE6l\xFDx\xB3~\x11}\xA7\x13\xDB\xBA\x81L\xC8\x184\xCCHM\xBF:\x1B#+\b\xCAt\xDB\xFE\x94\xFF\xD3E\xE4\\\xFA-\xD5\x7FW\xAA\xDF\xE0\x85\xD7\x8F\xDB\xFA%\x17\xB7?\xBFc\x7Ff\x93~F[M\xBFH\xAD\xCE\x1F\x89\xAE\xD4\xFEZlw\xB4\f\xFB[j\xFCXi\xFF\x9D\xBC\xD0\xFA\xE9U\xFDF\x17\xF7\x7FR?\xE9\xFF,G?\xA6\xE9F\xC24\xDAj\xFE\xEF\xCF\xEBc\xC3\xD2\xFE\xEF\xCCt\xC1\x94\xF6\xC7\x8D\xC0ks\xCB\xF2\x7FK\xA6r+\x1B?.\xFC$\xAB\x0E>p\xDA~ g\xFCE\xB6q\xFC\xB5\x87Y67/\xEA\xFA\r\x14\x937\xD7\xDE\xDAD\x96\xF5\nnt\xD1w>c\x1D\xAA\xD4e\x8C\xBFK\xBE8i\xFE\xD8_:{5\\\xA7/|\x04x\xF65Nl\xD1\xF89\xF5G+\xFC%\xF1R=[\xD9\xDF2\xE2?\xEF\xC99\x8A\xD5\t\x82x3`E\xD2\xE0\xF5p\xC1\xDE\x8B\xFF\x86\xA2\xEB\xA4\x01A\x10\x04A\x10\x04A\xBC\r\x88\xE8i3\xD3\xBCY\xF97\x9A6\xEF\xC8\x7F\xB2\xAF/\xB0\xBDTYl\xB39\xB8iw\xE8\x0F\xD6\f\xB6E7\xB7\r\xB6\x85~\xD7\x18<\xD7\xB2\xA2\x81\xD0`[h`\xCD`\xDB\xE0\xE6\xE0\xA6\xB6\xE8\x801\xD8\xA6\xC9Mu\xCF:\xEF\xBA8\x9B\xB7b\x03\xD4\x9Er\xE1f\xEF\xBE\xD8\xF0\xC6\xECl\xD7\x91\x91\xE9\xC2\x81\xDB\v3\xF9\xC2\xF1s\x14\xB5w6v$\xB8w&v$!r]\xFE\xC8W\xBF\xDCud\xDB\xFD\xFB\xBA\x8ED\xA6s1\xFF\x0F\xFF\xEB\xC3\xE6y\xD7e\xB9\r\xF0k`\xEF\xC3]GF\xEE\x7FX>\xEA\x81\x03\xB7?\xF1h\xA1p\xE2\x89G\x0F\x14N\xFC\"\xF3`ljd\xEF\x97c\xC3\x91\xFB\v\xFB\xE3S\x8F\xEC/\x9Ck\xB1\xDC\xE4\x97\xBB\xFC\xDBf\x1F\xEE\x1A\xBE53\xD35\x1C)\xEC\x8B\xC7\x87g\xBF\\\xF0o\x9B\xFE\x9BBad\xFA\xC1s\xEA\xB7w6\xE6\x0F\xEE}(v$\x91y\xB0\xCB\x9F\x10\xB9\x98\x9F\x8B\\\xD7\x91\xEA\xDE[q\xADW\xE6\xC1\xD8\xF0Hv66<2-e\x9A)\x14\xA6ff\n\x85B<3\x13\x1B\x1E\x99\xDC'7\x85\xFD\xF1=3\x85s\xDA\xDF\xDD\xFB\xBA\xFC{\xBE6\x13\x9B\x1A\xC9\xCCtM9\xFA\xCDvME\xA6\xF7\xC5\v\x91\xFBg\xCE\xF9\xF8\x93\xB3]G\x82\xB3\xB3]\xC3\xCA\x80\x13_{\xB4kj\xDB\xFD\xFB\n\xFEWg\xF3\xB2\x01\x0E\xBE%\xF5\xB3\xED/6\xBCM\x9A\x99m\x7F3\x07\n'Ndfc\xC3\x9F\x9B\xDC\x17\x9BR\xC2\xCE\xCC\x1C(\x9Ck\x8D\xEE\xB4\xD4/7\xD3ub$Sp\xECo\xDB\xFD\xB3\xB1\xE1\xC8\xF4\xC3W\x9C\x18\xC9\xCC\x9E\xF3\xF1\xEF\x7F8\xEE\xDF\xF6\xF8\xC1\xAE\xA9[3\x0Fv\r'\n\xFB\xE3\xC3\xC3\xB3_\xEE\x9AJ\xCC\xCA\x06\x98\x9EyK\xEA7\x1B\x1B\xDE\xA6d\x9Atd\x8A\x17f\v\x85\xF8\xD4\xFD\x0FwMIo6\x15\xC9\xEC\xEF\x8A?\xF1H\xBEp\xF8\x1CE\xDD\xF3\xE5\xD8\x91m{g\xBA\xE2#\x99\xD9\xAE\xF8\xAD\x85}]G\x12\x93\xB3WLm\xBC\x7F\xA6k\xF8\x87\x99s\xFB\xBF\xD9\xD9\x82\x7FOn6><\x92\xD9\xD75\xA5\xF4S\r`\xEB\xB7\x8C\x06\xF85\xD9_\xF0\xFE\x87cS\xDB\xEE? \xED/_8\xF1\xC4\xAC\xF4\x7Fg\xBApc\x99\xEE\xFF\xBB\xF5\xAF\rn\xAA\x15p\xD3\xB9\xDD\xBF\xED\x86g\xBB\x94\x03\x90\xF6\xD75e7\xC0\xDE\x99\xAE\xE1\x91\xEC[\xB2\xFF.9\xDC\xFD\x1A\xE2\xBF\xB7\xE3\xF8\xBBd\xB8\xF5V\xAA\xCB[8\xFE#\b\x07k\xD1\xC96\x8D\xA1\xD8]\xDB\x18-.X\r{M\xD7Y\xF2\x98\xBA\xCE2Z\xE47Z\x98\xBCX\x1E{\x83\xAA\xDC\xFC\xD3\xC6\x1A\xF3O\xBE\xFC\xDA\xDC\xFC\x93\xA5e\x95\xA1\xFF\x06\xEB\xE7>\xE3\x07x\xE3\x0F\x94\\\xA7E\xA1P\x18\x9E\xFD/\r\xBF\xF4\x11f\xA3\xBA\xA5\xC6\x13!{Y\x93ZA\xBC,F\xDF\xC9\xF67\x9E5\xB96_8\xF8\xDAe\xCF\xE6\xEB+;Y1\tx\x9C\xA5N\xE3r u>\xB0b2\x0E\xB0\xBB\x01\xCFU\xA7{Z\x97sOy\xF1;\xD8\xFE\xB2&\xFF\x95\xB4\xBF={\x1A\xECO\xE9\xE7\x9DH\xD5\xF5\xBB\xC4\xA3\xF4s\x952\x7F`/\x07t\x7F\xF7\xF4\xA7\xD6,K\xBFE\xD7\x0E\xCE\xCF\x97\x1B\xD5\xF0>U>\xDD\x7F\xBA?\xF0\x8D\xF2\x82\xBD\xC07\xEC\x8FEC\xED\xCF/\x937\xD5\xFE~5_8xjx\xB6!\xDFr\x952\x80\xF7y\xFB\xFF\xD5\xD2'#\xC1\xB1\xB0\xD2\xCF\xFB\x8AvH\xA8\xFF/\x9B\xFF\x8A\xB9c\x97.'BY\xE2\x7F\xE2\xD6_n\xB6\xA6r\xB1_\xEB\xC77\xCA`e\xF4\xA3\x1F\xAE\xB2\xC6\xCAVw\x8B\xAB|Z\x9E\xB8\xB6\xDC\"\xF5\xD3\xFA1>\xDF\xD2\x8F\xF9y\xC8=\xC8=uLs\xE1\x1B\xE5\xC0<\x94xo\x98~K\xDB\xDF\x81\xCB\x9Em\xB0?[\xBFW\xB4\xBA~s\xA6\xD2*p\x8A\xFF\x01.\x88~X\xD8\x1B\x9D^\xDB\xDCC\xBB[\x9C\x13\r{v\xAF]\xD0\x93e\xAF\xB57-o\xBA\xFFS\xF6\xB7gO\x83\xFFS\xD2U\xED\xAF\xDD\x8DF\xFB\x8B\xFF\x06\xEB\xB7\xB8\xFDig\x8C\xBF\xB6~\x8E\xFFS\xFA\xD5\xFD_\xE8\x82\xF8\xBFw\x8C\xFD\xC9\xF8\xE5\x8C\xF8O-\x0F\xAE\x8E\xBF\xEA\x9F\xA0\xAA\x8F\xBF\xFA\x1B1\xFE\xBEM\xF4{\xFD\xD8\x81\xE1\x05\x89\xFF\b\xE27\x97\xD1\v\x9F\x90\xBE\xF94\xFC\xFB\x81\xAE\xF2\xEB\xFA\x8DI\xFB2\xAF3\x00\x98r\x93\x89\x03B\xFD\xEF\x1C\x87\xDE\x11\xFAyO.\x8Cs\xC6\xC4\xAA\xF2\xB2K\x8A\x00\xCBz\x05\xDA\xB3Z`4\xB6Z\xB0\xBB\xB7p\x14\xD1\xAE\x01\x1Fy\xFB\xEA\xE7\xAD\xFFc\xB5\xAD\xFF\xFC\x17\vNN\x88\x16}%\xFA\x85\x97s\xDD\x9DA\v\xA3\x83\x1DE>\xB2\x85\xA3\x845\x9A\xF3K\xF7\xB7'\xFD/\xD7*\x1F\x98\xBFk\xC1\xC9\xCF\x8A\x96\xD1\x95\xE8\xB7\xAC\x7F\x13h\xCE\xB0\xD8#\xE9\x8E\"\xE7q\x8E\x1C~\xCB\v\x1C~\xFB\xEA\xD7\xF1Lm\x92\xCB\xDB\xF3\xD5\x05';E\x8B\xB9\x02\xFF\xE7:\xBCL\xFD\\sR\xBF\x91B\x1A9\xFC{M\xBC\x9D\xFBo\xA0>\xC9\xC5\xDB\x86\x17\x9C\xBCJ\xB4\xA4\x96]\x92\x0EmY\xE3\xC0\x9D\xBA`\x8F|& \xD8\x8F\xFE\xEF{\\\x02\xAFh\xE2\xED\xDC\x7F\x03\xE9Z\xCE\xED\xBDf\xE3\xEB\xB1\xBFqh\xCB\x9A\xEE3\xDCr\xFC\xF5\x02\x99\xF1K\xBC\x02\xFF\xCE\xFD\xB6\xEE\xBF\xBF\xF5\xED\xD1\xFA\xF8\xBB\xF0\x97\xA2\x97\x88U\xC5\x95\xD8\xDF\xB2\xF4\xEB\xE1\xC0\xA8\xDA\xF4\xB5\xBB\x80\x80\xE7m\x1D\xBF\x9C{\x92\x7F\xF9\xFA\xB9\xCEg\xBA\xD4sa\xFF\xD5w\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \x88\xDF\x18\x02`e\x04.\x01\xC0\x8C\xDAAf\xAD\xA4\b\xD6\xB0g\xB5qU\x8E0\xE4\xA7\xAC:\xA4\xCB\v\xACNM\x9E\xE0\xAA\xE4\x01@\xD3\x01\x9D\xA1\b\xCD\x05\x18-\x00\xBA\x01Q\xB4`0\bh\x80\x05]^j\xCA\xC2\xD4\x7F\xB5\xDBX\xDD\x8Dw\x17\xEA\x90)\xEFk1]3\xE0\x937g@\xD6j\x93\x1B\x1F +d\xA92-\x80\xABz\xDA\xF7\xCD\xB6\xA8[\xB8y\xCA)\xCCX\xE4\xF1\xDA\x96|n\x037Y\xBA\xFC\xD3\xDA\xEA-\x83\xEB\xAFG?&\x10\x96b\x85\xD2O\r\x19\xBA19$\x8FgD'\x83\x95\x89\xEE\xFA\xF6Q+:\xC9t\x80\x99\x80\xE1\xEB4\xC4\xA0\x0E\xA6\x0F\xEE6\xAD\xA0\xB6k\xFB\xE1W\x01k\xF3\xD8'>j\x0E\x94\f\x1F\x04\xA2J\xBF\x16nV\xCC\x80\x80\xB8\xB3\xA3(\xCCn\xE1\xDC\xCE\x1C\xAA=(\xAB\xE9\x17J3\xDD\x8Af\xB4!h\x99\xF4P\xF1S\x02CVH\x98CVt\xA2(\xEBr\xF9+\xAF\x9A>\xD3\xD1O\x9B\x88\xB2\xE0\xA0\xC0PP\xB6\x86\xE9OgQ2`U\x8B\r<m\x9A\xB2\xDD\xA4\xE4@H4<kU`\x1D\xFAhU\xBFQ\xB4x\xE4\xC5Z\xED*.Vd\xC2\x15y\xEB\x14<\x9A\xF7\xE8`\xB0\xC3\x9B3\xDB\x8CI\xB3\xF2\x1FY*'\xA2O\xBE\\\xC9D \xAE\xAF\x9Cr?\x9FB\xBB\x97U\xC6\f}\xD7\xE1/\r\xFA&\x9E\xD7\x13m\x1B\xAE=\xFC+!\xCC \x98\xB9Y\xBF\xB6mC%z\xD2\xE7-#*{\x85\xEE\xE2\xA6q\x19\x03\xF6j\xCC[6\xFD5\x8B\x1B\x02\x86\x00x+\xB6~\xE3R\xBF g\xE6\x9D\x11]\xEB<=\xA7\xA7\xCD\xEE\x8B;\xEE*]\x174b\xB8\xB3\xEF\x12o\x0EC\xB3\x02\xBA\xA9\v\xEB\xF48\x87aE|Q\xA6\x0F>\xF0\xF2/_\x95\xADa\xEA\xFC\xBEJ\xBB\x81\x0F\x97\xB1FxK\x18\x07\xEF4\xCD\x8E\x12\x9B\xD3:\xBE\xFD\x8A\b6>\xEB\x90\xB3\r\x88\xB6\xBB\xB9\x8E\\N\x07\xB3F[<`\xA7\xCFW?\x8D\x01\x03\x01\xE0\x0Eh\x13\xAB^\xAC\xB0\x94\xB0\xA2\x0F\xFF\xB4\x02<\xB9\xEB\xA8\x880X_\xBA|\x029\xCB\xEC\vdq\xAC\xE7\x9Eks\x86\xCE\x19>\xF1\xC1\xC4\x9E\xB1\x07\x1E~\xCA\xB4\xD60$\xDB\x01\xB1QO\x9BE+j\xEC\x12\xC2\xD8\xC0\xFCCf\x00\xDC4\x7F\xCA\x99k\xB6\xCF;\x01\xAB\xEE&\xBAu\xAE\xCCC\xD78\xF7V\xA0c\xD7\xC9\xB9\xF9\xFE\xEF\x1C\x1D\xEC\v\xFC\xA4\xAC\xF1\xFE\x97+\x1C\x10\xE6\xC7\xD6dc\xC6`\x84C`hV\xF6S]*\xDEQ4\x06M\xFD\x99\xABp-L\xA3\xA5\x1B\xE2\xFA\xB9\xF9'K:\fm\x00V\xBB\x80\t\xA6\xF43L\xC6\xC7a\x19\xB7\xCEs^\xBD\xB1s_\f\xC1\x98\x98\xE1\xB6~\x9CYI\x9D{_i\xD0\xAF{E\x1E\xB4\xE3\x1B\xA5\xCC\x04X\t\xE3\x1D\x03\xD8\xB3\xBE\x7FWE$\xCC\x8C\t\x0E1\x00\xCB\xCB\xFE\xE9\xF8)\xA9\xD7\x06\x8D\xA1\x9B\xC1\x12\x83\xAB\xDC\x93\x9D\xF8\xC3\x96\xE8\x94\x9E6\xD3\xDD\x99H\x1A\xC2\xECiu\xA5\xC7\x1Ex\xF8\xAErt\xF4]\x96\xC8\xBEz\xEF\xD4\x90\xA9\x1B\xDC\x1C\xBD\xCA\xCB\xF0\xF4\xE6\xF0\xC0^\xAB\xB7\xB9\xC9\x10(fu\x8DkzE\x87\xB0\"m\x1Cb2\xD1\xA6\v\x8D\xEB\xE9\xCEtJ\b\xF3X{&j\xCC\x8Ep\x88\xD9\xE8\x9E\x1B_\x9B\xEBn\x81\x05\x06!\xF5\xD3\x9Ej\xFF\bLC\x1Fjqu\x9B:\x87\x91\xEA\xE4\x03\xB0\xCA\xBB\xA4~\x1D\xC7:#\xA6q\xE9+<\na\xF0\x89\x9A~\x96\xE6\xB4a\x16F:\xC15MI\xA76\xD2g\xD7\xF4\xDB\f \xB7|\xFB\xF3$3\xE2.\x8FQ\xE1\x9A\xAB\xB4g\xBD\x94\xC8\x92\xFA1\xEF\xB5\x0F\xC2\xF2\xF1\xA1L\xA4\xE3\xE5\xB2\xB0V\xA5\x9F?\xCC0\x80=-\x1E\xAD\xD3\x18\xCC\xC4\x94~\xB1\xBB#\xC1\xC1\xDD\xD1\xC16-\xA1\xA7M1p:\x1B\xBF\xBC\xFC\xB8\xF1\xC5\xC1\xA1\x1E}]\xFA\xC1Lg\xF8\xAET:\xF3\xF9D*\xF5t\xFD\x96\\y=+\xD7\xDD\x1ExF7\xF5@\xB1(\xF5\x9B\xD0\xD2\x8E~\xE6\xA7\xC2\x13\xB8v\xF0\x15}\xB034\xD5\xFFre6\xBA\xC7\x12\xE6\x95\xAB`!\xC8`N&\x8C\xBBXiT\xEA7\x19\xD4\x84\xA9sn\x86;\xD9\xAE\xCA\xC7\xDB\x18\xCC\xCA8\"R\xBFH\x1B\x8F\xBA\xBCem\xA2\xE3\x1Beu\xD7T\x7FZ\xDD\xD7\x85,\xDCZ\xB3\xFDa\xA2\xC1\xFE<+\xD2/0\xB5S\x13{\x85ah\x81\x1D\xC6\x9E\xE8=\xDBs\x96ifLa\xE9\xCF|R\x1B\xF0\xF1\xD4\xDE\xCB8Cf\xB0\xE5ZC\x93\xFAe\f]\x7F\xDE\xCC\xEF\xFD\xA9\xBF\xE7\x9EK';\xFD\x89\xB6\xC1\x9BBi3\x13\xE9\xB9\xE7\xD2\xEDO_\x97\x8Dw\xB2\xEF\xAFY\xBBi\xC8\xEC\r\x0F\x98\x9F\xBA\x15\x03\xBB\xD3_\xD85\x99\xCB\xF2\xC6\x11K\x0E\x04B\x1C\xFD\x94n\x19\xA6\xCE\xB6[\x91\xB6\xFE\x97+\xBA\xC6 4\x0Eaj\x8C\xC1\x1A\n\xC22u\xF9y\x96A\b\xF3R\xBDh\xC1\xEF\x11f:aL\xCA\",\xD3\xE0\x9D\xFA@tsp\xC0B'&\xF0\xA2\x8F\xC1\xD4\x19\xCC\xCE\xA8\x99\x8D\x18Z\x94\xC3\xD0\xB86h\x0F\xA7)\xFB\xBE\xD0\x04\xC0\xDD\x8E\xFF\x03g\xC5d\x8B\xA7I\xBF\x95\x8D\xC0k\x87wjCB\x18fKh\xB3\xCF\x18\xDC=\x992\r3\xD3\t\xA1kL\x1B\xF0\xB2\xA3\xC2\xD48\xB2C\xB0\f\xCD\xC3& L\xC3w\x95\xF9\xE8\xFE.\xFFG\xEE\x8D>\xD3\xA9':c\xC3A&R\x17\xCB\x8F\xB7\x0E~2\xDAi\f\xEA\xAB&\xCB\xA5\xEB`\x99\xD33\x18\b\xA6\xA73\xCC\xDC\xD3\xA0_\xC0UTFhhJ?~\xB7\x95\x90\x03}]?\x9Ds\x91\xB3\f\bK\xE9\xA7)\xFDL]F1\x1F\xB4\xAC\xF4\x801\xE8\xE8\xC7\x84\x88D23\xA6\xC0u\x13\x03\x88I\xED*\fVg\xB4\xD30\rm>\rS\xE7\x9Ae5\xB6\x9B!\xF5c\x1E\xD8\xE3/8\xD8\xD1\x16OS\xFF]\x99~\x17}\xB8-\xDA\xCD\x90JnT\xFA\x19\x1A\f\xBDM\x1B\xD0\xD2\x1AGFzo\xA9\x1F32\xF2\xB1zZ!d\xADc_\xFA+\xDFem\xC3#\xD3\xB3\x03\xC6\xA0\xD4O\xDER~\xBC)\xD3\x19\x1E0b\xBA\x0F\x03\xDD\x9B \xAC\xBD\x11l7&?u\xFFS,\xD8\xB2\xE0\xBE\x9C\xC1\xD0 R\xE6\xFC\xDD\xC2\xD6\xAF;\xCC\x19;='\xF7ZZ\xAE5,\xC3\xC5DwXc\xD0=.&m\x11\x13s\x17\xF3\xCE\t>aJ\xFD\x98(\xA6\x80TX\xFA?\xABt\xC7\xE7;a\xEA\x1D\xDF\xA9\xE8\xE3L$b\x97u\x94\xCC\xB0\xD6_*v\xB7\xE8V\xD3p\xAA\xBB\x9C\xD0\xA6\xA6\x9F\xD1\xDA*\xEB\xA3\x9F_\x04\xDE\"REx\x98\xB8\xFB\xA9\xBF\xFA|w*\x1Cp\x15\r\xFD\"\xB7\xA8\xDC\xE9\x9A(\x8E\xB6\xB7\xB8pg\x87k\xE2\xA9\xD6\xBB\xBC\xAC8*{AwG@\x14\xC5\x1Fe\x8A\x9F\xEC\xFE\xC8\x1A\x97(\xF5x\x98\x90\xF1+S\x1F\xBB/a\xA2d\xEA\x9C\x89\xC3=\x01&F;w\xB9S{]\x97\x9A\xAF\xB4,\x1C\xD5Z<04\x17\x9B8\r6\xF1\xD4\xDD\xDFb\xB0\x8A\xA9\x16\x0F4\xEEa\xA28\xDA\xFD\x11\xA3/p\xB7\x87\x15Ka\x0FF{\xDA=L\x98\xF2\xC9?\xC9=\x8CO\x98\xD7\x96O\xF7\xB7z\x99\x12&\x15\xF6\xC0l\xC7^\x94M)A\x85yX\xBA\xBB\xC70\x8B)\r.\x14\xBB}\xDB)\xCD\"\bbY\xB8\x84\x15\xD3\xB8e\x868\xB3\xC0\x99\xA5\xDE\x00$\xA5g1W\x94V\x1Bn\b#\xC4\x01\xEB\x1D'\x91\xB5\xA4t\xF6\xE9\x05\xFA\xCD\x8B\xA5\xF4\vTw\xA2\xB5,}H\x86\x01c\xEF\x0E\x94\xDE\x89\xFAu\xDC\xF5B\xD6\xBA\xFC\xD9W*s\x1D\xBB^\xF8\xDAO\xAFi\xFD\xE5\xE9\x1FwLF\xF2\xD3\x1A7\xCBw\xF6\x97Xe\xACcW\xC9\x8Ay]E3t\x89\xD7\xD1O\x97\xF67\xAF\xF4\x8B\xE8\xAF\x1A\x93\xFD7\xBC\xB0\xE5\xC5\xDF\xF9\x9F\xF7f_\xF4\xF9\xB6}|_\xE1\xC8\xB1\xC7{;\xD2\xA5\xEC\xE5;\x13\xA6\xF5\x99V\xCF@6\n\xB0\xE4GC\xBB\xEE\xFD\xD5;\xCC\xFE&\xCC\xAC\xD5\xA93d1a\xCEv\xF9\xB8\xC8o0l\xFD:uC\xDFU\xD2-\x1F`\xF5h|\xA0\xF4\xA7\x9CYV\xC4\x970\xB3z\xDF\xAE\x7F:\x1Eu\xF4K\x1BS\xBE\xC4\xC4\x96\xA8ojOv6\xE0\v&g\vS\x89\\4\x946\xB3Q_\xC2\xB4\xF6\xB4\xF9\x12\xC9\xB1\xFE\xED\x13\x1F\xBF9\xB4\xE3\xB3[Ni\xFC\x9D\xA7\xDF\xF3\xC8v\xEC\xBAt\xF6\xE5kZ\x7F\x99\xFF\xB1q\xD7\v\x8F\xFF\xCA\xD6o\x82U\xC6|.1Z\xEB\xBF\xD6\xA5;\x9F6\xB3\xBA\x9ENf\xA2\xFD\xC5\xAA~\xD7\xDC\xB0\xFDOO|p\xF8\xD5l\x01\x815G_|\xE2\x9Ek\xA5\xFDI\xFD\x9E6sR\xBF\xDB\xF0nm yshG\xDB\x9F\x8E\xBC\xD3\xF4\xCB[\x91\x9Dm\xC8\x1Az$\xBA3\x92I\xC7vJ\xFB\xFB\xCF~\xF7MzlmB\xE8\x96O\xB3\xEA\xFD\xD7:\xD5\x7Fc.\xAB\xAF\xDA~4\x13E\xA0\xA4\xF4\x8B\xED\xEE\xCC\xA7?6\x15\x19\xDE\x93/x|\xC1d\xA105\x93\v{\xDC\x9D\xC9-k7\xDDd\xECi\xF3\xCD\xDC\x16\x8EN^{z\xBEo\xC7g\xB7\x8C\xBC\xD3\xFA\xEF3c\xBD7</\xFD\xDF\xA5_{\xB9\xF7\x06\xE9\xFF\xEEz\xE1\xF1W\xAE\xCAd\xCA\xDF\x8A\\\x99\xD2\xC7:\xB6\xD7\xC7\xDFk+\x9CY\x97\x9E\xB6\xEDO\xF5\xDF\xFE\xEF\xFC\xF2\x99\xF9k\x1E}\xE1s\xBF\xB8\xE6\x9E_>3\xEF\v\xAC\xF9\xD1\x89\xAF\xFF\xCF\x87\x1E\x8F\xFA\xF4\x99\xBE]\x0F\x1D\xDEY\xFEL\xAB\xE7\xC1\xC7\xA3\xD1I\xCBpC\xDA\xDF;q\xFC=\xD7\xF0\xBC`\xFCm\xD0o\x01\x9E\xEAN\xD8\xD3t<\xFCn\x97P\xFAm\xF9M\xD4\x8F \x887\x88\x88\x9E63g\xDF\x90Hga\xC0\x18l\xD3\xEC\xCD\xBA\xDA\xC6h\xDA$\x96\xFC\xF2\xBB\x06\xB3\xCE\xDE\xDA\x95z\xF5\xBE\xC0\xF6R\xE5\xEC\x1ByY\xF9<\n}S\xF5\xBB\x7F\xB6\xEB\xC8\xB6\xFB\xF7\xC5\xA66\xDE\x9F\xEB:\xB2\xEDP\xEE\x8A\xC2\xD4\x13\x8F\x1E(\x14\xF6\xCC\x1E(\f?\xF1\xE8\xC1\x13\xC3__\xF2\xCB\xEF\xB9\xE2\xB8\xB3\xB7>u\xFE\xED\xA66\xC13\xDB\r\x00[\xD9K\xDC\xCD\xC1\xC1\xB6\xC1\xCDo\xAA~\x93\xB3]\xFE\xE0\xF4\xC3\xB1\xA9\xE1\xCC\xC3\xB1\xE1\xC4\xF4\xC1|ajf\xA6P(\xEC)\xEC\x8F\x9F\x98\xCA\x17\n'v.\xF9\xE5\xFE\xE3\xD5\xCE\xDDe\xAE\xF0\xBE\x87\xF2W\x9C8u(\x9F\x9F\xDAvhF\xEE\x1D<\xD0\xDCn\x07\n\xC3\x00\xF8WWTh\xE6\xE0\x81\x13\xA7\x0E\x897[\xBFm\xD3\xFB\xBA\x86\x8733]G\xB6M\xEF\x8B=q\xCFC\x8F\x9Ex\xE2\x17\xF7\x16~\xFA\xC1\x1B\xFE\xFB\xA3'\x9E\xB8\xE1\xBF,\xF9\xE5\xAE\xAE\xAA\xFDm(\xAD\xF0\xBE\xE9|\xDC\xEF\x9F9\x98\x9F\x9A\xCA\x1C\xCC\xC7\xD3\xD3\xFBbv\xBB\x9Dp\xDA-\x1F?!\xF5+\xAE\xA8\xD0{\n\xF9\xA9D\xF6M\xD7/\xA1\xF4\x9B\xDE'\xED/\xBF?>5\x93/8L\xE5\x0F\x9E(L,\xF9\xE5\r?\x8B9{\xD7\x98\xE7\xA1\xDF\xA9\x99\xFC\xFE\xE1\xA9\xCC\xBE+N\x9C\x9A\xCE\xE7\xEDv{\xF4@\xAD\xDD\xE4e\x8F\xAC\xCC\xFE\n\xF9#O\xBC\xC9\xF6\xF7\xB0\xF4\x7F\x0Fw\ro\x94\xFAm;\xF4p<\xAE\x1E\xE2Da6\x1F\xF7\x7F\xE5\xD1|\xFC,\xFE\xEF\x9A\xF7\x1C?\xDF\xFE\x9B>x\xE0D\xFA\xD0\xC1B|\xDB\x7F\xCD\xE7\xE3\xE9C\xF9\xFD\xF1S\v\xDAM\xDA\xDF\xF4\n\xFBo\xFE@\xF0{\xE2\xD74\xFE.\xB5Y\xDA\xFF]\xB1?v\xBE\xFA\x89\\\xCC\x7FJn\xB8\xBD\xF7p<\xEEw\xDA\xADP(\xA8v[\xF9\xF8qh&6\xF5\xB9/\x89\xB7X\xFC7\xBC\xF4\xF8\xFB\xE9\xAA\xFD\xC5r\x17\xBE\xDDV\x1E\xBF\f\x04\x07wk\x03o\x9F\xE0\xF1]\x9B\xAA\xB3\xB0\xE1\xE2\x1B\x13\xFF\xE1\xAD\x1E\xFF\x11\xC4\xDB\x8F\xC5\xB25\xF3\x02\xDF\xC3\x1E:8\x84\xA1\xA7\xD5n\xCE,\xF7\xBA\x048\xB2\xEB\xFD\x0F\xE6\x7F\x05\xCB\xC8\xA4\xAB\xE3\x8B\vE\xBD\xC5\xCB\x8A\xC7\xDB\x81\xA2\xCE\x85\x05\xD3\xB4\xCF\xB5iV&\xB2;n\xE6\xE3\xFEt\xBEP\xB8\xAB\xAB\xE8\x12\xEA\x01.j\xAF\xDE\xA1\xF9\x8E\x18]aE]\x8D\xB1\xAFQj\x94\xE3\xFF\xD70\x96i\x03\x06\xE0V\xC90o\x1A-<=\xEAOra\xB9\xDD\x81!g\xCD\xF0\xFA\xDC\x997:g\xADN\x8C\xAFz!\xDB\xAC\x9F09l\xFDf\xF2[\x90\x8BM\xEF\b9\x0F\xCE`\x1D\xD6\\(\xDE\xD6bhw\xE8O?\xF6\b\xDE\xF3\xC2\x1D\x8B\xE9\x97)\x98\xDC\x02\x06\x05\xD6F\xA5^\xEBMn\bGDG?\x11Y\xE1\b\xDEh9}Ui*\v\x9B\"p\xE9\xE1\x9A~74~\xDD\xA7\x82\x18v\xC6\b\xDC\x82!`m\xA9\xAE\x1F_\x91\x89\x1E\x8A\xEB7\x94\xE0a\"\x1C\xDE\xDE\xA8\x9F\x9Fg\xD7\xB7\xCE\xC4l\xFD\fG?\x0E\x11\xD3\xBD\xAC\x18k7\xB4Y\xFD\xA1\xFC\x14\x8F\xCF\xE4\xAB\xFA%CS\xD7XJ\xBF\x03\x85\xCC\x13J\xBF\xA1\x89\xE2\xDA\xA8^\\\\\xBF\xF8\n\xF5k\xBC<\x98k\x14\xF5\xBE\x86Sn_\x02\xD0\\r\xA0]0\x07\x969S\xD3\x9A\xFD\xA9ef\x9A#\xDC\x07WP)\x9E\x7F\xF9\xD0\xF5y\xBC\xF4\xA1\xC1\x03\xA1}\xF2\xC0g\n\x8F\xBC\xD0s\xFD\x9E\xF1m\x1F\xFF?\x07\x7F\xF1\xDA\xA1\xADS\x07\xBB\xA6\xBF\xF8;\xFF\xF8J\xDF\xFFy\xF7\xB3\xBF|\xEEON\x0F\xCF\xFF\xE8OzO\xFC\xD3\xFF\xF3\xAF/M\xFD\xDD\xA3_\xD8\xFF\xE9\x13\x7F\xF9\xC2U\xCF\xFC\xF5\xB7\x8El\x9C\xFC\xA7\xEF\x17\xAE\xB9\xE1@|\xF8P\xE1@!\xFF\xC4\x95\xBF\xBC\xFB\xDF\xB6?\xCB\xF1g\x9DW\x9A@\x97\xC5\x1F\xFF\x1A\xC03@ \x86\xEF\x00\xEC\xFB\x9B\xE2+\f&\xBE\xD4\xB0\x7FY\x93\xFD\x19\x8D\xFD\xD7\xC7\x01oz\x91\xEFw/\xEE\xFFVK\x0F\xB4\xB1!\xBAa?\\\x89~\x85'v\xDE\xF08\xBEx\xC5`aZ\xE9\x97~\xE4\xF6tn8X\x98\x9A\xD9\xFD\x9E\xF7\x16\n[\xA6\x8E|e\xEF\x97\x83\x85\xFD\xBF]\x98\x91\x19KaJn\xFC\x85\x1F\xFC\xD7\xE8\xF0?|\xE5\xE7\x7F\x97\xEB\x0EL\xC7\xB5\x99|!>\xF9\xBD\xAF\x16\xAE\xD9\xFC\xB9/}\xF4\xC0\x89\xD7\x0E\xE5\x9F\x88\x14\xB6L?\xB8)\x1D\xFE\xE2{\xE2)\xE0*\xC1\xB3\x05\x80'\x01\xFF\x0FP\x10\xE0\xE1\xF5}+\vf]M\x9F\xAA>j\x9D\x94\xCEl\xD0\xCF5\xFA#@\x1B\x912\xF1O5~\xA3\xD5>\xED_X\xEEU\x1B\x16\xAE\xD1\xE3+\xA9\xD6\x13\xC7v\xDE^\xC4}W|\xB3\xEFk\xDF\x96\xD5\xB8\xE7\xAB'\xD2\xB9\x91\xD0\xF0/\xDB\xF7\xFC\xF6\r\x85\xC2\xCD\xC1#_\xD9\xFB\xAD`a\xFF\xCD\x85\x99G\xA4t?\x97\x9B\x96\xC2\xF7\xFF\xCB5\xFF\xF8\xD7\x8F\x1E\xD8\x97;\xFA\xFE=];\x82\xB3\x85\xF8\x8EH\xFE\x99\xD8\xCEm\xF7\x7F\xF4\x8A\x7F\xDCv\xFF7\xBB\xAE+l\x99\xECL\xCCD\xBF\x18=\x92\x93\xF6\xE72\n\xB6k\xB1\xF5c\xD9\xB5\xED\xB9\xF3\x1FM\xA3\xD5\x1D\xB5\x02\xE5\x1F\x9A\xDC\xA4%\xF5\vJ\xAD&\x1B\x8F\xFB\xED\x91#~\x86\xFD\xADO\x02\x9D\xB2\xF0N\xFB\x0E\xAC}%\xAD\xFA\xF3C_\xBC\xFEq\xEC-t]7\x93\x97u\x99\xFA\x9B\xDB\xD3\xB9=\xD1\x13\xE9\xDC\xF4{\xA6\xBE\xF2\xC8\xEF\xAF\x9D:\xF6\xD8l\xB0P\xB8\xD9\xB1?\xBF\xBD9\xF6\xF8\xCCp\xA1P\xD8\xF7\x90\xF9\x0F\xBBc\x9B\xFD3\xB3]\xBEH~6\xB6sd\xFA\x8BW\f\x8FL\xEF\xEB\x1AV\xFA\xFD\xB0\xA6\xDF\x02\xFBCrmhe\xFA\xB1\xA1\xC5\xF4\xD3D\xDD\xA3:=\xFA\x0E@KJ\x1B\xE2\xFF\xA9\xF1x\xE0\xA8z\xDE3\xFA/\x8B'\x81\x0FI\xE9>\xE4\xE8\xB7\xA2\x97\\\x8F\x14\xBExC\x1E\xC7\v\xEFu\xF4\xFB\xE3\xC2\xCF\xD3\xB9c\xD7\xC4_\xFD\xF8}\x7Fs\xE2\xBF=\xFA\xD1\xAF\x9F\xF8\x7F\x7F\xFE\xD7\xC1\xC2\x81/\x16f\xF6\x17\n\xB7K\xFD\xE4\xE6\xE7\xFF\xBD\xF3\xC8\x13_\xFE\xF4C\x9FY\xA3\xFD\xF8\x8A{\xB6=\xF2LW\xAB\xD4\xEF\x9E\x91\xE9\x97\xA4~\x7Fs\xE0\x8F\x0E\xDC=\xD9\xFE\xCC\x13\xD1?k\x9F\x1AU\xE3\xC7\xDD\x05\xDB\xFF\xF9\xF38\"\xE0\xCA\x1E\v\x15\xCF_?w\xA9Q\xBF\xB6\x85\xF6\x87\xAC\fHx\xA8\xA9W&\x97\x88\t\xAF8\xBA\xC0\xFEVT\xAD'N\xEC\x1B<\x0E\xD1\xD0\x86: \xCC#S\x91\xA6\xA8\x81\xA3\xF0\x9F\xF3\xF9\xBA\xF9\x9B\xD5\xEB\xBB[\xD4w\x9D\x02\xF4\x86aR\xFB\xF7B\xDF\xFFC\xBB:\xEB\xCD\xA5F\xD2\xE5{\xEA\xC6(%\\\xDD\xF1\xCA\xB2:\x9A\xBA\xB9Ta\xAF\f\xF6\\M\xFE\xAF\xE5\x16\xD4\x17\xAB5r\xE4\x16 \x92\x82\xB3Y\xA9~3\xBF\xB3\xEF\xA5\xC7\x179>\xDA~!\xA2\xF3\xF09#\x11\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\x82 \b\xE2\xAD\x8E\xA5\xB6\x1A \x00\xF0\xFAqq\xE6\xA5\xDC\xAC\xEE\xC8\r\xAB^b\xC8R\"\xF5\xCB4\xE7\xAF\t}\x91\xFBi\x1A\xCC\xDAm\xEDr\xD0Q\xAE\x9F\xDF\x13o\xAEY\xBDB\xF6\xDD\xFB\xD4Vo\xB8\xB7\xAA\x90\x80\xAE6\xF2\xBE\xF5\xBD\x05\xCF\xC1\x9DBM\xE3\x8Cj\tScM\xD7\x86\xCE\xAC\xBAY\xDBT\xE9/\xA9\x02]sZGq\xFB\x1C\xFA\x8F\x01\xF3\x0F\b\xA0\xBF\xFF\xC5\xDDQO\x7FI^\xE3-\xAB\xEB\xE4\x93\xCAkY\xD1\xD1\xCF]\xD3\xAF\xA3\b3\xE2<\xCC\xA5\x95&\xFDF\xDB\x9D\x0F?y\xE5\xF4xG\xB1\xA6\x1F\xAF\x8B\xE3\xFAg\xFB\x1B\x1E\xE1:\x0E\x04Nn\xAE\nm\xA1\x0F\x81\xA3\x00\x0FT\xD0\x17\x10R?o\x19F\xC7w*\x18\x97\xFA\xCD?YBv^\x04^\x9B;\xA7~NM#:\xB70.\x98\x99\x95\xCF1\x8A\xC0\xD3r\x0F\xC0\x86L\xDA\x9C\xECT\x8D\xE2uU>\xAF\xDA\xF1\x12\xA3V\xC7\xC0\xB1\n~G(\xF3\xE1\xB9\xBD\xF2\xC8\xE7\x9B\x1B\xC4\xD2\xEC\xF6\xDD^\x86\xAE\t\xA0\x93i\xBB\xA3=\xBCf\x07\xBC\xD9\b\x95\x9C\xEB\xBD\x8E\xD5\x18\xF2F\xF3B\xE9\xC7\xCD!x\x8BU\xFD\x02/O\x94\xEC\xFD\x0E\bSW\xF7\xD2\xBC\x95G\x9A\xF4c#\b\xC8\xABz\x04\xF2\x80\xB6\xE7\xE2j\xA5\xEF\xC0 \xFCYys\x03\xBC-\xF0\xDA\xDC\xB8\x14\xC2\x90\x06\xAB\xABG\xD5\xC0\xE7B`\x96\xA5K\x89\xE7\x9F,\tY\r\xD7\xDC\xFC\x93/W\xEC= Pi\xD4o\xD51\v\x16\x94~\xDC\xCC\xC0\x97p\xF433\xE9\xBC\xA3\x9F\x9E\x1Ez\\\x1E\xCAv\x86ju\xF4E\x04F\x84K\x16\xC5+\xB3\xF2H\xA5\xA6\xDFuJ\xA2y!\xF5c\x1C\xB8Q\xEA\xD7\xCF\x03'\xA3\xA6mu\xC8T\xEDO\xD5E\xCB\x02\x11\xD9\x12\xEB\xA3\xF6\xBD1\x17\xB2\\s\x8E\xFDI\xFD4\xFB\xBE\xEC4\x82Z\xD61w\xF9\xF8\xF3B\xD6\xAF\x7F\x12_\x05\xFCu\xFD\xF8\bzL\xD5%\xF9\x10\xE0}\xA5j\xBE\x9A\xC0<\xBCJ?\x13Z\xFF3\xD9\xBC\x12b^\xB0\x12tY\xA1>\xAF\xE0\xD9qxG\xC7\xD4\xC7\x88\xB6\xAB\x82\x88\xAA\xAF\x9E61`\xD7\xDC}\xB4A\xBF\x84\xE1\xAE \x01n\xCE\x01Z\x9B\x86\xB6D\xA7\xDD\x93\x07\xD6\xBD\xF8\xDF\xC6\xC6\xA7s\xF2!\x067K\xD3ec\xD6\x9EZ\x1D\xD7F\x05\xBE'\xDC1\xD9\xEB:\x13\xF2\xAC^\xD3\xEF\x0E\xF9\xF7N\r(w\x83\xBB\xCA\x18R\xF6\xD7:y\xEF\\\xBF\x92\t\xADG\x1D\xC1\xEC\xFE\xABg\xAA\xFA].\xED\xCF\x05\x04\x83\x16\xCC\x8D\xB6~\xCC\xBA\x01\xBAU\xF5\x83k\x9E~\xE8\xB4c\x7F\xC7\x1E\x8C\xC6'\xD4\xD1/\x94_l\xD6\xEF\x9Fm\xFB\xEB\x13\xB2VZ6\\\xB7\xBF\xCD`\xB2MP\x84\xCE\x139[?\xB3\xFF\x98i\xDB_D\x17\xFC\xD5\x9B\xA1\xAD\x99\xD1\rW\t\x03>f*\xEF\x98\x19\xD7\xB7\x970\x0Ee\x7F\x9A\xD1\xA0\xDFs\xE5\x96!$\xE0\xB9*\b\xAC:1\x85\xABn\xBD\xD4n\xDF\xA7\xBB\xEF\xFE\x99\xF6\xD4\xD5R?\xF3=\xD7Kq\\\xFA\x93\xF5\xFE\xFB\xBE++\x18\x11\xAB\xA5~\xAB/U>\xC7\xD6o>\r\x97\xEAl\x93\xD1\x80\x101\xB4\n\x03C\xB2-;7\x0E\xEE\x8EF\xD6\xAB\xC2y\x0E\x88\xE7\x94\x19\x0F9u\xB1\xF53U\xAD\x8A\x18\xE9/\xC1\x8CW\xF5K\xC0pj\xAB#\x02\xE14T[\xEB\x81\xB9\x9F)/\xA0e\xB6\xCF6\xE9W\x1D*t\xC1\x8E\x03\xAE\xE7\xC7\xAA\x9D\xC6\xC0\xBC\xED\xFF\xA4\xD5=\xF9\xF2/O\xAB\x1E0\xAEq\xD3\xF6\x7F}\xAD\xC2u\xCF\xCD\xD0\x82\x85\xF9,71\xF3\xF9\x01\xBB\x95O\x0F\xC8G\x18\x00x\xD0\xF6\xDEv\xC3+\xFB\xD3\xA4~\xFE\xAE\xA0\xDD\xAF\xDA\xD6\xDF\x14uN\xEC\xD8\x1F\xBD)$\x9F2\xB0c\xF3\x98mau\xFD\xDA\xA2\x19\x8C\xD8\xF6\xA7uF\x95u6\xFB\xBF\xC9\x10 \xA2\xD8xc\x05\xF3\x19\xD5\x7F\xA3\xAFD#1\xA5\x9A\xEC\xB0\xB6~\xEE\xA4\xA3\x9F\xEA\xCE\x1Fz\xB9b{\xB9\x8D\x86\xC5NG\xAA\xEE:-\xFD\x93z\x0E\x03\x91\xC0I\xA3j\x7F\x7F\x1B\x8Dk\xF2\x02\xEDA<\xD2\xA4\x1F\xAB\xC0%\x94\xFDAV\xF0\xE9\x96\xAA\xFD\x99\xD8\t\x7F\xD2\x19\\\xD3\xD6\xDE\xCB\xD4\xCD\x99vW\tm\xAA\xC3\xCA\x86\x1A\x87w\xDB#0\xB8\x89PxG\xB7\xED\x86\xC7\xCD\r\x15i\x7F\xAC\xE4\xC4\f\r\xFAed\xFF]\x1F\x91\xC2f\x10\xAC\xEA\xB75;\xF9`h\xB3\xD2\x8Fk;U\xFF\xD5\xC6\xA7k\xC3qp\xDF\x90\xD4O>\xAF\xFBd\xB4\xB9\xFF\xAA\xEE\xAC\xE9j\xFC\xE0\xA6\x01!\xF5\xEB\xE4\x1A\x8BF\xBAS\xCA\x0E2\xC0\x86\\\xAD\xFFJ\xFD\x94!\xAD\x8Fe\x9C\xD2\xB3\x16LYqS^\x92\x06\xB7\xEF\xCBL\xB8J\x13\x8E\xFF[{\xD9Cs\xFF;\xA3\xDC\xDC\x8C\x9E\x03\xFCCu\xE3K\xDB\xE3o$\xE7:%\xFDAw\xD5\xFE\x86\x1A\xEC\xCF\xD7\xF1\x1Di\x7FR?}\xD2B\x9B\xB2\xBF\xDF\x02;\x1D\x02\xBB\xF6+J?\x9D\xF9b\xB2$\xD7\x9C\xDE\xF1\xEC\x90\x1A\x7F{\x01W\xA9!\xF0R\xFA\xED\x00\xEFT\xDE:\x83`\xF4\xA6A\xE7\xC4\xE4\x84>\xE0\xE8\xF7\xAC\xAD\x9F\xFEx]\xBF?L\xE2\xF7\x85\xDD\xFC\x9D\x8B\xE9\xA7\xBF\xDF\xD6\x0F&\x98\xACZ'\xA4~f-\xD61\xCD3\xF5s\x07\x9CA(\x9E\xB3`&\x9C\x81\xBASC\x8B\xDD\xDA\xBC\b\x8E\xB43\x16\xAF\x8F?\x9E\x8F\x1BJ\xBFY=\r\x04\xEA\xFA\xB19\xDB\xFFEr\x18\x96f1^\xB5\xBF\f2\xA2f\x7F\x1CB\xB6\x91\x80\xA7\xCD\xB2\xD0\xA6|\x04Sa\x1A\xB3,\x18Z\f\xEF\xF7\xA4\xED\x88\xD3\xDC\xCC\xB9\x85\xCD\x80\xEB\x98#\x9Df\xD4\xC6\x0F\x1D\x19\xC1\xD5\x18\xD0\xA9#\x14\xDB9\\\xD5og\xC8\xD1\xCF\xEDS\xFAq}{\xAD\x8F\x84\xA2\xDD\xF8\xCB\xAA~\x83\r\xFA\xB5:\xF1h\xF7SO\xBE\\1\xC1]E\xA8\xA8o\xFC\xC9\x9F\x9C<=\x9FKUG]\xB3\xB6W\xD7\xEF]U\xAF\xFC\x8D\x07\x8B\xAE\xB9\x04\xC0\x04\xD0rq\x18\xDD\xB6\xEC\xBC\x0F\x9C\xA5\xFB\x1C\xFDR\xDB/{\xF6\x01)f\xF7O\xCAsp\x86\xAD&\xFAJ\xEC\x7F6\x05\xDA\x15\x04\xC4\xEA[\x80V\x97@\xD8\xC3D\xCA\xBE\xC5%\xD2\xC9d\xED\xF8\xCF5g\xC7\x7F\x81\x17{\xF0\xD4\xE3\x89\x14\xE4\xE0\x93\xDA\xFB\xF9\x96;\xB0W\xA8gSu\xD6\x9D\xC7M\xACy\xA9\x1B\xDD\x82w^\v\xB0\xA7t\x84\x0E\xEF\xDC\xA6N\\\xB7\xEE\xC5\x93\xB7^\xBBN6c\xC77\xAF\xB2\xF5[\xD5R3\x9F\xD03\x87\x91@\xA3~c\x94x\x11o)\x84\xEA\x8Ev\xEE\x833\x93\xD9\x85\xE8\xBC\x96\b\xF3zN\\;\x1B\xA9\xA6\xB6\x86\xE6\xE4R*\xBB3c:_\xBC\xBC\xA0\x1D\xF1pK%I%\x9D\x83w\xEB\xF0\xC9\xDC\xCA\xAE\x99\xCAXTQ\xA2\xA1jQ\xE5\x04\x9B\xCB4\x16\xCF\xDE\xD1\x98\xBCcU\xB9!\x82z\xB2\xF9\nC\xD5\xDE\xDFX\x88e`UQ\xC6\x07\x13\rY4\xE0\xAD?q\xBAr\x1A\x81c\xE6T$S\xFF\x1A+\"\xBA\xAA\xB4h-2\xEA\x1E\x11\xF0QD\xE0\xAA 6\xE5\\7&s\x1C\xFB,|\xBC\x92\x89\xEA\x02\x199Bd\xE1\xE5\xB9|\xCC\xEF\xAA4\x96\x13p\xBE6\xDD/dD\xE6O+\xFD\x92\xF9\b\xF8P\x06\xBE\x12\x0EE\xA5\x1A\x97\v\xF7\xE6W\xA1\xCB\x14\xCF~u\xC0J\x90\x03\xE1\xAC\x928\xD2\xD1X\xC9,V\x1D\x13\x87\xEC\xFDU\xC7\x1A\xEE6\x07\xB8*\x87\xFA\x84\xFD\xBC\x96\xEDc/\xFBB\x11b\x83\x00f7\bV\xF9\x1AV\x95\x90\x8D\xAC*\xE1P\\\xAF\v\xC1\xAD,\xFC\x16\x8BA\xDF\xD1#\x1F\xDAr\x1A\xB4~I\xE0XW\f>W\xA5I?n\xA2__\xBC\x15\xB3J\xA1\xB8\xE0\x19\xF4\v\xAE\xE3\xCA\xA9\x9C}\xE2\b\xC03s[\x8Bv\xA1Y\xD1\xBF\xAB$3*\x13s\xB2\x8D\xE66|\xE1XS9a\xC7I\vY\xDE!\xE8J]-S\xE8\x17\xDA\xE4\x1C\x82\x16f\x86D\xA0\x82\x98\xD0\xBE;,\x9F\xED\x90\xA387 \x15\x9FU\x1F\xFB\xF74\xDA\xDB\x1C\xFC\x91J\xBA\xDA\x112\rm\x0E\xF0\xA1\x99\x11u\xED\x9Ac\x19u#|0c\xB1\xB51\x01<\xDD\x05W\xEC\x19\xF8M\xCCl=\f\xCC\xC8\x8A\xD7\x84\xB8c\x0Ek\x8A\xEC\x17\b\xBCt\x18\xFDv&,7\xC1\x9A\x11\x1B\xEE\x93}h\xD3:\xC7\xB6\xDEW\xFF\x9Af`\x93\xB1\xA8|ll\xAB\xAC\xC6\xF5pCF\x96\xC71|\x9F\xAD\x1F\x1B\x06\xB4\x9D\x89g\xEDB\xB5\xDDcCmr\xB4Z\x97c\t\x18\x83\x0F\xC6\xB7\x84\xD67\xD9\xDF\x06\xE7kc\x83**\xE8xQ\xEA\xE9v\x7Ff3\xDC\x7F\xA1#d\xB1\xC8V\x8B\xE7\xB0\t-\x89\xDBa\b\x16C\x9B\xFA\x82\xB7\x02K\xC8\x92\xE5\xC7\x91F\xFD\x98\x89\xE0z6g\x7FX\xF3b\xA6\xA1\xCE\x80\xB6;\xF2=;\xA5P\xD5\xF0W0|_\x89\xC5o\x14`\xE1-\xC2}r\fA\x93\x8D\x1D\xB9\xAF\xC4\xFA\x86\xA7su!v\x0Ec\xA3\xB4?cg\f\x9B\xA0\xC9\xA4Z\xA6#\x91\xDA\x10\xFD\xBE\x7F\xBC\"\x82\xABZ.\xD5\x9F\xEE\xAE\xD7e\xD5q<\xFB\x81E\xFB\xAF+\xF1\xB4\xCA\x1B\xB1\xBA\x82\xE7D\x8B\x8E\xC3_\xB1\xEF\xE6\x1A\x06Z^\xC3G\x95\xFDm\xFC\xC8k\xFA\xE1\xABd\xB6xu\xCEeb\xC3#\x97\x8E\xFD\xAF\xBF\x7F\xA4)u\x8B\xDB5p\xE9\xCF\t\xB8\xC6\xB0\xF1#\xF2\xB1Z\xFE}\xEC\xA8h\xB9~\f\xEF+\xBB\xFA\x9E\x96\x19\xE4\xD3p\x9F*\xE0\x03%\x97\x8E\xF7\x95lW\x89\xE7\x00W\x14\x1Bs\xC0?lh\xA8\xA4\xAB\x0F\xEF\xFB\x97\xD7\x9C\x07\xEB\xBE\xB2\xDEZ\xAAj\x0F\xF5\x8D\xAB\xE7\xFB\xC0\xE9\xA4\x9D\x1B\xCC}5\xE7Z{X\xC0\x15}\x1A\xAB\xAF\x18\xC6\xFBJ.s\xF81\xB8\xF0\xDC\xDF\xD7\v]\xFD{\x9F\xC0\x9A\"\xFF\x05>\xF0\xD3\x18\x9E\x13\xABe\xF4\xBA\xBA\x02;q\xB2\xFD\xF7`\xD7\x16\xAC{\xE9\xA4\x9E\xD8\xDD\xE4{o\xDA\xBD\xB8\xFD%\x12*\xEF\x11\x9Ac\x7FC{r\xF5F\xDE9\xB6\xC9\xB2\v\xDD\xAD\xDFxo\x89\xB5#\x94c\x97\x81\xBBO\xC6\x06\x83\xFB\x16\xB7\xBF\xA4L-\x10T\xF9\x80\xD6\xF9\x99\x14\xB4\xBF\x18\x86\x91c\xB8Q\xB8\x8F\xE2\xC3B\x9B)\xC00\xD9\x18.2\x1D\xFB\x93\x16\x1BE0\x07$\xE2\xB9\x86\xAA\x19\b\x0E\xEEw\xE2\xCEu/Z\xCD\xF6\xB7Y\x1Fq\xFA\xDB^\xBBKK\xFB\xC3\x90\x00K\xDC\b\xF7\xC9ai\xE3}\x1F\xFD=i\x7F\xA1z\xA1\xEEOnC\xD0\xE21\x18\xBB\x8EcX\xDE\xDC\xB6?\x7F}\xFC\x1B<9\x84`t\xA7~m\xB0Xw\xEE\x15\f\x06\xAD\xB3\xF4\xDF\x04\xDC\x15;\xB3\xFE\xDDPc\xFF\xD5\xAB\xFA\xED\x1C\x1B\xB9\xC8dq\xA9_\x0F\xFA_\xEC\x9C\x1B\f\xCEf\x9B\xEC\xCF\xF9\x9A\xBEU\x80\xF5\xA1\xE3E\xE5\xFF>[\xD8\fm\xF3\x98\xD4/\x9E\x80\x9E\xC1-B{\xE8v\xAC+1\x1D\xEFVf\xE1\x1E\xC2\x87\x85\xCC].\xB2\x80\xF1B\xA3~sX\xBB\xFE\xA4\x93\xDF\x04\x1B\xBC\x85\xAC\x9A\xFB\xE4\r\x1F\xB3\xFD\xDF\xAFF\xED\xF1\xE3c\xD39\xD6!\xFB\xEF\xA1\x01h\x9Dc\xF2\x1EC\t\x03L\x1Fopd\xEE\xBF\xFA\x18\xD6\x95\xF8qt\xFC\xD4\xC0V\xE1\x96\xA5\xCBt\xB8Q\xBF\xCEi\x04\xA3\xBBC\x89\x06\xD9\xB9\x89\xF1=\x8B\xEB\x97H\n\xDB\xFE\x86dy1|\xB6Q\xBF\x93U\xFD&\x9F\xD5G.6\xD9\x90\xF4\x7F&\xB8\xD6\x19\xFF\xF0\xBDK\xE8W\xB5?\xE5\xD6;c\x9B\xA4\xA9\xA0\xCD\x94\xFA\xB1\xA2\xF49\x85\xB8\xB4\xBFv\x04\xAB\xF6w\xA7\n\x90.\xB6\x16\xDA_\x14\xE1\xD9\xFDN\x82\x10\xDCT\x1F\xFF\xD8\x1F\xCB\x92\x87>k\x9FX\x9B\xB5\xC7\x8F?\xBE\xAF\xC4\xB4\xEB\x00\x16\xD9*\xDC'ch\x13ll\xD3\x9A\x12\x1B\x1B\xCE\x8A\x06\xFB\xFB}i\x7F\xEFE\xF0@\x12\xB7*\xE9\xD4{\x95\xBA~\xA1\xC1\xCE\x7F\x8B`\xF4\x93\x91MF\xFDkZ\x12\x83\rr\x9E\xA9_\x02\xEA\x85\x90\xFB8\x12\xD9\x06\xFD\x98>`w\x92I\xA6'\x82&\xEB\x93O\x1EAp\xF0\xA6\x1B\x06\x8Dhi1\xFD\x9C\xFE\x1B\xB2\xF5;9|\x1D\xB4\xBF\n!\xD8\xCD\x86\xB7\x16y\x0E\xD7\xC1\xFD\xC1\x84\xF4\xEDq\xAC\xA9\xDA\xDF\xA0\xA8\xF6\xDFMM\xFA\xF5`\x8D\xB6\xDF\x99\xBEh\xDB\xD1\xA0_\x18\xD0\xF6\xDF\xE1\x8C\xBF\xBF\x92)\xA9?\x83\xA1\xE9\x1C\xEB\x1F\x16`\x91\x04\xB4\xCEa\x04s,t\xCB\xF7L\x16\xFA\xBDF\xFB{\xD7\x1E\x84L>\x84\xF6\xDF\x8DI{\xB1\xEC\x16t\xDE++\xFD>U\x04:^\xFA\xAB\xA7oi\x90\xDD\x9B\xC5\xE0:\xF3\xAC\xFDW\xBBEn\xC2\xF8\xC8\xBD\xA5\x9A\x93q\x9Ft\xDE\x81\xAE{\xE9\xE4\xD8\xD6{e\xA73R\xAC\x0F\x97\xAD\xDF94h|;\xBC\xC8\xF8a\xF7\xDF1\x84\x06U\x7Fc\xF7\xFC\x1B\x01v\xAB\xDC\x9B\x02Z\xF6\xE2\x16\xC0\xF5y\xB4\xA5\xD8\x90c\x7F\xEE[T\xFFM@\xD6\xEF\x96\x83\rm\xC2\xBE\x05\xE3\x99\x93\xB7\xDA\x1F.\xFA\xC3\x86\xFE\xFBG\x80\xBB\xEB\xF3\x1F\xB7\x9FO\xF9?_\x05\x9B\xE50\xFB{\xD2y\\\x07\xF7\xC9{\xA4\xA7\xB9\x15kJ\xEC\xD6\x91FCz\xFE\"\xD9\x1D\x87\xB0\xAEKe\xC2w4\xBC\x94 \x88_\x1B|\xB0)Y\x14gLvv\x14\xB9\xA9\xDE\xD1\xC68\x84\x95Q\xAF\t\xB5\xC5\xB2\xE7\xA5\x8ET'\xF1\xD4\x80\x92kJU\xAB\x974\xA48\xAC!e\xAA}W4\x9F\xB5\xEA\x97,\xEA\x9B\xA1\xD9\xDF`\xA6\xA1&L\x16\xCE\xE12\vgL1s\xB1prWe\xD6\xD1\xEA\x8D\xCC3n\xE1\xE43\x19@\xDF^\x01\xBC\x02c2\x9D\xFB\x12Z\x7Fr\x1C\x1Dj\xB2s\xD51\x13\x1B-^\x99\x95\xB9s~CfGl\xBE#\x93\xB6\xBE\x16\r4d6\x15\xC0W\xC4|\xED\x80\x1A\xF8\xFE\xAC\xA3\x9A\x19\xCE\xD9\x99\xB0?a\xD9S)\r\xF3\xEC\xB5\xE41\xE6\xC4\xB7\x15\xF4\xEDd\x15l\xB0\xBFaU\xAB\xAF\xD7T\xF2)\xA7Z}\xE8>\x7Fbq\xFDBv\n\xEA6\xB3\x1D\x19\x81\\CM\xD5\xEBTU\xFB\x80|\xE8\x0E\v_\xB3?\xFAg\xCC\xEA{j'?W\x99\xB5\x93\xBC\xF8\x13U\xFDT\xA2\xDDQ\xC2\xAF\xD4\xF4\x11\xE0\xFE\x11\x10\x901\xA6n\xE1\x88,j\x06\x17\xCF\xE6\xD1\xADR<\xFD\xD2\n>`i2\xA1\xB40\x17\t\xBC\xB8{\xA0{\xD7\v{\xD3\x977\xA6\xC8\x19\xC0o\xB2\x9Bk\x07Tz\xF4\xBD\xAB\xAA\x12\x8B~u\xED\xAA\x7F\xABj\xFF8\xFA\xC5\x19\xAF\x0E\xAA\xC7\xDC1\x8C\xEC|!\x86\xA8\xA8\xAAk\x9F\xA8\xB7\x96\xDA[[\xFD8\x10x\xA1\xB2\xA8~N\xE6\xEA\xAD\xCC\xFDv\xA0\x84\xB9\xC6\xD5\x13\xAA\xB9e\x03\x18\x89\xA4J_\x9F\xB1\x1B\xC5.\xCA\x9E\xE1\xCD;Yt\xFD\xBB\xF5\x1B\xA9h$(\xD8'\xA4}\xDF\xAC\x02 \x04\xAF\x97MQbc\bZl\v\xDE\xFB\x92\x1C\xA25S\x06\xEF&F,\xED\xB3Q\x99;G>\xBC\xE7\xE1\x93\xED[\xB3;|c\x83\xEBJ\x8Do\x89\xB1\xAE\xE4\xFA\xB3Z\x17S%\xFF\xFE\xD66g\\\x1D\xDB\xEC\x84\x972\xE4\xF4\x1E\xC6\xE6\x063\xA9Z\xC6\xB0\xAD\xDF\xEA\n\xFEy\xB7\xBB\x82\xEB\xD5\xC7uE`\x8B\xDA\v\xD6\xACL\xC5\xF2\xEF\xAE\xDA_a\xCF\xA6\xA1E\xF5\xB3'\x82\xE0\xF6\x8D\xDCl\b6X\x8DA\xD4\xA0\x99\x97\xD5\x95y\xCF\xBE\xEAC\xAB\x8F\xC1A\xB3:A\xE6.;Qd\xD0b\xC3\xCE\xEC\xCD`5f\xB5_Q\x97\\\x1F\x93\x97\xF4\x01-\x19`\xE3\xF0\x10\x10\xB3\\2Ev\xDD\x82\xF8\xC1\xE3\xF8\x9E\xCA\xEE6\xB6$\xF1\\\xB1\xE5\xF7\xA2\xF2D\xFC\x99\xAF\xDC}/\xBE\xF7\xBE\x7F\xF9\xEF\xD8\xFA\x95\xBA\x11\xC9\x02\xBAE\xDD\xFE\\2=r\x8D~\xD7I\x9B]\xCE\x9B\x84\x8D\x1F\x91Uk\xC9\xE3\xD9\xFAc\xD62\xEB\x1F\xD6\xED\xEF\xEF\xFF%\x86\xA3\xF67,\xE09u\xE2}\xB5\xD6\x92\xC7pU\xF5\xE3\xE6\x0F\xFC\"\xB6\xA8~N\xE6\x1A\xF8\xD9\xD8\xFF\xFA@\xC9ug5\x87=,7e@M\xF3\xCA\xBA \x9ES\x0F-K\xFE]\x95w\xCB\xCDj\x15\x97\xB8\xC6d\xB6\xEDD\xE1\x1F\xF8y\xB6qT\x88\xE7\xD8\xE7\xE4%!\xBB\xFF\xAE=p\x1B\x10(\xB2O\xC8\xDC\xE5\x8F\xF0\xDE\x9F\xC6\xF01!\xA3\xEBu/f\x94\xFD\xCD\xC9\x13\x9F\xFB\xE8\xFD?9\xD9\xA7\xEC\xEFh\xE3\x9B\te\x7F\xEC?4&\x99`7T\xD3\x16'N\xC4\x9A\x9F\xA8\x94\xF18\xC6\xEB\xD2\x87\xAB\xA5\xFC\x91\xA3_\x05#\xD3\xEB+\xF8\x84\xA8\xB6\xF4B\xFBS\xDE\xE7\xA2\x9A\xFDMk\x8B\xEB\xB7\xCD\xB1\xBF\xAE`rI\xFB\xFB\xD0K\x15\x99|\xB31\xAC\x95\x17w\xA8\xF74\xEE\x8C\x93\x97\x01lK\xA3\xFD}\xB8\xDA\x7F\xD5\x8B\x8A\r%v\x83\xBCd\xDC\xEE\xBF\xC6\x17n\x93c \x1B\x81!\xD3\x87\xD8\x15\xC7\xF1'j\xB23tW\x05\x1F\xB5\xB4\xCE\bB&\xDB\xB2%\xEBn\xD3G\xD6\xBDt2\xBE\xF5\x81R\xD3@\x14\xCA\xD5\xED\x8FI\xFBc\xDB\x86\x9C\xE0\x9D\x15n\xB2{^4c\xF7\x8FT]\xBF\x9A\x17\xD8\\[0\xF4\x89\xFB\xA4\xCBP\x97\x84L\x99\x1E6\xAC\xB1\x92\xD9\x84l\xFEZX\xBBy\xDDK\xC9E\xF5s^\xC1y\xBF;\xB7\xF5\x81R\xF5M\x16jI\xAB*`\xFD\xFA\x982\xA4\xB8\x9Ar\x821)\x8B\xF2\xA8F\xD6\xED\x8A\xDB\xBD[q\xF1\xBEjCE\xA5\xD8Q\x8B\xC9\xF1\x83\xC5m\xFD\xD6\x9D\xF8\x01\xD0\xE1\xD8\xDF\x18b]1g\xB2i\xDDK1\xDCli\xFB\xFB\xE4\x89\xE9\x8F\xDE\xF7\xE3W\xE2\x7F\xB2'\xFA\xE0X\xB2!'v\xDB\xF6W\xF7\x7F\x1FQI\xDC\x883\xF9\xCC\xC6\xFE\xD8~\x0F\xF7R\xC5\xD6ok]\xBFPu7Q{qgI\xFB\xDBZ\xB3\xB5\xDFm\xD6\xB9\xEA}\x9CO\xF3\xF77\xA7\xD25F.\xB6\xED\xEF&>\xB2Gf|\xF5\x9A\xDA\xCF\xAB\xEC\xEF\xC7%e\x7F\x1F\xB7?\xAES\xFDC\xCD\xB09\xF67&\x87\x89H5\x8F\xAA\xDA\xDF\xE5%[?\xE5\xE5\xFF\xC0\x16\xDB\x98R\xFE\x8F%\xA4\x99\x85\x10\xEB\xD2\x9D\xC9\xF6\xB5\x9B\x8E\xE3\xA3\x96\xFB\xD3\xCA\xFE.N\x1A\x93;\xFF\xCD\xD0\xBD/u\xC5\xC7\xEFmJ\x91\xD1f\xB1P\xB3\xFD}\xEA\xE3\x8E\x89\xB2\xF8\x80\xDD\x07/\xCB\xD8\xFD7Q\x7F\xCC\x8B\xAA;1\xA7\xFF\xEA\xD8r\xDF7\x87\x1C\xFB3\xCCZ\xFF\xAD\x05_j/X\v\x1Be\xFB.\xAA\x9F\x93\"\x7F:2ro\x91\x8D4\xD4\x14\xDA\xA8c\x7Fk\x07\xD5:\x1E\x16\xB7\xFBo\x9Bz\xCF {7<\xB6\xFD%d\xB7\x8AT\xE7\x7F\xCDF\xFB\xBBT\xB0-\xCE\xF8\xA1j:u\x8B\xF2\x7F\xEA\xDD\xCD\xAD\x88\xFD\xC9\x0F\x9C\xF1\xF7\xA2\xA8\xB2m\xA6\xEC\xEF\xD6\xAD\x0F\xBCX\xC1\x8D{.\xBB&\x9EhO\xD5\xED/\x03\xE7\x8D\\\xA3\xFF\xFB\xD8\xB5N/c\xF1\x1B\x9C\xF7\xC0\xAA}\x87\xEC\xE5^6\xEF\xAA\x1A\xD2\r\xF6\xB5\xFAq\xDC\xBAw\xFDm\xF8}\xF5qm\n\xF8wj\xAF\xADv\xB7P\xB1q\xD8\xD6C_^|\xFC\xDDj\xBF\x8B\xF4<{\xD1\xD6\xFBM\xF6HCM\xD5F\x19\\$*\xFD_\x8A}\f!Y\xFCE\xEA=\x97\xFB6;\xB3\xB6\x9F#\\\xAA*T\xB7?\xE5\xFF\xAEL\xB1?\xA5\xD4\x8B\xF8\xB5\xE3c*#u'\x17\xC9 \r9\xB4&\xD1<\x00\xE2\x8C\x89V\xBB\x97ZF\xD3\x04\xAB\xA5\xA6\x87\xCD3\x93cQ\xCDu\x9D\x15=\xA9\x86\x1CY\x13\xCE\t\xE5K;\xEB\x93\xCF\xBCyz\x99\xD7\xD2*\x9C\xAD^\xB2\x02\xFA\x99\xAB\xA8kK\xBD\x85\xBD\xB0fA2\xAEs\xAC\xFA\xD1\xE2s\xDF\xFA\x99\x99{\xC4\x97\x90\x19\xA9\xF7\xB4\xCAak!p\x05\xFD\x99\xEDeD\xC1m\xFD\xA6U2P?[\x7F;(\xF9\x85\x1CW\xA77\b ;?\tv\xBA\x9F\xB3\x81-C\xB2\xFA\xEF\r\xEC\x92\xA3)\xAB.\xFA\x06\xCF\xD6\x16|\x9B\xC0%\x80\xD9\xDE\xFF\x93\xD2\x1D\x97p^r\xF4\v<mVB\xF6\xCC\xB2\xF4\xD6\"P\xB1\xD7?\x83{\xCB\xF8\xF3\xFE\x92kn>\xED\xADd\xD0Qt\xCD\xD5\xDF^\xCE\v\xB5~\xF7e{c7f\xFA\xF2\xE3\x11\xFD\x81\x87\x8F'\x9C\x15\xD8\x97W\xDD\xE6\xE4\xE5\xA5,`\n>\x976\xEB\xFA\xE9\xEAa\xB8\x9E\xF6\xFDx\x1A}\x01uBc\xA7\xD1\xF1\x9D2\xB0\xAA\x04\xCC\xC7K\xF6\x02\x00\xF4}\xA8$s\xCB\x9F\x94\xD1\xFF\x85\x17*\xE8\x17\xAB\xB7\xC8\x1C\xB6\xF1\xCDG4\xF0\xD2-\xD5yN\x99\n\xAEmX\xEE]35\xED\x8Ej[x+sq\xA9_T\xAD\xDD\xEA\xFF\xE9\xE6\xE8x\xD0r\xCD\r\x18B\xE0&xF\xAB\xA3.\xCF\xE1\x7F\x8B\xEA\xE2Rp\xB8\xE6\"\x9C\x1Bz\x82k\x86\xA3\x9F\x1E\xA8d\xC6mI\x00\xFCD\xAD\xFC\xE9?\x9E\x01:\xBE\x99\xC4\xCD\x1C|D<\xF9\xA2\xEF4\f\x8Bs\xC4\xAAu\x16B\xD7!r\xB1!\x88\x99\xAE!\xB3C\x05E\xBB\xB5\xCE\xBE\x81Ptg\xA4!vT\xA3\xCB\xF4~;\xE6\xDA\xD3\x18\xC7:Q\xCB\xDC\xF8\xC1K?\x8E\x88\xFDj\xC3\xFB\x17\x83\b\x0Ee\xED\x11{w\x9FZ\x9D\x1A\x8F!\xA2V.k\xB0\x90\xB8h2\x8F\xCDp\xFF\xAA!+W/\xA6\xB7\xEE\xFE\xDD\x12\x06\x85\x1A\xF2e*\xD8`\x7F\xEEr\xB3\xFD\xC9\xD0\xCF\xF3\xDD\xF8V\xA5\x9Fa\x01\x9D\xDA\x8E\x9B\xB6\f\xF9\x05\xCCCO~\xBB\x8C\xAD\xD0\x8C\xEA\xEB\x99@\x053\xA2f\x7F\x1C<2\xD0\xFFRE\x1F\xE8?\xAE;\xEF\xC2\xA5\xFD\xA9X|\xAD\xFD\x0EI\xEA\x17\x89\xC9$}S\x127w\x14\xF9\xC8\xA1\x99\xCB+\x19\xAC\xBB\xF1\x14\xAF\xCE\xDD\x01\xAF\xC0[\xC6\xA1\x83\x07G1\xFE\x9E\x87\xCBv\xDF\xEF`OU\xFC>\xAD\xB3\xBA\x9AxU\xF5b\xED\xAE\x97l)\xE7\xB8\x96k\x9C5\x96|\xEC\xA2\xBD\xD7'\xAB\xFA\xB97;\xFA\xC9L\xF3\xEB\xEAE\x8E\xD95T\xD5o(\x83\xE7\xFE\xEE_*xNx\xB6\xA0\xB6jQf\x81Cx\xE6\xEF\xFF\xB0\x07\xCF\x89\xD5\x15'\x15l\bPV\xD7\xECOW\xF6\xE7\xDA\x02\xACz\xED\xCE\xEFA\xEA';X\xA7>00\x99\xE1`\xA7#\xC1\xC1,n\x82w\xB4\x9Aa\xE8:\x0E5\xDA\x1F\x8F\xCC\xCF\xC4\x90\xD9\xADV\xD9\xDA\xF6\xB7\xBD\xD4`\x7F\xF3\xD2\xAE\xEC\x85\x9A\xCA\xFE\x82\x16\xFF\x12\xFA_\\5\x07=\xA3\x97\xEB\x1E\xC9+x\x06\t]X\x88\xE8i\x13*\xE2\xE3| \xE6\xF7y\x9F\xAF\x8C\xD5l\xDFy;3\xF9PE\xAD\xAB\xDC\xD3\x7FW\xA9q\x15\xAC\xBD\x10p\xD7\x8F\xA7\x11iq\xF4\xFB\x15:\x8E8\xF6\xB7\xCF\xB6\xBFX\x06\x11\xB5\xF2\xFB\xFD\x8FV\x90\b\xEE\x00\x86\x84\xFBpc\x90\x0F\xF7\x0F\xB05\xB8\xCF\xC4\xCDv<)C\xC9\rM\xD6Y\x9D]\xCFW\x03>\xDFM[l\xFBs\x03\xC9\xFE\x8E\x87n\xD2\xE6\x9F,1\xCD\xD1O3\xAA\xFA\xAD:^\xB5?\xDF\x90\xD2oD\xFF\x9D\x83\xB1\xC9\xAC\xE0\xD5\xF1CO7\xDA\xDFfe\x7F\xB1\x83\x15 xc\x05\xF3\x0F\x14]|<ry\xC5D\xFFa=\x8B@\xD5}\x9D\x84v\x14\xF3\xD2\xDB\x8E\xAF\xDEU\x81Z\x01\xEC\xE1\x03\xB1\xB1\x8Et\xCD\xC3\xD5\xF4\xD3v<o\xAA\x0E0\xE7o\xB0?\xB7m\"c\x1DS\x0F\xFD\b\x11\xBF\xFA\x9Ao\xF3\x16\x04\x87\xCBPSV_\x8FT\xED\xEF\x85\x87\xA5\xDF\xBC4\xBE\x17\xE3\xF7\xFDa\x057\xAA\xE9\xCC\x86i6\xCD\x82\xB5\xF6\x9B\x15\xDC.j\xA9L\xC3\xFC\x96;\xD6l\x7F2?\n\x9C\x1C\xDB\"\xC0\x8CA\xA9_\xC8\xED\xDE|:\xE4\x06;\xDD\xD7\xA1\xFA\xAF\xB7\x8C\xF1\xDA\xA8\xD1\xE0\xFF\xDCp\xDD3\x1E\xDF\x7F\x93\x16\xC9|\xB8\xFA\x1B\x9D\xFE\x97+P\xFA\x8D\xDB\x1B\xA9_\xF7m\xBA\xD3\x7F\x83\x16?5\xD0\x7F\xAC\xED4\x82\x16\xB2\xF5\x81\xFDf\xF8R\xD8\xAC\xEF\x18\xC2f}2\xABo\x94\xC7\xAE_\xF3\xCD\x93\xFA\xA6\xE0\xC4I\xC7\xFE\xD6V\x1Fa\xEB\x17e\xAC\xBC\xA6\x84\xF4\x07\x1Af\xD8|\xF6\xA3\"\xD1a\xAF\xECW\xAFMwn\xC1E\xC3N\x8E\xB8\xAF\xE6\xFFDN\xEA\x17/\xE41\xF2\xC5\xCB\xF2H\xC0\xFD\xFD&\xFB\xF3V0\xBE'\x9A\xAF\xCE\x13/\xB0?Ov1\xFB3>!\xC0\x82\x83;L$C;\xBA\xACdH)\xB9\xA33\x89\x10\xD8\x90mM\xCEbd\xBB\x94\x14\xE0\x03\xE7\xFA\x07\xFE\xFF7i\x11}\xB0\x1E\xFF\xB8\xE6T\xD7u\x06a\xA9\x9F\x1C\xF3\xD0\xFFR\x127\xF7\x97\xF8\xD4\xB8q\xED+Qt\x14\xB1\xA7>\xFE\xFE\x9E\x8C\x14\xC6\xFB_\xEA\xC6x\xC7\xCF\x8E\x1B\xFFC\xA851\x83\x9D\xFA\xE6\xE0\x83\xBE\xA0\x13\xD4T\xF5\xDB\xBCV\xFA?C\xF0'|m\v\xE3\x176\xB6u\xCFK1D2\xEAb\xCE\xB6`\xDDp\x06\xCA\xD0\xBF\x1E\xCA9\xE3\xAF\xC8I\x87\xB2\xF1\x8F\x7F\x80\xBF\\;\x9BELh[d\x0E[\xB7\xB0!l\xB9\xF7\xC5<\x86\x85\xA6\xBC\"\xBB\xB3\xD1\xFE\xB4Z6\xE5\xB7\xF5\x9B\x05\xFC\xDF\x1D\xFB\x0F\x00\x0FN\xEE4\xB1'\xBA32\xB4'Z\xDDCT\xF0!\xE7\x952\xEA{\xF2\xBB\x86\xE0\x1E=rE\x9Co2L\x13\xF6\xCFF\xF4\xB4i\xAF}\xFBm\xD4\xFC\x9F\xD2\xCF\xD8\x94\xC4nC\xDA\xDF\xBA\xC4\x9A9\xD9\xDD\xF6\xD4\xED/+Z\x86\x10\xCA\xEC\x1C\xC2f3\x923U\xAD\xD3\xB9\xA1Hhwt\x9F\xDF\xD1\xAF\xB3\xEA\xC3\xEF\x89v\x992\x91\xE5\x85\xEB\"\xB9\xC6\xA5\x16\xB2\x82\xB1\xA9\xCB2\xD3\xD5\xC9l7\x1FQoC\xD5\fBv\xBAY\xBFH\x97\x8E-\xD3\x9F:\xECd\x9F\x175\xF4\xD0[\xF0\x07\xFFi}\x05\xE3\xC2\xAD\x86]\x96n\xB4?{\xDD\x88\xB2?\xF5;'\xF6~\xC0\xFF\x17\x85\xEB\x04\xF8%w\xFDm\xC9u\xC9\xB7\xFF\xF6\xE7\x7Fy\xC9\xB7\x9D\xBD;\xF0m\xD1\"7\xF6\xC8T\xDB\x93\xDF5S\xC0\xFC\xCC\xA7\xE3\xFC/L\xB3\b{\xD9t\xF7g\xDE\xEDyJ^\xF2}\xB9\x19\x80\x1E\x06\xCC\xDBz\x00\xE3\x99n\xFC\x9DQ\xE4\x9Ek\x8Do\xBC\xA2\xE1\x9A\x92\xEB\x92\xFA\xEA\xC5\x07\x04\x13\xF8\xC9c\x9F\xAE`|\xED\xAD\xB9b\xAB<\xF6\xF9\xCB\x8FGn\xDD\x1E\xFD\xE9)\xE75\xC5e\xD5v\xFF\xDB\x87\x7FZ\x01\xBAr\xFC\x89\xBFz$\xB7\xC0\xFE\xF8\xF0W\x0E\x94\x80\xED9{\x8D\xD2\xA9\x04\xE2\xB2\xF1\xBAK\xC0\xD7\x9E4\x1D\xFF\xA2\x02M\xB5G\x10o)\xB4\xC6\xD7\xFC\v0\xCF\x9C\xE6\xB5\x7F\xCA\xA0\xAB\x8C\xB79\x0EU\xC9\xA5\xA9\vf6O\x03\x03z\xD0Y\xB5a6e\xC2\xF2\xAB\xCCZ\xAA^\x82/\x9E\x87\xDA\x85\xE8rk\xBE\xCB>\x92F&Q\xFB\xD1j\x1B\xAFN\xE5%\xEC\x1B\t\x99;\xD7~\xD2\xEA\xCC\xA0\xCA\x13\xBBr\xE0\f\xAE\f\x906\x93\x1C\xDC\xCC\x8C@\xEBl^|k\xDA\x8B\xAFG\xEC5\xE2\x1A\x84\xFDkO\xF0W\xC6\f\x11\xC8l\x0449\xD2\xC9g\x13p\xBD\xBA\xE0-\xBBy\xC8\xC4!x6\xC8\xE4\x9DeP\x11\xB2\xAE\xF0\xAF:\xD6\x15\x8A\xE8\x89\xFA\xC2\xA2\x8A\xB0\x7F\xB8\xA2O\x99;\xED\xE98\xA0\"\xB8\xAA\x8A\xEB\x18:\x82\xBAt\xC8\xECiY\x1E\xD0\x17Q\xA2\xB9^=\xFD\x7F=\xEFK\xE4\xEF\xA9\xA9\xD9g\xF2\x19\xFB\x1B\x00\x8E\xBD\xFA\x01\xE9\xAA\xDA\xD5\x0Fp.\xBF\x03\x7F.\xCE\xD4\xEF\x93\xEA@o\xFA\x8EL\xA2\xD7\xF9=\x18\x86\xFD\xA2I\xBF>\xA9\x9F.X\x05\xEDu\xFDd\xE8\xD7\x97y\xF0\xF4\xF0\x87\xC03\xF8`\xE1\xC0\xDC\x0F\xA5~\xA7\xE0\x7F\xB0I\xBF\xC0C\xC7\xD5\x8C\xEA\xA9\x9A~2\xAEN\xB4\x81\xB7\x05C\x82_\x7F\x04\xF0\xE6\xEDH\xF0\x94\x00\xA6\x16\xE4\x8D\x85\x99\x9C\xEB\bz\nr\xD4m\x8D!\"\xE0:\x01\x04\n\xF1\xB8~\xF0\xC0\xA9\xDA]\xFC\xBF/\xC0\xE3\x80\xFF\xC0\x89SO\x96\x9C\x15^S\"p\\\x19[\x1Cm[\xD5=x|.-%\xD1\x0F\xDAn\xD8\x1F\x9C9\xF8\xB3S\x85\xDD\xB9\xFA\xEC\xA6\x9A\xBD\xB1_\xBFO=0\x93\xB3\x7F\xA2\x04\xF4\xE7\xF3\x98j\xD4\xCF\x95\xB9T\x80E\xAFU\x83]t\xD7\x17\x0E\x7FN\xCD\f\xC8 -\xAAf<\xA5\x92\xAF\"\x90\x03B\xC2u\\~4\xEC8\xA0\xD7\x9E_\xCE\x01\xFA='\xB5S\xDE\x92\xEB\x9F\xB1\xE1D>y;\x02\xAF\x1D\x1F\x81\xBB\xF3x\xD3Z\x8D;2\xEAk#\x81\x17*s*\xE97\x04X\xE2&hm#\xD3\x82\x0F\r\xDBa\x85\xD4/.\x80\x13\xF6\xB7>T\xD5\xEF+39LAW\xFA\xF1\x18\x86\x85Z\xAB\xE6\xBF\xE2\xC4xh&6U\v\xDFN\x14laW\xC5\xA6\x1C\x89!\xDB\xC3Ne\\\xB7\xA3o$\xA6~\xEBvb\xF8\x90Rc\xBF\x1Dc\x9E\x98;\xB4\xBFk\xF8\xD4\xA1\x9A~}9\xF5]{s\xEA_\xDF\x9FS\xC7\x00\x04\x0F\xE6U\xFB\xDA\xC1\xA2\n\xDAN\t\xF0[\xFF\xA32\xE4\xFE\x17\xF3\x87v\xA9\xB8XF\x87\xF3OVg\xDCo\x14Z\x05\xB8\xA2\x84/\xC1Wb\xA7\xED\xD8\xD1\x8EG\xDDw\x00\xFD\xC7\xF7\x9F\xBEq\xCA\xE2\xC3\xB8f\xD3M\xA7\x9F\x13\xEE\xD8\x97\xE6E\xE0\xD4\x97\x9A\xEC\xEF\x80\xFD\xCAg>\x1B\xF5I\xB7\xE5\x8BK\xFB{\xFA\xB3\xD0|{\xB6\x9C\xA1_u\xDE\xC5]\xD5/rH\xEA\xD7\xA7\xF4\v\x1C\x97\x8F \xCD,pb*\x189\xB8\xBF\xF6\x8F\x16\xA0\xE0\xD8\x1F\xBF\xE2\xC4\xA9\xAF\x9B\xECc\x8E\xFD\xD9\xFA\xF1\x02\xF8\xCD1\xB5\x10fj\xA3\xB2?\xFFA[\xBF\xF8\xC8\xCE\x87O\xC4\xF9\x9E\\}a /T\xED\x8FO\xED\xF0\xE5\xEC\xF53\xC0{r\xB7\xC1S\xB5?\x19+\xB2\xE0\xB0\x00\xC2\x9B\x95~\xD1\x87\xBA\xA7N\xA8\xB8$\x96\x032\x93\xC21\xDBW\x85\xAE\x9E\xCDu\x02}9\x16\xB5#\xDA^Uh \x0F\xC4\x0F\xEE\xD7>\xF7\xDF\x84\xEB\b6\x1C\xDF\xA9\xDD.\xFC?;Q\x10\xFE\x03'\x1A\xF5\xF3\x17\n\xEAk\x85l\xD4\xBF\r\xF0\xDB\xFA%\xFE?\xF6\xDE>:\x8E\xEA\xCA\x17\xFD\xD5\xA9n\xAB\xBA%\xD4mY\xC6\x86!\xA8\xD4n\xE1V\x1B,\xC7\xF9\xC0\x18[*\t1\xC82\x0F\v!\bC\x12\xAC!\xB9\x19\x86\xE4\xDD\xCB\xE4\xDE7q\bO:\x96\x05\x94\x05\xC1B\xC8\xC4\x93d\xE1NG\x86v\x9BX\xBE\xE4\xCBq@\x12\x0E\x13\x1C3/\xE1r3\xB9L\xEE\f\xD3\b\x19\x84`\xB0p\x98\xA4%+\xAD\xB7\xCE>\xA7\xAA\xAB\xF5\xE1$\xF3\xDEZ\xC9\x1F\xAE?\xB4Z]\xD5\xF5\xB1\xEBw\xF6\xD9\xBF\xBD\xF7\xD9\xFB\xEFP|\xB6,\xCAC/N\xCB\xDC\x85\xBA\x04\x90\xE3\xA0\xBB\x17\xC4\xC6\x91\xDFt\xAF\xB8\xB8!\xECI\x81?\x05.\xB6fb\xD6N\x1Fl\xCE\xE3\x8F)\xC1\xA6\xE3\xE9\x03\xA6\x8A\xA0N\xAB\xF1\xABO\xA0\xE2V\x19\xB8\x9E\xF8\xE9\xB0\xB8\xFB\x8B\x0FR\x8CE\x9F\xCE\r\xBD\xB6\xE6\x97\xD3\x8F\xCF\xC3\x9F\xD0\flb\xF6\xF1\x02\xFC\x9D\x9D'?=\xA3\xE4\xF7\xD4\x8B'\xD3\\\x1C\xB7V\fKIQ\x12\x00\x93\xCBw\x13\xAC\x19\xF1\x846#\xE5G\xD1 \x02M\xED\x815'\x9A\x1Fn\x17{\xB7\x9D\xCD\xBD\xCCC\x1Bz\xA6y(\xDDS\x80\xBF\x17'\xE8\x0E\xA6\x13\xD5\x06\x03X\xB0Y\xA8\x88\xE4j\x04\x96F\xA2\x12\x7F>\x85\xBF\b\x07\xBB\xCB\x13\xF3\xA2[}<\xA1\x95\xA1D\xE2\x8F\x86\x90\x16\x14bJ\xD7\xD7\xA6S\xEE\x85X\xCF\xB4\x14\xACqht\xFAYS\xFF\xB5tk\xC8\xB5\xBD\xE2\xA5,\xAF \x83\x9E\xA5\xEF\xA1\xA4\xE55R`\xAC\xAF5=8\x1E\xEC\xC9\xE3\x0F\x12\x7F\xF4Go\xEE\xA3G\xA5\x87\xBE4\x9DB\xDA\x1B\xFA\x94\xF83\xA5\xFC6Wje\xE9gMup'\xE9\xBF\xE5&\xF0>U\x07\xA8\x13\xB4\xA5\xCE\xD4\xA24K*\xDDD\xF8{2\xDE1\xFDw\xD0O\xE2\xAA\x98=\x10\xE7\xEC\x9A3\x11\x1E<t\xA6@\xFF\x19=t\xD2\xB6D\x8C\xE6\xDA\xE6V!\xBF\xBEJ\xAE-\x8D\xB4\xCD\x93\x1F\xD4\x90\xDC\xE8\xE2/\x99`\xAD\xB8\x98\xE4g\xA4\x1C\xFC\x05\xD3\xE9!\xFB\x9Bk\xDC\xF1\xAB\x9F\x11\xBF\x15\x82=\xF8\xE7\x91\x03\xA6\x8A\x1E\xE6x\xC8\x19\xBF\xA5\x17\x8Bk\x98\xFAD\xF3\xD7\x854J\xE4\xFC\xA1\x9F\xC9\rG\xB7NL\xEF\xF7\xE2o\xDA\xD1\x7F\xEC\x97\xB3d\xFD+\xFC\x9D\xC0L\x81\xFC\"=\x1CZ\xAE\x99\xE4WU3\xDD\xFA\xCE\x01q\xF0\x1A\x13XJ\xC4I\f\xA1~^b\x8BO\xFA\x19\xF1'G\xE1=5\xB6H\xB0U[O>5\x98A\x19j\xDE|/\xF7<\x0FM\xB7\xCE\xF0\xD0\xC9\xBE\x02\xFC}\xFB\f\x89}\x86\x9B\xC6\xF3@\xD1\x89\xBEz@\xF35\x80-}\xBE\x893\xA3K\xA6\xB4EM\xA0\x85\xBBQ\xEDrG~f\xD2\xD4\x8F#\x16\xB7e\x11\x04\x93\x83E\x80`\xCFh\xD9%\x97\xD9\xC7]\xFB\xA5\xCF\xA4\xB4Z\x18=\xD6\x9D\xCF\x98L\x9E\xA5\x8D\x1B\xB6\xB2_\x96\xD7\n\xF2\xD8\xAE5d\xD3\xE2\xCC\x17K\x1B\x8B\xF5\xDD\xDA\x1Fm\x8E\xB4\xFCw\xD7~YiB\xD8/\xD2\x88\xB9#\xBC\xD7t\xEE\xA5\xB6\xCA\xA0\xFBS\xD6\x1E\xA0'\xC5t\xDC\xD0#\xE7\xDF\xCA\xE2\xE3\xC6\x80\xA9\x06N%\xD5\xB2\x10?\xEB\xE5\xBAA\x96N\x97\xB0\x82\x1Adj\x9CL\x1E\x0E\x9D\x10F\xD1m\xAD|\xB7\xC9\x1EC\xBC\xB2\xAC1\xCC\xB5\xC0q\x93/\tv\xCD\xC9\x96D5\x9D\xCA\n\v\xA5\xB34\xF2\xE7\x80\xB6\xF2z\xB0\xF6\x95;9\xBBh\t\xA0\xAF\x04\xA2\xED\xC0n\x0E\xED~O\xCC\x95\b\xF8C\xED\xB8\x1E\xC6\x9D\x82\xFF\x86\xF6a\x8A\x03?\x06\x82\xFB\xEE\xFFL\xFC\xAE\x8F\x7F\xD4\xBD\xC4\xF7\xA68\xD8e@\xE0\xAB\x1D\x07\x06\xDA\xD9\xF5\xF4\xED\xB7x\x88h\xB3\xD8\xA1\xC9O\x1F\xDD\xFDw\x02\x02\xD5\xFF\x99\xD8\xBE\xFE\xEB\xBD\xC9\x17\xFE\xF7\x1BS\xFB]\xEFD\xBC\x9D=F;\xC4\xC1\xBFx\xBDN\xECX#\xFED\xEE:\x82C\x0E\xDA)\xB8Q\xF2!\x0E\xFD!\x05\xDB\x1F\xDF}\xFD\x876\x89{\xBEp\x04\xF8\xF1Ed\xC9\x8C\x00\xBFB\xC9\x11\xA0vD{\b\xF1\x11\xFD!\x99H\x10\xA7gc\xEB\xC4\x0E\xFD\x9D\xB3\x17\x8B\x7F/\xFFi\xFB\xBE\xD7Q\xBA\xFE\xF2\xB3\b~\xFB\x9D\x82h[\xF3S\xB8\xA2\x1D8KK\x91\x81\xCC\xF5\xE7\t\xD7\xF9\xED\x8F\xBA\xD1j\xDC|\xAC\xD6\x00z\x9DO\xFC?\x92\x9E\xCF\xA4I\xC1a1O\x0247}T\x96@]\xC6\x1B\x046\xE6sl\xD3:g\xD0y1z~\xCE\x00\xB5\xFB\v\r\v$?c^\x8Et\x89f\xB9\x8B\xFE\x9Ds1Y\x81\xCB\xFC\xFD\xE4\xC7x/6\x87\xB2\xAE\x19\xAF\xE7\n\x1C\x8D\x14}U\xDF\xCD\x0E\x9F>\x9B\x93\x9E\xE3.\xE0\x92H\x99\xC5\xEF\x94\xF2\xAB5e,\xDEl\x14\x17f\xF0\xC5\x10.\x94_ihD\xBA\xBC_\xBDr\x0F\xD7_]\xFD\xE5\fR\xD7qh7`sF\x7FW\xFA\xC2\xE7\xE5\xA6\xAB\xBAL\x9D\xBCH\x05\x1D\xC9c\xAD|sN\x14@|\xD7\xEF&\xA4\xBBn\fS\xC6\xDE;+^\x98\xB4f\xF7;\xAB\x83W\xF3\xD0\xD4\f>\x90\xC1\x904\x17\x8DS-R~\x15\xCF\xBE9\xE9\x9B\xDD\xF5\xDC\xD9\x9C#\xBF\xCA\x99Y\x0E\xC7'@\x89\xBD\x15\x14\x04\x96\xF9\xC5zN~2\x98\xDD\x87\xAA\x98J\x04\xA0\xD2\x1C\x8E\xC8\xA5k;\x86J\x9A\xF8\xC5{\x8C\xDArAqS\x0F\x83\x96\x99\xED\xDB\xF6\xBA\xDD9<\xD6\xAB|+\x15?\xCBn\xDA\xCE\xA1\xE7:\xE1\xCF\",\x9E\\\xC9/\x94\x80!\xC3\x8B>\xBD\xEC\xF9G\xC0Zg\xFE\xBB\xA9E\xEF%\x03|\xB3)L?\xDF\x02\t\x04`\x8C\xAA\xEBXN\xAA\x9E\xCAU\xAA2,\xC8z)\xD1\x9E\x04\x06\xA4\x9C\xA5\xFC\xB4\x19'6\xF1\x9E\xFC\xA4\xF9\xEA\x97\xE5\xC2\xBDL\xDD\xC9\x06\xEE\xB3\xFBa\x9A\x14d\xD2\xD7\xA2\xAE\xE6l\xCE\be\x80\xB1\x03\xD1e\x03\xC6\xD1\x1B\xC2\xBE\xCA\x8DE\xBF\xCA\x01\xA5\x95>\xF0R\xE7u,\x8D\x1A@8\x9AB\xA3\xCCy2\xB5VK\xCA\xAF\xF1\xD1~lnR\xF2\xDB_\x93a3\x85\xF2{\x065#\xAC[\xC9ow\xD9\xBD\xE2\xBB\x99\x1E\x81\xE4HY}\xCC\xB6\x99\xB8\x15\x92_Y\x83i6\x92\x81+\xCCK\xC2_\xC8\xC5_\xA7\x94_\xD1tk\xF7pF\x7F9z\xC0\xD4s\x03d@V\x99l\x82\xE4\xB7}\xFE\xB8\xCC\x92\xE9\xB6\xDD\x89o\xDD+\xE9pu\xF1$\xA66\vhl\x1AL\xE0\xFB\x9C\xDE\xEF\x1C\xFC\x81K\xFCi\xAC\xDE\xB4\xDAz\x9D24\x11^d7\xA1V\xCA\x8FEpE$\xC2f\xC5P\x1C8\x10-\x1BX\x97n^:V\x1F\xFFt\xAF\x05\x04+g\xEE\xE5n\xB2\xC1\xF2\xCB\x9A\x80\x9A\xCBRH\xC9\x11\x90`\xB5\xD24\r<\x94\xD8\x87*[el\xF5V\x82\xF5;\x90%\xAF=\xBB\x13\xD5\x96\x1A\xBFV\xD4N\xF6\x928\x1E\xAE\xCB\xC0\x8C\xD4\x8D\xC6l;\xC8\xB9\x83\xBF\xE3\xE6\xCC\x98\xC4_i\x16+\x81\x11\x17\x7FGp\xAD\xC2\x1Fk}\xBF\x17\xAC5\xFA\xDD\x04\x9Af8\xB4\x93y\xFC\xDD8_~w\x93\xD1\xD6\xCA\x15\xFE\x1A\xA5;\xA6n\"\x8C\x07\x0E\x88\xF3\xAD\x9A8\x8A\x01Y\x7F\x8D\x85\v\xE4\x17\x9AjS\xBC\xAFk\xC3\xBDm\xFBO\xBA\xF2\xF3\x1D\xCA\th\x88\xF1\xAB\x1FF\xD9\xE043*\x1C\xF9\xFD(\xDE\xBC4:{\xA8[\xC8\xAF8\v\xE4\xE5\x17\x11\xD6peu\f2]4j\xEAcR\x92\xA5\xBE\x91^l\x16\xB7',\xC6\xFDO\x8E\xCC\xC1\x9F\xBE\tu\x19%S+6~\x8D\xD4\x7F\x9CR2\xCA\xAE\xFFa\xCE0\xF68\xCB\xEB\xCA\xAEm\xE9\xDE\x02\xB0V\xC2_9\xA9\x17\x85\xBF\x18fm\x92\x9F\xFFLk\xF7WFX\xEB\xCC\x81v=\x17\xA5\xF1[\xE9\xE0o\xBE\xFC\xF4\xC34~\xE7\xE2/vH\xE0O\x9Co\xD3\x83\xC4/\x85\xED-\xE5\xE7jo\xB6\xEAU\xF9\xE0F\x97\xDD]U\xDE\xAC2\xA7\xA6yQ\x9A\t\xCA3*\xF1\xB7\xE9 cF\xB5#?\b\xF9am\xD1\xE4\f\x10\\\x95\xBB\x97\xAA\xFA\xD0\xB6j\x8D\x01\x84\xFE\xFA\x04>GwPaj\x97\xDCK\x9F6\xF8x/\x021%\xBF\xA4\x07\x7F2j\xC4R\x88ZJ\xA6\xD6:#\x19\xA3\xBC\x99\x1Fv\xD1\xF8\xB5\xB8M\xC5\xF8d\x12P\xC5\t{\xA6\x93\x83M\x93\xFE+\x03z\x9Dpph\x00\x03J~\xCB^\xEE\xEE\xB7\xF4\x97\x1B\xBFej\xE5\x1F\xE6\xC0\xC5\xD8\xDC\xCEzH~7\xCD\x93\x9F\xD0f\x01\x13\xAD\\.\xE1c\n\x7F\xF1\x9E0\xBE,\x13l{\xC8E(^\x80\xC2\x9F\x93hY\xF2\x92\\\xDDQ\xEE\xF7\xB5\fT\x95oU\x82\xA8\x84\xEF\x91\xAC\x80F\x9F\x14\xF6\xAAm\xD3\xACS\xCAo\xF5\x99':\x85\xFC:\xE3lg7\x104yc^~\xBEd\x93\x98+\xEEt\xF5\x9F\xFE\x92\xCC\x995\xA2\xBB\xFBp\xC5\xB8\x90_;\x90\x9C\xA7\xFF\xF4MX=\xE2\xCC\x1Ff\x80\x96\x8D\xB3\x99\xB4\x94\xDF\xB6\xAC-\xF1G\xF2\v\x84\xB2\xDDm\x82\xEC\x19\xF0\x19R\xFF\xD5\xBB\xFAo`7\xCD\xBF\xFE\xF5\xAD\xDD\xFD#\xAC\xEF\xA1\xEF\x9A\xEC\x8C\x18y\xEF\xA2\x12\xBA\x1C\xBF\xF3s\xC4\xC5\xC0\x0E\xD8\xD8\xCFe\xD0\x9B)\xFC\xD5~y\x1D\xA6\x88zl\xDA3\x8E\xB7\xE4q\xBE;\xE9'N\xC6\x9B^\xDC\xA8\xEC\v_e\xAC5\xE2\xB8\xBB\x0F\xC2\xD7k#n\xE9?\x97\x07\xD7nif\xF5!\x13H\x1D0\xD93\xF5\xF1\xB8\xD0\x7F\x95]\xDD\xA4\xFF\x1Ay\xD0\x89\x81\x1B\xD7\b\xEE\x17\xB5q\xAF\xC2\x1Fk\xBDW\xC9\xAF\xA7\x0F\x1B\f5\x7Ft\x99\xCE{t97\x103\x9D\xF1[7\xCE\xBA\b\x07R~\x11k\xA7a\x84\xB9\x83\xBF\xBA\xCC\xAE\x9C\x90\xDF\xF4,\xF7\xD9s\xE5\xF7\xAC|\xB0\x80\xF1\xD8\xBF\x0F\x98\xEC\x96\x7F\xBF\xAF\x1D\xDD\x07\xB8\x18\xD9\x9B)3NXT|\xA1\xF9\x83\xF5\xA2K:\xEE\x81~I\x87\x03\xF5\x19\xDCX-\xF0\\\xD5\x10C\x9AC\x7F\x87\xAAh\t\xC4\xBA\xF9\xD9\xED\xB2\xBC\xE5G/\xE0/\xAF\xFC\xF2\xAA\x1EE\x17\xD3<\x94\xBA\x1B\xF1\x11\xADD\xAA\xD7\xC8\xE0\x87r\xF5b\xE6\x1F\x7F\xF6\xD3\xCB\xC6\xEA7\xAD\r\xFB\xEA7F\xDA\xBBi\xFE\xBD\x97\x97:\xAFC\xE3\xEB\x80\xD0k\xEB\xA0\xCB\xE9d\x04\xAF\xCAO\xA1\xB1\xEC\xE3X}\xFA\xF7\xB2\xFF\xEA\x12!\x8F\xFDg\"/\xBFU\x19Yg\xD6\xFC?\x05'6\xE0\xBBU\xCA\xAF\xD3\xB5_\x94*\fd{}\xAB3\xFA\x11\xDFE\xC0\xCC\f\xA0\x8F\xCB \x8B\xD8\xBD\x7F\xC1Z8%ds\xC9\xB2\xAC\xEBw\xCB<\xF3\xB5+q\xF6\xA3B\"k\xA36\xDE\xE1`\xEB\x9Dp\x936\xE6\xD8/\xAA\xA0\xE8sG\xFE\xCAxc\xDDC\x9FR\xC1\xEC\xCFq\xBC\xF80\xFE\xCC\xD4\xC4/\xF4\x87QWy\x92uj\x1C\xD05\xC3\xF0u\xFA\xCC\xBBK:\xF5wV\x8A1hn\xD0\xB8n\x9C\xA7^\xE7\xB7?\x8D\xCDt\x99\xAB\x8Fr\x86\x19\x9BOi\xE7\xD6\xACR,R\x13VsF\xA6\x1A\xCF_\x02\xBCx\t*c\xB1\xD0\xB3\xB1\xD0!\xCC9\x15\xB1\xCFu\x8B\x9E\xD7\xE7\xFE\xCE\x89b\xF7\x1A\x05AmK\xEE\r\xD0a\xDA\xEF'\x1B\xE6\xE1\xCA\xBE\xF9|\xB9(\x03\xB3N|\xB8\x84\x15\xFD\xAA{\xB6\v\x1BL\xE6+\xB4\x14\x98\xD8\xC9]\xD5\xA7\x8D\xE0nm\xA7\x92_\xA3\\b-\xB4\xDE\x07\xD8\x03\x93\xA8\xE0\xFA\xA4\xAC\x18\xDD\x19z\x9E+M_1r\x0E\xF9ur\xA7\x14p4\x94\x81\x81\xA2\xCCQ\xCA73*\x1E\xE02\xEF\xC9#\xBF\x95(2K|<4\xBFv \x8A\xEE\x86\xAF(C\xA7\xD6\xDE\x15Op\xA9\xE0\xB1J~T\xF67\x94\xB1`\x84ve\xA5\xFC\x8A\x96\xCE\xA7\x85\xC5\x9E\xA5\xB5\xCF\t\xCD\xFF\xDA8\x18\x85\xE86gT\xB1,g\x8B\x91\xE8\x04\xEF\xD3\x87(\xDB5R7V\xD6\xCDw\xBD\xF0\xA3\xDCh\x01:\x1A\xC54\x91\x1C\xE5\xEE[\xD8`\xC1~\xB7\xEE]\xDB\xC1_(\x8B\xB7\xAE\xCE\xE8C\xA76r\x8E\xB7\xE44\xED\v\xA3>v\x9D\x90\xA4\x98\xA8\xD8B\xF4\xDF\xD9\x9A\xDC\xB9\xEC\xCAc\x96>\x84\rk\x1F<I\x87\x8C\nb2.\xAE;\xC1K\xE5\x945\xF4&\xF7\xAF\xE2c<\xB0\xC0\xAA\x19\x7F\vf\x7F\x00\xE04\x87\x16\x9F\xE5\xD0\x93@\xA9\xBA\x109 *\xAF\xAA\xC9b\xD6~(!\f\x1B}h\xFC\xD9\xF9>\x1CO\x11t\xE3\x06\x13(\xBB!\x85\x89c\t\n\n\x88;\bqo\xB2\xD6\x06N+\xA7\xD8\bE(\xEA\x99\xAF,7\xD4\xDD\bsx8S\xF0\xA8\x06g#\xC3j1Q\x02\x88\x9B\xDAL*\x16\x94\xF2\x13\xA3!\x86t<\xC1&\x0E\xACys\x12\x07\xF3\xF2\xAB9\xC1e}\x10O\x8D\x0F\xB8Y\xF8\xEE\xD6\xC1\x83J~\x03q\x8B\xD9Xsh\xA2\x99\xF2\xA0\xD2\xFB\x13\xC0 '\xDB\xA2X\xBA\xF8_\x8A\xF2\vZ\xB3\x83\v\xE3o\x12\x89\xB4\t\x04\x85\xFC\x0E\x00\xEC\xE7@\xF1t\x9F\x1B#AMu\xBC\t\x11\xE3\xC1,\x869\x98}d\xE9\xFCsx\x92\xB1*&\xB2@Ys\x02\x87\xD6P\xA9\xF0xS\x01\xFE\x84\rG;b\x9C\r\x91\xC93\xB4\xFF\x853\xDD|\xDF\x03S3I\xD3,\xC0_\x11\xD8PR\xFES\xDA+\xE4\xC7\xD8\xE0\xA1\x17\xB3.\x0F\x88\xE1\xD0S\t\x96>x\xF9\xCE0\x0E\xC2\x1D\xBFfH\xD5\xE7R\xEB:\xBC\xF2Kz\xF1\xE7\xC8\xEF\x99\xB4\x90_<\x9D\x16\xE3\x97u\x1C\x12wA\\r\x90\x07\xA5\x99\xFC\xF8\f\xD7{z\x8E.\xA6\xFF\x86\x05S/\x13\xE37\xC5\xC1\x1E\x02\x82\x11*\x15\x8E{\xC4/\xAAk&Z\x10\t\xF5\xA4p\x10`\xB9\xC1\xE1\xF9e\xBD\x9E\xCC\x9F9\x1C7\x81K\xB7f\x91\xA4\x90\xDF\xE6\x89\x16\xF5\xF8\xF9dU\xDAQ\x93av\x99\x13\x8A\x19\x18\xBA\xCF\xA7E\x935\x89\x02\xFDgp\xC6\x9D\x07\xB6\xC9\x9D\x90=\x18W\xBC1J\xF2K\xA58K\x0F\xC6\xF6\xD0\xABU\xB99F\x1Di=a\xA8\x1Bs5\x8DK\x05il\x05\xD5[}3m\xB1\x9C\x90\x9F\xC4_rsF\xC9/\ti\xEE\xB3\xDE(/\x99~\xE7)\xAE/P\xD1,\x94\xC5@\x8C\x03\xD7\x02\x9Au\x04`}B~)'x\nt\x1E\\\x93E-\x82R~vb\x81i(\x95\xFF\xAA\xE2mqW\xCD\t\f\x1E\xA2\xFA\xBD[\x9D\x82CJ~\xB1<\xFEz\xEB\xA4?\xF1g\xD3\xFD\xC9]\xA7\xA6f\x92\xB1D\xC1$\xBA\xAE\xDD\xC5_\xD1$\xD1\xE1\xB0#?\xA1_\x02\xB7\xE2;)\xCE^\xFE\x81x\xFB\xDF\x94\xD9\xE5\xA1,:A\xFAO<\xF9\xFC\xF1\xEBY>d\xE5\xB9$\x8D\xDF\xF8\xA1\xF5R~\xC3\x07L5~\x93\bNJ\xF9}\x98\x83\xA5\xD2\x9C\x99\v:\xBE\x9F\x14\x8Fjsh\xCDBBC\xF9\xF1\xFBE\xF1\xA75\x9D\xB6P\xFE\xECD\x8A\xC6\xEF\xD0\xE03\xF3KO\x1C\xF5\xE2O\xDC\xF8\xC4\xB8\xC0\x06yv\nI\xA4\x8B\xBF\x18g\xC9\xD7(\xD33\xDC\xD4\xD3\x9D|\xA8\xDAH\x14\xC8O\x9BA\xC5\b\xEB:\xA0,\x84\xB0\x90\x9F6\xE3\xE2\xAF\x85x\xE87c\x9C\xF5\x1D\x8C=0\x89\x03\x94\xC0%\xF4\xA4Q7\x16V\xF2\v\xCF\xC3__\x81\xFES\xB7\xD6\x19O\xB0}Xs\xE8e9~\x93U\xA6BD\x9A\xCBlx\xF6\xF8\xE7x\xD1\x99\xA7R\v\xCA\xAFh\x12\xCF\xC4\xA8\x9C6\xB4V\xA1\xFFF\xF3\xE3\xF7 \xC9\xEF\xA9\xCFN\xE2T\xD5\x9A\r\x94\x8C`\xA7\x06\xACs\xE2O0\xAF\xB2\xAD\xBD\n\x7F~\x1A$E\x93^\xFC\xADU\xF3o\x92\xE6\xDF\xFAp\xD3\x83\xDDC\xDF\xA96\xDAG\xBD\xE3\x97u#l\xE9\xDD\xE3\xDC\x95\xDFFS\xF3\xBD\xB7\xE9\x06\x82\xB2\xFE0\x102p\xEA*KO\xBE\xB5\xA1;\x8C\xB7\xA4\xFCX/\f\xA3[\xC8/d, ?\xDD\xA3\xFF\x92\xDC\xD1*\xF5W&\xF4\xA7\xB0a\xED\xA1\x13\xE2\x90\x13\xA3b\xFC:\xF3\xAF\x8C\x1D\xF7\x0Ep\xDF\xB2\x93\xE3\x9C-\xB0\xEA\xD7\x17\xC6\x98\xC0O\xBD`\xD5o\xC8k\x94\xDE$\xD9\xD91q\x96\xDB\x8F\xAE\xB5\x11\xA9Zk\xD0\xFCk\x8F\x0F\xCC\xC7\xDF\xB8gU3\xEF\x05.\xBD!\x85q\x02\xA5\xB1\xC7,(\xD8$t\xFBUT\x81\x9A\xA3V\x8D\xDF\x13\xFBJv>\xF0\xDA\xD9\xC7+\x12\xED\x9Es\n\xFCa\xA5*\xA9(^\x00\x1B\xD1f\x96\xFA>\xE5\xD6\xB0\xD2Vb\xE5\xFD&.\xBF\x88?0\x89er\xFC\x96\xD8\x98=\xF2W\x93\xAA\xCE\xF4|\xFB\xAF\xD6\xA3\xF49\x14\x05\xED\f\x9Bh\x06\xDAS4\xD9\x1AK\xC4\xE4^\xC1\xA5\xD9 Udx5/\x9A\xDC\x17\xE0%\x1B\x16\x98=\xDAQ\xF4@\x86\xF0\xC7.\xBDH\x96~\xD6\xEC\xCF\xD0\xAE\x87h\x80\xED\xC9d\xF1\xC5g_\xCF\xD2b\x98\x8E\xD0\x02\xF6K\xC0S\x9A\xE1/\x85\xAC\x9E;\x81\x00-\xB1Y\xD7\xDE^\x80?-&W\x10\x9C\xDF\xCEo\x7F\n[^C}z.95\x16\x89\xF3\x86=,\x97\xCDe\xC7|N\xCEs\xB8 n\x9A\x9D\x1B}]\x88y\xFA\xC4/|\xB2\x18\xB3\x8FLR\xD3X\x98\xF0z\x99l\xD8\xE7\xF6I:\x07\r\xE7\xF3\x02\xC8a\x97\xD7\xCA\xA2\xD2X\x80\xF4{\xB8\x1B=4W\x1A4\xC4q\x8D\xC3\xA8J\x7F\xFE\x19\xBA\xCB\ng\xE9\xAA\\\xC77_~f9\xF4\x11t\xE0\xEA\f\x10br\x99\x88\x8A\x82V\xEC\xF4\xC8O\x7FUh\xFE\x97\xC4\xECv\xA9\x9C\xD9\x1ExWN\xB87\xFC.\xF9i\x19)\xBF(B;\"\xD03\xB1\xF8\x9Cc\xA2\xBB2\x930\x8A\x8Eo\xC8y\xE4W4\xC2\xD7v\"\xB4\xC3Y\x1C\xC2\xE6\xCD\x13\x15;\xE7\x07\xE0/u\x81\xE4\xB81\xF4\\\x19_L~\xBE\x02\xF9\x8D\xF3R7{/\xF8\xB1}$\xB0Q\x94$\xCE\x85\xBF\xA2\xB3C\xD8h\xE9\x1C\xD5\x160\xF9C\xD9\xA7\xC6\x04\xE5z\x8F]u:/{\xD6\xAAn\xAF\xF4\x90\x9Cu\xC7\x8E\xA5\xA5\xED8}.\xF1i3\xB3\xBC4\xA5\xBA\x19q\xDF\xAAil\xA89\x9B\x9Bs\xD0\xD8\xB1ma\xCC>\xB3\xED\xED\xBE<\xDD\x9C}\xBA\xE6\xEC\xB4\x81@\x933\x9B\x86\xE6\xADr\x19\xBD:\xA3\xCF=\xD5\xA4<\xB8tR\x10h\xDA\xCB\"\v#G\xEC\xBD\x9Ab\xF4\xEF\x1E\x95_\f\xF2b\xF7\xD6\x82\xB7\f\xECV\xDF\xA9\xEBv.x\x92\x92\x86\x01\xAC\x19aCd\x85\x0F\x1E\x96\xEE\x8B\xAC\xE2\xAB\xD5\x8E\x81\x96\xE6\n\x7Fc@\xB0\xF5yi\x8C\xC5\xD3\xAF\xCC%q\vl-\x07\x05UHs\xB0^\x03\xBEH\x125\x13\x91\xF4\\\xC26\xF8b\x16\xC6\xEA\x93w\xB9\xD2`]\x07\xAF\x98H'gy\xA0\t\x8A\xB3\x07\xE7\x19;\x83i\x13\xA9\xB9\xDF\xA9\x83{q@\xD9\xF7\xFA\xF4\xC0\")*I\xCAlE\xFCP\xC61\x1B\x83\xAD\x0E#\b\xFEZ\xE6B\f\xF0\xA0\xBAD|a\xFCM\xE7\x04_Hb\xED\x11 \x11']\x16LQ\xC2\x1E\x9E>\xE4\xE0/\r\x89?\xD6\x06\x14\xF7H;\xEF{\x83i\xBA\x18;'\xFE\xF4\xDC0/\x1E'\xF9\xE5:\x11\xBAg\x1A\xF1\xE2\x89\xC3s\xF9\xFE\xE5=)tF\xB7N\xB8\xF8c\xCF\f\xC6J\x8F\xFD:\"P\xA7\xAC\xE1\xE2\xF1yf\xF2\xA1\x8C\xD66\xE7\xBB\x83\xEA\xF1\xA5w\x81\x928\xD8\xF0\xC2\xF8c\xD3\x92\xBA\xD5\xDCu\xD4\x91_\xF1W\xDFp\xF1\xD7\xBB[\x9Ae\x8E\xFC~\xB2\xE0Y|\r\x03\x82;+\xFC\x11\xD7\x17\xF8\xA3K>\x19\xAFV\x0E\xA6o;\xF8{E\x90\x81'\xE4C\xC7\x95\xFC\xCE\x89?\x96\x1E\xE0\xC1#xB|\x8AS m\xCDD:1\x0F\x7Foo@d\xF5D<\x8F\xBF\x81\xC4\xDADW\xEA\x93\x82\xAA*H\xCD\xF7\x93\x0E\xA6\xCDy\xE3wP=>\xC7S\xDC\xC1_z\x11\xF9\xA5%\xFE\xD64\xBF\xE4`7x\xB7\xAB\xFF~14+]9\xCE\xF8\xFD\xDBE\xF07\x84\x98\xC9N`c\x02\xF8\xC6\x15\xF0\xE2/\xBDfb\x87\xEB\x10\"o6\xBB\f\b\xA6\xA5\xC0\x86\x0F\x1F\x96\xE3\xF7\xE9s\x8E\xDF\xD40\x0F&\xA4\xABd\x96\v\xFC]\xDE\xD37\xF7\xA1\x07\xE2=M(\x8F\xACI'\xF3\xF8\x1BN\x0FN\xE78/\x9At\xF0W49\xEF\xD4\x83\xE7\xC2\xDFw\xC5%IL\x8B\xC9\xEF}\x85\xBF\xAD\xEA)3(~\xC4\t\xEE\x96\xBE9\xF1\r%S\xF5\xB6\xDB\x16\x9E\x7F\xCB\x14\xFE\xF4\f\x90\xAC\xE6^\xFD\xF7\xED\xF8\x15'\\r\xC1>\xAF\xFC\\\xC1\xF4\xF7\xE4C\x1F\xCA\xB4\xFCn\xFCi3\x03\xBC8A'\xE8\xABG\xA09\x895o\xF7\xED\x9B\x8B\xBFo\x1D\xCAbv \x1D\x1F\xCA\xE3/=\xD8\xD8gwz\xF07\xBFJ\xEE\xB3)>\xAF|\x90\xA3,\r\xF13\xF2\x0F\xE9\x13\x83\x8B\f\x8D6Z\x1D\x03\xC7\x07\x00?J\xFF\xD2\xF5\xD9_\x9F\xAE\x94s\xB23\xFF~aa\xF9-\x1B\xC0\x06S\xEF'\xA7\xED\xF8\x0F,5\xFFR\x16\xF4\xE8\xF0[j\xFC\x8E*\xFD\xA7\xF9\x04\x19\x95\x02{k#\x97\xDE\xBC\xDC9\xE5\xE7\x1B\xE3\xA5/\x11U\xCD\xD5#\xF4\xA53\xB8\xEA\x865s\xE7\x8F\x89c\xFF\xD0\x8B\xFA\xBA\x9A\x1F\xBA\xAFB\x1F\x98\xD88\xF0\xA9\xFE\x9B\xC9+\x8EE\xE4\xF7\xFAU\x966\xB7\x82\xEB)\x05\x9F\x94\x98\xB6u1s\xB0c\xA3\x8B\xCC\xBF\xB7I\xFEYw\xF8N\xC5\xF5\xB8\xF6w3y{\xB9N\xDA\x84\xFA9W\xB7\xEA\x93\xB5\be \x8B,\xAF\xBD\xDFT\xF6\x1F\x15W+\xC1\xEEW\xE4Qu\x1C\xECo\x15\xFE4[\xB2\xDE\v\xBB$o\xD4\xEDs\xE3\xAF\x8A\xBA\x86\x00\xE8\xEB\xA4\x99(\x18=\xD1<\xE7\xA0\xF8}\xDF4\xD0\x89\xE3\xE6eyw\xCE\x87z\x06W\xDE\xF1Ia\xE1\x96,6~/\xB9\xDF\xD4f\xE6|\xB7R)\xCB[\xC9I\x7F\xBB\x90\xDF\x13\x15\x8B\xD8\x7FO#@\x15S+\xED\xF3\xC4\xEB\xFC\xF6'\xB1\xB5,\xC0\xF6Ls\xC9B\xF4\xC3Y\xA3k\x10\x8Fd\xF3(\x8A\xB7\xA2a\xC0!J%\xF9\x81R\xB0W\x9D\xAA\xA0\xB6\x15<-\x8E\xDC@n\f\x9E\x14\xE3\x05\xB9)\xF7\x04Z\xFC#\x8B<g\xD0\xED\xEB\x1B\xA4_8\x15\x94\xCD\xFFo\xE2\x13\xBA\xAE\xF0\x8E\xEA8\xCC\x94\xEF\xDC\xF2\ve\x8E\"\bvt\x81\x05\xCD\xAE4\xB4,\xBEP\xA0\xEBz\xE7\xC8\xEF\v\xC0\xA4QV(\xBF\xB79\x8E. ?kq\xF9}\x94\xE2.n\x9D\xE3\vUb\xA08\xBD\xAENE\xDA,\xF8\xC0\x9Bw;\xF2\x13\x8A\xF1\x03?\x9A\xA4\x9F\xADUu?(\x8F'\xE4\xF6\xBE-\b\xAF\xA8\xBDP\xE9\xD5\xF9\xF4\x1F\xA0\xB4en\x94\xE2-P\xBFY\xCC34\x9D\xE3\xF4!l\xA8\x19\xC7i\x1E\xCA\b\xCA\xE8\xBDP~\x9B\xE5\xA5&n\x862\xE8\xE7\x86~\x89\xE8\xDC\x8C\xD2Gs\xEEj@\xF9\xDD\xB7\\I(\nJ7^:\xE99\xC1\x1Cn:Au\xC6>\xEC|\xF9\xEFV@\xB1\xB6\x9B\xC5\x94\x9A\x9Fag\x8F]{\x93s\x02A2\x8D\x87m\b;\x82\xD6(2\xCE\x8D\x9EV*\x92ds\xEA=\xEA\xF1B\xD9\xB0y\xA0Y-\xC9\xA2\x82H\xA6\xC9\x9CZ\xE0\xC1y\xF8;\x88`\xA4'\xC5\xC1\xE6\x91\xC0j\xD5\x9C\xB1\x075\x13G\xC5\xBC\x98\x90\xFEq\xE7T^f9 X\xF4\x17\xDC\x8A\xD4\x90aYg;$\x01R<=\xF0-\xF7;\xB2Y\x7F\xC8\x83\xED\x85fmC\nN\x10.\x9D?.\xBF\x1D\xA6r\xC15\xCE\xB0\x1D\x1E\tM:/\xA0\xF8\xA8\xC7\xC2K\x1F\xFA\xD9\xF4\xCF\x15\xB5\xA4\xB5\x05og)\x06I\v\x15\xD9\x90\x94_\xF1\xF8|\xF9\x05\x85\xFC\x8A'\x14\x99\x8D\x1D\x1A\x07j\x12.\x18\xC4C\x17z\xD9\x07Q\x9C\xB5\x87\x17\xB2\xD2T%\x13\x96C\xFC\xD08\x86\xC5\xFD\rz\xE5\xF7J\x81U\xAA\"\xDFC\v\x85\x8E\x9E\xA5\xC8\x02\x8A\xE3\xB9\x83\x85vl\x9A\x07\x95i\xFF\x1D\xC5a\xA7SP\x84H\x9Dj\xB0P~O\x13\xFE\xAA\x1D\x8F\xFA\x01\xCB)\x92\xD4\xE7\xBEP\x92\xF8p\xBA!\"Y\xF4\xF7)\x8Bay3\xAD\xA5e\xB4F\x8C%\xB9\xD1\xD3G\x1E\x071\xF2\n\xF8yp\x1C\xB3<\xB0U\xB5K\xB9\xF2N\xAA\x9DZ\x80?\x83\x17\x86\xE2\x83\x95\xD9\x14\x16\xC0\x9F\xAA\xA4\xC3\x9E\xC2\x9A\x89\x98x\xD4T\x01\x18\x82v\x01\xFE\x82\xD4G\xD6\x83\xBF\xDC\x1C\xCE9\xCB\x8B\xA7\x07\xF2L\x9DH\xD7!\xEE\x90~\x15\xF7\v&s@q\xCC\x83\xBF\x81B\xF9=\xCE\x831wh\x00\xDF\x1D\t\xB9\x1E\xB4@\x8B\xF7\xCD\f\xBE>\xDA\xAF\xC4)\x98\x93\xD1#\xF1\x97R\xF8\vl\xBD\x94\xE47\x0F\x7F\xA56\xF6\xF1@\xB3z\xFB\xE6\x1A\xC2\x1F\xBB\xC7yhs\xAE\xFE\xFB!/\x9Eb\x82\xCA\xBC\xB3\x18\xFE\xBE\x8A\xD8\x83\x82\xB0\x15\x8F\xC3\xEB\xA8(\xCE\x16\xE0/h\v\x85\xAF?\xE1\xCA\xEF\xE99\xE9\x12\x11\x04#\xCF\xE4_\x00\xE1j\xC8u^\f;\xF8\xEBw\xF1\x97\xF3\xEE\xC8\x0F{1\x1B\xD48\xF8{\xD3r<hG]?\\J\xE2o\xA0L\x9E\xE0\xBBj\xFC\x9E \xFC\x11\xE1e\t\x1E\x8C3\x92_?/\x18)\x04\x8B\xA7xhZ\xC9\xB4&\x1D\x03\"\xED\xEC\xA4\xE7\xA1\x97\x9B\x857\x14\xDC\x9D\x13T\xFA{\x8B\xE1/\x87:\x89\xBF\x987oD0Ho@5(\xD7\x01]\xEE\xCA\xEF\x17s8\xE7ox\xF1\xB4\xFD},\x82?%\xD8\xD2\xF4-\x80\x8C\x13\xB3\x1E\x15\xF6,\xB8\xA9!\xCE\xF6\xB9m\x1C\x84!\xE3\xE0/\xED\xA6*K\xFC\xA5\x07\xEF\xF9\x8E\xFAwI\x8B\x18\xBF;\bH\xBFP\xE3\xB7\xE4b\xE6\x14\x89c\xADs\xC6\xEFI\x1EhV\xFA/\xA2\xF4\xDF=\x9E\xF9\xB7\xCA,\x9C\xD0J\xDF\xF3\x9D\xA2\xFEj\x8B\xCC\xBFi,\xAF\x11J!\xD4\x84\t^\x00to@\xB5\xB4\x85\xAA\xA9\xDD\xEE\xCE\xBF\x9E\xB7:\xA1&\xC8o&\xF3\x1D\t\xDF\x94\xBA\xFD\x82T\xC1\xFC\xCB\xDE\xFE\xB9\x9B7,\xA7\x83w\xE7FnK\xDA\x81\x8F8\xE3\xF7\"\xCBI\xD1:\x8BR5\xAE\x88\xCD\xCE\f\x9D\xBA\xE9\x9F\x95\x81!0\xFE\x81\xFF\xA7\tXo\xEA\xEE\xFCQ\x9C\xA3\xF9\x97\xCF\x9B\x7F\xC5\x9C\x1Ct\xE6\xDFH\xCC\xA0\xF9\xD7!\x94\x9A\r\\\x91)\xB4\xFF\xF4\x8Bf\xB6S\x7F\xA6\x05\fUP\x9B\xC6\xE5\x89}\bs\xD6\x84\x82@\xC1\xAD^\xAB\x89K\xFB\xCF\xB3y\xF4\x1F\xFD\xEC\v\xD0b\xC7\xF2L\x93x\xE8;\xDCQ\x98\xCA\xFEc+\xBF\xE3\x9A\x8E?\xA6\xBF\x1F,\xC4\xDFf^\xB4\x12\b\xE6\x07B@Mc\x0Fq]Y\xEC\x14\xEE\x0E\xECZ}\xF7cysP\xB6\xB3X1\x02\x99\xBD\xBD\x93\x87\xA6\xD9\x7F\xC4\xFE;\xBF\x9D\xDF\xFE\x947sn\xA0\x94\xCD-\xC8<\xF7\x93Z(\xBBl\x84\xC3X0\xD3\x98\x17\xB6\r\xF6\x99\xD8F\x06h\xD81Cu^`\xD3\xFB\xD8\xEF\x0EJ\x17R\xC4\xC5\x1A\x17\x87\xA9\"}c\xE1\xA31\xF7g\x11wU\xEF\x9C\xDFmu\"\xDD\xB6\\\x0F\xA3\xF4\xB3*\xF7(Wx\xC81\xEDa\x81R\x85;\xF2\xF3\xBD\x96\xCB\xCB\xCF\xA9x\xA5u4\x00\xDA\x12\xFA\xDC\xA0r45S\xF62(k\xDC\xD9a,]\xE8!\xB8s\xB0l\xB0\xE8\xB3\xD0D\xDA\x7F\x99s\xC4\r\x80V\x96w\xDFE\xFB\x9CRF\x9E\xEE\xED\xEE\xB6\x8D\xFB.R\x8DF\xE0\xD44m\x04\xB4\xB5s\x8E\xEB\xA4\xEE\x98\xF0M\x95oQ\xED0c\xD4\xAD\xAF\xB4\x81\xFB\xF2\xF2\xD3\x82\x8D\v\\\x83zAl\xA7&\xC5\xE1=Y\xF9\xF8\xC2\xCE\x89s\x9A\xD9\x93&\x8B\v\x9B:-\xAC\xCAV\xC7\x8A\x94&\x84+\xBFJ5#\n\xB2\xE2N>\xE1\x06\xEA\xF9\xA7\xE4'\xCB`\xD6\xCA\x82\xCA\xCB\x1A\xA7|\xD5+\x16Hw\x14\xDFm\xE7\xD4<\x88Z\x1B\x94\xF6b\x1B\xC9o\xA3sD\x93\x94\x9F3]m\x7F4\xA3\xB9\xFE\xD3y\xDD\xDB\x9B\xB8\xEF54\x16\xE2\xEE:\x8Ey\xF5\xDC\f@\x8B\x00\xFEe\xF6\xED\xB2\xFA\x94\xECi\xF1\xC8\x8E\xED\xAE\xC7a\x96C\xEB\xD8\xC6\xE7_\xA3M\xF6\v\x14\x13\xCB\x8AQS\xBA\x8A\x9F\x10\xF8\xA3\x8A\xC2C\x84\xBF\x9A\x840{\x8A'\xA6\xC9\n\x92;x~\xF1qi\xA5\xEA\xCB\xCD\xA4\x97D\x0E\xB4\xDE3\x1CzB\x99$2\xC7Z?\x0E\x94Z\xC0\xC6\x9F\x1E\xEA\xAE^([j\x13UT\x12\xC6N\xDD\xBBb\xAE\xF5\x8D\xE3-\x89?G\xD8\xA79\xF4\xA1\xBC?\xE2\xF8&3\x8F?\xBDo\xCE\xE9N\xF3\xD0\xAE\xA19\x01\xF31ow\xD9\xBC{\x82\x06\xD8T\xED\x84Z\xC5.^^h\xEB\x13\xA3nr\xEEe\x94\xDD\xA6\x9C\xF8\xDE\xED\f\x15\xF4\xA6\xBAj\x1B\xAF\xC9H\x7F\xC4\t\x0E&\xFBM\xF7\x1F0Y+\xA2\xC4\x89\x8D\x9E\x1E\xF28\x90\xF5\xCA\v\xF0\xA7\xE4'\x8C@\xD5t\x02\xDA\xCAV\xEE\xB4\xC2\xD8\xCA\xD5\xF8\xDDHC\x12+NU\x1B\xB7=\xBA\x807\xAE\x9C\x13\xFE\xC4\xF8\x8D\x1E\x91\xA0\x91\xE5\x83\xDCn\xAFb\x80\xDD\x91\xCF\x99mX\x96\xD0\xF25\xF2\xA2\xF3\xF17\x15q\xC6\xAF\xFA\x85\xB0\xBE.\x9Dk\xFCK\xD5\xE2\xDF\x12\xBFI\xB5c\x15\x86\xBA\xBFr\x87\xEC\xD7!\xB6\xCF\x02\xDA=\xDB\x16\xB0\xDC\xE8\xEA\x8DT4\xA8\xAC\xC1D\x93\x02\x17\x9B\x1Er\xF4\xDF/Q\x97\x11\xF8\vMO\xD3k\x1C\x9A\xA7\xFF*\x95\x92\x11\xF8\xBB\xCD\x91_y\xAB{\xB5f\xEA\xEF\x02hLVw/\xBB\xB6r\xE5C\v5p\x15\xE3\xB7\xD53~}Y5~/v\x0E\xDE\nh\xEB\xF3h\xDA\xD2\x97`n\xEB\x10-6_\xFF\xED\xACU\xE2u\xE4g\xC9\xB1Z\xB0\xBD-\xDF\xB4\x7F\xAA\xF6?\xABN\x9Dw\x8A_\x04X\xAB\xAAoF\xCCF\xBBM(\x8F\xDB\xE6]\x03\xC0\xC7\xE8\x04+N\xABPO/\x07KS\xEF\xEBd\xD2de\xA86\xD9W\x81`\xBC\x07p\xFC\x02\xFD^\xF9\xDDh\xC8:C\x05\xFA\xAF\xCC+?U\xF1\xB8\x94z\xA5\xE0\xE2\xC6\xCA\xCB\x8D\x85\x1A\b\v\xB6(\xE5\xB7\x8C\x1Av/\xB1qg!\xFE\xFEZV\x80s\xA4a,K\xE4\xCD\x00\xADl\xCE\xE9\x9A\xE1\x9B\x8Als\xBBP\xB9\xF8\xBBc\xCEq1@k\x02\xFC[\xD3\xBF\x943\x84lX6\xD5\xB1\x9D\xFB\x8F\xE4Ud\xDB6>\x7F\xFEhPJP\x9F@\xD8\xD7+{\xAE=.\x97\x95\x02\xF8\x97\xC1\x84\x9E\x16\xF3\xEF\xDF\n\xBA\xFEy\xE5\xB1\x01\xF0[\xAF\xFCZU\x9DI\xE6Y\x91\xAC\x85\x85\xFC\x1A\x1D\xF9\xC9\x8A\xF9\xEBe\xA7\xA1\xF5\x8D\x95\xCD\x9D\x8B\xC9O\x8D\xDF*\x95\xB1z\x82\x0E\x8B8\x07\xFFD\xC2\xC7\xC1_gY^\r\xCF\x1F[\xCD\xDC\xBF{.\xFE\x1A\x17\xC0_\xA7B]\xB6\xD6\xA7>\xBD\xE4\xE2/\x91?\xE4\xBF5-0\x7F\x10\xB5\xFC\x18\xE9\xBF\x15o\x8FK\xF9\t\x9E\x9C&.\xDE\x9B\x14t\xAE\x928]\xA0\xB9\x87\xE6\xDF>u\x88+\xBF\xD2\x1E\x8F\xFC\xC6\v\xE6\x8F\xE7\xD5\xFCQ*\xAB1uI&\xEC\xBB\xE1&\xDB\xD8\xB4\x80\xFC6\x8C\x00\xA3(\x15\x13\xEEZ:{\x16\x86,d\xE2\xCC\x1FKU\x9E\xB4\xBA\x8A\xB1\xD1\xCC\xE3O\x9F\x1BI\x7F\v\xA5\x0Fr\xC5\xA2C*\xE0\xFB&/H\xB4v\xC0\xA5\xF7\x03!#\xFEg2\xAAP*4A\xE9\x83I\xCA\xF6r\x0F\xE9\x11\xF3\xCC\xDC\xE8$%\xB1O\x02\xFA\x19l29\xDE\xE5\xBF\xB7\xFD\xE7\xF2<\xDD\xC8I\xFD'\xE6\x0Fw5S\xB8\x82;VC\x05\xC7\t7`\xB4\x8E\x98\xB51\xDB\xBD@\xA2p\x91\xA9\xA2#\xD03\x8B\x07o.\xCB\xE3ov\x97\x97n~f\xCE\x81%\x1C\xD9\x0EEi\xB5p\xDE\x8E\xB9l\xFE\xFC\x8B;d#e\xD9\xA9\x93\xD1\xED\xDEza\x99\x1Br\x11\x87\xACg\x8B\xD9\xE8\xE2\x1A}(:\x9D\x85\xC6\xCF\xF3\xAA\xF3\xDB\x1F\x7F\xE3r\xAE\xDF>\xC2\x17tS9M\xD1\xF2\nX\x11EU\xBA\xEA\x1C\xCBh\xA9R\x92f\xC0\x870\xFC\xA455\xF7\xD4\xCB\xB8\x89\xEB\x1CUj8\xBC\xD4\xA1\xBC>R\xFF\xCA\x87\x1C\xCE3>o\xBC\xDA\xC9R\x0E\xC0ww\xC9\xFC\xF8\xAA7X\x1C\xF0\xE4N\xF3\xFC%-0j\x07W\xA2v\xB8a\xE7\xFA\x85\xC8\xBCa0w\x19\xB2\xF8D\x1Cy;g\t`\xF3X\vZ>vz\xCA;\xE3\xD0\xEAL\xD9\x99\xEF\xEFgd\x03 1\xA9\x87\xDD\xF9\xCD\xDC\xBE[|\xB7\xD4\xB5\x19\x88\x92\xED\xCF\xDB\xCA\xBE\x06U\xFEu\xF9X\x18\xD7\x02\xFA\xA6\x86\xA5\xD2\xB6\xE0\xC2\xEA\xB3\xC4w\xC2`qf\xBA^\xE2~t\xD3~bwR~ZX\xBAl\x97y\xF2Xd\xD5])\x92Q\xF8v{\xD7\x13\xAF\x98\xD46Q.S\xFE\x90-+>]o\xC8\x96\x19\x9B\xA4\xFC\xC4\x0E\x9F\xA5\xBA,\x06\x84f\rs\xCD\xA8\x15\xEFh;|\xF5\xD2\xECnp\x88\xA7Y$X\x86G~u\xA7\xA7:\xA8\xD0V\v9\xBAc\xD1,nn\xD5\xEA[\xE7\x869h\x8DqycJ\xD6r\x14\x93z\xA7c_\xE9\xB9\xB6aS\xDC\x9A\xAC\x00\x1C\x93]>\v\x1A;N\xA7%\x13\xAE\xAB\x92\xD6f\xF3\xF6\xAF\x9C2\x14\xC1\xBA\xFA\xD4\xA44H\xB1\"\xA3\x9E\xB2\x93(\xA8l\x02\"L]\xC8\x18\xA4\xD6\x01Jo\xDD\x98\x98\x83?%\xF6a^\xEA55\xB6\x94\xBD$xJq\xD6\xC3\x93\xB7\xEF\xAD\x12\xD8\x10\xA6\xE9jY\xD8X\x1A1\xAA\x00O\xAD0:Vd\xB4\x8E\xB8x\x98\x1B\xE1?+\x13#\xB7?\xA6.i\xEE@0b\xCB\xAE\x01\xF4\xF2\x18v\x06\t\x7F\xB3\x14\xB7\xDA|C/fg\xDF\xFC\xAF\xBF\xF6\xDC\xE1\x07]_\xFD\xE6\x9F\x1E\x95\r\x80\xC4L\xFC\x8F\xEE*N\xFB7\xBB\x05\xF1\xBC\xCAt8'\xD5\xE9\xF0\xE0/\xB4\xA5M\x8E\xEF\xC0\xE9\x16\xC1\x16\xF5\x8E3\xC7n\xC8\xAA\x8C\xE4\xE5\xDB\xC2\xCA\x00\xDAh\xE92$\xB9\x97,\x0F*\x13\xBB\x9CZ_JSR\x1F\xA0\xF2\xD7\x05\xF8#KP\x97\xD1\x9B\xE7\xE1;\xFB\xB2\x07\x7FW\xBF$\xCEW\xD2\xAB\x82\f\xC4\x84\x87\xFF\xCB\xC7U\x00\x80\xAA\x13-\xB5\xF4\x97)W\xED\x14E\xD7\x83\x82\xB4n\xB4\xF4\x9E\xD9g-\x8A\xF9\xA7e\xD5\xE7\t\xB5\xC4U\xCF\x19(:[\x88\xBF\xB3O\xCD\xEE\x17\x14\x8A\x1E&z_\x16\xAD\xAD\x8DK\xBD\xF8\xA3\x14Kj\x1C\xBB\xBC\x91K_\xBB\xC0\xDF\xCD\x80O\xE6\x01\xBC\xDA&N\xBFE.\x83\x17\xF8\x13z\xEA\xE62/\xFE\"2O\xA1\xA6j\x07\xB1\xC5\xD8\xF6G\x9F\xB7TF\xD9\xF2\xBF\xCF*\xFC-\x1BQV\xEEG\xB8\xDFiBSa\x01\xB7\xF3\xD0K\xCAV\xCE\xDF\x8B#?_\x1E\\i\xEE\xFB\xA7{=\xF8\v\xB7\b\xDAR\xBC\xC3\x83\xBFm{\xAB\x0E\xC6\x81\xA0\x83\xBF5\x19\xEDv\x85?a\xC1\x7Fx\x845\x11\xFE\xD2_\xC9\b\x86\xEB?+-\xC9\xED\xFDNv\x8C\x01f\xE6:\x87\xDFt2 \xCC\xEA-1\xDEE\x14J\xCF\x00\x9B\x1B{q\xDB\xFF\xFC\xD9\x17\xBD\xF2\xA3\xCA\xBER\xFF\x8D\xCD\xC8\x9A\xBC\x8A\xD4(\xFDgo\xDFk\x02\xDBd\x07\x1CW\xFFyV%\xFB\xB7\x92\x96\x8A\xE0\xAA\xFFt\x82x\xE3m\xAD\xBD\xFE\x94j\x18\xB0\xFCZH\x06\x8E\xB0\xE3{\xD8\x0E\xBF\xC0\x9F\xF8\xF2#\x96P\xE2\xECN%\x03\xAA\xBA\xFBg\xF3\xF4\x9F$\x90\xBF\xC1\x92\x83\x9E\xC5\xA5\xB3\x8F\x9A\xDAG\x81RI#\xE5\x9B\xB9v\xC5\xA9/v\xC82\xE3\xB20\xBE%\x86\xB8Oh`\xA1\xFF*L\xFD\xE7\xD4\xA0wv\xAF\x05|\x92\xFB\x1AnW?s\xF4\xDF,g\xA6\x1DM\xC99\x89\xA5Q\xF1\xC2\xDFtt\xD6\x8D\x10G\xE4@<\x9AE\xE7/\xEB\xEB\xBD\xA9\xCE\x95\x19g\xCE+\x7F\xC2t\x1D\xA6\xDA\x90\xD3\xBFL\xCF\xB5\r%\x80&Y\x1DZ\f51\x93\xDC\x1C\xE4s\xF0\xA7\xD5\"\xE8\xDF!\xC8<3\xB7\x7Fe\xECn5\xD8+Ne\xF1_\x1C\xFD'\x9F\xD2\xA6\xB7@]\xEE\xE4\xD4\xA6\\\x11\x8D\xA0\xEA\x15\xEB=B\"\xFE\xA6\xC0\xD5\xC3K\xA6n\xF7\x04^\xBFBMS\r\xD7\rI@\x1A8\xD8*\x03\xA0\x11N\x1C[\xFC\xB6H\xE0oIV\xB6\x01\xC3\xB2\x8C\x167\x84\xC0\x1AQ\xF4q\xA5\xFF\xF6Zy\xFC\xAD\xB2\xA3\x07e\xA5e\x96\x86\xD1\xBD4B\xD5\x89\x1Ah0\xD5=\xDF\x8B\x97\xFE\xEB\v\xEFy\xF1W\xE1\xE2\xAF\xFC[3\xD2a\xF06\x97\x1D\xABe\x84\xAD\xE5&#\xE1v*^r\xABTZ\xDB\xBF\x9F\xE7\x1A\xBE\x97\xC4\xE5\xB4~T\xFC}\x13aw\xA6\xAD\xFF@J\x11\xD4\x0F6\x1A\xF8{9\xFF&\x94 :\xC9P\xDA\x90Q\xEE\x89\xB7\x94\xEBY\xBBW\xA6\x96\xF8=\xF8\xA3\xB5\x0FJ\xEC\x1D\xC0\x8D\x9El\xE6\xCE\xABZH8\x93\x1E\xFC5\xEE= D\\4\xAE\xB2Tj2\xE2\x05\xF8Rh\xE6TbrD\x9B\xC1rK\xEB\xE8\xBC8A\xEF--o\xA8\xD9\x9D?\f,\x89\xD8u\x0F\xAB\xA0h\x16\xA1\x07\xFE\xA6\xF6\vB\xD3\x9C!\xFC\xB1P/\xC2\xC7\xAD]/\x17\xA4\x9E9FL]\"%\xFF\x15l\xF5Spj\x1F\xF6\xBD?4\x02L\x1C#\xFC\x95\xB4\x00\x9B\x01\x9C\xF2D).h\xA2\xDE\b\xB5`\xA1q\x9A+\xCC\xB1\xE1\xC31\x99\xCB\x04\xB66\xA50\xB21\xA1\xF7;\tqM\xAA\xED\xA58\x8B\xAE\xAC1=\xAEl\xC2\x969\x01\x19En\r\xE0\xBFz\xEA\x01\x18zK\x9E6\xEB_\xA7\xEF\xDEy\xE6\xF0M\xC7=1\x17F\xCE\xD1P\x18S\x94YB\xD5k6&\xF4\xB4\xF1!zo\xA1\xB0\x1C\xA8S\x1B\xF2\xFA/\x18\xB1-\xA3\xC1R\x93\xBF_\xBB&Y\xBE\xDC\x12tN\xCE\x9Cr\xD1\xFD-s\xC3\xE4D\xE6\xA9_\x94\xF8W\xC5\\e\xA39\xFD\xD2\x8A\x07\x85\x1E\xDB%+P\xF5\xCA\x83\x03\x9E,\x10\xF6%'Z\x9AY)\xC8\xB2\x9E[\xDD\xDD>\xE2d$kN\x9C\xB8\xC8\xC9\xA2\x9E\xE5\xEC\x88\xB2\x9B\xE4Y\x14\xF5\xFD\xE9\xFC\x02\x00\x92\t\xD7\xBA|\xB5\xA3\x90\xE1^\xE8\xFEV\x9Ey\xC5}\xDF\xB0;\xF2F\x82\xF8\xD3\x01h'P\xAA\xC8\xBC\x9E\x83?\x81\x8E\xD9\x87\xDA\x81K\xB9\xF6\xA2\xBC\xF1R\xD5]O\x9B\x99\xE5\xFA\xF4\x90\x15\xFA\x87\x1D\xEA\xE2u\xA7\xB3\x97\xCD~}\xE4<\xF9:\xBF\xFD\xB17\x97\xBF\xB2\x02&\xBB\x94\xC1\x14\x13\x8C[jX\xF51\xA2\x16B\xAA\r\x90kO\x1A\x85\x94\xD9\xA0\xEF\x94&\xE4\x92'S\x89d6?\x00L\\2\xEC\x9Ej\x9E\xA7Pc\v:\x92\fE\xCE8L\xF7\t\x16K\x8C\x86\xBB\xE0\x97\x17<0\xF7,a6\xF2\x8A5\x92/\xEC\xA49\t\xDE\xD7\x8D\xF8\xBCie\xDBF\xF2jx\xAE\xFC\xF4\x9C,\x87p\xDCg\xE2\x9A\xE1\x91\x9D3\x86\x9B\x00\x82\xDA\x8C\xB0\xBD3\xDC4\xB4\x11aS\xFF~\xF2\xAB\x15\xDC\x99\xE4\x97t{g\xAE\x95\xF9\xDE\x805\xD8\x85\x9D\xB3OR\xB1O!?\xB2\xA9\x95aM\f\x92i\xB5\xEA\xF4\xBE\x95nt\x8E\xCC\xD0\x8B\xCA\x11\xE6,\x82j\xF5\xB0Mdv7\xB8\xA1\n\xB7\xBF.\xD9ay\xF9U\xC8BBa\xAE\x1C\x85\xD7\xF5r-&W\x99.\x1BK \xB2\xD4\x9D\xE8\x97\x82\xA3\x01\xFE\xA9\xDAF\x9E\x0F\xC6\xFB\xEE\xC6\xFB\xCA;-\fY\xCD9\xBA\xEE\x94\xFCd\xD2\x1D\xDC|\xCD\x9B\t\xDC\x93\xA8\xCF\xF8T\n\x94\xC0\xDF\x1A\x93\xF0\xB2s\xC6\xB8T\xCC\x01\x15?S|p\xB60p(\x9D\xB2\xD2\x92\x0E\x9D\xCD5nJ(\xF7\xEC\xAC\x1B\xA4\xAE\x97F\xE0\x886s\xD7\xF0\xE9l\xE3t\xDF6\xB5&\xDD\xE2nd\x9Ef\xC1\xA5\xA3W1uz_\xC6m\x92(\xEC:\xDF\xEB\xA3\bs=\xE7\x91\x9F\xCFR\xA2s<\xF9N\x88aYFU\xDC\x16\xB7\xFB\xBC\f-\xB8vg\xA3\x90\x9F|Ge\xDD)\x10\x89S?\xA30\x91\xAF2\xFA\xFEH\xC8]!\xE8\xB3\xD1&c\xC7$D\xB7,\xA7_\xF5E\x9E\xA1\xDB\xFD\xBF\xBB\xA3\t4\x0F\xFF\xB8rF\x85\xBA\x84\xC0j\x05Qd\xA1\xAC\xD9\xC9\x84 \xCA\xD4\x98\x8EF\n\xF1\x17\x17s|D\xB5\xDE6\xADYa'\xC6\x97[x>\x02'\xADLfo/\xB7\xB4\xB6J_W\xE5\xE9\xAAx\xD2\x94\xAF\x82\xD61\xCB\xA6%\xE4\xF6\xAF\xAD9t\\=O\xC8T\xF4\x15\xD0O\x00\xA1\xCAOHb\xE2$\xD4\x9D$\x92\xF9>\xDC\x13\x90=$O\xC5\x11u\x1A\xA5i\x8D\xB2a\xC5\x06\xAE\xCBX\xD8o\xE4\xAB\xA5\xE3\xF6\x1C\x81q\xA1+\xBF\xCD\x95&F\x11\xDA\x9A\xBB\xD9\xCAw8\x0F\x01\xB7pE\xBE\xFB@\x9CIFt\xEA\xE5\xA7n\x8A\xB3\xFF\xA3/\x9EAz\xA0~\x83\xAFFE\xB5Z\x80\xB8\x05\x13\x15#\xDC\f\x90\xFC\"R\xF6\xDAL}a\xE0f\x8B \x13\x9F\x94\x8F\xE5{4w\xB3\xA0\x82\x9F\xAC2\xF5{F\xDD\xCAa7\xD3\xC1\x02\x7F\xFF\xC5\xBE\xB6\xA5\xEB\xF4\xB1S\xF2\xFEl\xBAx\xAB\x1B\"Fy\xF4`\x87Z\xC1\xED'\x89;X\x83?b\xA1\\\xBCP\xD5_H\xBB\x97\fJZX\xA9\x88\x80\x7F\x87\x1Bm\xD6\\\xFCi\xD7I\x8F\xE6\x8A\x8C\xB2\xDB\xDB\xFA\xB9\xD6$\x13#\xCB\xBB\x13\xE8\\\xEE\x8E\xDF\xE5\xF5#\xD8\xCE\xFDS\x91\x9B-\xBF\x8B?\x7F\x16\x9F\x1C\x91\xE3W\x8By\x8A\x8EU\xA9^\x9A3w\x88\xFB\xBE\xF7d\xF3\x11\xA4\x9F\xAC\x7F1\xD7\x9C\x97_]\x86\xC6\xEF\xAE\\\xA0n\xAC\x17\xA8{G\x12,3W\x18\xB8\xA6\xF1\xCBeI\xE1\xE2\xF1\xD4\xA7\x82\x16\x90\xDE-t\x1Dw\xB2Y\xFE\x8A\x1CLe\x96\xF6\xE9\x03uoO\xE4\x0E\xC4\x0F\x8DK\xBDv\xB3\x93d\xA2\xE4\xB7<z\xB0=\x8C\x02\x1F\xA3\x1A8\xFE\xA9O\x88C,W~M\xE4v\xFD\x18w\xFE@\xC5R%\x8Fjt+\xB9\xB7\xC9S\x95'\x94\xA7\x95\xE4'\xFB\x13\xAF\x18;\x82p\xD4\xC5\xDF\x8AQ\x13\xAD\xF0WF\xBC\xF8\xF3\xC3\x1D\xBF\xAC\xD13\xE5\x15u\xCBO\xDD4\x7F\xC4v\xD6\xC7Pv\xF0\x06\xDB~)\xAF\xDC\x02\xA4\xFF4\xCB\x9C\xED\xA2\x8E\xEE\xCA\xC8\xCF\xA9\x00\x90\x93\xB4,\xEE\xC5\xD7\xA9\xF2\xF9wF\xB7\b$F\x84\x91\x9A_W\xB4\x85\xDE\xDBr\v)\xA3\xAC\xCB\xEA2\xCA\xA4i\xAF\xBDD\t\xE3\xC9\xBC\x07(\x96J'\x94\xFE\v\x9A\xF9\xC5\x13}\xE2\xDFnTs\xF2<\xC9\xEF\x9Ah$\x0F\xF0|v\xB9S\x9C\x1D1\x9E\xD7\x7F\xE8\x97\f(\x9AP\xA9\xFCO\x1E\xCA\xB0!y\x8D\xE8\xEE\x14f\xFB]k\xBD:\x94\xC5~\x1E\x9C\xEE\x88\x8E\xB0\xFC\n\xE9,\xA2\x1C\xEC6\xC7\x8CO\xB8\x99\x9F\xB2\xAE\xF3\xF5\xFF\x03\xD4Pw\xA7\x89e\xDF\xB5nl\xFAO*\xA13F\xDD\x87Z\xE0gfK\xB9_\xBC;\xBFBS\xA4\xB3\xC0sN\x11\xD41#BR-\xFA\x15\xD5\xE4\xC5\xEC}\x805\xCB\xF3SLHep\xCE~\xE5gS\xEF\xCE~\xF9\x01y\xAAug\xF2\xEA\x8B\xD8\xD3\xA6+\xD6\xC8\xFAR\x85\xFA\xEFe\xA1\xFF\x1A\xB1\xC9D\xB7\xF4\xAE\x92\xFE\x13\xE37+\x13X\xE5/\x9C\xF1{\x15umT\xFA\xAFM*\xC6M\tE\x00\xDF?f\xEA\xB6\xBC\xC6\xA6\x87\x13\xA8\f\xB8P\xBBz\xAC\x17\xA3\xBCt\xD5\xC0\x87\xB9\xEE\xCE\xBF\xA54\x7F\xE8oH\x97G\xBE\x9B~\x91\xFA\xB4\x83\x9C\xD7%?b&\"\x11\xB3}\x9D\x9341\x02\x94\x8C\xC0\x86q_\xD8\xA6&\xE30\xB8\xBC\xCDW\xF2\xD5\x9CU2\n\xB4\xE8\x16\x85?nG.P\r\x9D\xBB#\xEE!\x11\xD2\xBB\x06\x87\x1DY\xDE\x18IG\xD6}Z\x8E\xFD\x7F\xB8\xD6\x8D\xF4\xCB\xF1\x1B^U}\x87\xAA\xF6D\xF9pJ\xFF\x95\x00\xBE\xD6&\x84G\x90E\xB52\x10\xEE!fNN1\xB5\xE6\xDB5:\xCAF(p+\xAB\xACl\x97\xEE\xCA\xF2\x84\xCANh|\xCC\xD4\x8CZ\xA5\xFFR\xA8]\xEE\xCAoyQ;\xAE\x85\xBF2\xFA\xB1\x91\v\\\xFB\xCFo\xD3\x03\xD2=N\x02%\x8E\xF1\xB6\xE1\x1D\xD9\xA0\xF2~*\xC7\x86KJL\x1C\xBF|\xD5\xCE\x91\xBFP\xCBh\xC5\x88\x82\xBE\x04\xEB\xEE|p\xC9sG>\xB7\x12X\xD7.\xC7\xEF\x92R\x15\x84U\x99\xC6!\x0E\xED\x9D}\xB2\xF3R\xE8\xEC\x92\xE7\x8E\xB4\x03\xC7\xD7\xB5k\xB9\xE7\xB8s\xC8s<0)N\xA0/yn\xFFh;\x9ES\x8AQg\xB7\xE6\xCD\x0F\xEA\r\x1D\xFE\x87\x1F\xD4>\xA7\xA4\x91\xCD\xCBo==\x07\x96\x89\x1BZ+]>\xDA\r\xD4\xA5\xF7\x1A\x95\xBA\x06o\xBD\xC8\xF2\x84^\n\xE4\xCBf\xF9\xA5\xFD'\x85\xB6\xED\xD1\x8C\xD6!\xAF\xB1\xE2\xD4\x06<\x97\xF7\xC0-}k\x1Fn\xE5\xBE\xA9Z\xAF)\xEE\xCBG\x06\xF4\xD2\xF3\xFC\xEB\xFC\xF6\xC7\xA6\xBF\xC6\xDC\x80\xAF\xE6\xF5\x01>\xB0pLx\xB1\x8D\xCD'\x86\x8BE\x87\xDD\x9F\xFC\xE1\x8Bo{\x17\xFCv\xF5\xEFr(\xB5H>\xAE\x8E\xE3\x9E\x15\xC8\x8B\x84\xC5\xC9m~\xCE\x87\xD6L'O\xCBM\xFCDe>c\xCB\x9F\xDD\xBB\x9DC\xAB\x95\x16\xD9\x8A\x04\xC5{\xE4\x0FUjb\x85S+g\x1BYnR\xEB\x19\xA6t\xE7\xCF\xDB\xFC\xAE\x1A\xF6\xB9\x05\x95\x99\xE9\xF0\xD5y7\xD7\xB1\xF0M\xE7\xEB\x90\xFA\xBD1\xEB\xAAsV$\xDB\xF6\xE8h\v\x10\xEE6U\x07\xFB0\xD7\xFE\xB6A\xC6]\xE6\x9FJ0\xE6!i@.X\x05\xCB\xFFO*\xD6Q\x91QZ\xD4\x13\xDFZn\xB9\x19\x83\xFE\xAD\xFF\xAB\x99C\x8B\xB4\xE4\x0F)W*\\\xD9\xF8\xCB}v\xDE\xEAC\x9B\x8C_zL\xDD9\xD75\v$\xE9S\xE1\xE0-\x8B\xBC\xDC\xE0\xC2\xDF\xE7\xDF\x82\xBF\xDAS\x1E\xE97\xE7\xC4_s_\x97\xB8\xABSG\xF1\xEF\x96\x8A\xBB\x94u\xCA\x15\xC8*\xB7\xB1\xAD0\xBF\xD3>\xD7sliu\xE4\xAC\x9F\xF08\x9C\xA5\xA9\xE7<d\x96\x87\xA6Zr\x82M\xFCF\xF6\xD7\xE0\x1E\xBA\xF9\xAA\xFA\xD9\x9B\xCER+z\x04\x19?\x17\xC4f\xD3B\xC32\xBF\xBA:\x14s\f4\xD6\x8E\xF7\x17\xA9\x14\xF2\xCE\xC2\xA2\xC8\xD7\x11\x0E\x9D}>\xFF\xF5\xCD\xE7\xC4\xDFo\x87O\xB7\x00\x9Bjb\xB8\x99\xE4\xBC\x19\xFA\xAFOr\xEF\x1Am\xCF\xD2dl\xB4\xF4we*\xDC\xC6\x05\x9F\xE3\x7F\xABXy\x85\x13\xBD\xF1\xE0o\x95\x07\x7F[\xB6o\x15\x83\xBC%?\xC4\xCB\x13\x05\xC6\xF2\xF2\xCB\x8Fx\xF0w\x9B\xF4\xBA\x14\xDF\r\\\xB8\xE0{\v\x17`\x88\xB2b\x96\x1CA\xEB\"\xF8\x8B-2~]\x86\xEA\xF7\x0E\xF1\x9B\xCE\xA9\xA9\xB6\xF5u\v4\xFD\xFDQ%\xE7\xE5\x19\xAD\xB1\xD3k,\x1E\xFC\x84\xE7\xE82K\\\xDC?\xA9\x94\xD6\xA2\xF8+OhM.b1'S\xE7V\xEE\x9F\xBAV\x8C_\x95\xF5|!\xF7\xC8O\xDD\xF8\x8A\xA4\xFA=\x1Dr\x8B\xC4\x1F\xE55'\xCE=\xF2b\xCE\xBF\xC1\x98\"\xBC\xFF!\xFD\xE7\x89*\xDDx\xEE\xC9\xA3\xEC\xBE\x14\xB0\xBC*\xA6\x04v!\xD7\xFE\x96\xB8\xFD\xED\x8A,OY\x05\xE3\x978\xB6\x05\\\xB8\xE0sL9\xFA\xCFr\xD6\x86W\x15\x86\x8E \x8B8Y\xFB\x1F\xE7`I\xB9h\x94Z\xF5\xAEV\xEB\x7FUg\xD2*\xE5\xB9\x93]b\x1E\x1Bv#?\x97-t\xDD\xFC\xEA\xEAb'\x93C\x1C\xBCH)\xA7\xC5J<\x05\xDC\xB7\x10\xEC\x19\xCA\x7F}\xD99\xF1\xB7\xFF\xC9\x89,\x10?\x98\xC5e#\x92^\xB3\xDB\xA83\x8BS#\x80y\xDFV4\xC1\x12\xF2B\v\xCE\xEA\x81\xB8\xCA\xFE\x8E[N\x9E\xEA\xD5.\xFE\xDCz\xE1\x13<4\xD5<\xC1\xA1\x0FM\xA8T\x15\xC1%-O\b\f\xD8\xDC\x10\xCE\x07\xBEpVv\x83bBo,4~K\xDD'/mq\xD4!\v\x17\x14\xA0\xF0\xEA\xBF\xA1E\xF4\x9F\x1Bd.=;\xE0\xD5Y\xE7\x92\xDF\xC4\xD1\xB5)\xE0\xAA\x1BzU\x99\x89\r\\\xFF\xDE\x84\xAB\xB8\x85\xFE;Y\x10~\xA4\xC5'M\x8B\x9C5\xF4Y\xF5\xF8\x97\xBB\xE3\xD7m3\x9DO\xCC\xFD\v\xF8\xB6\xDCx\x13\xA0\xDD!'H\x82\xB2C\xA1TC\xA1\x15\xDFTr\xA2\x16D-{$\xA5\xCB,6\xEF\xDB\x85\xF3oJ\x1E\xDC\xB0\x88\xFE\xBBc\x91\xF1\xEB&$\xFAv_\xF2\xFB\xEA\xBF\xE6\xBE\x03Y\xE0\xC2\xC6v|R\xB6\xCA\xB2\xB4\xDB>N;\x94\xFE\xFB\x86\xB7<\xD4rS\x8BK\xFBe\xE1\xF1[\xADV7|\xC8t\xEC\x17w\xE1\x1E\xD69\xAF\xF7z\xEE\xDF\x87[\x00\xED\xB2O\xC8\x88\x04\xB50n/x\xB6\xA5\x97\xAF\xF4\xE8\xBF\x1B\x8F\xB4;L\xF8\x92\x85\xF0\x97\x0F\xC3PY/Z\xB3R\xB2rQ\xFDw\xD9\"\xF6K~\xA1\xF9\xD4\x1D\xBF\xAF\xCD\xBD}\xEF\xA7m`\xE9\x01'\xF5\xFCBS\xFB\xE8]\xA4\xB3\x95\xFE\xAB\xF6\x8E\xDF\xE5\x19\xED\x16\x99j\xB1l\xA1\xF9\xD7\xFF\xD7w\x9D\xE7^\xE7\xB7?\x91-\x9CX\x88\xDC\x9A\x8B\xFD\xBB\xE8\x0E\xAE\xC2\x97\x8BPF3\xEC\rl\xCA\x1E\xC3\x9E\xEBF\xDC.w\xA4Z\x0F\xE6\xCF\xCF\xD4\xCFL\xB7\xD1.\x85\x8D\xC5\xBF\xDC\xFDN\xFE\xEBFP\xB9\x1BF\xE5\xF9\xFAZ\x14\xB8\x96?\x83\xBBD\xC1P\x11m\xEF\x99\x9D\fguz\xCF!L\xC6\x84\xB9CS\xE1\xA4v\x86\xB9c\xE6\xE5\xDD\xBD^\xCDez>m\x97\x953J\x8F:DV\xEE8Jk\xA6\x8C9\xA6\x1Fy\xF2\xA7\xEB\xB8\x90_Q\xD6\x1Cg2}T\x9B\x99\xDD=\x9A\x90\x1D\x84\xA4\xFC\xEA2\xE8\xA5\xCAM\x9F\x15\xF3\xF4\xEC\xC8\xE2\xF2Sa\xC0E\xE57\xCB\x17\x91\x9F\xD8\xB1\x98\xFC\xA4E\xB1\xA0\xFCf9v\xE5\xE6\xC9\x8F9\xF2\xDB\x94\x90\x16cs\xE3\x82F\xD6\x1C\xCD\xEFw\xD7\x0ES\xC0\xC3C\x06\xC6)J\xD31\xA7\x14\n=U\xD0\xC7\xF5\xDC,\xF7\xAF\xCA\xD5\xEC\xCF\xC8\xFB6\x97\xD7\xD6d\xA9z\x974\x87g\x13\xA6\x9E\xA3\xD4\xC9\x9B\xC1L\x99\xA9g\xB8\x8D\xFAd\x00Y\xB5\xF1c\fu\xE3\xC59\xEA\xDB\xAC\xBE\v\x89O\x8E/\x83s\xA7\x06\x04}7\xEB&\xE2r.\x8F;\x9B\x93\xE9\xC6\x92\xBF\xC9R_Tp\x83\x92\x83\xCE\xE6T+f\xE7\xF4\xFD<4\x9D\x94\v\x89\xC4\x0E&S\xA0X\xB12bVLJ{\xE8\xA4\xB7*W\xA8\xB0cH\xFE\xDF\x90!\xAF\xFB\x1B\x19\xCD\xC8\x93\xD1R\x9B\xEE9='_\xCA\xA7\t\xAB\xC7\xC80f\xC2\xE85\xAB\x99E\x89\x13z\xEE#e)\x83\xD8\xB64\x93\x9B\x873Z3\xAA\x12\xE2\x89\xF4,>6\"\xE5\xC7\x18L\x93\xB1\xAE\x84\xC9\"<a\xB2\x06\xE9W2WGX2\x19\v2\xF1]DX\xB4=| \xAEl\xB1\xA0SC(\x92L7\x19\xE0\x07T\xE6h\xCFZ\x04\x83=\xFD\x89\xEA`\x10\xB1\x84\xAA\"\xD3\xC5\x03\xCD\xE9\xA4Z\xC2\xC7\x9AaV7\xC7\x11K\x19\xE8~*\x9D\x8E\xF4\xA7\x13\xAC\xA1\x13\x86\x9DMSM\x9DX\xBAI\xC2[\xB0w\x85\x13\xF2\xF8\v\xC6\xB2eq\xFCy<O\x93h\xE5y\xFCy(Y\x86\"{\x1Dy\x07\x8ETF\xAC\x1D\x88T\x98\xC8\xD6\xC0(\xCE\xDD\xC8\xB8\x1C)\x037\x97\xBC8NLS\x9A\x92\xF7|\x03\xAC\x1FW\x12|\xFC1\xFC\x8D\x1A\x88\xAC\vu\x9CM3\x1F`\xD62\x19/\xD4\xDAP\xF1\x9C\x99\x1D\xDA\xFF\xC2\xAF^\xAD\xA5\xF4G\x04\xE3\xD3\x9Duo\x8F;\x11\xAC\xE2q\nc\xCD\xD4\xB2\x07&\xD1\xE9t\x84\xE9]\x8F\xE2/\xCED\xEA\xC6n:A\xBE?\n\xFC\x0F\xA2h2\x1B\x81[\xE9v\xC5\v\xEF5\xA1&=\x89\xE1\xBD\xAB\xDFk\xEBd`=\x11\x84\xCE&j\x01\xED\x9FQWt7\x984\xFC\xB5\x80\x17\x7Fe\xA6\x16\xBF\xC5\x83\xBF9nMO\x004\x86\x8F{\xF4_\xDE\x18\xF3\x1F\xA54\xE7r|\xA0\x80\xF2\xCC\xEE\xE2@\xA4\xB2\x1D\xE1z\xE8\xA3e7S\x14\x19\xD0\xEE\xB9\xF9\xCA\x84\x05\\\xCC59k\xAC\x18\xCCh3\xA8\xCA\x00\xB5(:*\v\xB4p\x0E\xEC\x83\x10\x9D\x1C\xA6\xCCM}\xF6-1a\x96Y;\xDB\"R\xFF\xF9-;l48\x11,hR8f\xA4\xE2\xB8\rk\x85\xB2\xF9;\xB6\x80-\x8B\xCE\xF65\xDB\x97R&*\x05\x0EG\xA1Y\xA9Yg\x95\xBD\x8Du\xF5\xD7|\x0F\xC6\xC3a\x9C\xBA\xEC\x8EdCy]\x06\xAF\xD4\xC2\xDF\x92}\x9D\x03i,\x1FM\t\xF5eRxY\xE9;\x8A\xD8U[\xAC6\xB1\xA0\xAB\xC9\t{\xE6\x81I\xDC\xF7\x93\xD2\x9B\x97\xC7i`\x9Cz\xEEv\xA0\xAA`\xC1 \xC5\xB6\xA6\xC5S\x1E\x07,\xF3\x94\xC1\xE9NY\xF8\x1F\xA9O\xC3\x07M]\x1A\xAE\x91\xA4\x8909A}(Q\xF5-\x84\xFC2\xD4\xE4\x8F\x19\x9C\x84\b\xAA\x8D{7B/l\xCD\xD5U\x1C\x7F\xEF\xE7\xB5\x15#\xD4\xE6|\xC4\x8ET\xFCH)\x8E\xFFK((\xA9\xFFz\xAF\x7F\t\x9D\xB6\xC4\x85\xDE0\xCBC\xFFcF\xAB\xF8\xD1\xAF\xCE\xD0\x02\r\x1AouB\xFF\x19\xCE\xA2\xD8,*FM\xA0\xE2GYT\x05v\xBD6S\x1B\xE4\xB0#\b\xAEy\xB8\x96\xEAL\n\x9D\x1DQ\xC4s\x8D\x17\x7Fu\x19=\xED\xD5\x7F\xAC\xB0\xEEoi\xCA\xA3\xE6\xFEU\x1C\xF7\xBA\xD2\x7F.0K\x8F*\xFD\xF7\x919\xE3W\bG\xC0g\xBB\xB8\xD3\x86\nY\xBDZ\xCF\xB5\x91\xBE/\xB3\x94\x07|\x9A\x10\xB6\x99\xD4\xBA?\x8B\xCE\x11\xD7*\xDA\x04=\xD7`p\xDC)\x06:\x11\xDE\xE3\xD8P\xDFdV\x965t}\"\xC28Z\x80\xD2\r\xD9\xCE\x98J\xB0E\xAB\xA07\xE2\xACve\xC5\x8F\xDAqP\xC5R\xB5\x8E8XK\xDB\x17\xCB\xAE\xDFy}\x1E\x7Fo\x80\xB5Fj\x9C\xF9\xD7F\xF9\xB6\xB39D\x0F\xF7b\xF6{wT\xB6\xFD\xD3\xFE\x11\xE4j\xB9>\xFA\xF9\xE5\xB4\xB7j\xD4\x84c\x05\x18\xDD\xCA\xD9@\xCB\x8CL\xAD\xA3\xD9#\xBF9M\xC2\xFC\xBD\x1E\xFDG\xBCg\x93\xC7\x07%\x0FI\xE06\x0E\xED\xD3\xF8@b\xBE\xFC\xBAdf\x177\xFF\xBC\x12\xB2\xFA\xB7\xB9\xBDK\xE0o)\xD7\xA4\x0F9:`\xC1D\xC8\x12\xB3\x86\xBF)\x1F\xBC\xED\x16\x16\x93\x19\t\x01\x03\xD1^\x8B\x12'\xF4Z\x18\xD7LE+\xCB\xAE\xE1}\x11f\xA9\xE0\xB8\x11rR\x8D\xF6r_\x98\x84c\xD7\x86\xAF\xBF\x15O(\xFD\xA75lA\xF1\xBA\xBE-\xA1\xEEGZ)\xBE@\xF8;\x84\vz\xA67\xA8E%\x98\xC6\x87\xBA*\xA3\xF0\xF5\xB4\xE3\xA0\xB6\xEB\xF5\\|}\xBB\xC6^\xE7\xBEG\x97\x8C\x12:7\xEB\x190\xA9\xDC|\xBB\x1B\v=^\xC6\r\x1E\xF9\x95\xAC,\xB4_\xDC2\xFCE\x86\xA4\xDC?\xE2\xC5\xB7\x168\xE3\x96\x9C\xC0g9\xB4\x8DXQ\xA0:W.\x01\xF0\xA9\xFB\x81\xF6?\x87\xC6\xDB\xFFi\x97z\xD3\xED\x99\xFB5\x0E|\xB4]\x97\xC4\xFD\xD3O\x8D\xA0\x1D\x1F\x1E\x01V\xE2\x02O\x15\xAD\x191~\xDB\x97\xAC\xCB\xE8\x91\x17\x12\xA6\xF6y\xA5^F\xD8\x1Du\x15\xFF\xF0\xA5K\x85b\\\x02\xE8\xAF\xE7f\xEDk\\[\xAAh\x92\xF0\x97}\xAE\xF79\x8E\x0F\xEE\xE1\xAE?1\xF8\xE2\xA5_Z\xF7Wg:P\x91Q\xF8{\x9A\xE3\x8E%/8\x8B\xC1Kq\xC9\xE7.\xBE\x03\x17=\xB8\x0F\x83\x97\x96\xAC4\x7F\xB2\x7F\x84\xDDB]\xC6\xAE\xE2\xD0\x97\xA0\xEA\x9D\x95(\x85&4\x94q\xF1\xE5\xE7\xB9\xD7\xF9\xED\x8F\xBB\x99\\\xAE\xD35 \x13~zM\x87\x9E\b\xD6\xC0\xF3\x8Dx\xB8\x8C\x96\x9A\xF90\xAF\xF1\x1FX\xC1\xAE\xCD:\x03lNyx\xEE\xB6\xDA\xE5\x8Bw\x1E\x92\xC5T\xD9\xEF\x8A@\x1B\x9E8\xB6a\x990\x94\x92QK\x96\xC5\x0E\xF3\\Q\xDF|j\xB7{5\xA7c\xD2\xAA\x11\xB5G\xAEV\x86arXv\xD5\xF4\xE3Fm\xA4~\x06\xC1\xCBM\xAF\xFC\xD6\xB7\xAB\xD34\x13!\x97\r[\xF3\xF2s\xA6\x89\xCE\xFD/\xBC\x97\xEB\xDC\xFF\xC2T\xAE\xB3\x82\x96\x0F\xBD\x99E'/\x9A\xCA\xA1\xE2\xCD\xA9\xDC\xEC\xFE\x8C\x96#u#n]#\xD1u\x0E\x8F\x19\xE8t\x17\xCB\x11-UR3lY\xE6z\xA1\x8D\xEC\x90\x88x\xD1s\v[\xB9\x94\xA7&i\xC2\x969\x9F\x01\x133\b\x8C\x9AC6/\x9A\x1C\xAA\xE3\xCC\x94'@\x00,\xB2\xF0\xFBq}\x19\xEE\xA7\xDAd\xA4E\xEC`\x91\xD5tq\x8B\xDE\x8A\x9E\xED\x95\x07\vs&\xFB\xECXOr\xF6\x9B\xA7\xB3>\xC4\xBF\x91u\xE4'^\x19s&\x87i7I\xBD*\x7F\xBB\x9B\x1C\xF9Y]\x8DK\x99\xD5\xDB\x18`\xF5\x94\xB4\x1C\x8E\x1A\xB0\xB8/\xC0\x10\x8E\x06\x18\xEF55\x06\xB5\xA6G\xE0\xCFg\xC0J\xAC\xCE\xC2J8(\xE0\xDCx0\xE7\x91_qfa\xF9\x91}U'\xC4^?w\x189\xA7\x8A\rg`\xC7\xD5\xCA:q\xD3\rVr\x96k\xD6\x00%\x7FI\x03-h.\"?\xF7\xBA\xAB\xF68\x9F\xE2\xC9\x88-\x97\xB8R>\xDD\xAA\x11ZS\xC4\xCC\xA4\xACQ\x1D\x18\xEB\xC5\x1E{\xEDM?\xDFR[uS\x0Eu\xEF<\x12E\x99\x85\x1C\xCD8\xA8\x1BU\"\xBA\x81;\xE58ry\xFC\xB9\x16\x8E5<\xB64\xD7\xD9{\xDD\xEF\x83\xBF\x88\xC2\xDF\xA9\x96\x02\xFC\x19\xB6\xA9\x14\x880*\xCF9\xAF\x116\xE6\xF6vr{v\x0Er\xB0!Y6u\x1DG\x0E\xF1\xE6\xE9!\x80E\x06\xD2<\xE8TJ\xAFY\xACrd\xCC9k\xF2r\xE7|\xE9\xBA\t!\xC5\x11t\x13r\xD2\x169\xA2\x82\xD9\x9C<\xB8v\xF5$\xB2\xC3UHu\x9A\x97\xDD\xDD\x87\xB2\xA8\x90\x9F\xE9\x94\x001k\x94\x96\xBA\x87k\xAAy\xF8\x8D\x1E\xFC9W\xEB\xEC\xBA\xEE=\xB3\xA5\xE2\xF9\xFA\xB0EI{K}&\x1A\xE1\xABlD\xD8\x7Fcc\xF2\"Skp\xC3&_ *xm\xF5uYl\xA9v\xEE{\x80\x1B\xBB\xA3J~pRO\x17\xC2\x1F=\x9B`cs\xB3C\xDC\xEA\xAD\xA9\xE1\fK\x0F\xAA\f\r\xD8\x88O\xF4\ft\xF2\v~9t\b\xC1\x84j\x86\x15\x9F\xDF\xFFC\r~7\xF2\x98vKq\xDB=w\v\xC1j;\x0ESi[\x89\xBF`\xBA_\x16\xD2\rD{\xF1Pr \xDCo<\x1B]\xF6*\xEA\xD6LE\x10\x91\xDC\x83\x035)\xC3\xD1\x7F\x9A%\xEB,\xB4\xE6\x15E\xD4\x91\x9F\xC5\x1A\xEBgn*\x7F`\xEA\xE5\xCE~q\xD2\x8A7\xB2h\xE3\xFE\xA9\x19T\x8C\xD5\xE7\xFEu\xAF\xA5ux\xF1\xE7\x9FT\xF8\xFB\xB6s\xBB\xC3\bME=\xF8\x8B-23\xD1\xA8\x1B\x16\xC3\xBEr1\xFD\x97\xEAv;\xEF\x84\x85a\x1DO\xF7\fY\x00\x1BH\n\xF9mQ\xF2[\xA4yU\xCCy\v\t\xF7\x0E\xD2u\x136\xBD\xD0\x81\xA7\xBD\xF8\x9B~C\xCA\xAFv0\x8B\xE9\xA1\xD5gs\xB3\xF6`\xD6\x80\x91\x88D\xB0\xC4\xC2>\xF5\x1C\x87\xC6\x1D\xFD\xA7Y\xD2-\xDC\xE2\xD6\xCFq\x92i\x01\xAB\xE2\xF9\x86\xE8'\xCA\x1A\x1B\xDA\xDA\xBE\"\xDE\xDB\xD2%1l\xE7\xFE\xEA2\x94=0\x15\xED\xAA\xC8\x14\xE2\xCFg\xA1\xE9\xC0uY\f<\xE1\xDC\xEE^\x18\xBBg\x94\xFC\x04\x9B\xAB^d\xE8R{\xBE\xD4\xFE\x11\xE0\xC5\xB9\x92uN5\xB8g\xC4\x19\xBFe\xA6\x9EC<==\xD0\xC9\xF5\xD1d\x12\xB2\x96\xF79\xE0\xED\xC1\xDF\xA0\xF3\xE9\xB0\xFD\xA0\x90\xB8\xA9\xDFC\xA0>;B\x86C0\xFDu\\A\x0E63\x8CX\xFF\xE7\xCA\xBA\xB5\xB8\xB9*\x87\xDA\x9A\xE9\b\xC0\xC9\xA3\xC4U\x9Dh\xB1=\xC5Y\x93L\xA8\x95\xE3\x97\x12/\x02\xAE\xFC\x98/\x12\xED5WO\xDF\xDAF\x99\xDB\xAB'\xB2\xE8F`\xFA^\xC4\xC7\x8F\xE7\xFE\"e\xB2\x0E\xE7\xD6\x94\xFE\xDB\x7Fx,\x83\xE1G]\xFCq\xEC4=\xF2\x8B/b^\xDC(\x1D\xFB\xD6\xFC5]qG_\xA5\x8EZ\xCE\xF8e\xC2\xCA\x88\xA7{\x06\x1A\x81\xE4\xB1A\x1E\xB4]\xFC\xCD\xEB?3\x07\x7FI\x17\x7F?\xA8MgI\xE2&y)\x19g\xE2\xD2\xC5\xC7\xC6\xE4 1\"a4\r\xF8\xCB\x9E\xAF\x8CGL\x1BF\xC44\xA1\x93+Vo\x07\xCC\xCF*\xFC\xED\x02k\x92\xE3\xB5/\x9Fb\x14w\xE4\xC7}F\xB8\xB1\xF7\t\xC3\xEA\xFF:u\xD5\x8D\xC6\r\f\xF0@<\x8C\xE8\xEE\xD6\xE8\x8Fk2,\xEA\fv\xD6\x00\x18MH\xED\xDA}\x04K?<\xE2\x06\xEA5D\x94\xFC\xC4\xFD\xD5.\"\xBF\x87%\xDF\xE7\xCA\x92\xF1\"\xC7\x91\xDF\xB8m\xE9\x13\xD3\n\x93Z\x19jO?8:\xCC\xB1k\xE4\fB\xB6\xC2\xDF\xA6\xC5\xF4\x9F\x9B+t\xF6\x07n\x0E\x81\xFD3[\xDC\x90ZbS2B)\x14\xA5\x9F\xDA'\x13\tj\xFFr\x1D\xFE\xEE\xC9\xB1\xA7\x9FZ\xB6\xF2/\xDBoE\xED_\xB6\xB7\xE3\x12\xE0n\xC5\x7F\x8D\x95\x0E\x07-\xD9\x01\xE2\x88\x94\xF2\x80\x0F\n\xE4\xC4\x1D7\x15_i\x04\xEE\xAF\xD8i\x7Fq\xFD.\xAAV]\xF4z\x16u\\\xCB\xE6\xB0r\xB4\xE9\xF9\xBF\xB0M\x1C\xF7\xE4\f 0\x8E\xD03\xED@\x85\x1BZ}\x96/A\xAD\xD2a%w\xCF\xF3]\xB8\xDB\xDF\x88\x8B_\xF4\xC0\x02]9M\xE7\xF4\x15{FP\xCB\x94N\xD4\xC44\x9B\xDD\xD8-\x1E\x949}K\x85\x02Y\x04\x7F\x9As\x16\xB6\xC4\xB9\xB5K\xBEff)G\xCCY\xFD\x18:\"\x0E\xDC\xF7\x19,1\xCF\xB3\xAF\xF3\xDB\x9F\n\rV\xFC\xD0R\xB56\f\xC5H\xCD\xC2\x10\xAF\x16\x05\xFB\x03\xCEj`~\x1D8c>_\xA5\xEF\xA2X\xB8\x0F\x91\x99\xFF\x85\xB1\xD0\xF9h\xDB\xE6Y:l\xD8s\xF2\x9A\xCD\b_\x84T\xE7\x03\x9B\xF3\xE2\xDF\xBEG\xA2\xDE\x1Cn\xCD\xE3M\xA6pCc\xC1/\x88\xCF\xB0\b\x02gLi\v\xD8\x0F\x8E\xF7DVG\"\xE6\x90\xDA\xCB\xE4\xB2\x87\x19\x8F\x95\xFB;\xB7!\x9B\xB3,l^\xA0\xCE\xE6j~\xBA\x1A\x97wE\x17z\xA5P\xBC\x92\xB4R\x88\xB8\x97~;\xF7\x04!\x8B\x8A\x8DY\x9E\xC0C\x04\xF9\xF5V`\x91\x9A\x11\xC3Fu\xB2\xF0\xC6\x03\x19\xC0\x96\xDF\xF9_\x8EH\xDEH\xF3cY\xA4\t\x88\x1C4\r!\xBF\x8ENY\xFEP3\x81\nb\xF9\x94\xD8\v-\x86\xCD\x99\xFC\x8D\xE8\xB2\x80>\x8Ck\x9CBL=\xDB\xCE\xE6b\xC3\xAFg\x93j\xAF\xB3rr~1\x87\xC5\xB7\xF4,g)\xB5V\xB5\x90\xC3\xCE\xB1|\xC5w9\xE7BM\x05\xBBu\xC9\x1B\xA9\x10\xD33\xB3|\x81\x13\x04\xDA\x81\xED\x9Ev\x7F\xFE\x16\xD4qf{\x9E-.\xD8\xE7\xDA\xE1\xC2\x1B\x0FZp\x02\xC3\xC15\xF9\xD5qJ~eO\xBE7\x83\x8A\x9F\x9D\xED\xB5$:i\xAF\xB5\x945\xF6\xAA8S/|5\xD9yI\x18k\xEEj!\xBB\x1D\x91\xF8\x98\x85#FOdH!\xB6X\x16\xF4\xB9\xE4\x0F\x18\xBDl\xC8'l\xD6\xFA\xC2P\xD4B\xE3w\x8B\xEA\xB9+.\x14,\xC4_\xB0\x17\x03\xAA\xEB\f\x1B\xA8\xC4\xFC\xD63d\xC7nA\xB0\xD7\x83\xBF\xA4\xAA\xDF$/\xE0\xFB\x96\xE57\xF1\x83\xB45\xCFV\xDE\";6\xF8_J;\x01F-\x8A\xB2x\x13\xE0o|$\n\xC6\xB4p\xA7\n,\x89\x8B6.e\x8D\n\x7Fz\x0E\x9B\xC7\xEDy\xF8\x8B\xFF\xD2\x965f:\xD3\xD7\x9D\xCD\r\xEE\x7Fq:\xE5\xB4\xFF\x94\v\x9C\x07(\xC0\xF3{\xCA/\xF1\x15\x1EL\xA1\xD3]5\xBD(\xFE:U_#q\x1B\xC1\xC2\xC5\x1D\xC5\x84?v\x98\x9A\xAB\xD2\xD2\xD0\x1F\xCC5\x9DM\xE0\x17<\xDF\xF7\x86\x99\x18\xE4\x1E\x0F\x98\x9EK\xC1\xC8\xE2po\xE1\x8D\xC7=\xF8\x8B\xBF\xEB\xE0\x8F5\xA1l\xCD\x9D\x80\xFF\xBA\xF7f\x84\xFC.\xAD\x97\xF2\xA3\xF5\xF6/\xBC\x97k\xECU\xD1\x87&T\x1Ay\xF9\xC9\xD8q\x14\xF1\xADY\x89\xBF\xE7\xD7\x8C5\xF4$\xCCx2\xAD\xD4\x92*\b\xD7:\xA7\xCF\xCA\xB9\xF17\xCD\x83Y\xDC\x9C_\x07\xE9r\xD89>7\x17\x7F\xD6|\xFC\xD9\xD4\x11:\x91\xC7\xDF\xCF\xF8|\xD2\xF5\x92G\xECE\x93Hz\xC2\xAD`=\x87x\xC8\xC6\xB7\x07\v\xF1'H\\\xFF\xC5\x84\xBF\v~\x99v\xD8\x94\x90_\xFC\x15`\xFD\x80\xC0\x9F\x7F*\"\xE4\xF7\x94\xC4_\xD8\xA7\xA1\xF3+\x19\xF4\xAB<\x8F\xF19\x15f\xF5\x1Cj'T'\xAE\xCE\xB8\xC4\xDF=C\x0E\xFE\x88\xC9\xE9\xBD\x7F\b\xFE\x92}<H\xFD\xDF\xF8\xEF\x81?G\xFF\x15\xDF97\xEE\xFC[\x85N6D\xFC\xF7\xE9\x05\xF0\xF7\xAF\x1E\xFC\x85\xB2\x9E\xEE\xCF\xE2\xA4\xE3\xBF\xB5`#\xBD\xCF\x9A\xC7\xF8fe\vn\x7Fk\xDA]\x9D\xAE\xC6o\xD9\xE0\xD9\x1C\x98\xAF>\xD2)\xC1%\xF6\n\xF9Y\xE5\t*>\xAD\x95\xC3\xB0\xE7\x8C_-\n\xED\xB6\x94\xF4\r5\xC6\xC7\x1A\"\xE9\xBD\xCD}\xB6*\xD7%_\xA8\x1E\xFD\x83\xF0wF\xC0\xF6^nx_\xD4\xDC\xB52\xB1\x04\xB0\x1C\xB2\xE7.z\x17\xC2_\x95\xA3\xFF(\xDE9\xB7u\x19\x01\xE9\xD7n\xC78\xC2j\x9A{\xF0\x87\xC3\xBA\x98?\x86\x17\xC2\x1FUX\x87\xFF\x7F\xE6\xA0\x94\x8C\x90\x9F\x98?\xC2,q'\x98Q/\xA6u\xB2\n,\x903\xD8Z\x9Da\x94;t\x06u\xE3\xF9*\xCA\xA4\"\xF5\x1C\xD8\xED\xE3\xA0\xF0c\xE3\xA6\xA6\x86\xF4\xEC\xFE\x9F~\x8AR\xACSnA\xCCM\x7F\x00\xFE\xF4\xD1\xBD(mB\xDF\xB9\xE5'\x98kT\x95\xEB\x17VV\xA8\x10\x7F!\xC2\x1F\xB5\x0E\xD0\xD3\xB4\xF2\xE0\xF8\x9C\x13\b\x1E\xBA\x94\xE7\xE3\xFB%\xFB\xF0[OT\x1FZ\xCAo\xF9[p\xEA\x82\xC4\xBC\x9F\xFD\xEA\xA2\x84\xB4\x18S@h\x9D\x9A\x7F#\xD1& V\xB2o\x00u\xE3\xD7t\xAB\xF9\xB7\xC4\x91\xDF\x00\xD0-\xA3\xD2\xCE\xF2gzgw8\x93\xF0J\xE0*1\xA2\xEE{{z:\xB8\xB7~_\xAD\x83\xCE\xF6\xB9\x9E\xCA\xDF\xBD\xD5f9\x1BG\x8E\x17\xCC\xBF_\xC2|\xE6\xFA\x82\xD3sW\\\xE8\x95\xB9\xF6s\xA5S\xEB\xEA\x96\xBDy\x06\x9E\xDFd\xC5m\xDD\xDB\xE5!\xC8\xB5\xFC\xF8e\x1D\x94\xB7\xBE\xF2\xFB\x857\xBE\xA4\x1D\xF8\xFA\x13\xAA\xC8\xCAz pB\xC9\xCF\x8C\x1A\xC0\xEA\x8C\x1E\x11\xC6\xD3Je\xFF\t\xF3\xA8\xE2\xCDl\xAE\xEE\x81\ff\xA4G`]\xFB\xF9\n\xD0\xE7\xB7?\xFA\xC6\xCD\x05Y\xAB\xC3\tM\x0FoT\v\xBB\xB4\x82\b\xAAf\x85]\x93\xF8\t7)\xB6k\xD1\xD0 d\x1B\x04\x98\xBD\xD1\x05y83\x1B\xE9\f>*\x8C%.\xE4S7c9\x81Wy\x13<L\xDF\xC9\x83\x1DOnX\x1E\x92\xBFgq\x9C/O\x12\x98\xF3\xBC>\xCD[}\xCA\xE5\xBFT\x8B\x8B\xD2~\xE5\xA9d\xF7&\xC3!\xCBn\xF4\xDBt3\xFC\xC4\xF9\x98*l\xF7)\x97\x19\xCA\xBD\xC1]\x19\xCBs/&w\x14\x8A\x06\xA4j$-\xF5\xB7\xF4\xC7\x9D\xE0_\x17\xE5\x80\xD7\xED\xC9(\xF9\xD5\xB8\xB4\xAA\xC6\xE0\xC8\xAF&J#4\x1Ay\xE9;s\x85W\xF4\xAB\x9C\xB9\xF95\xCB6\x96\x8E\xF0\xA1(\xF3\xF5\xFE\xFF+\xBF\xA2\x99\xFF\xA8\xFChE\x11\xC9o\x12\xA5\x7Fv\xFF(JW\r\x9D\xE6\xCC\xECV\xBD\x02$\xE7da\xC9\xCE\xA4\xF7W\xC8\xAF8S9\xE3!\xBCj\x89\x97n\xA3\"\xA3\xE7\x12\x9C\x8A\x9F\x84\xB2CNTU\x7Fw\x95 \xB2\xA6\xED\xAC\xEE\x8AIo7\x80\xEA\xBA\f\xF2\xED\xF3s\b~3\xFB\xF8j>\x7F,\xD4\xD9\\\x7F\xB5\xB3\xB6Rc\x8D\xF1\xD47r\xA8\xC8h9\xA5\xC2e\xC6\x82\xA6\"\x8F\x15\xA7\xA7\xE4wt\xF1NU\xE4b*'\x0F\xC9\xDF\xB38N\xED\xF5\xA5 \x93\x9Be\xCC\xFFt\xBEz\x97[\x1D&t\xD6\xC9\xB6\xA6\xD3CQ\x14\x03N\x87\x05\x13,s4\x02\x96MF@\xF2\x03\xB7d=(q*\xC9\rd\xFA|\xE8(P\xBBg\xCA\xE7\x19yN\xEB\xCB!\x94YH\r\xCA\xEB\xFAo\x1AK\xAA\x98\x12KM\x03z\xDF\xEC\x0FG\x94\x9B\x7F\x96;\v\xDE\xDE2x>\xE6\xAA\xA7\xB0\xE1\xE1G\xCF\xCC\xCC\x93\xDF\xCEh\xA3\xB1'k\x1Ba\x16i\xD8\xF3\xED\xB5?\xA0\xEA\xBC\xE1F\xC9Nd\xA2\xBF\xE3R\n\x07\xA8\x16z\x13\x1E\xC9GU\xE1{\xA4Qf\xA7\xE6uR\xD9\xEE\xCA\xB2F\xB5\xC2(\n\x98\x01\xD5\xC0\xB5\xA1,\x9Dr35\xC4wdq\x07\x82\xFD\x88\x82\xF1tU\xF3A\xA9^\xFA\x0E%\xD4\xEBI\xC69\xB3-\xF8*\x8Dm\xDCW\xBDq\x1Bg\xAB\xE8\r\n\xCEy\xA7\x8C<H \x95PXBP\xEB\x18/\xC0\x9F*\x01\xAE\xA7Q\x91A*!iU\xA0yHZ\xA11\xB0\xC3\x83\x1C,w0n\xA9\xDA\xD6)\xEE,\xB8\x1C\xDE?\xC2\\\xFC\xB14j&\xFA\xD2\xE9\xF9\xF8K\r\x1B;M{vx\xAC\xBE\xA1-=\xF0\xC8B\xF2s\xD6\xCD\xBE\xFD\xDE\xA5\x84\xBF\xE1\x02\xFC5\xCAC\xF2\x8B!\xCB\x07]\xFC\xF9\x9F\x02\xD6\x1E\xBCG.3\xDF\xBE\xFFm\x92\x9F\xFE\xEAo8\xD8\x04\x10\x10\xD6phz\x86\xF0\xF7\xCD\xE1\x7F\xFB\x1B\xF9\xBAgR\xA6t\xF6a\xF6\xBB\x19=7\x89\xD2\xAB\x87&x\xE8lz\x82\x87\xB2\xDD\x80ow\x1F\x10\xA4t;\xFD\t\x99\xC8\xFD!\xD3\x91\xDF\x9A\xD3S>\x8F\xC3OU\xC8bq\x94Yzn\x98\x13\xAD\nM\x0F\x18\xCA\xA0g\x03\xD4\xB1zx\xD0\xD1\x7F\x83.\x0FH\xF7Z\xEC\x98+\xBFi\xC4_<\xFB\xCE\xDBs\xC5\x17\xCA\x9A\xD1\xBA\xD7V\xBD\x1A\x89v\xF1\xAE\xE8\x13w\x1D\xA4\xFA\x02f'\x07{\xD7\x1D\xBFJ\x99\x95?t\xA3\xC4\xDFk\x8E7\x93\xF0\x97\x96\xF8\xCB\x07\x90+\xDE*\xC0_|\xF0\xA4\x94KK_\x9A\x16~\xB3\xD6\xBD\x00\xBB\xDC\xC1_\xF1c\xA8\x02k\x9D9\xB0\xF5'\x12\x7F\xE9\x9A\x8CZ\xDB\x97~\xD6b\xE90X\xC2\xAE\xE1,v\xEC\n\xA9\xFF|\xD4qY:H\xCC\xBA|r\x06\x11\xB6\x98\xFD`\xCE\xD3\x98:\x8F\xBF\x15\x19\x16\x89p\xAA^k\xF4\f\xA9\xA8\xBE\xC9\x1E'\xFC%\xABM5V\x0F\xB8\v~\x87\x873\xEC\xB0+\xBF~\\\x9EN\xF7u/\xA0\xFF\xA2b\xFC\xCE>\xB33\xDC\x15M\x0FN\xD1\xAA\x9E\xA8\xC2\x9F\\V\xEB\x94\xBBX\xF1\xF6\xFF\x905\xECi\x9D\x92\xAA\x01Q\xFC^X\xE2\xEF\xCA<\xFE\x0E\xBE\xD6\xA1\x9A\x05\xFBg\x04\xFE\xBE$C\xB2\xDB\x07\x15\xFEh\xE9G\xB3,!\x8CPz\x06\x9B3\xFA\xAB=\xC3\xEF~Q\xE9\xBFo8\xAFg\xF6PF\xEBH \x98\xB4\xD3<8\x9DL)\xF9\xD9\xAE\xFC\xF4\xDC\xA7\xDD\xE6xr\xA9s\xEC\x813\x91|G'W\xFF\xA5Qej3u\x9C\xF4F\xD1\x99\x81-\x0E\xA1\xEC\x16\xF8;18\x98Q\r\x8A\x86]Z\x7F0\xC8=\xF8{\x1Fk&\xA6f:\xE7Y/\xBBr\xB3\xF6\xCEJ\xC3X=\xBA\x945\r\x8F=\"\xA6|\xD6\xD8\xAD\xE4\x97q\xD8\x84\xD8\xA2\xCD\xEB\x1BH\xA6\x07$\x9B\x92\x96C\x99j\xCC\x90\xC7\xDF\x8A\f\xEBS\x1EC_\v\x10?\xD4,\xE5rg\xB2G\xF6\xB3\xEE\xFB&\xA8Ww1e\xF1\xA5\xBF\x87*\x93\xB5N$\x8A\xD3r\x9C\x1F\x14\xEA\x8B^@r\xB3\xA5\v\xFD7U\xBB\x8D\xFB*k\xB7)\xF9\xED{\xCCq\x1E\xB1\xC8\x01\x19\xB7\x97\x9E\x1C\x1B\b4\xF6\x15\xC8O-=?,\xE4\x17m\xE5\x94\xCC\xED\xEBU\xF2\v\x9A\xF8j\x8D\x98\\#\x01S\xC9\xAF\nL\xF1\xD0\xCB\xEA2p\x9BP\xE3\xAB\b&+\xA3[\x16\xB0E}FW\xC4\xE8\xDC\xD4\x1Do\xECM^v\x07\xC9\xAFG\b\xE7\x18\xA0\xB58\xE1a\x92_<\xD8@)t\xDF\x80\xA7\x1D\xF5hX\xB2\xC0\x12W~\xD1\xFBZ\xDB\xE4\xB0B\xE0!`\xED\x15'%\xFE\xF6\x04O\xCA\xF1{\xBD\x18\xBF\xD7\x03\x86\xE0\xBF\xFE\xE20\xEAL=w\xA8\xAA\xE9iYT\x7F\xF6\x80\xA5\xDA8\x8F\x7F\xC3\xD2\"GP\xAC\xF1#(f<\x01\x9F\x9C\x7F\xC3\xAE\xFC.\x93\xBA\xA5\x8C\xF0\xC7\xB2@i\xF4\xE9\xCB\xD4\xBFp*\xA2\x91\xFD\xE2o\xD7.\x17\xF2{\x1A\xF0\x1D\x19\xDA\xEA&\x7F\xAD\xE3\xD2\xFE\xD3d\x06\xD5U\xDCY\xDD~U\x9F\xE5\xB1\xFF\xCE\xA0xt\xEA\xF2\xAD\v\xCA\xEF!\x13Fx\xCF\x8B\xAF\xFC\xAA\xEE\xAD\xAF\x02:gg\xEA8\xF4\x9F\x02K\xA4\x92q\x8Al\xBD\x9D\xED\x00\xF4\x95X\xE5\xB1\xFF\x8AV\xE6\xA4\x88?\xE4\x8E_\xF3\xAD\xA6\xA7\xA3yE\xF1\xC1\xBF\xBE\xE7\xA7\xF4\xE1H\xDF!b\xF4\xFA\xD3oq\xEA\x82D\xD5\xC5B\xBF\xCC!j\xB2\xBEw\xD2\x87~\"U\xF8\xEEjSMOk\x9F\xCD\xE8\xC7\xF6pc\xBA\x83\xFE\xEC\xE7\x869s\x9E~\x9D\xDF\xFE\xA8\x9B/Od\xBB,\xCB\xA7\x01\xE5>\xC7]\xDC\xE2\x92a\xDB\xE1Bf>\xFEcz\xF9\xB24\x93\xC3\v\xD1\xEB\xFC5l\xA7\xF3\x89goy>\x00l\x16\xF2o\xF1u\xCCG\xFF:l\xDBpi\x9AT\xAFN\xC9\xEA^W+\xE6\xBF\x93S\x9D\x11\fX\xB0\xA91P\x19\xFB\x1D\xEE&\xC34\xE04b+\f4\x1BJT|\xBE\x9B\xC0\xC7iu\xAB\xB8\xD7\x07\xADF\xDFN\x13e\xFF\xAD?\x81\x99\xCEM\xD7M\xB6\x9C\x81\xEA\"\xA7b\vW\x95\xAE\xCAIv|u\x06\xA6\xF4\xA4^\x9D\xD1\xFB\xFE\x853\x1B\xB2\x03]]\xBE}j(\x8B\x7F\xE5\xFE\x97\x1C\xF9iY\x1B\xA1\x11\xF8\xEAB\xA4O\xF7\x9C\x90\x13.jW}\xEDL\xD46\x01s\xC8\x94\xBD\x8D\r\xAA\xB1\xD5\x00h\xB1\x86\x15cSM\xDB\x1F\x81fn\xE3\xFE)\x834\xE0\xB6\x15c\xF51*b\xDC,\xB3(}\xBDhX\xE9\\w\xDB#\xFE,\xB0\xF4\x8D\x844v\xEEZni\x9D\x949\xD6z\xB1z\xFCv\xB8\xED\xA6\xA8\x87\x87#x\xC34\x04\xD5\xF2i#J6\xB1\x82\x809\xA2D\xC4\x8A\x88\xD6\x03\xF7\x8Bc\x8E\xC2\xB0\xA8,\xA9\xA0_\xA3;\x1A\x88\xE2\xF9\x1E\xCC\xC0\x17\xF0Y\xCBf\xCA\xA4\xEB\xD9\x85F@\xCF\x0EHv\x1C\x14\x16\x9E\xCC$\x04\x86\xDA8\xCB\n\xAE\xDB\xE2i\xE1\x1E\xE7,\x85\xAD\x146\xF1Q\xD6\x1A[\xF6*\xD5kn /\x8EN\x95\x88B\xD90\x82\rw\xF4W\xD5Z\xC0o#\x169iY\x075q\xDC\xCF\xC1:\xB8i\xF74\xF1'3\xAC\xD6\xE6\x81`\x07q\xB5\xDED`Z\x9A\v?<@R3z\xB1\x7F\xD0\xB9\xAE\xFD\xCD\xB7L`u\xFC\xA84v\x0E=9\xC9\f\n1\r\xA7\x95\x88W\xC2-\xC6\xA9\xE5\x17\x7F\x83\x15\xE7fm\x0Et>\xAE\xDA\x8C\xA1\xC6\xC1\x9B\x9C\xF8\xEA(;Z\bQ\xCCGG\x11\xCAh>\x81\x97&i\x87\x19{NX\xB4\xEAz\xB6\xDF\x12\xF2\xBBn\xB2\xAD\f\xD0\x0F{\x06]\xF1\xA85 \xD9\xF1\xD5\x19\xAD\xCD\xC5\x9F\xFD/\xBC\xD4\xC4&\xE2\xBAn\x97\xA7\t\xF1\xEF\xCB\x84\xBF\xD0\x88\xB0s\x8A2\xB6\xB8\x9AO\xC6\f/\xB9\x96\xD6`V\xBE\x82\xE8\x9E\xAFes\xE2\xAE\x9Ak\xB9\xD6\xAD\xDC'\x96\xAC\x7F\x12\xAF\xE0<\xDB\x11\xD0\x80\x86\x10\xD7v\x04)*i\xB2\x84EF`m\xD0/\xA5p'\x98\xD3\xBD\x12\xA1\xFB+\xB3\x00\xFB\x91L\xBC3j\x1Fj\xC1\x10-t\x8C\xEE\xC9k\x1CGj\x9D\xE5\x96'PeZB\xCEM\xCC\t2<\xED\x06\xF0$\x19 \xF3w\x85E\x11h\x96@YB`\x88\xA3[\xE2\xEF\xEA\x89C9\xB9j\xDD\xB4\xC4\xF8m\xD4f\xDE\x07\x18\xF5\x83V\x9E\xBAM\x0F?8 \xD9q\xC4d\xAD2\x876\x02V\xDB\xCF\x8D,~\xC3\x8D\x14\xB0\xCAy\x8E=\xDC\x10fY\xA0\x89\x8C\\q\xEB\xD7\xE4\x10Oh3\x03\x07\xE9\x9E\xEF\xA3\x12\xF6\x95m\b\xC7\xEF\xE8\x8B\x0E\x99\xC0L\xD2\x94\xC6I/\xB5\xCCXO\xA6d\xB0\xCB\xB6\x97\x842\x98\x8Eq\xBD)G\x86H\xC5\x97\xAF\xC9\xD2\x88J^-\xB3\xE4Y\x13\xE2{\x9C\xEB\xC6\x1E|\xDD\x04B\xDCP\x8E\x9E\xAF\xBD\xA4\xDDL+-:\xBA\x12\x8E\xF0\\\xA9Y\x86G~\x86i\xC5\x05\xD7\x10*\x88\xE4\x97,\x94\xDFA\xCAQ7M)\xBF!D\x13h\x84\x8Fk\xD3J\xFF\x85\x8E\x98\xECR\xAE\x8F\x7F\xBEx\x04\xBC\xC9\xDC6\xD5\"\f\xFF\xBB<\xF83\xED\xD6(\xAE\x14\xB2X\x95\xC1\x8C\xC4\xDF\xEA\f\x8B\xF7\v\xD5\xF7u\x18Y\xCF$\xD0\xC3\x03Y<F\xA1\x0FCU\xAF\xB6\x11\xE2\xAC\xAD\xF3qq\x1B:5\x87*\x9A\x1A\x87\xB1\xF5k\xEFW\x89\x01\xBB\xBBV\x8E_\xEDRR\x83\xDB\xB9\xD0\x7Fec\xBB\x8D\xBF\xE8\xB5\xB4\xE6m\xDC\xBF%H<\xB4\xA1l\xA0\xDE(\xD0\x7F\x16\x9A\xFB\x1D\xF9m\xEB\xAB\xDA\x01\x94\xDF'\xEBI\xC7o\xDF\xDD\xA2w\xA2\"\x01\xF4\xA9C\xB4\xC6|}\x81\xCE\xF2\xFC\x94\x10\xDC2S'\xE4W\x1F\xB4\xD4\xF8u\xE5'\x19\xCB\x7FOq\xE5\n\x14\xCC\x7F\x00\x01\x13\xDD4~e3]_O\x93\xA9\xC1B\xB7\xB6\xD9Bn\xF6\x99\xA6\xE2\xDC[\xE4jr{/`\xE3OW\rH\xD5\xBA\xD1\x04\x97\x91\xA4\x8D\\\x1F\xFA\x17\xA1\xFF~3w\xFE(M\xE1\x7Fs&{n2\xA1\xA5|\x14\xD79H\xD9\xC7\x97\xD0\x8F}f3j\xED;V\xFE\xE7Z\x0EL\x97q\xEA\x02\xAE\x97\xE1\xCA\x11\xE0\xE7\x1Cz\xC7\xCF\x9E~\xE8l\xED\xF1+3\xFA='q\xC1\xD6\x8E\x9F\x883\xFF\xEB\x91\v\xBE\xB4\x96\x8A\xCD\x9E\xFC\b]\xED\x82\x1D\xF8_\x1Fu\xE4w\xFCC\xFF\xD6\x04\\\xF9o\xB2\xF7Y\xC7O\x8A\x13Z\x90\xCAF\xCF^\xA92\xB0\x1Bp\x9997\xFF\x8Ajq\x99\x86\x90_\xD3\xD3\x8E\x91\xE1\x90\x1A\x95K\x93\x94\xC5\xA7\xB9\xC4\xDF\x00\x98\xA5\x97C\x96u \xF5\xF8\x9A\x19\x9E\"\xF9\x05L\x8D\xD9\xDD\xD6\xE7[\xAB\x95\x1D\xE0\xF8,K\x92Mi\x99H\x1F4\xB5\x9C\xAC\xC4\x16L\xC0n\xE3,\x86r1a\x14\xCC\x1FY\xDC\xC2\x8B\xC4dH'\xD0?E\xAE\xC9W\xCBd\x87\xF9k\xC5-\xFA_\xEC\x87\x11\xDF\xF5\xF2w\xFAM\xC0~\\v\xA8\xD5$el\xE3\xD0\xE2\re\xDD\xBB\x8Dm\x02\x7F\xCD\xDC\xFFEY\x9D\xBCa\xC5)9\xFFv|i\xAF\xF4\vX\xF8\xF3r\x17\x7F\x8F]\xBB\x03\b\xDF'\xB3Y\x8CO\x06Z\xB4\x1BQc\x01{\x15\x0Fe\x16\xDC\xC0AU\xC0;~\xFB\xAB\x84\xFCne\xCE*!\x17\x7FR~\xC3\xA4x4\x99\x81\xC3\x9E\x17\x9F\x9A\xC4t\xD2$\xBD\xA6\xBE=Y\x03\xC3&\xCE\\\xB2?\xA11\xA3\xDB\xC2c\xEB\xB9:\x89:\x93\xD1eO\xCB\x85D\xA1\x8C\xC6$\xFE\x82\x16z\xDAxI\x16\x97\x90\xAF\xBE\xD8y\x8E:!\xCE\x8Fs\x1Fe\x81\t\xFC\x95\xDC*\xF0\x07[\xCE\x1F\xDAn1F\x8Duw\xE1\x92\x86\x9E\xB6*\xA1\x91~[e9\xF2[\xCA\xA9\x10\xB1v\x03\xC9\xAF\xA1\xDC\xD2\xEE\xD9\x02\x7F\xA0\x83jQ\xB7\xF6\xDE\xF7\xDC\x06:\xAEy\x85\x94\xDF\b\xB6V8\xB8oXz_\x13P~\x80\x8C\x0F-\xD2\xFC\xE0K\xDA\xED\xA8N\x00O\xA8nP\xAC\x91\x82\xB9\xD2HL\xE5\xE7\x14\x16\xECJ\bE\x97\xEAK\x00\t\xEE\xCD4\x91\xED\x95\"AK\x95\xDF\x14j\xB8\x1B\xE5\x96\xD6\x800\xD7l\x19\x90^\xD9e.\x017u\x96I\x99()^\xB9\xEDl\xF8\x9F9t\x8A\xFF\xAA\xF5@\x1F|\xE8,\x830\x8F\xB0\xCE\xC4%(i'g\xA1^\xFB\x8F\x9C:K\x95\x98\x9E\xDAY\xC7qA\x16\xBF\xE0\xB8\xDB\xC9C\xD6v\xCE`}\xBB\xB3\xB4\xECR\xCA@/\x1E\x01\xE2\x0F\x9D}\xE521~#\x97\xCBEzZ\t.l\x07>\xC1\xA15m\xFF\xCA\xA9\xA9\x8E\xED}#Z\xC9\xF5\xC2\xFE\xA3Z\xD4\x9F\xF9\xCA\x1BW\xFDX\x1Cwa\xAB\xB4\xFA\x96l\xC0\xE7{\x1DE\xB6\xFD\xB1O\xEF\x00V\xBC!\xB3\t\x8E\xC9\xC2]kL\xE0\xA9\xAF)Y\xDD\x8B\x0F9V\x9F7\x84\xC0.\xDE\xF1\xB8\xB0m\xF7<\x91\x00\x1E/\xC8\xD4\x19U\xF2\x13\xCF\xB6:!\r\x9Bn\xACN\xB0{\xCE\x13\xB0\xF3\xDB\x9F\xD4\xC6`\x18\xAA\xF4\x857'\xB8\x90\n\xC6\xE4'o&d\x9E\x07q\xF7k\xCB\xF4d^IF\xC99`L\xCA\xB5\x00\xDEvH\x86\xB3\xBE\x16\v\xF4;bK\x9D\xB2V\x01/\xF9\x94)\xDBa\x87\xC6S \xB2\xD7\x93\xE6\xDC\x00\xCD\xF2\\\xC3\xA7yI\xB9\xF7\x1A\x9E\x1A\xD8\xE0\xB44(\x9C\xE7\xE3\xF9\x85\"\x82Y\v{\xC24\xCF\xB1\xF2\x99\xC1\x8EQ8Xu\b\xC0\xD0\xEA\x8A\x11qB\xB2}\xBA\xB2\xA9/<8\x9AMIR\xE8\xB9\x07\xB6\xCEIw\x1C\xE5\xB6\xCC\x16\x01\xB3\xE4\x85N\x93+\x91\xBC\xC7\x01!\xCF\xDA\x16$\"\xD0\xB3fd3\x07j\xF6\x1F\xDF1TisX\xAB\x1D\xF9y\xB3\x8D\x8A3\x18\x8A\xD0\xCCY\x97\x81\x1D\x97\vL\x05[\x043\xBF\x0E0\x93\xA8y.\xAA\xBAT&\xBE\x8A\x80\x93V\xBB}D\xB3\xCCH\xF1\xE9\x1D\x92\x88E=\xC2\xDF\x95\xF5^C3Uh\xB5\x8E3NSo\xBFQ\x97\xA1\x94C\f\xE5\x97\x92E\x82\t<\x1E\xE7lj\x06FW\xF6\xD8\"9S\xD9\xA1\x1A\x1E\xB2\x89\xEB\x92\xFC\x92\xB1>\v\x88\x90\xBA_\xCA\xCCT[O\xC4\xC8I\xD3>\x94)H\xC2\x95a\xC5\xAE\xEC\x90\xCC\xF6\x82~6G\xE6\xCC\x16\xDA+[\xED\xBC9\t\x18-\x18\xAA\xE3lUm4\xD6\x0E\xC4\xFA\x1A\xEC\xE4\xDA\x8A\x11m&\xA6\xA2\xA0\x05Uc\x83&\xD2k>lJ\xAFx\xCE\x94Y\xB0\xCC\xA6\xC8\xFC\x80\x90$\x99\x06\xF6\xC78\x90\xED\xE3\f\x13(\xA9W\xB3\xEBKV\xE8K\xB9\xBA\x9E@\x93\x9C\bV\xBBKz\x11\x1Am\xCA\x15f \x9E\xCC\xDB\\u\x1C\x18\x9A\xBDO\x85\xB0\x93u.\xD4\xEA\xBEl\xE9g\xE2\x9C\xD9M\xA8\x1B\xB5\xD3\x8B\xE0\xAF+}\x84\xFBR\xC0\x9A\t\v\xA8\xC9\xB0\xE4\x11\x81\xBFYZ\x91Vs2=\xB4\xF7\xD0D_Z>\xC3\xC5\t/L\xE4v\xE5\xDBA\x1B\b\xEE\xA0\xEE%-\x88\x8F\x00\xFF\x07\x85\xA2\xCA\x12N\xB0\xF5\x92^\xF6\xF2\x01\x04S\xCD\xC3\x07\x01\f\xEE\x7F\xB1\xF5X\xD2\xE0\x9AO\xD6A.\xB3\xF4\x95\x05Yz,\x9D\xFE\xF6\b\xE5T\xB1\x81a\x99\xEF\x18\xCC\xE2\b\x82\x91\x1C\xE4\x1F\xB0\xA1\x7F\x12\x86\xC7;<8\x9DF\xDC\xE9q\xF3\xA6\x18\xBF\x07\xD7\x9C\xDE!\r\xE1\x81j\xD7V\x89\xF5L\x14T\xA6\xE5\x8Aa\xA4yq\x8C\xB2]\x07\xB6|@\x86[\xD9P\xBE\xBE\xEA@<\x81\xC7\x07y\xF0l\x0E\xBE\xE0\xF4\"\xF8\xF3\x9DI\x1F\xE6\xFE\x18\x10\x8F\xD3:R64H\xF8\x937\xDE\xFC\xF4\x89\xB6x\xF0\x8E\x9C\x94\x9F\xA7\xC2n\xD0\xF1\xF5\x84{&r*\x1E\x15\xDC\xD2Fq\x9C\xAD\x14\x8A\"\xF9Q\xC7.\xE3\bK\n\xF9\x19\xE9\x1F\x88\xA7\xDE\xDB\xBC>9<\x9C\xD1f\x06U\xF0J\xBB\xBC S\x86\r%7\xCA\xF1\xCB\xF6\r\xA4eh5\x85A\x92\x15\x82\xD3\xFD\x14\x03\xBAY\x90\xCC>\x1E\xEC\x99F\xEC?\xB58<7t\xCF\xCC\xC1x\xA0I\x86/\xF2K*\xB1f\xA2\xD9[\x99\xF6\xD2\x84L\xDE\xC40\x0F6\x91\xFCr\x9Da\x8B0\xC9\x92\xC3.\xFE\x06S\xD0^N h\x9F@\xDDD\xCF\"\xF83\xBA\xD2i\xAE\x87\x81\xF8\x9A\x14\xC9/\x99\x10\xF8\xAB%\xF9T\x9C\x8C\xD8\xAB\x0F\xAD\xF9jJ\x92\xC2\x80\x07\x7F\xAA\x886\x96M\xA4\xBB\x80\xA0`\x9F\xC1\xBE>r\x1C\xBDGA\xE0\x92\x8C\x83\xBFZ\xB0\xF4 \x0F\x1E,O\v\x83~p\xDF\xC9\xE6c\xC9\xA0\xA5)\x0FJ\x99\xA55\xCF\xC1\xDF\xE0\xA3\x02\x7Fe\x9C\xBD1\xEC\xCA/\xCD\x83b\x18\x04\xD3o\xD0\xBD\xDC\x02h\xD1Y\x1E\xECI#\xFE\xA4\xC2\xDF6\xAE5t\x7Fo\xF0\xF4\x0E|\x9Fb\xF9\x07\xBD\xF8\xEB\xF6\\\xA3\xCCR\xF8\x1B\xE0A[\x92\xDB-\x1F\x18\xD1\xFB\b\x7Fn\x19G<\xBD&\xC3\x9E\x16\xF8\xBB\x01\xE5\xCD\xD3\x8B\xC8\x0F\xD3\xB94/\xA1\xF1\x9B\xA2\xBBO\x0Ew\t\xB1\xCA%\xB3\xCD\x91\xA1\x13W\x9C\x94c\xA6\xD7\xB3d%O\xDB\xB4 \xE1\xCF\xA6\xCCy\x93\x88\xA7A\xFF\xAE\x87\xA3\xFF\x02&\xFB\xE5\x0F\x10\x8C\xDC\x91>d\x02\xE9\x8A\x93\xD3\xE9\xC1\xA7\xCD<\xFE\n\xDC\xD8q\x93\x1DK\xF5\x11\x1Bhg|\xA0\xC6\x19\xBF\xC3<\x18\x19\x12\xF8\xFB:-*\xDD\xC2\xA1\xCD\x04\x10\x9C\x9E@u\xA5\xE5\xCC\xBF\xA1/\xE5\x92q\xDB\x96!:\x0F\xFEj&\x9A\xEDB\xFC\r8\xF8kA\x8A\x83\r\xE5\xEE\x03\x85\v\x19\x7F:\x8F\xBFt\x02\x8F\x0F h\xEE\xC0\xEA\x17#\x8B\x8C_t\xD9\x879,1~St\xF7C\x03\xBB-\xA0\x8A\xF4_E\xCF\xB4\xED\xAF\xA6\x81#\xE4\xE71\b\x82\x0E\xFE|=\x84\xBFIBI?\xC9\xAF\x8A\xF4_\xC0R\r\x11Q\x1Ef=\x07\x114\xC3\xE9g\x85\xCE\xD9Y\xDCs,\xF5\xA0\x85pJ\xD5\xC6@S!\xFE\x0E\x0F\xF6%d\xD1\x8C\xA1ayL\x90\vU%\x86n\xF0\x8E1BI\x94\xFC\xAA<\xD8z\f\xF1A5\xFF6sX-\xC3\xE9T\x93\xD4\x7F\xA9\xFC\xFA\x8Fx|\xC2;\x7F\x04\xC0fT\xBA\tL*\xA00\x10\xAD\xCB@\x86B\x9Fr\x0FK\x1DjG\xD3 \x0Ff\xFB\x11\bNw-,>\xBF\xD1or\x7FXh\xE6\xA34\xFBqj[\x9D\xE8\x11\xF2\x8B5\x98v\xCB\xEE\x88yXrb\x8F\xF3Qw\xF4_yd<\xA9j\x8F\xB1t\x17-\xF2I\x90\x13\x86\x96&\x97WQj,\xA6\xAB\xC1nl\x8C\x8B\x11U]\xDE`'c}\t\xADQ\xCE\xBF1Kk\x983\xFF\xC6\xA8#V\xCCB\xB2\\9\xFCl1U\x9Ab\xFEMQ\x0Ew\xF2\x1B\x00\xEB\x1E\x02\xEBM\xC2\xA8\xFA\x7F\xD9\xFB\xFF\xF8\xA8\xCA3\x7F\x1C~\x9Fsf\x92\x93I\xC8L\x86`\x10PN\x86\x01&\x13$\x14\x7F!br\x88\x01C\xB0\x12\"\xB6]\xB7\x85\x94j\x17\xE9n\xB5n\xB7\x1F\xCA\xFA$7\x11u\b>\x10B,\xD4\xFA\x81q\f8\x19,Aj-Z\rY\xD6\xB5\x88m\xB5\xD4v\xD5\xDD\xD51\x82\x85\xF8\x03\xA4\xDANB:y^\xF7u\xDF\xF7\x99I\x80\xDD\xE7\xFB\xFDg\xFB\x07\xE7\xF5b\x98\xC9\x9C\xB9\xCF}\xAEs\xDD\xD7}\xBD\xAF\x9F\x92\x7F\xBFd\xBB\x8B\xAA\x03\x9E/\x8E\x17\xFBo\xD5F\x87\x93\xF2\xFB\xE2\xD9\xFC\xC7G\xA673\x99[\xB8\xDE;\x1F/\xB6\xA9\x9C\":J\x9D_U\xB4F\xB5\xEA0\xD3\x03-\x9C\x10\x17X\xBFy'\xFA\xA6 \xEF\x04\xBF\x86%\xB4\xAF\xA9O2`\x07m\xB0\x151+\xBD3\xEF\xFD\xD4aa\xD4\x9E\x9E\x91\x7F\xBA\x82\xBDSb\xB3~ \xF5?\xE3\xF65\x04\x91w\x90\xFEGHsz\x970\v?X\xC1\x8C\xD6\xB5U\x1B\x92\xC0\x8C'c\xA9\xDD\x15\xBBm}\xAD0\x97O\x8F\n\x93\xAD\xA2_#z\xCA\xE4\x17\xE8\x99*r\xDF\xF4\x14*\x98\xDE\xF82\x7Fn\xD4\x07\xABg\x07\x03\x07\xA3\xC6\xF8\xDD\xF0\x9Et*u\xE5\xF5\xAF\r\xE4\x97\x9D\x00\x95\x91\x0E\x148\x11\xFA\x9E@V\xE8\xBC\x18\x99\xDE\x94\xB2\xBC\x13\xA4,\xF6\xECxR\x82\xDB\xBEL\xA1\x99\xD0\xC6\xA4\xBE6\xCC\x8C\xC15\x98\x1EK\xBD|\x11k]<\xFE\n\xE0\xEEH\xAF\xADF\xA0\xF5\x9C#\x13\x10+J\xF6\xD2OTc\x02\x19\x11\xE5\x03\xCBF\x85\x01\xA0\x96\xB93\x06}\x0E+]\xCA\x85*@\xE5\x14f\v\xAC\xC6\xA5\x7F\xD2\x87uB\x99\xB5%.\xF4\xD5g\xD5y\xF1)/j\x9B\xEC\x86\xCEG\xAE\xD1\xCF\xB9\x19S9\x87\x98\xF32\xBAp\xB5\xA9\xCE.u\xC1q\xF8\x9E\xE78O\xF3\x91(U\x962\x85YY\xB3\xE1\xAB\x9C\xC7\xF8\xB4\xDCkP\x99\xC7\xC9q\x83\xAE\xE8'\x10E\xEE\xA7\xB43\xF9\x9D\x8ATm$\xC7\xB61Uuq: \xCB\x1F^n\xC6\xD6\xA5\xC9:P\xC5`\xBC\x13\x84\xF1\xB4\x7Fj\xFE\xFB)\xE9\xC7\xA9J\x02e\xEE\xBE\x03\x04\x97>\x03\xF4\xD3=\x83\x1BlDV0\x99\xDF\xD8\x96\xDA\x00\xA4\xAF\x880[\xCA\xF6\x92\xCFm\xD1BV6\x1C\xA4\fZ\xDDB\xF8\xC9$\xDF\xD4\xB5\x10V\xE8zj\xE4#C\x04\x95\f\x9FT0r\x96{S*\xCA[\xE4\f\t\x9Bj-\xA0\xFF\xF1\x9D\x8A\x16\xBD\xF4\xBBU\\\x9E\x06/\xC0Z!)\xC73GN\x14\xCB\x99~ R\xC5\x11\xDA\xF5\x9B\xDFO\xB5\x85[\xA3H\x13\xCE\x9DO\xD0rj\x9F\f\x0F\x96\x1A\x1Deas(\xA8\x00Z\xCFgN\xE5\x9C\x9F\xF5\x8A\x8AG\x86h@0ks\xDF@\r\xF5\x05\b\x03\xBA\x7F\x98\xE9\xED_\xADj\x95I\xCB\x1D\xC4\x7FU\x07\x8D$\x10\xB0)#\xF5t\"\xF8\xC5\xA4\xF1\xCEm\xA0^\x92\xDET\xCF\xE6\xCDI\xC4\xAE\xD9|*%gpum\n\x98-\x07\xE8\x91\xF1\x93F\n\xE5\xC5\f\xA8`\xDE8\x8EU\xF5\xC5\xB3q,e\x11\xE7%\x91\b\x89\xB8u\xCA{\x12{\x99O\xBD\x139\xC6[\x1Af\x1F|\xFF\xEC\x8E0\xDF\xCF\xAB.\xD0\xBC }N\r\xDD\xFC\x14\xEA\x98q8\xDD\x05w-\xC2\x1B\xAA\xB7\xA6\x13=Q\xBD\x85\xF8\xEF/?\xE6\x14\xAA,\x8F\xD4*\xC5\x8B\xF8\xEF4\xA5\x85\xC73\xA1\x7F\x15N\ns\xA7-|,\x06\x93\xEA\xE5\x1E\xED>*'\xCB\xFF\xF6I\x03\xCB?\xFB\xFA\xAE\xF2\xD5)\xE9\xC1\xE2(\xA6k\\\x7F\x94@5W\xB1\xDB\xD3g\xF7\xD8\x88\xFC\x97\xA8\x89\xE2\xA9;6\xD8e\xEB\x9F\xFD8\xDE\x15\x90\xAA\xC1\xD5\xBF\b\x01W~#\xA9\xF8\xAF\xA0M\xB4\x04=\xF8P\x12x\x8E\xCF\xF9]\xDD\x93M\xBF\x04\xB9u\xAA,\xFD\x93n\x91?Hy\xEF\x94\x98)\xBA\xB5De\xF4\"\xF2\xCF\xA6_H,\xBE+\x98\xE8\x8A\xCA\xE0\xB4\xF3\xF3_~j\xF4\x92\x1Ef\x9E\xE7\x13\xCF3o\n?\xDF\xD3\x7F\xBA\xB5'\xC2\xF4\x1E\xA0\xC0\x87G\x88\xB9C\t\xC5\x7Fb\xF5\xBB\xB6\xA6\xC5%\xAFP\xA1\xE3\x83\x0E\xFF\x91\xFC\x8B3\xC8\x06\x18]\xE5\xFD\x9C\xFF4\x82\x9Bz\xC3.x\x12\xCB\x0F&\xC2\x119g\x9F\r<\xFB\xC8\xE2\x14P*na0\xD1\xFA\x94M\xD1\xC7\xDAW\xF9\xC7\x17b\xDD\xBD\xFA\xF6g\xBAO\rJl:\xEEkQ\xC0/\xF9o\x87,\xB4\x9A\x9FB\xCC\xC5\x80n\x96\x1F\xC5\x91\xC9G\xB2oP\xBA\x15\x93z\".\xE36\x99C\xBA6\xA7?\xAC\xD1\x0F\xE4\x87\xDB\xF7t\xF7?7t\x90\xEB\xB6\x07/`\xCCKg\xC1z)\xC3O\xE0w\xC8\xEFOw\xB31\xF5H$\x12[?\xDAs\x99\xAD\x8BZu\x9FSs\x9E\xCA#\x11\x89\f\x05R\xF2\x0EreV?\x86\xB2F\xC9\x7F\x1B\xF9\x7F\\%\x14\xEE\xF3n\x06\xD9\x06\xBB;\xBC\xA7\xEE>\xBAK\xCE\x7F\xFFY\x8D\xFC\xB3\xAF\xC7\xCB\xFB\x15\xFFq\xF9\xD7UUG.N}\x90#\xD7\x9E\xEF\x94'\xE1\xFA/\xC0\xB8\x07\xF04t\xAE\xEA\xB2\xF4?u\xC7\x13\t\xC9\x7F%\xBF\xAB\x1F!\xFFrk\x05\xFF\xED\xDD\xC6\x87\x82\xBB\x1E\xB7\x98\xAD\xD9\xFC\xC7\x91W\x1A7XzZ\xE6\xAF\x92\xFC\x13Xr\r\x7F\x11a<\xED@\xFE\xC0\xF2\x17\xE7.\xFE\xD6\xB7\xBB\xF8]v\x9E\x9F|\x1A\x7F\xC8\x07F\xFC\xA9\xA0\r\x7F\x86\xE7\xF9\xC8 \xBC\xF7\xE0\xE0\x9E\x0F\x07\x8E&\xC2\x96\xFE\x02\xE0\x9E\x85\xAD\xB4B\xA7\x86S\xD2W.\xEC\x86\xE6\x86\xFB\xC85\xA5j\r\xE9=\xDFe\x90Mb\xA9]]\x1C\x0E\xFF\x85\xCA\x07}\x94\x06\xCA\xA5\xDB\xCA?3Obyw\\\xC4?\xEB\x8C\\\x92\xFB\xD7/>\xC1\xF7\x1D\xC1\x7F\xB1G?\x89jC\xBF\x05\xB4M@\xFE\x99\xF4\xAE\xEE\xA4\x1E\x8Dw\x7F|F\xF1\xDF\xF4\b\xE0\x13\x14\xD2\x97\x8Bf&\x9C\x9B\xF6D-\xFE\xDC\xF2\"h~(;M\x95\x90W\x02S\x93z\xA2S\xF0\x1F\xA5\xE4\xD3)\x9E\x8C\x91\xC8\xF8\x80+\xD0\x1D{\xF6\xF4?\xDDIx\xF0\x02\xFC\xA7\xFF^%\xDD\x8F\xE0?\x96\xDF\xFFI\x03\x1B\xF3\x15t\x95\xD5%f<\xAFAbg\x93\xF8\x0F\x1B\xDB|\xD9\xF2O\xEFk\x95\x91l2\xF5\xA8Cw\xE29\xA6\xC8d\\Y~\xFD`w\xFF\xAAe\xA4$\xF0\t\xF9B\xC8O\xF9\xA2\xE5\x1F*\xFE\xE3\x00\xFA)\x9D\x93S\xF2_{\x8F;\x9CD\xDBmR9\xA9N d\xE9\xE9\xEE\xC4\x1E\xBF\xECCT\x12\xB3\x81q\xD3\xA8\x90\x065\xA9\xB3\x047=\xFF\x80M\xFA\x83\x8D\xA5U\xFD\xA3\xF9\xAF\x07\xF3\x98\xDE\xFE\xA4\xC8\xDF\x17\x96@\xCB\xA9\xFE\xED$0\xE5\xA7n\x7F\xB14?\xE5\x8Bq\xFE\xBB\x80\xFC#>\x1D%\xFFl|\x0E\xCF\xF3\x8F\x16\xC3[\x8F\xEE=\xFD{\xFA\xAF(\xA6\xCD\xD0m\xE2q\x92\xAE\xC5\x81\xAF\xD78\xC0\x93\xBF\xFA\xEE\x11!\x0F\xEAI\xEC\x17m\x8E\xF8\v\xB5\xB1\x9A\xE3\xC8\xBF\xA9\x9E\xC0[\xD54\xD4\x15\x80V\xFD8\xF4\xC7\xAB\xC3\xAD1a\x8C\x8B\x93\xFD\xAF4~\xE3\t\xF2\xA0r\x88\xDC\xD8\xD1\xB0\x11\xFA\xFA\xAFQD\x00\xDC\xE6\xD1\xA5\x1E\v\x91\xD0\xC6dRB\xF6Ko\xF7\x01\xE3\x1E\xEF\x95A\x03|d\x82\xBE\xD3;, \xCC\xA1\xEA\x8A\xE2\x1B\xB3op\xBA(\x7Fm!\x11\xA6\xCC\x00x|\xCA\xFBM/\xA2\xF9\x1C\x1FJ\x7F\xBC\xA6\xBC#\xB0\xB4\xBA\xAA\x95\x01\xD7]`\xFD\xD6@\x8C\x92\xC5\x7F>|\x89\x19\xD1c\x8F\xC3\xBD\ne\x857\x0E|%\xF4$\xE9/y'\xD0\xD3J\xCD\xC9\x9ExT\xFA4M\x9Aw\xDE\x87\x9B@ADc%\xD6}g\x07'\xDD\x8E\f\xA8v\xDE\xCD\xD9\xF0\x8D\xBA\xB94\xD4U\x1C\x8C\xEE`zb\xED\xEC\xCD}B\x99;B\xC6\xD6\x99\x15\xB1\b\xC1\xCD?\x01\xC6\xF6>\x14$\xF5\xB5\x8B\x04r\xCD;\xF1\xD4\x8E\r\x8DHW\xB4>9\xFEm\x07\x8B\x03(\xA4\xBC^q\x8A\x80\xBEs\x9E\x8Cr\xFA\xF1\x8F\xD3G\xD4t\x99C\xFA\xCB\xF4(\x1E\xBC\x86b!\x90\x7FB\x15\xAE&=\x91\x06\x1089\xBC\xB6l\xFA\x13\xADk\x03\x05Q`\xC6\x05\xD6\xEF\xDAs\xE8\x97w\x02\xF71\xFD\xF0\xFE\x1E\x96{\x18\x15\x1B\xFB\xCA?\xB9\x88\xC0.\x1E\xFF\x9B\x87\xE3\x82\xDCdj\xB0\xE1r^,)m-\xE5-ep\x02\xB1\xC4\x17\x11='`\x99.`R\xC6ww\xAE\x10\xF9\x7F1\xA7\x8C\xDFY\xE4\x1E\xAB\xF4Sv.*\x07P{\x1E\xF8*\xE3\xA4\xF5Q\x0E_\x96\x15\x18\r]\x83I\xFE\x04\n\x0E\x83\v.f\x9A\xCE5|\xA3\xAFFY\xBE6j\xA0\xA9\xC4V:\xBE\xA6n\xBD?O\xB3j\xE1Z\xC7_\x1E\xB2\xC9\xE5G@\xA4<\x8Dy\xDD\xA9V\x99\x93IZ\x15\xA5\xC4\x8C\x89\xF7\x0F\xAE\xBFr\xCF\xEA\xA9\\\xC9\x97\x19\xA0.#\xFD\xA9\xD3)g\xF8`\x12\x93\xA0\xC9\x9E\xF7Md\b\x98/6\x1BW\x8A\x82\xFB\xC4\xB6#[.\xB9N\xAB\x0E\x9C.K\xB4\x8E_\xC1\\\xA1T5\\\x03>\xB1\xA3\xF9\xD6\xAB\xC7s\xC9\xB1\x81\xA6%[_Z\xEA\xE3\xE3\xD5\xD6d\xB5\x16R\x06\r\xF1\v\x8A\xCB\xA3\x9E\xA7>\xA6\x99+D\x88\x8C+\n\x8C=vieu\x91\xAB\x16\xD5>\x86\x1DK\xDA\x83\x03M5\xCC5\x10\xAA\xF51\xAD\xE9\x14W/\xBF\xEC\x1BA\xBF%m\x9D\xA5\x95\xA2\xA7h\x91\xABK\xD1\xCFuO*\xC6\xD4fc\xEE\xFCCJ$\xC56?W\x91\xE2\xF82EU\xC2-\x04\xA3\xF7\xA7\x85\xFBV4\\\xF0\xD6R.mkbg\xA0,\xFC\x19\xCB<\xE5\xDCO\xF5\x9C\xCCV\xDFfiI\x87~.\xA2\xDFra\xACqY\xA8q\xD4n\x99\xDB\xE7\xF2\xA9\xBC'\x0E38\xFD\xEA\xE1\n\x99+\x98\xABT\xD2o\xEC1%\xCC\x8B;\x8B\x96\xCD\xF7\xD7|\xA1\xE9\x16@[\xBE\x82\xB9F\xD5\xB1\xD1\x9Aj\x99C:\x1AtrRkj\x10\xF4\xE3\xC3\xFB\x83\xEF\x05\xAAK\x8E\xD5bq\x11\x8C\xBE\xDA\xF6\xE0:\xB3\x86y\xB5\xDA%\x1DQ\xCDC\xF1\xD9_\x1B;\xA2\xCAHu\xC9\xF1\x01\x17\x1F\xAA\r%\xC7\x97*\xFF\xB4k\x83+\xC3\x7F\xC3\xBE\xF56\xAA}-\x16\xAA\xF3`\xE1\x8Cl\xB1b\xA5P\xF5~2\"\xBBS\v\x83\x06\x9F\xD1\x98\xB3\xE9\xEE\x8E\xE6\xB3MA\xBEj\x9B\x05\xDAv\x15\xA5?Sev\xA9P\x99\x85\xAASDwc=n\x00pL(r^\v}\f\x86\x88j\x92\xAD\x7F\xA9\xD3.\xBD-\xB4De\xEE?3ojv\x1F\xBCS\xD2\x9F\x8B\xDD\xB5[\xD1o^\xF7\x947>\xAD\xBCe+;\xC1'~\f\x85\xA3\xEB\x00\x1D9A#Q\x07b\xF2}\xCEb\xC6\x913bi\x14\xC6\x81\xB93\xEF\xDF\xFF\xC7\x03\x85)\xF4\x1FLj\xE1\x13\x07O\x9D\x8D\f3\xD7\x13;N\xBF\x105\xDA\xFB\xF86\xFE\xBB\x11-\xF7\xD17g\xD3\x94\b%\xB6\xE2\xBA\xC2'\xDA\x95\x1B^\x1Ft\xF8o\x85\xE9\xEB\xB4Q\xBD=\x16\xC2\xDA\x83\xC7C\x98\x84\\jn\x14O!\xD82\xA5\x1F\x973\xC7(CD\xCC\x89E\x06'\x87KC\xC3L71\x1F\xD0t\xCE\x7F\xD6\xB66Yf\\_\xE4g\xDA\xD0(\xFE\xABq\xF8\xCFv\xF8\xEFf\x99\x1Bi\x02~g\xFD\x96\xF4\x02\xCB\x98kJg58\xFF\x89j\xC4\x9D\x19\xFE\x1BXV\xED\xBFc\xE9\xBC%\fZ\xDDM\xEC\x9C\xF5[+\xFA\x81\x93\xCE\xA5\xD6o\xD3\n\x11\xBF\xCB\xF9o\xEC\xB1\x81p\xB5\x7FA\x04\xD5~\v\xBF\\\xD2\x1E\xDC\xE0\xAB\x83{\xA0\xEE\x96mIm\xDA\x92\xADI\xE0\xCE\x91\xDD;W\xB4\xAD\x1FX\xCB\xF9/\x02\xFF\xF1\xA5\xC5\x8A\xFFR\x91\xFFR\xF4\xAB\xCB\xF3u\xD6bmGw\x1Cu\x91\xCDq\xF4Q\x10\x02\xDC\xA1V\x04\xBB\x07\xC3*'=\xAEzp\xE7\x95\x0F&\x1E\xA9\xFA\xB0?\xC1\xF9o\xBE\xE4\xBFE\xE9G2\xFC\xB7\x83\xF3\x9F\xD6\xA2\xE8\xC7\xD7\xD1ML\xD0\x8F\x1AvK\xFA-\x94\xF4K\xA9\x0E\xA6j\xFD.\xE3\xF2o\x05s\r\x8C\x17\xEB\xB7\xE4X\xCA\xA1_\xD9\xB2\x85>WQ\x90\x8F\xD2P\xCB\\m\xA3\xD7\xAF\x04\x1AN\xBB\xD3\x92\xA4V\xD7 \xE8\xC7\xE5\x9F?\xB8\xA5\xA9\xDA_s\x18K\xDA-\xC3o\xFB\x83\x1B*W\xB3\x82\xAEp]\x1B\xD3\xD0\xC7\xD7\xEFm#\xE9W]\xF2\x926\x89\x92\x9EqI\xF0\xFB\xCE\xFA\xD5\x86nS,\xFF\x89\xA7\xB8f\x16\xE6\xFB\xAB}XT\xB8\xCB\x87\n\x96\xCBg\x95\xFB\xDB4\xE6\x1D)?\x86J\x9A\x12\x991\x88\x88z\xFB\x83\x03\x97\xC5\xDBk\x06\xB9\xFCk\x16\x95\x83\xDC\x9F\xDA\x9FOPv\xAE\xCEv\x06\v\x86!\xE8\xB7\x1E\x13l\xE0?\x01-\x02\xE4X\xB8\x13\xD0\x84\xCF\xEBN1\xD1\x9C6\xE02:7\xC7\x02&1\xE0\x9FX\xCE\xAC\xCEU,\xA7\xB4\xE3\xEF\x85}\xF1AuK\x93v\x97\xBD\xF1\xAD\x89/_\xDAy\x17`|i\x19\xCB\x19M\xBF\xA3w\xD3\xA9\x13\xF9\\&PQ \xA6\x1D\xB9w\xA7\xB0\xC8\xA5\x80\t\xD3\x9E\x8E\xDD\xFD\xE8\xC28VNLjC\xEF\xFE\xE8\x83\xB3+\x7F\x03\xD7\x9E\xBA\xD5\xDB\x99\xD6S=\x9E\xAF\xDFI#\xE8w\xF7\xA3\v\x07\x12\\\x8A\x061\xE1\x8B\x1B\xD4\xE5rR\x96\xD2=\xB4\x06\xD7\xF8\x1A\v\xF3}\xD5>\xFC\xCD\x9C\x05>.\xFFfq6\xF3E\x80\x87\xEE\r\xA2\x9C\xE8GA\xF3y|\xFF)\xF0\x7F\xD65n\xC5\xD6cK\xE1\x12]\xFE\xD3\x80\x19k\xDA \xCB<\xEB\xDF<\xB8\x97K\x8B1\x85\x02\xB3\xBB0\x9B\xAAD\xC20\x81\x02\v\x87\x00C\xF0\xDFa\xA6L\x1B\x10\xE5\x8C\v,\xE0\xAA(\xF0\x06\nJ\xD7\xBE\x82\x82)\xFE^\xB1~\x1FV\xB7t\xF5SW.;\xBA\xFF\xE6\x7F\f\xFE\x06\xD0\xEA\x7F'\f\x83\xD9\xF2\xAFA\fJ.\xFB+9\x11\xBF\xC0\x8C\xA6w\x9F\xA1G[\x10\x07\xAE\xFCxb\xC3\xE1\xFD\x0FG\xF0\xEE~\vV\xCD\xFE\x19\xEBbK\xE1Z\xD7\xFE\xEBg\xA2F`\xC5\xCF\x92\xC0\xA2\x9F\x8E\xB0\x1C\x1C\xDE\x7F\xF3\xC6:\xCC\x82>\x88+\x8F\xDD\xAAdc\xC1F\xAA\xA1A\xF4k\x9EP\x14\x7F\x1D\x0F>\xDE\xB9\n-\x91x\b\x93X!\xDFf\xF3\xE3\xF7\xA2l\xFE\xAB\xFD\xB0\xA2\xCA\xA6\x88<\xFEb\x94\xD5\rv?\x12\xAE\x1BdB\xB1\"k\xE3\x84\x96\r\xAA\x8Eu\"\x1A\xE0\xFC\xF7\x05i3wQ\xB0y\rS\xF2o\x81\xB3~k\x99\x82\x96(\x12\xBD\xBF\xEBE\xCF\xF1e\xCC\xD5\x10X\xC8\xE5\xDF\x8DtFQM\xC4\xD1_J\x1B\xAA\x8B\x1E\xD8R\xB3\x14\xD0\xDAo\x14\xC08\x9B\xFF\nje\xFDq\xA5$\xFA{5\xB3Z\x84\x98\xBB\xE7\x00>wQ]m\xDBz\x92\x7FF\x9A\xEF\xBF\x81jV0p\xC6\xEE\x88j\x81\x16\xBE~o\x1E\xD9B\xB1v[\xE7\x06\x1F\xFC\xB6\x1E\x80\xBF\xE6\xEB\xCA?\xED\x8AX=\x0E\x9B\xBE\xB7\xBB\xDC\xC4\xF6\xDDS#x\xF8G\xA1\xC3x_tes/\xDE\x84i3\xE7\xB4\xA3\xCA\x92\x99*\xB2XG\xC1\xABg\x82\xCC\xFB\xEA\x99\x0E\xD9)D\xA3\x88\xE4\x82u2\x90C\xFBf\xD5\xC3\f\x8D0r\b\xBE\x1A\x93(m\xE4\x17\xC2\xD8_`\xE1M\xC7\xEC\xFF\xAF\xE2\xF2c\x1A\x81k\xE8\x1Ac\"\xC0\xBC$?yL\xA4\xF1-Vp\xD6\xF7\x9Ft\xC653\x94\xFC\x9B\xF5\xF07\x1A\x0E]\xF3\xF7c\x17\xFE\v`\\\xFEK6f\x14\xFD\x8C{E\x89@J\x02\xA6L\xFE\xAB\xA2\x86yH\xE4\xF4\x8F\xB1\x80k?\x1A\xDB\xF4\xDA\xCF>\xDA\x8ECW&a\xFD\xF6\xCA\x8F\xCEV\xFE\x92\xC1(\xF8\xD7k\x93Fe\xCB,\x06\xFC\xF1\xE9\x11\xFA\xCBk\xFBf\x9Cm\xC2U\x16\x1A1\xFBW\xF7\xABE[\x90j\xBC\x88\xC0.\x1E\xFF\xAB\x87\xA6\xDC\xA3\xD6\x88\xF0`\xB5\xC2\xEDQ0YxK\xCFS\x81Y3p\xC1\xA6BjP\xDFhTz\xCEP\xB6\xF37\xD9J@\x1F\t\xA5M\xD9h\xA6>s\xB2H\f\xD6\xC5\xAC\x19L\x97\x86\xB6\xF3\x96\x88v.>\xCA_\x19\xFC\x9Fl\x03\xFC:c\xB3:R\x8E\xA8\xA1[$\xFA\xFAj\xD3\xAE\xDD\x02R\xD0\x90\xDD\xF9]\xBE\xD3\xCC\x8Cj%u`\x8C\x88\xB2E\xEE\xC0\xF70\xF6\xA5\xD2\xEC\xBFq4\xBBfkR\xAB\x14\xCA\xAC/\xAA}U\x86\x95\x8D\x80\xAAKJ\x92\xDA\xF7\xA4sH\xF4\xE3\x1B\xE0[L\xE9<\xDA\xD5nw.\xB4\x82\xCF/\fW\xA9%\xB6\x18\xFEl\x95\xEFX3\xABK\x8E\x0F\xB6\x12\xCC]P\xE4\xDA\x92\x96>D\xF7i\xAC\xD8\xAAZ\x0F\x92\xDEY\xCDO^\x01\xF7\xEB\x0EI\xB4\xE0\x12&z\xD9\xD3\xCB\xA7\xF3\xD4\xEC\xA5[[(\x90s\x17\xA8\xA0jF\xF3s\x9A\x06J\xADT\x9B\xD3\xC7a\xB3\xDC\xB7\xA2\x99\xC8.\xC7\x15*\xDF\xF9k\x99p\x98k#\xAAa\xBA\xB6\xB6\xA3x\xC1@\xF6s/\xB6\x80\xBAvK\v\xD4\xCAfD\xA2~\xC6\xC8^\xF1\x1C\x96Bk\x90\xC6eR\x84]\xFC)\xB8\x078\x99\x8D\x9E[\x19!\x1B\x00u[Dc\xC7\x81J\xC0\xFD\xA6\xD0\xB3\xEB\x19\xB4\xEF\xD2(+\xDA\xA7\xDE\xDA\xCF\xAF\x91^\xB2\xF3\xF8@\xFD\x12gS\xAF\xEF\x90\x80(@\xC373B\xC7\xAE\xAF\x88*\xB9\x12,\x13\x0F\x11\x8A\x16\x05\xA0D7FI\xBF\xB1|\x93\x18\xFBo!\x15\x14\xE7.\xEF\x11\xA5\xB4\xE8\xB8N\xD4\xE54bs_\xB0\x00\x814+{\xB3\"\xAB\xE9['\"\xD4xVt\xB8\x04\x8Cw\xB2\xE97\xA6\xA8\x1CU\x9FL\xC9\x8E\xAA\xE3\xE8\xF3\xC8\xCF\x93F\xFA\x14\x13\xC6aYS\xE7L6\xFD\x8C\x8ES\x07\x93\xC6\x9FT\xF5.Q\xC2\xAB\x15(\xBC\x95\xEA\xD6z>c\x90\xDD\xA9\xDF\xE3\x00:\xC6\n\xA7\x1C\x92-7\xBD6\xD9}\xC8\xBF\x7F(y\xDD-\r\xAD\x98k\x1B\xE1\x93W\xDE\xB25\xAD@\xF5i\f\xFF\\\xDE\xC2\v\xF4\xF1(\x83\xC1\xFE\xCC\xBC\xF7d\x8A\x89t\x0E\xCB>\x9E\xF4\xF2\xC7\xB4\xBAsy]\x81\x1C&,\x91\f\xF7\x1E\xBC'M\xA0P\xD9`J\x8E\v\xFE\xAB<\xC6\xD7\xC7\x8D\x18\xB9~=\xF2\x199\x11\xC9\xDA\xED\xB58\x1F\xFF\xE5\x0EL@qgW\xDD\xA8\xF5\xBB\x96\xF3\x9F\xAD\x16\x84\xEF|\xFCW]l\x11\xFFY\x0E\xFFu\xF1\xA5\xB6\x81\xBE\xED\xF9\x1AS&\xC4\x15[\xA9\xB1\xADk\xE9Z\xC5\x7Fk\xD0 Sk\xB5\xCA%\x1D\xEE\x1F\xF5\x93\x81i\xC5#\xC1-\r_r\xF8\xAF\xA1M\x01T\xBA\xC6\xDF2hkm\xE2\xB5\x92\xE4(\xFE\x13\xF1\x16\r\xD2\xF9gk\xC8Z\xBFW*\xE3\xCF\n\xE6\xFE\xC2\x87Y\xEB\xD7W#\xE4_\xA0\x8A\x8F'\x90\xFA%\x0E\xFFM\x8E\x8E\x96\x7F\xFE\x15\xC2\xDF=J\xFE\xB9\xB6N@\xF1\xEE\xAE\xEC\xBFq5\xB4\xE1QK\xC9\xBF\xE2\xA8\xE8\x1A*z/;\xE3\x85Vl\xCB\xC8?\x8A\xD0\xC8\x1D\xF0\x00\xEE\xEF\xCC\xA3\xA8\x8B\xDB\x1C\xE1Q\xDFNi\xA5\xAE\r\rR\xFE\xB9\xE3\xD4\xADt\x1A\xCD\xAF\xB6m} \xC6\x9F\xD1\xAF\x17M>>\xB0\xB6\xC6\x01\xD5_\xDE\x96t\xE4_n\x8A_\\\xAB[N\x02OJ)\xCA,>\xA0\xFA\xA0\xBA\x06\xBE\xED\xC8?y3\xC2\n\xD6)\tV\x03\xF7\x87\x8B\xB2\xBA\xC1_\xFB\x81\xE0\xBF\x1E\x93\x03T\x81\x1B\x9D\x1C|\x95A\x97%\xFF\x9E])0,\xB4\x11\xAE\x95\x9C-\x15\xB8\xF6\xE3\xEF\x1C\xC9\xFA\xD3\x84$\xF0\xCE\xCF\x92Zd\x95\x88kNj\"\x1F\xBEy\xC4\xFAmj\x9C\xC4\xB4CB\xAD\xC5\x18B\x86]) \x872\xF9\xB5\xCA\x7F\x02\f\x11\xBAt\xF7D\xAA\x13M\x15\xFEr)\xF7\xBA\x96O\xD7\xF8'~\xDE\xDE\xBB\xB7}<\xF8'L\xB0\f\xDC\xFD\xD3i\x1B\x97\xC9k\xE4Dp\xEFc\x92LG\x80\x82(\xC9\xBF\xC1{\x19aD\xB97\xA6W\"7$N\x06r\xEE\x97\xDB\xDB$\xA6I\xCE%\x00=\xF6\x9B\xF2v\x9BYn\xD9\xB7\x801\x0E\xFF\xDD,\xE4_`x\xBF\r\x0E\vF\xAC_%\xFF\x1C\xFE3n\x7FW\xE5d\x86G\xC8\xBF\xEF\xD7\xC3\xBF~J6\xFF\xCDf\xC0\x1Dm\xCC\xA8\x14`\xE0\xAA\xA8!\xAC\xEA\xAF\x8C\xD8\x7F#\xAF\xFD,iTs,\xCEg\x7F\x9A\xF3\xC1\xD9[\x801gi\x8F7\x7F\xE70\xFA+\xB3\x89\xFF\xC6\x94\xFB\x81\x82\xAF\xF0K\xD6s\x14-\n/\x87\x0E]\xB7\xBE\xD1\xC2l[kz\xA5\xE4\xA3\x81e\xBF\x14w0&\x04\x89za\xDC\x07\xB8W\xE1e.\xCC\xDF%^\x9B\xACd\xFB\xABl\xCC\x01B\x13\xFC\x17\xB2j\"8\x12\x11\xEF\b\xC5\xF8gH\xFA\xBD\x821e\xD9\xFCW\xAC\xD6\xAFY\xC4\xD4\xFE\xEB\xE4\"+]M+\xCE\xAC\xDF\x05J\x7F\x19\xA17\xB9\xEF_\x82\xE2\xCE\xA5\xD9\xFB\xEFX\x06\xD4lKj\xA6\xB3\xFF\x8A\xBC\x98\x85\xA3L\xC5[(\xE0Y\xEC~\xF4R\xBA\x06p=\xCEY\xDF\xB8\xE6K\f2\x9Daa\x89\xD8\x7FO6H9\xE9\x9EE\xAB\x91\xF4\x979u\xED\x9D?I\xA3\x88i\xE6\xA2q\xAE\r\x83J\xFE\x1DF\xBDZ\xBF\x1E\xC0\xB5\x0Fu\\\xFE50.\x00\x94nVw\x8B\xD4\x9B\xE8\xE2]\xC5J\xFA8\xFA\v'\xD0\x95\x0FH\x86\xBB\x05\xEE?6g5-\x9F\xFD+\x11_R9\xFE\x9AFUZ~\x8E\x83\xFD\xA49\xDEX\xE9\xF0\xDF5\x1C\xB96\x11\xC8\xCC\xA6C\xE1\x1A`\xCE\xC7\x1B\xB3\xE97\xAF\x11xk\x1F3\x9A^Q\xFC'\xD0\xE2[#\xD6\xAF\xF9\xDA\xB3\x96\xB1P>}\xC1\x02g\x1F\x04\xC6|K\x04A\xBF\xC4\xD4\xE6\xFF\xD6>\xC6\xF9\xAF`\xE2}2\x12k\xCCa\xF0\xB5\xC0\xF5\x17\xE3\xE5\xDF?\xF3\xE3\x90\x85k\x1A\x8D\xF4kO\x7Ft\xD6\xFFo\xD2\xA83\v\xEF\xEE\x93\xDBl\x130f\x15\xED\xBFu\xBFg\x1Cc_%\x19\xB3\xE9-F\xAB\xB1\x80O~\xCC\xDF\xAEt\xF8/\x9C\xC5\x7Fd\x15\xE2\xC7\xA7\xB4\xF63\xEB\xF7\xE2q\xF1\xF8+8\xEAG\xC1\xBE\xE0\x92^\x8C\xC4\xAB\xEE\x11=P\x1C\xEDO\xAD\xD86d\x95\xA5\xF9\xEF\xD0\xA7R\x03\x1CG\xAB\xD2\xB3\"\x19\x10\xEC\x1E\x91_\xCBF\xC3\xE6q\xF3-\xDF\b\x1F\xB0\\[\x1Eu\xBE\x95\x89Wv\xB0\xB3KwP\xF4\x8D\xD2\x99\xCDq\xAC7:r~\xB6z\xC7\xE1\xFA<f\x8F\xF26C\xCF*|\x9D\xA5\xBE)\xFA\x8D\xED\xE5\x82\x16\x9Ay\x9B\xED\xFA\xBE\x95\x8DW\x85\xCC>\x00\xD2\xE6n\xDD\x92\xA1\x9F\xEB\x1EG\xF3\xB5G\xD3Y\xAA\xBA\x8E\x1B!\xE3PUv\xDB\x86s\xE8\xC7q\xED\xC1\xE3Y?{A\x02'\xE7\x0F\x93\x8F\x97\xFAP,:O\xBC\x8E\xCCfXWb\v\xC9o\x11,\xF8\x1AsP\xD68[\vV\xD3\x00E\xEE\x14\xFA|\x8Co\xEA\xDE\xCF8.[#\x9C\xCFK\b\x1A\x89\x9B\xE13\xF5=\xF0V\x13B\xC7n\xFC\x1E}\xFC2\x83\xE6C\xC9\x1D\x1C@\x93\xA6\xCF\xEFr\xDC\x82L\xCB\xA0\x94\xA3l\x93\xBA\xA05}\xD4\xEB~E\x14`\xFC[\x89\x85V\x89\r\x92v\xD3\xE5\xDB2\x9Dgi\xD3\xCC\xA8\xBF\xA3\x9C9\xEE\xECn\n\x19\xE8\xD1\xAF\xE8\xD7\xE4\xE8HC\x99\xB9,0\x1F\xC8\xFC\xCC86\x9A~s\x9F\x1ChB\x89\xF0\xE6\xAE\xC9\x9A}\xF3\x96F\xE9\xEB\x85\x7F\x97\x89\x1A\xE6\xDC\xD6\xE4\xA4\xB6\\\\|\xF21\v+\xFE\x9D\x8C\x03n\x1B\xF0\xDF\x14\x17\xCE?*\x80\xBC\x93)\x83\xD3\x8Am\xC7\x16\xF9pC\xEE\xA0x\xE4_\xE5\xB0\x19\xE3\xA6R[\xCF\x94,%=\xB1\xD3\xB9U\xA7\xDBCUR\x80\xDB\xC8M(\xFC\xC9K\xD9x\x95\xE8\xE2=\x00B\xB3g\x9C\xF6\x86\x1D\x02<z-\xE9Z@\xE1\xE9\x11\xF4+\xCC\xE6\xBF\x93\xCE\xBB/\xAAv\xF7\x9D\"\x8C\x1F\x90\xE8\x04\xF0\xD6\xE3\xD4\xE6M\x99\x9Fi\xCB\xE9\xBF\xCF\xB3lFc\xCA;e\xF3\xDCB\xCE\x7F\x85\xF2>\x0E\xBF\xC8\x81\xD3\xD5\xB6\x91\xC0\x9C\xCD)\xFC\x85\xA9/p\x95e$\xCE\x88w\x9BSX\xF6\xA2\xC5\xEF\xD2;\x04TQ\x9D\x1D\xD5\xDB\xF8s\xA7SS\xFF\x81M\xFF\x91F\xF0\xDB{\x04\xFF}\n\x18-\xA8\xBA\xFB\x04>\x17W\xE3\xE7]\xF3\xEB\xD3\xE7\xF0_\xB1Ea\x15Z\xE5*\xE6~o\x04\xFF\t\x03\x93%\xF8\xEF\xF6v\xA7\x02\x12\xB2\xF8o\xD6\xFF\xC0\x7F\x99\x82\xA7u\xE7\xF2\x9F\xEA(\xEB>\x8D\xDA\xC8\x03\x99\x1CB\xEDXv\x9C\x02\xF9\xD5\x1E:\xD9\xA4\x82=\xEA\xB3.\xD9@\xB3\x1A\xCB\xF9\xAF\xE48g)g.%\xBD\xDA\xE5\xCB\x85O\xEEx\b\x7F~\x84\xC0\x99{\x19P\xFC\xE4\t\xC1M\xB7\t\xFEs\xCB\xEB\xD6m;\xB6\xC8\x8F\xAA\x7F\v\xF8\xD5\xC2\xD1\xE6a\xDC\xAE}\x0E\xFFEG\xF0\x9F#(\xA4\xD9K3\xFF\xDDv\x97\xD6d\xE3\xD5B)\xFFh\x194\x8Cs\xDA[\v\xBB\x99\x80\xFF\xE7\x91\x7F\xAE7\xCF\xBB~O)\xFA\xD5:]H\x95W?\xA7\x16K\x0E\x1E\xCB\x8C\xA2}e\xB4\xD9\xE1\v\xEEEA\xA9\xE4\v'\xB5<\xB9\x89\xA4\xCA%\x96\x16\x86\xFF\xDFR\xEAV\x89-l\xED\x0E\xE1\xAA\x1D\xB7\xE0\x00\x1A\x8A\xA9\xBE\xADq\x82\xDF/\x13\x03\x10\x97\xF4\xC1-\xE5\xDF\x97\x8B\x83\x03\xF7a\xDC\xC2\xFF\x10pd5\xA9\xF1%w\xAE\xC2mR\xD9\x9E\x03\xF8\x1Fr&\x99\xA3\xDEM\xB2\xB4\x16R*or\xA0Ls&\xC0\x07\x85\x87\xF1\x06\x95\xFBv\xD2\xEF\xFE\x8B\xE50%\xFA\x04\x06\x1BY\x84rL\xB6M\xFA^\x87\x06\xAA\x87\x8C\x96\xC6\xB5\x12\xA0*\xF97&\x85U\xED\v\xB3Z\v\xFD\x89\xFE\xBB#C\xBF\x92_\xFD&-M\x1Bc\b\xB9\xCA\xA7\xFF\xBBI\xFCo\x13\x93F\x13&\xFD8\x84;3\x1D>'\xD9Z\xCF;4\xC0u\x1FXX\xF1n\x92 \xC02`\xFCf\x9A\xB3\x8D\xD7)\x04Y\x04]\x008\xF1\xA3\x97\xB7\x02U\x1FI\x94\xD5\x04\x18=\x98\xF4d\b\xEF\xB2\xDC\x13\xB2gK\xD5\xC7Nt~\x81\xE2\xBFk\xC5\xC8Zq\xB5\xED\x9A\xE2\xCF\xC6\xABb\xFF\x8D\v\xC9u\xD4\xE9\x1CmJ\xE4@1Y\x14\x183\xD2v\x9Es8\xEB\xC3\xBB\x0E\r\x96)\xF9W\xEBt\x92V\xF7\xEA\xF2\xE1\xDD\xEE\xA7\xCEiM\x97\xF9-\x8A\xDC\xB7\x8E\xC7,Ky\x13\xC4\f\x00|\xED\xDAF\x8Au\xD1\x80k\x8F\x9F\xC0\xBB\xCCA\t\xD7\xF6\x1AAa\x98\x9A\xFC\xC5\x14j\xEE\xB59\x04\xE5\xCF\xFCZ\xE2\xBF1)a91\xA9\xF9+\xE9\x07\xCF\xFE\xC3@\x1A\xDE\x87\x06\x85Ty\x95A[\x89k?>\x81\xD5\x8C\x1E\xD9\x989\xC0\xD8\x8C\xDF\xDEa\xF4\"\x9B\xDC\xB2Z\xF0\xB5^wYC6^-8-\xA8A\xD0\xF2o\xFD\x96\xB3\xFF\xBA3\xC8u\xCD\xB9\xF2\xCF5+\xEB\xC32\x87\x06_\xCA\xAC\xDF\n\x15\xF1\x96\t2^\xA0\xBBF\xB5\xB6\x1A!\xFF\xAEt\x9FT\x01%\x14a\xAF\xF4\x97/m\xA1<\xFF\xA8\x16F\xF1\xAEYX\x90Q\xCB\xFCQ\xED\x1Ea\x06\x1A\xBB \x847\x8F\n-\x83\xEF\xBF\xEBh\xFD\xD6\n\xB1>\xCC\xDC\x92\x91j\xDB\xD6oi\x80\xEE\xAA\x17C\xDFN\x9D\x9F\xC6\x05\xF7a\tss\xFEs'\x81q5\x8E\xFB\xB2@M\xF7\x1A\xCB\xB8\x84\xCFy9\xC7\xA1\xF7\x9D\x83W\xC7l\xC7\xAF\xF8\xC77F\xF3\xDF\x18N\xA6\x82\xF3\xF0\xDF\x98,\xC7\v\xFE\xFD\x9C\x10H\xA3\xE9\x1C\xFE+\xD8\x877Y\xC19\xFC7b\x1A\x8Bo\x91\xF0\x95\x16\x8Eb\xB37\x9E\xE5\xA7^\x1D5\xEAp\xED\xA9\x13x\x93`\xAE\xC0\xE2Ic\xD3\xAFi\x80\xAB?&\xAES\x16%1\xCA\x98U\x02\xF9\x9B(\x90\xDB\xDD\x9B?\xFB\xE8\xEC\xF7\xB8\xBCjT\xE2\xDA8\x84\xAB?n\xE4\x83*\xFE\xBB\xEE\x8A\xED\x17\x81\xD7\xC5\xE3\x7F\xF5 \x03\xF3\xFCC\xF6\x7F\x83W\xF5\x11\xAE_\x81*\xF5L2\xAD\t\xE6S\x9D\x81Td\xB0\x9E1]o(5E\xB5(\xB3\xC5\xF2\xE9\xE4\xCF3EL\xDB\xFC\xDAL~\xA3~9\xF5\xE7\xD5-\xAAn\x17\x91\xBFu\xAB\nW\x13m\xEA\xA8C\x033\x14\x9F\xDB\xC8\xD7:\xDFgk\xA4\xD3\xDA\xB9\x1B\xCB<\x7F\xEB\x9EQ\xBF\xD2*\xCF7~n\x16q\x18|d\xE3\x9A\xEF\xBF\x00\xFD\b\xBC4(\v\xE4w\x17\xC8!\xFE\xE6{\xCB\xB3\xE8\xA7\xDF\xFFzH\xD0\xCF\xA5\xE8\xE7w\xE87\xE9\xC1R\x13\x1EA\xBF)\xAF\xAF\xCD\xA2\x9F\xF7_\xB2\xE8\xD7\xE0\xA7\x16\xB5\x82~\xC6\tI?\xEF\x01~\xB5\xD8\xEB\x18\xD7(\xE9w;\xE3\xF4\x9B\x9BT\x889\xCF\xD6\x8E\xDCI\x0E\xAD\"\x06\x18Z/5\x8F3^.\xEDJj\xCBUm?c9\xD1\xEF&\xBF\xB8k\xCD\xAA-r\xC9h\xF8Z\x11\x12\xAF>r\xDD[\xCC\xA8y\xF2kk;0\xF9\x17\x9F6\xDD\xB8\xB3\x17\xB0\x8A\x92\xB2/E\x9F$\xEE\xC0P\xDF\x9C\xA4\xF1\xD8\x9Fi\xDB\xF9\xF7\v\xB4\x14$\x9DuE\xBBL}kU\x9A`W\xC3\xADLm\x8B^o\xFF\xC0\xE5\x15?'o\x9FW\xE5n\x8EM\x02gE\xEE\xF7\xC9\xFFO\x1A\x1E\xCA\x8C=\xF5\xFC\xF2\xFB)\x84v\xC2\x07\x9C.\xFA?;=O\x81\xB3;O\x03?a\xDE\x03\xD4nh\xD3Yir\xE1\xDB\xA79g\x07&\xDA\"\x1E\x1D\xD5\x1C-\xFEYN\b\xB5\b\xF5\xEA\v\xB7RJ[\xA5\r\xDCw9\fr'\xCDI_\x0F\xE3\xB4R(\xF5}\x84qRtq\xD9\xDC\xE8<\xAD\x8F\xA8\xFDgT\xDE\x96\xA9\xE7\xDD\xDA\x01_MQ\xF5}>\x1B\xA8\xDAB\xA1\\\xB6S\x89\xB3\xB0\xD4\xD5\xBD\x87\xE9\xF1o\xF1\x0F\xB7\xAD\xBD\x00\xFF\x11\xCA?y\xBDt\xD4\x7F\xF7w\x92-\xCE\xFEi(\x8B\xFFZ\xB7\x04\x17yl\xAEh\xBA\xDA:3.SJ\xF1BeK\xD8/b\xB7\xF2\x02\x8B\x8F\rm\xB0\xA8\xFA\n\xDF\x16\xBD[\x1A\xA4\xDA\xC3\x15\x9B\xF6(0\xC4\xDC\x16\x82\xEDQ\xE3L\\v\xE3!l\xFA\xEA\x19\x8CK\xC2\f\x986D+\xE6\xE2\x12'\xAA$l\x1Bg4@\x9B\x8D\"K\x88\x8F7\x89\x91:\xAF\x80V\xAF\x00\xB5QO\xFCgS\xAD]\x93iv\xBD\xFF\x01\xE1\xB4\xB0\x1Bd\xE0\xA7\xF8\x18\x84\x8FIo\x81\xE9\xF76\xF4\x10\xFDl\xCE\x7F\xF6\x8B\x8A\xFFd\xF3MO\xE9\xD0\xAEPT\x8F<K\x1C\xF6\xFF'\xFFI\b\xE5.j\xB8\x8D9\xF4\xF3m,z\xE97\x05T-\xC5\xE5[\xAF\xE0\x12\xD0J'\x9B\xFF\xDF\xF2~\xAA\xBE\x8C\xCA\xEEDM\xA0\x87\xBF3c\x14E8v\x10\x8E\xBA\xBFvG\x94\x83\xA4\\\v\x03~KO\xA4\xB3\xF8\x0F\xE1\x04\xAA\xA2\x88L\xCAe@\x19\xB4$\xFEO\x91\xAD\xBC\xAAy\xB6\x9E8\th\xFD\x98g\x03\xF6\xE4\xA4\x91\xC3\x7FW9|0\xA9\xBD\xF3eU>\xB7\x87\xE8\xB7\xD0/\xCA\x87kM+\xDAvI\xA7w\x9D\x10sB\xFD\xD5\xE6q\xF8*\\\xDD\xC3;O\xDE\x1A\x81\xEF\xA6O\xAB\x9B\xDB8g?\xA2\xF8O\xAE_O\xA9\xEB\xF8\xDC\xA8\x91&\xF9\xF7\xBB\x86\v\xF0\x1F\t\xBCE\xCA\xD1\xFC\xDD;\xA5X\xFF\xB4i\x85\x83\xB7\x86;[\x97.\xBB\xED:[[\x06\xE46t(-\x9CRV\xA9(|8!r\xD7\xC3\xB1\xF0\xB2A*$T\xD5\xCD5PoC\x98\xBA\x88\xD3\xD1\xCA'\x19cX\x83\xBD\x07\xA3F\xBF\xCC\x88\xA4hW\xEF\x87\x1F!\x10E\xDB\xFB\x07\x1A\x81n\x14\x8EG\xF1\r\x8E\xFC\x9Bg\x1B}\"\x14s\x9A\r4o\x11\xB32:w\x95YZ\xC3_\x14\xFF\xBD\x01o/\xF0\x9D\x9DQQ\x1E/q\xC7e\xBB-'\xCEW;,\x82\x87\x01\xAD\x13\x13z\xA5\xAB\xD6\fxS&&\xBFT\xD4T\xCA\xB9\xAE\x93\xE8\xC7\xA5\x80Z\xBF)kW8\xAAG\xC8l\xF3\xE5\xCF\xA3\xE7\xA7\x9Fh\xAD\xF6\xA8\x02\xA8\x12B\xE5\x16u~\xC7i\x99S\xEAjmXv[\xA9\xAD\x15\x03y\ro\x88\xDF\xDD`\xAB\x8Eby\x15[?\xC3\f\xFEx*\x97l}\xA3\x94lUe\x8B8_\xE5\xDDzL\xD6)\xE22\xA22\n\xFC\x05\xDE\xC3XSf\xEB\x9D\x03\xF2!S}\xE4\x86vL\xB6Q\xEF\xF2R\x9Bn\xE34\x86\x95\xFC+\x84\xD9\xA8\xEF\xFE\x94q\xF9\xC7/YS\"\x8C\xB1z\xE7_n\xB0\x8C3S\x95\xFC{\x86Z'\xB5\xD1c\fXz\xE2\xE0\x93u\"\xAB\xF6\xAB\xFBE?\xA0|\x95d;#*\x9B\x84\x15L1\xFDB\xFEU\xF1}\xEB\x85G\x92r\x03\x97\xF4\xF3LI\xC7\xCA{\xF5\bY\x94\x1A\x1E\xBD\x00\xFF\x91\x95\xE9\x8D\xFD\x92\xBA\xD6\x17\xA5\xF6\xFF\xC7\xA6w\x1D{q\xC0(\f\xD46\x84\x18\x07\x94y\x01)\xCE\x82Lf\xA7cF,\xDC)\x1A?\x15\xD4\xB4\x99]U\xFC\xDD\xF5K\x88~\x81 \xE0\x95`\xAF\xEB\x12\xAA\xB3\xE8\x89\xA3\xE2\xA0m|&\xED\\\x04\xCE\xBC\xBFM\xC3\x15\x855\x1C\xB1\xF9)\xAE6\x04\x94\xBA\xB0\x06\x97\xF6\x1A\x837\x01\xFA\xF3\b6\x02\xEBK\xA9\xD09\xF4\x97\xA6\x96Y\xF0+\x8B\xA1\xB1\x8CV^[\x98\x89*x\xE9\xCE\xA9u\")\xBB\xBE\x9BQH\xADGt\x06b(O\xCAJl\xC5\x0F\x84\xAF,\xA6\xF5[\xCA\xB9.\xD8\xA1\xBC\xE1j\xFDZ\x91\xE3s\xA2F\x84\xE2w\xFF\xFD\xB7\xBD\xE7\xA7\xDF\xDF\x90)g\x9B\x02\xA82X\xDF\xD55\x9E\x13V \xEDI\x05\xAD\x8D_Yx\x1D3\xB6\x03\xDAJ\th\xA62e\xF6\n\xBD|S\xBF\xA8\xB3\x18\x8E'\xB6'\"\xD4{ \xCEA\x92\xF7\x1B\xFD\xAA\xA2\b\xD0\xBF\xC7\x07\xDC\xCB\n\xF7\xA1vjT\xAB\x9B-\x19\xBD\x96\x13\xB1\xAC\x1E\x05Q\xBCi\xF2u\xB4\x97\xE5\xEC\xC3\xBCq\x82~F\x043m=\xF0\x16\xA0\xEB\xB8\xA1\x97\xD3\xAFQ\x14\xDEZ\xFF\x97JKk\xB8K\xF1_'\xD1\xEF\x12\x8F\xB4\xB1\xC5\xE6=\x10\x10r\xF7\x9E\x80\xB0\xC2\x18\x02'wp\x8E\x17\xFC\x17\xDCp\xC5\xAD\xBB\xE1\xB3\xB5\xEAR\xCEu\xF3:-\xC9\x7F\xD2\xA3[h\xDDc\xB2$\xD7~\x95\xAB\xF6|\x07A\xC6\xD7\xF7)\xFE\xFB\x83\x14K\xD7\x7F\xF3?\x18\x8CM\xF4\xE1\xFD}\xDF\xF8\xE1\xEE\xBFy\xB0\x11\xDF\x04r~\xF4\x81\xDC\x7F\x1B\x01\x11-?\xD1B\x03\xA8\xF0cYy\xDD7\xEF\xA0\x12\xCCe\xA1\xC3\\\x1C<:;c\x9D\xA1l\x81\x87Y\xDEa\f\xBFh\xE9G\x7F\x99\x85u=\xAF\xEE\xE0\xB4\xCA\x19\xCFi\xB0\x8F\x8Di\xC3\xBF\xBE\x90T\xFB\xAFi\xEB+\xE7\x03\xC6\x19\xA2\x90K\x13\x02\xC1X_\xAA[z\xA0+\xE3\x000\x18\xF0u\xC2\xEC\x972c\xDA/~8C\xC8\xBFM\xEF2J\xA3\x18C&F-\x86+U\xD4\xC1/\x9E>\xB1\x1D\x98\xFC\xDA@\x13\xAD_czr\xA4\vK;\xBB\xE9\"\xF8\xBAx\xFC5\x1Ds\xD4\xA2\xC9\xD1\x18\x87`Y2qH\xB2\xAE\x0E\xB5\xE2\x05\xC6I:1\x1E\xB2\xCE\x93\xE9$\xED^\xE0`\xA8\x94_\x13$eL5\x1A\xD2,\xFA\xF1C\xFC\xCB\xE1\xA6LM*\r\xA3\nT\xD5g>\x9A\xA34\x05d<\xC82<\xD1jr\xF0xe\x90\x9C\xD4\xD4\xB5\x80:\xD9j\xFF\x9D#\\\xCFvkg \xAFmQ\xF6\xA4\xE9b\x8CDi\x84\xDFyZ\xDC~\xE8\xA1\xD3\xA8\x02\xBE?\xD4?\xD7\xD6R\xFE\xEB\x1D2\xA1\xB0hh4\xFDr\x93\xDA\xD0|\x9F\x054\xE7\xBE\xC7\xD1\x98\xAB\xC8\xD5Lw4\xB9\xB7T\x9EL\xD9\x8ABOt\x12\xAB\xAF\xB3\x8D\x18t\xED\x87C\x14n<\xF9\xE7I\x16j6z\xB9(\xD5\xE6\x0F\xE53\x18't\x18\xC9\xE1j\xE4\xAEq\xE8\xA7\rq\x82\xA5\x9Be\xB5\xE4z\x9C\x12\xFD\x11\xB5\x94\xE9\x15\xF28\xC9\x1F\x04U\xB8\x92xp\xB9|Wx\xB6\x93\x1Ay\xE8\xD3\x93F\xCF3D\r\x0E-\xDDp-\x1A:\x87~Z\x8A\x0FU\x8F\xCB\xEEOf\xE8g!\xD3\xBE\xB2\x99\xE9\xB65\xDCbiC\xCD\xAE\xCD)4\xBBZ\x92\x11~\xE7:\xDD>*\x8E\xF9P\n\xEF\"\xDF\xD33,\xCDlv\xEA+\xCE\x87\xE7/\xAESL\x05\xB5\xCAh\xDC\xA8\xE6\"\xFE\x9B?\xCF\n\t\xFE\x9BO\b\xD2w\xCB\x80K8w]\xB6\xDE \xFB}\x16(\xFD\xB2<\xA9\xF7`\xF2\xAF\xBF\xEE\xA2>$}\xE1\x99g{\xE6\xCF\xB3\xF5\b\xE0\x1Dp\xF5\x03\xDAk\x1C\xA1\xADkR\r9I\xDFuq\x94\x1A\x9B?\x87d\xBE7\x85]\"r\xB9pOZ\xF8C\xF9\x17\xC3\x8CT\xA1<\x11\x8CwZ\xF2\x9F\xA7!=\x9F\xB8\xB3\xC3\xD2c\xD3\xC9\xD3z\x03\xA1@\xF7\xD3\xAE\xAC\xB6\xB2rK\x8D\x03s\xBBS8\xF6\xBC\xE5\xF03\xFF\x85\xCFiV\xC3\xF4\xF9C\xE6\xE4^\xCD\x95Wu\xAC\r\xF3'\x1F\x1B\xFBN\x16\xFF]\x97\xCB\xF9/\xEF\xFB\xE9h\x17\xD3R\xFE\xF2\xA4\xC3\x7F\x9EG\x86\x12\xB2\xB1\xA8\x1E\x11M\xA3\xCB,\xC5\x7F\xD3\xFF\x10r\xF8O\xB71\xF9H\xE9\xD0\x1E\xB1\xBA\x18\xB9t9\xFF9eT\xCAl=\x06\xBDn\x8B\xE0\xBF\xEED\xB9~\xB8y:\xA7)\xDCK\x87z\x00=\x1E\x13\xFC\xE7Un\x932P\xA3f}\xEF\xB0(\xFF\xEA\xA9\xC7A\x91\b\xE8\xF1wt\xCB\x87\x02D\x98'\xC3\x7F\xDArY\xFA\xC53\xD8I\x84\xD8\xC5\xAF1D5\x89\xF8F\xBA\v\xAE\xFFH;~?g\xA3\xF7\x01\x15\xFD\xF5x\xB1\x9BN\x91j^VG\x18\x9By\x07\x82\xCD~[\x1B\x1A\xEEx\xF24\xE6\xFB+R\xD9\xFCW&\xF9\xCF\x1C\x9E\x03\xCD\xF4\xCF\xB5\x1D\xFE+\xFC\xA9+!k\xE3\xEA\x11*\xDD\x84p\xA3\xE6\x1A\xE6\xF71?\xA8\xAD\x11}\x9B\xAB)\xBD\xCB\xB7x\xC0\x15\x931\x13$L8\xFF9U\xBE\xE66\x1A=\xA8\xFAp\xC0E\xFE\xD0\xCE\xE7\x8E\f\xF6\xCC\x0FF\x8D\x18_\xBF\xAE=\fHw3\xDD\xAA\x19f\xBA\xE2\xBF\x8A$H\xCBM&\x12\xA2\x82@\n'\x85\xB9)\x7F\xB0Ch(a\xFE\x18\x85*..\xC4\x9F\x9B\x8B+2\x85\xB7\x8A\x8E\xD0\xDD\xED\xB6\x11I0\xCF\t\xE0\x06*8\xE4\xFEAB\xF9]\x9C\x83?\xE4\xB2\xC5)P\x7F&Y\x93\xC8\x93\xA2\xFBP\xF4\xF3,\x1AZD\xFC7\xF9X\x1B\x86w\xF6\xEFI\xF3\x85#\xF9\xAF\xAC\"\x85f\x96\xB78\xBD\xAB\xBCWK\r;\xD5j\x87\x99\xE7WCbI\x9A\xCCH\vo\xF6\x1C\x18i\xB2\xC8\r\xBFx\x05\xCD\x99\xB5\x1F\xA4\xE4\xF2\x8A\xBDyC\xC3,K\xFEqa^\xA8\xE8\x17\xEA\xE5\xFCw\xCB\xFC41\xC8p\xBCpO\xA4\xF9\x85\xA8.l_\xFC\x1A-}\xF0\xA6\xFE4U\xF6\xFA\xA5\xF4q\xE3\x9D$`l\xEA\xF9\xB9J\x1F\xEF\x16\x1CQx\xA3\x8C\xEC\xBF>\t\x04D\x85!\xEFi\x15\n\"J_\xDD\xBB\x9E\xE6\x92\xBA?\xA9\xF7\x9CEaH\xB4\x90\xEDg9\xED\xDF\xC4\\\xFB\xDC\xF5[\xF5I-N\x1DL\x02\xC7\x95\x9A\f(\xB4\x8D\xFB\x98gQ\x16\xFF%\xDAC\x1B\x96\x01\xE6\x06\x1F\x97U\x11\x84-\x06\x9B\xE5}\xDF\xB5+d\x83\x95:\xECm\xC1\xF3\xA0uPu\xE8\x8Et\xAA5c\xCD\xE4\x88\xB4c\x17eFxSGc\fz=\xC6-N\xC5\x05\xF3\xFBDqIND\x87\xFF\xCAm\xBD\x07U\xFD\x03!b\x90h\xF9\x87\x83=\xF6\xF4$5\x97\xF6E\x9E\xE7\xFCw\x90\xE5-\x0E\xBE(*\x079\xFC\x07\xE8g\xC2aU\xC1b\x97h\x9A\x95?\x18\x8B;\xFC7\xCC\xC8H+~\xC6Y\x9E,\xB3\x9E@\x9A\xA0`\xF7\xB3\xB6\xDE\xD1\xC98L\xBB\x8A\xBA\xD1\xBAS\xD6\xB9\xFCw\x0F\x10\x0E\xEF\xC3s\xE1\f\xFF\xE5\x1F\x10\x853\x9D\xF5\xCB\xF9\x0F\f\x93\xFB,\f\xEF<5\xD8\n\xE4\xB7\xFA\x80\xDC\x7FLc\xEE\xF4\xD3hf\xDEEC'\xE7\xD8F\xBA\xCAy<\xCD\xAC\xF0\xC1!\xB1$\xC7\xF7\xEA\xDB\xE5\xFA\xB5\xF0B\x88\xAF\xA3\x8E]\x14\xBC\x9E\xB7\xF8\x07\x95dp\x9A\xDA\x9A\x9F\x16\xF4\x9B\xDC\x8B\x94l\xFE\x95?\xC7\xD1\x91\x8C\x0E\x98\x1B\xBB\xC2\xC4\x7F\xDD\xCF\xD5%b\xC31f\xF4\xF0\x8F\xA9\xBD\x9C\xFF\xE2\xCC\xBBf8F[\x80\x90\x7F\xCCx\xA7\x8B\x8F\"\xE9\x97\x9F\xC2\xF0N\xD1\x9F\xB8\xBDG\xDC%'\x84\f\xC3\xC9?\xAD\\\xF1$\xFF\n\xCF\xAE'\xC1\x13\x1B\x9B4\x12\xCD\xF4-\xDFM\x13\xCC\x9D\x9FF\xD9(g\xA0g;P\xF1\xE1*t\xFF8S\x13\x90\xAF\xF8,\xF9\xE7\xA9\r\xDD\xAD3-\xDDlV[\b\x985\xBE\x14P\xF0<g\x86\xDA\b\\\xFFb\xC3f\xD8\xE0\x1A\xAB1-P\xEA\xCAD\b\xE1aK\xF0s(j<%\xD6\xEF\\\vI\x92\x7F\xC7\x9F\xA3\xAET\x9E\x90/\x00\x181\xE4\xCD\x8C\xB4\x9D\xCC\xE6?\x8E\x93\v\x95\xA6fp\x9CgnJ\x1C#\xFE;\xD1\xF2\xED=\xB1]\xF3\xA2\\)s\x15\x05\xF9\xFAM\x9Fby\xB5M\x9F;\x86\x19\xCC\x8D\xA2\xFE$`|4,\xCB?\xD4C\v\x89\xFD\xF7\x1FcB\xAA\\g\x03\xFF\x97e\n^\t\x91K\xC8\xDA\x9AG\xFC\xD7\xBF\x1D\xB8}>\nk\xC5n:\xCC\xF2R\xEB\xB3\xB2\f\xE4Zm\x04\xE6\xCE\xDC\x87\x93s{\x81S\x99\xB8\xAA\xA2,\xF9W;{\xBCa\x19\x81\xF9\xE6\x8DIL2k|\xFC\x06\xD9\xCB\x80\xF7\x9FM\xAA4\xD5\xCC\xC0u3\xE87W9\xE3\x96\xF358\x9Ef\xEAe\xA8\x13\xDA\xAB\x914.\x17@;\xEF\xFD9\x19\x15\xB6\x07_H\xFE\xED\xE5_`Y\xFC\xC7\x95\xBB\x91\x85u\xAA\x92\x81\t\xC4 ^\x86T\xE5?FDZ\xFD\x99\x95\xC2\xCD\xC4\xBCk\xA4\n\"\fII\xAD\xAD\x8A\x01\xED\xB2\xB6\x8D\x16\xA1~\x86\xF4\xAEr\x1C\xFDIDi\x18_q~F*\xA7\xE4\x9A\xED\xFC\x94K\x9E\xA4\xDC\x07\x1C\x16\xDC\xA4\x03\xDA\xA0(\xC8\x9F\xAD\xFFm\x07\x8C\xF7V\xC1\xFB@T\xF41\xE6\x7F;\x01Lr\x14\x11\xE6=\xFB\xEB?\xBC\x90\xD4~\xDF\xCCg\xF0\xFE\xE6_\x9C\xBE\x18\x05}\xF1\xF8k9\xF4\x11\xA8\xB2M\xB7K%b5\xB3\xAA\xD0\xD6[&\xC0,\x93j=;n^\xD7\x85\xFC\xB0T8J\x96\xD3\x82O`N\xE5;f\xA6\xBA\xA4%\x93{\xF5,\xF0\xAC\xCD\x1B9\x8C\xA9B\x90\xE9\v\xCD\xA5\x9A\x161\x8C\xAE\xE1\xEC\xDC\xC7\x12Uk\xDA\x92i\xC4.\xCBA\xBDY\xCD\x8B\xCD\x80n2\xDF\x88;8'\xCC\x84\xBA-\x99\x02\x8B\xBB\xB2N4\x9B\xC9\x8CKRI\x87\xF1\x0EuS\x15\x01p\xCFo*%\t\xB7\x03y}\xA5\xCB\x95\x8C\xBDu\xAF\xA0\x9F\xC9\"\xCA\xCD\xEBM\xF6\x04\xA9\xBEr~\x12\x16\xF2U\x81z\x98\x8D\x92~\xA5\xA6\x8D\xA8\xB0\xD5s|\x15\x80\x9E\xB2*\x1E\xEAe\x91*\xD1\xC3\x80?\x9E<\xA0\xC7\xD4sO[\xD4\x0F\x97\"\xC0*\x98~\x8FL\x81\xCCO\"\xCE_\xDA\xA6\x03Z\xB0\x94\xB2f\xF2\xC8\x02\xAE34SGY\xF3PJ^W\xD1/R\r\xA0\xA7\x82\xB9\xD6DC\"\xB2\xDC\x95\x12\x19\xB9\x15L\xD4\x84^C\x15\x1D\"\x01\xCF\xD43>24\x88/\xCC\x95L\f5\x9D\xA2v\xF3\x93\x9C~\xBA\xD53\x1Ca\xF8$\xE8=>\xA4\xE8\xA7\xA7\"\xF33\x8E\x8C\xAA\xA4\xDE\x80\xB0%\x1D\x00\xAE\xB8\xE7\xECQ\x90i\xB2\xAA\xE2\xEC\x19\xA5#\r\xA6L\xE4\xFE1=\x1C\xE1\xF4\xE3\xBA@\x00\x9A\xD5\x1E\xA4\xDA\xD6y\\\xD7\x13\x91\xF3D\x12\xB1\xE5\x9CMs\xFA\xF5\x8C\xA0_~:0~I*\x12\x14\xD0\x9C\x9F\xECMb\xFD\xF0\xC1cc\xA9\xD04E\x10w\x94B\xF7\xC9-2\xCFF\x9CzY\x95\x02F\xE7L\xFE-\xFFE\x84\xEEr\x917\tT\xE4Sx\xB8\x9E\xC99C\x84\xEF\xCE\xB1\x10\xF3\xD6\xEE\xAD\xD8\x98T\xDA\xB0\x97\x94m\xD1\xDF\x8A\nS\xD6\xB6\r\xB7\x86\xD6\xDD\xE7\x12\xD1\x18|.\xF9-)\xD1\x9F#\xC88\x94\xF1\xD0\xDE\xA8\xC7[\xC2&\xD0\xFA\xB3\xD6\xEEe**L\xB7z\x9Ai+\"\xFEsq\xFE\x9B+\x92{\x81\xE1\x83\x9F\xB4.\x17\xCDPG\xF2\xDF0\xE3\xFCW\xB99%\xF8o\x10\xDA\xF5G\x05z\xBF\x81?\x14\x11\x96\xEC\xB5\x00a\xC8\xD5\xA3\xAB\x86\x0F&\x8DC\x02\x11TQ\x0E\x96\xD7\xB4\xCE\xB8\xD6=\xD1\xFF\x99`\x15\xEF>\xC23/\x8D\xF7\xDFt:\x8Ey\xCC\xE8'\xFE;\x03\xEF\xC6\xA4\xF2G\x19\xFD\xFC\x8B\xD7S\x9C#R\xB4~\xAF\xB3\xC8\xF3\xDD\x86\xE69\f\xF8\xFC\x86%Tpw\rD\xB4\x03\xBF\xC1\x9B\x00\xA3/\xC5\xDC\x8B\x07O\xBF`\xA9`Ual(\x94\x81\xD6\xF4|\x03U}\x91bS\xC4\xDF\xF3IVz\xB9\xC6\xE2m\xA3\xF4\xE27PI\xEDl\xBD{\x06\x17U%\x8DD\xE7\xDC]\xC2\xAF\x1C\x07\xBCS\x0E\xCFw\xF8\xBD\xD4\xDB\xAB7\b\x03\t\xE9%\xF1V\xE2?\xCD\x8F\x1B\xA6\xBCw\xD4\xE1\xBF3\xB4~'Q#7.\xFB\xA6@7\xDB\x83\x8C\xF8/\xA9\re\xF1\x9FX\xBF\xAE\xB6N\xCE\x7F-\x82\xFFL\xFA\x95>0\x14\xC8\xD5\xDB\x12\xD3\x85#\x8Dkn\xF9\xBD\x88\x84'\xBFT\x14\xE4\xA7$\xC87[\xC1\xF4x\x8F\xC3\x7F/\xF0/\xDAB|\xE9V\x88\xF5k\x11\xFF\xD5c\x11\x1Ftj^u\x9B\xAC\xAF\xA2\xBCK\xB4~c\x15,\x7FMb\xE6Fb\xE4\x9C\xB8\xC8\x11\t3Q\n~\x161a\xAC\xD2\x13\\\x1B$\x9C\x17\x14s\xE9[#\xD6\xAF\xE0\xBF|\v\xF8\x16\xF4T\xE2\xB1\bC\xE2\x85VA?-\xC8y\xA3g\x98\xA9\xE4\xD4\xD2\xF1\xB6X\xBFB\xFEu\xC6[[\xC9\xFC\xF4{L\x9Dy]\x83\xD2\xD1\xEB6M\x82w`(<\xBE%*\xB8i%smi\xBF\x83J(]jiA\bE1'\x05\\*P\xFE\x87\x81oL\xB0\xB5\x98p\xB2\xF2oW\"g]p\xE5\x9C\x8F6$\xEEhu\xF4\xB7\t\xB6\xB6}\x91\xFF\xA6?\xA61\x9Ei\x9CjF\xF1J\x96S*\xBD\x85\x13\x93Z\x9C\xBF\xEC\xB8\x9B\xC1\b\xDEE\xEB\xF7R\xC6\x15\xB6\x9Cza\xC6\xBD\xEBG\x1F\xB4\x89\xD8i\x04d\xC2~\xE4\x14\x83\x16k\x04\xD6%V\v\x17\xEC\x98\x140\xA1\x11X-*>\xF1\x93\x91\xF3J,0!\xB4n!\x95k\xBE\x9Bq\x12OXh\x8B\x82Rw\x10\xFD&\xD8\xC0m\xC8)M\xF0\xA9%\xFE\xB0\xF3\xD4c\xF4\xD0\x07\x81\x9C\xE7\x12\xB5N~cUE\xAF\xF1\x0En\xB0\xE4\xFE1|\xF0\x93\xB3\xEF\b9y\xC3\xFB\xEF\xAB\xD8\xD0\xC2\x9F\xA4\xC2\x9C\xFF\x16M\xE2\xF4\xE3\x9C{\xAF\xED\x1D8\xFA]&\xCAWiA\\FO?\xD7r\xCAR\xDA\xD6\x9D\x97\xDAZ;\xDD*\xC6\xDB\x82~C+\xF5\xDCO\x13\xDF\x15\x90\"\xA7\x91\xE8\xF7Tdg\xEF:\x17'ST\xD1o\xBE\xE4\xFB\xCBl\xED\x04\x9F\xFD\xD1;\x14\xFDr0\x81iOQ\x88\x879\xC1\x02V^\xB6\x90\xAF\xDF\x9C5J\xEEB\xEB9\xC4_\x9A\x99w \xB1\xF6GN\xB0\xE5D\x06\xFC\x83\xA0_.\xFFcNW\xCF\xF0\x8FN\xA5,\"\xC2\x1A\xC6\x1F\xFC\x84\x97\xF9=\xE4F\xF0w\f\xC62\xF2\x1E6#\xB7\xB4\xBFybRK\x98\x13~\xECR\xE9>9\x8F'\xD6f\xF8\xCF\xE4\xFCWf\xCB\xFD#\x18oM\xB4\v]~\xEA\xB4Y~\xB5~WoZ\x04-\xBA\xAA'\xC1\xB1{\x0E\x05Mi\xB1X\x9Cy\xDA\b\x13\xAF\x82\xE81\xEC\xB1\x00\x91\xBE\xE8\x1D\x18\xEA\n\xD9\xFA!\xD0:\x98a\x03\xFB\x91\x1FY\xB5\xBF*\xD9\xD2\x1F\x17\x15\xC1\xF2M l\xEBG\x90\xB3y`\b3\x98\x9E$\xFA\xFD\x04\xF9u\x1D\x8E\xD90\xC1\xBF\x88=\xC3\xE9\xD7\x05h\xF7\xF1Ex\x84.D\x96\xA2\x83]u\x87\xF9P6p\x95\xAC\x94\xDEW\xCD\xB7\xE7N\xA6\xC5\x12{\xF7:Q\xDE3\x01\x1C`\xC23\xCF\x95\x96\xFC\xD6\xBE\t\xE1\xC0\x13\xA2\x07r\x9C\xE5\xC7\x81\xF0\xB7\xD6\b\xE8\xFB\f\x83v\x14\x15|y\xC0\x93x>\x1Cbz\xFFpb\x97\xA0_\n\xC8\x8F\xF5/v\xF6\xDF\xF9$\xFFB\xBD\x92~\xB5]u\xED\r\x82\xFF*\xCBO:\xEBw\x7F*\xC2\xF4\xB6N3\xD4\x19\x17\xD5\x11b\xD0\xDB9\xFD\"D\xBFN2\x86\b\xFA\x85\xC4}\xACs=\x1E\xB2\xF5\x16\xE1\xA4\x0EY\xFC\x17\x9EHg\xCCc\xB7$\xE2\xAD\x82\xD8\xB3\x88~\x91\xDB<\xD5\x8F\xBB\xA8e\x1A\xC9\xBF\x18<\xAD\x0F\xCB$\t[\x7F\x9E\xBE\x883h3\x9E\xA6\xFDcF\x94K\x1AO#\xC2e|\x9F\r\x93\xAF\x9F\xEF\x1D2wN\x8Fq\xFAu\xC6\x99\xDE~$*\xDA\x9Eq\xFD\x8F\xCF/\xCE\xC8\x15\xEC\xA1\xAE|\xAD\xB1\xB2\xF0\x8C\xED\x9D\xB4~\xE3db\x9DQg\x8Bd\xBAN\xD2_\xC2d\xC5\xF5$Z\xDE\x8A3}o8\xBCkH\xF1\x9F'\x96\x18b\x80\xF8|\xA3i\xEB\xBFG\xB9%\xF7\x8FE{\xC3\xAF\xEE\x16\xFB\xB4\xFF\x9B\x81i\x19\xFE3Q\xB01`\x9A'\x0E\x00\xB3I\x1B)\x88<<\x852\xD4\xCD^# \xF3d3\xFA\x8B\xB6nh\x8A\xD9\x8B\x87\xC9\xDDM\xDDW*\x98~6P\xB1\xBF\"\xD53e\xB68\xB9\x17(hD\xA4u\xFF\x8C\x1F\xD2\x06$f0\rzJv\xC0\xF7\xD8\xF85Wl\x1E.\x87\xAA\xBB\x0F\x93\xF4\x17c;^\xD9\xD4\b\x04\n\xAAS\"\x84\x00\x93\xE5\xFEA\xA3\x1C\xBA\x12\x05\x91\x1DS\x9C\xF6\x88\xA4\xCD\x95\x89\xEE\x16:\x07\xEE\xFA\xF6\x9E\xC3\x1B\x93F\x80*\xB6U0R\\\xABm\xD5c\tZ5\xFD\xE20\xD3S\x0Fr\xDD'\xFEJ\xA4\xD1\x89j\xD7S\x91\x8B\xB0\xEB\xE2\xF1\xBF~\x14\x8D\xFE\x83\xEB\xDCx\xA2lo\x9Fe\xAA\x9A&\xB6\xC0\xA5\x99\xD4ZM~\xEB8g\xD9\bT\xAA\xC9\xD1\xCDQ\xEE[U\x8C\xE5\x7F\x80\xE6\x99\xCE\xBD\xE6\xE8x\xE7\"\x02\xA4zVnnP\xB4Cr\x14\xD2\xCC f\x11\xE1\x9E\x16+\x98\x8Dz\x19\xAC@\x06\x14\xABkXk\x91u#v\x06\xD5;sK\xF5\xD4\x9DC\xBF5\x8F\x89\xF6\xB32\xE0\x94k\x05N\xA7!o_4\"\v\xAA\xE8\xB6h\xB3\x12\xE02\xA2b\x83\r|'o\xA5\x15'\xE1!\xA9x\x7F\n\x15;{\xD1#\xA6\xC6\xD1g\xA8\xC3F+T\x00\xD7c2\xE2R]\xBA\x82\xB9O?\x96\x99\x1A\xA6\xF7\"\xED4_\x92H\x98\xFFv\x05\xD5\xBA\x87h\xD8\xA3\rUl\xEB\x13\xF4K\x0F\xAA.\x86\xF1\xC06.\"M\x8E\xC6\xF2\xFB\xACL7s\x98\xBE\x96\xD3\xFC\x8E\xACN\xD9\x96H\xB7P\x11!\xFA\x19\xA2\xE1G$\\\x92\x14\xF3\xEB\xBCQ\xBA\x7F\xD9c\xC84\xAC\x94!\xF0\xF4\xDBH\xF4\x9C\nd\x85\x91\x18?Ye\xEF\x10@\xEDS\xBF\xC8\vP\x83\"\xA3\x8D\xEC\xA2\xD4?\xA0\xAA\x95\xEF\xB7/Z\xC0\x97[\xF5T\x82\xE4\xB8p\"\xF1\x9F\x85\"\fL4\x19\xE2\xFB^p\x9B-\xEE\x9C6z\xA9!\xDF\xD0\xEB\xF8+]>\xD5\xD0D\x0F\xC5Pd\xA3#\xD3\x1D\x97\x0F@\xFBB\xBA^=\x80\x04<\x96\xE6\n\xBD\x10\x10\rS\"\x01u!V\xF5\b?\xB9\xAA\x8F\xEF\x94\xDETV\xA7\x83\xE1\x9F\xBFo\x02\xF9\xA7Ri\xD9V\xC2H!\xECM\x1A\xE9a&\x1B\x06\xA4\x87\x1FQ\x17jR\x9E\xE0X\x96\x1D\xD8|\xDF\xB1\x9C\x16\xEEI\x0F\x8F\xB6\xD7\xB8?\xEC%\xCDMq\\\n\xB8n\x89\xA2\xFD\xF5w?\xD1&\xB3\xDF\vkA\x06\xDFc\\\x11\xFE\x9C3\xD7\xEF\xE6\x15N\xF9\x88~!\xAAU_\xB7\xA4\x16\xE9\x87`\xA4\xFB\xA0\"\xE8>\xBDA\xD8x\x8C\xB7\xF9K\xEF(\xFE\xFB\x8Cy3|\x7F6\rw\xA3\xD1\x89yY\xB6k\xEA\x04bt\xCA\xC8o\x18\x83\x18gkC\xA9\xAD\xAF\xED\xE3\x14\xFF\x86\xE8/D\xCE\xBF\xBE\x1B,\xE30\xF28R\xAF\xEAk\xC4\x99L\xD2\x86\x8F\xFF\xAD20\xA5S\x1A\x1B\n\xEB1|\xC0\xD2\xEE\b\x88\x90\x7F\x18\x89\xD8\x8B\x8D\xC6\x11\xBA\x90\x8CE\xD4\x9Fx\x87\xEEW\x1C\xF369;\xAF\x91\x8AGF\xD3\xCF\xC5\x81\xA7\xDE\xB5,\x8B\xFF<\x01E\xF111k\x07\xA7\xDFU\x84>\xE9\xA9\x96\xF1\xC78\x85\xCF\xE5\xA7y\xEF\xA7\xE2d\xBCh\x16\xFC\x12H!\xF4b\x92\xE3P\xE1\x00\x05\xCA\xC6\xD9\xE2\xD1F\x1C-#K\xFE\x05\xE0\x0E%\xB2\xF8/\xC0\x99\xF5\\\xFE\xEB\xACW\f\xFC\x14\xAEf\x9A\xABb;\x89\xBE\x9C}\xED\x8DL\"\xE6\xF6\xF0\xB6$\xDA1\xE1P\x14\xF0,\xDC\x97\xC5\x7F\xCDc\xF9\xD3\xCC\x7F?\xF9B\x86\xFF\xCA\xF2{\x11w\xF8\xAF\xA7\xB2X\xF6t|t\xADx\xC2.\xCE\x0F\x0E\xFF\xE5\xF7eRW7\xC4\xCF\xA96Xx\x92\xA3\x93\xAE\xA1\x8C\xD0\xC6\xA4\x1CE\xF1K\xA7\x0F\xF0Eg|\x952\x18W\xF3Y\xAD\x9E\x98\x04\xEE\xE0\x8F\xA1\xE2G\xD3J\x9F\x02r\x0E\x88\xE2\xF3\x98\xFC\x81\x85o?bk=Bk\x9A\xC0\x80;\xC6\xD9\xA2\x00\x14\x99\xF9\xE4M\xDD\xA0.u7\xDC\x03\xAA\xB7q\xCE@\f\xC5\xBDZGV\xA3\xEB\x89I\xF1\xDB\xF4\n&\x07H\xE0\x92F-}\x87\xA8C\x95\x7F2\xDDE#^\xDE\xA8\xA5\x9B\x1E\xB1\xB4\x1E\x84vsHV\x17\xC2J\x87~\xE19O\xF2\xBF\xCD\xBC\xAE\x13\x13\x05\x82\x8C\xE2\xEE\xED\xD0\x82\t&Ra\xB5\x84Y\x92\xD4Z)&Z\x05\xA1\x97\xF6H\xC4L\xF71\xCD\x19,\xA7\xEB\x9Ds\xD6oA\x17?\xF9\x80\x95\xB5~',T\x14\x9F\xF8\xCD\xD2c\x04\xB0(o\x96\xE8w\xC7\xA3\f\xB8\xBB'\n,\xBAl\xDA@?\x90\xDB&\xFB']\x9A\x93\xC2\xEAV\xA6\xC5dE\xE6$\xD0\xFC#\x9B \xA3v(\xAB\xB2\xD6\xD5\xEAZ_\xC7\x982\xC5\x7F9\xF3\xD3\xD0\xA1\xBD\xA1J-q$,\xA9\x169\xCA\xA8\xC1\x13\xB4A\x143\x04\xEE\xDE\xFF Y\xF3Je\xF7\xFFK{\xB5\xB6o]\x1B\xD5\x18\xBC\x0FF\x81\xC9\xA7RYu\xB7\x86\x7F\xF2\x01G\xC2\xEF\xBF\x97\xC6\xE5\x02\xAE\xA7\xB0fg\xD2H'X\xEE\x01\x81\x9D\x87\x9F\x89\x8A\v\xA5\x9B{%\x0E}\t\x19\xAF\xFE\xC4\x0F\x1C\xFE\xF3$\xDA'\x9C\xB3\xFF\xF6\x1F\x06\xF2\xF3\x95\x1C\xE2\x80\xBEl\xB1\xE2\xBF+\x12\xF7\xF6\x88\x92\xBA\xA2\x8F1\x80\xAE\x99Q\xE0\xC0\xC360\xDC\x15\xE6\x82\xDC#\v\n\xA0\xFCC\v\xCF\x1FL\xEA=\x07\xE8\xE3\f\x06t}!\xA9\xB7\x8A\xB4\x02\xD9S\x10YA\x12\x07Y\xAE\xEA_\x06\xCF`\x04UI}\xAFj>\xC7%ER\xEF\xA3P\xEF\x15\f\xFA'\xA23ZI\xD2H\xC7\xDB\x13\x94\x06\x1F\xE8\x11\xD7\x9Di\xEB\xE9\xAE\xCB\x1A\xF5\x04\xCC\xD6\x14\x10\x02C\xA7C\xBF\tE\xAF\xA6\x80\x99?~\x94\xA1\xBCQJ\x85\xEE8\xD3\xEE\xF8\x86\xF4\xF4\xEB\xDB'\\\x1E\xD5\xDF\xA6\xD8\xDFq\x92\xFF\x02\x11Y>\x9C8\xB8\xDC\x91\x7F\xF9\x83\xB1\xB2s\xE8\xE7\xE7'\x9B*j\x80\xDFdY\xAB\xFAEY8\xD1)kb\xE5\x9B\xC2\xD1\xBC;l\x03\xF1G\xA3@\xB8,\x1CH\x10\x0E\x15\xE6\x83p\xD8\xC2\xDEV[g\"%\xA6<\t\xEC\xF5\xDB\xFA\xC3\xD4\xA9\x9EP\xAA\xA4\x9F\xA2P\f\xEE\xB0\xEA\xED\x9E\xDF\x9A\x86\x87\xE9\xFB\xB2\xE8W!~\xA1GV\xF1\xBB\xE4\xEF~\t?C<\xDE\xD1O\xF3;\x14\vK\xB7\xBB\xDE\x10{\xC4\xD2\x13(\xD8\xC3Q\xAF}:\xABMT\x99?\x11\x07\xC2}\xB1\x0E\x19D\x94\x9FB<\x11E\xFCY&\xE9\x97(+I\xEAO\xF1w\x8F\xDE!\xF8/g\x7F\f\"\x91\x8A\xA6\xD1\xEF\xD0O\xF7=u\xF8\xDC\x06@=\\\xFFS\xA8\xB7 \x02\x14\xAEtd\xE77,\xD5\x93Y\x9F%\xBC\xF8\xD7m\xE4\xB8\xB6\xCB\x02^\xD9\xF0\x8D\xD4\xAFI\xFF\x13U\xAF\xCC\x7FM\xA1l\xBF\x85\x9E\xCC\xFE\xF1\x85\xC7l\xECw\xB6\x8E\x9EQ\x17\x9E\x06w\xE8eG\xFF\x8B`v\xA3\x80\xBEJyJ\xCA\xBDg\t\x03(\xDAz;\x8A\xA3\xC6\xB4\nF\xD4\xCCE\x8F\xB8na#~0c[\x12G0\xBBo\x0EP`1d\x1A!\x1F\xA6m\xC2|x{\f\xF9\x8DJ\xFF{8jL\v\xA8\x86GG\x0EwX\xA06L\x1F\xA8\xBB\x0E=\x0F\x18\xE3\x1D\xFD\xEF\xA2\xE7\xF7\xE2\xF1WpPC^\x1DL\xA0=S\x87\xA8\xF8\x94\xB5\xA03\xE0$\x04\x1D\xA5\xE3\xF5\xACJUY\x81\xC1\xE7D$\x9F\xE3Ae2,\xCA\x94\xFE\xDA-UR\xE1\xE3\xE8\xD3-\xA1%\x81VQ\xAAJ\xD7\xB3Rs\xE14_\x92\xD3sZ\x15\x99Y\xAE\xDF\xBCL\xED\x1E\xDD:_\x84\xB3\xC9\xFF\xA6\x9A\x02\xBBX\xB1\x06\xB4e\xF9\x8E\xF3d\xD7\xE0,\xF8o\x9Bp\xA7|\xE7\xB8\x84\x990\x96\x15\x07\xC9\xA3\xC3_8\x90\x8D\x04J\xFA\xEA\xB9\xEA\xAC\xDA>\xE6\xFF\xDB\x9B\x9D\xD3\x85\x82\xBB+\x15\x87G\x7F:X-\xD3\xFAd\xDF\xD7\x15L\x7FS\xFAl\xC6&GRV\xCF\xDC\x8D\xD6\xB48\xC2\xB4J\x94T[X\xDCv\x7F\nA\xEF\xA1)\"\xFAq\n\xB9\x89\xC6U\xD7\xD2n\xDF\x19\xF0&\xD1\xB9\xDC\xDB\v\x84\xD7S\xA8\xF6\x03\x99\"S\x96\xF2,G\x81\xC5J\xE9\x8F\x04\x9D\xB9\xE02\x9FS\x95\x95o\x04EzJU\xFF!A\xCB\xA1e\x1E4rk\xBF\x00hk:f\xE7\x1D\xB2\xA8\xCF\x93P5\x02\x14c]\xA4g\xD1o\xF9b\xE6^\xEA\x13)\x90\xD0O8\x84\xC6^\xBEIvTQ\x03\\\xD5\x057]\xD5\xD6\x92\xEA\xC8:\xCF\xB3\xA06-\xDA\xE2\xFBw\x99ix\xDF/?\xB4\xC2ixD\xF9P\r$\x8BKd\xA7\xA1\xF4\b\xFAe\x82\xD7\xB5\xEA\xE5\x9B\x93\xC6\x0FP\xB4$\x85\xBA\x9D}qT\xB5N\x19\x10\xFCw\x06F*\x86\xAA>a\x8BLWl\x00\x9E\xADk\xB5\x81pE,\x05x\x8F;\xA5\xE1\xA8\xD6\x95t\x16c\xF9f\xB9\xA7\xA4\x89t\x96@\x1D\xA7\x9D*P\x9C~\x93\xFB\xE2\x99j\xB5\x1C\xD1G\x12\xF0&\x8D\xA3\xF2\xA3\xF7p\xBA\xBC5@\xBD\xAC\xE4\x83\xA7v\xCA(\xF9\xD7\xCC\xE6`\x9Cnb\xDE\xDF\xA4!\x82\xD7\x8D9\x193\x06\x1F\n\xE9\xE4\xF3\x16p\xF2:\x1B8\xC6`\xB0\xFE\xE7Nm}#+^\xB4\xEA\xB5\xFF\x10\x11\xC4\x98\xD7}6\x81\xB9\xDD\x03\xF3>c*\xE9\x99\xB2L\xD3\xF4\x91\x82\x05\xABz\x8D\x11\xFC\xE7\xCD\xF0\x9F\x91\xEE\x7F\x0E\xDAL\xCC\xFD`\x15\x86\x9F\xE9N\xE1\xD8\r\x9F<.\x96\xE3t\x8E\xC0an^Lh\xB6\xF3\xF3\xAAF\xE3X\xFF\xCF\x93\xC0\xF0\xF6\xD7\"\xC0\x9C\x8A\xD7\x9D\xF1TK\xD5\xB9\xD1L\x05.#r2\x93\xBF\x90\xE7\x93\xC5vD\xEE\xDCUK\xDEt\xAAMs\xB0\\\xF8\xF34\xE6\xDA\xFALe>\xFE\xE7\x8E?\x1D<e\xE13\x069\xF1\xBE\xEB9\x99\xE6\xDD\x92\xF5\xE0\x97\x1Fe\xEE\x7F^&[3y\x15_UZF\x1As\xA3F\xE2\xFA\x8DI\t_\xAFa@O\xB8(\x90zVT6R\xFC\x17\x0F\xC8\xF5\x1BJ\xC3\x13\xDB\x82/3\xB5~\xC9\x98\xDE@\x1F\xA9\x16z1\x1B\xA9\x8Dd\xF3_\xC3W7&\x8D\x0E\x94\xD4EQ\xF7\x83>\vU\x11\xE3\xACp\xEAL\x85~ \x86\xC9\x87\xEA\xE9\x16^\x98\x9A\x1FE\xE7\xF2\x87\xA3\xC04\xE2\xBF\xFC\xE3k\x1CY\xAD\x82\x06\xB8:\xB3B5\xE4L\x93\xF6*\x16\xC9\xA5\x19\xFE\xE3t\x9E\xDC\x17\xC9\x94\x9C!\xF3\tC~\xAF\xE0\xBFN\xC0S\x9B\x9E\xE2\x91\xFC'\x16NE+\x1F\xB4\xE4P\xD6\xC4?[\x811\xBF\xB9\x0F\xF9b\xFD\x1E\x18\xC5\x7F\x89\xD5\xDBm\xA0yg\x92\xEA#i\xB1\x7F|\xE4\x83-\xB1LA$L>\xFEV\xFF\xDDr\xFD~?\x81\xC9O\x9E\xFD\xD3WY\xAE\xA4\xDF\xB7\xF9\x17_E\xEEv\xC0/\v\xC7\xB5g\xD3/'\xAB\x86U\xD3\xA2I\xCC\xB8\x1C\xFE\xD7RX\xFE\xC8\x93)\xAC\xDE\xB1{\x8F\xD0t\xFF\x0E9\xEBz\xA0\xE7\x12\xEA\xD5:\x9B\x1F\x8Dj=\x8B/\xB5\x81\xD5\x11\x0E\xC9\xC6?\xF0z\xC6\xAA!\x07\xE5p\xB8\xE1\x872+\xBE\x83p\x99\x98\xE4$\xDB\xA1\x9F\x19\x01\x8A\x17\xA6\x9C\xB2Y\x1C\x8D\xE5\xE4\xA51\x1E\xFAc\xFC\xE3\v\x80\xF7\x95\xC4\xDA\x1F}`q\x12\xCB^B+\t\x0E\x17\xDF\x94\xB5~\x97\xD5\xB11_\xF0K\x04\x9E\xAB\xF8j<\xD3\x061!\xAA\xF5\xAC\xDD\xCE\x80U\x1C94s@\xDEx\xF5\xB4\x81g\x81\x1C5\xE7\xF1W\xE4=E\b\x17\xD7\xFE\xB8,\x81\t\xBB\x17\xDF\xFE{\x96#K\x82\xAD\xE5_\xFC\x96\xE5\xDC\x03\\\xDBK\x05\x8B\xB5\x11\xF2/'k\xEB|\xE3\xDD\x1F%\x8D\xABpMo\x04\xBF}\xF6\x03\x1B\xCD\x8F\xEE\xDE3\x93\xBE\xFA)r\x07b\xA8\xFA`CL\x14c~\xB4W\x8B\xBD\xCD\x01o\xF3A\x0E2/\xBB\xC2)`4&.\xAB4\x8F\xB7\x80w\x1E\x95n\xF24\x15\xC6\x12\xC5\x85\xCA\xEA\x8D\xEF\xC9\x93sO\x03%\x1F\x00G\x15\xFD\x8E\n{\xC4\xE4$\x19R\xB5N\xC0\xB5\xAEg\xF5\xA3\xB9)\xBC+M\x11\xC0\xDD4\xE8\xB5\x1Fd\x95\xB6\xB6\x8E\xB21O\xA7\xA5S\xCA\xE1\xAB\xCB\x93\xDA^\xCE/\x87\xF7t'\x81.\x8E\x8F\x9Eb\xD0#\x07\xFF\xEF\x87\xEDo8\x8D\x9A\x81\x8A?x\xE2\"\xE3\x7F\xC2\x93\x83i\x84\xF7\f|\xFB\x9F\x98G\xF2\x1F\x01\xA2&\xC6O\xBE\x8C\xF3\xDFeQ}\xFF\xE8\x84\x00\xF5\x18\xEF[\x19\xB64\x1F&\xAE<\x8D{\x7F\xD8\x9ABg\xF7\xE2\xEB\xEA\xA4\xFC\xF3\xAC\xECAN>\xA1^}{\xF7\xDE\xA8\x9E^\xCD'\xD4\x95\xB31\x04\x94\xFF\xC1\xD9?('\xC9\x93\x12\x01\xCF\xF7v\xCBFK\tB\xE0\"\x12\xDALjo\xA8'\xC6\x80\xD9{2V\x03\xFDY\xC0\xD3\xDA\x83\xB0\xA8\x10\xA1\xA7\x01\xEF`b\xCF\x9E\xFEz\xFC\x83\x03#\xF7\xD3\xA0\x97\x86\xB3&\x9Enb\xEE[]\x19\x9C'U9\xA6?\x83\xB0\xA5\xF7$\xB8\xE0\xD8]\x1E\x05\x9Ee\xD0\x13\xB1bO{GV\xBC|h\xAA'!\xA2\xC1\xFDS=\x9D\xB8\xA2\x7F\x83\xB9\xCC\xA1\x1Fe\xAF,\x85\xA7Q\x9A?\xFD\xBD\xFA\xD1\x11\x01\xD9\x99\xC7\xA8\xF9\x17\x94'\xB5\x99\xF0\xDF\xC8\xB0\xBC=\x11\xC1\xC1D\"\xEF\x16a\x8E`\x9ED\x1F<\xAD\xAD\x84k\x13\x89.\xE8\xB1/r\xFA=\xE9\xA9\xDB\x07\x842\xEB\x97\xF4\x97\xFCY\xC2\x87\xFBe\xE1h\x86\xFE\x9F\x84\xAC\xC5$\xF3\xF69uY\xF5(0\xA9.\xB3\xFF\xEAo\x03\x9E\xC1\x0E\x94G\xC9\x01\xA0s-#\x96~jf\xB8\x8D\xAF_]\xD4\b\xDDC\xDE\xFFq\xE1\xAC\xC8\xE8\xF8b\xB8\x7FX\x83\x99\"\xF8?\xE4d\x05\xE8\xBF\xA4X\x97+70\xE0\xBAH\xA3\xC8y~\xBBj[_\xAAGv{&)||\xFC^\x91WXrg\xEA\x10\xCC\xFBg\xE1N\xA6\xAC\x88\xD4\xDE\xEAK\x949M\xFA\xCB\xB8(vd\xD3\xCF\xF8J\x86~\xE9\xAF\x90h\xBE\xE4\xE65X\xF0Xl\x16\x82\xADO8\x0F\xD9\b\xB5`\xF6\xCA\x14-\xA1#\xE1\xCDI\xF4\xD4r\xE5d\xCE\xFE)\xAB\x00\xEF\xB1\xED#\xF5\xBF\xC3@^#p\xBB\xC2\xC4\x89+\xB3\x93\x1F\x1D\xFD\xAF\x80\xCFjJF\xFE\xE1Y\xBE\xF7\xA4a6R\x89\x13\xF4\xF1SbWn|\x7F\r\xFE\x8E\xA9zz\xD7\xC8\xFDcN\xE6\x1E\xA6\xDDN\xED\x13\xF2\x85\xA7Z\x15\x834\x19~\xC07\x91\xF4E\x04v\xF1\xF8_>\x98\x82\xAF.\x15\x04<\xB6\xD72\xDD\xA3q\xA3\xAD\xBC\xA5Zv\xB1h\x012=:\xDA\xB2\xBC{:F%\xED\xBA\xBESpn4s\xA6\xDAT\xA6\xBC\xBEu^\xCF\xAFp_\x8A\x82\xBBltL\xB4\xC2\xF1\xAA@\xB3( \x9D\xDDJI\x8Cbb\xA4C\xFA\xC2@={\xA8Q\xC9\xC7\xC8\xAA6\xA8\xA4J\xA6ql\xBD\xB4\xD2\x15\xD5X\x910)\x95\xDE$\x97\x1B\xEET\x04\xDEc\xB6\x04\x17y\xFA\xD2\xA6,WJ^u\n\xE1\xF6@\x9B\x13\xB8C\xD5.\xF1B\xD0A\x95@a\xE9l!v\xBD\x92\xC4Oa\xEC\xBFF\x1D\x7F\xB7\xEA\xF4\xE2\xB8\xBF+\xD4\xE4\xD2T\x81Kl\xD4\xA2\xFC\xCD\xFA\xD3\xB8I\xC9\xA6\xC3\x99\x93;\xA1\x7F\xEA\xCBx\xFF\xA7\xAA\x8A\x90\x11e\xA3\x80\x9C\xAF\xAF\xE5\xAD\xA6\xD1\x14\xC9\xEFUnh\x18\xCF\xD5\x02\xAE\xE7:2_\xDE\xC4FWt\xA5\xAC\x96\x01\xA5(\xE5\x9F\x00D\xB3\xBD\xC2\x03\xEB\xC3\"!\xEF\xCET\xCF\xD5\x94|\x9Dg\xE3mN\xD84\xF2\x16\x9C\x96\xD4\xC8{\x7F\xA0\x01\x8E\x11\x01\xF9}\x11T\xED\x9C\x92\x82\xC4\x88\x00\x163\x80\x92^\x94\x1A\xE4\x1E\x16[q O\x16\xAAx\x1B\xC5\x14\xEF#\x9E\x82\xC3\x7F\xEA\xA18\x06\xF1\x84\xA8\x80$fE\xBD_\x8F\xD7:U|uA\bKT\x8E4\xF2\x9C\x02\x96'P\xA5\n9\xA7\x1DK\xC7^\xE9\xE8{\xFF\xAE\xDA\xD1\xF4\xCB\xB3\xE1\xB8\x9C\xBB\x9A\x00\xF7\xA2\xB5\x99/kD\x19\x95,\xE7\x1A\xED\xDF\xF3UHZ\xCE,\xD1n\x17p\xDF*=\xC1EK\x16'N\x91\x7F\xB5*i<\vxo\xED\xC4\xF5\xA7\xC6JjTn\xBAu0S\xF9\v\x95KR89\xFB\x93\xB6\xAC\xB6+C\xFC\xB7'\xB3Kr\xFE\x83\xB8\xD5\xE1\x17\x05h0\x9EB\xD5'Q\xA7r\xB3\xB3i\x16J\xFE;\xA5\xE8\xD9C\x8D\x8CD7#\xE2\xBF\xB9KRN\xAE\xBE!t=\xFA\x98`\x85g\x1D\xE86\v\xC7UI0\x11\xE1\x7F2\x93\xD0t\xC3-\xFF\xF1\xCEh\xFA]\xDF\xEB\xCC\xD4\xFB\xF3N\xC0{\xF6\x97\x99/\x87\x1D\xBC\xAF\xF8\xEF\x1EQ\x03,\x8B\xFF\xC4\xFA\xCD\xD9\x97\x10\xFC\xE7\x7F\xC07\xC4\xDF\xB5\xC3\x13%\xFE\xBB'\r\xCFT\xC5\x7F\xF9\xEF\x0F\xDC\x9C\xD5\xD9\x9F\xF3_\xD9d\xCE\x7F\xF9\xAA\n\xCA\x97\x14\xFF\xA9\xA7\xEA\xFD\xA9(\x85<U\x81\xD6\xB7Q\xFC\xC4\x1A\x07\"k\x89\v\xF1\x1F\xA3\x1AV\xA2r3\xC9?\xEF1Y\xAA9\x8B\xFF\xF8\xCB\x87\xD0\x9DQ\x04\xFF\t.\x13z\xDDU\fJ\xB5\xF2?qW\xDDyD\x9E\xE3r>\xD9\x04\xB8\xB6d\xF1_\xC3h\xFE#\x18\xA9/RO\xABp\x8E\xF2~\x8D\xF9\x9B\x1E\x01#\xE7\xAC\xEFJ\xDC\xCD\xA0=\xCB!\xCA3\x80[\x8Ba\xE2\xF1\"\xD5\xCFfa\xD7\xDA,W\xDE\x84\x85)4?\xB2\xBBM6\xBA\x81\xB8_-}\x17\xA0\xBD\xAD\x941\xF9|\x9Bw\xCARZ\x11\x94P\xBCr\xAEl>\xA2\xD6\x82\x14\xB1\n4h\xE9z\xE6T\xA0\xBE\x8E\xF3\xEE\x84\xA9\x19\x93\x9E\x94\x7Ft\xF2U,g\xA0)\xA3'\xDE\xC1\xDC\"\x13N4\x14\xBA\x13P\xDDx\xC6~0p\x8E\xFC\x9B\x9C\xD4\x94\x04\xCE}\xAE\x0Ep\x7F\xFF\xD7\x99/\xBF\xCCF\x94\x00\x07\n9\xFF\xE5\xBC\xA5\xDA\xEF\x18I\t\xBF\xE0\xDA\xD2\xBFF\xF4\xDD\xFCx \xBD\x9A\xF1K\x8E\xA7\x19\x8C\x19\xE8\xC1\x84+\x06$\xC7N\xFE\xE0l=2\xA5\x95'\xFE!\x8E\x95\xD7\xFE]\xA6!\x0E8\x83h\x9D\x1CO\xAB\re\xCC\xB0xZ\xAB\x1D\xD0\x8A\t\xBBS\x0E\xA0tZ\x01\xE5\xC8'\xBDZ\xD1/A%\xB7D(\x03\xF51\x99\xF8\x91,\xD5\x9C\xD9mV\x8B\xCA\xAF\xB9{\x94D\xCAM\xE1[(p\xAC\x06\x82\xC4\n\x9A_\xF3\xE4\xD6\x86\xD1\xF4\x9B\x10u`_\xCEb\xCE\x1B\xBF]\x93\xF9\xF2(\xC6\x8CL\xD4\xA4\x91s\f\xF5\x14\xC6l\x07\xAE\x16\xCD}\x07\x13\x02\xEB\x16\xBD\x1C\x88\x1Dd\x1C#V$\xF5}@n8\x86\x8A\x0F<\xD2\xEB\x16\xAE\xEB\xCAN\x89\x0EyN\xE0\xE0\x0F9\x9A\n)\x92\xFE\x17\xC7\x97\xBB\x05\xC8\x14\x97\\*\xA4\xF7\xC1=\n\xB4\xE2\xEA#\x87%\x9A\xCDj\x88\xA8\xF0\xE5\xCF\x9D\xCAsT\x83I\xD4\x1D\xA4\x8E\xF83\x1E\x92\xA5\x9A3\x85\x8D\x0F\x8A\xFD\xC33\xA0\xE4ZA/\x9Ee\x82\xB3%\xAEMpl*\x1F\xF7\x91\x81_\x8E\xA6_\x85J\xDA\x00<\x1F\x1E\x01\n\x9E~6\xF3\xE5\xDD,\xE7\xC0H\x85\x85\xFA\xFA\x0Etf\x01\xC5q\"\x0F(\xB0Ob\xDD]\xE1\xC7\x12t\xF10\xD3\x1F\x04\xDC\xE14\xCAj\x12G\x14\xFD>5U\xC9-*\xCF\xB7\x0F\xBB\xC6\x95\xA7 C\x9F\x01|\x8FA\xEF\xCC\x9A3\\\x03B\xFE%\xBAd)\xC1_\xC2\xBFg\x8D\x8C\xC7r:\x01\x03\x9EH\x96e\x82\xE8\xBC\bN\xB1h\n\xDA\vO\xADU\x1D\x83!\"\xD9@\xF87\f\xCF\xD2\xEA\x8C\xE9t\x8F\xB8K\x85k\x0Ff\xE6\xE2Kl9\x87\xFF\xC2Q\xE5\x86\x86\xA7k9\xE0~kY\xE6\xCB:\xE6\x8A\x9E\xBB\x7Fx\xBA\xC6g\x01\xC5Kh\xFD\x16\x8C\xFF\xF5\x1C\xD5+\xA0o6\x03\x1EFA\x14\x07\x84\xFEW8\xF5+\x8F\xAA\xFD#\xAF\tpL\xCD\x9E'N`\xCE\xCE\x95\x96\x80\xA5b\xCBg\xC0\xB3W2\xE0\xF9Q\x13\x9D\xA9\x8C\xEE\xFB1.V\x8B\xD1\x89\xC1P1\x86\xD7+\n\xA5Iu\xF9\xFB\x8C\xCE\x9B\xBFk\x95\xD3;D\x00Y\x11\x17\xF4\n3\x9C\xE6s9\xB5\xB8\x86\xC9\xBE#\x87\x1C\xFDO\xAE\x85\x92\xBEs\xE5\x9F7\xE9\x18~\xF5\x93\xAB\x80\x9C\xA7\xB3\xEC\x98+F\xEB\x7F\xE2\xDA\x03\xDF\xBC\x88\xBC.\x1E\x7FE\x18\x98\xF0F]\xF6g%\xCE|6,K?\xB7\xA8\xB2\x13\x0F\xEC3\xC9q\xAA\xA9\x8F|k\xF4\xA1\x98\xBC\xB4n\nv\xD6|A5\xB0O\x9C2\x0E\f.\x9D:\xCFga_\x9B\xBFh\xC3\xCEE|Y0WW\x91\xD5j\x8E\xD6hw\xB3\x995\x92\xB7\xCD\x84\xCE\xA2#N\xA7\xFD79\x1A8\xF3{]g\xBA\xA0\xCF\xC8\x84\t\x8F\xC2\xE1\x96\xFE\xDF\xFA\xB6\xAF\xFFAR\xFA{VH\t\xCCU\x04\xB7\xBA\xF88\x1B{\xAD\x00\x90D\xA6\xAC\x80<\x8F\bf\xCC\xAA\xCDs1\xE02a@\xE0\x9A\xBE\xF7\x89\xD7\xC9\xBD\x99\x82\x97\xAA h>\x11Bz9\xD3\xF8\xD0\xFA\xEB\xA8\xC2\xFD\xE9\xE0\xD8_\xD4\x02c_S\xD5[\xA1}g\xDE0\x83\xE6\xBF\xE9\xA0\xA8\x1Dc\xBC\xFE)\x83q\xF8\xCF\xE0\xB8\xB9\xD2\xFB\xC4\x91\xAC\xA2K\xF36\xA7T?\x1B\xE5\xE8\x93r\xCA;%\r\xB8\xCA#\xA8\xDA\x1BO\xFD\xF9\xE7\xBD\xC6;\x80{\xCD\x8E)\f\xC6'\xFF\x1E\xE0w\x95wJ\x84\xA9\ra\xF2/(\x18y\x9DY\x03\xE3'\xFD\\Q\x9At>\xFA\xF1\xDD\x80\xB4\xCDy\xE7\xA3_\xF8\x91\xA8\xD4\xFE\xFB\xE5\x9E\xA0Z\x84\xD017\x89\xC1\xAA\xAD\xA2\xB2\xA0^9\xE2\x81\x8B\x19\xBF\xB3\x99\n*\x97\x8A\xAA\xCA\\\xD3wW.\xC7\xB8$\xD0\xCD\xDCk\xD0\xCD\xB5/Q\xCC\xBA4\xA9_.\f\x06\xE3\x92\xCC\n\xFAQ\v\xF85U\xBD\x1A\xB9\x03V;\xA0\xFD\xFD\xE9\x16*+\f\xED\xF2[\x00\xAD\xB2\x96\xD0\xC4\xD8c\x03\x95\xC8T\xFA.9f)\xE3\xA8j\xF9\xA0\x12\xCE\x07\xC2@\xEE\x82&\xF8w\xD5F\xD6\xC7l\xDD\x0F\xE8\x8B\xCF\f2\xE8\xE1G\xAE\xE1\xB7zCX\x84I\x06Q\\\xA3Qp_\xBA\x06\xFA\xB4=\x8B\x00-yNoE\x18\xE9\xD7\x98PR\xB5\xF3\x16\xEA<\xDB\xA3J\xFB\xA8\n\xC5T\xF8\xB6\xD7\xE1?comKT\xE7\x03\x18\xABG\xFCRL#<\xD8\xDA\x19\x07*\xA9.1\x8C~\xC0\xFB\xB3~\xAA\xFA\x9C`\xDE\xB8\xD0\xBEdX\xB2E\xC9\xBDz;*\xA3\xCC\n\x12\xD9\xAB\xFA\xA2\x8E6G\b\\\xBBf[\v\xF9{\xA0\x1D\xBD\x97+\xD1\xFFH\xC0d\xD2\xF4\xD2\xC3\xB8\xCC\xE1\x8C\t7\xAD\xC1]\x8E\xC2L\xC7w\xE4\xC7\xD2~\xC0}\xDD!L\xFEC*\xF2\xC6\xF3\xB6q\x94+m\xED\x01\x06\xA3\xFFw\xA4*\x8Ds\xE8\xE7_|f\b@\x8B\xAF\x86\xE5\xF6\xEC\xE5\xFCw3\x9F\xDF\xDC\x91\x04\x8AT3i\xE4h\xFAo\xF8OO)h)\xF8O\x99\xDF\xAB\x92HlpE)\x9E\x9A\"\x1F3\x1E6I\xB0\xBA\x8E'\xE3\x80\xD9-\x14\xB2V \xB7\xA1\x0E\xE3\x1A\x81~\xE6\x89\xE3y>\xF1\x98@\xD6\x8Dd\xCC\xD3\x7F\x8Fp\xE7\xA7\xD6\x8B:g:]\xB2O\x9C\x13\xC2\xFC\t\xA0\xDDy:\xB7W\xD4\x1E[\xD9\xC0\x95\xC0\xAF\x92\x9E]\xB2\xAB\xB4I\xFAyi\xD2\vj\xB1[>n)\x9A\x94\xF4\xE1\x1A\x8A[\x7F\x01\xE3\x16\xDCZ\xF8T\xACQ\xBF\x170_=\x93f\xD0\x1F}\x84X\xA5\xAA\xFC\xB0\xA4\x9F\xAF\xAE\x8D\f\x06}\xFF\x04\xDC\xD8\xCF\xF9\xEF\xF4\xB9lf\xA4\xBF\x05\xE1\xE24\xCE\xCB\x7F\xCD\xDB\xE8\xCF9mx7[\xFE\xA9\xF0\x81\xA9\x966\x18q1\x91\xEE>\"\xC2 Ovy\x1F\f\xAC\x8F\x02\x95BD\x1B\xAB\x00\xF7\xD8\x13\xA8\xA2\xBD\xC1\x1B\xA5\xDC\xE9\x88P\xBF\xC6\xDA\xE4\x9A7\xBE\x8B\xCA\xF5\xEB\xE6\xED\xF6\xCFO\x02~\xD1\xDAY\x0F\x00\xAE\xF9\xE9\xDF3h\xF1\xCD\xDBmQ\xCE\xA5\xE6]\xCE\xBB\xBFa\x9C\xE8W\xFD\xF8l-\xCA\x9D\x1B\xA8\xF8x\rd\x85S\xD5\xFF\xE37\xF2c~\x1D\x90\xDFt\x04W\xFF\xEA\x1ED\xE7\xD0M\xEB\xBA\x15\xE1\xD2\xFB4\xB5\xD4\x13\xD9\xE6d`\xEA\xDB\x9A\xE6\xEB\xA1g!\xDC\xE1D\xB3j\x173i\xA4Z\xEA\x7F\x99\x89\x1E\xB4\xDAy\xF9o\xB5\xA8P\x9C\x9B\x12\xCD\x8Dd\xE1\xE01>\x87\xFF\xB4\xBD\xA6O\xD0\xCF\x18i<\x13+\xEFD\xACrs\x1407\v6\xE6\x8C\x14\x0E\x91Qb\x90\x83\xD4A:E8\xDBl\xB2\xDB\xE8\xCBP\xBC~\x9D\xD59m\x81\x0F\x98&bW\xF8\xFA\xCD]jF\x00\xAD\xE0\xCCz[\xA7}&\xBD\x9F\x83\xE5g\xC9k^\xB1'\x90\xA6\x04b\xE9\x9A\xCE\xAFUv\x86|\xC9\x7F\xAAh\xD5\x19N\x92\xDBzp\xC5\xB7\xFEf\xE8\xDD'\x92\\f{\x07\xDEif\xD0wTT\xF29\x96\vI\xAD\xD5\xC0\xB7d\xA0\x96\xF3_o\r\xF2\x16&jd5\rmd6\x94\x96\\\xAD\xA2\xAD\xCF\xBB\t\xEF\x15\x15\x8A=m\xF8Z&\xF8AT\x90\xA2\x982K\xFF\xACX\xD2O\x1F1\x80Wx\xA5\xE2\x83a\xCEz3Z2\xFC\x17\x8E\x13\xFF%8\xFFq(\x18\x11Pd\xA2\xE4\xBF\xCF8\xFFY\x9Dx\x80?\xA3\xF5t!}%\xE0.\xED\xEF\x06\xB4PE\v\x03\xA1\xAC\x06?\x97>\xE2\xDA\xAE\xC7\xEF\xA9\xCB\xD8h\x91\xFF\xDE\x1Ae\xE7\xD2$\xFF\xA9\x8E\xB4\xBE:@\x9F\x13\x83{~}d}\x0F\xC9?}Q\xC32\x06\xE3\xCC\x00\xD5\x1E\xBBL\xC8?\xBD\x06\xC1\x9A-)\xC0\xD5\x9E\xA8a\xC6\xB6O\xFE\x0F\x93+t\xD46[\xF9\xB2\x88\x97\x87\xF6\xEB\xF3\xD1\xEF\xA7\xDB\x99\xA4\x9FlK\xC41q\xA6\xA7\xD9\x15\x96\xFET\xA0\xD4\xD6;\xA8,\xC6\x88\xF5+\xEAN?s\xDB\xF5\v\xEA\x81\xBC:\xF9\x11\xC8\xBD\xE9*\\\x12\x05>\xE6\xAC\xFCc@\xEF\x10\x92\xF5\n\xD1\xC4[\xAB\xC3\xD4\x9Au\xD6\v;\xDD'\x00C\x94\xF3\xE3\x00\xD5\xF3\xF6\xC3!@oJ\xDC/\xDB\x99=<\x15\xD0\x8A\xA7P\x9F\x01o,\xFE\xB00\"\bbM\x01\x16f\xD7\xC9\x17e\xBBi\xF6\\\x7F\xB9m\x1E\xF2b\xAB\xEE\xF9c)\xD3o\x06rg\xDF\xBC\x15\xD0n\x9EF\xFC\x17:\xB2O\xD2/P\xD3\xE6#\xFA}\x95\xB9OO\xAC\x91=;\x8C\xBE\x91\xF2/i3\x01\xD2\x8D9\xE7\xA3_p\v\xCBF\x9F\x02\x13#W\x9D{u#\xFE\xF4/\xBB-Qz{\xE5\b\xFE\x13\xD20\x16y0\x14\x01*EP\xBA\xB8\xF8!JI\x18\xCF\xCC\bR\x8C\xEA`\x10\xFFY\"\xFC{6*+\xCE\xA6\x7F\xC1\nM`\x92\xD3=\x02\xD0\xF7\x935\xF9\xCC$Py-c\xF6\x9B\f\xFA\xCA_\x92\xA24\xEBWSfg\x051O\xF98\x85\xE7d\x9Bi)\x94_\x95\xF2\x8FzW\xEB\x87p\xED\x15\xAFn*\xD8M\x99G\x9E#\xF7>\xC6\xA0\xCF\x1E\x10\xD3\xA88\xAC\xE4\xDF\x1F8\xF3\xE7\x9E=B\xB5\xAD\xFF\xCC\xE4\x0E[9\x8A\xFF\x94\x01\xEC\xFC\xFCw\xF1\xB8x\xFC\xAF\x1F\xA3 \x8B-Q\xB0\x96\xE5\xE8\xB5/\xE0.\xB5\xB2{\xBC\xB1s\x1C\xAC\xAEQ\x8EWmd\x1B]:\x8A25\xACL\x85\xB3\xE9\xB3A1F\x87\x03>\x17\xB2\xFA\x181ksL\x94\xCD\xB2|\x17\xF2\xE1f\xCD\xDD#p7\xC55\xBB\x86\xE4\x85tX\xD9\xCE]m\xF4\xA4\xE5\xC8.\xB1\xEB\x9A6\x85\\\xCF\xBA \xFD\x1C\xC9R\x80\xC9\xBDZ\xE5\xFF\x03\xFAiV\x81\x03\xE7vF\xD9\xC8\xE8\xF2\xBC\xD3\xB2>\x85\xC5\xF4& \x8F\xE3\xBC\xDC3M-\x92L\xC0f\xC6\xFFf2`=\xF2\x06+\xA5\x7F\x9A\x7F\x1B4\xEF\x01\xAC\xC3\x13r\xE0s\rX4\xCA\xFA\xE9I\xA0\x05&\xB3\xAA\xFD\xFC\x94R3 \xE97\xE5p\xC6J\xC7\x95\x04.1K\x95\x05\xBC\xD5\xDA0\xE8\xDB\x19\x8DTO\xC2\xF4\xBE\xF5\xE8x\x92\xEF\xE2.\xD3B\x8B\xFA\xC51~r\x13\xA6'\xF5BX\x8D|O\xE0#\xCB\xAB\xA5z\x00wC\x93i1\xBD\xE0\x82\xF4s\x92\xB5N\xC3gk\x81f\x19\x94\x99\t\xE9\xD3\xD2\xCD\xE7\xF1\xDD\xF3\x1BW\xC6[W\x04\xF3)5t\xA4{\xFE&&\xCC\xEF\xFC1\xBAl\xA0\b\xEB\xCC:\xC7\x8D_\xCB\xF8;#\t\xD4\xC0\xB5\xC5\x92\x8DY\\\x1Cp\x1C\xF3\x01>\xD7{\xE4\x8C\xA8\x11\x9E\xE0-\xB4C\xBA\xCE>\xAB\x1B\xC7S@\x91\xABTj\xB4\xFE\x9A\xCCs\xE3Z.\xDF\xB1K\x92\x9A`\xB0\x15m\x0F\x94\x05j\xDA\xD6\xCFw\xA1\xD8\xFA\f\xCB:\xF8&<\xF9%\xAA\xB7\t\x89DJ\x92Z\x03\x9F\xE4=\x18KA\xD0\xC7\x07\x9APl\xF1\x85\xE8\x8A\x98\\\x01\xAA\x1E\xDE\x96\xD4.\xBC~\x95\xAD]\xF3\xC1g\x1B}L\xB2\x9E\x9E\x15Jq\xBE\xD0\x87\x93\xFCY}_\xE1Dh\xA3\xD7\xAF\xE6\x93q\t.*\xD3\xC9y\xD8{*e\xE6;M\xB6Mz\x17\x88\x92\x97;j\x89\xC8QJ\x070\xA9@\x13\x98\x89\x8A\x13\xF7\xAE\xA5\xEEE.\xAE\x9EMf\x88\xC47\xEE\xFAz\bp\xDBQ\xD52\xCD\x8E\x8C\\\xBF)\xE2\xE4\xEF\x8A\xF5\xFB\xD0{\xA1\x80\xF9PrM\x00\xAE\xD0\x1B\xA8\xE2h\t\xBE\xF9)\xD9x\x8B\xB244\xA0\x01z/|\xE2\x96\xCD\xD2\x90\xE8\x12:\x99a\xD0\x07\x98\xC9&\xD3\x15\xC5\x9A\v\xD2O\xF9l4\x1F&\xF7\xEA\x95\xC3\x80>\x94\xDD\x16\x1A\xC6\xD0\xF0\xF9\xB03`\xC4\xA5\xE1\xCC\x8C`\xDD\xF4c\xA3\xD6o\x1B:h\xE4`\x94/+\xBEV\x03v\x8B\xB9\x89V-\xD1\x9C\xF1\x85\xE8\x8F\xF2\xF5k>_){J\x99!.\xF5\"@\xC0\x1C4\xE1_\xBFT\x8C\xD2\x11\xB3\xF9\x8A\xCA+\n\xD6m\xB9+\x04L\r=/\xF9/\xB8j\xD4\xFA\x8DP\xA5-\xE1\xC8\xD8\xD9\xD9\x15\xAE\xDC\x12\x8DTW#\x18|\x03\x1D\x9D\xC4\x7F\xAF\x98xd\xC4\xFAm\xE0\x93l\xC2\x14\xBE\xBA\xA7w\x05\x82\x94\xFB\xD2\x02s\x03\x87\x96\xD5\xB5\xCD\xC1\xA8\xEE\xB9 \xFD69\xCB\x14E\xD03\x06\x9CN\x87\x93\x96\xED:?\xFD\xB0\xEF#\xB9~\x0F`\xBE\xAF\xE5\xF5\x91\xEB\xB7\x1E\xA2\xF1xq\x94\x96\x15\x03\xFC\xB7l0ogj\xFD.!\xFF\x82\xD1H\xEB\x97\xCF\x94\x1A\xB3\xF0\xBF\xF9\xF8\xCB%5[\x9A\xA0\xB3\xFA\x10\xE1\xD2e\xED6G\xA8\xAE)io\xCB\xAE\x10_\xBF\x8FKo\x90/\xABo\xA9Z\xBF\xFEF\x19\x0E]W\xBCk\x00\xB6o\xFD|\xBE\xA6\xDF\x90\xEB\xD7\xB7\xC0\xCC\xB41\x8D\xF0\xF5\xFBm\xBE~ua#\xF3\xED\x1A\bR\\K5\\\x91b@\xFB\xB4\xC9_\x1C\xD5\xFE\xFE\x82\xF4;\x9B\xC5\x7FI\xE2?\x12D\x99\xD8(\xD4\xFC\xE5<?[\x04 \x1Ev\xCC\xD6\x1A\xD6EG\xAF_!4\xE4\xFA\xE5\xCB\xAA\xFAu\xD3\x83\x91\xEB\xD7\xC3\xFFA\xABmP\xF1M\x16\x90\xFB/\xB5\xFC\x8B6\x13\xFE\x96\xA5\xA2\x04\xE2\xE4\x87z\x81|h\x03.+\xF28';\xA2\x92~\xB9\xBDm\xE7\xAC_\x83A\xD0\xAF\xEA\xA1\xF7B\x95\x93\xEF\x7F/U\t\xBD\xE53\x94<\xC0w\x88\xAA\xF7\xB2\xD6\xEF\th6\x87\x1E\fA\xAA\xE7\x83\xDC\xC7k\x83p\xF7R\xCD\\*\xD3n\xD7|\xE8M\"tA\xFA\xA9x\"\xCD$\xFE\xD3$\xE9\xB2\xD7\xEF\xF9\xF8\xAF\x96A\v\xAA\x1A\x01\f\xA5hi\x1BM\xBF\xD2,\xFA\xD1\x1E\xD2\x12\x8D\x84\x1C\xFA\x85\x88~~\xAAA\xA9\xCDZ&[r\vk~-\xA0k>\x13\xC1\xF5\ruD\xBFb\xE2_\x86-C\xF6\x16\x8B\x9F\x12P\xF4\xD3\xED\xAC\xEB\x8E\x17\x86\"\x0F\x94\xFC[\xFFx(\xE6k-5c\xD0\xD7\xAF\x87\x8F\x9C\xFF\x9E\xF9&\n2\xCBH\xE7\xF4\xCB\xE5\x14r5R\x0EY}\x88Jg\x07\xA0o\xF0s\xFD\xA5\xE6f\xC60\xE3\x82\xF4S\x81\xC2\xDA*\xF8\xA2F\x8Co\x16\x04\xC4\x1CW\x9E\xD6\xD0q\x9E\r$\xC2\xA0\x07d.\x15\xED\xBF\x0F\x8F\x94\x7F\x1E\x9Fl \\\x1C\xE5\xB4s\x9B\xC0\x94\xF5[\xCCZ6r\xFF\r4\x02\x1D\xCC\xB5\xB4\x00\xC8{X\xF65\xF7\x05\xF9\x1A\x9CZT\x8C\xD0\x89G7\xD1\xFCj\xDA\x18\xAD\xA8\xAF\xBB\xEE\xB7\xEE\xB0\x00\xDFK\x8F\x7FI*\x90\x0Fd,\x1B\xDA\f\xB9~-\xB9\xFF\xDE\xDA\xB1\xAB,P\xDF>5/\x80\xE2\xF8\xC3\xA8\xE7\xFB*\xFC\x0F\x98Nv\x88\x16\x16\xF2\xC5\xC7\xB4z\xEA^\x87\xE2\xF0\x17Lj<T\rW\xEB\r\x809\xBF:\\dku\xFF\xE3\xFA5\x1E\xC4\xBCF\xCC\x05\x831\x01\xD4\xDAO\xC9\xD8\xBA\xA1\xF3\xD0o<\x80\xC6\xF1\x8E\xFE\xF7\x90\xB5n\xE4I\x9E\xF1\x10\x01\xCC\xD3\x93$\xD6g\x013\xEEjm\xDA\xEC\xEC\x1F\x99w1\x96\xD7\xAA\xAE\x96\x17\x01\xAC\xD0>`\xCA\t\xBF\x80\xDC[\xF9\xB8\x0F=I\x1AY\xDE\x0F\x87\x84\x8A8=oP\xEE\xBF\xD3\xEE\xCA\xD0O\xAF\x13\x1B\xD5\x94\xA4\xD4\xD7\xDA\xA7\x9F\x1C\xAC\xDC\xF9\xC4\xC9\xC1J\x04\x93\xC0N\xD2\xFF\xA6\xDD\x95\xC2C\xCAQ\xFF\x0E\xA6[z5WRo\x81\xC5\xE97\xFD\xC4\x91&\x94\xF1\x93\x99\xF0R\xE8\xF7\xBE\xB5\xDB\xD2\xC7_\x04Z\x17\x8F\xBF\xDACj-\x81zg\x1Bc#=\xABL\xE70\xB2\xCD\xCCB\xCD.\x8D\xFA\xE3\x8C\x80\x91\x17T\xD3\xF5l\f\xC8!\xAD5\xA2\x96T\x06\x8AKK\xDE}\xCE\xB0U:\x99\xA9K-\x15q\xAA\xA2\xAD}\xFFM\xB7\xA5\x11\x88\xD3if\xBC\xEC\x11u\xAB\xA6\v\xD0\xAB\xE0Rh\xDF\xA7\xE5e\xD7l\xF1e\xFF6;\x9E\xBAE;/\x96\xD0C;\x84\x97g\x91X\xF1\xB5\b2\xBD\x12\xC8\x1B\x94\x04\xB3\x98\xD6\x04+\xD2\xAE\xE8g&f\"\x98\x07\xB4\xF8\xA0W\xA2\xF4\xF0,Q\x9Cos\xA9u\x81\xFB\t\x9C\xB0\xB1Y\xC9\x1C\xDFzR\x93\x03\x11\v;\x1D!\xB8\x01\xD0\xAD\x9DQiI\xAE\x91\xE06\t\xD6\xE2\xEF\x05v\x8E\xDD\xB3\x1D(9\xADW\x82\xEA4MO\xEA\xBE\x96\v<\xAA&\x02\xFD\x84aw2R\x84\xC5\x8B~_]\xEC\xC4\xDBA\xBA\xC1\xF5\x80V\x8A\xE0\t[<\x94\xB6R\n\x9B\xCF\xBBG\x00\xA2\xAD0Oc33\xCF\xACm\x81Y/Ex8\xAA7-y\xDCl\xBF\xEF\xDCKj2\xB4\xC9\xFD\x99-\xD5\xD0\x92\xA4\x16\x00\xDCyR\xC9/I\xC2\x87\x92c[\x9CH\xED\xAE0J\x8E\xA7\xD0p\x7F\xAFf\xC2?\xB5Wd\xD2,\xBD`55\xFF\xFA\bj\x1D-W\x84\xE6\x8C=\x96B\x03sK\xCD\xAA\x9EA\xAB\xB4e\xCBC\xC8I\xFA-\x8Ckh\xE1[\xAFV\xC3\xBFaZ@\xC51\xF0Q\xCE{)\xADV86\x8B\x94n\xA1B\xA9\xB5\xD08\xFF\xFA\xAF7\xD1)\xB7q=\x10%SSb\xE2+\xB6\xBD7\xA4B\xEA\xA3\xC0}\xCCmb\x11\xDCy\xFE\x15\xCCE\x9Dh\xB4&L\x88j\xD5z\xC9\xF1\x81\xF3\xD9}\x9A\nE\x95\x96\xF9\x82\x19j\xB9~\xB9\f\xD0N(\xD8\x12\xD5\xE7\xC1\xF5\xFFc\xEF\xFF\xE3\xDB\xA8\xCE|q\xFC=3\x92\xF5\xC3\x8E\xA586N)\xC5cEIl\x05\xE24\xA5\xDB\x90\x1F\xB6b\x1C\x90M\xBF\xC4\xB8I\xA1\xEC\xB6\xF6\xB2\xDD^\x96\xF6\xB6\x94\xCBnS\xCA\xB5\x0F\xC6,\x8A\xD3\xDD(\x8E\xD3\xA4,%\xC2u\x88\xA2P\x9C\xA6\x94M)\xB5U\x96\xB6i\xB6\xAF\xC2e\xD9\xBD\xB4\xB7KE\b%1\x14\x1BH/\xF2\x8F\xCA\xDF\xD7y\xCE93#\xD9\xE9\xBD\x9F\x7Fn\xFBG\xE6\x0FE\xB1f\xCE\x9Cy\xE69\xCFy~\xBE\x9FGr\x96{65\ro(\x85\xD2P\x14^\xB8\xB4\xA5b\xE9\xD6\xDC{\xA1\xF5\x14\xB87\xC7\x15Rq4W2QF\x1F\xE7F\xA6C}\x8B\x06\xA4\x11\xAD\xB7(\x07\xBA\x1E)\xE5\x8CTs\xF8\x15\xBE\xEBN\xA2\x91lS\xFEq\xC1\xF5\xFB)\xD1DJcd\xC3*\x99\xC1\xA8d\x99%h\xFD\xE6+\x19\xF4Z\xB8\x921\xB9`\xFB\xEA]2H\xC6/\rB\xCFqm3\xD7\xE6\xA3\\x-\x8A\x10\xCA\xB3\xE8\xDE}_4\xB1\x00\xFDt\xAF\x00\x14\xAEl\x8DI3Rxl|~\xC9\x7F+\xB3\xDA\xA7\xB1\xF2\xEC\x80\xB27|\xD3mX\x99\x8A\xA1wI\x86\xDB\x8D\xE7\xBA\xB8q\v\xF4\x1E\xCE^p\xFD\xB6\xF3\x15*\xEE\xD6\xD8GZ\xC6\xCA\xB39\f0%\x12\x1E\xE0+\x8F\r\xC9\x96\xAF\x92\xFFB\xA6V\xD5\xCB\x1F}p\xCF\xAE\x13@eB\x97\x920l\xEA\xDD\xBB\x17\xE6?=\x06\xF8vp\xBB\x1B\x18`\xA4(\x89\x0F\xA3\xA5s\xE8\xDC\xF4Fk\xFD^\x8E\xF0\xD1\x9CX\xE7\x0F\x7F\x93\xC0\xD9\xB9\xF2\xB4\xC2\xE4\xAA\xAF\x97\x8B\x16\xAFn\xEE\xA4\x99\xAE\xE8\xD2\x1BQg\xEA\xCD[\x96\xD7\xDD\xBE@\xE9\x96\xD6}\x8Bp\x95l\x89\xD9\xEB\xB7\x02p\x9F\x93k.\x98\xC4FT\x0E\xEF\x89X\xEB\xB7\r\x95\x87b\xE8\xEC\x8Dj^\x04\xDD1\xB1\f\x9A\xF6\\\x88\xFF*\x0E\x1D\xB0\xCA\x0F4t\xD2\xAA\r\xBA\xE2\xE8d\xAEI\xDB\x9E\x89t\x0EH#P\xF2\xDF\x12\xBE\xB6z\x93\xFC\xE3\xD9$\xE0\x99\xD4\x1AE\xC9]uV\xAB\xBC@\xEFXn\x04\xBBS\xC0%Y\x80\xB2\xD0I65\x03x\xAA\xF2k\xC3\x9B9\xFFi7wR\x8ES\xCDpL\xB4IiIPCb\xB7)\x18\xF5\x93\xDC\fof\xEE\xA9\xEE\x8F3n^\x07\x99\xE6BMV\xEB\xF6T\x9F\xD9\x13^\xC8\x19z\x89\xE0\xBFGN\xD8\xFBo#\xA0\xD5I\xFE\xF3d\xB50<\xAF\xE6\"\xD6\xFA\xED\x87\xE7\x91\x14\xDCK2h\x84\xF1\x8Aj\xDE\xF7\xC0\x85\xF8\xCF\x93\xBC\xC3^L\xDD>\x8A<\x1A\xD9\x1C\xDF\xDF\x82v\xC6U\xDE{\x7F\xA6\x80\xFF\xC0\xF0\xA9`<\tT\x0E6'\xE9\xD9B\xA2-\x91\x8B!_s\x81\x8A\xA2\x98X\x88\xEE$U\xC6C\xC8\x8DR\x06\xDC\xDC\xF9\xF7I\xCA\x1A\xC2\x9B\x15\fZ\x13\\\\^\x95$\xB9\x9DL\xFC\xA7%E\b2\xCC\xE5K\rC\xCA\xAB\x93=\xED\xC9\xC2\xCBY2\xB6\xC5\xBD,\xD7\xB1\x10\xFDtI?\xB1\x9A\x0E@\xCB\xE0VN?%\xFF\x98\xB6\x91?L\xDA!\xFF\\\x8FxI\xE0\x0E\xC1_\xDB%R\xB2j\xD8\x05\xFA1\xC3\xFF\x88\xD3J\xF5S\xFFi=\x94B\rS1\\\xFE\x94m>\xA5\xBF\xC8M\xA54\x8BxM\x82\x8F\xBC\xE7\x95\x1D\x94\xC9;j\xC9\xBFp\x90]X\xFE\xB5\x83\xCB+|\x849J\xC1\xB4\xE6m\xBB\x1E\x11Ff\xDB\xE5\fz\x05\x16q\xDB\xD9\xC8\xF0\xD7\xD1\xDF.\xE5\x9F?\t\x94\xF0\xF9\xE9L\xCBu\xD7\x10\xE2\xBB\xC6\xD0\xCD\xC7\xFB\xFCu\x9Elbp!\x96o\xA1\xB9,\xAF\xF2J\xA3\xB0\"I\xFB\xEF\xB9J\xB5\xFF\xEAa,\xB6\xD7\xAF\xBB>\x82\xEACg\xD1\xBA\x92\xEF\xD3\x15\x91vQ\n\xD1\x1C\xCC\\h\xFD\x0Ew\xD9\xEB7\xB2\x8D\xF6\xDF\x8Ap\x82\x1B\x99\xA6\xBD~\xDB\xAE\x95=\x87\xF4\x1F+\xA9\xAF5\xB5\x1Ff\xC0\xB6\xE4\x16\x06\xAC8\xA6\x85\xB0\xC4\xA4F\xE1\xDA\xB6-\x17X\xBF\xDC\xDA^#j\xAB\xA8\n\x82\x00\xA2\xFF\x91\x8B\xD7\x83\xE9\xE1)Z\xBF\xB1v\xDA?*\x87\xB3b\xC1n\x1BH\xC7e\x868\x9F\xC1\x16\xB8\x92\\\xB4\x1C\xF16S\x8EW\x05\xD72\"I-v\x7F\x95\xEB\xF6\x8E\x85\xF6\x8F\xAF\x8Bw)\x941\xFD\x06\xA5\xFF]z\xAB\xD2\xFF\xC8nT\xDB\t|\xFE\x1B`\x9E\\\x83=\x8C\xEB\x7F\xCB\xC6c\xC0\xF2.\xE0\xEFW^H\xFF[Q\x7F@\x02S\xF2\xE1\xF73_\x1D\xB7pOr!\xDD\xA5\xCCa\xE8\xDD_\x7F\xB4p\x80eY\x80b\xD4\xFB\x98\x9F<\xC0\xFA\n\xBA\x11V\x98z\xD9\xD7\xD9\x05\xF5?\xDFI\x87\xFE\xF75\xFE\xF1m:9T\xD7\xDFL\xFB\x87\b|\xAF\\\xB5T\x9E\x17\xA6\x85\xC3\xB7\x1D\xBE\x7F\x1C\xE0Zi/\xBC\xE9\xEE^\x8A\xA7\x84\x93\xFAR\xAE\xFF}\x1E\xB5\xE7\x1E|\xE2\xA2\xB9u\xF1\xF8S9\x185\xBF.H\xF1u1\xBDR\xE0?\xA9\x9D\xD8[\xE1\xF4\xEFr\r\x94\xABG\xF0&Q\xC1m\xD6\xF8\x90\xD2$\x0Ef,;V+\b\xB0\xF2\xCD5\xBC\x95\xB9\xD6\x04\x17\x8C\xD7\xCA\xF4$\x8A_\x9E\x80*\xE4e\xB8\xC0\xC9L\x81J\x8B\xFB&\xAC\x18\xB3H\x92M\xA0v\xA1\x94m+\xB2-\x8C`\ti\xE0-\x88O/\xA8\x12\x05\xE9Z\xDDirG\xC3J\xAE\xE9\xF7\xF4-\xFFi\xC4\xEB\x10\x1E\xCBMm#\x96\x9Dl\xF3ceF\xF7nM2\xDD;\xB0\xF2\xDC$\xF8\x7F#\x0F\x1F>;\x10\xA6(E'\xDC\x93B\xD1\xEC\xFC\x9F\x9F\x10b3\xDF\x11\xB5\x02\xE1\xCB\xEB\xAD\xB0\x8Eo\x07\xF63\xE8\xE1:\xA6\x87\xAC4:\xF2\x10\xE89\xAE\x8A\xDF\x03x\xA7z\x84\xD1*\x92\x97\xBC\xCD\xDD\xF7\xCBp\x9C<\x9Eb\xD0\xBD\x07\xC5\x93z\x13\xC2\xA4\xFD\xA7G\xA2d\xEB&\x01\x93\xC4\x97w\x8A\xEFo\xFA\xA7P}\x92^\x05\xBF[\xE9\t!\xE1h\xF8\x07\xE8\xBC\x95Y\xBDn?s\xB7\xD3\x13yw?e\xEDy\xB5\xBE\xF6b\xDA\x1Dd\x14\x8A\x12\xB7\xD4\x83\xB2\xAE\xC5\xDB\x1CV\xFB\xAA\xD6\xD2\xB3\xCF\xFD\xBD\x1B\xACW\xD0\x86\xA0\x89\nTn\x99\xEAF\x85\xA9u\xD7Ug\xB5\xEE\xEE\xCA\xE5A\xA02\xAAuw\f\x1E\x9A\xEA\xA6=n\x0F\x7F)=\xCC\x93\x84\xAEo\xA9\x13\xB1T\xD9q\x98o\xAEUa\xEB]zN\x12RMw\x80a\xAA\xD9\xB9KR\x07\x12\xD7\x8D-\x80+\xE1\x15\x97A[\xC7\xAF\x98j\xEEd\x16f\r?\xAE\xE7J\x82\xDC\xF9\xDC\x12\x1C\xA2c\x7FVk\x16\xA9\t\xC2\xEEv%\xFE\x8C\x8F\xE0\x87~\xFF\tJGm\x16\xEE\xE8JuY\x8C\xCC\xEBJS\xC3\xCD\x8C\xB3\x1D\x7F\xA2\xD6+,\x9D\xAB\xFA\xF5\xDC\x02~\x1C-\xAFn\xA9]~\x8DL\x93\xB4Jq\x18\xEEY\x1Cx\xE5\xB6\x98\xC3\x93\x15H\xEA\xF7 \x90\x8D\xC5\xE0\xCE\"\xBC\xFB\xFE(\xAEX\xF2\xC0+w\x00\x9E\f\"\x97?\x90\xA5\xF5;\x89N\xF8&Q\t\xFD,v\x8F\xBC-\xEE{W\xC2\xBE\xAB\xE7\x15k.\xDA\x0E\xAAc\x0E\xC7\x997n\xA7q\xD2\xB76@\xCB\xDD\xC3U\x9A\x1EI\xD2\xD2 %\x16v\xBBU\x95\x96\x1D\xEDk\xAB\x96J\x82\x84d\xAF\xB87\nY\x10Oyw\xD0\xDAB\"!`\xE5\x0F\xF9\v\xD5\xDA\xF9\xAF'D4\x97\xD6uM\x1F\x13\xBAc\xBE\x8AR\x1D\xDD\fm\x95c\x96\xCE\xAFo\x9E\xC7\x7F\\G\xDF&*\xCA\xF9\xFAUh\xC1\x89\xB0\xD2\x0F\xF4\x96\x7F\xAC\xF5E\xBA\x1Dr(\x94\xD4\xEA\xB0\xBC\xAE\xE3n\x98\xD0\xC37\x1F\xCE\xEAm\xA3\x87Z\xDB\x81pT_=0|d:\x0F\xB8\xBA\xE0\x85\xBB\x1D\xFB\x99?\x85\xE6`Ld%\xAE\xBE\xC9\xD6\x82L\x9F\x15\xB1\xF2\xC50\xC8\xA0o\xEC\xCC\xB8\xA6-\xFE\xA3\x16\xD5\xFA4\xE0M\xB7\x00\xBE\xA9\xEDRyr\xDFCH\xE7\xCD\x07Y\xA9\x93\xFF\xB8\xA2\xD4=\xA8\x8A\xCC\x84^2x8\xAB\x87hm\x89\xC8-\xBC\xB5T)\x10A\xC5N\xCE\x7F\xDE\xFE[D|oyT.\xFB\xF8\xE1\xA4\xB0\x9D\xC3\xDF$\xA4\xFB\x86\xAC\xDE\xDD[o-\x94P\xEB<\xFA%\x18\xF4\x01ze;\xB9p\xBB_\x99\xFF\x1B-\xFD\xB4\xFB\x8B\xFB\xB6L\x85\x1C\xC6cE\x12?\xC6%\xAFM\xDD\x82\xEA\xA4\xD6\xDD\xB0/\xAA5\xB6\xED\xE7\x9C]\x9D\xD1\xCC\x8E\xFDg|W\xD0\xFB\xD8\xCA\x8C\x1Cn\xE6\xEB\xB7\xE6'\xDBDV\xEC]\x952\x9C\x94\x02\xAA_;[\xB4~W\xE8\xC0\xCEn\xA7\x95\n\xED\xA3r-\xB8\xA2\x9F\x94\xD9\xE0T\xBE\xE0\x9E\xEAn\xB61\x93 2\xC4\xB56\xF9z4S\x98\xC7\x9D\x03I\xADQ\\V\x91Tr\x83\xB4\xFF\xC0kd\xCD~\xF1\xF3\x82\xFF\xAA\xD4\xAF[)\xFE[\x9D\xD5b\x9Fc\x06\xB7kM-\xFC\xC9\x11\x8B\xFFj\xE6\xAF\xDFN\xE6\\\xBF\xB7\xCB|\v\xF7\xE2\xA0\xB2k\x11\xAA)\xAD\xAD\xABtlr\x81\xA4\x16\x84\xCB\x8Co\xE3Jxs\x8C\x9FR\xD1\xD7+\x1E\xA6\xFB\xF2\xDE\xDA\xB3\\hM\xE2\x16\xE6J\xA2\x1Ez\x16\xCDU\xA6\xF85l? 4\xCD\xE2?}\x07-\x83\xD9UL\xCF\xD9\x1B=\t\xB3\xDB\xF8\x1E\xC6e\xCCT\xAB\xCC\xC6\x15\xC5'\xAC\xAE\x86\x19N\xFE\xF33\xA0\xBB\xD2\xE2?\xCA\f\xA9\xB8\x8F \xAD\xA8@_l\xB5\xB5=\"\x0F\xA0\xF2\x1A\"D\xFC\x16\xC0uRy\xA3\xF5\x18\xBC\x9E\x8CH\xB2\xED\x8EP\xAA\xB3'\x83|\xF0)K\xFE\xB9\x86\xE6!$TP5>\xF4v\xFA\xF6q\x8F|@U\x92\xAF\x9Bh[\x8Ck\x1Cu\xD6\xDD\xD0M\xFD\xD3\b\xBC\x92\xBB\x8B\x0F\xDF8\xB7\xD3D\xE3\xC6\xDD\xA7ST\xAD\xB8\x14\xBB^\xA9[G\x85+\xC7\x98/\x88\x00\xD3\xE3\xB8\xBF\xBA]\x82\x9F+\xA4enr\xBFr\xD6\xE1P\xBA\x8A\xDF\xFC\x06\xB8\xDA\xBB\v\xD3\x96Nr\xAA\xF1o{>\t\b\x17\b\xA5\xF9\xE6n\xAF`\x05\xF2\x8F\v\xD0!9{/\x13\xAE\x88\x9A\xDE$\x1F\x85\xDB\xBAB\xC2i\xD3\xDB\x85\xAC\\\x95$\xA0\xFE\xDC\xE7eR\xBB\xF85\x87\xC0\xCE\xA8\xB4\x9D\x1BXIR4\xD4\xF8\xC0\xB7\xAC\xFD\xD7\xF3jn!\xF9\x97\xA74\x05\xFE\xED\xF6\xAB\x95\xF9?\xA0\xFCC\xDA\x9Dc\x8B\xEF\xFF\x9E\xE5\x93\xD1*Qe\xEAK\xB1\xB8\xAD\xBF\x9F\"\xB7\xF5\xF5\x19-\x14K\xFC\xFDY\xAA\xD6\x8E\f\x0E,?\x17\"Q\xF5\r\xF8\xBDhE\xE91\x1C\xC8\xEE\x93Y\xED\x87\xE5\xFA\xE5\xE6\xF0r\x8B\xFFJ\xC5\xFA\xED\xBA1\xE3\xDDi+J!\xD5\xAF\xBC6\x02\xB8\xEE\xBC\x1Ep\x1D\xE3\xA2\x85\xD3\xCF\xED\xAB\xBB\x89\xB9O:\x9E\xA3\x1F\xD0\x87\xE4\xA4\x039a\xD2\xF2\xFD\xB7R\xD4\fT\x886G\x1Ds*\xC7\x9A\"\xE1;;\x04\xFF\tO\x97+\x8E\x9B\xA9\x95\xFA\xE2\xA8\x1E\xFB\fu\xAD\xAD\xCEh\xDD\xEDi\x8B\xFF*\xEF\x9F\xC7\x7F)@\xE3\xA3\xAC\xA1G\xE8\x90u;\xA5\x15\xBFT\xFEI\xBD\xEC\x91\x15\xBE\x88-\xD6o\x15\xED\x9FV\xD4M\x1F\xC7\xF2\xA4\xBE\xF4\xE4\xA3\xA6\xDE\xFDO+\xC7\x97\x92\xB4m\x1B\x1A\xBA\xEDRG\x8E\xF0?\xC1\x9B\xB12\x1F\x95\xD3\x98\xDC\x90\xCB\xFF\xC6z\x97\xDE\x03\xA4\xFFu\xDB\xC8\x0F\xA2\x92Z\xA4\xDE\xFB\xA6?.\xAE\x80\xCFZ\x06\xDE\xB5\xF9\x04\xF3\x1Fp<\xC7w\xB8\xA1-\xABf\xC0\xC4\xFEqp\xC8\xE4\x03\x94\xE6\x80\xDA.u_\x19\x04\xE6\xD7z\xA7\xBB\xC5\xB7\x10q\x98o\rv\x0F\xF1\x89\xAE\xE8\xD2\xF3\xA2P;\x1C\xD5\xBD\x07\xBFe\xD1\xCF<ws1\xFDF\x18t>\xBF\x8Cx\x84\xEF\xC9\x07<\xF5\xE4E\xD3\xEB\xE2\xF1\xA7p\x14\x98\xAA.\xC0\xEB\xD2\v\xECN7\xD0\xEE-\x8A\xA5\xC2:E\xFD\x92(\xF8\xD9v?EEQp\x1D\xB7\x9E\xC2>\xF8\x9E\xF7:\xD3\x84\x94ul\x05hII\x85\x1E\xAA\xE3bG\xD48\x992l\x122\x99\xC0o\xEAg\v\x06{u\xA5Bx\xEFx\x1A\xC5E\xBB~nR!Z)\xEF\xEB:1?<\xEDOUB\xB6\"V\t\xD9!\x06\xAF\xA1Z$\x15\"uu\x01\xCB~\x9A\x93\x92\xAB\xD66}\xB3\xBA\xB7/\xC4\n\r@\xDF\xB4\r\x99\x7F\x8F\x88\xB9\x86vI\xE1\xB6K\xEE\x88\xA1Q\xA1\xC2\x86\n\xA7\xC5\x15\xAF\xFD\fZ\xE3A\xE6~'\xBC\x13\xEEO\x05\xC9\xE8\xFD>SI\xD0h8w\xB7\x18t@\x04\x81Ks\xE8\xAD>ob\xEC\x11\x7F\x12\x0F\xF3\xF3DiT\xF5\x8E8B\xDC\x90\xBD>#\xFA/X\xEF(\xA3\x7F\xF4 \x83\xD6#\x15pW|\x98Kj\x95\x1DM\xA2\xCF}\x07\x06\x1A\xCE6WJI\xAD;\xBD\xE4\x07Ef\x8D\xBB\xA3\x92\xCC\x87^\xCBm\x88%Y=\xD7\vo\xFA\xEF`2n\x04sS\x1A\xA5)aJ\xA3\xB2\xAF]\xAA\x9C\x12\xBEEk\xC6\xE5I\xAD[A\xDD\xC8c\v\\7\xDAJ\xEF=\"\xE6Zs\x869\x8C0\xC0=3(\xFA\xD7.)\x8C\x7F\xE8Q\x01\x96z[\x1B\xC3\x8D\xDD\x9DL\xDB\xFE9\xCE \xB8\xDD\x86f\xA8x\xE0\xA7.\x1A\xF4&\x11\xA5-\xF1\xA2\xF3\xDEh\x0Em\xFB~s\x02[\xF8\xFC\x16\x8B\x1A\x9F\x95\x93\xA8\xF9\x1FQ\xE02f\xC3\x16\xD1\x00Q\xED\x1D\xBE\x1Do\x97\t\x84\xDA\x97f\xB14\xA9\xEA\xFD\xC4\xD6\xAB\x9B\xE8y\xF00Ug\xE6d\x9By\xEBh\x1B4\xF9}\r2i\xB5\xEE\xCE\x04S\xD1+\x9Di\x8Fw2\xD7T\x05\xD7\xB8\xBB%f\ra\xE3\xF2Q\x02\xC2@MY}s\xD1\r\x7F\x12\xDB\xC2\xFD\x051\x8C\x00\xD3\xEC\xA8\x11Z\xE4\xFA5s\xB6YJ+(/\xF8\xAF\xA8\xFF\xD9\x8A.\xD2@\xF5F\x1D\xBE\xDC6\x1F|g[\xE8)70MYJ\x81Wv\xE4\xA9|\x8DX\xB7\x94[\xB3>\xBE~\x1B\xEF7\xCE\xA2\x9AK\x86\x07iz\rI\x86\xAF\xFD\xA4\v\xD8\x97\x01\x9C\xFC\xE7\xC9\"\xEAg\xD0{\xA4\x02\xEE\xD5\x87\x11HBf\xB7\x89\xB29\xDFK\b\xEF>\x9Dj\x93\x85\xCB^\xA7\x17\xAD\x82k\x87>\xF8c\xB4B+}2\xF5\x19\xC0\x95YLVCk\xFF;>\xE5Aa\xCAP\xF7,\n\xD1\x87S)\xB1\xA9\x13*\xABPsW'\xF5\xC8\xC1\x86la\x9A\x9F/b),z^pv\xC3\x1B\x92\xE4\xB2\xF0\xD173\x84F\x13\xCASd\xCF-\t\xFC\x80A\xAB;\xC8\\\x1D\xF9\x83\xCC\xF5\xB5\xCF\xD1\xDBO\xCB\xD40\xFE\x06\x8E\x9Ej\xA3A)T\xFB\r\xE67\xB1\xB3\xFA<7n\xCF\xD6!\xCEJs2\v\xB8\xEA\xB3g\xF1\xE7\x7Fm\x02\x7F\x01\x1B^\x06\"\xBD\x9A\xCFJ\xE3\x064)\xE0syD\x92\xBA,\xF7\x16\xA6\xAF\xEB\x0E\x8C\x0E\x97Nw+\x1B\xDB\xC9\x7Fc\xC3&e 6\x93~\xF5w\x07\x87\x93@\x9F\x88\xA61\xFD\xE18+\xED\xA8\xE02\xA2\x1B\xF0\xDF&\xBA\x8B\n\xB8\xFD\xEA\xD7HZ\xDC\x06\xD5dH\xEB\xC6\xFB\xB2Z\xF7\xF6K\v\xF8o+sOY\xD3\xD5\xD2BQ\xBC\xF4Z\x99\x8E.\xF1\x96\\\xCD_\x13\xAD:*\v\x85\xBB++0\xFC\x1A\xAF\x87\xF6\xF6\xB6\xED\xC0\x0F[\x88\x05z\x98[\xC9\xD4\x9A\xDF\xB4\xBE\x15\xB3\xB2,Z\xE1\xC9\xA1\xB3\xD7\xDC\x81\xCFV\\w\x12\x9D\xCC\x95\xC0\xE5\"\xB5\xE43k\x80\xEA.\x82\xFC)@K\xAE\xCEj\x83\xAD\xA2r\xCD\xCD\x19D[\x91D\r4\xD98\xFB\x12\x01\xBFn\xA2c\xFFo\x8EDe\x8E\xBA\xE6\xC4\xB5\xFA8\x7Fq[`LQ\xD3\xE3H\xFB\xD7\xB2\xAA\x1E\xDB\x93\xD5\x127\x91}^I\xD5\x8F\x9E\x93\xA2VZ\xA8\xEC\x12\\'i\xC3\xF7\xB5\xA1<\x8A`M\xA0\x80\x87\xBC\f\xA6=]\x19s\r\xFC\x8B\xA4q\xA3\xB4\x07_2\xB1\xDA\x84\x03\tP\xCE^\x84`\xB5`\x05s\xB7\xA7#\xCC\xFDP\xB7\xEA\xEF\xAC\xF8\xCFuM\xCE\x15`\x12*\r5L\x8F\xC2\xBF\xF7t\n>=\x9A@\x1D\xD3Ti|\xF5\xB2,:\x7F\x18\x05\xB6G\xED\x92\v\xA9M\x9Fo\x92U\x92\t\xC9\x7F\xFE\xAC\x92,b'u\xDF\x81M\xFEo\xE6\xBA%\xD4\x84\xE1\xCC4~\xFF\xFD&\xBF\xAF+K\x19\xBA\x7F\x11\xB0\xCB0*\xA2\xC8{\x99f\xC6`Pkv\xDD\x02\xFE\xD1&\x95\x83N[c3\xCD-\xDC\x98\xE8\xAE*\x84\xA9\xACa\x9A\xA3\xD9h\x8Bl\x8A\x18M\xD9f=\x99\x07O\x8A\x86V\xAEB\xFE\vE\t\xC2K\xCF\xD70\xDFdw\r\xF3\r\xEA\xE4\x9DYm\x15\x81\xC0\xD5,\x1B\x15\x10\xFF\x05\x99\x91C` \xBC\x03W\xEE\xFA\xAB\xE7\x11`\xE8\x92\xFB\xEF\n3\x8A-\\6}2Z\bo\xE4\xC9\xE2a]@iib\xFFM#`\xAA\x9DM\x80\xF5\xFALT\x05\x86\x93i\x89K\xE9v&\x83_\xF2@\x96?\x87\xBB\xFD\x16\x9Aq\x95'\xAB\x9A:,fH\xF3\xC7\xCF\xA3\xDC\x84\x85\xBC\xD9.\xEBf+ZT\xAD\xEFJ\xC1L\xFA\xE3h\x88j\x1D\xBB+\xCD\xA2\xFD\xB7\xC32\xB0\xB5u\x02B\xF3\x92a\xF9\x06e\x8F>w]\nWF\xE7\xAF\xDFp\x12\xD8\x07\xE8\xDB:\x98\xFF\xC6\xE6v\xE6\xFB\xCF\x0E\xC0w\x17\x86\x99Uc\xDC\xF0\xFAO[h\xD0AADW\x02\xCD\xCB\xCE\xC6q$\xD2\x92\xE27O\x89\xF0#\x1A\x0E\xC5\xB0{0\t\xDC\x9B)\x94\x7F\x15L;\xDFIaT\x10\xF4\x9F7\xF7\"B\x19U= \xBB\x12\xE7\xF0\xE8\xD0\x91\xE3\xC3\x12\xC3\xCA\xED@\xB9\xC2\x9F'\xE9\xBE\xFE\xD6+\xA8\xF9p\xDB>\x132;zE\x97\x9E\x8E1\xF7\x8D1,\xCBh\xCD\x129\x8D0\xED\xDC^\xA0\xBE\xBEN\xDA\x9CW\xC8\xFD\xA3\x1F\x91.\xFD\xEEo\x17\xE6\x00\x1D`\xBE]\xF6\xFE\xF1cQp\xBDj\xD5I\xB5\xBB\x88E\xFE\xD9\xCF\b\x10\xC0\x95\xF3\xF37\xC8's\x90\x1B\x8F\x07\x85-\t\xE0qf\xD9\xBA\xB5\xBE[\xAE\xA0A\xFF\x99\x91\xBB\xD2wLh_c#o\x9C\xE4\xCA\xA7U\xB7\\:i\r\xAF?U\xB8\x7F\xB4\xC8L@\xAF2_\xEB\xC90V\x01d:\x1E\x1B\xB9=\xBDV\x99\xC8\xCE\xE3k\xE9\xA4\xC8\x0E\xBC\x85\f\xF2\xAF\x1D\xEA\xE2\xDB\x98\xDA/w3_\x7F7\xAE0i\xFF8+\x8Cy\xC0w\xF6\xA2\xE1u\xF1\xF8\xE3\x1E\x94F\xBC\xFCfa\xFF\x16\xA3K\xB8\xA0\xC1;\xCA42\xFB\xF4\x95\xDC\xEC\x8B\x95fd,4\xAD\xAC@\xFD\xEF.8:%I\xED\xB3\xB4i!\x8DV\xDE\xE10!\x81\x85`\x9F\x8BLW\x19\xD0\xB3\x01\xA0\xE5\x05\xB5\xF6\x06\x14tf;\xC7\v\x8B\x1D\xE3^]\xBF\xF0-L\xA7\x94\xFF\xBF\xA5\x9A=ur\x81\x1F\x9A\xA5jY\xAF\x00\xDA'\xF9\xB2<\v<\xC0|k\xBD\xDB_?w'aO|\x18(M\xC7\xBE\xC1g\xB9\x9FA\xDF6\xC6|\xC2\xA3\xAB\x8A6JO,\x107\x05\xDA\x0E+`@Q\xAEW%\x91\xFF\xEF*\xA4\xDF\xC3vy,u\xF6\xA9\xF3\xD90bQ\x02\xAAe\n\xABIQcE\xE0\xE7\xAA<\x8F\x9B\x8C[\xAD^G\rC!f\xB7\x97\x8B\xD7\xE9\xDA<\xFAM\xAB\xAE=\x0E[i\v=P\r\x9B\xD7\x95\xCE\xB9\x8B\xDB^\x8E\xAC\x152e&\xA1\xA8\x92\xED\xD7Oe\xAF\xB8$\xCA\r@\xCFO\xF3\x97\xEF\xBBn\x0F\xA9\x01!\xC05\x95'\x9F\xEF\x979\xBB\xB6\xB1\x12!\xD6\xA5\x91T\x18\xEA\xB1_\xA8n\xD9I\x82B\xB2\xFF\x8AfC\x19\x85\xA8S\xA2\xE5\xBD\x15\xA8\x87#\x03\xD1\x02\xFE\xBB\x82\xC0>\x89~\n\xC6\xF7\x89\xB5mj\x03Z\xC7\xA8\x05\x91x\xBA\x93\xA9\xA6\xF1\xE9!\x05\xF7\xA3\xFFj\xE4\xBE\xCC\xBC\x94\x82\x10\x93\xC1+\x87\xB3~\"-\x9A0\x17\xEC\xEC\x8E\xE8\xA9eR\x10\x8C\x19\xA9\xBA\xC4\xE7+\xA7D=\x0FU'\xFDR\x04\n\xDCd\x00j\x88\xF6>\xF0\xCA\x0EZ\xBF\x7F\vhf\xAA)#\xB1\x84\xF3k%\x02\xAE\xAE\xD0R\x8C\x13\v\xC5\rp\xF0'\x8A\xFF\xAE\x14\xC6\x94\\\xBF\x16\xFF\x11\\\x97\xFE\xAC\xD5\xEAI\xC0\xFF\x1C\xB3\x1BV\x12\xFF\xAD\x1A\xE7\xAF\xC7\xE8rt\xC68\xBC\xB3_\xF1\xD5\x1A\x06<\xAB\xE8\x97\x18a\xA5\xFE\xA7\xAC\x1E\x9B\xF1't\xCF<\x8D`=\x13\xED\x04\x9D\x908?\"\xEDkC\xF4\xFFH?\xB1\xBDG\x95\xAAQY\xB5\rX\x91\xD1\xAF\x10q\xD3Z\xFEC\x03%\x00\x97Nww\xBEv}\x9A*\xD1?\x01\x94F\x1EOG\x05B\xB6\x9E\x1Ea^\x91p\xA0R\xE1\xFC\xF3\xF8\x8F\xAC\xD9\xED\x7Fm7\x07%U\xAD])Jj5\xF0a\xF4>\x9B~\xAF\xF2o\xC9\"\xFE\x8B\x10\xE8M\xD9Rj\xA6(\xCDZO\xB9r@Td\x81V\xAB\xD7Q\xEA\xE0\xF8x\x1A\xCAD\x8E\x1F>\xF8\xC3y\xEB\xB7\x8DQ\x9D\\\x81\x15\xB8\xA5.C\xD6\x80\xBE\xF0\xFA\x8Dt\xD9\xEE\x14\xFEB\x93\x90\xD0\xD9Z&'\xB2\x18\xF8\xF7\xBBe7\x0F\xCA\x1B.im\xB9\xF4k\x87\xBE\xEC\x97R\xCA=\xF5\x0E\xF1\xDFM\xDC\x1A\xFB\x8C\xCA\xADP\x8E-\xCFBqS \xB0\xDF\x01ll\xC3\xF5iE\xF2\xCFA?b\x89\xBA{\v\xC2\x96\xF0\x87\xAC\xF5\xA2\xE4\xDF\xF2u\xE3\xED\x8E\b\xA3E\xEF\xC1\xBA}\xA1\x14\x91\x8E>\x1E\n\x07\xAF\x99\x9C\x17\x12b\x947RP\xEB\xD3\xF9SS\x90da\xFE+M:\xCCY\xF9A\x8C\xBD\xE4L\x9C\xBEE\xC4-iO\xF6\x98@\x05\x8C\x97\xF2\x1F\xEF\xBB/E\x84\xFD\x12\xA0\xC5\x1Eo\xE3?\xDE\xC3\x80{60\t\x1F\xAE\xEC =\xB5\xE0\xFE\xDB\xD1\x9Ct\x84\x1F\x81*\xF9\xCC\xB6\xFA\xBF\x86\x8F\xD2g\xCB?\xF2$\x84m\xFE\xA3\x97\\\xFD\x9A\xA9\xE4_\x89d\x84\xED\x15\x11\xAB\xA3,\xB3\xF7\x0F-\xD6\xB9\xEF\xDAs\x84W\xF5$\xFD\xF7\xD35\xCF\xCE+7X\xCCd\xF2\x8D\x83\xFF\x92\xB4C4e\xB5\x85\xE9g\xBBThA\x10\x9B\x91\x1368\x98#. FzG O.\xCA\x02\rL\xBF-}\xCB\xA9\xD3\xB96\xE9\x1A7rg)\xDD\xB3\x9AAk\xB9\x84\tPyk\x06\xFA<\xFE#>oS\xA8\xBB\xA8\x92>xG\xE8W\xD0\x8B\xC2\x9E\xF7[\xFF'_}\xBBM?z\r\x15n\x8B~\n\xB0n{\xE8\x86\xB8\x83~)E\xBF\x8EX\xAD\xFB\xDE\xBB\t\x00\x8F\xE8wS1\x86\xFD\xC2\xBA\bR_\x93\xF8\xDE\vkd\x97$\v\xAE\xA1\xC4k\xBE\xCDb\xD99\x17W+\xB4\x88\xCCz\xCE\x88\xFD\tm\xCC\xF3\xCB\xB7\xF6\x0E\xEC\xDA\xC3\xC7\xD3\xDF\x03\xDCmi\x92\x7F\x9F\x00\xF4{\xFE\x9CI\x90e\x15\xB0,\xB9\xAD\xF8\x8E\x9F %\xE6EE\x88o\x89U'\xF7_{\xE2}|\x94\xB0\xDD\x86\xFD\xCF(\x98\xF2\x0F\xD6\xFF\x97f\bQ\xA4]\xED\x1F^\t\xC3\xB2s\xD1\xBD\n\xC1\x85[hVeXc<\x14\xEF\x0F\xA9\xF0\xB2\xDE\xF8\xD5\xAA\xE8<\xE0\xB4\xED\"\xEElKo~\xCB[M\xC2\x8B\xD4C\v\xD2o\x99E\xBF*k\xEBXf\t\xD6\xE5]\x94w\xA8\xFFo\xB2\xF7q\xA5IQ\x8F\xC8q\xAC\x1C?\xFE\x1FJ\x02\xDC-\x80\xC4\xC9\xCAW\xDD\x86m15o\xFD\x8A'Z\xA9\xE4\xEEa\xA7_A\xB7@\xF6\fNI\xBDl\x8D\xF5\xEB\x0F\xF9\xB7\xFB\xD6t\x15z!\xC8h\xA5\xFD\xC3\xAB\\\x19E\xA7\xD8\xF7\xFD\xEAm\xD3+D\x9E4\xBD\x9F\xD0\xA1y!\xDD~\x06B\xD4\xD4\x1FsR\x88\xA27I\xBDq\xC1QC\xD6\xDD\bE\xD5d\x17\xCD\xAF\x8B\xC7\x9F\xC0\xD1\x03G\x14\xB6\xF0 HD\x97\xE9l$d\x1D\xCD\x85\xD6kA\xA3 \xADGT\xB5rU\xA3\xC8\xAA\xDC\xCA\x16\xBD$t\x10_\x11(\xD6\x1F\x96\xF0\xDE\xD3NAQ\x18b\x8E\x03\xEE\xA5\x8E\x81B\xB6\x96!F\x1019\x93\xEA:\xE4De\xF4\xDA\x94X\\^\xE7j\x8C\xCF/Jd\xC5_t\xEB\xAB\xCF\xB2I\xA6\xAD-O\xE0\r{{M4P\xED\xA6\xD7\xF66\xA8C\xE02\xC1#\xA5^AA\x98\xD1\no\xEF=|\x03\x8F\xA2\x93\xA4\xD5\xA6\xD3\xB2\xC5O\x8C\x91\xFA\xE6O\xA1\xDE\xF7\xF3\xFBF\xE9o\r\v!cZQ\x00\x1Ay,>,\xAA\xF2f\x89\xF6\xA2U\xEF\xA6\xACE?\xE5\x8A\x9DZ\x98~9\xA9h-\xC9BTnl\x12Ns\xDDD\x84O\xA8a,k\xC7\xF3\xF4\xB4x\x98\xD2\x1F\x9D\xF8\x15}\xF9\xC8\xEEq%\xDB\xCB\x98\xB8o>\x04#\xFB\xA4\xC3,\xE5$\x1F\xC98\xD4Kn\x84L\xE4\x90be\xED*:\xECq\xAA\xA1ge\xD4(W\x10\x84\x93\xF4\x1BE\xC3x\vR\\q\x10\xFCW\xCF\xCD\x07\xBE\xA9O\xB0\xB2\x9C\xA0\xDFX\xBAm\xBA\x9F u\x8F\x14\x8E,\x8E:G\xF6\x0E\x90\xFA\xD6\xD4\x1D\x8A\xDD\x17\xDD\x8C1\x9A`\xBD\xE0}c\xD6\x86k\xDD\xCD\xACv\xB6M\xD6\xD34\xBDe\xCA\xF6\x18\x1F\x8C\xEA\xA2\xCF\xC5!\x910Y\x9A\xC3Q\xFE\x91\x8E3\xDBj\xD3\xB6\x89\x87\x89l\xF1\vl\xAF\xA1\xF4Q\xE5+]\x95%\xD5E\x8F\x8F0\xF4\x8A\xFC\xAB\xC5\xC2\x83\x91\x81\xA3\xC7\xFF\xB7\x85V\xD5\xDC\x85\x11V~\x87j\x11R\x10\xD8\xF8\x17\xB9\x98\xE4\xAE>\\\xC0\x7F\x11D\x8E\xAE\xC3\bs%\x04\f\n\xAE|#(b\xA4'E\x03Hw;\x8E4L\x1C\x1D\xA0\t\x8D`\xBE\x83\x04V\x04\x95H5vD\xF4\xF0\x94]?\x0EQ\xB4\xE4J\x19\xF3\xDF\x06\x949\xF9O y\xFA\xAC\xD5\xA2\x8BW\x96\x046du\xC1\x7F\xFF,h\xEFo\xC7\x18\xF3'0T\x93\xB1\xF3\x19\f\x99\x98\xD5\xF0\xDBqA\xEC'GN\xAB\xF9\x91\x89\\\x1F\xD5\xF3C,0\xFD\xA4C\xFEUp\xBB\xD6zcB\xD5\x88\\{\f)\xE6\n*\xFE\v8\xB9\xE4\xA3\xB2H\xD2\\\x80\xFF\xB4F\xAC:\xCD\x9F\xDC\x93\xC0s\xA2\xA8\xCE\x9F\x13\x16\xF8V\xC1\x7F\x81\x1CF\"\xE9\xF4(\xC5&\x8E`\x01\x05\xD7\xEA\xC7B\xFC7\xEC\x9B\xDA\xA1\x9C\r\x81\x1CR\xC4>\xCB\xE5\xF3\x9E\xB7\xBB\xD7\xEDS\xCE)\x10\x82\xAD\xB4\x17\x9EmW=\xBD3\xBA\xA8\xFCK\x8D$eLd\x88\xF3\xDF\xD8w\xBBl\xFE\xD3\xFB\xBF+\n\xC9G:$Bi\xCA\xFD\xBC\x93\xFF.\xCB\xEA\xE91f\x8C\xFF\x12\xB6\xB4\xE0\xF2\xCF\xB6[\xAE\x12\x11\xCA7\xEA\xB8\xFC3U\x8B\xA4\x02\xFE\x8B\xC9\"?i\x8E\xD5\x17\xEC\x1F\x11\xF8\x87\xD6\xF1k\x13\"\xCB\x11\xF5!\xD9y\xBBYp\xAC\xD7\x8B\xFA\xD2\xDB\xC7\x87\xC8\xAB\xD6\xC0\xDC\xC1\v\xCB?b\xB5\xA7w\n\xFE\xE3\xF2\xCF\x1B\xC7G\xFCQ{\xFD\xE2A\x19\xF5\x05\xF0o\xFC\xE3cV\xDE\x8D\xB4W\xFB\xEE\x80h\v\xBD$+\x1F\xB2A$X\x18q\xAC\xE6v\xE8\xAA\xAA\xA8C\xFEM\xAF\x16\x8F\xFFfJh\xBE\x1B\x03\xAA\x04Z\b\xD5\xFA(F\x97\x03\xC2\xC7\x88\x97-\xA3\xFD\xA8E\x1F\x91\xC3\x1Ct%p#I\xB8\xA6\xF9\xF2\xEFq\xC1\x7Feq\x87\xAF\xC0\x9A\xC1C\xA8~\xAD\x0E\x1Dp\x1FS\xFB\xC7k\x12\x8C`+#G\x9E'\x8B\xCE\x07W\xBF\x7F\x14\x97\x98@\xBB\xB3u\xBE3\xEDH\xEE\xD8|j\xFB\x04\xFFq\xF9\xA7'\x11\xDB\x9B\xB1\xF7\x0Fm\xC8\xCE\xA6\"\xDB\xF9\tfG\xDD\x887\xDE\x98\x95\xED\x95\x82Lb\b\xDD<\x18\x95\xD2\xFB\xB3\xCC\x9DC\xC7?wiv<**<\x1D\xC1\x07j\x05`\xD8\xF5\x0F\x8E\xE4\xAC@=\x012h\xB16\x16\x98\xFAt\xD1\xEB\x9E\xB6h bw\xD5g\x12\xF8$\xF3/\\N\x99*\xF4I\x16@\x1B\xE9=X\xDC'\xF1\xF4%l\x16\xB7\\\xF9\xCD\x0F\xA1\xEC\x98\xD8\f\xAF\xA5\xB9Pq\xF9B\xAA\xFC\x92\xAE\x02E\xA92\t%\xFF\xB4(:\x07\x8A<\xA2\xFE\x84\xC3v.>\x82m\xFC%{\x9E\xE7\xCBOjJ[\x0F\n\xFA\x99\xB8\x85\xB9\xBA(\xAF\xDE\xDE?f\xC5\x84\xAA_\x9B\x12\xBE\xE1\xEE\xFDC\x8A\x06\x14\x9B\rE\t\xFD\xE2\xC6FG\xFAE\x90ol\xB6\vHd\xB6.\xEB\xC2\x1E\xEA\xF0[%[<:\x8D$Yf\xD4n\x19D\x0E\xFAy\x11J\xDD\x83^\xFE\xAB\xB0k\xABbY\x89n\xC2|;D/\xF6\xFEG\xB6\xDC\xB8\x8D\xBC\x8D\xFD\xCC=\xAF\xE6\x02\xCB\x93\xCE\xFDc{m\x95uJ\xF9:\xA4\xBE\x99Qv\xA8\xD8?|\xF78l\xE7\xED\xB6\x95*\xE4\xDF)\xDA?n\x83\xCCA\x03p\x7FH\xD4\xAA\xD6\xE1\x01\xE6Ma`_\xD4\x8E\x87j.\x99m\x18\x1F\x12\xBB\xD2\xCEP\xAD\xDA\x19\xC8G\xB5\x88\xE9\xE8g\xFE\x88Sg[^`K\xEE\x17\x96\xEB\x9BKe\x14T\xDC\xCD\x9BZ \b#\xFF\xF6\x9D\"\x1E\xBA\"I\xE0Q\xEA\x8A\xD0\xD1\xA5\x8E-\x15\xD0\x96\xE2\xF8\xA3u\xE9\bU\xDA\xEEc\v\x8C\xBCJM\xE8qF\xAFG\x9C\xA2\v{\x7F\xF7c\xA65+a\xC8:m\xE7~\xC7\x9C\xE9\xD9\x88{JO:N>\xF8\xA8\xD8?n\xC3\x01\xE6[\x87\x83CI\x87\xFE2{L\xEC\x1FG#\xA2\xED\xDE\xE8\xC8\xCFU\x04\xBA>Kv\xB7\x9E>\xC8p\x01;\xF9\xE2q\xF1\xF8\x7Ft\xB4\x14-:m\xA1\x8E\xB7\xFF\xF7AQ\x97\xD5\xCC\x88\xD4\x11S/4\x91u\xFA\xAA\t\x84+\x87\xF99?\x10\xCClc;\xBA@\x88\xD8t8\xF1\x95\tj:\xACH\x9F#*\\\x90\xDB}\b\v\x80O\xCB>\x12\xE2\x8F\xF3\xFA\x04k\va\xE729\xBD\xAD\x99B\xCF1\xDF@V\x16\x9C\xFBV\x11\x95\xFE\x93yr\x98;\x98\xE1j7Wg\x9AH37\xFE\xCA\xB5\xBB7\x90\xEB\x93P\xC6\xFE\xDA\xE0\b\x83><\\\xE8\x18\x1C\xAA\xC9h\xE46\x88\xC2+\xE9\x97\x84Cv\xE9I\xD1\xCDM(Y\xBA\x9E\xC3\xDC\xE8H\xD4\xA9\xA4\xCB\xF3\xCCbo\xE3\x90\"g\xDCR\xD2Fe\xE4T\xAFS\x8DJD\x9F\xE0\xDCh\xC8A{=\x87&\xA6\xAB$\xBE\xD2\xAC\x1C\xA0!\xDE\xBB\xC3~5\b\x15x\x17F\x1B\xF8\x96\x18\xE2\x8A\xAB\f\x99\xAA\xC6\x7F\x14S*0\xC4\xE6\x85\xF2\x06\xB9J\x9C\xE6\xDAC\xAB\x00\xA5h\tR\xC7\x81\x93\xDB\xC6\xCE$\x14\xFDJ\xA7\x82)@\xCF\x8F\xC8\x8E\x1C\xCAD\x8E3m\x96+\xDAq\xD4\t\x9Ch}T(\xF4\x96)x\xC4V\xF2kN\x99`\xF1\xA1\x1D(\x8AR\xC8\xF1\n\xE87\xC2Je\xF1\xB6\xD2e\xF5!\x02\xBF\x14\x15\xE6J\xCF\xC6\x1C\xF3\x87\x06\x86\x1C\x1A\x99?\x85#r~:\xB7\x85t\xD9\fgd<\xEE0#GF\x1C\xF1O}(\xCD\xFF;\x926\x81_g\n\x1E\x10\xAB3E\x86\x98^\xCC\x7FsD\xBFGL\xA0\x8FjK\x9B\xCER\x14&\xBAfez$7+{\xF3\x96\xDF\x98O\x01\xC6\xB0\xB4\xA7\xD5\xA3\x9E\xF62\xDDD\x93i\xCCbc\\4k8\x83F;\xAA\x1A\xC8\t\xF3Ud\xA1\xFB\x02\xC4\x7F)\x14/V\xD16\xB8@\xE3yG\xF6\x0E\x96m\x11\xE7D&%\xA5\x89{r*K\x80\x96\xB7\xAB\xB6\xA2\x8D\xB9,k\xD1\x95\xE2| \xDA!5cIV\x13[\xEA\xD6=[\xD4\xF0\\\xAFk\x1BL:m\xD3\xAD\t\x06\xC4\xF6f%(\x8A\xA3\x9B%\xE7\xBF\xA1?\xC8\x7FC\x9C~#c\x19z\x97\xA6R\r\x02\xB9\x9Fm\x1BhK\xB9d\xE0@?\x82\t\x06\xFD\xD2\tINi\x1B\x1C\x8Cs\xFA\xD5G\xB5\x10V\x89\xF7\xAB\xF79\xA3\xD2\xFE\xA4\xB0u\x05\xFF5\x8D\xC7\xF0\xDD\xB8(\x864\n\xF8\xCF?\t\x14Z\xCC\x7F\x80\xFF8\xE9-\xDB2\f\x7Fh \xED\b<\xF8s6\xFF=\xC5\xF9O<}*\x1DQP\xF7uQ \x9Dv \xDA\xE8,\x9DNJ\xFE\xBBE6\x84Vs)\xCF\xCA\x86\x92\xD6Q\x8C\x93\xF5%\xBEjS:\x95\xC4\x18\x96\xFC\xF3]\xAF\x7F5\xFD\xAD\x97\\+\xA4A?E\xC0\xB2\xE1~V\xE0\x88\xEB\x1F\xCB\xC2D=_\xC4u\xF7\x89\xAE3\x83\x05\xF43\xE5\x93R}Fx(\x87\xBE\x8A\xF0\x01y^\xB1C\xB5\x00\x18aH\x05O\xE3\x96-\xFA8\xA0\xAF\x91\xF4\xF3\xA9G\x1A\xE7\xF2o\x95#\xD2\xAA\xA7P\xAF*A\xD2|\x02\x82~\r_\xD5c\x0E\xBB,\x12/\x94\x7F\xDCv\xAE\xEB7-\xFE\xB3\xC0\xA7\x97\xB0\xA2\x16)\xF3B\xA1i\xCE\x7F\xA9\xB1,\xD0D\xF29L\xD9\n\x81\xF6\xF6\x9B\x06\xDA\x8E\xCC\xBE!_\xC3\x91\xDCy\x06#/\xF9O\xB1\xCA\\/3\xF2X\xC4\x1F\xA9L$\xB7\xE3E,\xB2\x97\xA6\x91\x83\xE8`J\xAE\x83\xC0\xBF\x00c\x07\x7FBt6\n\x9An\x1B\xB9b[\xBC\x89I\x16xK\xD1OK\xCA~\xC2\x9C~\x97\xAA\xC7O\xA3\xA4v\xE0NQ\xBE\xA1rv\xFEF\x06\xFE\xB54\xDE\xAF:)\xDF~\xE9\xB5\xEA\x94\xA5Q\xE0\v\xCEj\x18m\xE8\xD6\x0Fd\x80/\xFCS\xD6r\xF8Y-\x96?\xD0Ud\x8Cj\xA3\xF3\xE5_\x1C\x87{\xA3\xC0\xFF\xA0\xE7h\xCA\x92\xAC\x8A\x99\xE1CW\xBE\xD4r\\\xCA\x83\xEFy\x0F\x01\xFA\xB04}\xFD\xD2\x92H\xF51\x98\xB8\x9A\xAF\xC6ub\xFF0\xE2\xB8\xDA\xA6_\xB9\x89\xB7D\x07l\xCA\x03(\xCF\xE1Y\xB9\xF3\x15\xF2\x1F\xB5p/\xD8\x12\xC7Y\xB9\x90\xA7O\xA9D9\xCESd\x13s\"Z<\xFEm\xBE~\x87\xE0\xD8?rP\xCB\xD9\xB9~\xD3G\xAEW\xEC}E\x14\x18\xAAs\xDCL\x1F\x1D\xE1\x16e:\xA5\x12T\x00\xEF1e\xE8D\x8B\r\xD9\x07\x8B\xE8\xD7\xCA\x17N\xA2&\x03\x94\xC3\xE5\x05\xEA\x97q\xE2\x04b/m\x8B\xF7\xA7Z\x94\xFE\xD2\xEF\xFD&\xBFv\xACp\xFF8L`\xE3>\x13\xA6\xA5\xBF\x1Cp<\vg\x15S-d.\x19\xE2\x18\x1B\x9B\xC8\xCD\x97\x7F\xFA\xD9b\xF9\xB7\t\xBA\xF0N\x0FZ\x1E\xB9!\xA9\xBFp\xDD\xA2L\xD1/\xC9ts`\xB9S\x7F1\xD1\xC8t!\x9F{\xED\xF5[\xEF\xEB\xB5\x1A\xF4F\x81\xD0N\xA7\xB7b(\xE4\x8B\xF2S\xEC\xBFYy\xC8\xF5\xA6*\xFB\xBA\xD0\xFE\xF1$\xF3\xC6\xB1\xBB\x17\xC0\x17\x99\xEFf\xE0\xAA7)\x8B\xE9\xBF\x95\xEC>v\xDB\xD7-\xFDo\xDA\xFB\x18\x83\xFE\x9BG\xA4\xBE!]\xF1'\xBEM\xF4\xE3B\xB04+\xEE\xF2\x1B\xF83\xCEu)\x84/\xB5\x12\xE6\xFA_\x9F\xD2\\\xFB\n\xE8w\xA0@\xC3\xA5\xF4\x03\xB9\xF3N+#\xD8h\x04\xCA\xB8\xFC3\xBC\xC0U\xF6\xF2+\x9Bi<\xC9\xCA,\xFA\x95\x99\xC80!B\x8C2|$+{\xB1\xFF\xEC\xC9\xCF\xA9\xD7\xB3&\x03<\xF7\xA4c\xFF7V\xFC\x9A\xFF\xF7g\xC7\xCD\x8B\xF6\xD7\xC5\xE3O\xE8(\xE6G\x15\xF3e\x85\xB1I\x98\x95\x05'\xEF\xA9+\xBAB+\xB0\xA0+\x87\x8A\xEB\t\x95\xFF\x7F\xBE\xFD\x1C\xB5\xBA#\xB1\x93\xCEy\xE8\xA6\xBA]y\xCEr\xA3G/\x9B(.@\xB6`,\xF5b\xE0\xEAy\x01l\xAF\x91\xA5\xFF^\xA36\xC8\xF2\xA8\x8C\xCFz\xEE\x90\x96\xFA\x19a;\xDFQD\x17\xE3\tQ>S\xDC\fI/|J]\x14\x1C\x8D\xF2\x1DP\xCA\x7FJ\xEF*=]7\xC8\xADJ!\x18W1\xDDT\x9Eg}R\xC8\xA0M>\x87I\x96\xCBoe\xE5;\x16P%\xA5dmb\xBATDB\x14J\xF1'\x81i\xA6\x9F\xE8w\xD2/\x903\xD1D=\x81UY\xD48\xC35q\xD5~\xC7j\xC6\x0E#!2\xF2\xD6\x8B_\xEE\x90\xC6\xF5\x86\xACE?\x95\xAF\xEB]o\xE6\xF0\xCA\xE6\xCCfEbw\fX\xCFIpup\x07\xFC\x801z\xDD\x03o\xCD\x02\xEB9\x11\xAF~%g\x19A\x9A;p\x82\xF2T\xBB\nc^\x05H\r|\x0F\xA5\x8Ev}c#Y\xF56I\r\x88D\xA6\xF3@ \x9D\x96\xBE\xE1\xD2\x99qu\xC5\x80\xA0\xD0#\x8F\xDB\xA2=\x90\x1E<\x04\xD7\xF3\xF3u\x10\xC88D\x9A\xD9\xED+\xFD9\x11\x1FL\xB3\xD2\x7F\x1Bw\xAAL\xFA\xB2\xBC\xF4\x9A(\xFA\xB5\xB1\xF2/{\xAD\xF6E\x96\x1FS3A\x8EN\x81\xA4S\xBEKu\xDDgr\x03?\x8Fry\xB77\xF6\xBE\x95B\xF3\xDD\xAB-\xFA\xF1I\x8A\x80Bc\x9C[OZ\xE8\x96\xF5-}@ew\x0E\xA8\xDA\xEA\x85\xD2\xB4\xB4\xA6w\x96\xF0W\xBE\xB8\xA1\xB0\n\xC7U\xF4\xDF)2l\xBD\xCD\x15Q\x85\xE3\xBAD$[\xD6r\xF5\xEA\xCB\xD2Pd\xAEG>\xA5\xAE\xF8\xB6\x98K\xE7?\xD9\xFC\xA7\xDF\xD8\xD8\xC0D\x9F\xCCy]\x89e\xD8I\x19\xA3\xADp\xCB\x10\xC9\x1Cs=\xF5\xB0#z\x01\xD7\xE6\xB0\xA4_\xB9E?\xD7\xCEF+a\xD2*\xAB\xD7Z\xC4\n^\"\n\xCE\x15a\x17\xAB\xB7\xB5\x95\xB9d \xFCS\x03})4\x0F>;\xE5u\xAC_J\xD4\xAC\xDA\xDEN\x88\\w\x9F^\xF2\xECy`q\xD8\x04\xAA\xB6\xE4T\x156\x8C\xDE\xAD\x14|\xA9\xB8\xAB\x88\xFF^*\xFC/\xF1\x8B>:\x92\x8E*\xCE\x91\xFC\x17\x19\x05\x02\xA2\xA1/\x9EB\xE9\x8C\n\xCD\x97NK\xFE[m\x9Bd\xE5\xD3C\x7F-\xB1\x0E\xF4\xA2\xF5+\x84B\n\n\x9C\xF6\t\xA6B\xC4i\x94\xBE\xE1\xA8\x8D\n\xC1\xCB\xA2E\xFC7\xCE\\\xBB\xE2\xEA\x1C\xBB+\xA71-xH\xAC_\xF7\x94\x94\xB1\xEBM-&\xA3s*\xCF\xA3\xED\xFBgR\x18\xDF\xEB^\xA6\xE4\x9F;\xA7\xD6o\xE5\x1A4\x03F\xBA\xF3\x85\x1B^\x04\xD6/\xE7\xFC\xB7%\x06\xD5\xFCZ\xF3\xB7<E\xE7\x85\v\x19N/\xFAo\x8E\x94\xB9xhQ\x12\xB3N\xF9\xF7j.\xCD\xC5\x94\xB8o\x03\xD3\xD3)+h$\xD4\xBFM^\x87I\xDB>z\x18%^i<\x15\xF0\xDF\xD9B\xCB\v\xCB\xA1'd\x18\x10\xFAS\x8E\xC9\xB4\xC0}\xE3]\xA8\xC9h\xB3\x05\xEBw\xB1\xD7\x82\x82\xB7\xF9\xAF\x0EWG\xADV\xAC\xE5\x86\xDC\x85\x16G%\xB7\xE7X\xB9\x9C\xED\xF8\xC0\xEE\x1C\xAE\xDF\xF1\xF9Zk\xFD&\xAD\xF5\x1B#\x07\xCE\xFA\xE6\r\xCF\xBE\b\\\xB2\xDA\x046q5^\xC2\x0Ei\xE5\x13{\t\x80\xA7\xB3\x90`%\x85\xECX\xB2\x93\xB2\xEEG{\x0E0M\xBE_Jq\xBA\xEC\xEF[G\x81E\x12\x89\xF8oPb\xD1\xAF\xE4mA\xD3\xBF\xBC\xDC\xE1\xED\xD99\x14\x92)\x1E\xDA\x13\v\xF1\xDF\xEDL\x95\x8D\xF40>\x83\xF7Qa\xAF\xC7\xC9\x7F\xF5\xD0C!\xC9\x7F%\x92~\xB73\xD7\xE2\xB8E?\xEBA\xB4\x14!\xE7J\x83\xD7=%Sc\x972\x99f\xBA\xD5\xE6\xBF\x07[R\xB8uI\xDF\xB7\xCB\x1C\xF4\xA3\xB5_\xB5-\xC7\xF9OK\xB7\r\\{\x1E\xA8\b\x13\xFF\xDDly\xC1\xB4t\xF4Rn\xAF\xBD\xBFx\xFD\x16&s\xFA\xA7E\x05@z$\xAB\xCF:2RV\x8D\xF3\x1F\xFCC\xA3\xCAq\xF4\x95\xDB\xAC\xFDC@+\x8D\xA6\x1D.\xBD\xE9|\xA7\xCC>\xD6\xCF/\xC4\x7F\xA3L9\x1F\xD3\xAC4\x01\\\x99\xE1\xFC\xE7\x7F\xCA\xE1\x1D]\f\xF7\xF5y\xAE\x92\x98d/\xD0q\x92\xB9\x96ycj\xFF\xB5\xF8\xCFh\x13\xF4\xFB\x10\xCD\xC0\xD5*\xE9\xF7AS\xD2/f\xC9\xBF\x8E\xE3-)\xFC\xB8\xDD]\xDFo{\x12p)\xBF\xF6}Uq\\\x07\x18\xEB\xC7\x07>\xD7\x07\\\xCA\xE5\xDFbN?\xB9~\x8D\xFA\xADO\xF0\xE1?\xE8j_\x88!\xEC\xE5L\xB6x\xBA!\xCET\x13$\xCA\x99\xF0\xDE\x17K\x03\x81\xE7\xD3\x8A7\xFCWY\xFA\xCB\x19\x91\xFB\xD1\xEF\xD8?\xCC\xC1^\xB5\xF1\x17\xAE_\xFD*iy)\xB9\xD1\xC4\xF4.\xA0\xB4\v\xF8\x07\x18\xFFv\x97C\xFE\xB1\xC0\x0E\x93\xABW\xA6\xC0\\\x11;jy\xFBRK\xFF\xB3\xF3\x95o\x102\xACDt\xC4\xBF\xFE\x19I\xD6\xAC\xF1U\xB5~\xE5z}\xE7\x81\xD5)\x94\xE6>\xBFL\xED\xDD\x8B\xD6\x01W\xF1;|\xA81\xCE\xD5#\xB8\x02c\x99\xAF\x02k?o\x02\x157\xDC\fl\x90\xB7\xDB\x94#\xD0\x12}\xAE\xB0U\xD6\xA2\xC2\xE6\xC0e3%\xFC\xCE\xDD'\x8F1C\"\xC7~\x88\x86\x7F\xF3+\x8D\x80\x7F\x97P\xADN\xB1E3*\xB1\xB1l\xAF\xA8\x84\xFB\xD5\xA8\xAD\xBF\x94\xBD\xDFr\x87\x19\x85\x90\xD3\xB2I\xF1\x7F\x8At\"\xAA\xDAZt\x00\xF8p\x92\x9E2\xED\xF0\xE2\xCE2\xBEt\x85\xFE\xE7\xD0\x7F\xE2\v[\x01e\x8Eet\xB3]\x13q\xA7X\x0E\f\xF2)\x171\x1C\x00\f\xB6P\x06u\x0E\x15\x8E\xD8\x15\xD7\x18\xD7\x9F\x8E9F\x96-$\xB4\x8B\xDD\x90.\x1E\x7F\xE4C\x93\xD8\xC7\x97\x15f \x07\x8B\xBE\xB9\xC9p\xD4~n\"\xC0\xCA\x13^\xBE\x17\xF2\x8F\xA0j\xA5\xAB\xCCa\xCE\xD9^\xD7\xFCQ\x84\x84\x86\x06\x16V\xCB\xC2\xF4R\xD7\xD5\x1A\xE5\x1A\xA7`q\xA1\x8A\xCD\xA5Ly<(\x03?\xD1y\xF5\xC9\x94\x82;\x0E$\x1B\xE1\x02\"\xD0\xA2\xF0\xFE\x13\xC3\x1D\xD6\tkT\xAD\x12s(\x10\xFCxiA\xAB\xDF\xC5\xFC\x93\xD6\x1F\x85\x15\xEF]\xC0C\xE0\xB4\x87\xAF\xCEr\xFD\xF5\xDE\x99x\x01\xFDlI\xA3\x89\xA6\xA153\xDC\x00\xD4\\9\x9Ce\xEE\x99\xD1\tV>\x93\x1Fgh\x0F\xBF\xF7\x83\x89\x1Dx\x95\xC9\xF8l\xF7iO\xD6xhNm\x8BO;\x86\xF4t\x19\x0FBO\x9E\b\xD7@\xBB\xFE\xE5\x19V>\xEB\xF5<\x95\x04\xCEE\x92B\xFE\xADvI\xC7\xBB\x8D\xD8+Pn8\xFD\x8C\xC3\xD809\x8F~$A;\xA1\x1F\x1D\xC5\xFAGf\xFE\x13\x1B&\x8D\x93mP5\x855\xAC<\x06lJ\n\xFB\x17\\\x80&\x9C\x01<\bZ\xAD\x16\x8Ew>\xE7\x89\x8C+!\xB2\x99\x1BX`\xEA. 0s\x16\x8D\xF4\x02\xF4.\xBC\xB7\xF1\vI\x82\xC55\xDF\xB3\xE5{\x05\xA7\xD5\x86\x89\xFAF\x99\xE1'gn\x034\v\xB2\xFE\xEE\xE3\x8FG\x81\xA63&\xD7\xA0\xF6T\xC6\x98kgs3\x02\xFFk8\xE4\xED3\xD1,\xDD\"\xC6\xA9\xADO\x9B\x9A\xB7}\x9EY\xC57-S[\x8EM[\xDF\xC8\x9Fe\x81X\xBC\x83\xB9\x1EH\xCF\xEE\xED\x02>\x9E~\\$2N\xCF1zo\xE5\x96\x1A@\x84p\xED\"5\xF4\x0E\x04\x8B\xF6\x0F\x95\x18x\x03\x02S!\x04\xF37F\xB0\xB8]\xEF~\xBFe\x0F\x8E3\xD7\x13\x02lG\x94ZUD\x15\x1C\x16\\\\!\v\x04\x1D\xA1\xB3\xF3\xFC\x8C\xEB\xA3e\x93\xA2?\xC4\xEF\xE0:\xFA8\xA0k^\xD1\x0E\x18\xEE \xA2{\xFB\xF8\xB9\xFA5\xDD\xCD\x0E\xDD*K\x9D\x9F\xA6\xBC2\vZ>\xF9F\xEB\xAB0n\xB7\xDF4\x9C\x04\xAA\xCA_B\x8C\x95\xBF\xDDs\x1Ds}q\xE3\xFF\x8F\xB9n\xEC&\xFE\xDB*\xBB1j\xDDm\xFB\x92Z\xE3V5J\xB7c\xC8\xAA.\xEDrT\f\x7F/|\x13s\xCF\xBC\xDC\xC1\\\xAD\xB1\x8FU\x98@kU\x8B\x88\xDE\xB4m\x13\x15}.k\xD5S\xF8\xB6|\x8A\xAA\xACV\xA2\xAA]+\xEE\xF9B\xD1\xAF3p\xEDiD\xD5\xA1_\xF4`\xC9\xF3\xC6\x8B\x03V&~\xA7H\x9CM*\xC3\xBD)k\xB1\x85\xA8\xA2\x13\xF7\x15\xA0\xE1\x9Fd\x94\x8D\xE1J\b\xFAm\x17\x0E\x12\xE3\x95\x93\xB8\x8C\xE8\xE7\xAF\xC3\x8E\x87^'p\xA0\\\xC5\x97l\xFE[\x97\xD4\xDA\xB0\xE4\xB5Ui\xA5\x1D\x8A\x95gg\x7F\\#\xE62}\xA8\x0E\xA8~\x16\x98`\xAE\xBD\xE9qVn<\x9D\x85\xFB\x17a\xE2\xBF\xB3\xCC-\xE8\x17y=\bc\xF07j\x14g&C5\x8C8\x82\xAE#\xDDQ\xB8\x10?\xCF\xCA\xBF\xDB\xF8)\xBE\xAC\xE6\xC6\xCE\b\xEB\xE4\x9ENF\x8E\x14\v\x93M\x00\xDC\xB8vFD\\h\xC3d\xC1\xFB\xE0GV\x98-\xAE\xBDq\xAC\xFF\xDD\xF5G\xB0\xEEy}\xDBM\x19\xE5\"\x8C\"\xB0\rh\xE4']M\x05\xC4IK\xA0\xD0)\x02?G\x13\x8A\r\xE5\x8B\xBE\xC6oN\xF4\xBB\x1F\xFE#a@\xAF\xED\x96V\x87g\x127\xED\xBF\x9F\x90\xB5Z\xEB\xB6\xD9\xF4\v2\xE31\xACo\x98\xBA\xACp\xFD\x16\x01\xE4\xE2w\x1D\x8F\xDF\x01lZ\xCE\x87wO}\xF2\x06\xE6\x9A2\xDBX\xF9\xC7\x1E\x9B\x1B\x9B\xC8a+\x93\xEBw\xB4s&\xAB\xF5\xB4\xCE\xE7b`cVkB\xD3\xC4\x1B\xA7\xF2,0\xF3r's]?\xF4\x0E\xE7\xB4\xD6\x90\xF06\x18\xA7\xCE3r\xE4\x95\x9B\x8Et\x04\x01\xC4\x04h\xAB\xB0\xB8\xDD\x18*\xA2\x1FU\xA0lG`\xAA\x11\xC1\x91_\x84\xB1$i\xE4/\xB5:\x93\xCE1\xD7\t\x99\xB6J4\xF8H\x97\xF6\x19\xC5\x7F\x94\xC1N\x9B\x88!\x1A\x1F\x93\x98\xBF.\xB3\xC8\xAB\xD6o\x80\xAF_\xA36f\x83\x01u\f\x12V\x98\xFB\xF6\x96\x9Bl\xFA]\xCA\xD7\xEF\x923\xB5\x97\x14l\x96\x9Am\x8A\b\x10\xAD\xCE_\xB7\xF0\xF5{&\x85\xFF\xCAJ4\xEF\xAD(\xA9\x1D\xBD\x15\xAE\x1B\xEF\xDA\xBC\xD8\x95\xC0\xAD\xD2\xAC\xD7\"wv\x98\xDA\xE0\x17\xE6\x8F\x02T\x9B\xDA\x00*\x0F]\xDD\xD6\xC1\\\x9B\xC3\x1D\xAC\xE4\xF7\x8D\x9D\xFB'\x81\xAD5\xCF\x8Autw\xA7@$\xB0\xF9\x8F\x06-9\x12\x14\xB1\xD9\xEAI\xAD8]\x91\x12g;\xE1\xAA\x1D\xC4%\xE7o\xFC3,I\xEAf[\xA6\xC4\xF2\x87y^\x94\x85\x03KM\xE2?My8K\xE2\x96\xBFN\xDBa\x8B\x82/0\xC5\x7F[\x80T\n\xD0\x87N\xE2\n&\xDF\xE5\x13#\xBBh\xFD\xFE\xAF\xFC\x136\xFD\xD62\xED\nT\x1C\x9A\x19rd\xBBR\xF9\x86\xFA\xF6,\xFD\xF3\xD7\x7F\xB6e\rPu\xEDY\xFC\x14e{F\x7F\x8C\xB2\xA3\xA1\x1F\xC1\xFD\x8B\x15\xA3\xDFx}\x12\xCF1\xB7\xD0\xD4#\xFF\xF3cY\xE3\xAF~\xAA\xAEu\xAE\xB7\xCA\xA4q\x05\xAA\xFE\xBA\xBE\xBB\x13\xEE\xE9\x81NV\xD6\x1Aj\xDE\xD4\x0E\x9C\xD3\xFBD\xB7\xA0\xB6-b\xC7\xB1\x81\xB7\x88\x92\x8B\xFE\xB6[Lh}T+.+\xFD\t\x7F\x8E\x7F\x87{&\x82\xF5\x87f\xD2X\x9A\xD5f\xDBX\xD9\x1Djw)K\x02k\xC9\x1C\xEE\xA2\xA2gC\xF1\x1F\x99<\xAEy\xF2\xEF\xDF\xE1\xF6\nJ\xFE\x8E\x11\xFF\xE9\x916Q\x8D\xCAM\xD0}\xC3\xE7\xD6\x91\x9F:\xBE\xDF\xA6\x9F;k\x9C\xC2\xFA\x1B\xCCk\xB1\xC9\xE9\xBE\xB7;1\xFC\xB9\xD0\x97\x9Ey\xBC\x0E\xB8\xFA\xA3K\xF1\x01\xA6\x95zK\x19R\x8D^V\xFE\xB1a}\xB1\xCB\v\x1D2z\x9D\x0FN\x9Bh\xAC\x99\x1F\x96\x00\x1A\xA3\xF8\x186\x1E~c\xF0\x1D\x16\x88}\xFA\x1D\x86\xAF<\xF4\xCE\xEEI \xA0\xDF@lj\xFC\xEAMF\x123P\xE7\b\xA7\x03\x98yA8\xB7\xDC\x93\xF3\xF6_\n\xA1\xAFf\xE5\xED\xB7\xC0=W\xB7\x05\x1FJ\xA0n\x7FTE\x1B~G\xFD\xBB\xE8u\x18\xA6\x88O(\x81\xA2qk8\xB0\xC6\xB1\xFF\xBENB.\xE3\xCB\x81\x8C\xCF\x87\x99\x9E;\x0F\x18\xE3\xCF\xE0\n\x01*}\x16\xC7\xAE(\xA5\xD8\xEA\xDF\xAC?V0\x8B\xA50js\x80\xBB\xEB\x0Fk\xDA\x19\xBBn\xDE\"n\"|\xD9&B\x8B\x97\t\x84B%^\xF0\xA0\xA2v\xCF\x9B7\xDFz\t\xD3\xFE\xFC!N\xE2[\x05\x9D\x9B^\x11\xB5\xB9\xB7U3\xD14\xABP\xFF\x03\xEE.\nO\xCD\xB7\x01\xE2\xD6\xC9N\x12\x87\x8Br\x1E\x9B\x8A\xA6\xA6\x9Dt\xB0\xCAR\xBB>\x90\x11\x9CG\xA9\xCF\x05\x94mh\xC4\x87D\xE5\xD0:<\xF7\x9D7\xF9=|\xBB~\xFE\xDC\xC5\xCA\xDF\x8B\xC7\x9F\xC6\xE1/\x92(\xBD\xC2\b\xF5R\x04\xB4\x16\xFA\xE2k\xAD\x0E\xBD\xA6e\xD1\xDA\xE9\xCC\xE6B\x81c~\xB1\x17\x88:@\x07T&47\xB7}*\xC7Z\xD7dn2]/\xDCQ\xBAN}\x8Ddr\x8B9\x7F\xE9\x9A\xE2\x9B\xB2\xB1\xA3vrs\xD0\xF1M\xDE,*\xFE\xE6\x92\x1F$\xE1\xC5\xDF\x82\x05\xD7F\xADSl \xAD\xA85\x8AR\x07\xF8\xDF\xBC\xD6}\xE9\xBF\xF8p\xD685\xF7\x03%\x19\xE6\xE2\xBD\xEB\x80UY\xE3\xA4\xA2\xDF\x927/c\xFA#\x92~\xA5\x13\xCF\x93y\x18\"\x80\xAA\xB9^O\x8E\xCA\x92gM\x04\xEE\xCB\xDBU\xD8-L_r\x16\x88\xC6\xBC=ZF\x9BEi\xD6xR\xE4\xA5l8m^F\xF4\xF3r\x85T\xD7P;\v\xCD3iB\xCB`\xA0\x87\x0F\xA5\xD7<\x93l\xD4eB\x1D78H\xA0\x06r\x8D\b\xDC\xF7j\x1E\b,;I(\x05\x7F*\xF4\xABdH\x87,\xD3-\xD54\x91\xE5W\xE8\xDD$mk\xE1\x99j9\xC3\x02S\xA6\x10\xCD\x91\xA1\x1D\x88q+\x95\xB8)\xDE\xEB\x12!\x92p\x13\xF3\xE7\xCCV\x8B~\xB5\b\f\x8C\xA0i\xE2\xFA\xB7Z\x1BM-\x8C\xD5I\xA4D\xA2\x9Cy\xF8\xDD\xD3s;)w\xD0\x95\xC0\xDC\xD8\xC4T\x18Mg\xF6\xCC\xA2\xD14~\xDF\xCA\x87\x9A\x1B\x9B\x9895\xC7Dr\x9F^'s\xB7\xF4\xA3'\xE1\xEFM\x86\xF86\xD1\x8D\x8DQU\xB3L\x99{\n\xB8:\xEF\xF8&\x1C\b\xAFO\x89\xBF\x11\x98u\xCFA\xDA\xE9<\xF47~\x8A}\xAD'\xA7N\xB1~\xA0\xF3\xC4(\x8A\xB9z\x98g*o\xDF\x97\xFE\x8B\xC6I\xE3\xEC\xCC7\xD4)#Um'\x80\xA6\x8C\xF1\"\xA9\x83sL_\xDC\xB9\x92\xF9\xEBgE\xBEE\x93\xE4?\x93F\x89\x1F<\xB3\x93\xDAO\xCCF\x99\x7F`\xBA\xC7\x99\x88Q\xF1mD\xDA\xA6\x8F\xF7\xD4A\x9B\xE5\x86\xD3g\x8E\x8A-1\xD9\xFB\xD5p\x93\xC9\xE9\x17\xC8!\x1D\x89\xD4\xCE\xA2^O\xAE@\x1D\xB4\xB6\x1E\xFE\x8E\x86\xF4\xB6\xC8`Z\xAE_\xE3-\x99&Y>=\x8A\xA6\x89\x1C\xB7\xA8\xCC8\x01_\xC8\xA4\xAD2&\xA0\xAF\xF8\xC9A\xAC\x95\xDF\xA4\x06\xB4\xB6l\x99\xD0\xFFN\x1Eg\xC0\xC9cT:^v_\x10k`\xF0o|\x9F%\xE5\xAE,\x81g\xAE2\x81\xCC\xDA\xA4\xE1\x12?\xA0\xCC\x90\xFCw\x95\n\xE6\x9Cb\x8B\x96\x85\xE5}\x17\xD5\xE1\x05\xB6\xE8\xFA *\x13\x18L\xEFSz\xC9\xF7\x9A&R@$\xAA\xC7(\x05\xB9\x16\xC6\xDB\xCF\xCE\xB2\xD2qS\xD0\xCF\x9F>A\r*\xF3\x14\xB8\x89\x0F\xAC\x9C\x12\xFC7\xCB\x02\x03i\x9B\xFFzX`\xEFo\x11ikK\xB7\xD6s\xFE\x8B$\xB5Y\x99V\xD70}\xAC\x15\x04\x16\xAF'1r\xB4m*\x8C\xC8\xC8\xCC,Ve\xB5\x8F\xB5\x02z\xFF\xC8\xC1gB\xE9o)\r#,\x01~\xBCz?\"\xE9#&W\x94\x06hiHe\xD55)\x9D+\x80V\xA1\x02\xDC\n\x10\xA9\xFA\xB5\xA9\x10\x99\xF5[\x07\xA3\xC0\xF6%gHk\xFE\x9E\xE2?\xF7\xA4\xD5\xB1+\x89\xCE\xFDY\xA0s\x1F\xB9h\x04\xFF\x1D\x91\xFCg\xE5\x9Ewp\x86\xFB\x8A\xD5\xFC\xA6\x93\xB9\xBF\x9CG\xE5\xF3\xFA\xD0\xF4>u\xCA?\x98\xA1\xDB\x80\xA6\xA8\x91'\xFE\xAB\x85\xFE\xBE\x1B\xC2L\xC4\x7F\xB4<\x9A&\x12D\xBF\x10\xF1\xDF\xDC@X\xF0_x[!\xFF\xC5\x98\x7F\xE0\x11\xBE~\xC7{6\x99$\xFF\xB4\xB0\xAC\xA8?\xFD\xCD\x1F\xCF\x8D\xD2\xF2\v\xE4\x90\x1B}\xCE\x9CE\xE3P2\x8C\x8DL\xBB\x81\x9F\x92{\xC7\xFF\xC0\xBB\x99\x9C\\\xBF\\\x9B\xA3\xC2\xE5\xC0\xCC,\x9A&\xA66\x02\xA5\xE9<\xEA\x92\xAAB\x9Fs\x8Eb\x10#/\xD2V\x01\xE3Zir\x7FkY7\x99\x1E'O$\x81\x1F\xAF\xBD\x92\xCC\xAF7L\xACa\x9C\xB9\xCA\xE2\xAA\xCCyQN\xF0\xDF\xF3\xC7\x93F\x9B,e_\xB4\xAA\x98\xFF~\x84E\xCB\xC2/0\x07\xFF\xFD\xEBUh<f\xE4\x97?\xAEL\x8F\x99\x9A\xE7^\x02\"\x19\x9D\xD1KnB\xE0\x95\xB6\x95L\xAF\xA5\xAE\xB8\xED\xF0\xF6\x93{Q\xF1\x9F\\\xBFF\xFE\x1E\xE6\x1Fp\x04\xD7zX`\xE8\x10_\xBF\xC3k\xA9\xF0\xE2\xD2\xA46+~\xAE\xF8\xE8\x83'Z#Q\x02\x91Hb\xE4Hd&\x86\xC8G\xF7\xE6\xF9\x965\xCE\xC7\x8A\x8F\x8C\f\x0F\x8CR\xD9\xBF\x8C\b\x96\xAF\xA3(j\x12\xE14\x1F\xCC?\xCD\bnZz\xA2\xDCA\xAB\xB0U\xAB\xB3\x12\x04d\xB8\xB5\xFA\xD0T\x88B\x92\xB1\xBD\x00>\xB1D@\x85\x1FiAuV\xFB\x94@\x85\x92\xFCg\xA2\x87\xF8/!,p>i\xCF\xB9\xEE\"\xF9w\vs\xD7\x7F\xAE\xDB\xE2\xBF\x9B\x98\xBB\xB5\x83\xAF\xDF\xF8\xEC!u\xCA\x11\xEF\xBD12\xB5Do\xA6Z\xB8\xAF>u\x9E\x05\xC46{\x0F\x02o\x9Cp\xF0\x9FZ\xBF\bmc\x81\x81\xE99\xE6\xE0\xBF\xA3\xE7\xF8\xFA\x1D\xFE\xB7z\xD3\xC8\xE3\x92\xA4\x16\x16u\t5?y\x87\xF5\xF0\xC7\xEF\xE1\xF4K\x1D\x1D7g\x11\xB9.\x97B\x1DC\x19\xF1\xDFp\xFA\xF0;\xFDi\xC5\x7F\xE3\x00\xF5/\xE3\xF2\xAF\xFC\xBEW\x92\x80\xFF\xD64\xFCY\x8B~\xDC:\x9BO?\x19\xF5\xAD\xFC\xEB\xD6F\xA2\xDF\xD6\x87L\xE0\xDA\x810\x81\xB1\x1C\xA9CeRk\x17\xF9\x02\x95\xAA'Wt0\t\xB4Vg\xB56\xB9~\xDD\xF5r\xAB\xB5\xFCzm\xCC\xF37O\xCA\x84gW\x12\xDB\x98\xFB\xCB?GU\x97\xB6~\xB9\x05att\xC9\xA1\x9B\x81eI\xCD\x8F%IN\xBF\x12\x94\x0F2\x91}\xA7\x07q\xF5\n\xC2*\xB6\xE4\x9F)\x14\xC3g\xEEa\xA8\xD0\xBD\xCE\xF5\x9B*A\xE3\xC8\xAE\xF1\x8AQ\x13q\x84l\xFEk\xD9\xFB\xE3\xD6U\xC4\x7F\xB4~\x1B\x96\xF5c\xFDp\"\x85\xF5I|\x88\xF8oz\xEC\xCC\xDE\x17\xF3*\xE2>,\x93\xC6\xF4\xA3\xE3\xD0\xF4P\x17\xE0O\xA7)\xB9@a\x15?\x0Fi\xE0Co\x83lv\xA8\xCB\x10e\xD8\xBF6\x84U\x19\xAE\xBFf\x80\x03\xA1\xBAvn~E*\xB0\xBCKo\x97M;DO8\x13\xF1\xE1(\xB0\xD3d\xD4\xF6\x96:\xF8\xF5\xCBWT\xAB\xF8\xE2~\xF8\x9E\n\xA7\xAD\x8A\xAAA\xE6\xEB\xE772~\x9E\xFF\x8E\xE2\xBF\xDF?\xFD\xEAm\xE0\xCA\xC4[\xD8H\xEB\xD7\x93\xC3{\xCCx5/\xD2\x7FJ\xFE&\x87\x9D\x9C\xFF\b\xA9p\xEE`\x96\xE8g\x94\x19\xC0\x7F\xCB/u\xAE\xDF\x1C\xB7\xD9\xE3ko\xD5M\xE37\xA4\xAF\t\xFD\xAF\xE6'\x93\xEBz\x1AMR?\x18\xDC\xF7es9xV\xBE\x9B'\xEB\xF8\x87\\3Z\xCC<\x93\x11\x8DY\xD9@b'^\x94[\x8F\xA6\x89\xE9\xCB\x81\xC0\xAAS\x04\xDC\xF5\x8F2#\xC7k\xC3A\xDF`\xD1O\xB6]^9~\xAA\x11Wt\x01\x07\x0F\x03x`\xE59\xAE\xA2\xFB\xEF\xCEc\x85\xA9\xE7E\x13\x81\x15\xA6\xA4\xDF\xFD\x87M`\xECp\x96\xDA&\x91\x99{\x8B\xB4\xBBW\xAB\xCD\xF5\x00\xF3\x85\xC2\x12\xF4\x86\x1A\xCB\xFB.\xFD\xF1E\x03\xEC\xE2\xF1\xC7<\xBC\x9A3\x12\x1C,\x86\xA1R\xE9\xC2A2~\\\x00sx\xA9]N;\xD4v_K\xE3G\xFD\x1A\xB5\xC2\xAFQ\xE7\x15r<{d\xFBd\xC7\x84hTn\xF1F-\v\\D\x81\xBD\xE2F^\\\xB0\x86@\x0EZ+\xD1\xAC\x168\x8FKV\xDD\xF9_:'(L\x7F\x1D\b\x9A\xF3\xAEc\x8E\xE2\xE8\x12\x12U\xF7\xFEA\xFA\xA9\xBD[=\xA5'\xF7\xFF\x95~\x9E\xD9\v\xD3\xAF's\x01\xFA\xFD\x1E\x81\x7F;\xFF{=\x90\x13\x14\x8B\xC1\xB5yv\xAB\x008uE\xF9\x9D\xB8\x86\xEC\x8A\x02\xA5gR\x17\xA6_\xD8\xA2\xDFt\xE9\x19S)6\x9Ew\xF3\x80\x9E\xC5\x1C\xF5]\xD6ez\x11\xA7X3\x9DS\x11\x83\xBE\xECe\xE80\x9E\xBF\xEEx\x176\x8A6)\xB2Z\x8C\t\xBD\xB3\x81\xC1x\xFA\x1C\xDF\x1Cn\xAC\xB1\xDBffm\v\xD2\x8A\x0EK\xD5>O\xC6c\x0Fs\xBD\x92w\xAAy\x16v\x96\xA3@W\x19\x8F\xF2\xD7E\xDB\xAC\xBF\xE5\x9CW\xD4\xBC\x9E\xC3\x8D\x8E\x91\x85}Ia\x9D\xE7\xB1\x0F\xBE\xF6m\xFB\\|\xBA\xFC\xA1\xB72\xCF\x97]1\xF1\xF8\xEE\x1Cz`\xC5\xE9\x1A]\x17\xA2\x9F''\x1E\xF5:\xBE)\xED\x1E])|\xF5|2|\t\xB9\x82R\x01\x12\xC8\xE6\x142\rP\xEB##\xDF\xC0\x02\xD3\x1D\xA8\xC9\xE8\x0F\x9F\x7F<I\xA0\xB9A\xEB\x94\x9Cx\xD3u\fz\xDF1\xE6\x8A\xE2\x85c\xCC\xCEu0\x80\xAB\ns\xF0?,3\xDE\xB6=\xFB\xC1\x8F\xA6\xB8\xC6\xFD1G\x0E\x15\xA9\xE2V\xACC\xA1\xC1R\x82^\xD9\xD1\x8E\x7F'\x93\x11\xEE_Ab{\xB9Mq\xF2)\xBA\xE3U_5\xF1\x9F\x19\x18\xE1g\xAEz,!\xFE6.\xCE\xF3\xB5\xA3\x83\xB9\xEB\xEF\xEE8\xF8\np/%=0\xD7\xE6\xD9\x9C\xC8\xA8(o\xC7f\x10\xF0t\xC0\v\xBC\xFF\xAD\v\xE1\x9A\xBAb\x02\xF6\xE4\xF7\x00\xD2\xD3G\x05|\x1A\xA7_ \xF7iR*\xBFBJ\x82\xE0?\xD1#\x97\r\x10\xCA\xEB \xD3\x97\xBC\f=jd\x7F\xFD\x9D.M\xEE\xD3\x82\xFF\\\x12\x1A}\x8E\xC1\xE8\x1D\xE1\xEF\xE8\x1E\x9B\xE1\xAA9\xFFUg\x16Z\xBF\xDA\xE7\xFEv`\xF9Y\xAE1\xBE}\x8F\xFDc's\xA0\x0E\x15\xF2\x9F\xFB\xC6\xBF\xBB]\xB0\x94\xFB.\xFE\xB7\xB3\xC2H\"6\xBB[@\xD3\xBC\x9E\x13\xA6t\xCF\xC1\x95;\xF0\xDFA\x90Gn\x19\x96\r1\xBD\xAE\x7Feb\xE5\xA4\xE0\xBF\x04s\xB5\xBA\x0E2\xE2?\x7F\x9C\xF3\x9F>J\x95\x7F\x88\xB4]h\xF9\xBA\xA2\x02\xC2k;`\x9CMG\x04\xD8\x15\xF1\xDF}C\x94\xA6\x9F\"\x18=\x87O\xDF\xF367\x9B\x8D\x93m\xE0\xFC\xD7\x94\xD5?5\xF8\xA8\xA9\x05%2\x1E\xF1\x9FKvy\xE3\xFC\x97\x7F\x8D\xDFc\xFBZ\x8B\xE1\xD6\x9AF\xE4B\xFC\xD7r\xEA#\xBF\x8D\xE2\xD7\x85\xFCwJ\xE4\x81\x16\xF1\xDF\"\xAE\xA4.\x9A\xE9\xF8\x85P\xD9\x17q\xFE#\x83\xD2\xD3.\xD8\xECEq\xB7\xC7\x12\xD8\xCE\xF9\xEF\x85\xEF\xFE6\x88\xFF)XeQL8\xADz\xE0y{\xF6\xCB\xC1pP\xF0\xDFy\x16\x98\x9A\x9Dd\xC4\x7F\x01\x10\xFF1\xA0\x9C\xBF\xDF\xE7.\xC4\x7F\x9EI\xFC\x0E\xB2\xE5H\xE3\xDC\xD8\x19\xC7\xFA5E4\x8D`\xD1\x04\xA0\x97\b\xDA\xF4r\xB3E\xDF\xB6\x07\xDA\xB2\x97Q\x15\xD5\xA33\x1B\xBA\xB89\xE7\xBBY\xD1\xCF\x93\xC3\x18\x85j\x18\xF4\xC4!.A^\xAC\xB26\x98\xEA\x8C6],\xFF$;j\xF9\x9E\x07W\xE6\xF8\xB2z\xFBS\xF6\x8F\x14\x85\xB7J\bT\xF2e\xC9\x01\x8A\xD1\xFF\x1D\xE58\xCCH\xFEK\x89pa\x9BC\xFE\xDD\x9F\xC3/\xA2\xD0ni\xADY\x99\xB3\xF8o\x87\x98i\x9C\xF9\xDA\xFAw\x1F|}\x12?\xE1\xFC7\xC0\\AsPd\xC7\xF8\x13x\x83\x11\xFF\x95\xE6\x14.\xD3\x82\xE1\xAA \xF6\xF3\x7F\xEFb0^H\r\x1D\x8E+\xFAy\xDE\x9E%\xEA\xF6\x90f\xEEU\x8D\xE1\xB8\xFC#+\x81\xDB\xA6'C\x88$\x8D\xD9\xC1\xA1$\xE7?\x8F\xB5\x7F\xE8APE\xE4\x17\x18\x8C\xD1Cp{\xD1\x92\xB0A\xE7\x93ZH\xD6\x9D\xD8\x9EPY1\x92n\xDF\xFBZ\f\x9D\xCC\xBB\xB9\xABh\xFFP)\xC8\x9AJ\xDApMR\xE2\xF6-\xB70\xCA\x9C\xA7F\xB4\x14\xA9\x0E\x98\xB2\xDF\xBB\x00q\xFFM\n\x9F\xCC@{\xBCs\xDFk1\x81V\xF6\xDFEk+\xAF\x97\x90=r\xE7\x13\xE1 8A\xDB\x13\xCC\xF3\xF6\xEC>\xE1\xCE\xF2\xB7[\xC5\xF9I\x85\xCB\xB4\xD0\xE13\x05\xA3\x9Fb\xD0:\xD2\xE9\xF4\xF3\x8A~\xEE\x1B\xB7\x11v\xC2v\x02Pp\xC0B\xD2\x0F\xD0f\xB7#\xF0\xBDY\xD4d\xB4m=5\x19n\xA7\x10\xD0\x02\xF1\x9F1)\xF8\xEF\x04\x83>t\x8E\v\xC6\x7F\xB0\x11\x95Vf\xF4\x88\xB2%\xD5\xA1z\xC2\xA5\x0F>Z\xFF<\x06\x98\xEF\xB8\xE3wJ\xBCV`\x13\xCA\xE6\x14P!\xDE\xB6\xB6]\xA0\xAE=\xBE\xBB\x14\xBC\x82;'@\xB5f\xE8\xB4\x15\xF1\x04\xDF\x7F\xF5\xBA\xE3\xABw\x1D\x13\xA8\x1B\x87\xA8\r\x9DHg\xD6c\xB1%|\xFDF\x1900\xC9\xF9\xEF]\xD1'\xBD\xBC\x8B\xA4\xF7\x90\xC8\xD3\n\xDE\xD0~!\xC56+\xE2\x97\x1F\x04\xB4\x8FN\x05&\xD6,L?\x07\xAC\x97\xA4\xDF\xB6\xED\xF4\xAD*\xAAm\xDB^E\x9D\x04l\xFA\xE9A\xA1\x89\xA5\x18\xF4\xDER\xB2\x93m\x10\xE3pR\x9FF\xFD\x82A`=\x9F8z\xEE6\x92%\x8ErtrE\xF4\xAAS\x94)H\xED\xE5|\x0F\xDEB9\x0E\x92\xBA\xB4\xBFyL\xD1\x03J \x93\xAD:'\xC0\xA8\xF2\x07\xBF{e\f\xFF.^\x85_\x96k\xFC\x90\x95}%\xFF9\xBE~{\x18\x8C\xCB\r\xAE\xB4\x951\x91\xD5x\x80t\xE7F\xC0X\x07\xD4\xFC\xF0B\xFCg,\x15B\xF5\xE7\f\xC6;+\x8E\xF7\x9DT\xFE\xC4\xC0L\x9E\x14\x919\xDA\x7F\xC5\xFEA66\xFD\x00#?\xC7\xF8\xB7\xA6\xAC\x91\x9F\x1B#?k\xC0\xDA\x7F\x8DI[\xFF\xFBja\xEB\x8B\x8B\xC7\xC5\xE3\x8Fq(\x03\xD0{!\xD4+/W{Le\xE2\x99Eu\xF3\"$\xEB\xB2\xECD+\x92'S\x1D7d\x16\x18\xCF2&\xB9.\xA1/\x94\x97!\xCDH\xB6\x0E\xF3\xD2\x8F\x172x\x13\xF21|NK\xD5\x1A\xD9tf\xCBX\xE9L\v\f\x13,$L\x14\xC1\xFF;\xFAq\x81\x1C?S\x935\xF2M\xF3\xE5H\x1C\xF0\xFC\x8B\x00\"\x99\xD8Y\x9E\x84D\x18q>l\xF8\f\xCA\x93\xA0S*\xD4e\xD2\xAE\x8A\x14UN\x97\xCF\xC4\xADd\x94\x97qu\xB9\x893\xCE\xF2]++\xDB\xF1\xBA\x1CsyZ\xE4\x14\x15'\xB2\x94'\xA8\xDEE\xF5\xB7\xE1OtB4\xCCW\xF9\x84MY\xE3\xA1\t/\xB3QPT\xC5\xE1\xA6l!\xFD\x02S\xB9\xF7\x9C\xF4\xD3\xD7\vL\xFCe\xE7\xA6\xBB\x8B\xD2k\x84\xBF\xBD\"*\x90*\xE2c{L\x98\x8F\xCC\xA7\xEF(\xDF{\xCC\x94\x80`\x1EO\x16` \xCAS\xA6S\xAC4%\xCC%\xE5\xC4W\x15\xC3\xC5\xFC\xA7J\x84\xB9\n\xDF\x8BUo\xE4p\x84\x15\x17f*\xFC!a\xEA;o4$\xB4\xBE\xBA\"\x1E,\xCD\xC9\x8D\xCA\xAA\xDB&\x80\xAA\xA3bdQ\xD4\xA9\x0F'\x7F\x90\xD5;\xEC\x1DQ\xFC\xBB\xDC,L\x9A\xF7{\x832\x93\xC8\x98\xECCM\xD68\x05J:\xDCX\xBE,Q\x94i!\f\xE8\x15Ip\x85\xD4x\xEC\xCC\xC1\xAC6;\xB60\xFFM\xE6\b+{\xE2\b\xD7\x19\xAE\x9EwN\xFB\x1C+?&\xF8\xCF\xEB\x98\xCB\x82\xFC\xF7}\x8B\xFF\x8Cq\xAC\x7F\xDC\xC4Y\x06\xA3\x7F\x1E\xFF\xD1<\xDD\x1Dw\x16\xCEe\x14(\xAF\x93\xD9\xF4\x85\xFC'\xB0\xBC-(\xADW\xAE\x8E\x02y\x91\x0F\xC7\xE7\xBC.j\xE4\xE7\xE2\v\xF0_S1\xFF\xE5\x14R\x80\xEB\xBE<\xEAM\xFD)\xF1.W\xBDA\xDE\x85\xF9\xF4\xD3\xA8p\x0F\xFA\xA9\xE1\x04\x10]\x80\xFF\xE2\x14\xB3\x16\x10\xE0\xF5\x91I'\xAA\xADE\xAB!\xE6O\n\xFES\xEE\x18}\xE0B\xFC'\x15\xA0HR\xEF#\xFE\xFB\xD6B\xFCG\xAD\x99\x10\x98*\x14\xCA\xFA\xB0\xE4\xA6\xA2\x19\xF8'1\"\x07\x95\x7F\x19;\x9A\xA5\x96\x91\xFC\n\xCE\xB1\rY}8\xD9\xB4\x00\xFF\x15$\xCD\xDF\x03\xF8\xF7*\xCC$\xEF\xBD\x84\xE6\"\xB1v\xFC\xA1\xA3\xC3(lv&47\x8F@\x1D\xD7\xE3\x8FVg\x8D\xFC\x02\xF4\xCB\x03\xA5\xD9\x1C)\xB8\x8F\x8D\xF1\xF5[?\x0F\f\"\x9EF\xE91\x81\xFC\xB5\xB8h~\xC5\xFC\xE7W]\xD4\x1B\xB8j\x15I'H\x17\x9D\xC7\x7FBF\xE8\xA1B\xFE\xD3\x9F\x16\xC8:\xAB\x8A\xF8\xCF\x1F\x95\xA87\x16`\xFBc\x8F\x9B\xC0\xD3r\xFD\xC6\xE9m\xBD<r\xC8\xB4\xC5\x97z\xBF\x05I\xDF-\x9C\xD8!\xA9\xC3ss\xAE\xC94N\x8B\x8E\xD0\x8D\r\xB5\xD4\x98\xD5\xD1r\xF9\x1D\xFA\\\x17\x05_y\xC6\x81\xF1J\x13}sl\xA1\xF5\xEB7\xE3\xF4R\xDE\v\xDE\xB0\xE0\xFE1;\xC1\xCAS\x18\x87C\xFE\xA9J\x95b\xFE+\xDF+\x1Fa}Rsa\xC3D\x1D\xDD|\x9E\x13o\xBD\x04u+\xDCX(;5\xA7~\xB5\x8F@N\b\x0F\x04\x95\xF6\xFF\xDE\xF7\xB3\xC0k\x80\x91\x16\xB9\xF6\x9B2\x06\x1BOd4kC5\x1E\x9B\xCF\x7F\xA2\xF8\xE4\xD3_\x90\x8F\xD0KHIO)\xD0\x8C)FM\x9A\x1C\xE6\x83\xB8wF\x9A#\xE9\x95Ymv~\x82\xA7\xFE\x10i\xE6\xC4\x7F\xC35\xA7R\x0E,B\xEB\x94\xFE\xE3\xDC\x18MKs\xA9\x80\xFF\xF4\"b\xFB\x9FJ[\xFC7\x8BH\xFF$\x1E\xA5\x96\xB9\v\xEE\x1F\xB8wv\xDEZ\xE0\xDCT\xBC\x83\xF9c\x92\xFFj\xD4\xDB\xFAV\x1D\x03~ \xFD\\q`uT\x1F\x1D\x19s\xF2\xDF/e\x8A\x82s\xA84\xB7\x94RI\xE93\xBE&\xCF\xE9\xD7/2\xFC|\xCDm\x02M\xA3\x98~\xDE(\x90d\xD0\xBFz|\xD8\xD4\xFBZ\xE7\xD3/M\xF2\x8F\x84\xDBp\xA2\xED\xEC\x02\xF2\x0F\xF1\x11F0\x8E\x00\xFE\x87\xBA\xEC\xB8\xF4\xA6\x16?j\xC5\xA8\xDA\x7F5\x17\x1A\xC6M\x12\x1E\xF3\xFA\xEE\x89\xD6~\x81\xE9\xC2\x85\xAD\x0F\nj\x14K\x90\xD2\xDB$\xFD\x82\xEA\x87\xC3\xE9$\xF0(#\xE9\xED\xBF\x03\xA8g\xFA\xD0\xA1`\xD4\xE6?\xD5\xB5\xC7S\xF4\xA8\xFE\xA3f\xAD\n\x87\xC4Qejm\xB8\x84\xFF\xAFj\xCB\x9D\xF4\xE2\x17\xE4\xBFW\x01\xE3\xD8\xAB\x0Fd1\x1B\x9F\xBF~O\x02e\xEF/!X\xB4\xD7\x0F>\xB7n\xFE\xEE\x07\xE4N#\xB0\x0EoR\xE7mu\xD9\x7F,\xACn\x96\xCF\f)\xC1\xA3\xCD\x12\b\xDB\xBB\f\xC6\xBC0\xAA\xBC\x07+40\xC9k\xB0\xC0\xFA-\x7FI\xCA\r\x8B\xFF\xA66%\t\x9B\x94\f\xDE8\xD0\xD8e\x8C\x8E\x1F\xCC\xD8(\xA0\x86\xE4\xBFu\xD9\xC2\xF5\x1Bx\xA9K\xE6\xE8\x97\xBD\xBF\x04\xCB\xB2\xFAZ\xA5\xFF\x89j\xF2\xD9b\xFD\xEF\xE2q\xF1\xF8\xE3\x1E\vaS\x99\x17jH$\x93Z\xBFhY\x99\xFA\x82\xC6\xAD\x93\xB5\xE7\xDB\x84\xEC\xC26\xB1\xD3\x84u\x1A\xAD\xA6\xD7i\x033\xAE\xEA2\x11\x1C^`\xA8X\x815[8\x00\x81Ti\xB6\x91\x1E\xF8\v\x98\xFC\x14\xCD1|\xC1x.\xF5W9\x80\xE7\x0E+\xFC+0R\x9C\xF4Sx\xAFI\xCC}\xAF`\x18\xF1\xC3\x86\xD3\xD7\b\xBDD\xCA\xD8r&\x9B\xCB\xA8|Q\xA9o8U\x1C\xED\x85bj\xCDS\x80\x8C8\xB7\xC0G\xC9\x908g\xFDu\xC6F\x82\x86wY\\\xEA%o\x99\xDC\x022\x06\xB1\x8Eq\x1D\xA9\xDC,\xB0\x8Ea<\x8F\ro\t\xC4Y\xB9\xD1o\x14Oi6M\x90\xC3\x8F\x80u\xAE.\x17\x0E\xBF8\xE0\xDA\x81\xEB\x9EJ\x8A8\x1D\n\xC6\x93Ss\xA9\x80\x9B\xD8q~\xBBIv\xFF;)\x9F\xA3\x00\x1B\xAD\xCD\xCA\xCEj\xAD.\xD8&\x84\x9B\xBE\xE2\xFA/_.\xB4\x0F!\xA8]9\x15\x7F\x13q\x18Uv\xB8\xC4y\xED@1\xFD\x8Ab\x04\xFC\xB2f\b\xBCa\xAF\x03<T\xCCE(\xB8na=\xA1e`9\xA1\x11k\x8D\xFC\xA3\xA0XN\xC0Ci\x8D\b\xDEo\xC7\x8A8\x1B\xCA\x01^h\xA3\xB6\x8F\xC4\x95\xD5g\xA8\xE2\x86\x0F\xE0\xFA(\xCE\x0F$U\xBF\x13\xE7xrj\xB4M\x84\x194\xD2\x9F\xB1e\xBF\xE4\xBF}2w\xB0\x00FY\xD1/\x85\xD6\xC5\x05oB\x84\x89*\xDA6\x07\x9Dk\xDE\xED\x95\xD1\fUK&\xFF\x1E\xFC\x83\xFCWQ\xEC\xD3\xD2\x82[E\xE9\xAA\xAB\v\xB6\x06\xF5\xE7\x0E\xFE\xD3\xEA\x85\xB5\xB9u\xEF\x99\x04P\x99\xD4\xC2X\x1C\xD5\x9A\x1D\xC0\xB7\xB2\xDA\xD38\x8D%gD\x9F\xAE\x88s.\xEE\xD8\xC3[)<*\xDA\x9F\xB4p\x8D\xC9x\xDB\v\xB8\x06\xF1\xEB\xBDY\xE0\x93PO^85\xEF\x1E\xC9\x7F\xD4\xEC\x16\xB8Iv\xD1\xD0~-\x13\x03}N\x18\xBE\x87\xA5\xED7\x89\x9D\xA1\x02\xFA\t\xC5f\xD9\x1B\xA7\x04\xFD\xCE\xCB\xF3\xCE*\xEE\x12\x88M\n\xF3w\xA5S+\xB8{\x9Ep-^\xBFz\xA8\x9FQ\xABJo\xC2\x8A\x07(\x18V\x01\x15Rz\xA7(\xBD\xDC\x19\xAAK\xF0\xE1\xF5n\x84L\xFD\xF3t\x855\x8A\xE4\xBFP\xDD\x0E\xA7c\x93\xD4\x0Fxo\xCC\xF4\xC3\xD7.#b\xA1V\xAA\xCC\xAEh\x04<;@\xD8\xD8\xB2$\xD0[\xC4\x7Fz#\xF1\x1FWR\x05\xFF\xC5\x0F\x8A\xAA\x7F\xE3\x06\xF9\x94\x05\xF2o\xDC\x96\x7FO\x17<\xA5\xF0o\xAC\xBF\xE1+\xA3v\xE8\x92\x9C!R\v\x12\bk\nn\xAA@\xFE\xDDt\x01\xE5\xCE\xA9xM\x88\x90P\xC0\xABf`\xCDE\xF0\x9Fk\x97\xC4\x15\x1F\x9B\xB8\r\xD8\x984\x86\xD1\x94\xE5\x12\xCE\x01\"K\xC6\x85q\xDA\x92\x7F\xA3NS\xB0|\xA6g\\\xD8~\xFCq\x9B&\xA8\xD3\xFB\x928\xA5F\xCC4\tcO>Q\x91\xFC\xFB.D\xCCK\xCA\xF6\x89\xEFJ\xFE\xFB[1\x94\x13\xBE\xD5\x823\xF6'q\xA4\xAE\x80~#\xB2\xA1\x90\x84\xF7\x95\xF4\xF3\x9F\x85l\xB2\xED\x17\xEF<Q`~]`\xFD\xCE3`t\x96f*\xA5\xE0\xFB\xD6_\xBF\xEF\x90\x7F\x81ia\xE2\xA5S\xFC\xE2\x86\xAC>\x8AHR\x1F/(\x9F\x12S\v!\x12\xC9\xC1\x01|+\xE6R\xFA\xC8\xDF\x8EP\xDF4\xFAo=\x9D\x12\x98\xCE\x03\xEE{0\x986-l\xA4\xD2b\xFE\xCB\xFF\x92O\xA3\xCFr\x12\x9D\xD8'\x1Aqi\x9D\xD2\x8C\xF4{\x17\xA0_\nG\n\x8DL\xD1NoU\xC3\xB4\xA0\x9F\x94z~\xA6\x9A\x1B\xF9cN\xAFF\x01\xED+.`\xDC:\r\xA7\xEF3e\x9C\xA5\x8B\xE6RI\xAFW\xAF\x10r\xE9pdU\x8E\xEA+\x869\xFD\x1E\x17\xEE,\x87\xF9\xC5\x99P\xF4I\x87\xFE\xA4\xF3m\xF9\xA7~\x9B$\xA0-\xB2\xDE\x1B\b<\xDE\x1D\x19\x04<u\x98;\x9A\xB5\"\x85\xFE\"\x0F\x80>\xD4$\xDD\xC2\xF2}\x8C|C\xF2\xDF\xBF\xA3^\x00#8Q<\x1F\xB3\xF8\xAA\x88\xFF\x04\xFD\xEAJ*\x04\xFDz\x04\xD3\xFA\xE3\xF8&\xD47\x8B\x05\x8A\xE8\x17\xFA?\xF3_\xFAQ\xE9\xDC\x8B;:\xF8\x89oW\x90`-\xA9\x10&r\xFA\x88\xE4\xBFa\xACJ\xEA)G\xE3\birk}\xA8\x17\x9B\xA0\xC5\x7F\x19\xB1\xA2\x96\xA5\x99?!\x1Dj\x82E\x17\xDD>\f\xE0Y\xFCe}\xD4\xE2?\x7FQ(A\x7F\xBA\x8B\x8F\xF6\x97\x80\xFE3\xFA\xC3!\xB7D\x88\xA9\x91\xDE\xC6\x80s\xFD\xBE*\xB5\xB9\x13x\xBBPK\x13bn\xC3\x1B\xEF\x16\xC0\x91\x97\xE7\x84\xD5\v\x94\x1Fs\xCA\x9C\xA6\xEC\x1FR\xD8\xD7\x17\xC7\x98\x8DSS\xC2\b.\xCF\xE1\x8D\"\xF9W-\xF6\x8Fw\x85\x89\xFC\xBFO|\xDE$o\xF2(\xD6u\x19?\xB7\xE1d\xF9(_\xE5\xCF;\x8B\xC6\xD59\xE7\\6\x9Ar\xA6\xBFc\xE5'\xE5\xD46\xFE\x9C\xDAqm\x10\xEE\xE81\xFE\xB7w\xE4s\x14\xF5\t6\x9E!\xC6\x1C\x03\x8C\xE3\xC5V\xEF\xC6\xECE\xE3\xEB\xE2\xF1G>\xB4b\x13\x94o\xA1\x8C\xF6\xD1\x9F-l\x18s\x9Dt\xF3\xC2\x91P\xB3 \x86\xEAh\x94\v\xAF\xBA\xD1\xBD\xCF~\x110E\"s1b\xB23\x0E+5I/\xE9/\x9Ac\xC0\xE8\x02\x06\xA0\xE3i\xAC\xE7h\xA7\xF3\xBC\x7F\xE8\xD9\xB3EF\xB5\xB3\xF3\x93\xC0\x05\x03\xF3\xDA\xCF\xB1`\x84\xFC\xEAh\x81\xBF\x9D\x90\xA1\xD6?N\xF9\\O\xCC_\xE2d\x1E\x06f^\xDC^<\x8Cg\x12!\xB8L\xBC\xB7Gf\\\x96\xD4Z\x99]\xCD\\\xC2ac\xDF\f\xB7pY\xB9\xB6\xE4Lmx\x82q\xBB\xB1\x82)\x81\xF2\x01\xA7\xC6\x13\x04\x02B\x87{\x99\xE8\xB7UT\t\x95\x9F\x00\xAA\x9F\xDD\xDC]\xEC\x80p\xE8\x93\xEE\x99\x93R&\x06r\xE8\xBC/\xAB\x14\xD2\xA6\xD7'\xB9*\xFE\xC5\xD9\x9E2\xEB\xDA\x9A\x9F0\t\x9C\xB9hs\x12(a\x0EU\xA1\x1B\x1E\x13'\x9B\x18\xD8m\xF4\x03!5\\Up\xD7\x97\vLU\v0\x87l\x1CQ(\xF6&P]\xB4U\x92y\xE8zd\xFD\x1B\vp\x00\xD1\xCF\xF5\x03\x99\xF1\xB6q\x85e\xC4q\x93\xD6\x0F\x84\xE3\xDC@\x989\xF3\xA5\x17\x96O\xCD\x82\xE8\x17\xB4\x12\x01\xC2\xA6\xD3\xE6$\bC\xD2}\xE6\xC6\xB2\xC0fa)ig\x81\xCA\x96/\xCFS\xC0u\x07Zm\xAA\x91 }\t{f\xCB:\x06\xF9X:uj\xBA\x8E\x99^\xBBI\xBD\x8E\xFB\xA4{{\xCD\xCFM\xE1X\xC8\xAA\xE8\xCD\x00\xAE6\x8D\xEEg\x10\x98\x19\xA5\xBBQ~\xEF\xB3\x05\x1B\x8BT+.\x91%c\x1FWLz\f\xA8j!\xE0\x9A',\xC4c\x9B~\x94\xE85\xF5\xB9\xED\vp\xF24\xA5W\xDF/\xF9\xF9\xCC\xECF5\xD33\x94/\xA5\xAD\xCE\x85\xB9\x85|\xB0v}C$TN\x88E|\xE3\x13e\x9B\x05\xE03\tk\xFD6~\xD2\xC7\x80\t\xB9\x9F\xA7\x80M\xCF]\xF3tA\xD0\xC7\xCA\x1E\x15\xF3\xA3fL\xA4\xFF\xE50\xB77\xAB\xD24j~2\xC9\xEFv_~\xCE\xCEwl\x9A\xC8I\xA5\xA5\xA29%\xD2\t-\xC4\x8E\x87\x11\xC8j\xDE6\x06\x96&\x90\xBC\x06g\xAA\xA8 X\xA5\xD3<\x84~\xBB\xF2\xBFq\x1B1F\xE6\xE1\xAF\n\rY\xFA\x95*\x9B:\xD6\xFF\xB4\x98\xFF\x029T@31\xBBS\xFE\xF2\xE9\xEA\xBFw\xB4\xDF6N\xA2\xA9yW\x1E\b\xDC\xDDw\xC4_;\x93\x9Fd\x86\xEC9\xBE}~n\n?o\x87x\v\x9B/\xCD\x00\xB5%B\xD3:\t\xB87O\x0E[A*y8\x1AP\x95\x1DU\xF9f\xE5)\\\xFA\xCF\x19\x150\xAAhI\x00n\xB0\xDB\"\x9Bl\xB6m\xFE\xA6\xC48\xDF\xB45%b\x9F\xBFWo\xE4\x1D\xACg\xC6\xC97\xE0yw\x9C\x1C`9f\x05,\x1Dq\rR\xC6$\xBF\xBCl\x13\x02\x1B\xA8\xDBu\xC9 \xB0\xBE\xC8\xD5D\x88r\x81w\xDF\xDA\xBE\x80O\x94\xBA\xAA\xAD\xDC#\x19i4l\xB5a\xE1/\xAF\x1F\xBE\xA1\xF80\x9F\xF4\xF0\xC8\xBF\xBEZ\x97[M\xD9\xDB\xA5\x16\xFFU;\x19}\xD0\xF2D\x8C\xF64$\x81\xA6]Y\xB5N\x03\xAF\x06\xF3\xC5\xEB\xB7\xD4\x91\x03\x9E\x1B\x928\xB8F\x0E\x1F9\x16\x95\xEDT\x04\xFFUl\xCD\r\xB7\xEE\xB1\xFD\xBA\xBF}I\x06\x91\x82\xCD\xA6\xC0b\\\xC1,\x9F\x9B?\xA956C7\xD34<\x19\x04\xCD\x05;\xD5\xE5\x05\xC6\x94\xD5&\xC5_\x07D\x8E\xF27X2[\xDCJJ\x9A\x87\xBE\x8E\x13\xF3c'\fw\xA2\xC4\xC4\xF0\x07\xA5\xFC\v\x7Fz\x80\xD9\xBEC}\x10\xF5an\xFB\xF9\x9B\xD3\xC3\xED\xF7\xD7!\xCD\xB8\xA0\xB0\xFD\\\xA6S\xFE\xE5\x95]&g\xD51\x90T7\xAF<\xF4v\x1B>l.\x90\xAC\xE0\b\xD1\xE5\x84!q\xCB?g\xAD0*\xDFr\xAA\xA2\xF7\x85F/\xB5{zGU\x8F\x87\xA5\x9F\xE9\"_\xB0\xB5~\xB5\x87\xE1\x8Fj\xDEf\x94=\x9F\xA7\xA5At\xF8l\x01\xFFIX\xDC\xBA\xC2x-\xFC\xC7\xA0,\xC8\x18\x10)\x0E?\xF2\x1F|\xD3\xFF\xF1\xB1b\xF2\xB9\x12H\xB3E&\x9E\xF8\xBA,\x01\x1F~\xE2\xB8\"\xCEK\x94G\xB1\xAA\xBC\xFF8P\xBAc \xFC\xC5\x7F\x98\xC9\xA7\xD9\xA2:\xA1\x88\x14E\xCE\xF8\xB5a\xE5\x17\xD0\x7FE\xFB\xC7\xBF\x8Ae\xE07\x81\xAB\xBE\xB5\xA4\x1B\x85\xAEI\xBB@R\xBA\x04h\x92\xFE\x1C\xDE\xDB\x17Ul\xD14\xC1\xA5\xED+\xC9D\xE9q\xBB\xA7\xEDO\xDE\x96\xC6\xDA\x07\xFF\xD5\v\\\x9A\x04>\xA7H\xFB\x02.\x8Bj\x0F\xFD\x9Ayv\xC6\t\xFF\x8F\xA4\xC9\v\x05\xF2\xCF\ti\xEF\xE8\x8D\xE0\xCFr\xFE{^\xC6:W\xB3y\x99&\x80\xAF\xCD\xA6\x8D\x15&\x88#\xC4\\&\x86\xF7\xC9\x8C\xFD[\xEB\x1ET\xE7\xDC\xC6\xA0\x9F\xC2\x95\xB4\xA0\xFD\xD1o\xAC\xFC\xE5\xA3\xB5\xE1\xC7\te\xAE:\v\xE90u\x82\x0Fj\xDBTC:=\xDD\xCA\x7F\xE8\xD8/<\x1D\xED@\xF5\xA1\xB7Oaq\xE1[\xAD\xB7i\xEF\x1A\x18R\xDD\t\xDBq\xCB\xFE\xA8~F\xEA\x06\xA9\x14\x10\x1EJ\f\x04\xEDFx~\xD6+\x1F\xFA\x92\xE65\xA2\xF3\xDD\x13\xF6\xFA\xADK\x1A\x91[\xA1\x9F\x1E$\xF6Na\xDE\xFA]\xAA\xF2(\xC4;W\x18\xCE\x81\xA5\\\xFE\xA5.\xE0\xAA\v\xF0\xED-\xF0\xD9\x17>5OqeX\xC6\xDC9\xAC\x94\xF2E[_\xB7?\xEB\xF0]\x0F\xC0\xF7ZnTh\xCC\x95gB\xB7\xD62W\x97X\xBF\x07h\xCE+\x9C\xEB\xB7\xCC\xC2\xE2\xFF\xE5\x81GM\xE03b\xD34\xE2@\xF03\xEF\xEB\x9E\x17S\xB6\xAF\xF5\xC5Ge5\x82\x91\xC3v\x06\xC8\x96\xC8\rG\xCF\x02\r\x9F\xDBu\xF9_\xD9\x1A\xD9\xDA.\x15\xBC\t6gD\xA4\xDF\xEA\xFC9\x8ARS\x8B5\xA3\xEC\xC0i\x1A\x9E\xD6\xEF\xB5\x05\x0F\xDCu\xD1\xF6\xBAx\xFC\x89\x1C\xEF\xB3\xC5\x19s`\xBA{}\x10}7\xF0\x87:u\x95\xD4Y{\x1C\v\x9A2\xD2j.\x14\xEB-0F\x99Y\xDC\xB4H\x97\xE70\xB9_\xEA\xB2;\xB08\xB1\xE8b~JaP\xD8\xB6+X\xE1\xF8\xCC\x11\x05\x16\xA1`9(3U$L\xFC\x1A\xA7?y5Yr\x1C\x84\xEE\x1CX\r\xA7\x9B\b\xA9\xCC\xE2\xA0\xA0\xDC\xDA\xA80\xF1\xBAQ\xC2\xA4|\xAD\xE6&\xF8\xD5\x81W\xDA\xB1\x96\xDF\xB2i^\xD2Z\x0E\xF0\xBCz\x96\n.I\"u\xAF-K\xB2\xE7W2\xC3<)\x9A'R\x0FFW<\xD7\xFD\x11u\xAD\xA3%\x14\xCA\xEE;!\xFF\xEB\xC9\xCA\x92\xB8K\xFF\b\xF4\xF3F\t\x14\xF4\xDEr,\xCE\x18\xBF\x84\xB7\xCF\x84w1\xFFu\xC9\x99\xCDA\xE8.S\xAA\xC4K2ZD\x86V9\xFD\x16K\xBC\xD2\xA0\xA8\xBA\xAA4)Bd\fa\xDDsv\xC0\xC8\x18}\xEE\xD8?\xE6\xF0k\x06#\xFF\"[@h\xAF\x7F\x8Ck\xB9\xAE\x19r\x9C\xA7\x7F\xFD\xCF\x133\xDD\xB3l\xD1L\xB70\xE1\xA9\x97\xC1\x86\x89e\xE9\x05\xE1<?\xF2\xE67\xBB\xD5\x0E&{\xD6M\bO9\x95\xB5\x90\xBE\x915d\x1D\v+J\xD7\xA1\x02\x97\x89\x99\xBC\x95m\xE8L`\xA5k\xF9)s\x8E\xE6\x9B\x01\x1B]\x91\xEAbT\x99\x8C7\xAAy\x81\xC0\xD4\x1D\bFQ\x0Fo_\x0Es\xFB\xF9\xAF\x89\xBE\x9D!\xD4\xFC('c\x13\x15Q-\"\x03\xBD\x81\x1Dxo\x8FGt%~Y\xB4;\xDD\x90\x11[\xCC\x10\xFCC9\xDBhH\xB7.>\x9D\xA0V\"wu\xCE\x8B9\xE6\x00\xEF\x96:\xA2$yz\xFB\xDA\xF74\xD7\x86\xC3\xCCud\x9B\xD8>)\xD2\xEA\x8D\xE7\xFA\xAC\x12WG\xA7iTm\x99\x92%\x0E\xDE\xA8\xF6i\xFA\xB2\x9C\xF8\x84\xF9b\xC0\xF2z\xFEa\xEA\x1D\xF41h\x97-\xC9m\xB6\xAD\x03\xCB\xEB\xDB:\xD4\xDFtgg\x07\xBA\x96\x9F\"\x7F\xA5\x00\xAD\x8C\xCFt\xD0\xC7\xE0!\x1A\xD4GP7\xDC\x10\xD3\xAFI\xA0\xD1\xD4bh\x9C\x88#\xB4\x0E\x88Ul\xE2\xD4u\xFD#\xF1_;A\x82\xA9\xF7\xE1n\xC7\xF6\x0F\x8C\v|\x9Fa;\t?G\xD9^\x1BwK\x9Dr\x92^\xD4\xA6\x06*\xE3\xD6\\\xE7\xE7\x19\xBC\xDCd\xA4\xAC6\xD7\xBB\xE3d\x0F\xCE\xADo\x98y:\xC7\x023C\xE2u\x93Y\xDA4\xB1+?\xBE\x10\x97\xAC\x7F|Y^9\xFB\xA5\xAB\x9D\xE6\xC2\x98\x16\x05|\xF4\x01$\xE8\xE3\xBF\xA0\b\x19_\xDF\xFC\x10\xDE\xF7L4\x11vX\x1D\xF6\xCC\x9E\xE12M\xAF\xFF\xD9\x7F\xB1\\k\xB2\xAAQ4C\xD5f\xC3\xBE\x8C\xF6P\x03Jrq\xB8'\xB9\xD4\xD3\xA3\x0F\xC3oj\xB7\xC0\xD5\v\x84\xFCQ\xC4\xE6v\x9Df\x83p\xF5\xE6dE\x9F?\n\x16\xB1\xF8y.\xDD\x1C\xB4l{\xD9\xAD\x8A\x9Bxq\x94\x9E\x8E;\xF9\xAF\xEAt\x82ZQ\xCD.\xC8\x7F\xFE\xE1\x1D\xD4\xB7\x85\x1E\xFF\xC9\x96\xFD\xFFz\x0Eq\xB8\x8E\\&LP\xC2M\xF6\xF6\xE6z-\xFEsb5V\xBFf\xF1\x1F\x93\xB8\xE2\xC4\x7F\xABQr\x07\xD0\xF4\x9B;(E0\x8F`Vk\xA4\xB9:1G\x03\xB9(\xDC\x9Ew\xAD\xF5[\xD0\xDD{\xDD.Z\xB0;\xCC\xF5\x0E\xF7V@\xF0\v\xA9\xD3\xA9_?\xCD\xB4p\f\xA5\xA98*\xA3\xFA(7[&\xB1*\xAB5\xA3\xB2\x9F\x13'j\xE4C\x91\xC8\xF4o\xD0D\x86X\x80\xC2\x9EV3r_\f\x83i\x05\x14%\x92}\xD73\xA0\x89Z\xAE\xFBCr\xFD\xFE%\x7F[\x9D\xFBB9|\x89\x01\xE6\xF3\xF3\xE8\x97\x02J\x7F\x1B\xA3\x14Sz\xFBC\xB7\x1F7\xEF\xCD\x7F\x89\x95L\r\x01\x9E5r\xFD\x06&\xE2\xA3w\xAA\xA7t\xC6\x9E\xAA\x96\xD7v+\xF3_\xFE@{T\x88D}P\xE6\xD4\xF4A\x87\xF1\x02\xFD\xB0\xCD\xD9Av\xF1,\xAEL\xF5\xB6-vX,\xB6\x8D\xDE\xC7\x1F\xCE\xB7y\xB6\xC5\x91\xDA$\xF8\xCF\xA0V\xA7\xB3\xAD\xCBI\xFE\xE9\t\xA2\x1Fg\x98\x8A\x87Qoj\x9FF\xF5x\x10\xAD\x91(\xFA\x1AW\xBD\x11z\b\xFE\xB6\x9Cl\xD4\x1C1\xF5\x84\f\rr\xF9\x17\xBFND\xE1\xCC\xA7\xC4\xFE\x9B\xA4\xAE\xC9\xDAI\xBC\xFF7RJ\x1E\xE7\xAB\xA2\xEB\xC3\xAF'\xF0S\xBE\xF2\xBA\x8B\xE9\xE7\xC9\x01\x97\x1E\xE6\xFCW\xF6A\xBE\tiO\xFE\xA8fb\xA6-\xCC\x16-\xEB\x16Ay\x826\xBB44u\xF2\xD7j\xFD:3E>\xFC\xDB\xFF%\xC5\xE1e\xCC\x10\xF2\xEFvA?O\xD6\xF2\xD7\xD1\xFE\xA1U\xD0u\xC3\x8E\x19x\xCE\x06Q\xB5u\xE6\xB8U-q\x8Fs\xFFxEt\xF76%wR\x13[\xC9\x7Fo\x91k\xE3\xBF6\x99\x88oG \x97\x90\xF4\xF3\fL\xA2\xDE4\xE2\xA8\x8C\x04\xD1\x13a\x98\rE\"\xB93\b\x9C\xA2\xDE\xBC\x93\x14FU\xFCW\xD2\x85\xC1\xB8\xF4Z\xE5\xC5\x9A\xAE\x14\x01d=\x8E\xD5\x91\x84\x1D\xC2\xCD\xFF\xE82\x7F\x82\xCC\x96TG1\xFD\xB81\xDF\xF0\x1A\xED\xBF\xA7\x1E\xE2S;\xFD\x89\xCA\xD0#w\xFF7\xB8v\x86\xC4\x8B~?\xD5\x9D\xFC\xB8cH\t\xF7\x02\xF8\xEB\xCBV\xEC9\xA3\xC2\xC1\xD2\x96\xA4\x8C\xB9\xCD\x02\xBD/\xCA\xC8'\xD8\xC2Wwh\xB7\xB3P[DQZ\xB0<\\\x11YSTm\"\xC4\x00\xA18\xB9K\xF3\xAD\x0E\xF7\xAA\xE4?J\xBB:\x13\x1B\xCC w\x17+\x89\x05\xE1\x8Ar\xF9\xE7J\f\xF0\x07Z\x03W(\x88X\x9C\xA1c\xAE?\xF4\xB1\x03\xD0\xC9\x15\xC6\xEDA\x8Fi\xA4C\x96\x0F\xE5\xBFx\xA5\xB9nF\x983\xCC=\n\xFF_I\xBBx5\x03\xFAn\xDE\x7F:\x87O0\x18+>\xB5\xA0\xFC[.\xB0\xCF\xC9\x8C\x1C\xBDv\xFF\x9B_\xBF\xF61Vr\xAE\x91\xF0U\x84s\xAA,\x12\x7F\xEA\x1A\xB5~\x9Fr\xCA\xBF3G\xA4|*MJX\xFA\xD5b\xFF(_\x07\x18\xBBs|\x00\xED\xABX\xD3\xA5\xFD\x8C\x14\xB9w\x9D[\xC4\xF4\xDD\xB8\xFA\xF5w\xF3\x8A\xB3\v:k\xAE\xFC,_t\xA5\x1F\xDC&\x01\t\xCB\x96J\x9C,@\xEF\xA6\x14\xA3\xB7\xBEe\x1A%\x9D\xCC\xFFF^\xEE\xBF\x9E\xEF<\x8C\xC6\fmwk\x10\x18\xCB\x1A\x0F{\x9B&\xE2\xBFA\xD3D\x9D\x14\x00\xEB2HK~.=\x81\xAF\xEF|.\xB7`\xB6\xE5\xC5\xE3\xE2\xF1\xFF\xFA\x10H\xBC\x12\x8E\xB7\x00\x06\xD8\x81\xE7[\bZ\x05W\xB9\x02v\xA2\xBF\x15'Kk\x12\x108\xA8>\xA2Np+\x8D\x80%\xA0 \xA3\xA0\xA0\x9B,\ba\x19\xE6ufa:\xA6\x16\xB4\xF0\x86\xE5\xC8\xC5\xC0S.5!m\x1E\xC8\x14Z4\x05DLC\xB9\x84\xF1\xAD\x9B\xC5!q\x17,\xC4c\xCD\x19&\x0F:\x80\x8D\xAD\xBB\xB5\xC8\x0FJ.\xD5\x82v|\xABe1\x05c\xE9W~,V\xDFZd\xBC\x8C\x9F\xCC\xA7[\x14\x11\xA3\xF3\xF8\xB5\xF2C\xDDC\xFE\n\xE0K\xF2\x9B\xACh\x113X,n\xA9hp\x99\xED|tLMM\xC8\x1Eyq\xC1\x9C\xC5\xB5\x8B\xD5\x8D\xC4t\xE1x\"\xC8G\xA5\x01D\xB4\xD9((\xE0\xB1/[\\0\x94\fM\xBB6\x17\xD0\xCF\xB3\x03_b\xE2\xE3\xCB/\x93Mg\x07\xB3\xBF\xF4\x8D\xAC\xF6\xB2<\x85\xA2\xDC\xAF\xCBo_\x92i\xA2\xFC\xE4\xD7w\x14\x86\xBF\xD5y\xFCZ\xF9\xF1\xBA\xBC\x87\xFC5\xAB\xC0\xC6?@\xC3\xF3\xF1h\x06\xDF\xC8B|\xD0-\xD1`\xFB\xA4\x1DSS\x13\xB2G\xA6I:f\xE0Q\x13\xE2\x1Fb\xBA\x16'\x8B{\xD0\xA3\xF2\xA1\xBE\xC4\xF8\xA0E\xFD\xB1\xED\xCB\xBE\xF1\xBAs(1\x039\x17[\x11I\xE0\x88\xFC\x18\x18\x16\x8A\xB1\xB5)\x1F\x890J+K\x8A\xE2,D\xDA\x12\xE2\xDB\x91ER\xB7\x1AF\xA4?9\xAF\xCC\x92\x9F\xF7\xADHT\x1FN\xF3\x01\xD2\xE22\xBF\xF2\x8C\xF1\x93E,U\fO\x95g\xFE$\xD2\xFC\x87#\xE2\xE6\xFEdA)\x83\x9C\xDA0\"Q\xCAZK\xE0\xC8\xAA\xA8>|\x84F\xA6\xBF9f`\xA7\xA9\xA9\xBC4;\xA9\x90\x86\x17\x8F\xCA\xE7wD\xE4\xCD\x05\n\xB2&\xF9)\x94\xC8G\xC3\x8B\x06\"\x92$t\xF3\x81\xE1\xA2\xC8\x99\xC0\xE3a\x12\xB7\xB6\xCF\x16\x17\xDE\n\xEA9\xA9y\x95\xF7H\x0F\x8Ao=k\xBA\xAC,\x11n\nV\x16\xAA7\\\xFD\xF5\xEA0\x9E\xE7\v\xA0\x9Fx\xBF\xC2v\x05\x062\x80h\xD1\x15\x8C\xCA<\x03\x1F_\x19\xF5\x9C`sOw\xA9\x85\xD2`\xC75d%z7\x96d\xF9\x15\x9E\x1C\xF4uYmv\xEE\x07\xAF\xD6an\xC0\xD4\\\xCE:\x14\xCF\xA4LS+\xCD\xCA\x97`\xBF\x89\xF7\xFA\xC8\xD06\xDE\xCEcS\xD6\xC8\x87\x19\xDDI/X\x91\xFCZ\n\x90\xC5(\xED\x83\x12I\xABld_W\xAE #4\x90E\x0F\\\t\xAE\xF8\xE7\xC2\x12\x06]M<P\x93\x91\x00(B\x97jzM\xA2\xC2\xC5d\x07H\xE3e\xAC|ur^\xC2_\x05\x12\x98;\x98\xD5\xBB\xF35Y\xAD{\xEE\xFB\xCF\xE5\xB0\xC9~\xC9|_xKE\xDD\xC4B\xEEa\x9EIl\xDD\x97\x05ZKU\xBB\x1C\x84\xA2\x8E\xB8PH\xA8\xBF\x8D\xC2X\x0E\xE2\xE0n\xA6\xB9\xE2\x87\\)\f\x8Ee\xB5Y\xE7\f\xAC\x9C\xFCFS:%l\xDF\xD7\xE0\xC1\f7e\\\xB5.T$\xF5m[E\x89\x9C1Y\x10\vc\xC0_P1xUKB\xD6\xDB\xCB\xE1\xF9\xCD]\xF7m,\xD8mLT\xF0[\xAEd.\xAA\xCD\xD5;\xECw\xE9\r)\xA3A\xEA\xDEW\x04AVWO\xAF,\xF2\xEC@E\x98\xCD\xE3\xBF\xA6\x89\x1C\xBC`\xC6\v\xADkM\xC3\xDBW\x11\xF3\"\xCA\xAC\xC7\"\xF8p&\xF7EA\xD4\x16\xFE\xEB\x8B\x1F6\x81\xCF\x8Az\r\xAE\xE0;H\xE2\xEE\x98V\xFCg\x88\x17\xDA\x1Eg\xDA\xEC\xE8\x0F&\xCE\"\\\xC1\xF9\xCFQU\xCB\xF9o\x93)\xF9\xAF\x8F\x15\xA4\x10\x9FOD\x81\xDF\xB3\xC0T\x1E:\xF4\xFFxAx\xD5\xE6\xF3\x1F%m\xC7\xAA\xB6\xB4\xCB\x1C\f\xD5\xBA\x96\xDF|\xEATAJK\x1D\b\xAE\xFFF\xB8\x84?h\xC0\x9Ex\x8F\xE0?J\xAE\xA2\x91\x97\x07E\xBCq\xA9M?}\"\xA7\xB2D\xED1\x91@OSV\xEF\x18}\xD8\xD4\xFCc{\xB7\x9E\xC5\x98\x00\x12\x87,\xA1\xFA\xA8J\x0E\x17)<\x7F\xCB\xAD\xA2\xEB\xBE\x96\x04\xE2\xC2\"/\xCD\x15\xE4tx\xEE\xEE\x10\xFC\xB7>I\xDD5\xE2\xA8\x19\xCB\"~\xE0p8\x85\xCE\r\x9C\xFF\x1A\x92\x05\xFCG\xB8\x10\x97\x9A\x10 l6\xFF\r\x8Fe\x81a\xB8?\xD6\xC6\xCD\xEB\xBANFYI\xC6\xD9\x82\xD5\x13\x95\xB0|=c\xAF\xABW\xA1\x96d\n\xD0\v\xDBX\x19u\b\xC1\xE5\xC5?\xC2\xBBsVX\xA9\xD6\xC47\xEB\xC4\x7F\xAE\xA0\x14\x89\x15\xE1\x84h\x0FT\xD7k9.+4s^\xA3K_C\x0E\x9B\xBD\xCC8\xED\xAD0\xB5\xB2\xBE\xCAS1\x01x/\xA5cF%\n\x9B\xA6l+\xBB\x97K\xC7\x96\xCA\f\xF0g\xE5\xA2l\xA1\x1DXc\x87\b]\xCDdD\xDF\x89\n\xA6\t\xF8\xB4\xF683\xF2\xE9\xA7\x9F\x8D\x83\xDF\xA3\xC2Il\xBE\xF6\xE9\xA1W\x9B\x10\xF9\xD97\xDA\xA9!\xBD\xD4\x0F\xD7\xFF\x97y\xF8\x99\xDE\xB2\x05\xD0\xAE\x02<K\x8B\xF9\x8Fp\x05\xA3\xFD}1\xF9**L\x8B\xFF<\xD3\x059\xD2e'\xF0\f\x17\xC8\xDFf^\xF2*\xE8\x1F\xB5'\xDE\xD3\x94\x95\xFC'\xDE\xE0\xE5\x9F^#\xF6\x8F\x7FU\xAC\xF42\x96\xBD\xB5\x14\xC5\xB0w\x1F\xCC2\xF4\xB8\x99\xFE\xD1\xB9\x873\xDA\x9DsO\x7F\xF6%4\xA1\xEC\x80#\x9F\xD2r\x9D\n\x1C\xE7\xA7Y \x87\x96j\x13\xF8\xE1wlD*\x87\x90\xFEJ^\xB4j\xFBP\x96\x9A\xC8'p\xF0X\x97\xE6\x9D;\xBC\xF2\x00\xE6\xBE\x935^V-y\xD5\x8E\x18\xEE\x92\xEB\x97\xF2\xB3\x0FZ?\xFDv\x8C\xC2\xBC\xEE\xAF\xB7am\x97\x91\xBF\x99A;=/}3*\v\f\xF6\x1D\xFF\xC2\x0E`S\x97#\xC7\xCB\x04\xFC\xE9\xEE\x8BF\xD7\xC5\xE3O\xE3(\x86\x1F\x96\xC6^TY\x86Bz\xDFa\x19\x9E\v\x18\x80V\x17\xE0\xE2\xCB\x94\x01m\x83\x13\xBB\n\xAFpi\xFF\x7F\xF6\xDE>>\xAA\xF2\xCE\x1B\xFE\x9Es&\xE4\xCC\x04\xE6\f\x01\x85\xB6\xD6\x1C\x86A\x92\xC1\x12\xA4u\ro\xC9\x10\xB1\x86\xB8+1B\xD7\xB5\xBB\x92u\xDB\xAE\xB7\xED\xED\xDA\x97\xA7\x8Bm?\xC9e\xA4u\fVb\x88-k]\x18C\xA8\x93\t%\xD6\xAAE\xD4$\xEBz[J\xFBQo\x1E\xBB\x8F\xDBgo;F\x94\x10Z\x12\xF1\x85\xC9K'\xCF\xE7\xFA]\xD7u\xCE\x99\x99\xD0\xF6\xBE\xB7\xFB\xD8?8\x7F\x84\x19\xE6\xBC\xFE\xCE\xF7\xFA]\xBF\xEF\xF5{+\xB8\r{\x86|\xE4|?\xB1\xCC_\x94\x15\xAE<\x9Ef3\xA7OR\x0E\xEF\x95.M\xE1S)\xF4M7\x88#ty/\xAC\\\x97\xFF\xF7\xFB6\xC5\fUe\x05A\xF6|\xEB\x153\x14\nk\x91\"\x9E3\x11@A#g8L\x11\xE8\r.\xC3\xCD=b\xC3\xDC\xFC\xDB\x80\r3\x96\xB3\xC6X\xF2\xFA\x98\f\xC6\xF1\x0F\xA2\x1Df\x1A\xA8d|\x067\x19\xF6\x84\xA5\x9C\x8C,J\x86\x19B+\x9B\x10\xAF$?\x84\xFF9\x1BX\xFA\x93m\xFD\xAEI\x07\xB3\xD5F\x05\xE5\x98\x95\x88\xA4\xA6C\xAAq\x9D\xDE \xFD\xBAB~\xBE\xF6dX\xF5\xD5s}\x0E\xFD\x14T\xF3\x1B\x16x\x15!\xF8\x16M\xD1\xBC\xAA\x98\xA1\xE4\xA1\x92\xEC\x9D\xB8C1Ca\x8E\\\xA7\x88\xE7L\x04\x10D#g8\x8C3\xC8\xBDi\xF9\xEB?\xB2Y\xDB<W\x93\xFC\xD2!\xDA\xEA\x87H\x0E\x11\xAB\x03.\xFDVX\xCA\xAF<\xA6O\xA1\x12@\x82\xAC\x9B\x8FA?\x96R\xBD>\x1A\xB0<\x92A\xCB\x87\x13z\xFFc\x80~Dd\x18\xCD\xDD\xA0\n2\x12\x87\xA8<\x95\xC1\x00%q\x95\xD35\xA8\xAA#\x99\xEB\x14\xB1\xA5\xAAhM3\xBD+;\xC0d\x04\x98\xD3\xB2T?BA]\x11f\xD5!\f\xD3\x8EQ\xF2g\x0F<N*\xC5\xF3\xA2m\xA5\xC9\x1E\x19\xC7I\xE3\xF7\x8C\"\x9E\x82\x00v\xE5\x12@\xA2\x91tX\xC7\xE3\x92P:t\xB3\"&\x7F\xEDAI\xC2I\xCE\xD2S\xF4\x7F)GV\x0EAM\xE2RW~%u@9{nD\xAD\xF3\xEB\x9D\xA8\x00\xF0c\x16\xA0\xC0O}\xCF\x8F\x18p\x89\xA0U\xCB\x1E.\xC7\x96+\x9A\xF4\xE3\xDD\x94\xC6X\x1E\x88\x03E\xFF\xD0\xD8\xEFRn\x94GmI\xC3E~Y\xE0\x10T\xB0e\x83\x88\x1C\xA5\xD2/\xF7\xC3\x9AH\xA5\x98\x8C\xE0t+\xC6\x88\x92\xB5\xFF\x9D\xE9\xAFb\x03,;N\xB9\n\xAA\xE9\x8E\x8A\xDF%\xD3\xD9w\xE5;g\xAAE=(q\xE8>\xCE\x16\xE9M\xF3?\xA2\xD0\xA57^TX7\xA1\xAB\xC7\xEB?\xCD\xDCP`\xCA7M\x1BY2a\xBF\xCC\xF4\x06\xB7:Q\x96\xE8\xC4\x16\xC7\xE8\xF8\xAD;~\xFD\xAE)\xC4_\xB9y\x97\xFD\x8C\xE3q\xE9\xA6_#\x8C\x8F\xC1\x80\rN\xEA\x8C)\xE1\x7F\vD\x1A\xB01\x1CC\xB7\x18\xBF%C\x19\xA0\xF4\xAA\x15*\xAD\x8D\xCB\xAF\xE4\xB9\f\xC2\xD0\xC7dh\t\x1C@\x88Ald\b\xDD\x1C\x7F\x89l%\x93\x11t\x9E|F\xDA\xF9q\x16\xA8C9t\xBB\x81\xDE\x93R\xB7\xAA\xE5\x12ud\xB7ZK;\xDF`\xC0w\x94p\x87\x1A\xB1\xC4\x16^\xDA\x06\xA0\xA8!\xB7\x0F\xB4\x11\x11\xE1\xD05\xC7S\xCDg\x98\x93\xC4J\f\xF4\x9E\x98V\xBA\x97Qf\xA2\x95\xC1\x03J0\x1D\x94.?\xFD\x80\xC2\xDA_\xBA.\xF6j\x17\x7F\xD6-@\xCD\xAF\xBF7\xEC\x18\x8B/P1\x8A)f\xB5S\x93\x923g\xE4\x03r\xFE\xDB\x13\xC7t\xDF\xA0\xD1\x9Fa0F\xB0\xD6\x8A\x03\x91\x83?\x93o\x9A\x9A\xA0WY6FX\x90SZ\x11\x8F>\xECDw0\x91\xFAKQ\x02=(~'5\xC1\xAC\xBC~\x9A\xC6i\nK\xA9\xE4?\xCC\x85/\x11&34\xDF\x03M\xF8\xAB\x1A\x9D<\x13\x96\x05\x05\\\xFC\xC9\xE0\x11\xC0\xFC\xA7\xDC\xB2JZ\xBDP_K\x96\x8E\xD7of\xD0=q\x86\xFE\x9A\xB4\xF6\x1A\xC5\xADO\xB0\xA2:\x0F\xFE(\xA0}\xF3a\x85\xB5\xFD\xEA\x80[r\xE6\x8F\x1B\xB8\xD2O\xA8\xF9\xC3F\x9C\xF0\xB7\x94\xF0W\x92\xC6\x9EJ\x06}\xA5\x18\xF6\x81\xEEv\xD8+\x9B\x04\xFER\x12\x7F\x1B\xDAS\x9E\xF9\xC3\x1A\xCA`\r\xAD\x15\x04D\x86fU>\xFEH{\xBDr\x0E\xFC\xC5i\xE7q\x8E\x8F\x16X\xFB\xB2@p\xB7\x93\\\xAA2\xEF\xE9\xEE\xAD\xB6\x8E\xCD\xB2\x99\xBB$Dq,\xB5\xC5RI\x12(~;\x9A7~i\xB5\x02\xEB\x8E'\xF8H6\xBC5z\xDAl\xFDK\x84\xBFz6\xE7e\x07\x7F\xE8\xA0t\xF9\xFF\xE5d}8\x04\xB5\x1B\x17\xB9\xF2\x9B\x15\x07.\xDA9.\x1F\xE1\xA3\xB6\x96\xA5\xFAF_\xC1\xAC\x04'\xB7\xDA\xB1[\x98\n\t\xC2\xC5}\x19\xB4,\xB0\xB5\xE7\xB71h#\xB8\xF8\x92$P3:~ZRFj\xA2|w\x1C\xB7b\xD6\xAB\x8A.Q\xE0\x1D5[\xA6\xFA\xDE\xB3\xE2\xF8,\xA8\f\xB05\xDE\xF5%\xD1\xCB\xC0\xE3\xF3\xE7\x9F\x8A%\xFEL\xE8\xE56\xB8*p\xA8\xB0\xF4\xE0\x13\x92W|s\xD9\xB1\x9BU\x1E\n\xDF\xEE\xCAr\x16H'\xCC\x00\xBE\xD2\xBC\xB2r\xB5\xC2\xB7x\xC1\xC6\x1Fnhd9\xC1\x00[.\xB6\xF1\xE7B\xFF\xA1h\x05&\x14\xDA\x7F\xFE.\xFF\xE7zg\xA1L\xE1\xCF\b\xE7\xCC\xBFq\xCE\xB4\xBB\x0E;\xF3G\x9C\x96Y\x92\xE4|\x8E\xDAzGR\xA55'\xB1\xAC+\x81\xF5\x1FN\xE8\xDB\xC5\xFFE\xA3\\E\xB6v\xEDv\xBD\xD9\x88\xA62H1\x8E=\xB1\x1A*\xE6_\x1Bn\xC4>y\xA0\x1F\x80\x1E\xEE\xEAU\x11\xD8\x0E\xD7\xA5l\xF7:\xDC\x81Y\xED\xD8(\xBA\xA3\x97\xB4\xE3_\xD4\x13\xC9y\x9A\xA8\xEFE\x9F?\xF3\x89\xA7\x18\x8CK\xE0\xAA\xF5\xA5M\xC6,\xFE\x80\xB3\xF8t\x9C\xCA\x95_\xF3\xBDt\x96p4u\xE9\xAFXN\x98\xD0\x97\x97\xA5\xB5\x0E\n$\xBF\x97YG\\\xFD\xF7\x18\xE1o\xCA\xD1\x7F?f3\xDA\x7F+\x00\xF3\xDE\xDD\xB2\xB2y`P\x8E\xDFr\xB2\xCDJ\xD2\xE8\xAF\x947i\\\x82\xC0\x17vc\xD6\xCA&\xFA?\x1A\xBFG\x80\x95_P\xC7\xD2\xF8\x9D\xD3\x15\xC72\xC6\xC7\xEA\xEC\x84R\x0F\xD2\xFE\x93\x83\x98\xF2?\xBA\xD9\xEC\x85\xFD\x7F\xA6\xC6o6g\xFE\x18F\x1F\x9F\x98\xE3,p8\f\x04B\xE7\t\xD8\xF9\xED\x83\xDE\x84K\xA3=\x92\x9B\xEC\xAA\x83!\xA4{8(\xF3,\x10\xF1\x1Fb\x90U\xA5\x98\x87K\x12;v\xE3\x9FE\xE0\xAD^\x10d+z\"E\xE4\x85(\xFAG\xC7L\x85\xB1\xBEYH\xD8g\xA3 \x90W\xAE\x8F{\xBA\rs.n\xE7\x94\xE6\xB29\x85\xCF\x0F\xB9\x9E\xEF\xBD\xA1V\x11,,nS\x97m\x93\xF2hx\xC8\xB36O\x7F71_\bu\xF3\x8E\x8FWo\x00\xEE4\xC97A\xBE\xB1\xDAR\xA6\x85jC\x9F\x1D_K_\xCD\x90W~\xED\xB5\xD0\xD7Omb\xBE\x1Eq\x84,\x88$\xD9\xB1y\xF5.\xD9n\xC8\xDC\xC4|\x7FezZ\x05Rj#\xB9\v\xE7\x1D\xBF\xB3\x1C\xF0\xDD\x8EZ\xE6\xE3\x13\x8E\xBE\r\bm_t1\xE6>?&\xB3j\xE7\xA55o\xCA\xB2(\x97\x14\xF8\xF7jO\xBA\xED\xFC\xEEE\xD5\xB5\xFC\xEB\xF5\xACh\xDC\xB1\n\xB4\xC8\xD6\xFB7\xAD\xB7k\x17\xBC\x99\xC1\xD6]i`\x13|\x9C\xC2\xF3?pca\xAD;\xB8\xFC\xB4\x8B0\xEF\xF9:~\xF1\xAF\xF0{\x89\xA1r\xD7\x9B\x19\xD4\xCEKk\x16\x15\xA2\x10\x8DE\x194\x93zq\xAA$\x1AMxc\x193C\xD8\x99\x88\x97\xB2>X\x13\xD5\x94\x8EI.\x83\xBD]L\x0F\xED\xDDw\xA4CT\xB6\x9A~\xE4\x84\xEBc\xD1_k\x85\xF5/\x916f\xA6\xAA\x85{\xC0N\x8A\xFA\x1Ba\xC0\xFCZ\xF3\xF6\xAEr*'\xA1W3f\xB6V\xEF\x95\xA5}\xC4t\xDE%\xB28\xC3\xE5\x13\"\xB4n/37\xCB\xE4\xCA\xA5'\xEBoF\xB8\"\x04P\xF1\xA3\xB0\xAD\xEF\xF5\xC8O\xD4,\xF3\xD5G<K\xB0\x97\x1C\x99\b\xECe\xD0\x11a\xFE\xFAzwBk\xDB\x97\xFEZ\xF5\xDE\xEE\x9Erl\xEF\x8A\x01\xED\xCC\x9Ch\xC6\xA2\x93\x13\x8E\xB9\xA1o\x06\x02\x81\xAF\xF2O\x1B`o\xCC\x00K\x87\"\xFC^28\x13\xAE(\xC7\xDE.[\xEF\xA0\x1Bg\xE1\x04\xA5bQc\xC2\x06\xECU\x14t\xB9\b\xD3e\xC1\f\xC6\x9E\xD99w\xEDU\xF0\xCD{\x8E\x82n\xC9\n?S\x9D0^9^}\xED\xBE.\x92\x9B\xB9\xCE3\xB8\xF4\xF6i6k\xE3\xD4\x04\xB3&GD}\x8BU\x95\xC2Z\xEF\x02\xAC\x1D\xEDg\x07\x0E&E\xE4\xD8{\xB0\x8C\x11\xB9\xC0+Jtp\xEB&\xD8\x00\xAC\xDBT\x92\xA5n2g\xC4\xF8\xF5\xC5\x81U\xD6\xD7;\xB1\xD6i\x8BPm\xE7\xE0Oxe\xCC\xBD\xC7\xBC\xC5\xD5v.N\x8D\xF1)\xFFj/\xAB4\xBA_\xAF\xDE\xB4\xEB\xB9\xE1\xFE\xBE:\x9C\\g\x03\xA3\xCCZ\xFC\x1C\xD6\x05\x17;k\xCDT\xBB\xE8\xFAN\xAA\xB0\x815/\xD6\x01\xAB#\xE58\x03+\x8E\xCE\x81\xD1a\x9C\xACIk5\x14x<}(&\xEA\xAFu\x00\xD6\xABN}$\xE39\x19\xA6\xEB\v\xC1\x8E\xB7\x96n\xFF6\x8Ct\x87\x9BE\x1C\xDD1\x88\x8E%\x81\xDA\xA7\xC2\x94\xBB\xD4\xE2\xF7VJ:\x13e\x81\xF1H\x94\xE9\xC9~\xA1\x07\x027\xC7\xD5\x1A\x8F~]8\xD2\xD6%\xC6j\xF2\x12\xE8\xDB\xFA+\x9D\xB8\x7F~\xEC\rBV\xE6s\xC3\x9Dd3\xD4\x8B\xF1kl\x03\x02\x1B\xEC\xDD(\x19JJ\xE5R\x92\xD6/\xF7:UHk\x06\xEB\xE2\x9E\x80\xD3\x05C\x99\x8EJ@\xAB\xFD\"\x8A6\xBA%\xED\x1F\xDC\xBA\xE3\xE4\xDF~\xAD\xF2\x81%\x19|*N}\xCF\xF4\x86~\x94\xBC\x91\xE9\xF7\xAE\xFD\xF9/\xFB\xAA\xF0\x97\x99\x1B\x1A\x00\xFF\vS\xB8\x89[7\xEF\x85\x8A\xCA\xB11\xC0\xF4\xC02~\xE3\r|\xFCFE9\xF8\xA2\x06'#U\x13e\xBD\xEA`\xB6cC\xFB\xF6\xC9\xF8\t\xCC\xF9\xAB\xF9T[\x8E\x14^}\x07\xD3B\x1B\xE7\x1Dok\xA6\x11\x1F\x99{\xD2\x13=zm=\xD3\x16\x91\xFE\x8B\nU\x15\xF2\xC5\x9D\xC8\x9B\x9B\xE7o\xE8\xE8\x16\xC6{\xF9F\xE6\xFB\xA92\x88e\x89\xB6\xCF\tw\xF6\xDCH\xCF|Z\xAB\xDC\xC3\xAC/p\xE3\xCC\x06\xE6\x9D\xDCx\tB\xBE\xA4\xD4\x7F!&\xBD#2\xE2\x97\xE4\xEF\xDBB\x8DL\xA4\xAE\x8Bl\xD7.\x8D\xF1\xB1\xB5t\xD0?\xD1\xEC\xEA\xBF\xF6\x8Ek\x1F,\xAD[z\xB2\x1C\x8C\xEB\xE7\xBD\xCCw\x8F\x89\xD2\xC8\xFDN\x04\xA7V\rX\xF5\xF3\x85\xFFv\xDEIN\xF6\xC2\x11|\x87\xF9\xE2\b?rr\x10{w\xA5\x8D'\xE9\x89\xF7>,\xEA\xD2q6\xEB\xBF]U\xA8Sw\x90\x81\xD5\x803\xCF\xEC\x9C\x1B\xBA\x1C\xFA\xBEWP\xD3$\xC7\xEFt?3\x1E\x1D\xA9\xDEt\xCD1\xA2\nu\xCF\x86=\xCB\x02\xED\xD3L\xAF\xEB\x98`\xD6\xD3#\xD4\x8C\\\xE6\\\b\xF7\xE8\xF7\x8E\x9C\xED\xEF\x93\xE5\xC4\xCE\xC0\xBA\xC6\xC9\xC3hp\xC6o;?\xE2\x94p\xE4\x9E\xE4\x1AH\x10\xC8u\x9B\xA8MrFx\xBEQ\x93\xD6.\xF4\x8E_\"+\xC1_\x11a\x93O\xB1\xEE\xA5\xC9A>\xB6\x8E<\x11\xB3\xAEq\xD6\xCD\x8C\xECt\xCD\xC9\xC5\xD9\xE9g+3\xA0\x04\xD8\x11fM\x9EF\xCD\xE8\xE7\xDD!\xCE\xD9\xC4.\xFEh\xC6\x14\xD6\x1E\x8C\x035#\xDF\xC0{\x14\\\x7F\xB8\xB2\ng\xFAc\xF86\xDD\xF8\b?AV\x96\xA2\x1Dt)\xFC\x94$6:\x8D\xDFy]\xFBc\x9C\xE6rfD\xE37\x1CH\xA05\xDCV\xBB\xA2\x83\xBEN\xB7Uz+\x9DE\x995\x99\x8D2\x9D\xF5\v\xBE\x10\b\xC7\xD5\xE4\xA0\xDB\x1D\x91\x1D2\x8B\xA4\xA3\x92\xE9um\xB2\x9A\x93.\xE4w\xAB\xF8\x14\b';\x89\x1EU \xB0A\xAE\x83\xF8k\xEDn\xF8u&S\xCA\x03\xB6\xF1Yo\xA0\x0Ey\x05g\xC7\xBA=\xF3\xEF\x85]\xF1x\x98\x7F\xDD\xC7\xF4\xE1\xFFpv\xED\xAE\bl\x1A/-\x7F\xE0\xB3u\x88\xDCC\xB1\xF1z2\x89@\xB8=\xE5]M\xB62\xDF\x11\xEB\x02\x81\x7F\xCD\x00\x81h7\xFE\x06z9\xBAJ\xDE\x1CF\xE5\x8E\xB4\xFE8\xF1\xAF\x9A\xB6\x98\x18\xBFI\xA0\xA8\x0E\x978\x18\x17\x1A\x8A\x95\x84\xF0hr\xC7\xDC\xEA\x8AA\xBDc7\xD5\xA6\xA2H\xEDToB\xBF\xF7\xF1T\xB4\xB1\x8BJ_UD\xBD\xF8\xEBN1\xBD=\x99b\x81\xD6\xB8X\xEF\x8CF\x9D\xFAW\x81\xE7\xBA\x1EO\x89\x12W\xFA\xB1.\x94\xD4\xFF<\xC9\x9C\xB0\x1E1p\xB8$\xA2\xD1\x11Q\xF0\xAA\x8B\x05\xBE!K\xB7E\xEBSYq*:>jk^cO\x9C\xD3\xD7O\xA5\x0F\xA5!\xF7\x89\xB6\xC6\xAE\x14\x831\x7FI,\x90r\x82\xA0\xF5\x07\xBF\x1F\xAD\xDD\xD5\x98\xFC\xF1onAO4\x01\xCEzG\x0E\xA1r\xE4f\xA7P7\x95\xB5\xA6u`\xBD\v\x97\xA6\xE2\xC0\xB2\xA1\xB58\xC6\x02\x8F\"u\xF0c!\xA4R6\xEEI\tA0Q\xFF/K\xBD\xD9\xD4\x12\xB0\x9C\xC1\xFAX`\x05\xF6-\x1BY\xC1_m\xDB[\x886\xC9Zu\xBD\x07\x9B\xF4G\x1F\xE9\xEDm;@_\x8F$\x7F\xEEz\x8D\x8Dp\x1F\x9B\xBD\xE3\x92>\x16\x98\x88\xA3\x9C\x0F\xABe#\x19\xB5F\x1BX\xDD\xDF\x97\xBAU\xC8oO\x1F\v\xDC\xF8\x98\x8C[/Y(\x16\xBB\x80\x92\xDD\xFC\x88\x95\xA2\x1B\x80,Y6;\x0E\\zkj\xBB8\x15\xBF\x8D\xFC:m\x97\x8A\xC5\x06j\xB4\xA4\xF0\xB7`\xE4\xC1\xC3O2h7\x03\x81\x91=\x8Ep\xDEz\xAA\xF7\xD7\xF7|\xA3\xAFs\xC9B<y@\xC8\xEF\xC3/\xA0|\xC7\x83q\xEFj\xF2\xEC\x07I~\x87Q\x91\xCA\x00\x97\xDA\xC0gX\xC9-\x88&\x97\xDC\x82To\x1A\xA0,\xF1\xD4\x01!\x12\xCE\x87\x8B\xD2P\x99\xE3\xDA\x97\xCE3\xAF\xF3\xDB\x9F\xCA\xC6\xF2\xDC\xB0\xEDn\r]\x13\xA5\x831\xD9\xF6\xD0\xEB<\x8D\xC5\x9Dr\xB1\xA6\xE0\x97\xB4\xCB\\\xF1\x95,\xDFv&\xE3\x86\xF5*\xF8u\xB7\x85/l' V\x9C\xE1\xDA\xDC\xFA/\xB9\x1E\xDD\x98\xD0u\xA6.\xDA\xCD&LEb\x13\x14e\x91Ks\xFF\x7F\xDF\xE6\r\x02\x9B\xDA\x13\xC4a\xBF\xA8L<NUea\t\xCDD\xD8\xB7\xBE\x19\xA1\xFB\x12Y*l\xCC\xFF\xEF&Ns[0w\x83\xC8\x8C5\xB1\xE0M\x9B\xF3K\x92\v\xD7pE\xFF/\xDF\xB9}\x8F\x14\x93o\x036\x86\xBEi\xF3k\xF0?\x9F\xB1\x81\xC5\xA4\xCD\x8A\xEEi\xC6\xBC\xE3\xEFL\x90\xFC6y\xB9\xAE\xD6|c;\xE3$\xD3\xB7^\xC8\xEB\x9A\x8E\x18P\x8B\xA2\x93\xE65\xACh\xFC\xAB\x9B\xE0K\xE2\x9F\x07ado\xFA@\xE5g\xC7\x80\xB6G8\xD6\x16U\x94\xAA\xC0@\x93\xCB\xA5IrI\xCC;9\x11\xC3\xD2S\xD1n\xB5\xE8\xC0i\xAE\x7Fb#\x96\xD4%\x81pL\xAF\xC6\xA2\xBA\xC9,\x96r3\xB4,MD\xF1\xBFm\x06J&\xCF\xC8\x02F\xFA70\xF0\xC8)\xCEz{2\xC0\x92\x8A\f0W4\xBE\x9F0\x11\xEE\xF1\xFF%\x91\xB3{\xDC\xBB\n't\xF3\x81\xA5i\xFDZ\xA0\xF8kb\xAE\xF8g~\xAA\xBD\xCCL5\xFF3\xFC\xD1\xC6\xFB\xE1\xAF\xA3\x9C\xA4\xEE]\x1Fh\x1D\xFF5\x83\x90\xB5vW_{J\xA5\x81Z\xB6S\xD8\xC9Ha\xD1\xB5\xBB\xB2X\xDB71\xA2\xCA=\x1A\x9D@\xB0\xA7\x1A\xAB\xFB\xA8\xA0\xAD\x91B\xCD\xE9\xD4\x06\xAC=h\x03\x97\xC7\xA87\xEA\xABq`\xF6?\xFD\xB9ld\xE4\xDB\x8C_T}\xBB\x1C\xA8\xBA\xAF\x01\xA8\xB9\xAD]\xE1\xCF\xDA\x97E\xCD\xE8\xF8{\x84?O\x86\xF4\xEA\x84\x91\x9Dx\xC6&_\xCF>qW\xA7\x0E\xC7\x80!X\x93\xA9S\xCC\xFA\xFA\xFB\x94g\xFD[\x8E\xBF\xA9\x0Fv\xF5\x8F[\x87\v\xF8\xB0\x9C\xDF\xE5\xDF\xEC\t\x9C\xA8r\f\xCD\xCB\x9F{{3\x16\x8C4>\xAEBc\xB5\x8B\x01_W\x14\xA5]I\xF2\xA5N\xA1t\xFFd\x16\v\xFE\x8E\xE3/\xA6}\x150>?\v(~\xE7}\xB9\xE8T\xFC\rlYpbX\xB8\xC0p\xC1b\x15\xA0\x87\xA2;\xEA\x11\xD8\xAE\xDDH\xF8\xF3\xE4\xD8Yi\xAD~K\xC9 W\x14\xC5c\xEF\xD3\x7F\xFD5\xE7\xA15\xAC\xE8\xBA\xE6FV\xD4\xD3\xD8\xC8\xC9h'\x83\x16\xDD\xF2\x81\xE2\x8F\x8F\x8AM\xFB\xF9\xC3,=~\xE6b\x8F\xFE[0\xA6\x16\xCA.\xD8\xA0\xDF\x88\xF05\xA9\x14\xE0\xA7\x054\xFD3\x80\xFF\xEB\xFD\x88p\xDE]\x9A\xD0\xA2X:\x9CJaI\xC4\x06.\x18\xD4\x1B\x01\xDF\xBF\xFF\x07\xE0\xBF\xAEN6p\xD5\xCB\xB17\x9C\xAA\x03J\xFFG\x9C_\xA8]\xAD\xE6\xF9\xA3\xB7a\xDE\xC9\xF1\xF7H\xDB\xEEe\x9E\x10P\xFD\xB6\xBD\x9D\tNT|s\x05\xD3\xBC\xAB+\xC6y\xA8\xFFK\xD1\xBB\x99\xBF\xF1\x1B{\x99\xFFv\x9C`\xD0\xDF\xDD\xFB\x81\xE2o5\x03&\x06\xF8`Z]Yr\xCCqX\x02\x977(\x8F\xF6\x15\xA3\x93\xDBQs\xFAzN\x00\xA9\xBC\xAA\xC1\xC9O]\n\xEBnK\xCA,\xD3*kr\xB3,Z`\x1B\xEFC\x847X7tH\xD2\x1A\xA8\xC2\x99\x81\xD1\x97\x81\xB5\x079\xF48\x15\x145\xAC\xAC\xC98\xAA\x0F\xF6\\\x87+\xD2\xC0\x90w\xAD\xCA\x88\xBFW#b\x9D'\x05/\x9Bz6A\xD5\x11>\xFD\xCA\b\v\xF6\xA6\xCE0\xEB\x06\xCE4\xF5\xD4\xDB\x1F\xA8\xFC\xE6$\x80\xCA\xB6\x98h\x91\xA4\xA62\xFE\xDE\xA5\xFC\xD0\x8A\xCBj{\x9Aa\xEE\xC8\xD49\xC5\xF2\xBB\x81\xA2\xAF=\x84\v\xAE\xCC\xC8\xE6W\xD6\x9B\xE1,\xCC\xD68\x10`Z#\xA0\xFFl\x04(\xBA>\x8B94\v\x05\xCAqS[\xB8\x81_\x83C\xB4\xAB\t\xB8\x82~\xF0=\xDC\x8C\x927\xC6\xA7\x89`zj|\x98\f\xD9\x1B\xDBlP\xF7X\xE1\x1A\xBC\x9E\xDFd\x05\x8A\x1A\xFA\xAFaz\xE6\xFD\xAD\xAC\xA8\x01\x8FpZ\xBF\xF5\x03\x95_t\x10HU$\x88\xC3\xF6\xAA\xB8]NU\xCB\xC4\xF8\xD5\xBBP\x1A=\xB5\x01\x95#\x0F\xDF\b\xCC\xA1\xE6\x03z\x1A\x98S\xD7\x85\xCB\x8F&\xA8\xB5\xD0C\x88~\x9BmF4*\x92\x9E\xBF\n\x04.;\x02\xCC\xB9%IU\xA5\xC8\xFE;\x96Z6\fDSI\xE0\xF2hR\xADF\x05{#\x88\xB6\xC5;h\xDD\xD6\xE3\x15\xADL\xEB\xA9_,\x1B\xE4,\xB5dD,\xDA\x1D[6\b\xF4\xC1\xBA5\xFE\v\x04\xC2\x0F\x1D\x85u\v\x0E\fB\xAB;\xFA\x81\xEA\xBF\x8F%\x80})[\xB4\xD8S\f\xB2d\x9B\xBB\xD6\xFC\x1D \xF0\xA1KQ\xBE#z+P\xB4[\xF0Z\xA0h\x1B\xB0\xE0\xF3\xE5\xC0\xF2&}\b\x97~\xFF\x8E\x0E,\xEB5\xA9\xD0G\xA3,\n_\xFC\xB3K\xF01\xF5Jn\xEA\x1D\xA9\xE3\xD7\xB8\x05\xB8\xA0\xD7i\vZt\xC7\xD7P\xCE\t\xEF2E7\x95\xBF[Om=`s\xCE\xEE\xEB\x10+\xBD\x7F}\xC0\x06\x1EeEG\xFBof\x81\x89\xA1/\xB3\"\xD1@\xF8\xC6/\x9F\xEFCt~;\xBF\xFD\x1Fo\xC2\x17\\\x90A\v\x87R\x17\xFD\xB1.\x14\x125B\x017!\xCA\x0F \xA2\"\x86\xC9U8WPi=\x1C\x93.\x17\xBF-\xABH#\xD7\xF9+O:\xE50~\xCF\xFDg\x15q?G\x82\xBE\xF9\xC7\x95\xDF\xD5\xCC\x97s!\xA7\xC0\xE1\xD9\xBD\xCF\x8Fa\xD3@\x1Ab\x1D\xDD\x8D_\xF3|\x1A\x18\x9D\xCCRh\x93\xEAHN\x05\x96\\S\xDA\xA9\xD5\xA4\xDB\x888%\xB7el\x9D~;P\xF2\xBA\xF06OQ\xA0R\xA9H\x16\xD4c\xCF\xC8\xFA\xDC\xBA-..z\xFD\xFA\xC9]=\xBAM\x14c>\xCBfEDI\x92\xCA\x9D^\x11\xA7\xCE~S\x9EE\x1Ah\xE4+w\xC3LK\xD2F\xF6\xEC\x1FI\xEF\x1Ac\xB8\x03\xC59\xF9.\x1FU\x1F:;>\xD9\x8E\xFF+\x92\x00:\xB8\x8D\xEE\xD6[\xF2|\xDA_Q\xDFH\x8DsDE%*\xD8\xB4\xDFS\x12\xD1\xAD\xD5\x14\x93\"\x86\x1B\xF1F\xCD\xF16\xC9$:2\xAE\xA4\xEC\xAD\xC9\xE3n\xE9\xAB\x18\x05\xCA\xD1;\xA6\x8A\xCC\xAB\x96\x94\xF3\xEFu\xFC\x92_\x10%q\x8E\xB7\xE7T\xC0\xEC|\xD6I\xE3\xD1l\xB9\xCE4\xC6\x9CB\x1F\xEBl\xBD\xA3\xF1\x8F$?\x1F\xC3\xC3Tv\xD6\xDD\x9C\x95\xE3\xB3\x03\xA72\xE8\xEBN\x00\x9D\xDF\xC4\x7F\x16\x7F\x14x\xA7\x96\xDALw\xC5\xADT$#\xCA\x93\xCAp\x91\xA2\xEB\xD6\xCAu9_\x12-\xB4\x98D\x89X\x94'7\xEF\xF37\x88\xB6\x85\x8D\f\x8F\x8B\x1C\xC0O\xF5yK\r\xB77\n\xFCq\xBEZ\xD3d\x88\x95\xEF\xAD\x8C\x82\xD8h}\xA8\t\xBF\xEC\xFC#\xC9\xCF,\x94\x9F\x93\x80\xDD\x99J\xD5!\xF5$g\x0E\xFF\xE4\xED\x93a;\x05\xF4\xE3\x15\xBA\x16\x8B\xD3J\xA0\r\xCD\x06J\xA1\x85b\xF7x\x82\xD8\x1A\xE2\xF0_\xB5\xBEn\v\x97F\x8B\xA8f\x05U\xF6\x98\x164\xD6\x9C\x10\x9E\xD1:\xCA\x91k\x11A\x85\x81^\x95\x17\x1D<\x840\xA9\xE0\xF9\x8E\x84\xD6\xED\xE7\xB7k\xDC\x82NfE\x04\xFE~\xE3m]\xA9e\xB7\v\xFC\xCDj\x07\x96$\xA4\xB7\xE08\x83\xF1\xE7\xF2\x04\t\xE3\xC9\x96?\x92\xFE\xB32\x18\xCF\xCBWs\x128?_3z\v\xA6{l\xD9\x80\xCAE\x9D\x13\xB7\x9Em\xB9k\xF4\xEB\xC3t\x16\x11s\\6hd\xCF\xF6zRW\xAF\x9B\xC2\xBC\xD1\xAFg)Itf\xFC\xD5\x8AP\xC7\x86\xB3\x02\x7F4\xF6\x8B\xDFn\x06\xC5\xA9\xC2\x17\xC7\xD9\xBD\x83j\xFC\n%\xB8(-\xD2#.cE_\x10\x19\xAF\x1B<\x90\x87\xDE\xDE\"\xB4hQ;\x1F\xAB\x86\xA8O\xF8$s\xDA\xA2.h\xD2\x8Em\xFC\xE3-^/\xCA\x9B\xA8\x02\tG\xFF\xE91,\xE16z?\x7F\x047\xCD\xC8I\x98\x89\xFF\xB4L\x8B\xDDK\xA1G:\xD3C\x1C\x7Fz\x03\x0Ez\x82P\xC7}\xA8\xDE\xB8~3\xE1\xAFP\xFFe\x80j\xE1Z\xD5\xA6j=\xFA\x0Fw\x1D\x93]\x99\xAC\fR\x94.:\xBBI\tq\xD9m\xDC\x82\x0F\xBC\n\x13E|\xFC\xFAB\xF8M\xA7w\xFCf\xC3\xA2\xB1\xBC\xB5\rX\xD6\xA4\x8Bu\xA9\xDF\xB8\xB9\x05\xEB\x12\xFA\x93\x7F\xAC\xFE\xA1>*n\x90#?\xA7\x7F\xCF4\xE9\xBF\xC7\x9A\x80D\xAB\xAA0I\x8F\xAA*Wi\xFF\xD1\x12\xDA\xF4uN\x96\xC70\xC1\x11\x86\xB2\xB4\xF1\xDA\xBB\x1E\xFCY;\xB2(9\xB5\xAD\x7F)\x03\xC3\xFC\xFC\x187_\x1D0/\"\x8C\x0F\x9BN\xDA\xD1!{\x7F\xD7\x8B\"{\xF05 K2\xA5\xF1K\x84\xE8\x02J\xF4(\xB9\x05-(\x8A\b\xFC}\xEA\x07\xDE\x82\xBA\xED[\xC4`/*\xA7\xB1\xEA\xE0O\x931J%M\xC6/\xC3\xF8c\xCA\xAFa\xC6\xF9cci};z\xC26\xD0\xCF\x1F\xE1\xA4\x92\x9A\xAF\xD6\xF1\xC3\xD6\r\xBC\xCE\xF5\x9F\x8F\x0F\xF1@\b\b\xD9z\x83\xAA\x0FG{\x8C\x1F@4f\x8Cd8\xF4\"\xCC\x90\x8F)+\xC8\x9B7\x00\xB6h\x02gdi\xF9\xE8\xAAU\xD2\xFE\xFB\x92\\n3\x1B\x90\"\xEDA\xF3\x07\xC9\xA5\x9CP\xAC\xD7!\f\xDF\x17\x04\xFE\xB6\xE7\xE2oZ\x88\xB3\xE4\x06\xA0\xC2\x96\xF8;\xCE\xA0\xCB\xB6\xBC\v\xA1w\xFC\xB1\xF0G\xD9\xC1VNN\xB1\xD3z\xA1\xA5\xEC\xA5aL'\x9A\x80;[=f\xA76\xF5\xB6S\x13\xD5j\x9Du\xE50\xCD\xBF\xE3\xCC\x18\x03\x964\xE9\xAF\xBD\xBD\xC3\xC5_\xA0-\x85e'\xEB\x0E/\xE1\xF8\xFB\t\x9B-S\x9Deu}3\x06,}C\x16\xA3\"\x97\xEC\xEE\xEF\x888\x85\x0F\xCF\xA6\x19\x82\xA2\xE5R\x8F6\xA9\xF1K\xF8[J\x8D*\x9C\xB6\xC1\xFC\x11\xBE\x9D\x83?\x98\x17\n\xFC%\xF9\xF85D\x14\xF5_0\x8A\x9E\x10\xEB\x1B\xC6\xFB\xEB\xCFS\xA7\xF3\xDB\x9F\x02{\xB5C\xBA&f\xA6\x98\xD7\x1F\x1C\xCB)\xE5l\xBA\x19\x064<^\x9E\x81\x12\n\x7F\xADq\xFCw]\xCC\xE5\xC7v\xE1\xAF:\"\xBAh\\@Wk\x95]\x19t\x1D6E\x1E{#\x9C\xF9>\x9A\xF7,\xDEO>\x8D\xF1\xEF\x9E\x98\xE3\xD8\x8C\xEC5\xE2\xFD\xC1vn\x90\xA9h\xE7\x82\x07\xF4\x9C\xC0\xCF\xFF~\xAC\xD5\x91_0\x86\x18\xE9\x83)\x861\nW\xFC\xD6\x15;\xD3\xC0\x15\x9E>\x9E\xAA\xCA&>\xD4\xA4V\xF7Ui\xE0#X\xCB\xA8\xA9\x88\xB6\x15\xB0n\x17]\xE4\xD4\x1C\xBAP\xD8\x02g$\xA3\xBA\xE35\xAC{Q>\xEF{\xCA\x12<\xF6.\xAC\xB7#g`M\xD6\x8B\x0EQk\x95\xFCZuk\xF1k\xD0a\x1C\x19\xCD\x95\xDF\xEB\xB0\x16g\x85\xB5\xB9\x86\x9F\x8F\xCA\xF5\xD7\x9C\xB6q\xFC\x10\x97_\x15c\xF8;ig\xC7<\xC6\xB1\xE9\xB4\x8D\x8B0\xF7\x07\xAA\xC8\x1C\x9C\xEC\xC7\x9A\xD3\f\x94h\xB2\xDF[\xD6\xC6\x88\xBB\xED\"(#od\xAE\rt\xEFMk\xD9\x96\xB2\x13c\x9C\x87iS$X\x9B\x153`]\xCC\xC8\xA4W\x8B6\xEC\x00V\xABS\x89l>S\xE2o\xBBj\xE0\xAA\xC7\xB1,\xAD\xB7\x89\xCE\x86\xA2\x8D\x9F\xCBI\x02ij!\x8B>Vd\x12\xA5\xED@\xF95\xF2\x11\x9C\x9C\xD6\xEE>\xA67\xDE\xD8\xC7|\xA5Y\x91\xAF\xBBl\xF4)\xB182\xBA\xF7\xC8\xF8\x97P\x93\xD6\xEBz\x1C\xB3\x9B\xEC\xE2\x87\xE1\x0F\xD7\xC9xY~\xBE\xA8\xEA\x13\xD2\xDD\x9B\xD6\xD6\xA2r4\x83\x8B\xA4\xC1\xE1\xE9\x13\x1Cna\xAA\xCD\xE0\tO\xC3A\xD1\xB9\xA34\x85h}F\x14\xDD}\xD6k\xD5\xEAY:=Y>\x14\x11\x95X2\b\xFC\xA05\x86H\xA9\xBE\xDE\xA6\xF8\xC4\xBA\x904ME\b^\xDCv\x9B\x02\x95\xA8\xE9]\x04\xB0~T\xCEVS*.RO\"\x9A\xA0d*\x8E?\xAA\xB4\x1Bp\xF2\xBF\xC8:,\xAEC\x8A\x91\x03\xC5\xFA\xFA\x19D\xA3r\x14=\xA1\xEE\xEF\x97)f\xBD\xDA\xDE\x85\xE23\xB2\x9AU\xF9\xF6\x84Xeim\xBD\xB6\xE2\xCF\xB1\xC46\xB2'=\x8A@o\xE7\xF3\xFE\xE2#b\xB6_}\xAD-\x9BI\x94\x9D\x8Ea\xFApB\xB3\xB1J\xA5\x94\xE7\xE1\xAF\x8E\x05\xE3j\xFC\x06\x1D\xF9Y\xDC\xD6\v.Na\xF5&SP\xA8\xFBK\xBC]I:\xB1zP\x16N\x12\x11\xA6\xCF\xF2\x13\xB42\x94O\xB7\xEE\xCC\xF0{\x92\f<Iv\xEC\xBA\x98\xF1\xE2t\x7F\x02\x10\xEB4N\x93!1\xDEJ\xC6\\\xFC\x91(\x8D\x83X\x9D\xA0\xA08\x8E\xBF\xA0lA\xE4\xF1\xE7q\xFC\x8D0\x8B\xEF\xEC\xDFx\x13\xD6\xF6ID8\x01\xD9\xDD\xBFa\x81\x1F\xDD4\xCD|\xF3R\xC2;\\3*C\xC2\xA7\x07\x86\xC7'P\x9E\xD0\xEB\xBD\xF8C\x82\xE3oB\xE1\xEFV\x15s\x12\x8A\xC6\xD0\x1DM\x18YTlR\x85W\n\xF0\x97Q\xCA\xC8m@\xCA_r\xC5\xC8\x97\xFA\xB1ldX\xE0o\x7F\xD0\xAB\x9D\xBB\x88\x16$\x98\xEA\x06\xBA_K\xCB\x04\xE7\xC6\x9A7m\xA0(\xAD5t\x8AT]\x8A\xAE\x8E\xE1P\xB8$\xADV\xDA\x1C\xFC\x89\x1EA\x1F\x8D\x15\xE2\xAF|P?\xC0\xEF\xAFef\xFCY\x19\f0m7\x95/\xB5Q\xA1\x18\xCB\x80\x1A\xBF\xD9\x14\xB366\xA4\x9851!Z\xF2\x04\xBA\xE3\xE2\xDA]m;\xA3\xE5X\xD9\xE4\xCAO\xF3\x91\xC5\xD8C\xE3\x97bD.-\x91^\x14\x94\x8Dl\xC3\xF7\xA3\t\xCD\x87\xE8\x86\x85\xAAS{\xA0.\x07\x7Fj\xD4\xFE\x8B\xA7\x01.\x97dE \xC5\xC7o\xB9\x1C\xBF\x9E\n>|\xFCr\xADr\x90)\x9D\xB3\x7F\x1D\x80F\x1F0\xF8\xEE\xF6\x8Du\xC0\xC5L\xBF\xB6S\xFC*\xD7\x91^<S\xED0M\x07\x7F\xE3bUN\xF2\x8Do9\xFA/\x89\nQKY\xBBN%4&\xBD\xB7\xC6\xF5}7||D\x04\x96e\xB1\xEC\xA8\x9C]T\xEA\xA5\x9E\xECc\xFE\xC9\xEC\x00+j\xEC\x14\xFA\xAFft\\\xE8\xBF\xE9\xC3\xC3\x13Y\x84m\xE3\xD8I\xC7\x00\x07|&\xDE\x843~\xD7\x9C\x8E\x03T\x91v\xE1\xF2:\x8C\xACi\xD2\xA6\xB0\xFA\xEE1g\x9D\xC6\x13\xFD\xBE\xBD\xC5\x19\xBF-\x9E\x06\xA4|\xFEXe\xF1\xF1\xBB|X\xAC3\xEC\xCF\xE9*\xD4N\xBD\x06i\xB8\xBCO\xE3w\x7F\x1A\xD8\xBAsP\xFBF\xD9\xCE\x9Fd\x80\x95i-\xD3)\xD0\xA9I\xFCE\xDA\xA0\xF4_ W\xFF}8\xE1\xE0O\xC8\xCFHbU\x8C\xEA\x03\x1B\xFFS\xDE\xAE\xE5\xC8\x8Fn\xB7x\f\xA3\xCC\x9F\xA4\xC4\xD1\xED\xA8\n&r\x16\x02`\xA4\x86\xE0\xB3\xB7\x0F\xA1\xE8\xFAw\x85\"[\xD8\x1A\x12\x18\xEDZ\x1A\xB5\xCBia5\x0F\x7F\xDE\xF9\xA3\xBE\x1D\xA2\xB6Y\xE5H\x1C\xA9\x94\xAD\xF9piw\b\x0F\x17\xE0\x0FS\x8B\x9C\xB6\xC1\xEB\xBD\xF3\x07\xC7\xDFH\xB8\x1F\xCB8\xBC8\xD9{6\xE4\xEDL\xD5O\xA3\x82\xA0\xD7\xE5\xE0\xAFc\xBE\xAD\xFB\xC6>\xB1!\x04\\l\xC3\x96\xF2\xD3\x13\xC0\x87c\xDA\xD1\xAF\xEC\xB1\x81\xAF\x88Rsj*\xFA\xA2X!\x90\xD1\t>i\xAB\xD0\xFC\x11\x13u\xE8\xAF\x07\x027\xA8\xFA\f\xE2\xD6\xE2\x02\x7FI\xCA\x1CG\xB0<\x8Bh}:\x0F\x7F\xA7\x93\xAC8\x93M2k\xE2A\x81\xBF\xD5\x8B\xA5\xFE\xDBz\xF8\xE4d\x96\xEB\xBF\xDA\x9E\\\xFCy\xE4W\xD1\xD6$C\xA4\xCB\xA3q<\x96\xB2\xB5)T,\x1D\xA3\x84\x7F\xC8\x1BR\xF8\xABqFm\x8BW~\\\xFF\x05\xF4\xB8\xA8=q\t\x19'\x839\xFA\x8F\xCFj4~\xA9\x06X\x0F\x17\xF1\xDE\xBB\xD3\xA8*\xBB\xFB'\xA2\xBCt\xF6N\xFA\x81\xCD\xDE\r\\\x1A\xD3\xEF\xEB\xEBM\x03\x8F\x90\xFC*\x94*\xE8\xCD]<p\x9A\xEEg\x11p\x1A\nI\xC7\x83\xC3\xC8u\xB9\x8E\xBE\x98\xC2\x9Ca.\xF3\xA1d\x9F$\xB2\x15j\xA7\xE4r6{\xB1o9\xD3Bg\x84\xB5^r@\xE2\xAF#\xDAg\xDB\xB0\x9B\xF4\x9F\xF70\x17\x7F\xBE\x85\xD8\x87\x92\x89,.\xE5\xFF\xB9\xFC\xF3\xBB\xA5\xFE3o]\x81}\xA9&\xCD\x87\x8A\xE3!G\xFFy\x90to\x0E\xFEr\xE7\x8F\xC0D\\D`\xAFm\x02\x0Ex\xD7\xF4\xF5{qi\x13\xF00\xBF\x18\xFD\xE9\xF9\xD8\xF9\xFE\xBF\xE7\xB7?\x15\x12\x1C\x82Q\x98~;4CJ.4\x18\xBB\x05\t\xD4cy$\xD6\xFD\x96\xF0\x10M\x1F\x18|\xBA6\xA3\x036\x96\xB7\x92-\x19\xA8\xEA/\xE4-\x1B\xADNo\xE7\x9C\x80\xA1H\xDDcH^\xD3{\xCB\xC2\xE1\xA9\xAB\xE7\x98\xEFF`\x07\\\xA6\xEF\xB8C}:\x13W\x9Bo\xAA_M\x9F\xE7\xB6<!\xE2\xCC\x94|8\xB8\x1B\xD0\x83_n\x7F\xA7j\xB0@V},\xF8\xB4\x93r\xA7\xEA\x1A\xF8E\x85!\xA3\r\xAB\x99!\xFDy\xA2O\x9C\x87K&$e\xE4\xAC\xD7W\xC5\x8C\xCE\xA1U\xC8\xB1\x05\xC4a\xA2\xD1\x9C\xD1O\x16\xF7\xF4!&\x9Bt\x8E\xAE\x12\xA72^<\x0E\xDF\x95\xAA\xBBJ\xB0\xDC\x91\x9F\xD1\xAE|,c\xE2\xB0\xDF0\x18\xED\x82\x9B\x1ERjw\x9AQ\xC5\xCA\x18\x9D\x94\x01\xAB^|\xA7\xF3,\xB3la\xAB\x8C\xAC\xE1\x93\x03\x11\xED\x9A\xB4!r\xBFF\x0E\xDF'\xFA\x96v\xFE\x8D\xA8E\xC3\xF4\x80\xCF\xAD\xA7\xCD\xFF\xEF]y\xF2\xBB\x8E\x84\x84\xFC87-;\xDA\x91}\xA8<x(_~\xC3\xACd\x84\xE5/\x9E\xF8\xD3\x94\xBB\xA9gQ\x0E]\xF6\xC4\x8Dz\xCC<\xD7\xDC\xD7\xB3@\xC0\xC4t_Z\x7F\x7F\xA0/\x9Dc\x8B\x8A\xC3\x969E.\x02I\xEC\xE7\xB3\xEE\xF7H5\xAB|\x9C\xD4\x00\xB3&D\\V\x8F<)\xBDF~\xF1\x84D\b\x1D\xF6$\x83\x9E\xA5@\xB7\x81Ju!\x914\xC4\xBF\xF6\x91E\x1B\xAD\x0Fd;\x99_\xD5\xBAJ\xDA\xAA0V9\x937\xF4D\xE5HL\xDC_\x17\x83n\xD3\x0Fg\x85WA\xCE\xC41\xD9b\xCF\x1Ao\xFE{F\x02\xE3\xB6\x99\xBEi\xB2\xE3\xED\xA7Y\x01\xFE\x1EA\xB07\x95\x8F\xBFR[\x7FF\x80kM\xDAH\xE4\xE0\xCF5\xF8\x92\xD2&\xE4\xEC\xE4\xFEU\xB6\xD19r\xC83\xD4\x8D\xD6\\\xFCe\x05\xFE\x0E'd\x1F\xFC\xD1\xEA\xE5dV\x18\xF7\x9D\x84\xAF\xF7I\xB1\x88\xA0NO6f\xB7\xC4_q\x06\xA3\xFC0\x8E?\xD1 a\xD8\xE9\xEE=\xE4,\x9A\xBCG\xF6~\xCD\xE8dj\x82\x11]\n\xB4\xE3$\x9D\x80\xDAo;\xF8\x9B~jS\xC6\xC5\xDF\x14\xD62=y\x80\xF9B\"\xCC\x99.\xAE\xBCn\xADf\x8C\x99q\t\x9Au#z\xC7\x9E\xF2\xBEm\xF9\xF2K \x90z\xC5\x01\x8D\xCCo\xBC<F\x9F\xF4~Dm\xFD[\xBF\x13\x7F\x07\x89\x07M\xF7\xA6\xF5\xF7S\xCB\xD3\x85A'\xD1\xA8t\x82\x10\xFE(g*\x17\x7Fm=\xB0\x1AS\xEA^<\xF8{F\xAE\xB5\xF8\xEA\x90<0(\xF0\x17'\xDB\xB6\xBFO\xC9o\xC0\xC1_/\xD1\xDCh\xBD\x9E\xDD'Z\x18[\x19\xF4\x916\xA8\xE4fYyB\xE2/\xD5'\x13\xCF\xFA\xF9\xF9|\x880c\"\x07\x7F\xDA\xD4\xB8tZ\xBC\x93\x8D\t\xFCqcq~\xEALw\xE7\xC1\xE7\nV4GY\xC9\x88\x83?]\xD6\xA2\xB9 m<$\x1E:j\xAB\xFE\xA6b\xCCx\b\x1B}\xD2G\xE8N\xF7/\xB7\xF5\xCE\x1F\xA5\x12^\xFF\xAA\xF43y\xD2\xE62H\x1DH\x00\xD4\xF5\xB6/%\xF3\x11O\x0F0\x7F}\xBF\x94\x86<i\x9Bx\x97\xCB\x15\xFE\xFAz\x12\xC0\x0F\xB8\xAC\x06\xF8\xFF\xECs\xDA\xD9\xF6\x8A\x9BLp\xBE\x10l\x00>vj\x82\xBD+\xF4_ \x8E\x1E2\x16\xE9-,O\xCB\x06T\x03=\xF5\xE2\x86\x8E\xFF\r\xB8\xFC\xD62<\xD8\x0E/\xFE\xC2K\xE4\x13,\x8A\xFC\xA3\xC0\x1F\xF5\xD1>\xBD+\xFB\x1Eg\x8By\xDB~\x04{\x9DA\xAD\xC9Z4\vl\xD1\xA0\xB8\x9F\x8F_9\x7F\xACf*\x18\xC0\xB3\xE0\x02\xE30\xB9\xB6\x06\x9E\xB6\x8D\xCE\xB4\xA7K4\xE4p\xC1\xDA\xFB\xC4\xF8M\xD1\xDC3\xFD\xB4\n1\x1A^sZ\x9C y\x9C\x15\xBF\xC3\xE4:MP\xF4@\x99\x10 \xAC\x12\x0E\x9E\x10\x86\x0F\x8Bi\xC7\xE8~\x9D\xEC\xF8\x1A%\xBF3\x94\xB4\xBBn\x10\x98\xA4\xAA\x7FU\xC1\xDEl\x1F\xFCcb\xA4\xD0\xB0\xC7*1\x89\x18\"\xC6\xFF\xCD\x9A\xDBD\xE2r\xFF/\xA8\x0EUE\xCCx\x97\xFC\xF6N\xFD\xEC\xA9\xF7TT\xC9\x8B\x1E\xFC\x85\xEA\x1FK}'z\xB4\xBCP~%Q\xB7\x00\x94O\xE1O\x94\xEBI\xA1\xC2\xE9\xAF+\x06\x93\xEB\xC4\f8#\xBEx\f\xA9TB\x7F\x7F 5\xC3\xFC\xB1l\xE4U\x07\x7F\xB6\xA8MO/d\xE0\xE05\xE5B\x01\f\xD0r*\xDF~\xC8\xE4\x1AT\\\\\x9CF\x1E\x8A\xC60\xC0\xC7\xEF\x01\xC2\x1F\x95\x0Fr\xF0\xD7\xC7\xD4\xA2S\x8A<\xA3\xCBNM\xA4\xD6\x13\x9A\xF8\xFC\xFB8\xF9\x98\xA3b\x12\x91\xBA\xE9\xC7\xE5R\xF1\xFC:E\xF3GEL\xEFN\x91\xFES1x\xB6\\O,\xE9\xD9\x16\xA3Nk$\xBF\xB2\xA3m\xA9\x07.\xDDW\xC0GzX\x89[\xECX\x93J\xEB\x02\x9B\xEB5\xD2\x7F1]N\x04\"G\xDF]d\x13\xB9\xBE\xFA\x01\xC2\xDF\x13)[\xEF\xEC\x8A\xB2\xC2\xF1[\xDE\x96t\xE6\xDF8\x0E.\xA7\xEAS\\\x0F\xF5\xB4\x89\x02\x1E\x8F&\x99\xAA\x16uP-:eD\x83c\x91\x0E\xEC\x0Fa?\x7Fy\xFB\xF8Ii\xAD\xA0\xBB\xCF\xF6\xCC\xBF]\xA4Z\x0E\xD0ze4\xDA\xD6-\x03h\x02q\xA4zb\xCAS\x1DM\x10\xA8\x81\xEE\x1F\xD4\x8B\x1B:\xDCI\xF2\xAB\xB6\xF5\x89\t\x92\x9Fr\xFF\xD8*\x7F\xFA\xCEKc\xD4\x82\x9C\xB4r\xA8~\xE2\xDF\x1E\xEFi\x9D!X0\x10.\xC0\xDF\xDC&\xA5\xF4/mr\x80D\x87\xBA\xF5\xA0d\xBB\xA1\xC7\x00\xDF\nDSMz\xF7\xC0\x81\x19\xF1\xE7\xEA\xBFa\xFC\xB0'\rpc\x0EO\x1C\xFC\xFC-\xF4\xC3\x8B?\x82\xC2_7\x93k\x00q\xF1f\x84\xCA\xF5\xAF\xC0\xA1\x1F$\xB8\x84\xA0g\xFB\b\xBB\xE5\t\x0F\xFE\xFA\t\x7F?\x12\xF8\x1B\x99xL\xE2/0\x8C>\x1A3\x97\xDAB~B\x0F=\x99\xEA\x157\xD4\xD5Ec_\xB7\xF5\x0E\x8B\xC6\xEF\n\xE5\xEF\x19\x97\xF6\xCB\xE4\xD1\x16\xC7\x17}~;\xBF}P\x1B'\xA7\x92e\xE6\x07\xFBR\x9FW>ju\xD80ow\xFC\xA0\xBA\x1D\xB7\x15\x1B\x89\xC3l\xB5\xE3\xF9\x8Dd\xCD\x18f\f\x0E\t\x9Bz\x82Xq\x9C\xAEV\x01\x9F\x8D%\xD0E\xF0\xB1\xED\xF0\x1C&\x95tA\xF41]\xCD\xFB\x03}5\x99\xEC\x82\xE1~\r\xF3\xBBr~\x88\x87M\x06\x16\xA6~r\xB9\xCEl\xE70\xDAE\x1C\x11\x86\xAE\x8E\xA5\xB3\x00\xCE\xE9\xE9Wu\x04\xCC;C\xC0\x878\xEB]\x956>\xF9\xBF~\xFC\x0F\x19\xB4Xw\xA5q\x99h\xB5S\\q\xF4f.\xBF\x16\xE8\x88\xB9\xEB\xA7\x98\xFB\xFC\"\xF3jU\xCD\xC5Dh\xFB\"sk\xBBZh\x14}e.V!\x87y[\xED\xDC\xE7\x13\x94\xDCk\x92\xBB\xBE\x16%i\\\x05\xDF\x17/\xE6\xF3\xB4\x8DyoP\xCB\xC7/=\xF3;\xE4\xB73\x93#\xBF\x9D\x99\x02\xF9\xD5\xA4\xB9\xC0vf\x1C\xF9\x19Y\x92\xDFt\x9Ci\xD3\xE7\x96\x1F?\xEC\x7FO~5'\xA6\x80\x10g,\xB6\xAD\x7F\xA9\xB3;\x1C\x83\x19\xDA\xD0\x8E\x97@)\xDE\xE6D\xFF^\x06-\xBB\x04\xC5\x99)\x99/DF\xDB\xA6\xC9\xEC{\xB0 \xBD\xE65\xA7\xAF\xCC\x8E=\xA3l\x06\xE1\xA0\x98\x172:g\x92\xDF\xE4\xE1\xCA\f\x99[\xC2\xED>\xCD-\xA8i\x16\xDC\xD5\x0E\xF8\xE6N\xA1\x9A:\x07\x06v\x1DOy:\xF7z\x97\x1D\xB2\xA8y\xF3e\xEF\x0F5C\xB6'\xC0[d\xE0\x05\x98\x91\x9D\x1E\x18Z\x9Cu~\x88O\x0F\xA4\xB5,\x97\xD0\x86\xBC\xF8Nu\xD8dv:\xCE\x9Cn\xC3\x142L\xCD#\x85\x07\xD0p;\xC5\xCA\xC0c\xFA\x81\xF0\xF7Q\x8E\xBFu\x84\xBF\xBF\x1F\x83Y\xD9;\x8C\x8D\xA2[\xA4\xB5\xF8\xC8\xBB\f\xDA\x86R\xCCi\xE8\xC6\\G~\x97T\xE8\r\x0F\xC0OdOoF$:\xD1\xFE\x1D'\xDE\xFBq\xE1\x1DI\xEB\xDD3\xC9\xAF\xABo$\xA9\xCC\xAD@\x03\xBAP2\xC8m\xCC\x89,P\xFC\xB6\x0F\xCBF\xA9s\xE5D\x7F\x8A\x9D\x13\x7F,w\xFCr\x9B?\x0F\x7Fsh\xFC\xDE\xCD\xDC\xF1k\x87M\xA6\xD7^d\xB2\x82:\x05.\xFEB\xD4\v'\xE0\xC1\x9F\x86|\xFC\xE9\xC8\xC1_Yz\x10\b]=&\xF1\xF7\xF0\xA51L\xB7\x82a\x9C\x8A\xC9A\xCF\xF4_\xCD\xA0m\x9Ef\xC5\x99N\xD48\xCF\xF2g?\xF8r\xC3\xBF\xB39\xC2kT\x8F\xCB\x83;\xBA\x8E=i\xBB\x9C\x1D\xD4\x958{n\xFC\xADNp\xFE\x11Lb\x94\x05\xB7q\xFC\xF5\xC6\x15\xFE\xF8{\v\xA4R\xA9s\x86\xD6Yo\fzV\xED\x9C>\xDF\x13\x92\x95r`^\xD1\xA4M-/\x1Bd\xB4\xC4'\xAA\x14\xB6\x94\rj\xF5-e\x83\x90\xA5\xA4\x97\xE4\xBE\x98u'\xC6\xB6\x85\xF5\x986E>\xF0\x16\x18og1_|e\xB6G5\x97\rj\r\xB2\x91\xD1\x1Bc\xDBQZ\x1B\x02\xCA8\xEB-\x1B4.\xEC\x1C81\x06\xB3\xE6\xC4\x1861\xF2\x9CY\xBD#\xEF\x02\xFA+=(j\xD8\xEE\x19\xBF\x91{\x1AojW^\xCBz,\xB9\xB5\xAD\xD3\xEDH\xD5'\x96h\xD2\xFA\x8C\xE3\xB7\xAB\x97\xF07\xC8\xED\xBF\x92\f\xBA\x10\x88q\xBBn\xA2_\xE0\xAF\xE4x\xBB\xB8\xEE9\xF0\xA7M!\x14\xC9\x19\xD8e\xCF\xB7\xD3\xDD\xCFR@\x92\x16\xE8\xFA\xD2M\x99\xF9(m\xA2\xD7\xA8\xADE\bZ\xD64\x99\xB6@Q\x80\x9C\xF3.\x89\xB4o\x9F\x9E\xCD\xB4\b\x1F\xD8\xBE\xF5\xF0u\xE8(\x8Di>\xC7\x83/\xEB\x1A\x94\xC6\xB0BD\xFD\x05Z\xEFo\xC6\x85\xF5M\\\x03o\xA3t\xE5\xC6\xE9\xEFn\x88\xA1E'\x1D\xA6\x97\x13\xFE\xAA\xAFf\xD07o\"}\xE0\xD1\x7F;\xAF?6\xCD\xACmR#\xAD\xDB9yd\xE2Y\xA5P\x84\xBB\xF0\xC2\x98\xFE\xCAL\xF2\x1BH\x89\xEA\xF3r\xC1\x85\x8A\xD1\xF7\xA2\xA4\x91\xE3\xEF\x9E)T\x13\x03\xF7\x8DWK\x9F\xA6\x96\xDF\x8A\xC1Fd\xE9\x98w\xFC\xE9\xC4&\x98\xEC\xA2\x84\x157\x87\x00\x8B\xEB\xBF\xBDG\xE2\xB5\xF8\xB8\x18\xB0\x9A=\xBD7\xAD\xD7N\xD7\xA4\rY\xF5\xC3\x9F\x8F\xBF\xB7\xB3\xD8;\xA8M\xF1Q{\xBC\x05\xB3\xEF\x1FB\x88\xE3\xCF\x87V\xDD\x83\xBF\xD2\x18\x8E\b\xFC\x95n\x9A\xF4a\xFE\x95q\xA0\xE6\xAD\x15R\x03\x87+\xB7a}\xD9O\xC6\xD0\x03k\x85\xC4\x1F\x03\x9A\x9F@\xA0\xDD\xAB\xFF\x96T4\xDE\xDC\xC9D59\xBD\x1EK\x03m\x1D\xAE\xFE\x13O>\xAF\xC188\x93\xFCN\xAE9\xDD\xAE\x1Av\x07\x0Fa\x84\x05\x93x\x9F\x05\xF9K\xF6]\x17A\x80`\\|g:\x8A\x9C\xC5u\xCF\xFC\xA1\xDB!\xAF\xFCj\xD2q\xCA\xE1R\xFA\xEF.!\xCE\x86\xB9!\xFF\xC6\x18JE\xF9\\\xCD\x0E\xCF\x85Vong\xDA\xA2\x19\xE5\xB7\xC4\xD7\xB1\xA1%\x14\xD3\"\xD4\v{=\x8A\x7F\x18F\x15\xD7\x7F\xD6O\xDE\x9E\xF20\xD7\x9A\xB4q\x89\xC0\x9F^4w\x03*?\xE9\x03\xCC\xB6r\xB2%\xE2\xEB\xCB\x8E\x98X\x1F\xDA\x10B\x92\xD1\xF9\xCD\x89\xEAN\x06l/c\xC6x\x04\x8B\x1C\xFB\xEF\xF2\x8F\xED\xAA\xFD\xBF1'\xA6\xF4_\xB4\xAD\xEB\xE5'\xD4\r\x89\\\xE7K\x06\xF5Gg\x92\xDF\xF7\xA9\xBDpyL\x12\xDEg9\b{)B\x17\xBEE\vq\xE1\x06\x93\xD8p\x97\x8C\x8E6\x9A\n\xF0\x87X\x93W~E\x1CyA@\xDE\x9C\xB9\x9D\x1F\x05t,\nE\xA3\x1BPjk:\x89\xFD\xAAE\xD0&\xAC8\xD3\xE4\x89\xE7\xE7\xCA\xCF_\x99\xD9\xB0\xBElP\x8B@\x83v|=|\xFE\xE30b\x1AP\xB5\x81<\xA8\x8A\xB9\x9A\f\v\x85\xFCj\x8E\xDF\x1F\xC1\xA2\x9E)`\xC5]i\xA0j\xD0\x98\xC5Z\xAD\fZ8\xFEN\x8B(\x1F\xABw\xE4,\x83\xE1{\x1D\xB3\xE7z\xEBxU\x9E\xFA\xF0\xCF\x9Fa\xA2M\x9B\x9E\xC5\x92\x91\x89\xFE\x1F\xFE@\x8D\xDF\xEF\xAB\x81\xF5\xE2L\xF2{\xAAwd\fXF\xFA/\x90A\x8A\x8F\xDF'Y`\x82\xCA\xDE\xBD\x80\xC5K3\"\xE1H>f\x01\xBFl\x82&R\x8D\x94\xFE\xABJS\xB7%U'p\xC5v!\xF7\x8B_(K\xE3\x1B\x98\x97\xD6\xC5\x8D\xDF\xB1\b\xB8\x97\x0Fge\xC7\xE7\xBE\x98\xCB\x8E\x87\xFE\xBAET\xD1O\xE3\xA2\x16\x14g\x16\xE2\"[\xCB\xC2\xFA\xC9X\x93\x07\x7F+\x9A\x90\x16\x03L/\x1E\x9F}\x9E{\x9D\xDF>\xF8Mp?\xC9\x1Bsl\x06\xDD\x16\xC6b\xD8\xB5^\xD5\xD7\xB8KF\xC3\xE2\x8F\x1A\x1Aa\x87\xE8H\xAA\n\xC8\xD3\xE7\x9C\xEA\x9C\x9B\x97\xB4zn\x92\xE5S\xDF\xB8\xEC\xB7\xA3\xDB\xEAN\x9D\xC4`\xB3\xD5n\xF0\xD04\x97\xAB\xB9_\x9Dv>\xE1\xFC\xF3\xA9\x07\xCC\xBF\xB8\xF3\x1C\xE2\xF1\xA9m:\x9D\xA5f\xE8\xBFD~\xDC\x16p\xE4G,\xEB\xBFB~\xD3l\x06\xF9\xD5p\xEA\xF6\x07\xC8\xAFj\xE8\xFF\\~ecJ~\xE6\xCE\xC9\xEC\xF4\xC0\xA8\xAA\x19\xEC\xE1\x9C\xD6dv:7\xE9\xCF\xF1JKR\xC8\xE9&\x1D\xEB\xE6\x9BN3\x87_:5Q\xA7\xE3;s\x93\xD6\xCE\xBD\x19\x0EiuS\\%\xF1\x94\xE7s\xDB\x9AX\x19De<\xBA\xCCn\x15\xD7\xD8\xF1R\xA6\xC1Cs]\xAE\xEB~\xA5?\xC5;3N>\x9DC\xC8\xD5\x03\xE6_\\f\xDAf\xE4\xE3\xFBb\x86\x8C[\xD7\xF5\x87M\x81?\x1D3\xE3\xCF)\v\xBC\xE1\x0F\xC6_\x11\xB4\x87`\xCA\xB5}\x16.S\x91\r\xFF\x1B\xF8\xD3\v! \xF0\x17\xF3\xE0\xA5\xC5\x19\xBFnrA\xF8\xA2\xD6\xF2\x8C\xC7\xE3o\xE6\x06\x00\xB8\x7F\xBC\xE3W\x8B\xD0\xF9\x16\xA9\x9Bl\xAF\xF5^\\\xD4:\x8D\x87u-F\x9EZ\x13f\x02qQy\xBD4\xD6\xDE\x1F+\xFB\xF96\xF5\xA24'\xE4\xADh\xBD {N\x8B\x9A\r\xCE\x9D\x13wkC\xD9\xF31L\x0F\xBC>\x88i\xC7I\"\xF2\x02M\xA6\x03e/\twf\xFFt\xABL\x10G\xD7\xEF\x13\x9F6\x85\xB2Aa\xF4F=\xF9\xB5~\x18GPM\x1E\x0F\x11\xF8*\xBB\xEA\x86\x85\xCB\xCF\x1A\x9Fr\xF1\xD7R\xBA)\x13\xF7\x00\xCE\x8D!u\xBF\xD2'\x8BR\xB6E>\xB1&\xBA\x91U\x88\x98@\x18S\x9EZ>\xBA\xA8\x15\xCB\xF1w\xE2vl$\xB0F\xD2\x86ly]\xF6\x93\x89\xF0$\xBB\xA7N\xE1/X\xE5F\xF3\xD8Dw\xB6\xE4\xFA\x8F61\xAA\x01\v\xAD\x19a3\x0E\xD6\x15\xB6\x11\xAEV\x83\xE4\x88\xEC\xEB\xAB\xF5#tU\xB9X\"\\T&\x91\x88\x7F`\xBF\x1F\x7F\xFE\x18\x19\xBD\xFA\x01OB3\x15\xC53\x0Ffd\xC2\xA5\xF0\xECQ\xF7!\x82\x8F\x19(\xADp\xBA\xFE\xAE\xAFl\xB53\x0E\xDFr:\xCF\xAA\xF2\x12\xF4\x94\xD4\xECV\xF3\xD7!N\xCE!\x81\xBF\xE21PW\xA1\n\xFE\xB5\x03\xF9\xE3W\x8B\\n\xDE\x19#4\x99\b\x11\xFE\xA8\xC8|d\xFD\xF2\xFA\x81\x93u\xCE\x8Br\xEE\xDAH\x7F#\xEC\x95\x9F\x8CQ*e2\x84\xC7D\xCD\x9B\r\xE8\xEF\xEBnGu\xA9\xF2\xD9l\xA3\xC3m\xDB0Q\xF6\x12\xA5\x8A\x18\xCD\xB5\xD6\xBF\x8E\xFD\xA1\xE37\x83Y1\xE3k\xFCv\xE3\x1E\xFC\xAD\x8C\x19GQ#\x8A\x9A\x0F*\xFC\xF9m\x98\xF0\x1D\xA2\xC8`\xBB\x99\xCD\x92\x8C\xA7E3\x92\x12\x7F\xD4\xE6\xC8\xC5_U\x93\x82\x1E\xC9\xAF\xE6u\x13\xFD\x12\x7F\x94O\x12\x12\x91\xAC\xA5\x1C*[sjI\x89\x1E}[\xAEx=&\xF1\xE7Kc\xB7\b\t\x0FG\x1A\xEC\xFAoV\xD4\x01\xB3\xE8\x90b\xC7\x89>\xFB#\xDB)u\xE1\xEFs\xE3_t\x19\x9D\xA6\x99\x98\xD5j\xA3k\xFF\xB2a,\xEEP\xF2\xABS\xF83]\xFC\xFD\xAAUA\xE0\xE6\xDF+\xBF:\xF8\x19%\xD9\xEAqO\x8D\x90\xD2\x98\xDE\x88\xD9\x07I\xD7\x99J\x97\x14\x8F\xA1E\x04zi\xEB\xA7v\xC0\x94B\xDBXsz\x9E\xB7\x19VQ,g\xFE%8R2\xD5\x82M\xC3\xD8\xCDd\xEB\xF8[H\x1F|E\xE9\xAB\xCD\xF3\xBD\xF3\x87\xE8\xDC\x16\xF9\xC5\xBD;\xB7\xF1\xD1\xAD\xA7`&\xB4\x03\\\t\x025\xC3\x7F\x1Bn\xBB\xE7\xDA\x1B\x9C\x10W\xE7@_h;\x95\x98X\x9Fk\xBF\\E%\xCF\x01m>\x02\x1B\xEA\xD0\x95L0T\xCFV\xF2\xBBCD\xE2\xC5\xB4\x85\xA89)\x1E\xD5\xAC]7\x94\xF8\x03\xF5\x1F\x1A\x10\x89\x89\xD2\xF2\x9D\x9E\xFC\xF8\x10\xD3k\xF1a\xD2\x7F\xBE\x15j\xBCQ\xBA\x1D\x050\xE9\x1B}s\x1D\xB2\xFCI]/W\xF8\x8B\xE5\xAC\x15\xB8\xFA\x8F$\xB9\xFAMJ\xE8\x11\x1D\n\xBB\x01\xD3\x14y\x1D|\x86\xE8\xD8\xE7\xB9xL\xE2\xEF\xA6\xBB\xB5\x18\x01$\x89\xB9c\xFAQ*\x1D\x06\xF8\x1F\xAC\xFE\xD1\x8F\xF8\xAC\xB6\xD2\xCE\xB5_\x8A\xC7\xA6\x9E`n\xA5\x06\xC8E\xB6\xDD\f\xFA\xC5\xFC\x11n\xC6J\xAA\x8F~\xBC\x1DC\x1FW\xFAo\x96\\h\xE4O\xE5\x17\x05\x9F\x9B?\x89\xD922\xAE\xE6\x0F\xB0_\x96&4j\xB4t\xF3nw\xE7\x05i\xE3\xD7\xA8\xB85#\xBA`\xBA\xF3\x070\x9B\xFE\xDC1\xF59\x87,\xBF\xCDf\xFDL.\x07\xD2\x13]\x96v\xDF\x82\xAC\x17)\x93\xF9\xFC+0\xCD\x82b\x1D.L\xE7\xA3\xDC\x82\x9F2\x18\x17\x1F\xF0(\xDFA1\xF2\xEC\xF4\xA1\xB7bthR\xA0i\x99}\x9E~\x9D\xDF>\xF8-\x1EV\x06\xA9KU\xE3\xF9\x9E\xDB\\\x9Fk8\x97\x10\t\xDE\xE3\xF1\n\xF2\x9D},\x7F\r>\x0E8mu\x85kF\xCF\xF7\xD7\xE6qgO[\xD9\\\x06\xE9\xB9\x83\xB02\xBBsh}\xCE\xC5\xC3\xCA\xF3\xA88\x18]W]2\xEC\xEEl\xB6\xCE<&\v\xEAn\xE5\x10\t\xF9\xC9\xCA\xFC\xA7\xE47\x1D\xFF \xE5\x97\xE7\x92<\x97\xFC\x88K\xFEg\xE4\xE7\x12\xBB0\xE02M\xFAt\x97d\xC2@\x81\xFB\xCC\xB5\xEF\x05\xEBe9\x84\x92\xBE\x86=\x8F`\xCD\xC0\xA7\x1D\xDA\xEC\xF8\\\xD5~\xAA\x88\x93<\x9F\xC3u\xD5\xA9\n\x19\xB8\x97h\x8B\xBB\xCF\xABB\x9E{q\xCA\x92\xA4\xFDh-C\x16\x8AR\x97T\x15\xB32\xF0^\xF7\x1C\x8Foz\xFEO\xC5\xF2\x87\x85\xD9be\"aS\x06A\xDB\x05/\xC0\xA7\x04\xEF\xBB3\x84\x8D.\xA1\xE4\x13\x1A!\xEF\x1FC\x1E\xFC\xC5\x9D&\x9D\x9E\xA0\xC2\r9\xBE|&r\xC8\xF9\xB4\x18\x8F\x98\xF1\xF6v\x01\x9A%1=\x8C\xB9\x1E\xD82\x07\x7FZ\xA9\xB0\xF0\n\xF0\xA7\xD9\xF9\xF8\x8B\x88\xBA\xD3\n\x7FE1\xD4R\xB3\xEA\xB3\xADTE\x8B\x93\x15\xDD\xD7n\x8B\xA7\x12\xF8+j\x004=>\xB3Y\xCA\x8A\xCA\xF3\xF1\xD7\xE8,\xA4p\xD2\x9A\x01|\xF7g\xCF\xDE}\x0E\xFC\x9D\xA5\xBE\x87\xB4\xAD>\xD8 m\x1A\xBA\xE7\x05\x83\xC0)~\xD2-\x9Elc\xDD\xC1_\x91'\xF16\xAB\xC2\xF7\xB8U \xAA\x86\x8DQ\xEC\xF9\x9E\xE9gO\xFF\xD3\xC5\xA2\xAD\xE7\xFC\xC49\xF1\xA7\x89$@\xBA\xF8\xA8\x83\xBF\xB3\fF\x7F\xBE\xFE\x13\xE5o\xD4:\xFFk\x03i\xE35b\x0E\xA5eG\xCB9\xEB\xE5\xF7wrY\x0E\xFE\xB8L\xCB\x86f\xEEz~\x014y*\xD7*}B\x95c\x8B\xB73\x02B \xB9\xA1\xB3\xEBNQ\xF0\xB5-\xEF\x04\x9D\xCC\xAF\x80\x14\xF8\xD7\x15\x12\xC5\x14i7_\xE1o\xBA\xDBu7\xF2\x17/<$f\xB9\x97\\\xB8\xF8[\xB2\xC4N\x8A\x86q\xD1\x84qfs\xA4\\\xEF\x12nmkP\x8B\xA04G\xFF\xDD\xA9\x14@\xC4}\x84.\x0F\xCC\x80\x91|\xFC\x89\x0E\xAB\xEA\x9E\xAF*\x8A\xE9\xA1~\x06\xC4\x97\x98w\xA5\x11!Y\x95\xF7e\xB6\x83\xF3\x8C.\x17\x7F\xF3\xAFj\x9AQ~?as\x14\xFE\xE0\xC1\x1FuG\xD767\v$j\xFF\x9A=\xDByp7<(q\xB6\x7Fc>%\x88\xEA\xFBT\xDB`\xAA\x05\xC7o\x9C\xF0g\x97\xBA\x10\x98\x93qj\xE5\xE7\xE9?\xD5\x90\xB3&\xB9;)t\xCE\xEA\x04\xF6\x9Cxvx\xBCT\xF0\x85\x95\xB66\x85\x8F\xBC\x91\xF6\xE0\xEFln\x93b\xCF\xAA\xD0GDo1=%:\xC6\xE5\x8F_\x05\xFE\xF8\xDEA\xE35\xD2\xF7g>^kc#\xFD\xB0\xE0\xAAe\xD4V\x16O\xEDL(\xE6z\xC1_\xEC\x9EQ~7:\x05\x0E]\x9C\x7F\x1B\xD0\xC2T\xE9($\xBAK\xE9\x89x';\xC7\xFC\xFB\x04C\xDA\x99\x7F\x17\n\xC0\x89sq\x10\xD2\x12aK\xB1;~}Mj\xFCz\vS>\xCFe W\xD6.X\xFA\xF6\x94X\xCD[\x966\x8E\x95.\xAA\xDCuT\x945!?\xE2\xF2.g\x19\xC8\x8C;)\x9A\xD2\x8Fx\x01\xFF\x93\x10\x98\x11\xFAO?\fo\xAA\xB33~UW\xED\x96\"h\xF5\x9C\xB9\xB6-\xBD\x98s&*\xD4h\xED\xF8\xAB\xCD\x84S}%\r\x1C\xCE\x84?\xB2\x7Ff\xFCmr\nl\xBA\xFAo\x05\x83QM\xB0\xD8\xCC\xA0-\x04f\xEF\x1E\x9B\xFE\xEE\xEB\x833\xCA\xEF\xDF\x98O\xFD\xD7G\xAF\xBE]$\xC0\n\xF9q\x10\x922_?\xDF\xBD\xB6/\xA9\xE6\x8F9\x1E\xFCQ\x9F-\xB92T\xB6\xA4\xC1\x16\xF8\x8BB\xBFi\xFA\x99#M\xAD\xA26d\x11\xC7i\xC0H\xBB4\x12\x9F\xF5\x9E@&t\x8B\xA6J\xAB\x9A\x80\xCFS\x91o_n\xACBY\"G\xF9\xCE\x89\xE9\xFF\xF60\xA0O\xDC\xBAc;\x9F\xFD\xB8\xFC\x16\xFE\x8F\x8A\xCD4\xFBM\xDF/\xDE\xC5\x11`Q\xD1\xCC!\xB9]N\xC6\xF0\"\xE7\xFFfI\xFC\xC1n\x01\x8C\x17\xF8\xFD\x05\xCD\xC4}U3\xCE\x1FO0S\xDDK4\x1A\xC2\x9D\xAE\xFDb7At\x11\x9E\xB5\xD4\x85\x00\x9F\xADV6\xE5\xE3\x8F\xFA\xD1\xFFZ\xE2\xEF%\n-\x89\xF1\xF9\xC3\x18\n/\xAEx\xF0\x00\x96&\x84K\xD7\xC6\xC7\x7F\xED\x1C\xE6kwJ$h\x97Je\x04\xE0M\xA6\xE8\xF6c\f\xC6\xCF\xB1*\xCF~\x1E\xF4\xEA\xBF\xCE'l\xED\xD6\x1A@\x9FEw\xD5\x02\xED\x06\xA0\xB2\xF7\xD3Y\x82m\xF8\"\xBAS\xCE\x84+\x8F\xCF\x9C\xD3\xBBW\xA4}\x01\x98\xE7\xFC\xDF6\xD1\f\xEB\xFCv~\xFB\xE0\xB6\x19#e\x8B\x80\x06Nj\xB6\xBB\xFEUA\xAB\xAE\xB8\xD9K\x88\xF2'$\x93\x19_u\x7F\b\xBB\f\x8D\xE6s\xA2P5\xAF\xC7\xF2\xE8\x1C\xBC\xCE\xD3\x9C\x1F\n<\x8A\xBA\xE3O\xF6\xB2\xDEx8\x97e\xD1u\xC3\x8E\xF7\xCB\xE5\x9C\x85\xB7\xCB\xFF|\xFB\xD5x8\xF7\x87p\xDE\xA7BNG\xFC\xB2\x8E\xCF\xBC\xA9?H~\x16\xC5\x12\x1BY\xF7Ta\xFAZxC\xBB\xCF%?\x9B\x1Eu\xBAmg\xE6?+?\x11\xCD\xFC\x87\xC8\xAF\xE5\x0F\x91_k\xE2\xFFL~\x8B\xB3\x80\xBEh\xF3\xF4L\x91\xC6\xB2\x84\xB0\xA1\xBC\xAA\xBE]d\xA8w\xA2\xEC%\x97P\xC2\xEB\xE4R\v\xDD\xC7\xE90\xB9\x8B\xC3p\x1D\xBF\xAE\xE9x\xD2=l\xD6\xE3|\xCE\xF9\xA1\xC0#+o2\xAEJq;\xF1\xCA9,\x95\xAEK1\xCC\x1E\xFC\xB9|&\xDF\x1D|\xE2\x9D\xAC\x87\xCC\xC3S@U}*\xE0\xC4\xC4\x8F&\xEA\xC8\xEF|.\xFC\xC5\xC3\x17\xC4\x10\x8AJ\xFC\x8D\x878-}\x1C\xA5\xB5\n\x7F\xBEX!\xFE\xA2L/\r#&;Cn\xF1C1\\r\x19\x94\xC6\x10\x9F\xEE\xB8\xDA\x93\xA3(\xDC\x9B\xE1\xC8U\r\x8E[7\x17\x7F`\xA2\x12r-\xB7\xE4\xC2\x90=^\xA7\b\x16Q\xDAonL3]\xA7\xC0U\x9CCl\xF1\xD7.\x8A\x98\b<\xBC\xD9\xE3\x03\xD7\x8B\x1A\xDCgSN\xD1\x189\xDB\xDA\xE3\x9Bi?\xC7\x05\x16u\xD6\x91J\xA9\x94j\xA97s\x94\xB6v\xE8\xB5\x8BN\x03z4%\xAF\xE1\xCF\x11q\xD9\xA0\x91m\xF9AB\xCBn\xA1\xFA\xDE\x84\xBF\xF9\t#\x8E\x8F\xC6\xE4\xA9\xA7\x9FN\xAB\xD4A\xF7\x85\x9Ai-\xC3_\x99\x90KK\xD9\xD1\xB9k\x15\xFE\xB4\b*\xD3\xC6ka\x8A\xB7\xCD\xC3\xDFw_\xCA\xC3\x9Fc\x15X\x19\xD0\"~\r\x83~\xB0E\xD5\xE3\x89\xFF\x8A\xC3b\v\x9D\xA0,md\x07\x1C1\xFD\x96\xF3\xDA\xE9g7\x8DO\xF5\xB3\xE2US\x9E(\xEA\xB2\xA3\xC9\x99\xF1\xB7ntB\xE2o\xB5\x92\xD2\xBB\x03\xCA\x0E\x9B\xA6\x9A\xDAV\x01\xFE\xFA\xB1\xE6\xA5m)\xC0:b\xCB\"\xE4\xBE\x1C\x11_\x10\xD3\x1B\xBB;bZ\xE4\xAC\xB0\xFA\xAC\xF1rX\x83x\x14\xA5\n>\xF3\xCB\x99!\x9F\xD2IwD\x8D\xAD\x99a\xBF-\xE5\x12\xBE\xAC\xE4\xA4\xEDt\xAC\xB9\x1D\x81\x84~\xF3\xD9VO\x17W\x19\xA2\xFF\n\xE1\xEF\x02\x0F\xFE\fUE&\x90\x14\xF9$m\f\x98\xF8\x85\xCC\xFFE\xA6\xBET\xB2\xB6zDcz\xF7I\xE7\xC0\xFD\x1C]\xAC\xF7\xCD\x98\xFDw\b\x1C\xA9\xF3\xE0\xCF\xDC\xAE\xDE[e\"\x07\x7F\x11}_\xA7\xC0\x9F\xEA\x17\x88\xFF\xEE\xDC\xCB~\xFA\x14>\x9AO&\xE6C\xDFX\xCF\xF1w\xC7\xD4\xF5\xF2\x96\xB7\xE5\xEB\xBF\xE6\x81\xB4\x96\x8D\n\xFC\xE9\x8B\xFA\xB1\xC26\xB6\xA3\xECy\x19\x9F]\xF9c\x07\x7F\x95\x0E\xEB\x88&\xB4\xEC\xF4\xB3i9~\xAB\x85\xDFEVw\xCA\xE2\xA2\x84\xF1J\xB8\xE6\xB9\x02\x98\xF5}w\xD4\xA9\xDC'\x7FP\xB97j\xD0\xD53h\x81\x8D\x12\x7Fz\xE4\xAC\xC4\x9F>Aw\xBA\xD7\x83?\x7F\x06-+7Mf\xABa\xF5f\xCD\x99\xF4\x9F\x8E<\xFD7\xF6\xFE\x8F\xE9\x04N\xCD\xDB\xA7\x9D\xF1:@\xF8\x9B\xDF7\\\xA0\xFF\xD6\x8C\xDE\x11\x02\xAC\xB6L\x96\xA9!\xED5jb\x887v\xD9Z\xE4\x7F\xC2\xE4\x8F\xAF=w\x04e\x83z\x16\x15K\xE5m$*@I\xE8N\xEA*I,\xA1\xE9)\xA6&\xE60\xF4d\xDC\x99\x99\xE2X\x96F\xFF\xF4=\x1E\xFD'C\xCC'\xEE\xE1Z\xF2\n\x0F\xEF\xD4\xBA\\\xEAF\x1E\xB12\x06\xE3+-*\xA9\xBDu#\xC7\xDF\xDF\x00\xC6\xA7\x10\x88\xE9q\xB7\xED\xD4\x12\x98&~\xB1l\xA8\x01o0_r\xBB\x07\x7F\xCB\xBBC\x05\xE3\x97\n\xC0]p\xD5\xF5\xDD\xD7K\x1F\x9F\xFC\xFF\xBFpv\x19y\x82\xE2p\x8F's\xE5\xA7w Z1L!\xB4\tY\x06\xD8\x97C\x9BW1\xDC\xDE\xBCwP_;Kd2\xCCZ\xD1\x89\xD2\x98\xDE\x8D\xCA\xED\xF2\x9D\xA6\x0E\xDB\xAA\x85\xB6; \xA2\x83z\xEA\x1Fk\x14\xFE\xA6\x1F\xA8\x0F'\x15\xFE\xB4wa\xDAz\xC7\xFC\xCAnOMQ\x01\xB3\xFD\xA5K\x1A\xF2\xF0w\x91K\xDD\xA8]\xF6u\x80v\xE3z\x14\x89\x8Bg\xDE\xE2\xF2[O\xC1\xEB\x17\xC6t\x8F\xFE\xBB\nz\x12\x9Fx\xFC\xEA\xEB6W\xA3\xF8\xB2\xED[<\x8F\xEC\x84\x05\x04\x9C\xBD?L\xF2\xDB41A)\xC7\xF8\x84\xBA\x83\xD5\xCE\x8C\xF8c\xF2s\xCE\x7FdE\x9E\xFC\x1E\xC3\xF2\xDE\xFA\xCD@q\xC3\xD4\xA4\xD4\x059\xCB6\x974\x19\xF7\x19\xA51=U\x85\x00\xFD`\xDCL\xF5\xB4\x00\xBF,\xC3u\xE6\x11\xE75.r\xA6\xEEe6\x90\x8A3\x19'c\x86{\x9F\xE6\xE3\xF7U\xF9\xEB\x15i\xE3\xB5\x13\f\xEE\x8B2D\xB0\xF2\xA1\xEE#\xC9\\\xF9\x197\xBB\xF8\xA3\xC1\xB9\x03\xD0:Z\xE4\xBD\x00\x7F\xC5\xC7o\v\x8D\xA3\xC5i\xC3\x83\xBF\xBD\xCCw\b'\xF6\x8FtD\x7F\xCA\xCC\xA3\xDE\xBE\x845\xBFV\xEFm\xA5s\x03\xCB\x84\xB7@\xEF\xF8o$\xAF\v\xD4\x1D\xFCt\xAF\x1AQ\xA9\xC7\xA8X\xF4\xF0\x91\xBC\xF1\xFB\x1A\xD6\xFC\xB7\x91\x0Exj\x8F\x9D\xDF\xCEo\x1F\xD0\xE60\\\xF1\xC75au\x0F\xFD*0\xB1s\x89S\xA1\xE5\xEB\x1C\x85\xB4X\x88\x0E\xCA\x96\xF9\xE9\x85A \xED\x04\xFFk3z\xAB\xF8!3\xB4\x18\xB2\x17j\x7F\xC8\x03\xA9JX\xFA\xEF\xD8\xC3\xE9\x7F\x91\x97\xE2\xC4Dn\x89Y\xB8L\xC0B\xB9'P\xF7\xFD_-?&R]MU\x9A:d\x02w9\x1AE\xEB\xF7\xC8\xAF\xC6Y@\xF4\xA7\vO\xC5o\xC8Y\xBD<\x9C\xEF\xF0\x00\xF0\x90\x98p\xC3\xE1r\xB2&\xF6\xC8\xFB\xF3\xD5\xCD\xE0\xCD\xBD\xC3\x84\x9F\xDBW\xA5\xDF\x94\x16E\xA5Z\x11\xEE\x04\xF4\x85\xE2\xE2K\xE9\xEF\x9AA l\xA5\x99\xC7D\t\x97\f\xE2!\xC0\x18V\xD4\xD7\"\xAA:\x99\xF5r\x03\xCB\xA5\xAF\xE7\xA0\xC8\x05\xD1@\x85Y\x97\xC6\x89\x8Cx\x99-\x82U\x16\x8FO\xB70k\xC2\xC9\xAE\xD6LO~\x8A[j\xCD\x8C\xCD(\xBF\xFEJu\xC9\xB6\x19\xD0\xB5]\xAC\xF3\xD7\f-\xA4>\x80\xED\xBFK~\x1B\x9B\x11\xB0\xB50\xFC\x8A\xCF\x89\x96\x1B%i\xEC\x01\xF4\xB4(\x9Aa\vb\x17\x03Z\xFCV\xA6\xDF=A4\x1E\xC3v\xAA\xB9)\x8DT\xFD\xE1\b\x84\xBD&\xB7nPiL\x14\xD5\x9D\v\x7F\xDA\x86%\x05O\xA0m.xf_\\\xC4\xF4\xD6\x89\xE8G\xDF=s73\xB3\xD7\xC1\x1F\xBDBi\xF1x\xF07c\x02\xAC592\xAE\x0E\x1B)\xC4\x9F1$\\\x03>\xEBgC\xD4\xD6jz\xE6,lZg\x98|\x0E\xD5\xD02\xAEa=)\x8Dh\xE38`-~\xC5\xE3D\xFBH\f\bW/\xB9\xFE\x98{\x82\xC9\x9A4'I\x14|He\xDC\x8B'\x87\x01_\x9B[\xAB\xAEY\xE1\xCFA\xAD\x95\xA3)\xD6\xA5\xF5\xE6\xAD\x05\xF8\xD3\n\x1E\xBA\xEC\x84L\xFAn\xAE$\xE1\x14\xBF\xDD\xBC\x95\x05\x12\x0E\xFE\xF4~\x8F\xFCL\xE7\x12\xD1\x98\x9E,\x90_\xA0-\xA5j[\xE9\x87s*r\x8A\xFFK\tBS3\x92:LM&%\xFF\x9DS7\x837\xE3\x9A\x06,K\xEB\x97 \xFC1y\x1A\xB1\xF32\x91\xDA=!,xq\xB5\x95\t`\xBA\xF7d\xBD'#7\x15M\xF0\x1B\xA7z7E/\xF3?\x8D\xFD@`\xD21\xA5\xB4(\xE0o\xDC\xEC-\tV\x94C\xF1\x96\xD8Z\xB40\xCB\xB9\x10\x7F\xF3#q\x90\x9C\xEB\x1E\x93\xC1\v\x1F\xDA\x82\x92w\\\xFC\xBD\xEC\xC5\xDF\xEF\x91_*\xA5\xEA\xC7\xEA]\xD2C\xE4\x95_\xF2\x94\x18o\xF5m\x9CZ\xEA\x9D\xBFS~\x9FB\x14\xC6\x14*\x7F\xB0\xCD+\xBFrF\xB5h\xC2\t\xCF\x02QY\x1A\x88F\xEF>\xE3\x19\xBF}\xBDi\xBDK\xD6$\xA6\x19\xA8\xE8z\x8E?\xE4\xD4J\xB4\xBE\xFEZ\x0E\xFE\xE2\xB9\xFAO\xFFT!\xFE\xF4=\x05\xF2;\x92\x11\x11C-\xA2\x96\xADo\xFCs-\xCC\x9C\x1B\xCC9B\xE9?w)\xA2:f\f\x17\x8E\xDF\xDE\xF7\x9D\xF1;\x81h\xFE\xD5\x8Da\xC1\x88J7\xED\xA0\x12Y\xEF\xAA\xF1\xBBm\xA6\xF1\xFB*\x88)\x05vJ\xE9N\xC8E@\x1A\xBF\x93\xC7=\xBEJ\xAE\xFF~:p|\x97G_d\xFA\x134~\x9D\xF9\xA3d\xE2\x00\x10\x9C\xE8\xF2\xE2\x0F]\xE5^\xFC\xF9\xF3\xF17u\xB2\xE0\t\x8Dw\v\xC6\xAF\xDF\x16\xEE\xB3\xFB\x97\x88\x868\x15\x91\xED\xCC\x9A|%w\xAD%\xAC\x16p~\xF7\xFC\x11\xEAZ\xEA\xCE\x1FV>\xFE\xD0Q-\x82\xAF\x9F\x13\xA5\xC5:\xA5\x84\v\xE7\x8Fr\xA6o\f\xC1LhS\xB0\xBE)\x7F]\xA6\xE6\xDF{\x01=\xDE\xE9:J\xC9E\xD7b\xDE=\xF6\x8C{\x82\xCA\x1Di\x8E5*\xA3IU\x86\x03=7\xF2\x01\xF0s\xE7\xB1:\xA5\xFE+\n\xCD\xAC\xFF\x96\xDA\xDA\xE6K\n\xED\x97\x82\xAC\xFD\xC8\xA2r\xB16q\x9Fp\xAC\xFA\xC3\xCDq\xE6\x0F;\xE3\\\x14\xD0\x92\xF23\x1D\x91\x04b(\x1C\xBF\xFA\xA3]N\xB1\xE3\xD4\f\xAD);T\xE7\xCB#]^\xF9\x15\xCD(\xBFF\x04\xD2|\"^\x12\xF7\xCE\xBF\x01\x86'\xB9\xFCv{\xE4Gqmm,\xEE\t\xDE.oK\x90\x9D\xC3\xEFq6\xDF\xB7x\"\t\x94L\xAEt\xF0w+\xE0\xBB?\xA2\n\x81\x15\xE2/\x9A6\xB2O\x15\x8E\xDF\xFE\xFC\xFFY\xFAV\x15\xCA\xF8~\x97=\xA2\xEA\xF5}\x1C\xB3\x16\xBE\xE5\xBC\xA8_{c\xDA\x12\x1E\xF3\xE8t\xE1\xF8\xFD\xD9[\xCE\xF8=3\xC3\xFC\xEB\xD4\x16\xD9\x91\x93\x006\xF3\xFC\xFB\x1A\xAA\xA9`\xC9\xE8\no\\\x81\x1A\xBFo\xE5\xFC\x9F\xE3\x8CP\xDBx\x7F\xC2x\v\xB0\x8E\x9C\xA7_\xE7\xB7?\xE1-\xC4)\x81Y\xC8\xFB\n\xD9\xAA\xF7\x0F\x1C6\x11\xCE\xA5\x96y\xAC2\xB7\\c\xCC9\x97\x9DOI\xCF\xFD-\x9F\xC7\xCB\xCD\r\x943soR<A\x18hh\xC8y\xAA\x86\xDF#\x88J\xD9\x11\x89\xB9\xA7\x92\xAB\x9C\xCC\xF7\xF5,E\x99-\xDD1t\v@1\x90kdC54@\xCB\x91\x1F\xF5\xE1Y\x90\xCE?\xF3\x83ps2=;'\xD0\x11f\xBAX\xB8|\x06\x171\xF4s~D\x1B\x11\xB1$\x05\xF8L\x83vQ\x0E\xB8eLO\xA2R\x9D\xA3\x1F\"C\xCB\xD9\xAAg\x96_\xD6[|\xD5+?U\xBDU\xCF\xC4a\r:\xB1\xD3\x86\xD0f\xFD\xCAoX \xBF\xBCL\x15>\x15\xC5er\x96\x91I\xE1\xA3T\xC2K\xBF\x1D\x9D\xAC\xA8M\xC4\xDBF\xDA\xAEL\x02&\x7F\x8B\xA1Vy\xBE\xAD\xCC\xDA\xE6M\xDA\xA5\xC5\xDB\v\nZ5&\x9D{\xF1\xF2\x0F\x7F\f\x1B>\xC6d\xA9\xC9V\x84\x19\xBA\x9CwA\r\xEB\xB347\xCE\x15\xD5(U\x9C`5\xD33\xF0L\xB3(\x1A\xFE\x03\xF0\xD7\x9A#?O\xA0u\xD61\xAE\xFB\xA9\x921\x11\xE8i\xE8\x02\x7F))+\xA3`\x8A\xC9\xB3.\xCF\x8ASQ\x8E\"?U\x84\n\xA4\x89\x0EB\xD7\xCB\xDC\xE1g\x97'\x01\xA2@\xABG\xE5\xAC;\xC2\xB4\x18<a\xF5\xF4Vj\x12\xB9s\x99\xBC\xDD#\x9E\xBA\xCE\xCE\x12\xC3\xBB\xCC\x1A\xF3\xF8\xCF\xD5\xA4)\x82\xB9\x13\x80u\x03~\v\xDAE\x99\xE7\xA7\x98\x95\xC4\xA4\xD7\x8C/\xCF\xB5\xDBg\x12\x9F\xD1\xEF:\x9B\xF8F\x8Dl9\x1B6\xBA\\\xEE\x8Cb\xD5}h\v\xACLF\xDD30\xCC\x82\x05\xB6\xD0P\xEE\xD7\x14\xA3\x9A\xB7\x84?\xEB\xD4+\xFCa\x8E\x90\xD4l\xCC\xF9\x9A(\xC6\x92,\xDF\xA1:\xE0\x04\xDA\x9C\xDEX\xD66l\xF1Z-\x00.\xCF\xB9X\x92\x81j5\x91\xE9\xA2{\x8D\x8EhBO\x1Dd\xB2\x12*C8\xA1w\xC9\xA2\xA5\xD0S\xFC\xB0\x83\xC0\x9CA\xD8b\x97\x80s\xC9\xC0!w\xD4%\x8199U\x81\xC3\x89\x19u_Wn\xA0\xFFq\xF5G\x7F\xC6\xE1~\xCF\x90\xA7\x9Fh\xDA\x04\v\xEC\xB8\xCF5\xB7\xFA\xBC\xDD\x91\x94\xEB\x8D\xE5Y<\xA2\xE6(\x15\xCCNu\"\xCA\x8Cf2\xEEZ\xD8\x9C\xFB\xB3$\xBF\xBE\x9E\x91\xA44#kF\xE4\xBB\xECg\xFA\xA0\x8C\x95\x94\"\x01pE\xCE#\xF4\xC93\xEB\xB2,\xAE\xBB-K\xEB\xFD\xFBe\x7F&\xFD0\xAA9\xE5\x96\x8DE\xF5\xFE>\xD1KwN\x15\xA6\xC5.\xCA\x97\xD0\xCF\x02\f\xCE2A?0'\x07\x7F\xD53\xCB\xAF?W\xFF\xF5\xAB?N8}`\"E\xD8\xDD/tv\x80\xF0\xA7\xDF\xAB\xE8p\x81\xFE\xEB-\x18\xCE\xBA\xEA\xC7\x1C\x98\xE8\xE7\xF8\xAB\x03J\xB6\xE1\x15f\xDD\x11\xA1\x1F\xC6\x9E\xD9\x94\x94\xE3\xA3tS\x83\x1A\xBF\xB3w{\"\xCE\xC5\xDD\xAF\xCB\xC1_FVs\x16\x83\xF8t\xCE\xA3\x1A#\xEF\xCA\xC6\xA2\xC6\b\x16s\xC8\xCB\xC77\x86&\x18\x8CW\xC8\x02M1\xF2r)\xF8\xBC\xC1\xA8\x93\xB2\xB3L\x05+G\xFF-\x9By\xFCv\xE5\xC8O\xF47\x88\xE4\x84\xD2\\/\xDA\xB7\xD1\x99O\"\xB8\x83\x93'\xE3\x97\x12\\\xC1\x02\xB2x&\x17\x7FK\xC5\xA9\xE8\x1A\xD6\xE2\x11\x94\xD2\xFAZ\x10\xF8\x06\xF3\xCD\x9D\x02\xF4&T\xEE\x18\x1A\x96\xD1,e\xCF\x1DR\x8E\xEBb\xA7\x03\x13T\x13\xAE\x05\x89\xFC\xF9\xF7?\x1C]\x9C\xCC\x9D\x7F\xFB?\xC6\xE4:\xCA3|\xE6\xCC\x9B\x7F\xF7P\x9C\xEA\xB4\x98:TI\xE30\xD3\x9B\\\xED\xDD/BY\xDD\xED\xCF\xCE9\xFF\xBA\x11\xBFb=B,J8\xA1\\\x99.Z^\xA4\xF9\xB7\x06\x86\xE8L\x95\x94\xE02\x1Af2Xr\xC7/vChj=\xD3\x8F\xB2A-Js^)+\xCA\x84I\xD1,\t\xD4\xC6\xE5\x92\x8C\x1E\x96\v\x99\x9Fb\xB9\x99e\xF4\xEB\xFCD\xFED\xD5\xE1\x8C\x19\xEF\xF8-I#u\t\xD3\x8F\xC8\x894\x92@\xDC\xE9BE\xD5\xA0;\x81\xA2G\xB9\xC0\xA8\x1Cw\x933\xFF&\xB1\\]\x92\x9B8\xB7\xE7\\n\xC6\xF1K\xBC;\x9E\xE3\xAE\x90\x7F\xD4\v\xD5\x13\x0F\x11\xBD\xAE\x14\xF92zC\x18N\x12D\x94\xE9\xBFo\xFE\xD5\xC5\xB3\x89\xBAt6'\xDF\xDAWH;L\xC3\x9A\xC7'\xB9*d\xFA_\xDA\r\xAC\xA3\x94\x84Q\x19\xFD\xFE\x0E\xF3d\xAF\xF0\x87\xB3\v\xE6\xDF\xF7\xD4\xFCKk\xBE/\xE6\x98j\xC6\xD1)f=*\x07\xE2\x1A>\xFF\xAA\xF1\xFB\x16\x9F\x7F9\xD3\xAC\xE3\x16\xC0\r|TH\xE7\xEEqf\x95c\\\x8D\xDF\xD3\xC8[g9\xC7\xF8\x1D:G\xA2\x98;~{\x87H7MH\xFE+(\xF2\x84\\\xBA\xB2\xDA\v)r\xC15^\xF4\xF8:j\xD2Fj&f}~;\xBF}\xB0[\xAC\xC11\xF2=J\xF5\x01\xE7?m\xCCD\x87u\xF5\x83of\x9A\xE0)#j\xE7\x9D*\x87\xA16\xCDp\r\xDB\xE5\xC7\xA1\x1C\x06\xEE\x9EI\x14\xFDpOe\xCA\xFDc\xF9\x94\xDD\x84\x96\xD3\xC87\xEF6D\xD5y\x93!t.\xCEo\xFB<\x05x\xBC\xAA^n\vj\xAF\xAB\x16Z\xBE\xC4\x9BJ\x97\x82\xF5\x129\xF04oT\x89\xC8\xF9\xB1\xA8\xF6\x8E\xF6\x15y\x1B\x9CJ3\xE5\xE7\xDE\xD4)\x92\x90\x9EZ\xCE\x8F]\x8E\x05M\xDA%X\xF0\x99\xDD\xC0\x82\xBF\xCF87\xAE\xCD\x92\x9F|6\xC5\xE1I\x89\x85\xFE\xEE\xF5\x8B\xA0\xAB\x04\x92\xABi\xA2\x12\x19\x98T|\xDA\xB7\xE8\"\x84\\\xF9\xF9\\\xF9Qy\xE9\x18Z\xE6\xC6\x80\xDA\xB9i'\x1E\x89\xFF\xE0\xDF\xD4c^\xD3=\x83\xFC\xF8\xCE\xFEyi\xA06\xC9\xF4\x90\xCB\xF27xv-\xCA$\xE7s-\xBA\x95\xF3\xACM\xC9\xFD\x19\xEF\xBCJ\xDB\x05o\x8C\xD7\x8B\xAF\xE6]\x1E\x85<\x8A\xD0\x9D\xE8\xCE\xC7\x86(M\xC3\x8DO\x93\xC9\x8C\xC3\x10|\xE5\xA8u\xB2e\x99S\xEE\x17D\xB7\xC3\\\xBC\xD4\x954\x1A\xD8\xE7d\xF3j\v\xD5ZF\x06(U\x01\x98\x98\xB7}n\x185\xC7\xE5\xA9\xDEe\xD0\x9Ae\x94#E\xF2\xFA\x16\x851\xD7]!\xF5=\xEA\xE6i6\x93\xFC6\xCEm\x02\xB6\xDE\x1F\xD3\x9Ce \xAD\x1A\xEB\xC2\x15\xC1\x86\x05\x85\xD1\xD6\xD3\x1D60\xDD\x9E\x00\xB6\x0E\xA4\xB5\xCD\xAE\x95\xE1\xF5\xF2\xF8\xAE\xCC\x9E\xFD&\xE7\x87\x03i\xA0n`\xBFY\xC0*k\x96/>\x83u\xD4\x14\xE8\xB4\x8B?\xBD'\xBF\x94\xB4\x17\x7F\x19\x0F\xFE(\xCAv\x82\xF9s\xD7\xCC\x8D\xC11!{\x8B\xA1\x1C\x16\xE3\xCC\xF7\xAEtL\xE1\xCF\x18\x94V\x87\xC5\x19\xB8\xAD\xDCqkw\x9C\x1A\x84.\xBBna3\x83ab\xAD\xED\xF8\xB2\xAC\xC9\x9F\xCB\x1B\x17A\xDA\xE5\xCEP3\x8E\nF\xFFt\x1Axsu\xCCp\xDC\xCA\xC6\x11\xF8\x8B{\x8F\xA4}\x1E\x99\xC8\xAB]\xB0\x96j\xC7\xA4\x81!\x93\xA1\xD1\x15\x89\xD7\x92\xB6&\xDA\xE6\xAFKsa\xC7\x80\xE9d_\xA6\xC0\xDA\xB9\xFC\xF3\x937\x89\xD6\x10\xD1\xDE\x1C\xFC\x95\xD6\x86S\xF9\x89\xAD\x02\xB6\x9C\xB8G\x12\xC6\xA7 \xA8y`X6p%3t\xBB\xB8\x8DC|\xFC\xE2}\xF8\xD2\xC8\"p\"\x03|x\xE8P\xBB\x948\xF0I\x89?-\t\xCCr\xE4\xE7cv3j\x86\xA4\xFC\xBE\xCB\xF8\xF0+\x16y\x81\x19J\x0E|\x14\xB3H\x9CD\xEB5\xDB5:\xEA\xE8\xEB\xC6`\f(\xBF/\x06\xB7\x96|3jF\x92\xCDK\xBF\xEB\x8D\xB6\x16\x1Ai\xC87\bD}\t\xA0\xE6\xE9\xB4\xFE\t7\xA2\xB9\xCC+\xEB\xBA\f\xE1\xAFt\xEF \xB0\xB0\xFFa\xBB\xC0\xAA\xBA\xA2\xFE\xFA\xAF\x88\xBC\xDE\xE8H\xBBw\xFE\xA8\x19\x9D(\xD0\x7Fn\x92|\xD9\xA0\xFCa\v\x02\x87\xD0\xC7t\x89\xBF\xF5\xA5\"\x8F\xD4\x1F\xA6\xC6\xC5(Kh\xF5(\xEB)\x07*\x1F9\xD9\xE1(\xEE\xDD*\xAC\"\xC9u\xB1\xBAFI:\xC6\x10\xBA\xD2M\x9C\xD7\"\xF2\x95\x11\xAD5\xCA\xBF%bHE\xE9\x17\xEF\xB2WVT\x07l\x8B\x01[w\xA4=\xB3E\x1C\xE6\x9D&+\xF7\x16G\x97o\xAB\xC2o\x03\x1B\xB9fY\x99\xE4/\xCAR\"Y\xC9\xBC.R;\xC2\xF1W\xF3X\x13P\xD9\xB68S\xC0\xCAWo:\xF5\x9A\x88\xA3X\xEBMu\xD9\x8Bh\xAAw8\x7F\x85@v\xEDIB\xB5\xEE&\xF9%\x91bs\xA4\xEC\xFFe\x05=`\xC9\xCFn\xE5W\xFF\x12l\xDB\xF8\x1A\xA2}\xC3@\xB4G:\xF4\xB9\xFE\x8BI\x83\xDB\xF7*\xD7\x7F\xAAL\xD1\xFC\x9D\xE3\xD5({\xDE\xF6.\x94\xCDK8\xFA\xAFh\xBCJ\xAAC\xC2\x9F\xCF\xC6Q%\x92FR\x87\xA5\\??_\x1As\xB3\xFC\xB4jT\xF7\x8D7\xDF00\x83\xFE\xFB\x0E\xFFs?H\xFF\x19Y8\xC5\b\xBC\xFA\xAF\xE8\xD3\xD9i\xFE\xD6k\xB9\xE6\xAA\xA3\xAE\xD3\x85\xF3\xEFW\xE0\xA7\xEE\xA7C\x1E\xFC\xFD\x025/\x8Dq\xFC\x193\xE0o\f\xA8\x194\x14\xFEJ\x8E\xE00\x93\xFD\x1B\xB1^\x94\x8D6\xEFI\t\xFCU&\xF8\x9FT\x12\xA8\xEC\x1D\x16\x84\xAB\x02\x90\xA1m\x15\xD4\x8Bn\xB5m\xC8\x8A\x83U\xAD\xBBZ\x11\xF8\xEF\xF2&+(*\x87:$\x8B\xAAus\x961\xAC\x16\xED\xC6v\x8B\xFF\xBB\\\xD1\x96FZ\xB6\xA1~r\xFFp8\xE6,\x02\xC2\x88c~\xED\xAE\xF8\x916\xAF/V\x80\xF1\xF1\x1F\xA5\x81\x8A5i\xE0X[\f\xDD\xB8B\x89\xC4\xEB\xE5\x9E3\xDC]1'\x06\xFC\xEA\x81&\xE0Wm\x7F\x91\xF1\xAE+\v5\xBAo\xFC&1H\x02]M\xDE\xF5I\xB3\xAB\xBCM8\xAE\xDDM\x04\xFAsRh&\xE4\x0F[\x1041\xA4V\x9D\xD5\xF8\xF5\xAB\xF1[\x9E\xD0&\x10\x8E&\x81%\xCB\xEBD\xFC\xEE\v\x80\xF6I\xF9\xA9(\x0E\\hkrZ\x9B\x7F\xEF\xDFn\xC0e\xDF\x92\xD3\xD8\v\x80\xB1\x10\x17\n}@\xA8\xAB\xF8\xA4\xFC:\x9B\xDFi\x91\r\x15\xDC\xAF\xCD\xE6j\x14\x1B.L\x00u\xDF\x89i7\xBB\xFA\v+\x0F\xFC\xED\xB5\xB7\xFC\xD0;&\xC5\xE4\xFF\xFF<h\x03/\xF0\xF3\xB5\xFC\x90\x19\v\xB1p&\xFC\x15_\xB3\xF0\x85?K\x03\x9F+g\xC0\xAD?\xFC\x96\xA2\xDCN\xF9>\xACY\xBE\xEB\x15\xAC\xE5\xF2\xAB\xEE\xCB\x89\x89\xAE\x19\x9D\xFCe\xFE\xFC\xEB\xEA?\xA7\x85\xC44\xC3\nXl\xB6<\xF3\xD5\"\xA7\xBA\xE4\xDF/\xE1w\xFFUT\xA6\xB5KPy\xCBn\xA0\xFC\xD4\xB8X\xE3\xFD\xA2c\xBF|\x91\xF9vs\xFBO{A\xDA/'>\xB4\x10\x17}V\x9E\x8A\xEF\xF7\x82\xB2_2\xB9\xE3w\xA1\x18\xBF_T\xF6\xCB\x97(\"\xFE\x9D]6p\xE5\xBCt\xCE\xF8\xFD\xD0\xD2\x0F\x99\x1B\x1F\xF2F\xFB\x8B\xAB=\xB4+\r|\x91\xFFi|\xA8I{\xC1\xB5\xFF\xD6{\xED\xBF\xBFz\x81\xAEQ\xBF\xA7\t\xD8\xF2\xD0g\xCE\xF3\xDF\xF3\xDB\x07\xBE\x89\x90\xDF\xD0L^\xAE\rs\x1B\x9C\x18\xE5\xDF\xB5\xE9\x1Eb\xC2`{<\x9EZ\x01Q\xA2O\x11\xDD\xFBc\x03\x9D\xA1\xC9\xF1\xE1\x86\xFE\xB7\xEE>\xDFem\xBA\x8C\xD5\xE7\\\x9EO\xF1\x1A\xC0\x1A~\xFF\x19s\x9A\xAB\xD8\xA5\xBF\xEBW\x88$\x95\r\xA2\x10KQF(\xCB\xAD\xC0\x9DBeXk\xB8\xA2\x98\xDF\xAD\xC6\xB9P\nE\xABr\x9A\x1B\x15\xBD\x8AZW:\vl\xAF\xFC6\xDD\xEF\xA9\t\xE3|\xB4\x16E\x1A\xC5\x85\xA8\xC0\x83\xAF\x01(MkA\x92\xDF\xDF0\xAE'\x95\xD3L\x953\x96\x15\x8A\xA7T\xDA\x97\x96\x05|\x93\xFD\x9B\x98\xD3c]\xEA\xE2\xC9\x97Q2\xB4\r}\f\xDAM\x805~\xB1\xFCy\xD6\xA3\xC0:\xA0\x7F\xE6\n\xCA\x86\xE3\xA3*\x1EC\xE4#\xB2W\xE3k@\xF1\xA2\xFC>\x1CD\xB3\xBCu\\\x8B^\xE6R\xE3wU$j\xC2\xE0:X\xE3\x822\xBEI\xD5nK7\xA8U\\aX\xF8zr\xD8Y\xD1-\xD8\xC4\x9C\x89enN`t\xBD'j\xCE\xADD\xE4\x1F\x17\xB1\xAB[DU\x10*\xC6BU'\xADC\x9C\xA6i7:\xA0i\xA0\\n\xFA4\x1FZl;d\xCD\vn\xF4\xFA\xE2]unU.aI\xFB\xDA\xF6\xA0\xBA\xF2\b\x92\f\xC6\x19\xC0w\xCF\x19u\xF1\x06\xA0\"m\fm\x9EQ~n\x91\v\x7F\x03~\xDC%^\xB4^\x0F\xF8\vb\xE4\xBF\xAB\x12\x1A\xD5\x16l\xC7q\xA6VpG\x85{\xD9\xB7C\x98L\x95\xDF\xE5/f\xCD\xE8\xAB\xB9/yMN\x98n\xF0U\xF2\xCAt:\xEB\xEFa\xD7\xE39\xE1q\xDEY78\x9F\xAE?pR\xD0\x04z\xFC`\x03\xB0:m\x1C\xA44\xD0\xDF2\xD7\v\xA5]\x99\x95\xD5\x1F\x8B\xDF\x9ER\xF8\x13\xFDk'\x80\xE0d\x7F\v\v\x94\xE7P\xA8\x92\xC94J\xDE$\x9F?\xE1oB\x05t\xF2\vU\x9F\x13\x7F\x9E(\xF9\x06tW\xC7\\\xE7\xD5d~D\xF2x\xFE\xEA\xB41Fn\xF1~Z\xDD!\"<\x17sd\xB0\xF9F\xAA\x80\x19xX\xD99\xA2\x16\xAB\x9E\xAC\xCF\x01\x7F\x1D*\xDD\xD0\xC9\xA2\xB4\xD1|\xD69}\xD9\x0E\x8FW\xC7q.\xF93o\x11\xD5\x9A\xC7\xA8\xC0\x8D\x91\xA1Uz\xB1 >\x9F\x01\xF5\x0E]o\xA4\\Z\xA0\xE8\xBA\xCD\x9D\xCC\xDF\xE0\xE0\x8F\x138\x9D\xE3\xAFDy\xE7\x96\v\b\xB5]\x8B\xC0\x92:\x98\x02\x7F\x81\x1D\n\x7F\\\xCE\xCB\xD2\xC6P\xF7\xCC\xF8s|'\x81\x06L\xF7J'\xEB\x93@ \x95\xDF\x07\xAB\xCF5\xB9\xE5\xB1\xBB)N\xB0\x8B\x9E\xA3R\xA4+\xFB\x12\xC2\xEB3J\xAA\xA0d\xC8)C#\xD8g\xD5T\xCE\xE4\x91\xE1bW\x83nvB/wA\x1F\xF5 \xDD\xCD\x91\xB5\xECg(\x92a%\x8CC\xD2Kn\xA61A\xCF\xC1\x7FP\xEF\xDC_\xCF\xE5\xC7\xC7\xAF5\x99m\x86\x95\xD9\xEED\xACf\x00}GW\x1Ds\xA2\x86(\x1B\x10\xC1\x1D\xEF\xD2\xF8\xCD0\"qV\x9B\xAA\xE3l\xA49K\xD5\xBB\xA6f\x94_\xB1\x17\x7F\xEB\x15\xFE\x8E\x03V\xEF\xEF\xC5\xDF\x9CW\x94\xFE\xF3%E\xBAc\x1D+\xAA\x103\xC4UD\x1F.t\xC4-\xBA\b\x17=\\\x97\xF7\xF2\xB6R\xA7S9\xC5\x18\xF5\xEE\xE97yV:|\x0E\xFE\xCC;\x85\xA2\xDD\xEA\xD1\x7F\tm9\xE1\xAF\x91\xA929\\~{d\xF5`\xFD\x9E\xC6\xEBYQ\x833\x7F \x0E\xF8&\xFA\xA7]\xF9\t\n\x1A\x18\xF7a\xDE\xD06\xEC\x14\nYw\x86\x1F\xDF/\x143\xB2\x7F\xF9\x07\xE0/e\xBBN\xF9\x89\x02\xFC1'\xD8\\\xCEL\xED\x9C\xE2\x19\x9F\xA1RK\xD4-\xFE\x18\xD3w\t\tm%\xF5\xBF\xFA\x07\xEA\xF5\bR\x18|\xFA\xA6\x1C\xFD\x97\xA1\xAA\xE3\xAF8\xCB\x15\xDD\xCE:\bF~\x98[SL\xCD\xAB\xCD$\xE2\xA3B\xFD\xCF\xA9\x03>\x91\xE6\n@o\xC7\xAF\x18\f5~\xFD?\xD3a2\xCD\x07\xF8\xC6o\x9AbE\xDB\x1AD\xDDd\x90\x1Fmv\xE3\xEE]\xAE\xD7\x978;\xAC\xCB\xA6P\xFD\xD2\xA3xG4\xCF\xB5\x1E\xBB\xD7Y9\x01\xCA\x06\xF5?\xFF-~\x0F\xFEn@\xDD@\xC2\xC5\xDF\xBE\xE3y\xBB\x92\x03>\xCBr\xEC\x97k\x01m70+)\xEC\x97\xBFf\xB3\xFF\xF6\x97\x1E\xFA\xBA\xE0-\x85\x9C\x0F\x8BB[\xFF\x923\xA9\x17\xC5\xF1\xF7T\x8E\\\xEC\x920\x16\xBE\xE0\xFC\xB6\xF5A\xD7\xFB8\xCB\xB1\xBD|\x8B\xCA\t\x7F\xB7\x8A\xAA\x84\xC5+\x80\x8B\x98\xF6\x05\"\xB2_e2\xA7\x8B\xEA\xB2\xEB\xB0\bHs>~\xE6/a%;\x9C\xB4\xFFF`\xD6\xAE\xD4\x03P\ver\t)\xF0r#\xE6}\xB2\x81\xAA#\xF0\xF7\xD1\xD8\xE92_\x14\xD9\xDA+\x0F\xCC\x1C\xC0\xE8zN\x861-G\x92^\r\x98\xA9\xFC\nM\x9D\xF9\xF3o\xD1\x18Q\xCB\xCF\xD1\x00\xA3\xE2hW\xA2\xF8C\xB7zMR\x95#\x86\xB9$\xBF\xE2U\x9F\xCB\x01\x7F\x0670\xB7\xBBwZ{\xE1\x8B\xCE\xE9k=\xCE\xF6\"g\x90X\xFFT/\fM!?\xDF\x11n6jO\x12\x91\xFD4\x83Z?\x80Y\x92\xC5\nr\x87\xF8\x8E|\xE7)\xA6\x7F\x9A[s\xFA'96\xF6\x00E\v_\x1Cg\xB3\x95R\xF5\x89\xF1\xFB\xBD=\xB8\xF8\xD6\xDD\x18g\xD0/\x01\xAC\xEF\xA9@\xEB\xE06`UZ\xFF\xDC\xF8\x8C\xE3\xD7t\xAA\x86\x99q\xB0\xEF\xCB\xF9\xE33\x80\x7F\xE23y\xBB\xEE\xE0\x7F\xFE\x99\x9D\xA7]\xE7\xB7?\xADMs\bd.\xB5\xF4\xFAg\xB5\\\x1F\xB0\x9EK<g&\xA4\x80\xA9!?W\r\xB3\x1D\xA7-\xFF\xE0\xE4\xEB\xDA\x11\x8A\x12\xA5\x94W\x9FC\x9Bu\x8A\x9D\xF6y\xBD\xB9,\x8FT\xEB\xE2\x7F(L9x;\xFC\xB2\xAB\xB1\x97\xFE\xEAN&\x92s\x16S/\xA4\xE6\xE2\xFF\x9C\x8B\xFB\x80\xA0\xAD\xFC\xC9\x14\xC2\x1Dl\xE7\xBF\xD2\x11\xED\xA8FpR\xD8zo#8\x86Q\x16\fq\x12bt\x01\xC1\xBB\xBE\xC5?%\xB1&M\xB56\x8C\xB8x6\x04m\x91\x14\x8B\xD50\xFA_g\xB4\x18\x1C\xFCr\\Tt\x95\xBBx\xC3f\x86W\x05c\x18}Z\x86\x9E\xEE\xA1_\xDF@\xF0\xAE\xEF\x03\xC1rjg\xDB\xFE\xFAS/\xDE\x8E\xA1\xAA\xDB\x16'\xA13\xD9\xBF_\xCE|\xC1\x04\xDE8\xCC\x8C85\xCE\x18Z\xC3\xCF\xB2*\x8D=\xA8n\x02\xBF][\\m\xE8P\xC2\xE8\x7F\xE3\xF0}c\x18\xE6\x8F5\xC2o\xE3M\xB1N\xCD\xB7U1`\b\xFEk\x9AI\x13\x0E\x01F\x8A\x9Eh\x88\xA2r \xCE\xC2\xB9Vpq|\x84?\xD1\xF1U/q6\x16\\\xCCg\xAB\xC98V\xBD\x18\xA3;\x8D\x03\xDAd\xF3qy]Z%\x0E\x99\n\x7F\r\"w[\x97M\b2\xDB\xF8[,\xE7\xA2\xA7\xD7Q-\xAD\x05-#\xC3\xBD\x8D4\xC2A\x89\xD0\xB8z\xABBl\xEDb\xA2\x12\xD3\xC5\xDD\xE98tY\x18\x99<\xE0tD\xA6J\x9C\xCAH\xA39\xA8\xC7\xE2\xB0\xEE\xBA3C\xE5xE\xCE\x9Er|%q1\xDF\x05~r\x86%\x88\x06\x19/\xD3\xA2\xBF\x0E<*\xE0Svw\x1Af\xE0\xAEt\b\x16\xB3La/[\xCC\t\xBF*n\xE2\xC7Z\xDB\x1A\xC99W&\xEB?\xA1\xB9\xAC\x95\xCCs\xE1\xCF\xA3T\xE4\xCCmt\xDD\xB2\xED\xEB\xCB\x11`Z\xE6\xCF8\xBFl\x86\xBEh\x1BP\xCCo\x03\xC1\xF6Z\x8B\x89#\xA8\x85\xF1<\x07\x7F\r\x18\xE2&\xAC|=\x96\xD1\x9Ef\xFC\xD3j\xE1A0\xDAd\x8D\xA3`\fX\x1D\x13\xD9\xB2]\xC32\x8B\xEE\xE3Y\xB1\x9C\xBC&-I\xB5\x8B\xBFw\xD7.\x8F\xE3\xF8\xE1\x84\x8B\xBFa\x9C\x86U\xD2%^|\x153\x9E\x1B\xAE\x19\x05\x86\xAA\xEE\xBB&+^\xC0\xE51@23\xEBQ\f\xADfF'\x91\xEF!\xBA\x83\xD51\xEC\xC1jF\x91\x8FI\x81\xBF3U\xCCH\x9Dz\xE6\xBE\f\xC6\x801\x8C\x1Eb\x14&\xE9\xC5\xDF\x183w\xD0\xE3c\x98Q\x82\x1A\x8C\xF8\xC8\xB3\xB6\f\x84\x94N\x15\xAB\xE4(\xE1ol`\x94\xF0\xB7\x8B\xE3\xEF\xCBG\xB1\xEEt\x12Xe\xD3a\xEFp\xFC5\xC8\x81\b\x84D1\x02\x8Bicy\xF8\vY\f\xF8\x02\xC7\x1A1\xB2\x00\xE4jQL\x85\xEB1T\xAB\x97<h\x06\xBC\xF8\xCBx\xF4fq+2\xF0\xB7\x0Ez\xF1\xA73m\xB8Z(\x1E#\x8DoX|\x17\xEB\xAEt\xBB)^\xC0\xC2vj\vJ[\x02\x16c\bS\xB4\x83N\xADG\x8AbF7\x19,%R\x0F\xD5\xA1\xB45\x81\xA8i\xA4\x93(c\xC1v\x98w\t\x00{\xF1g\xC1\x7F\xA4\x91\x1C\xC3\xFC\xB1\xC8'R\xCD\xCF\xDC\x98Sn8s[\tC\x1C\xD6\x9D6\x1D\xDB\x1E\xE1\x82\xBDM\xF4<)Nc>\x7F\x01\x8DbQ\x88\xE3\xAF\x1A\xC1yG\xBD\xF8\v\xB6\x93\xFEK\x01\xC1y{\x86\xC1\xF5\x9F\b6\x87\xD1\xAF\xF0\xB7\r\xA8\x12\xBA\xCE\xE8>\t\x01\x81\x8F\xC7Oy\xF5_\xBB'l\xF5\xF8\xEA\xDB\x80\xB4\xF8\x01F\x07\xE1o\x12\xC1\xDE.\xE1\xBB\xAB\xB2\x8D\xF6\xE15\xA7m\xA4\xAB\xEE\xDB\xD7/\x9C\x99so\x07~#\x0E\b>\xCA\xB5\x9E\xD1O\x85zF\x0F\x0F\n\xFD7E\xF8;#\x95o\x06\xD9\x81\x84\x91\x1A=t\x1FQ\xA81\f\x1FB\x01\xFEN\xC2,i\xA6\xE5\xA2\xD7I\x99\x13\xFE\x06\xD2\xC6\x04\xC8\xEF'\xD7\x82\x16\x1F\x1D\xE6\x87\xA5\xD7\xBC\xC8\xF1gMr[~\xC7Q\xAC9\xD8\xC0qOe\x9E9{\x12\xD7\x8D\xCD\xA0\xFF\x1A\x1C\xFC\xD9\xB7\x9B\x94%\xA4rhL\xD5\xE3\xA5\x0E\xA0Z\xC5\xC5iDJd\x8C\xE7`u\xC0!\xEAy\x894>\x83e\bC\xB4]L*-\x00\x10\xFE\xDA\xE9\x88\x8B\x17|\xD3&\xFC\xD5\x99\xF4\xA8\x98\xC7d\x99bZ\xB6)c9\x11Q0b\"\xA4\x9FO\xD3\xF2B\x17\xE81\xFC5\xEE\x12\xF8K\xF0S\x91\xFES\xF3jqL\xE0\xAF\xD6\xD1\xD4B\xFFY,\x81\xCD\n\x7F\xF4\x1C\x87\x9A\xCB\x98\x96\x84\x85X\x12>*\x9B\x87\xE0\xED\xCD\xD0\x13qz\xDE0`5l6\x99H*\xCD\xA0\x05y\xFA/\x18R\xFA/xM\xFB\xB0\xD2\x7F\x1Db\xFE\x15\xEEV\xF2\xD2\xC6\x14\xFE\x18\xE9\xBF`I|D8\xE0\xC5.G<\xF8;q8\x18\xC7\xB0\x9A\x7F;\xA8u\xF7)\x81?>\x83U\xD9\xC6\xD8\xBB\xCF\xDEfc\xF8\xF0\xF2]q\x91D\x1D\x89\x81\xA3D\xCE\xBFo\xAD\x1A4\xFA)\xDA\xE67\x84\xE2u\x1C\x07|\x9C\xBF\xE9\xE0\xEF\xBD\xD51#>}xy\x06\xEF\xB2@\x12o\xF2\xDB8\xE9\xAE\xEB\xADj\xE2_\xFD\xD7\x1C&\xFCM39\xFFv\xBD\xB5&m\xBC\"\x15\x99\xC0\xDF\xBE\xF8[\xFC|'\xD7\x9C\xA6\xFE\xE2\x1C\x7F\x81\xC5\xBB\xB1\xE6`\x86\xF4}?PbLM\xB3`Z\x84\xE1\xACG\xA0TP\xC8\xFB\x11hG\x17\x02!t\x89\x84\x8A@[G\x92J{_\x1A\xA3\xA2\xCDz\xA7L\xDF\b\xC4\x81\n&\xF2h\x9F\xFB!\x02\x1C\x9C\x81\x95q\x11\x80 w\xF1\xFA\xFD\xBA\xA3\xD18\x92I\xD9\x93\xBB\x03\b\f\xE31\x16\x18\xE9\x02J\x86\xF9\x11zGwO\xC0F2\x15\xBD9\x8B\xD5T3i\x10\xE8\x12\x07\x04\x92H\xA5\x12z\x17-\xFE<Nk#\x151\xC4\xB1\x9C\x92O(\xED!\x10\xC7\x81dB\x8F\xEF\x8FF\x93\xE8`V\x15z\xF8[\xE8A@\xF9)\xA3\xF4\xD5\xFF\xCB\x14\xED\xDC\x05\x95\xB3\x92J2\xFDk2\xAE^\xFC\x19\xEAL\xF1\x17\xD0\x13\xED\xCD\xF0\xD3\xA7\xF8K\xBE9\x85h*N\x8D\xEF\xF9\xD7\x89\x8E$+Y(\xAE\xDB\x82\xE0\x97\x1D\xFC\xED\xE6\x12_A\xF8{\x0E\bN\xEE\xE1\x9A\xF0 \xAA\xF8\xDB\xA7\x85\xB7\xD5\xA2P\xF2\n\x90\xF5\xC5\xF1\xD7\xFA:\x82\xFCT\xC1\x7F\x95\xAB\xF6r\xFE\xCDx\xF5\xDF\x9A\xD3\x191#\xCAT\xA1\xE0B\xBC\x85\xE0\xC7\xF9'\x93c\xC3\xD8s\xE2)\xBE\xCB\xD3\xA3\xDF\xF3\x8C\xFB_\xCB\xF4\xDD*\x9Cy\x86\x19\xF7\x12\xFEN\xACI\bwu\x86+A\xBC\xC3\xEF\x99\xAE\x96~\xDA6\xFA\x87\x9F>\x9D\x14\xF3\xFE\xDB\x87\x85u\xA8\xE6\x8F\xD5\xA2b\xA0q\x98v~K\x85kw\x9Dy\x8A\x19\xC7\x00\xEB\x16@\xE8q\xEB#Cg\xF8a\xD3\x03\xA7mn\xA4\xF6\xF6\x8Bx\xAE\xD5\x1C\x7FUL\b\";\xCA\x82Mj\xC6>\xBF\x9D\xDF>\xB8\xCD\x9F\xEF\xBE\x85-\xC8\x86\xF0\t\xEB1\xCC\xF7f\xD6\xEA\"\xF6\xA4\xA06\x95\xDB)\xBF\xA0g\xBE\xBBs;\xD9~\x11\xBF\xF7\xC7\x98\x87\x91\xFAMf\xD3\xA7\x90\xEBj\xD5\x9DL[2-K\xE1\v\xD1\"\x9B)\xBA\xF8i\xB1\x86\x0FV~'\xD7\xBCD&\x93t?\x92\xCA\x18\xE2\x1A\xE4\x04\vN\xB6c\xC5}_\xEE\xC4'l\xE0\xC4\xD3*\xD6\x8A\xEB\xC4\xF8o\x98\x13X\xE4q\xCCq\x06\xB9\xCA-\x87\x1A\xA3\xF3\xBDs\xC0u\xF4\x1Dcs&\xBB\xB9zu\xD2\xFAD\x17\xFA\x87\xCEp\xAD2Ts\xDA\xC61Q\xBC\x02\xB2&\xE5\x90\xD3\xF5\x83<\xAD\xD3\xAC\xE8e\x9Ce\xC1w\xE2B_]\xF1\x9B\x0FX~e\xAD\xEB\xCB1\xC0\xA07\xAA@\xACG\x85\xE1\xE5\x03\x92\xCD\xB0^\x0F5\xC3\xB2\x81\x8BZ\x132R\x8C\xE3\xAF\xF9BE\xCE\xA29\xA8k'\x1BI=n\x13\xD9p\xB6\xE3\xCD\xCD\xA0\x86\xA1\xA1\x99\xF3\xCBH\xAE\xE30\xB2\x973\xD2\xB2V-C\xDC@\xBA\xE7\x17\xD9\x82\x047\xBB>\xB4R\x04\xAB\xF0\x03h\xA1f\xB1\xA4\xAC\xAD\xCF\xFC\t\xE0\xEF\xA4\x13W:\xC2\x826\xDE\x175\xAB\x83\x93\xDDXy\xF0T'\xCDt\xA7\xAAHBV\x13\xE1\xAF\xDB\xC1\x9F\f\xA7tX\xAF\x07\x7F\xEB\x06\x81\xD3l\xCE\xA4\xC2\xDF\x9C\x06\x8C`\xCEd\xC4E\xBBJ\xFA3\xB2\xEF\xF1S\r\xD5\x9Cn\xA0\xB1\xD0\xED\x82:\x1F\x7F\xF0\xA79\xFE&e\xF6\xCF\x15\xA7?`\xFCY\xFA\xFAr<\xC6T\xB2G\x90i\x19\xD1S\xA9\x14HF`\xA5M\x81\xBF\x8B\x05\xAF\b\xEC\xA6t\xB8\x88\x83\xBF\xE5R\x7F9a\xC9.\xFE\xB8\xDA\xF4\x03\r\n\x7F\x06\xF99\x93Y\xAE\xD2\x94\x87((\x9A\xA6n\xE6\xF8k\xB6:\xD6g\xBC\x80\xE3\x847\x0F\x7F\x17\xB0`\x15\xF6\xD3\xD0\x80\xD6\x00\xF8\x1E\xFE\xC0\xF17\x9AA\x9F\x83\x8847\xC5O\x81\x1AF\x05'\xB3Xy\xF0\x9D\x14V%\xFE?\xF6\xDE\x06>\xCA\xEA\xCC\x1B\xFE\xDF\xE7\x9E$3\x13\xC8\x84\x18\n*\x92\x9B!1\x93\x89\x1A\xA4\xB5\xA2&\x93\x01\xB1\x1D\xA2[b\xC4\xAD\x8F\xEBO\xB2>\xEDS\xEA\xEES]\xFB\x85\x1F\r\xA7\x14\xED\x10\\\t1(U+c\f:\x99(\xB1\xDAZD\x99D\xB7\xB5Y\xDA\xB7\xBA\x96v}X\x17\xC7\b\x1A\x82\x92\x18A\x86I\x9C\xBC\xBF\xF3q\x7F\xCDL\xB4\xFB\x96n\xE9\xF3r~?\x86\xC9\xDC\xDF\xE7\xFE\x9F\xEB\\\xD7\xB9\xAE\xEB\x7F\x01c\xC2|\x95\xF2/\xAD\x07e\xAA\x11\x1B\xFE\xA2\x16\x1Aj\xFE\xDB\b<\xE3a\x13\x7Fi:}|\x05\xD3\xC3Z,n1@=\xCC\xE4_\xD7\xE0\xC5\x87\x1B\xF1+\x18\xF8c\x06/\x83\xA3\x05\x7FG\x05\xFE<Wu\x88\xBC\x93\vG\xFE\xD2\xF2\xEF.-\xCC+\xF3\x84\xF5E\x98\xA8\x11\xEA\xD2X\x02\xCF[\xCE\x00\x1B\xB4(\xFBAB\xCE\xA5\f\x7F\rF\xA9\xA3\x80u=\xD8\x8E\xBF|^\x16\x80DM\n\x02T\x00m1'\xCD\x9A\xC0\x83a\xB1\x18\xA7$\xF19j\x9ETF\xBF[\x00|\x16\xC3\x9F\x13JR\xE2OY<\xF4\x97\xED\xBFw\x98b\xDDG-\xF2/*\x82`F\xA8\xE7\xC14\x16\xDE3\x1E\xC3E\x1A0(\xF1'\v\xA8\xBF\x87\xA9\xE4\x9F\x1D\x7F\x93\xD43\x1E3\xFD\xC4\x1F\xA3\xE8\xDE\xF8\b\xB5U\b\xE0\xB38;ixx\xE7\xE1(\xFE\xDD\x94\x7F\xCC\xE0\x182\xFFd\xA6y\x82\xE1o\x92\x16\xF5\xC4x\xA8\x00.9\xDC\xF6\x97\xED\xBFX\x0F\xB3M\xA9\x9E\xD7\xB1\x9D\xBA\xA9\xF0\xAEw\xC1}C'\xCE\xDB\x1DK\xE3\\\r\xCC\x04\xE5\xB3r1\x93>\xA4\xE9\x11=\xC1^v\x8Ed\x8Fj\x86\xC8\x1D\xE1\x8D\x99\xA01\xEA\x8E\xE9\xA4Z\xEE0\x1E\xA3\x85\xA9Nv\xB5\xA8EF2k{1@\xD2\xBB\xFC=m\x88\xCApp\x19\xED\xD0k\xE10P\x12\xF8\x19\\\x1A\xB3\xD9o\xD9\x0F\xB8V\x01\xE75\x8C\xFEe\xFBol\xC7o\xB7\xF0\x98\x04!\x87\xDF2\bK\xDE\xA5\x9E\x07\x7F\x83\x8B{\xC7;q\t\xB3%\x9F\xD73\x05\x18\"\xF6\xE9\x11R\xBA\xFE'\xF0\xE7\xD9\xA2\xAF\xFF\xE9\xD3\xE7QZt\xE8i\x13\x7F\x13\xB4h>\xC7\xDFnKX\n;\xCB\x1A\b\xFC\r\xE1]\n\xF5\x1D\x13\x7F\xA3\x94\xDB\xE2\xE2\x04\xB31L=\xCC\xB2\xF6<\xB8S\xB0O]2\xE2<e\x03\x9Dj\xA7\xDA\tk\x96\x1C\\%\x98\x9BL9\xCBQL\xB3\x88\xB5\x94\x8CT\xDF\xA0\xE9\xA4\xD6,\x16s\x9E\xE5T\xC1\x8C\xBB\b:\xDD@P,\xAE\xB3\xDBh$\n\xDB\x8BX\xEC}\xCD\xC8L6\xCD\x7F\x1A6nH\xB3pq\x19\x81\xD4\xF3\xA5\x1B'\xE4\xCC#'\xAA\xCF\xD6\xE9\xC1\xB9\xEA\x1EQU\x83\xCD\xAB\xCB\x98\xB0\xDC\xCF\xB4\xB4\xFF\xB4\xD4\xC71V\x84=/\x99\x911?\x98\xC8\xA0\v\x99\x9C\xAE\xB6\xC9T#\x1E68\x9D\x9Dt\xFA\xDBI\\\xECy[\xF6\xD3\xE7`\xB0T\x95\xF5S\x04jee\x87\x1DU\xCF\xBF\xFD\xD6\x84\xB3l\xE4\xF2\x81\x06\x90`\x89\x13E\x17\xA5\xCB\x99\x810v\x11\xD4\xF8\x17\xD7zV\xDF3\xC8&\xAEIZ\xE4\x03j7\xFA\xF8\xADY\xFAo\x84\x92\b\x06\xE1Y\xAD\x1D\x14%3\x98\xA2y\x91\xBE\xFD\xB8\xB8\xBE\xE7\x99\xD6\x03'\xAA\xFF\x94\x85\x80\xB3XL\xA4\x82b\x02\xBC\xCAg^#\xCA\xA8\xDB)\xA3\xE5\x88e\xC1\x80M\xAE\xEBLf\xD5\xE4\xD2\xE5\xF6\xFE\v]\xF0~1$_\xF0t\x9F4\n?\x7F\x9E\x86\x7F\xDF)\xEBs\xE2M^DO\xCE\xD3I,)\x17\xA5q\x14\xC7\x97\xFC\x8E\x19\xE5\x93\x9B\xD0\xD02I\voO\xAFA\xE1\x8B\ro2\x05\xAD\xDD\xAF\x11\xF7\x91\xBE\x83\xEBW3}\xAD\xA5\x94\xB3\x0EU\x1EL2k\xDCT\xA8\xC6\xF7E\xD9\x1C\xD5G\xDD\x85\xE9>\x11\x1E\xEC\fZ2,\xBDrU\xBC=\xDD\xD7\x978A\x1D\x18\xD2\v\x88(:e\x1D\xA7\x8D)\x18E\x82z\x1A%\xFE\x84\xAARd\xC4\xCB\xBF\x924\r\xBDx\x93\xFD\x84\x15\xF7U$\xD1d\xD2o\xF2\xBB\x9Fyy\x10\xD7\xF5\x0EKs\x86o\xED3\xF07Y\x9F\x10WI\r\xEC,<\x94v\x96\x8D\x8C\xBF\xD4\x00w\xD0\xB9\fE\x8B\xD3K\x98\x8D\xF8\xE1N\x8D4\xADh\xDDxU\xD1~\x00\xEDk\xF8\xBD\xD4.\xD78\x19\xB3\x8E%G[x\x84\xBA|8\bO\xA3&\x1D(\x1C\x7F:,\xC6\xFBe?\xC7\x0ETh'n\xFC\xE6\v\x9A\xAB\xBBe\xE1DG\xB1\x88y\x7F\x9E\xBA4\x89?>\x06Q\xA8\xC7{\x97,6\xAE\xEE\x19\xDF\xDDi\xC7_\xBA\xB6\xA6X\xAF\x14\xCB\x94\xA2\xB9\xDC[\xFFr\x12\xC7\x1ExL\xC6\xB2\x1FeG\xAC\xE2\x87\x15_:\x8A\xC5\xE5\xCB\xC5\xFB\b\xAD\xE9I,._SZ\xDE\x19\\\x03\xCFxr\x92\x16&\xD7\xAD\x01\xC3_uB\x9D\xE8\xEB;x~\xB2\x97BI\xF2LQ\x94/\xE3\xF8\x93\xD9\xDF@\xDE\xEF\xD2QZ8\x84n\xB8\xDE\x9AxLRs\x15[\xA8\x81c\xE2\x8B;\x16\xEF\xDB\xDA\x7F\x82\xC6/\xD1\vP\xA9\xAFIv'G\xB1(&\x163\td\xCE\x17*\xB6\xCE\x86Sf\xE2\xCF\xE9j\xC9\xA0\xDB+\x9FY\xB1\x00\x12\x93yz\x8D\x9B\x99\xFE0V\xF4\xE8\xF8\xBB\x86\x1A\x04\xD7\xC5K\x8A\xB1\xA6\xFC%~a\xA5\xCD\xEB\xF7\xCE\x9Bp\xCEz\xB7\xB3\xC5\v2\xCF\xE7\x85\xDB9\xE1\xA5P\x1A\xDB}\xBC\xF6\xDE\xFA\xD0=;(\xC8\xDDk\xB8\xF3\xAA\xE2\xA0\x06T&\xF4b0pw\xAF\xE8\xA5DC\x1F-:\x7FE7\xDC\xA32;\xC40\v$\xFE\nS\xB1X\xF8\x04E\x01\x12f\xFB-\x90\xB1\x02N}\xFC.f#6E\x1D\xC5\xD2\x13\xA7\xC26~\vM&5\xF5`\xEC+\xF6[\xD9}NO#\xA4\xDE]\xB8\x1A8\x83\xDDt\xCD;I\xFC|\xCB]\xB2\xDB\xFBL\xFC\x95\xFD\xCB(\x16\xD7]*\x9E0\x19\xA8\x9B\x9F\bOv\x94\xDF\xFB\x8B\x00\xD4\xB7\xF6\x07P\xD4\xB6.\xC0)\xF3\x9EO \x19({\x85&\x99\x81\x9A\xF2rs\xB3\x96\xC1\xF6bj\x04 \x14\x8C\xA5\x86\x98V\x9F@\xE1\xC1\x89I\xCA#\x84H\xB1\xEE\x96\x15\xB5\x8D\xF8s\xF4\xAC\x1D9Q\xF8c\xE3\xD7\xD3\b\x9D\xE6O\n\xBB5\xEC6\xAAM\x02\xAD\xE9\x82\xA0_\xAF\x85s\xC1\x93F:\xC8\xF4+\xAF\xEB\xB5\xF7\xDF\xC2\xD2\x8A6\x9B\xFCk\x96\xF8\xBB\xAAzX\xBA$\x9B`\xB2\xCC\x91b\xAC\xC1\x12\xBD\xBA\xA3\xB2D\v{+\xF7\xB79\x18\xFE\xCA\xBD@d\x82\t\xE5V\xE7Z\raoqpu\xD8Iy=C&\xB3\x1DA\x1F@\"\xAA\xC1\xD3\xE6\v\x971\xFC1\x10\x86]B\xAC3\xFC\x19\xCB\"2\xB6VI\xB6\xB8\xA3\x91\x13\xD7\x7F.1\x7FxE\rn\xE17Q\x82\x88\xB1\x0F\x91\xB5t~\xB3\\\xC3\x93\x8E\x97%F\x0E)y\xC4\xFF9{\xFF\xBDT^U\x8C\x87ei\xBA\x90\x9C\xB5+\xBCalv\xAE\x95\xA63\xDF**\x188\x7F0\no\xA9\x81?\xDF\xBF$\x92\x01\xEF\x17]K\x19\xFE^\n /\x18\n\xB0\r\xD1\x98\x86d\xC0sg(\xC9\xED\xD5\x00\xBF\x17\xDFe\v\xB8xH\x1A\x06e\xB2\x81\xAA\tD\xA9\x9AH>F\xDDCr\xE6\xF3k\x19\xF2\xAF\xB3\xB3o\xE3\x89\x8A\xE2\x9D\x00<\x1CW\xA4\x05u\tc\x9D\xC6\x93\xB4\x12h\t\x8E\x17\xB7\x8E\xF9\xCF\x9Fk\xA4\x17O\x7F\xF0\xDA_\xD9oe\xCE\xEC\x97\x17\xE0\x9B\xE2\xB7\xFC\xD5\x00/\x10}\xFA{I|\xFD\x99\xF7%5\x17\xDF\xFA:\xDFe\xC1?\xCE\xC6\x8B\x9D\xBF\xE11\xCCj\xFE\x8B=\xE7\x9C\x99\xFF\xE2\xDD\xBE\xDD\xE7\xBCH\xA7\x9D\xB1\xF0E\xEA\xBA\xE8\xAE\x17)\xD4\xFC\xDE\x9E\x84\x9A\xFF\xE2S_\xBF=?\xCA\xFE|\x91\x93\x84T\x0F\r\x00\xD5\x9A\x9A/\xAF<\xED\xCC\xFC\xCDt\xDAl\xF4\xD2ig\xE6?G\v\x9D\x92^!\x93w\xCB\x1D\xBB/\xFAT\xF3)s\xE9T;\t\x9A\xD7\x05\xACs\x19\xA5f\xF5\xF2@\xDA\x9F\xDFV&\xA2\xC4\x8B \x19t\x12XJ\x8EZ\xEDi\xA7>Md\x9D\x81f\x19\xD4\xE5\xB9\xAFe'\xE0\x92\x84\xB1N%\xFB1\x9D\xC6\xD9\x1C\xA6\xA1m\xDD\x9Auw\xBC\xFF:\x06\xE1~4\x8D\x8B\xFA\xA1\r\x02j\xEB\x1A\x14\xFD\xB7\xF4\xDF\xC3\xB2\xFF\"\xA2\xFF\xD6\xB2\xA9\xD2Z\x05\xC3\xD5o$g}Z\xFF\xA5\xB3\xFB\xCF\xA0\xAB\xF1h\xB6\x0F\x91\xED\xAA\xEE>j\xBApDt\xB9g|\x00u\t5\x8DZ\xAA\x8A,\xA11x\xBE\xF9\x82\xA8\xFA\xC6\xFD5\xB5\xFA\xFE\x93T'\xF0\x9D\xAC\xE3eL=\xA9\x15\xF0\x07\xD5t/\x05\x89/\xCEAJ{\xA2\xDB\x1Ax\x9E\x1F3\xD5\x9E5e\xFD\xEAp\xCAR?\x94;X\x98\x90\x16\xF7\x9C]\xC8C\xD0=\xEAS\xA7\x98\x99\x8FY\xBBT\xD1\xE3\xE8\xB9~\xEF\xD2\xF4o\"\xF2\x914\xDC/h\x80\xC5.\xBCcc-\xA8\x00\xF1\xA2\x9C\x12\x91\xA5\xB6\x95\xBAf\xB0wBn`\x1F~T\xEA3I\x98\xB2\xF9\x92\xB5\xAB\xDDAe\xC5~J\x1E\x8D\xA3>\xA1`\x90B\x1D\xFAo\xC2_\xE8a\xFB\xF8m\xF5\n6l\x13\x7FT\x7F4d\xB3\x84[\x88W,l\xE29\xFBO\xB3}8\x84\xB9\xD9\xF2#\x91Jl\xED\xBF\x06T$H\x80\xD9$\"\xF5h3\\\xC7?\xC7v^\xC1>\xCE1\xEB\x8Cn\xA4z\xF6\xD8d}?\xF62\xFCu\xC1\x1FT&\xFA(\xC8\xCE\xFF\x0E\xFCMR\xCF\xAFGE\xFF\x05\"\xBC\xDC\xB3:<\x9E\xC1\x91\xC2\xF1'\xD9\x04^\xCF\xC6\x9F\x95HH\x04p\x1E\xA1S\x8F\xDFE\xFA\xB7|\xE17\x1D\xF8\xC0t\x81\x89\rE=\x03\xA8\xD3\xD4A\xD4\x05\xD5_\b\x85\x92z\x94\xC3l\xE7\xDF\x88\xF1kp\r%\x8D;\xF5vD\xD4\xCE.\x9A\xD7\x94\xC6\xB9\t\x84c\x14d\xF8!\xEA\x8E\xFE\xB9\xFB\xAF\x04yU\xD7\x8B\xF1;3\x018\x8B)\xEE\xF1R{1X\x81\xBF\xC4\x14\xF8sY\xC7\xC8N\xFEY\x93=m\xE8\xF4\xF0\xDC\xCBOV\x8B\xF4\x1D\xD6Z+\xA9(\xB5\x03}\x83\x9A\x8C\xB3\x93\xC6\xE1\nJ1\\C\xC9\xED\x1C\xC5<\x95\xF8\tS\xE4\xD6P\xDD\xEB\xCB$^r\x92\x16\x0E\xAF\xC3\"(\x13L\xA8\xBEp\x8C\xFE\xF9\xD9Q\xAF\xC2\xF4{\x9BD\xD9\xA9\v5\xA0\xC6\x05\xB2w'\x17\xD9f;\x87\xE1\xEF\\\xC1\xA2\xB5*\xEB\f\xE7Z\xF0GD\xA0\xC8Om\xAA\xB8\xEE\xBBS5\xDD\xDB\xCFM5\x19\xF9\xB8\xE7\"@\xD1\xF1\xC7'\x03\x12}\r\x9E\x04\x86\x98\xC9(\x12x~\nu\x19\xBB\n\xE1\x1F\xC3\xE6J\xC2\xC5\x14\x10~4^4\xDFI\x89w\x02jBY\xE1\xA1@y\x07\xC5\x9F\xBD\xBAh;\xCD\xBB\xF2F\xD6\x7F\x7F\xCB\xF1\xE7# k;3\xAAP\xF1@\xE1*\x11<\x92]\xEE\xA5\xCA\x82?2,]\xB0\xD6\x1D\xF4\xF9\x85O\xB8\x82\x97\x8A\xC9,\xC1\x8FD\xBA\x1E\x01\x14=\x96\x84op\xC7\xDAQ\x05\x12\xC3\xB9A\xC9N\xDEK\xDD\xFF\xA3V\xAFtE\xA2\x82\x9C\x0E\"\x89Z\xFAa\x03\x1E\x8A$\xB3\xF8B\xF0k\xCAD\x8CBi\xF8\xAE\xB9\xD4\xF4\xE7\xD3;\xE1\xF2_!D33\x9B\x17\xCD\x81J\x13\x06\x9D\x98h\x8B\x8C\x0F\x14e\x9Fa\x91\xE5\xBB<\xEC\x80m\x07\x1D,\x9C\xA1]\xF4\xDF\xCD\xD0\x03\xEE\xC9\xEEN\x9A\xD5\x7F\x0F\xB1\xFE\xEBBU\x90\x880\xBA(u\x07\x132p\x9Bu\xACO\xB7@\xB7S\x10\xC13\xFE\xE2S\xCDj~/\x9Dv\xFA]\xA8N\xA8\x7F\xCB\xC3\xD9\xC2\xB4\xF0\xCF\x8E\xBF\xB3Q\xD8\xF0\x1A\xBB\xAB\xDF\xF0\x81\xF8\xABG\x13\xA4e\xAB\xA1\x15\x88\xC6\xD5\x05\xA13\xB8\xB2\x05J\xA5u\xFC\xB6H}\xC3\xDA\xA7:\xFF\x8B\xC7\xC8\xF0\xB0\xD4aS\xDB'(\xD4gm\xFA\xDF\x99\x83\xA8O\xA8c\b\x04\xA5\x1B\xFACxn\x9Fk\xF0I\xFF\xD6,\x12\xF6\x01\x85\xFA\xF2)\xE3\xEBT;9\x1A\xD1\r;g\x0E\x7Fm0\xA7R0\xF5\xA9x\xD6n\xD0\xF2g\x86\x1B\x95'\xD9\x96\xE6\xE58\xD6\x8C\x8Ev\xDB\xCE\xC7L\x80\xE0\xA7\x97b\x12\x93\x86\xC6\xADho\xE6\x83\x906\bG\x9F\xD3\xD1\xC8NH)\x99\xC2-]l!\x9E\xCE\x91\xD3\xCC\x0E\xA3\xF3\xEC%\xE8\xC6\x02\x82\xB0S\x1D\xC8\xAC+X?2n[\xA9\xF6\xE8\x8C\x9A\xDC\\\xCA\xAC\b\xE3\xB9\x19<\x9Ayr\xC7\xC6$\xAF{#K\x9B\xF2\xFD\x14M\xAA\nl\x97=G3\xEF\xDDs\xB3%i\x88s\x81\xF0(\xD6\xB1\xFA\x84\xDA\x05x.\x1D@=Sg.iV?\x126\x9EI\\h\xB9\rO2\xF8E\ne\xEE\x92\xD32\x16\xD8\x1D\x9AL(\x9Cu0\x89\xA5\x00\r{\xE5r\xF9\xEA\f+\xA6\x8D\xFDf\xF6\xCECY\x13\x1F\x10\xAF(\x1C\xB4\x96\x86\xD8\xFA\xE8A\xE1\xC3\xBDmkFw{\xBB\xDD6\xC20]\x8E\xB7\xF1\xBA\x8C\xE5\x19{\xBB\x8A\x99\b'M\x9B+\x0F6\x8A]\x04\x87\r\xF7w\xC8\xA7\x94\xD3D\x16\x19\x86\xCB\x89]T'\xA3\x16\x8B\xF3\x15A`k,B\xD2\x80+\xD5\"\x96\xB7}\x11\xB2Tl5\xCB1\xF8\xCD!\xE2~$9J\xA1\xBE6V\x97\xB1\xC0\xE9IbD\x98-\xCB}<\xB4.\x99\xF2\n>dSc\xE7\x11M\x9C\xB2\xEC\x07f5\xE4\x8Cj>\xE0F\xFA\xE4\v5\xD6\t\xAD\xDD[%&\xF5+\xD6g\xEC=\xFF`*\x96\xF1\x94\xE6L\xB7\xF5\xF1D\x96I\xB0\x99\x19Nm]\xEB}b\x97\x07\xA9\xD1\x7F\xB2\xB3Ih3\xD3Z\x1E\xC8\x1C\x17\xAE$\x1E\xA5\xBA\xDD\xD8m\xCC\xB0Gk\x12L{p-Y\x81\xCAf\x1E\x98J\xBE#\x9C\xA2\xE7\x19\x17\xAF6\xB1V\xF8\x9C\xB3\x8D\x82\\\xBBu\x9B\x96ukO\n\xFF\xF2\xC1$6\xC3\xD1\x1E\xAD\xEC\xCB\\\xD9\x11\xCB\t1\x80(\xE5\x19\x9A\xB9\xD9z\x99\x85\xDB\xEDj\xB0\x1AJ\x93}#\"\x98{\xF8\xA3\x8C\xC7\n\xF4\xCE\x8Fe\x8C2\xDE\xB8\xE9\x9A\x8AG\xB2^2\x1B\x97\x8DG\xEAG\x1A1D\xF5\x9AM\x02z\xB2\xF6\x85\xA8\x1F\xF5\xC6pf\xFF\x15E\xF11-\x92\x94.B\x8C\xD4F\x80\xCD\x17\xF3@9\xCF\xF8G\xC2=zq\xBF\xFA\v\xE1\x140\xA35/6\xF1W\xD4\x9D:F\xA1\xEE\x19\v\xE4\xC0\x1F5\xF1W\xF0\xE1PJ\x845Z\xF17\xACS\x87\x1D7X\xAA\xD4\xCC \xC3\x14\x85:|\xBCn\xA3\xB5\xFF\xFC\xAD^\xF1\xE2\xE3U\x19{\x17\x0E\x1E\xBF-Sz\xF2\x97Oe)R\xBBl\x8D2\xCBPMW\x85\xD7J>-\x19\\\xC9\x1EP\xAFV\x1C\xAE`\x1FWfM<\xAF\xA3\x02y\xD21'|\xC2\x9E\x040\xB91\x81\x0E\xC01\x14\x13\xD6\xFB\xF4\b\xE2\xC2ud\x12\xB1{,Dy\xC7\xA7=\x04\x90o\xDD\x9F%Zt_~\xE52\x89\xBF\x98\xF0\x01\x99UfED(\xB3+\xDC\x8F\x98\xF8{,\xE3>\x99\xE9\x11\xEB\x8D\xDDh\xED\xD7\x9A\x8D\x878\xFE\xC8`\x863\x1B\xCE\x1F\xCC\xB3\xE1O\xAF\x96\xC6\f@\xF8[3\xF0\xA7jx\x9AB)_\xB4\xF1mM\xD8\x07fG\xE8\xAC\xF2$}!3\xBB\xBF\x9D5\xAF\x85Q\x87\xBCQSH\x8B\x15\xD2\xB5\xEE\b\xD2@~\xF0\r\xB1p\xE7\x8C`\x90_\x1Cg\x19#\xD4\xA4\xF0G\xC1\xE5I\x86\xBF\xBD\xA9\xCC\x00\x15\xC3\x97U7\x12\xC21\x8E?\xC1$\x94\x85\xBF!\xC0\xF3h:\xF3\x81-\vG\f\x7F\xB5\x1B\xAD\v\x1AO\xFBcB\xFE\xC5\xBB3\xF6\xAE\x19>\xEE\xB7-\xBA\xC9\x9B\xE6Tn}\xBD\x99\x9E)\x11\xCF\x7F\xF1\x93\xDD\rI\x11 \x10\x95\xA5\x9D\x01|VH)\xD2\x19a\x06\xD1\xD5\x99\xF8+L\"Fu\x9E'1C0s\xFD\x95\x9A\b\x93\x7Fy\xA9N\xE1\x07\xAB\x89\xF0\x02^\xB6ZL\x96\xC2>yC\xBEF\n\xA5\xA9\xA94\xE3\xFD\xE4i\x10K\x103/[\x8D+\x01\xDA\x1A\x13\xFD\xE7\xB6\f\xC4\xA8\x8E\xBFe\xE5S\xEA/~\n\xEC\x9CW=h\xE5Q{,\xD6 \xF0\xD7\xF9X\xC6\xEEU\xAD\xEB\xAF\xB5\xF5P\xD4@1\xD0\x15\xCD\xD8\xDB\xDD\xCC7$\xA2\xB1\x86F\xD1u\xBD\xB2\xB4\xB8i\xC2\x92\x17\xD8\b\xD8\xFB\xE5\xAC\xE5\xD00vR\x9D\xA7m\x9Bq\xAB\x8B\xFC\x11\xF24\x90\xD7\x10\x17\xD3\xAC\xBF\x9Ft\b\x92*\xB3\x16\xE2y\x96\xF1\x1B\x1A`\xF3G\xE3\xD6m\x19C\xC3\xD5(\xEF\xA5bY#:\xA8g|xB@4\v\x7F\xBC4\x98\xB1\xDC\xA8\xBE\x93C\xFE\r\xA6^\xD8h\r\xFEO\xF5\xD5\xC8d\xA0\xE3Y\xF3\xC7\xF8om\xC3\xC0g\x9C\x058\x9E5H\xA2\xFC\xF4s'w\x8D\x84\xC5pI\xCA\xD2\xF6\x00\xCE\x97I\xE8/\xB1]\x9E\xFD8k\xFE\xB8\x06\xEFQ\x8F|\xAB\xF2\xB0\b\xF0\xAB\xBEfu\x1F\xE0\xF9\x0FQ\xC3\buT\x1D\x94\xB5y\xCDh\x7Fs\xAE\xF5\x1C\x9A\xFD\f@\xF6=}^F\xFF\x19\x16\xFD\xB9\x87\x92\xF89@\xEF)_\x9B\xE5\x99\xBA\x07\xA2\xB0\x14\xB9=\xDF\xF8mK\xE6\x88\xA4\xC0]\xE7l\x18<\x15|}\xAA\xFD\xE5\x9BS\xB81\x15be\x93\"\xBA\xE3\x95\x96\xC3\x91\xD4\x07\x1A\xD16\xD8\xE9\xA0\xC3\x86\xD5J\xA5\xC9H\x00\xC2\xEB\xCD\xB0\x99S#k\xB3v\xD6f53\xEB\x98\x04\xA9\xF7D\xDC=\x8FR\x96\x14Hp\x84\xD7\xCD\x13?/\x9D\xE1\xB0'#[\x1C\xC9\x9F4\xEC\xB2\x8B\x0F\x13~z\n\x07\xD1)\x98\x9D.\x83mK\\\x97\xFB\x17\\K\x92z\xD9=\x92|\xC8\xBB>!\x1C\xAFi\xFF\xC6\xC3a\x9D\xD1\x90\xCC?\x82<r\xB3i(\x8A.\xA9t\xF1?\xC9\xF8\xD9\xDC\x96\xF4\x8A\xFE\x8B\x005\xED\x96*@\xB2\xC4@M\x97\x06\r\xB3\x964\xA6\xE7\xD3\x13\xD3\x7F\xEA|\xBD\xF8p\xD1C\xEB\x84b8w\xE9\xA6o\xAD\xE9{+\xA8\xEB\xAB\xAE\x94\xF3\x1E\xF6b\xB9\x8D\x13\xAE4\x8D\x15\xD7\x0E\xA0\xB8\x9F{\xD3x\xD7hV+\xB5\x92\xE9\xFF^\xA7\xB7\x18^J\x96\xAE\xA5$\xC1m\xD3\x86Vm}\x12\x90oJM\x8B\xA0\xE5\xBA\x1AM\xF7<xz\xF6O\xF2\xEE\tP\xB5\xED\xA8\xAF\xEB?\xF4|\x17\xCF\xAD\xBBQ7\x126\x8CB\xE9\x80J\xF6%\xD4~\xC0\xD3\x9A\xE2i-\x93}#Iap\x8C\xD5\x1F6_\xA8\xDCy\xEC\xC2fe\x02\xFE\xED\x87\xBAR'\xA0\xFB\x94\x89I:=\xA5\x97\x16R\xDEN\v\xFFo\xF5\xC8%\xF7\x045^\x18D\x94CZ\xE6\\\"\xD6\xEA\x1D\x1A\x96\xB7\x9B\xB8\xCC\xF3q\x1A#\xC8I\xCB$\xA9v\x84\x80\xD2\xF2\x1D\xC0i\x07\x8E\x07pZB\xF9\xD6\x12\xEA\f\x82iF\xE7\x04g\xEDo\x04\xE4\xF2\x04_\xACf\x1D\xEE\x0E\xE9\x85O\xDD\xB1\xB8\x97+T\xFE\x04I\xC7z\x0E\xC7t\x1AL\xE2\xFD\x19\xF2\x88\xD4\x13\xCD\xAA\x95\x951\x8D\xB3\xAD\x8Eog\xB6-b\xB1\xD6F\xA1\x91\xF5\xB6W'\xAD\xDA1W\x1B\x1F\xD1\x10\xC5\xAC\xCB\x9FN\xF7\x9E\b\xFC\x85\x17\xC3\xD1\xDE%):\xDD?k\x12\f\xD9gU\x0F\xA7\xD6\xF4\x1Dh4\xEC\xA5P\x8B\x9E7\xAB\xA1\x98\x98\xFD\xA7\xF8\xC4\x0E\x1E\x19-g,\xA98\xB7\x00\x95\x8F\f\x01\x8E\xF5>/\x1C\x94\xAC(\xA3y\xA3<n\xCE\xB9\xF5\x91eI\xA3d\xB6\xFA\x12j\xFB\xF92UR/\x96\xE494<\xD9\xC7\x8BHE\xD4\xF6Qwt|X\xC7\xDF\xF80\xEA\xC4\x1A\x06\xAF\xCA\xA4\xE3\xAF>\xC1\t\xB8\x9Bn\xE1\xEB\xE3\xC7\x04\xFE\xFA\x81\xD4\v\xDB-\xAA\x95,\x97\xC8\xEB\xBB0\xFC\x1D?\x11\xF2/\xBC\x06\x1E\xCE\xF2\xC5`V\xB4K\xF6_^\xF9&G\xD0\xF7\xC3\xA4\xB1\xE8\x18r\xCA\xFES\x92\xF0\xFC\xB0\xDF\xD6\x7Fj\xC2\x88\x041\xAB\x95:\xB8\xB9\xC4T\xBA;\x93\x01\x14$\x94\xEF\x10 \xC8\xA3:[.\x9ByY\xC8\xE8?\x12\x11n,\x7F\xABn\x1E\xC2\x1D\x8B\x89\x84A\x7F\x84\xEC\xED\xED;l\xF0\xF5\xE6?\xFD$\\n\v\xFE\x84a\xB7\xDD\x82?7E\xA7\xDF\x1F\x05wT\xF5\xFE\xBC\xC7t:J\x87LO,\xA2\xAC\xC0\xAC\xCBw\xEE=\x11\xF8S\xD3^8R-R\xF3u\xF4\xEC\x13\xE3\xB7~\xE4\x92\xF4\x9A\xED\xE6\xB5\xA7mp\xFE\x12\x9C\xD9w\x9A\x86\x97\x16\x9A\xF8\x9B\xBEJ\xAC=\xEC\xD6\xE3J\x8D-I\xC0\xF1D\x14X\xF8b\xB5\x17\v(J\x7F\x8Di\x11\xCC\xA5Pg\x97\xDD\xF9\xF7;\x80\xCFJev\xBF\xF0\xEF\x07zW\xEB\x85w==i)\xFF\xFA\xD5gS\xED]\x06\x8Bt\xE1\xC1\xBD\xA8\x97\xEB4\x83f\x05\xEC\xD4\xAE\x04\xBB\xFB\xA2\xA6&\xA0`\xB5E\xFE\x8D\xEE\xFA\x122\xF17V\xA9)i,\xFC\xC6\xDB\xE1\x13\x82?m\x92z\xC4\xFC\x11\x07\x8A^\xE8\x10\xF3\x87\xFF\xB2\x7Fs4i\"&_eh\xFA\x913Du\xF9\xB7\xB4\xDD\x14\xCAy;\xC4\xD2\xC6\xA5\xB2\x9F\x8D-\xD3\xC2\xC0\x85\xDB|@\xE9\x93U^\xCC\b\xAA\xA5M4\xEFU\xBCJ\xA1\xF8\xFFu\xE1\xDF8y\xA5&\xDE:\xC4\xFC\xEB_\xA2\x19\xF3\xEFPGL\xCC\xBF\xFD\xD8[\xF3\xC0\xF6\x1Dz\xD5\x1E\xF2\xE80J\x1A\x92\xE6\xFC+&\xE6\xED\x1B4\xF6\x8DW\xB5w\x0F\xC0\xB7\xDE\xDB&\xCC\xE4\x9A\xFB/Mf\xEA/5[\xFB\x95\x15(\xFB\x97k\xB6\xD7\xD0\x131\x7F8\xE1\x12\xF3\xC7\xEB@\xDE\xE5\x12\x7F\x17\x1E~>\xDD\xDE'J\x88)\xBC\x92\x853(g\x92f,\xB7\xF4\x9FC\x13\t2WP\xE3O\xB9!\t\x94~u50\xE3\xCE\xE3\x01\x94hJ\xF9\x126\xA6W\xB2\xB7\xB0\xAC\xE4\x97I\xC8\xE27P\xB7\b\x9F\\\xA0W\xC3\xA8\x8E\xBF#\x93\xF1\xA0\xA8!\xDD\x9Ez|\xFF\x86=\xC6\nF\xBB\x1D\x7FbH\xA6^\xE8\xE7\xF8\xDB\xE4\xE0\x91\xBC\xC9\xF8\x97\x9E\x12u\xAAGwm\xB7\x94\xC5\x17\xCB\xB8\xC3k\x99\xD8,\xFE\xD2U\xD1\xD4\t\xD1_\xD6\xC0\xE5eoF\xF1\x03\xAEe\xA5\xCBt\xFC\xAD\xD8\xE4\x131\xD6\x84\x02nB#\xF2\x1B\x10\xB1\xAC\xBB\xBBeY\x89H\xA6\xD3\x85}\xF3\x89\x0FB\xE1\x03;Aa\x12\xFC,\x11\xB1A\xEE\xF9\x8E\xD4\xFF\xBCI\xCC\x93\xF8\xF3=\xE6\xE7\xF8sFp_M\x84\x9Au\x91\x99>)\xBD\xEE\\3\x16]\xE2\x17\xF8#\xBB\x99\xF2<\x80\x9A\r\xF3_\x07\x9C\xCD@\xCDf\xAF\xC5\xC6\xDEi\xAC\b\x84Q\xF6R(]s\x82\xF4?1~\xB9#\x9C|E\xAC\x9E\x7F\xBE\xA1\xFD[\xB5\xEB^\x99\xAD;\x86])\xDD\xB3\xECJ\xDA\xD6\xCC\x99\x9A7?a\xB8\x8DM\x1F\xB3K\xCF\xEE\xAA<\x98jA\xA5pM\xF3\xFDH\xCB\xD6\xC7\xF9\x86\xC4)\xDB\xEBT\xFBK\xBB}\x97&\x9D\xDCa\xB7\xD6\x12\xDD+\xB0\\l\xAE\xD7;\x89\x92i6j0H\x91\xED+\x8C\xBA\xC2\xA7(fR(\xCA\x89\x02M\xE6\xEB.\n\x02\xC4\xA5\x9FO\xD8\x92\x84\x1A\x91fA\x19\xA5L\x94~8\xF2\x88N=\xB9\x1E\xD4f\x9B\xF2\xE2\xAF.\x8B\xD7r\x87\xB5\x0E1\xBB\xB7\x9C\xE6a\xA6\v9\x97\x1F\xD9\xB1:\xCB vNq\xAA\x8D\x9Dk\xBD>\xCC\x1F\x8A`e?\x88\x1B\xDA\xFAT\xCB\xD6H\x84\xB4l\xAC<\xD8\xD4\x82\xF9l\x9C{\x87R-\xED^_\x8A\xEDO\xF4EYf(V\x0E5\n\x19\xB1Q\xA3<\xD0u\x94\xFD\x16\xE1\tew`\xDEA\xAD\x05\x95Cc\xB5?~t\xE8i\xDF\xDAy\xAE$\xEE\x9C\x97\x00\xFAz\xFE.\x89\xB5\xDE\x04qr\t\xB2\x9E\x8B\x91\x9A!oZ\xC8\x1Cv\x07?\xA6N\rk\xE7\x81|k}\xCDP\xAA\xB8\x8F\xC9\x9C\xAB\xDEr\x06\xA54\xE3\f\xC3\xE5\xD4\x1E\xFF\x97W\xBD\x8F\x1B\xDF\xF3e\xE0\x1D\xB9\xDE\xFB\xCF\t\xE9\"\x1E7{\xD2i\xF68\xF7\xFA\x92E\x19\xF3\xF9a^\x95\x1D\x81\x91\x1D\xB8\x9C\x1D&\xDE\x82\xCB\xE2hVZ\xCCS\x85\xDA\\\x1F\x1FF\x89\x03h\v\xB2\xE9\xBD\xA4k\xB1s\xE9\xAC\x84\x12jl\xEF\xDA\x04\x14;\x8A\x81Y\xEB\xD6;W\xDE\x7F`\x13S\x12\x94%0\rE^X\xAAx\x9D\x86\xA6Y\t`\x19/\xA3Q\xBA\x8EMh\x9A\xB2\x023\nR\r()\xDFT\xBE\xA2\xBD\xC2\x85\x95\xF7\xEF\xD7\xB0\xF2\xBE\b\xD0p\xD1\xFF\x8A`\xE5\xD6\b\xBBZ\x04X\xC9\x8D\xD1\x92;\x8FG\x81<'P\xB6\x7F^\xE9R\x9A\x97\xC4\x9A\xFB\x13\xCA\xF5+7_V\x95\xBE\x91B)\xF7_\xF5\va\xCD\xFAEmJ\xDE\x89\xF5\x16C\xF6\xFC&n|_L\x15n\xCB\x92\xA6%?\xD1\x83\xD6\xDA\xCD\xFE\xB3T\xBF\xF7\f\x88\xE5^{\xFF\xB1Y\xFCf\xC0\x1D\x8D\xE2.\xB3VE\xBD\xA9\xD7D\x88\x8C\xD8\nD\x00\xCF\x0F\xF7k>\xCC\x7F+\x89\xEB\x83 N\x94\xAFO\xB6\x9C\xD1E\xD1\xE2\xD9\xB6lG\x00\x05o1;o(\xD9R2/\xD8\xCC\xE77\xA3\x96\xB3\x0F(H\xB4\t\xFC\xD5wr\xAA%\xD7j\x88#\n\x12\xB8\x03\xF3\xDFZ\xD6\x025\xF1tm\xC7\xA3C\xA3-.\xA5\x8A\xE1/\b\x94\xB6_\x9B\x04!\x11fL\x05\x81\xD6\x1Fr*\xD1\xB7\x9A\x86\x05\xFE\xF2\xAA\x92-.fV\xCD\xAC\x00nk\x7F\xFC__\x8D\xD5S\x90k7\f\x86d\xD0\xB2\xA8o\xCA;q\x86\xA5\xBCR\xCF\x1E\x1E\xA2:H\xF3D.\xDE\x91{\xE7\xF17c\xEF?\xA7\xC5O\xC2\xF6sf\xF4\x1Fy@\xE0\xAF\xBEWR\xA17\x18n|\xFD\x05H;@\xE4\fP\x9A<\x8C\x12h8\x83\xE3\xEF\xB4\x03\xA1\xF2\x82\x92\bB\xA4\xA4\xEBU\xAF4\x0F\xBB\xB4\x062\xEB\x7Fni\xD1\xAB\x0F\xE9\x86\x0Eg\x9F\x9A\xB1\xF4)\x940\f\x950\xF5\x1C\x0E\x1A\xE4u\x92V\xA0d^\x9B\x1F$\xF2H\xF9\xDF\xB5W\x84\x9C.\xCF\x81F\xAC\xBC?\x01\xD4\xB7\xBD\x13AYk\x02i\x9E\x95w\xFD:\x1E\x95\xF7\xC8\xF1\x9Fr\x07\x0F\xF2\xF7\xB7\xF9\xCB\xA8\x9AD\xD5\xFD\t|\xE9\xFA\xCD\x97\xAD\xBE\xC2\x05(\xDF\xB8\xF6\xCB\x07\x845\xBBB\xE4@\xF2N\x9Ca\xC1_\xD55\xDC\xC9W\xCD\x89\xDF\x00r\xCD0\xF7@\x9D\xDD\x0F\x8C\x9B\xFD3\xB7\xDF>\x94=OeH\xB5+d\xCA]\xFF\x02|\x93\xFD}\xB9\x88X0\xDE@i\xBFr\x85\xD4\x10\xFB\x81W~\xFE\xDE\x06\x1F\xF2\xDE\x8Bb_\x90\x99\xD7d\xDE\xF3\xD7\xEFU\xFA\xD5\x967\x7F\xF8\xD6\xBD\x01|\xF6\xFD$\xF0\xF9\xC8x\xCB\x9Bk\x7F\xF3!\x87\xEDu\xBA\xDD\xE8\x03.|\xAF\r\xC8\x7F+\x847\x19\x86\xDE\xA4\xCA*\xE0\x82\xF7\xA3\xC0\x85\t\xB5\x05\xEA\xE1\xF1\x00.|?\x19(\xF9\xE1[\xCF\x07\xDE|\x9A\x13\xA2S\xE0\xB5\xD3Kv\xE0_\xEB#j-\xB3*Q\xC8\x8B\xDA\xD4\xBF\xDF\xF8\x1E8\xE7\xF8\xE7\xE6\x8D\xDF\xF1KLk\xC3+\xEE\x88\xFA\xAD\xC2\x82\xB7~\xF7\xF4+\x14\xB8\xD6u\xE7b\xE1\x98;O\xF4\x1F\xFF\x98a\x91\x7FU+8\xFEb\xD4\xF3*\xEF\xBF\x15d\x1B\xEF];\xFE\x16Z|\"\xB9\xF0\xA70;\x80\xC9\xBF\xDE\xA8(\x93\"\xC6o\x9E\x05\x7F\xE46S\x14,\x9B\xB1\xF4\xB8\x1F\x17\x94'\xD1\xD8\x0F\xB5\x05\x9F}\xDFUr\xE9\xE7#\x8A\xBFa\xC1\xDD\xDD\xA5(\xA9\xF0\x01%O\xCC\xF3\x85~\xB2n\x1E7\x92t\xFC9\x9E\x02f\x96\xB7\x01\v\xEE\xBE\x19\r\xAC#\x9A\xE8\xF4W\xD9o7\x03\xA5Ti\xC2\xC2\xF2M~\x94l\xBB\xFC\xC6\xFF\\\xF0\xCF.\xEF\x92Y\xEF'\xF1\xE6\xD3\x11\xE0o\x7F\xF2q#\x96\x97D\x14/\x1F[\xAFmf}Pz\xD97\x9F\x05\xA6k@\xD9{W\x9E\xBD\x92:F\xD1t~\xBFr\xFDk?;\xF7\xD6\xEB\xAE\x06\xD4o\xBCv\xCB\xB9\xC2\x9A]-\xA0'\xF0g\x9D?^\xE3\x8Bg)\xAAr\xF9\xA7\xBE\x96\xE2\xF1\x1BLJY\xEA\xC5\xCC\xB5\x8C\xDFP\x0E\xF9\x07\xBF((\xE4\xEC\xF4!\x9FJ\xEB\xC5:Q\x95Ft\xF6\x1Fv\xF7W\xB4\x97+_\xC2\x8C\xFD\x1A\x13EJ\x03J*\x8E\x9F}\xC5\xA6\x88\xE2o\xBA\xFF\xC0\xB2\x00N;\xE0\x03f\x95\x1FoX~\xDFW\x8F;\x8D\xEAM\xA2j\x1Ef\xEEO\x02\xB3\x0E\x84q\x15\x1B\x97+)\xFBm\xC6\x81(/Bs-f\xFC\xF2'-(\xD9v\xEB\xE7\x9B\xEE=p<\xB0\xB2\xEDN\x1FB\xF7&\x80k\x9F+\xDD\x82\x86\x8E\x88\x12\xE0\x16\xE4\x15\x9B\x19\xFEf\xBD\xDC}\x8E\x98\x94J.\xFB\xD1u\xCB\x90\xB7\x05\xFF\xEB\xBE\x88\xF2\xAD+6o\xBB\xD2\xFF\x15\n\xE5\xDA\xE0\xAC\xFD\xBC_\x94\xF3d\x1A\x16\xFB\x9C\xD1\x9F5\x7F<F\xF3\xE4\xFC\xB1\x81\x07\x1By#z(\x97\xF1\xD0\xBA\xA8\v\xD9\x16\xFC\xCCE\x0E\xF7\xCD\xC0\xDC\xDE\xA8XMIe\xCC\x1F\xF5\x11\xEC5\xE7\x8F\x88\xAF0M\xB9\x9D\xD7\xD7\xCF\xBA\x9A\x19{\x11\x9F0\xF1\b5\r\xC0\x88\xCF\xED5\xDF\x86\xDD<dg\xA1l\x9C\xB0?\xAB\xFCAN\fM\xE1\xF7\x93\xB0~,\xA1\x9D>\x874<#\xE7\xA7\x80N\x1F\xBF\x1Atc\x94_\x8D/9\xF8\x1AH[DZ\xA9\xE2\xD8W\xB9\xCD\xD97,\xC2u\b\x15]\xC7=\x99\xD3-\xCE]\xEFu\x80\xE3fT\xF3\xE9\x13 \xD7\xA5jX\xEFz\xFB\xF5\xDC\xF7L\xF9\x97\xC7\xF6s\xE6\x90\x7F\xD3\x83\xC0\xC2\x97\x16\x88Z=\x1B\xC4\xD9\x8D\xC3\x1C\xFD\xCA?\xCAW\xD1\xCF\xC3\xA7H\x8B\xB0\xF3\xF8\xD4\xC6\x8C=\xFE\xDB\xD6\xC7\xB9\xD9\xA7\x1B\x80\xE2O\x98\xB1\xC9\x16\xF3P\x1A\x94[\xA9\xF9[B\x9E\xCA<v\xEB\xE3\x87\xAC\xFB\xC9\xEB&\xF4\x00.\xBE\xB3<)3U\xF5]\xC4\xB1\x14\xB6\x9B\xAC\xCFix\x92Wy\x8D\xCD\x85\x82\xDE\x1D\xEA\xAB8_\xB8 x\xBC\x99\x81?\xCBT\x1C\x14\x8C\x9Av\xF9'\x83\xFC\xE7n\x8C\x88\xC3\xC4\xB1\xA7\x9B\n\x10\xD5\xEB3\xCD=U\x05\xE9T;)\x9B\x83I\xF4\x9C\xE9\x1F\xAA\xCCV,\xF9\xA3\xCE\xB3\xD4a=e\x86k5(\xEDk%\xE3\xCA\x14\x0E[\x91\xDD\xA0nlR\xC9\xA4\x90a\x8B\x92\x1C\x9E\xDB\xC7\xE1it\"/\x02\xB8\x15\x9B\x91K\xEC\xBE]\xDE\f74_\x91s\x96\xEA\xD1\xDE\x86\xFD\xBF\xE8\x93\\\xC4\x9E\x1D\xB9\r\xE8\x92F[|\xB1.\x1E\xA4\xED\xE2H\x00=4\xD7\xB1F+\x1BI.=R72 \x84\xE5\x11x4[n\xA9\xE7\xD2\xD7P\xCB\x84O\x9Dg\xB5>Azn\x1F\xE6\x89\xB7G\xAC\xF7'\xAC\x89\x01\x91\x91[\x97\x00\x0EQ\x91\xC9*K\x96\xEE\xD7\x97v\xF5R\xEFE\xFF\xB1\xEF}8\xC6\x07\x04\xEB\xFD.\xCE\xE2\xAB\x07U\x0F^(\xE4\xDD?ML\xC6\xA9\x9A^S\xF6\xCA\xF1\x89T\x81\xF0\xED\x1Co\xF8.\x852\xE0\x9F\x13T\xDE\x80\x93*\xAF\x02\x05\xB7v\x02y\xB6\xBC\xE33\xDF\x95\xFDw\x13\xE5%\x82s\xA5\t\x16\f@D\xCAz3):t\xA2\x19\xA6;>\xFD\xC9)\x86y\xE4\xB4\xF4\x17\xDBx\x10\xBC#\x88\xE5p$\xB1\xD4Z\xF7\xF0\xD6\x12^\xE6\x033\xF6\x87\xA5\x91\x04G\xA8\x03\xA7%\x94\xB9!\xEB~\xBC\xFF\xB8\xB2\xA3\x04\xB8\xC2w=u\bM\xE63|\x87\x95\xC6\xCA\xFB\xEF\xE5\x85ol\xF7\xC2se\x00\xA5\x1A\xE0\xDFd\x16\xDAd\xDFDL\xAF\x87\x06\xCB\xC3\x14\xB1e\xC4\xBD\xC91_\x10\xE18\x1B\xFC\xDF\x07\x88\xF3?;\x83\xC4\x81\xE2 \x99\xCB\x7F\xD3\xB9\xBD\f\xF4\xE9\t\\\xEB(\x8F;\xF2\xE4\xE8\x03W#0\xB3\xD1nm\xCB\xF1+\x99O\xFD\x11\xA6\x99\x7Fb\xFF\x95\x8D\xB4\x85\x92\"\xC6ZI\xE2(\xBB\x905\xB7\xD4\xF3hZ\xC4d\x05j\x1A3\xF0\xB7\xDFZ\xDF\xD4c0\x1B\x053\xF1'\xBC\n\xF2\xA4\x9E\xD5X#\xBF\xFD\xC7{#t\xFA\xED{pI\x90'\xC5\x02\x07\xCC\xA0~\x11.\xE6\xD8T\xFE\xD3\xDE\x04\x19^S?\xF2hzB\x10\xE1x\x96\xED>\xCE\xFDy\xB5A\xF5\x17\xA8\xD4\xB8G\xF6\xD7\xC3@\xC1\x1D\xD6\xC7\xAA\xAB\x91\x83\xEE\b\x15\x81\xBD\v\xB2\x1F}z30\x8B[7\x99\x14;\x8A\xD4\xBD\xFD\xFD\xC0\xFCl\xE3\xD1\xDAf\xFA7\xA5_\xFD\x19\xE7[r\x85\xF0{f\xF1\xBDa\xAD\xFBzI\x93\xA8Gz\xC1\xDF,\xD0\x8BMM'qf\xFB]\xFF{\xEB\xBD\x88\xF1{=.\b\xAA+p\x81\xC6\xB4\xE1\xE9\xC2\xC2\x101\x80o\xCAc\x07\xB0L\x1Eqc\xD36\x14^\xD5\xC2\xAB\xA6\xC4~\xC6\xE3E\xA7K5yR\xE0\x8FD\xC2_k\x8D \xBE\xAC\xA4\xE1x\xF9WE\x10>\t\xB5\xCE\xE3\xC4b\xAE\x04:\xE0\xA4L\x1C\x92P,\x937\xC0\xD9)=\x12\xE7P\xCE4\xE0\xC9\xC1\x00\\\xF0*P\xDBhT\xE5\xCC1~?\xCF\xB5\xFAO\xC4\xDF\xE9\xEFo\xF2\xFF\xF4\xC9\xE9\x03\xC2I\xF8\x1C-\\\x00kw\x17z_\xE3\xB7\x80s6\x84t\xBFs\xE1\xED7\xE0\x9C\b\xE9\x7F\xCE\xD2\xCF\x85\"\x86\xE0\x178/B\xD2<\x1C5N\v9\xFE\x88\xF0\xAA\xCA\x84\xD5\xC2\xD5\xFA[(\xBC*=I]\xB7\xEDA5\xEB\xDD'\x13\xC06#\x19|\xDB\xE9\x02\x11\xB4\xF8\xE3@D\xEDZS\xF6J\xF7D\x9F\r\x7F\xAF\x85\xE3A\xF5\b\xCA\xFAya\x10\x8E?[\xFF\x05\x96\xCB\x87\xFE\x88r\t\xEC\xF0\xE5\x18\xBF!\x89?\x7F\xD6\xF8\x95\x91\bL0\xC6\xA9\xE7\x93\xFA\xAF\xD8\xB7\xA9\xA1}\x1B\xB7\xCF\x15'\xDA\x99P\xB0f\x96\xB8\xBC\xD7\xA3\x82r\xD5y\xB5\xDE\x7F\xAE\x92\x00*\x82\xE4\xFA\xFB\xAD\xF7r\xB3\xB4\xB5\xCA)Y\xC2WM\x1F\xA5\x82\xEDH\xFA\xE3u\xCF\x0F \x8B\x9B\xBB\xBAW\\\rO\xD3\x8D\xBC\xDCK\xF81\n\xF4Q\xDD~\xED\x13\xA1/\x9E\xF1tEa\x02ig\xC9\x92\xAAr=\x88\xB2!&\xF0\xE7\f\xA2\x03^\r\xAD9\xF1\xE7Z\"\xFB\xA4B\x14-\xCF\xD5\x07l|\x946\xDB\xF2\x03\xF4\xF1{\x859\x7F\xDC\xF8i\xF2oSztWMX/47\xBD\x11{\xACr\xED\x92\xD7\xF0\xF9~.P\x06t\xF97\xFD\xF6N\xD4'\xD4\xD7\xAC\x8Eu\x91\xB5\xAF\xCAJ\xFCL!\x18\xD4\xE5\x9F\xC0\x9F\xCCb\x9A\x9E\xC4\xD7\xA4\xFC[\xFC\xD0Up\x8D\xB7\xF0\xB0\x8A\x91]|\xA4\xE8\xC5\x87\x87\x05\xD6\x94\xC8\xAAo\x9F\x11Q\xC2k\xCA^9\x7Fb\x8D\xE8Sw\xEB\xDAn\x80t.\xF3\x07I;\xCA\xFA\xC9K@aC\f(\xB4\xF5\x9FO_\x8C\x88R^K\xD7\x99C\x86\x15\x8C\x02\x95Ai<\xDA\xF17\xA4\xAF\x82\x01\xF5\xBC\xFC\xD8'\xE1\x8F\xB4m\xF3\xB1\xFE\xCB\xE3\xF8k\xC3\xBD\xD6\xF7\xE8mB9{=\x15U!+\xFE\xCA\x83\xA4\xE9\xBE\x8C\xB9\f K\x05\xFE*)\xC3\xBD\xAB\xD8\x82\xBF\x87\x8C\xC8\x9F\xA0\xFCv\xBAc\r<\xFE\x06>\x7F\xAC?\xBB\x1Fx\xCEH\xAB{\xAE\\\xD4\x91h\xEB\x8An\x8F\x90\xB4\x93\x10M['X(\xC8\xFA\x97\x19\xFE:\xFD\xCE :\xE1\x96\xF2\xAF\x13\xC8_`\xC7\x9F\x8Cyd6\x7F\x97\xCCl\xCF\x94r\xFAjW`*\x13\xCFK\x81\xDD\xF6\x04\xBAl\xFC\xFD$\xFDa\xDD\xC8\x16\xA1\xFF\x8D\xC13\x1B\xD6\xEA\xE3\x9E\xF9\xFB\xC4\xFC[7\xB2\xDA\xF0\xDB\xDF>\x88\xBA~u\x9F5\x02[\xEA\x7F\xBFa\x13s\x9Ak\x8C\x07t\xFC\x89\xB0n\xA9Tz\x92\xC6\xFC\xFB\xF7\x13&:'\x19\xFE\x0E\x1B\x92\xE6\xF0\x8F\xA8\b\x87\xF1\xFA6$\x10\x9E\xEC\x1B\xF9\x9F:\x11\xA7g\x01\xC6\xD9\x85&\xE3A\x95'\x01\xBF\xC7\xC6\xF9K\x99\x8F\x15\xD0\xB3\xB6>\x04$\xC5\xC4\xA9v\xAA\x9D,\x8D\x061\x0Fd57\x14\xC3\x99\x96\xE2\x14\xCDi\xDA\x95<$C:Vi\xA6\xC5[l\xB3 58\x9D\x19\x8C$\x99\xD7\tN\xE1{\x15.g-\x87Q\x9Dy\xAA\xBB\x01\xE2\x9B:\xDE9\xD8\xFFI\xD1\xD0\xC4tH\xEB\xBEl\xA7\xFD\xD6\xB2\xDA\x9C\x1F\x06\xD1\xF4\xE0\x01\x1Fn93\xA1\xE8\xE95\xF9\xB6\xE7:3\x01|\xD7\xF8\xE5kb\xC9,\x8F\xEB\xE8J\xFCZ^\x17\xFE\xAC\x04p\xCBl\xAADtCQ\xCC\xDD\xAF\x01\xF9\xCF\xBD\x01\x14\xF0\xAA\xF1\x1AV\x95~\xC1\x96\x195'\xA3\xFF\xF2\x83\xDC\xC8\f\xF3KZ\xDA\x19T\xB9\x03s\xEE\x8A\xE0[\xC8\x7F\xE4\xAE\xBF\xC9\xF5v\xE7\x88K+M@\xDE\xBC\xAC\x13\x18\xEDI~z\xCE1\x98\xA3\t?\xC7\x19_\xF0\x01g\x05\x85\x89< \x9F(?\xA8\xDB\x8D\xF66\x7Fh5\x1C78\x9F\xC0\xDAy\x9A\xA1\xF78\x93\x99\xCB\x0F\xEB\x8Cc\xC3\x94Ge\vl\x11?\x0F\xC3\xDE\xF8\b\xFBx<A\x02\xE6\xB2\x06\xDBZ\x02\xB8\xFC\x0Ey>\xA7\x86\x8D\x8F$m\xF0\x99\x9F\xF1\x94\xCE\xB0$\x99\xF2\xDAQ6?A\xBC\x98?\x94\xC4\x0F\xA93\xB6\xA8=\xD7\xA3\xCBS\x91y\x803u\x8E\x1E\xEA\x9D\xBDPBE\x99\xFD\xDCT\x19\"j\xAAr(iD!\xAC\r\xC8\x87v%\xADN)\xB3\xD5n\f\xE3\x9B\xF1\x82r\xA4vi\x8A\x9E6\xEC\xB1A\x9C\x99\xA0\xA6!;*f:\xA1\xA3\xAB\xC3\xB7q\x97\x01\xDB%\xF9\x9C^9A\xA7\xC3\xE1\x95v\xAB\x99V\x1F\x11\xF3\xE5\xE8C\xCBm\x1D\x13\xC8\xB8\x19Ym\xA4-\xD3\f\x0FP\xB5\x1F\xB5\xBD\x11$\xA9\xE7\x99\x81@\xAEG\x97,U\xCA>\xA0`\xFE\xF0\x14+\xD6\xC0\xC1~\x1E\x02\xEA\xC9]\xC5F\xE6\xC8\xB2\x9B\x94\xEC\xE9\xB2V\xF7$-r\"g\xF4\x9D\xBB3\x04\xADpp)\xFC\xEB5\xEC\xD2\x81c3\xF1\x98*_i\x1C+Y\x8C\xE4\x1AY\x8C\xCB?/\xDB\xA5\xDC\xAD\xC9\x805c}\xAD\x1D \xD1N\x91\x9E\xC7t\x9F\xF3\xD67\xD9:\xC6\x9DqG\xC4'\x95,\xB7\x1D\x7FN\x8A8\n\x075T\x80D\xE2\xAE\\\xCF\xA1\xB3T\xF1K\x86%\xAB|\x8E\x05J*r\xA5s\x8F_AE\xE6\"I=g\x92\xB4I\x8E2\xA8;tk'C\xBB\xE9\r\xE1\xBB\xE9\xCA\x10\xC6\xEA\x13\xCA\x9E\x9C\xF8\xAB\xD7\x80\x8Fa\xC5\xDF\x80\x81\xBF4\xF7\x16L\xF6\xB1]v\x05\xA5\xB1\xA7\xAF\xFA\xA9c@QO\xBF4y<7#\xF5\xE3\x95;\xEC\xB8\xCA\xC0_DT\xBB\xC9\xC4\x1F/H\x1C\xD8\xC8\x95\xCAg\x06Z\xE8\xA7\xE0\xEF\x9Bi\xC9J\x9D\xDD\x0E\x04E\xA9\xED\xDCUl\x86e(u\x14\x92\x96\xDEs\xAF\xC0\x1F/\x937\x99\xF3\xBD\r\x86Q\xDE\xD0\x19\xC5\xD9.\r\x1D9\x17`]\t\x9D\xF8V\xC7_\x1C bi8\xC6\xB1\xE6e\xBB\x9C\xED\xA4\x12\x7F\xE7\xE8\x17z\x98\x81!.\xB3\x1EH\x14\xFE\f\xFC93\xF1\x97\xE4\xF5\xE5:\xAC\xC9\xBD6\xFCUR\x12\x8D\x0F|\x12\xFE:\x00w\xB4\x13\x85SP5\xFFM?\xF0\xC6\x94\xF8\xBB\xD8\xC4\x9FdpL\n\xFC-\x9C\x12\x7F\xFE\xD6!Dc=\xC5x\xAA[#\xDB\xF4qe#\x9E\xAA2rK\xE5\xEA\x07\xE9\xD4mD\x12\xE3\"\xF7\xE9s\xD9\x86*M\x96\xFB\xD6\x19\xBD\xC8k@a\xAC\x13p\xBF\xCA\x9EP\xC3\xF6'\xAF\xB5u\xCC\xB9\x19()\xE4\t\x01dO\xE62\xC6\xB9\x94\x84qN\xCF\xCDx\x82\xBA;;\xAF\xCD\xF5\x1C\xE7\xC8D\xED\xDF\xB3\x9B\x8A\xA3j\n\xAA\xDC\xFD\"+\xA5\xB08\xE7\xD6'\xF8\x99\xCFeV\xBE\xE0ow\x131Y\xF5Rw\x04\xBF\xCF\x19\x1E\xD7\xE9\xC4\xDF;_\xFEG\xCCwi\xCA\xBB:\x0El\xE3\xD7m\xA4\xE4C\x86\x911\x1BQ\xAC1\xC6\xF8\xF8\xAD`\xD6fy\xAB\x86Nc\x17C\x18\xED\xE8\xE4r\x8D\x83K\xDB\xB2$\x92)Y3\xF0W\xC5K1\x15\xDA\xFB\xCF\x1DA\x18\xAE%Qf\x12G;C9\x9FC\x00Ny\x1C\xF0\xAC\xEA\xCC\x14\xA0F\xFBu?\x87(\xC9M5\xE7\xB3\xC8?\x11;\xD7\x18\x93\x1BH4\xB7\xFE\x12\x18Y $\xDC\x84\x95PeA\xE6,i$\x14\xE2\xA8\xA5\x9A\x96%\x9DK\xB0!\xA6\xED\xF2\x8F\xCD\xBF\x8F\xA6\xF5\xC01\r\x1F\xC2\xCE\x91W\x97\x99J\xAC1\x8BY}\x19\x19D\x10\xB5|%\xA6F\xC31\xEA\xB9$\xFD\xBD\\\xCFQo\xE90\xF5\x1D\x91 \x94\xBB\xF1e\xE6\xDC\xF8\x13aG\xB5L\xFEqO\r<\x1B^\x96\xF3\xAFg\x91n\xB3\x9Fj\xA7\xDA_\xB8y\xEDf\xA4\xC5\xFB*|\xB3\xA4x\x1Dq\x06)\xBCT\x8Fa&2k\xC2Rz53\xB0\xD8K\xB9\xFD\x92#0\x1A\xD9a\xC7\xB9\xDC\xB2\xB9\"\x93]\xD6#\x826\x9BZ\xE6\x92\x89\xDBp\x90O \xE9rNqI\xE3V\x89$\xA1\xE6\x15\x93\xB2\x86\xB6#K\xD9\xBE\x8A\x16\x98WS\xE2\xDF6\xBE\xAF|\xE01&\xA0\xF2\xBEw\xF5\r3?\xDA\x94\xFEr\x7FA\x10\xDF\x06\x94\x17n@\xDE\xF1=@\xFE\xA8a\x19n\xDAi\x9E\xEF\x06\xF6\xF1\xE5\xFE\xBC\xEF\xBD\x80\xD9\xFAM\xDDDE\x89\x15\xA5\x85\xCB\xAB\x9B\xEC\xC2\xA3\xC5`-1\x8F\xB8\x81\xE6g\x89\xF5\x1B,\xDF\n\x96\xFD\x86[\xD1F\xE3+\xDDB\xC0\x7F\xE5\xCC\x97\x93\xCC47\xCCa\x8B\xFC\x93\x15*\xCDS\xFD\xEF-\x82\xC4\xE4\xB8$T9\xEB\x97w\b[\xFC\x96\xD3\x01\xCC\xCA\x14s\xEE;2\xEF\xEAnj\xB1pI\xA9YW`m\x05\x8F\x99u\xC6\xCA\xB7vv\xA7JZ\xD9~\x1B)H\xF9V\xEAl\b\b\xCF\xA8\xB04\x9D)3sGx$\xD6\xC3\xB9\xB3\xDC\xCC1i\xA5\"5\x854tPa6[[+5LP\xE3\x88\xAD\xD4\x99\x85!\xD3\x81\xB2\x95:\x9B\x16\x02NS\x01\xE7|K\xD2\xE4\xDE\xDA\xE9\xD3\xB0\xC92\xC2\xAC<\x9F\x81\x8CS\xDD'\xD2i\\\xFE\xA6\xFB\xF8o\xF3BQ\xF1X\x1B\xD9\x86\x89,\xFC\xBE\x9A\xF9\xC3w\rJ5\xEEU5\xBD\x0F\x93;{C\x00\n.\xDA=\xFA\xE3\xB9\xF7v}\x93z\xC28\n\xA8\x13\xC3\xD43\xBEG\x14\x9C\xAE\x13\x0E\x99{-\xA4\xC3\xFCv\xBE\xDB_\xF0\xE57\xE4Va2r\xFC\xA9\xA9\xA3\xD40--\x9A\xBEA\x8Em\xF0{\x8F!\x9B\xC1\xD6\f\xE4;\n\xCF\xF8>Y9\xDF2\xF9\xAB\x02h\x07\xEBG\x928Ls\xCE\xEC\xD2\x05a\x9E\xEA\xFD\x9D\xD2\xA7\x94\x12fU\xDD\x17'\xC4c\xA5vF\x80/g\x91\x84d\xE1o\x9EM\x01z\xD6L\xAB\xF2\x87\xB9( \xD8T\xB3al\xD5^/%\"\xC5\xBF\xAB\x86\x92P\x87\xF0L\xB9\xE4\"\xD9:\xD8l\x12T\x04\xC9\x1D\x1D&\xC1\x92\x06\"\xC2\xE7\x1B\xAE\x83M\x81\xE4\xEDz\x93\x89\xEF\xB4\x84\xF9[\x96{\xCA\xD4\xB9|\x94\x84\x99>i\xAAV\xA2\x84\xB60\x10j\xDCK\xC2\xD0\xCCk\xB8\xAD\xF6\xEF\xF6\x8CS}^\xF8\x8F\\\xF3\xAE\xF8\x82\xB4\xC1\xA2\xE0\x16sM\t\x05\xBE\xF7\xE9\xF2\xEF\xBB\xFDV\xFC\rZ\xF0\xC7\x13QQp\xD1/\xC6\xCE\xBA\xFE^\xCA\xF1\x97b\n_\x8A\x16\x1DJ\x8B\xD8\x00\xE1\xA2\xF3\x8C[p\xCE\xB5C\x86\xBFt\x0E\xFC\x8D~\x98\x03\x7F\x87L7\xB4\x81\xBF\x8F\xE8'\xE1\xEF\x18<\xE3i\xBB\xF70l\xE6(&.yE\xE7\xAA\xE3\xED\"+\xFE~\xCA\xFF\xDBm\x9C\xEA\x80Pu\v\xC7SbY)\xF0\xF8\x84Xp\x19\xDE\x95\x00~\x8FO\xC5_Ep*\xFC\xB5vrS\xA1xs\xF5\xFA\xDF%\xD3g\xF7K\xFCEj\xA8\xB1\x90R\xD4/\xF0\xD7\x91\x81\xBFn\x90;b&\xFE\xCA%\x8B\x99\xF2\xA5\xEB\xA8uMF\xB4\x06\xB3$\xABq\xC4\xD5\xF84\xFC\xB5\xC1\xBA\x8B\xA8\xA1%\xF0W\xDF\xBA$\xCC\xA3\xD3\xF5g\xB6\xE2o\x1F\xFF\\c>e\x07\x7Fe\xD365\x8A\xD3\x17\x0Ev\x89\x05\x97\xFA\xCD\x1A\xF0\x0FY\xF8\xCB\x9A\x91\x9F\xA1ns\x01\x91t\x98\xFCW}=\xC3\xACc\v[Zc\xE7\x9C\xD1\xDE\xFE\fu\v\x8B4\xFD\x18\xDC\xC3qQ\xCDH,\xF2\xB8S{\xCC\xF3q\xB3m!-\xBC8\xC6\xE3-t\x93Q8ro{\xCD\xE4t2\xDA^Q\xE9\x8A5\xA3\x94\xCF\x7FZi\xD1d\xDBm\xDE\x1Au\xA7\xE2\x80\xDB\xB2\x80\x135}\x9A\xB1\xDECI\xEB5\xAC\x06\xB4\xDC\xE55\xD3\x84\xBFP\xE0\xEFP\x8B\xF0O\xFB\x1B&\x04\xDDT\xF4g<\xDA!\xE3\x1E\xF2\xB3f\x94\xAF\xDA\xF0\xD7a\xF2\xD7y\xDD\x9D\x9C-~\xC6\xBF\x9D7{\xE1\xAA\xAE\xAF\xB0\xFDX\x7F\xC5\xFC\x948%\xFE\xC4\xDA\b\t?\x90\xB1n\xB6?\x98\xBFb\xA7\x19\xE0\xCDC\xA2\x19J\x96\xFE\x1D\xB2\xF1\xF77&\x90>\xA3\xFF\xD6D\xB3\xDD\xA3\x7Fg\xB1MI#\x93\x7F\xFD\xF6\xF9C\xAE\x19\x9D\xB7~I\xA3\xB5\x92@\xA1\xF5$\xE2N\xAF1\xC5\xFFfQsmS\xF1\xDF\n\x83\xF7\xAE.!\xFF*gj\xD0\x83j\xCC6mE\xB6Ji%EN\x9B\xB2i\xB2oDZ\x9E\x1FP\xCF\x83{\xB9\xB8\x99\xA4P\xFF0F\x85\xF4Y\xA5\x87\bz>k\xE1\xB8\xD4\xABY2\xCBU\xEF\x02\xDD\xD6U\xF7\x1E\xC9!\xFF\x92f(\x88!\xAA\xDE\xFBD\xF97B=\x1B\xF6\xC9\x92\x00VkV\xA8\x01o\xC5k\xC2\xD6k\xD4Z\xE5\x9FX\x0F\x7F\xD7\xD8\xFA\x91\xAC\xD94\x9E> \xE4_\xB3\xFCH\xEEJ \xF72\xDF\xA9v\xAA\x9D4\xCD\xE9\xA5Y\xC6hy\xA6\x8D\xC8\xA5\x97\x9E|g\x9D\x81dF\x886\xB5q\vP\x93\xB9\x99\xDB\xC9\xBC0\xF0\xCD\xC8\xE9K59\xAB\x94 \xFDk\x18;J\xF8\xCB\xFDP,\f\xC5\xB7\x00J\x17\x9F\xCAo\x99u\x99.\x82\xCE`]7SL\x92\x8AEW\xC1\xAC\xC7\x92\xCC\xB8\xD5\xC5\xD7\x99\xCDY\xC6-\xCA6\xDE\xAA\xCB\xD7\xFCMa ?\x8A\xAF\xA2\xC0\xE8\xA7\x02iz,\x17;\xEB\xF9\xB5+7_\xF6\xDA\vSznO\x9EFZZ\xA9\x11\x17\tY\x98\xA6\xE5N\xFE\xED\x91U\xBA\xB2\xCD=n\xDE\x84\xD5\x82\x94st8j\x18\xB720pm\xA6S`x\xAD\x91v\xC3\xD3d\x1Aq\x8F\xC5\xE4v\xCA\x9El\x13\xD6gP\xE6h\xB7>>\\\xFDNv\x04\xF6I\xD7\xD4\xAE\xEF\xF6C\xB5x\x90\x99\x85\xBB\x9BO;G\xEB^\xD1I,/f]7'h\xB5 \xE5J\xEFH\x12)jxP\xEB\x9B\xB3\xA7\xACz\xCF\xB8N\xE0Qto\x077[\xC6\x85\x13XL\xFEI\xAB\xBB\xB5>\xA1\n\x05k\xF2\xB9\xCB\xFE\xED\xBA\xEC\b\xD8\x93\xAF\xA5\xCF\r\xEA\xC5\xBFt\xF3A\xB9\x8D+O\x15n\xAF\xDE\xAF\x9C\xA9\xD5%\x95\xDC\xB8\xE5\xE8\xD2N^\xE3\xA6\xD1\xF4M\xC0\x9B\xC9\x1B|\xB0JG\xAC\x9ALs\xB5\xF1<j\xAA\x9C\x92\x84L\xD7\xC4#\xE8\x12\xF6\x87g\xE4\xF6\xFDf\xB9\xA1\x93\x1C\x7FO\xD8\xCCW\xB5\x9D\x83a\xB2\xEF\xF0\xEBV\xB3T\xC7\x9F\xD5\xAE\xAA\xEF\xE5\xC1\xF5zo0\xBB\xF1X\xC6\x15.\xF2\x8C\xBF\x91\x89?K\xECo\x16\xFE\xC4\xBB\x1C\xD9y\xD9k;\xAC\xBC\xD8'-\xFE*\x82V\xCB\x88\xE3\xAF\xBCJ\xD8\xBF^\x1DW\xB3x\x1D;\x89\xBF\xC3\x96\xA3K\x96\xB41\xFC\xE9\xBD\xC1\xF4\xF6L\xB3\xC1\xB3\x7F\x93^\xA0[]\x95\xE6Y\xCE\xE7!\x1B\x7F\x9A~\x82\x98\xC4\xDFc\xCF<f\xE5\xC5>Y\xE7\x8F-\xCFP\xC1\xA6f\x9A\xAF\xEA\x1D\xDC\b\xEE\xED9\xA4?\xE5\xF9A@\xAF\xFDC:-\x87_\xD8\x90D\xA7i\xAA\x9E\xD7\x9Ce\xDC\xC2\xDF;~\xBD>\xBC\xDBc@\xE1\xCD\xF8\x195]\x8AnkIdT'$\xA9\xDBd\xEC\xF2\xE1\tk]\x80\x93\xB5\xC5\xBE\x12\x04b6\xF3U\x89\xD5\x8B@\x96%\xBA\xD3\x823-\xCF\x91`\xD8i\xC5\xDF\xA3\x8D6\xFC\xD1\x8C\x12v<\xA8\xE6\x11\xDD\x01IF_\xE0\xC1\xF4\x15:\x9B\"\xCC5\x14\xBF\xCE\xF3.\xE0}u\xE1/6\x95\xC3u\xD2\xAB\x80\xEAoa\xAFY\xF7\x11\x85z\xE3\xA0\xB0\x7F\x0F\xEBS\xAD5\x04E\xBD\xCB*\xFF\xCE\vY\x97\x8A\x99\xDD\x98\xCE\x9C\x7FG\xC6\xF5\x92Z\x9E\xC2\x97\xB8\xD9|\x84\x16\re\xCA\xBFa]\xFE-\xE4\x7F\xFE\xFB\v5\xE3\xE9L\xD7\xEF\xA9v\xAA\x9Dj\x7F\xED\xCD\xB3\xFA\x8F\xDA\xAD\xEE\xFF\xA7\x04s\x96\x05\xDEc\xD4s\xFB>Q}\xB7n\xC4\xF8v\xF0\xF2}\xC7\xA8g5\x8E\xEDJX\xF7;\xB6+\xA1J\xFEI\xDEu\x155\xAB\x8D\x9ET\xC5\x11F!\xDF}\xFC-XN\xB0kd\xB5\x88\xD4\x91'\x18Y\xFDW\xFB\x02,\xD3O\x07u54\t\xE7ZE\x95\xF1\xAD\xE6\xB6\xA6\x0E\xEA\n\xA1\xC3\xA8\xD0\xC3\xF7\xEB\xD8\xA6\x91\xA6\x0E\xC1\xB7\xC4\x19\xAD\x0F\xEA\x11\xF0\x15|\x83K\x12\x9B\xC8\x0F\xFB\t\xB6U\x85\xC0\x8F\x95'\xA8\n\xC9\xB3\xFC_\x88\xBF\xA1\xC2\xFF\"\xFE\xEA\xAD\xF8K\xFF1\xF8\xAB\xFF\xBF\x19\x7F\xD5\xC3\x02M\x0F\xD9\xF0w\v\xC7_\xD8\xC4_\xBD\x81?\x7F\x84\xDC\xD2\xA5\xE3\xAFU\xE2\xCF\xEDC\xB8K?A\xB8[\xC7_\xA7p\"u\xFB\xEC\xE5I\xFFz\x9AU\x175\xF0\x97f\xF8\x934\xED\xF5\xC3\xD5i\x8E\xA6CF\xF1\x91I\xEA\x19\xDF\xC7C\x0E\xE3f\xB59_\xAFi\x95\x93\xF6\x94N\f\x98\x92\xD7\x986\x80\xC9^\xA3\x9Ay\xDF\x88\xAC\xEE#\xE2Jkz\xFFz\x19N\xBB,P\xA4N\xB7\x97\x13\xC7c\x9E\xAF\xB5I|\xF3V\x0F\xB7\x86\xA93\x8Cx\xA7\x01\x1F\xEAl\xCD\xC2_M\xCCg\xE2\xCF\xBBM\xA6\xDB\x9A\xF8\v!f\x028\x16\v\x8B\xA8\x1C\x91\v\xEA\x8F\x85r\xA4\xEF\xFEu\xB4\x0Ek\xFF\x15\x0E\xF3\xFE[\x88\x9A\x18\x8F\x0E&)T\xFA\xFD\xA98-\x8C\"f\xC0'N\v\x87\xF7\xC6\x9Fk&)\x81\xBF\x1A\x9E\x19[\xAD\xDB85\x11\xB2w';B\x877\x03\xA1+\x89\xB8\t\xE0x\xCF\x90H\xE9\x10\xCB@\xFE\x9E$\xCCZ\xC9\x7F]-l\xC7_\x93\xE0\r\xA8\xF0\xC7$\xFE\xFC\xB1\x8B[;\xA8k\x00\xF1\x98\xDE\x7F\xEB\xA9\xEB\xF2\xBF\xFD}4\xA2\xE3\x8F\xAFtTu\x1B\xF2O#\xAD\xBF\xA1\xCEU\xB6\xF9\xD7\x1DE\xEC\t\xA3\x1Ar\xF7*\x1F'\xB7\x97\xF3o\xFD\xE1\xE8_\xAB\xFCS,\xE5\x9A\xBEO\x9Dg\xB4\x8A^\xAB\xFA\x87\xE1\xFB\x04r\xBC\x1Cf\xEE(\xD6\xC7L\xFC\xB9\xFD\xB7<\xD4\xD3LZ-\xF8\x83[\x8F\xCE\x9A\x1F!\xA9\xA7i\xE1\x16s\xFC~\x07\x986\x84\x7F\xFD\xB9!\xFF\x9E\xF6G\xC1\xF3\x8E\xB7\x89r\x89\xD5\x9C\xC7\xF0\x94\xADr\xAA\xFD\x957\xE7'\xFC\x9E%\x1FDF.\xFD\x84\xE3\x1D\x04\xB4\xD8\xA9W\xF3\xE5\xAB\xA3\x9AmgJ\xA7*\xEE\xDB\xC6\xB6\x16\x9B\xE7+\x96\xF5\x89l\x17\xB2\x1D\xAB\xF1\x13\x86\xBDN*\xD9\xA3\xF9>\x0E\x85\x04ylw\x9B\x83 (\xA3\xBC\x15\xF6\xAD\x98\xA2X\x86\x7F\x13\x9D\x9F\xAB\xAC?K\xAB\xFA/5q\x9AE\xFA:\xDC\b\xE5\xC5\xFF\x8B\xC6\xC3@\x91%l0\xCE\xAF\xB1\x9F\xFD\xB6_\x8F\x7F\x89\x8F<\x97P\xC3#\xB6\x8A\xE4]\x83\x8B\xEE\xF9\xDDv\xA0\xE8\xD2\xF0\xBB\x17\x1Df\xFDW\xA4\x899o\x84\x9Ft\xD1=?xx\x10E7\x03\x97\x18\xB1A\x97\x1C^\xCD\xAE\xFBh\x18\x97\x1C\x96)h\x93\xCF\xF5\xAB\x91w/\x8E\xC8J\xC0\x93\x94'\xB2A\xFD\xCD$-\x92^\x86\x91\xE7\x0F?\x85CT\xF6_\x1B\xF7\x8A:\x99bxY\xDD\x92K\xD3\x98\x17D[\x05)j\x94,\xB4\xF5\xCB\x1B\x81\xD2\x88R*s\xD3\xC8\x95\"Nhrm\xC1\x87\xBC\xEB\xB45\x9CW\x03\x05\x1FL\xA0\xAC_\x99\xF8c\xFB\xAF^h\x00z'DE\x9A\xA4\x9B\xE7=Y\xC2\xA6;\xD9\xC7\xDA>\xEAN\xA2KO\xD8\nw\x9E\xA7\x91\xB4\xADB!\x89\xF7\xF5\x0E7E\x81\xC2T:\x1A\xE3\xD5}\n\x93b\xF5\xFB)\xEA\xF6\xA6Q3\x9Cj\xEF\xE3\x01u\xE6\xD2\xBD\xBF'\x8C\x18u\x934\xFC\xFE\xBD\xC2\xD3\xD0]\x15$\xE9\x9F\xF8#\xA4\xBDO*m\xBC\xCA,\xE9\xECD\xA1Dh4\xD6\x10E\x1C\x05\x1F\xA6'\xB7&\x944\x0F\xF8[V\x11\x04&{\xDE\x1D\xE5D\xD8\x135}\xC3Ii\xA6U\r\xF1o\x8A\x1E>\xC5\x03\xA4D\x8Fs\xE8\xAAi\xA7\x99\xF8N>\xBD\b\xB7\xD1D\xEE\xB1\x11p\xDBCe\xFFEma\xB1\xA2\x1C\xCD\xCE\b\x9B\x16u\xFF\x07\x89wU\x05I\x9B\xCD\x1DB\xBA:}\x1BRi\xC0\xED\x8E=uNCPT\x9F\xEC\x151\x81\x85\xA9\x18|\x1B\xDC]\x9D\xFC\xCD\x98%}\xAB\x87\x1B\xF9\xD66T\x0F\xB7\xCB*J\xD5\t\xD2\xBE\xFD\tJ\xF6rO\xCD#\x92\x8E\x88\xBC\xF1s\xAA\xFBSz\x9F\x8C\xAD\xC6\xCF)\xDAZo\xD8\x04\xB5\x98\xE3\xF6\x81mA`\x99\xFF\x8A\xEF\xA7\xE1\x0F\xAAZ\x95\xEBKm\xC0g\x82\xBC\xA6m\x1BP\x1D$]2\xFC1\xAFI\xA8\xF1\x93\xB1^\xDE\x93\xEA\xC2Ia\xC0\xB0\x8E5\x9C\x84\x7F4\xFE\x8C`\xCE\xDDt\x1A;\xCB\xF4\xF1\xF3\x80if\xFFqb^\xD5?\x80i\x11\xBC\xAE\x8F_\xFF+?\xA1j\xC0\x96 \xA9\x96\xEF~\xF6\xBD\xAB\x9C\xC0\xB4\xF1\xC0\x9B?y\x9F\x9DjZ\x9B\b\xA6\xED\xC7\xB4\x9E\x00.|\xFF\x90\xF3M:M\x03\xCC*;\v\x9F\x88\xB0\xEB>\x1A\xC0\xC2s\xEE\xFD\x06\xFF\xA9\x7F\xA1\xA6\xB6\xF4?\x93P\xCB9\xFF\xD5+\x14*\x83\x9D\xFA\x99\xFF\x07\xD3\xE4Q\x03O\xFDs\x04oP\xCFx\xBA\xB7\xAF_\x99X\xC3E_u\x02X\xD9\xF3\xEE\x07\x04\x85\te\xA2\xEF\xFEC\xB2~\x05\xAA\x069\xFE\xD4\xB4\x8Cqu\xDF.z(\xBCu7\xCF\x8A$\xAD1a\xC0\xB8c1f\xCF\xC4\xFE\xD8\xFE\x13@5T\xF1\x98\bVu\xB31\xE8\xCE\x1C\xBF\xB1n\xF6\xF6\x9F\xD0\xF1\x17\x8Bno&\x83v\xFC=\x1B\x8B\xC5\xDA\xD9\xB1$\xD6Y\xE5o\x14\xE3w\xBB\x89?\x7Fk\xC3\xB3\xDB\xF8\x99\xAB\xCD\xE2\xD2\xC3I\xB6\xD5?\x80\xEA\xE1\x94p^\xF5\xF5$H{\xAF_#\xFB\xB8x\x88P\x90\x9D\xBCT\xF4\xE3\x06\xFE\xB6\xD5\f'\xF1(E\x9B{l\x13\x94b\xAEK\xD7\xEF\f\x02\xEB\x03K\xBF\x9FF \xA8h\xDD\xFE\x8669\x8C8\xFE\xAA\x82\xD2s\vx^\xED\x92\xCF[0\xF6\xBFx?\xCC\x15\xF2\xCFup\x02\x9E\xC4\x7FU\xFE\x19\xE37\x86\xC2\x90\xD1\x7F\xE1\x8C\xF1\x1B\xDB\xCE\xB6\xEA\xE5\xA6\xC8\xB3\xBD=\xFD$n{S$\xFC\xF3\xEA\xDD\xDE\xD7\x99\xFC\x8B\xF7=\xC9\xDD\xA3n\xA0G\x8CAw,\x8Es\x0F\xA5:w\xF27m\x86\xE4\xF86h\x88\xC0}K\x1C\xBE\xD6V\x11>\x1F\x8Bi$\xFDTO\x82P9\xF6E\xE5m\xF2\x87\x9F\x1A\xACR\xB1\xA8?\xC2\xE4\xDF\xA1\xB4gk\xBF\x9A\xE6\xF8\xFB\x05\xC3A\xEF\x86\x91\xE3!\x14&\xD4}\xBD\xF7\x1E\x96\x95\x9AP5\xCC\xBF\x19\xF2\x8FH\xFC\xFD\xA8/!s\xC3\x17\xCB'\x98Q\x8E\xF35\xB3\xBA\xF7\x1F'\xFF\xCC\xF1+\x18\xE5\xA6]\xE5\x03\xA6;3\xC6\xEF\xC5\x03\x98\x1E\x82>`\xD5\xCE\x81\xA7\x83\xAAw\xB7m\xFC\x06^\xFA\xDC\xDD\xE3\x04\x98\xF6\xA8\xF3\xA5\v\xCEic\xA7J\xE2\xD7\xE0Dt\xD3\xC7gc\xE1\x15\x97\x7F\xFE\x15\xF6\x9BE\xFB\xBF\xF0\xBD$\xDE\xA4\xD3z\xBC\xF8\xEC{\xE3\xA2[?x&\xA1~\xEE\xCD\xA7\xA8\xDA\xC2\xAF\xF6\x12\xA0\xDE\xC8N\xFF\x8F\xBF\x17\xF2\x85\x9D\xEF\x99\xF7\x92\xF8\x1Du\xBF\xFA\xC0G\x9B\x800\xBF\xD75lR\xAA:c\xF1#-p\x07ISw\xC0\x8E?'%]\x19\xF8\v\x87\xE5\xFC\x1B\x96\xF2\xAF\xE0\xF8\x04\xCA\x82\x7F<\xFE\xC4\xFB0\x92)\xDA\xA9s\x01\x9B\x96\xDA}f%ya`\x01\x84\x84\xD9V=\xB9\x88\xD0\xF0\xE3\t\x12\xB0\xD5\xA3'\xCE;\xE7\x85\xBC\xD3\x00g\xAC\xA5}[U\xA3\xA0\xD9xXf,y\xFD\x98\xB7\xBE\xC1\xBB\x16\xCEF+\xF9e\x85O\xC3z\x14\xFA\x03\xD0\xC2\xAD\"\"b\xFB#A\xD2\xD4\xDA\x15!\xA1\xAD\xB2F3\x99\xCB\x89\xFD\xA2\xD0Yehy\xC8\x89\x87\xE1\xE8|\xA2z\x06p3\x7F\x8E\xA5~>\x7F,i\x1F\xC0g\x82\xE4\x96\xE7\xDC\x97\xB7\x01sY\xFFU,i\x03\n\xA0\xEE\xBFU\x1C\xED\xBE\xF2+\x02\xC5\xF7\xD3b\x1F{3\xDF\x99!\x12\xE3\x9C\x9B\xCAQ\xAC)\xDE\xFF\x9A\xFEl\xF4\xDF\xBD\xCCp\x07\n\xCFh\x01\x9C\x96\xEC\x15\xCE\x0E\x9D\xBF\x91:\x07\xB0^\xEF\xBF\xF4\xC6H\x90x\xEF\xB6\xC9\xBF\x96-\x8FU\xA5n\x06\n/v>\xB6mx\x81\xA0GY\xCBvy\x98\xBAR\xBBq\xF6\xD7\xC7\x02[\xA9+\fT\x18\xAE\xDF\x8A\xEE$\x1E\xA2\xCE\x97\xBC\xA8\x1CJ\x89\x8Ah]\x8Fi\xE4\xE1\xAD\xDD\x11\xF2\x00\x8F\x96\xDBNAn`\xA7\x7F\xF8q\xEA\xD2\xC7\xEF\xE3\xDD\xD7\xB0\xDB}`\xEF\xB3[\x13\xEA=\x02\x7F=\t`\xF2\xC1\xF7Z[0?A\xF2_a\x10\x15\x82\xB6n$\t,J(\x01)\xAE\vo\x131O?\xA2\x05\xA3b\xAC~\x8D\xF3\"\x02?\x99@Y\x02\x81S\x96\xD5\xA9\xF6\x7Fm\xB3i\xE7D\xE8\xED\x9A\xB0\x055(A\xF0j\x94\xC2\xD2\xE4\xAC\x1B\xA5\xE6\xBEP\xAE\x85B-\xB5\x93\xE0\xD0\rj\x87\xDD\xE0\xB5T0r\xDA\xAEk\xC6g\x97\xE6e\xDF\x9B\xB8l\x9E\xED.\x8B\xA7\xB8u\xBD\xE5\x89\\\x14\xAA\xC1E\xACN\x9A5\xE2\xA3\xE0\x83\ta\xDD\x95\xFD\xCA\xB0\xEE\xF8\x9F\xFD|\xAB4(\xD7\x00\xFA\x06y\x98\xFE\x8D\xDB\xD8e\xBF\x1A\x15\xDC\x8Bk\xE0\xD1\xB0\xC6$P(\xEB\xA7\xB2\xB4\xDFi\xFD\xCC\x12T\x82\b\x11O\x12\x13\x9Ca(L\x95\xEB1\x93\xED\xCC>\x9A8Gh\xE9\x9D\x9AL|,\xA5\xC0\x8A\xD2;E\xE9\x94\xA5(\xA5\xEA\vM\xC6S5\x19\x1F!@\xB9\x0E\xC8K`9\x0F\x88\x93Y`\xCA\x8A\xAB\xB3\x97\x17\x97\xF2B\x0FW[\xBBJ\xB1\xF4_%\xFD\x94\xFE\x13\xD3\xFB\v<\x99\xD9\xA82-j,3\xA8\x18\xD6\x9D|\xD5Nc=E_q1\xFF\xD4\xBF\x11\v\xCC(\x9C I8M6\r\xC2\xE7}G\x12\xA8\r\x02\xC79\xD5p}\x82b\x16UBh\xEFK\xA8\x83\"L\x97}\xA49\xFE\xEAG\x92\x92l\x91\xC7c\xF6\x8Dh\xD0I<\x95r\xB3\x1AT\xCA(p2I\xA1\xEE\x07\x8A\"\xE0\x1C\xC4:\x7F\x8E5\x19\xC8\xEA\x9E\xF2\x14\xB3#L\x1D\xC4j\x8D}\x9C\v\x7F|v\x81\xE7x\x1Au#\xDC\xA9\xC2\xAE\x06\xD2 \xC2L\x99\x8D#\xB4\x9B\xFA\x11\xC3\xBA\xF3H\xCDr\x92Z\x02D\xF5\r\xD2\xE7\xA5\x7F\xE3n\x84zq\x8D$\xDB\xE0\x83(\x00)T)\x9E\x87\xE0\xD1Drj9\xC3_\xB8|c\x12I*\xF1\xD7\x84R\x1E\xDE\x1F\xE1\xE5\x86\xD41\x94n\xD3$?MI\x04\xB8\xA6\xBD\xCB\xC0\x9F\xA6|\xCE\xC4\xDFU\xC6\xC7\n\xCA\xEB\xFF:\xA2\x1C\x7F;?\x11\x7F\r\xFC]\xB2\rK\x8D\xDF,|\xF4\xA1\xA9\xF1\x97\xD7\x18\xC2g*\x04y7/\xF9:\x11\x13\x8B\x17\xCE\xD6\x98\xB0\xEE\xFC1\xC3\xBA\xE3\x7FF\xB8\xC1\xA6+\x04\x14\xFA\x06i\xC9\xE9\xDFD\xB1\xDB\x187\x0F\xA3lC\x12\xB1\x1Ec\xFC\x12>\xCE\x19\xEEk#@\x8A\xE1o\xB2o\xD8\x87\xED\xD4\x1DB{Y\xBF:,\xC2\xE3x\xA91\xFE\xF8\x81^\xB9\xA6\xC59\x9D\x8E\xC5{u\xCFO\x1D\xD4\xC3&\xA4R\x06\b?\x92\xAFv\x88\xE3\xEF%=\xEC\\\x1D\xCC\x81\xBFa#\x0F-\x9D\v\x7F9\xABb\xD7\xF1R\xE0\xEEh\b3\xB7q/\x00/D\xA64p:\xD0e\xC8\xFF`b-gq\xF3\xFCj\xB4\x11\x15\t\xC5!X\x14\x98\\[N\xF5az\x8CB}\xC3\xAC\x11\xF91\nd\x0E\xCC\x97_\xE0\xC5\xC4\x0E\xB0?\v\x92\xF8.\n|Xc\xB2\xF9\xB1\xB1*2B\x19\xFE*\x19\xFE\xBC\x17\\>\x84\x9D\xB4p\x00GK\x82\xA4\v\xFE\x84\xCC\x92\x8C\xF1\x07\xF4\xC7\xF4U0\xA6\x9Bu\x8B7\x03\xD2\xC5\xFE\f\x9B\xD1\xD7\xBDF*g\x97|\xB5O\xB1?\x95\xDBt\xDB\x99\xC4\xB3\x19\x82y\xA5\xE2Qnd\x9A!\x9C\x16\x97\xE9\xD59\xF1\xC7c\x17\xF2\x9FI\xA3\xB6\xC6\xECq\xBE\xA6\xC5\x06\"\x99\x87\x95\x94\xA1\xE4|\xE5\xD2}\x98\x01\xE5\r1LK\x82<\xB7o\xB5nz\xF0\xE0\xDE<\xA9\xDF_\xC5\xB5\\\x1Ep\xC1\x19\x04f6DEU0\x07\xC5(\xAE&\x06\xFEJ\x96\xCBe>\x8E\xBF1\xEA\tbr\xBB\xC0\xDFjtl\xEDW\x8F\x98\xF2/\xC5\xEB\xCC\xD7\xDF\xA4I\xF9W\xA7\x01\x93\xF5#:\x89q h\x15i<Q;\xA9\xCB\xBF\x01\xCE8\x96\xA4V\xFC\xF5\xE7\xC0\xDF~\xC0s\xCD\xD4\xF2o\x82N\x89?%\xB8\x0E\xE5\x07\x05y\xF7\x12i\xD3\x01X\x8Ci\xC7\xD3ky\xE6T\xD9\xC8\xA2FT\n\xFC5\v\xF9\xB7\x9C:C6\xF9\xA7\xAF\x9ANP\x8F\x8E\xBF]\xEC\xEC~N\xD6\x91?\x84c\x94\x8D\x8F]\xC6\xFCQ\xF6\x8BbY\xFE\xBC\x92Y\xEFTY\x8DR\xEF\x86!\xEC@\xE1\xAB\x98\\\xCBp\xC0'\x1B\xF6\xE1\xA7\f\x7Fn\xEF\xCDr\x1E\xE4Tx\xCE\xB5\xE2E\xAD\x83;\xA8\x94\x9B\x96\x13_\xD4\xAD\xD1\xAB\x11\xC6y-m?\x85r\xB1\x91\xF6\x10\xF7g\xF7\x06\xDB\xEF)\xBE\x9F9\xFF\x86\xCC\xCD\x8FO\x8D?\xCF\xEA\t\xD4\xD7\x84,\xF8\xE3\xCE\xCE5\xC8\xF7\x86W\xF2\xBAs3\xD4\xB7\xF7\xA1Tc0\xC8\x7FJ\xE8fCT\xE7oZ\x06(\xEDf\x8D\xE1{\rb1\x81\xBF\xB2\xDD\x9A\xE0k~\x80:(\xFCfm\xA7\xE2/2\xF9W\x94\x14\xB4rc A\x1C\x8B\x0F\xFB\x10\xA5\xEEF\\]\x9FP\xF7\b\xBE%\xF6\xC1\xA4Y;\x025Q\x88\xB7T\xDB\x0FL\xECZ\x1E\x96\xC8\xB9\x88\xAA\xE9\xF1\x1C\xF8c\xF2\xEFuf\xF4s\xC6\xA7a\x9D\n/\xA7\xFC\xDB\xCFq\xFA1\xA6\x90\x7F9\xF1\x97\xA7\x18\xF8\xAB\x12Q4\xCC\xA6S\x1C\x9B\x05\xFE\\\xA9w\xDA\xF9lZ\xF6\xDE\xEC6T&\xD4\"\xA0\xD0\x07,h\x06V2\x93V\xD7\xFF\xC8\x13\xA6\xFC\xFB\xA91\xB0+\xB8\xFC[\xF0\x059L\x8F\xB2\r\x93qK\x91\xE7b\xE9\x16\xAF\xA0\xC0}\x98\x16D9\x9B\x7F'\xA9g\v\xD6\x10&\x148\xDF\x17\xFB\xA8\x16A\xE47h\x12\x7F\x85\x1AP\xD9\xEA\xE52\x1B\x0F\xA3\xA8\x19\x9A\x89\xBF*\x03\x7F\x15\x92\b1\x8C\xF9\x80R\x8B\xC2\xE6\xA9\xF1\xF7\xB0`\xC6\xA3V\xFD\xCF\xF9)\xFA\x9F\xAE[L\xA0\xF6\x15\x11\xC5\xF5\x12\x80?~\x11\xE6T;\xD5\xFE\x1C\xCDj\x1E\x8A\xDA\xFD\x96rD4\xCB\x8Bik\x96\xE2us\x12S;?m\xF9\xC1\xC4\xC6Q<g\xD4z\xA1\x05\xC5\xB2\xA6\xE2\x7FG\x8C\xC8\xD1O[5\xEE\xB7u\x83\"\xEE1hu/+\bby\xDF[\xC9\x16\x14\x1CL\xA2\x9E\x165s\xBA\xE5\xC0\xE4\xF3\xEF\n\x9E\xCA\xF8M&\x05\xC1i6*\x80\x1Afp\xDCAE\xB2\xAB\x12\x9F\f\x07\x11\xAF\xE9\xB30\x06\n\xAE\x83\xF4\xB1{G$\xE5%\xDF:I\xD5p\xDC\xE26)\r\n\xC1-|\xC7\xBD?N\xA8\xE9/\xFF\xA9\xF92k\xE4\xC5\x95\x16\x04\x04\xAF\xD0\x8EL\xFBm\x92\x92\xE3gL\xD5\xB1)\xF6\x947\xA3\xA4R\xCF\xEF\x9EC\x95\x97qz\xFE\xF7\xE3@A\x10\xB7\x18{\xDE\xF4\xE3\x82 \x8E\x92\"\xAF\x13\x8BZ5,\x81\xA3\r^@\x1D(\xC1\xDA\xF9\x03<Mu\xAD9\xC5\xD7Rk\\\xDE\x98\xA2\x17?\x1D\x03H\x88\xCC\x89\x90\x811\v}\xA9\xA4\xAB\r\xB7\xD7\xB6>*&\x9F1AT\xE9\x9E5\x00\xB3\xEC\xC0\x9CQnS3\xCD\r\xC47VL\x15_\xEAOE\xD6b9\x82\x94%2\x0F4\xABB\xAD\xCFG=\xEB\x8FLu\xFC\x15\xDD\xDC\xC9\xAD\f\xE8#a~\x82,\xC2\xBC\xA1\x94\x068W[\x98\xAF\xDB\x1E\x19Z\x8D\x9B\xB6\xFE2\xD5\x82Y\xC3Il\xA5\x8EQN\xAA\x15\xA8\xF9\xC1A\x0E\x1A\x12\x9F4|Y\x1C\x7F}v\xFC]\xDD/\xF0\xA7\xA6W\xC6\x12$7\xFEzFR\x02\x7F+\x05\xFE\n\xDF\x88\x9B\x064J\xDBD0\x9E\xC4__BI\xF7\xFE\xE9\xF8SFue;15\xFE\xAE\x9D\xE2p5V\xC1\x15kR\xD3h \x87\xB3\xFD2s\xD4V\xC2\xE9p\xBC&\x82\xAF\x16_V\xF8\x12J\xFDa,\xA0Em\x88R\xA8\x9D\xC9x\x95\x9B{#;\x9D4_7q\x02\x1A\xF0\xAAq\xEC\x8E.\rx>(\xB5/o\x94F\xD4\xC1\xE4zSa\x11\x8E9\xD2\xD9\xD1\xAE\xAD\x17\x15\xAB\x1B\xD9\x11a\xEA\xBE\x7F\x100N\xEA\x1C\x15n\x93A\xBE\xF3\xE7\xBA5\xC5\x9B\xFCS\xFB\xEFJ]\x827I\x07^f\x91\x17\x12\x8B\xD1\xBC\xEE)\xE5_\xF4(\xA0\xE6\xA3\xF0\xA0\xDE\x7F\xE5\x11\x12B\xF9z\x7F\x80C\xF9~\xE3\xFE\"\xDB\x86\x92\xD8j\xE0\x8F\xD7\x8C\xAD\xA1 \xF1\x95\x1B\x04h\xD8\x8B2\xF2\xF2\xD5\x84Q\xA9\x89\xE1\x8F)\xCC|\xFE\xF0p\xFCu$\x10\xEF\xFDq&\xFEH\xFCX\xCF\x88\f\x83\x98\x94\xF8{8`\x91\x7F\x01\x89\xBF\x00\x97W\xBF\xAEO\xA8\xE9\xE5\x7Fj\xFF}O\xAEJ\x92\x16\x1D\x7F\xC9l\xFC\xE5\xDD:\x15\xFE\xD0\xF9\x15\x8E?\xB7\x89\xBF\x88\x9AF\xFD\xC8\xFCA\xAEv\x9B\x15c\x0E\xBF\xB0<\x8A#m\x97\xB9\x97p\xFC\xB5\xD1\xFC6\x84(H\xE7\xAA\x07*\n9\"\xBC!jdI^l\xC3_\xF2\x05Mr\xFA2\xBCt:;\"d0\xD9\xA3Y\xBC\xBCB\xFB\xF7\xE6\x97\xB7\x8Ad\xD7h\x87\x89?\x83\xAD\xA7t\x94\xBB\xDDU\x81\xBF@\xB7F:\xFFd\xFC]-\xEDs\xB2B\xB26\xB93\xC8\xB1I\xC4M=\xDDS\xC9?u\xA2\x97\xD9\x158\xCD\xC0_e\x82\xE1/\xEA\xF5s\xFE\x11\x13\x7F\xB1m\x03Q\xDC[\xA6\xE3\xAF\x9ENk\xC6J\n\x92^\xDE{ %\xE4\xDFJs\xFE\xAD\xB6\xCB\xBF\xFB\x13\x82\xFC\x9C!VMO\xDE\x17T\xE25Y\xF8C\xE0\xA7\xCF\x8F\x8C\v\xEA\x887\x7F.\x96\x12\x07\x02\x16\xBA\xE09\x02\x7F\xBC\xA8\xB0\x9A\xF6\xD7'H\xFCO\x96\x7FwP\xE1%\xC3\x1D:\xFE\xA2Y\xF8C\xDE?]9\xD5\xF1\xB1\xA3\x1C\x7F%\xCBm\xF2\xAF\xB6w\xFE0\xC7\x9F)\xFF\x86w1q\x18\xBE\xFB\xAA\x0E\\\xD4\xD0\x88\xCB\xA0l\xC1f\x80\x94^6/\xD4\xC6C\xB8\xF7|\x15\x06\xAF\x01\x03\x9B\xC9\x9A}\xD9\xCC \xF0\xFD\xA0`\xD2&+*\xCA#\xD8\xF3\xED\x99\x96h\"\x01\x81\x8ED\x95<\x15*N\x0F\x02\x15 \x9BW\x00\xF9\xFAI\xAB\x9B9\x99\x97\xC2\xBD\x1F\xA5\x93\xB1\xA0\xBAg\xDB\x9F:\xFF\xB6SQ\x12Ym\x87[z\xA13%\x9C\x97\xBAc#S\xE9/\xBEm\xDC\x9C\x9B\x1F\xD3oR\x8B\x90RT\xF9\x9A\xAE\xE0\xB6}\x97q\xB6\x87\xBB\xAB\x16\x01\v\xFE>|\x03\xF2\xAB\xC2\xD8\"mqr\xC3\xEBwU;\x07yH\xC15\xD4c\x9D?\xCC\xB1\xB5\xC50nwP\xA8\x83I\n\xD5\x1B\xDDn\x8E\xDFB1\x7F\fn\x8D\xCF/\x14D\xA3\xAF?\xAB\xF1\x9D\xD9\x84\xE1\xB2\xB0m\r\x9A\xE3\xD7Y\xAF\xE1O\x1F\xBFi*\xA9\x04\xD32}(3\xD9P\x1D\xEE\xA5\xEE\xE4\x94\x8A\xF5\xD9G9\xE54\xA6o\xD1\xF1\x97P\x07q\xC1M\x1B\x9E\x06\x8A\xC2\xF8w\xE3\xFE\xDE\xFA\xD9\xE1\xC8)\x03\xECT\xFB\x8B7\xA7\xACW\xB6V\x8E\xBF\xA0\xE1Q\x93\x90\x0ER8\xA8\xCD\xE7\x9A;&\xDA>\xF4\x94 \x9C\x9C1\x8B\xFB\xF4\x9C\xE8?\xC1\xB7M\xB4r\xC1\xE6?\xDBd\xCC\xB2\xBBok\xA9~\xA3l&\xC9]\x04\x18\x80\xC3\xC9\xEE\x9C/\xF1\xD6FL\xAFb\xC8\xFEl\xDA\x14\xE6=\x940\xCE`G\x9CN\x82\x82\xB9\xEA\xBB4\xFF\xF8\x037PQ\xDC\x88m\xF8B\x1B\xBE~V\x02\xB8\x91\xEA\xBC\xC9\xFF`,=[\xDA\xE9yL\xD3\xCFO\x02\xBC\xC8\xE4\x99\t%\xFC\xBF7\x8F\x027\x9C\xF1\xB2\x86\xC9\x17\xA8\x95c\xEBD\xF4\xDFb_'\xAF&\xB8\xC0\x10CuL\xD1\xE4FH\xDFA\x1E\xD7\xA2\x0E$\x8Dt\x9A1C\x8E\x8F\xD5\x8D\xAC\xC6\x07\xC6\xDB\x1Es\x8DP`F\x02\x18\xF3ED\xA1\xE1tfM\x9A\xDA\x8D\x1AP7\x125\x1DA\xFBD\x8Du\xAE\xBD\xF2\xBE\xAD\x1CI\n\xEB.H\x9D\xED7n4Y\x9A\xE7\x1FL\x82\xCE\xD3\x80V\xB9`\x00<L\x1D\xD7d=P\xE5A\x9F47\xE7\x05\x05\x91U`]$\x01l\xDC\x16M\xE2\xEA\xCA\x04i8\xC1k((\xE3\xB1C\xC5FO\x14&\xE4\x9Aj\xC8W\xA11\xFC\x91\xA8\x88E\fDtV\x15\xA6GtV\xF9Cx\xCC8O\xA4\xDE\x9F\x14\x8E\x96\xAE:\x8D\xC4%\x83\x8A\xDBv\xAD\xEA\xE1$\xE0\xF7\xCB\xFE\x8BP\xF0J\x16B{\xDD#\x02\bk5*r_\xBF\r\xCF\xE5Q\xFE\xB6\x84\xB2]\xF7\xA56\xE1\xCD\xE56\x0FW\x80\x0E\xD1\x82l\xC7Vm/\xEB\xBF\xA2\xD7%'t}B\x8D}\xFCP\x10\x18\xBB\xF8\x95F\xD4\xEC\n\xAA'v\xB5\xD63\x9E\x1E\xE37nf\xF91p}\xC4\xF1W;/\t\xF8\xA8z8e\xE0O\xD4K\xA8\xA5\xC0\xE4\xAE\x9AU0\x15\xE8\xC9\xF6^\xA7\xE0\xAD=\xD23\xAA\x0E#\xA0q\x17\xA7\xBD4\x043G\xEA\x96g\xE2\x8F[O7\xA0\x82\x07\xC0\x8D$E\xEE\xD7\xEF\xE0\xF2\xA6yT\x9D\xE0\xE8._\xBF\n\x9B\xCB)\x84\x8As\xBF\xF0\x18Oo\xCC\x81\xBF\x904}y\xDEgy\x84\xA47\xCD\x1C\x05\xB6>\xD9\x9D\xC4\xEF?\x13QN,\xFE\x14%t=\x1F\x11%\x86d=3\x01ts\xFCU\xCD\x13\xF8\xDB)\xF1\x97\x80\xD4\xDC$\xFE\x1A-n\xA2\xCE9\xBB\x87DY\x98\xC7wi$\x86*\xE1\n\xB5=`UC\x18\xF0\xEDNf\xE0\xAFCPvs\xBC\xD4ye\x81\xF2\x00\xF5\\\x1A\xE5\x1C\xA6Bd\xD4\x1Fn\xC3\xB1\xBEf\xF9\xE7\x11\xA1d\xA9\xA39\xF0\x97\xD4\xDDD\x11\x81\xBF\xCEI\x86\xBF\xD1\x1D\x1B\x1B1\xBF\xAF\xFF\xFFs\x06J\xEEV\xF0\xC1\xF5\x1Fq\xF9grq\x9F\xA7\xE9\xF2\xAFj1\xC7\x1F\x19\x8E\x19\xF8\x13\x9A\xB9_c\xFD7\xDCh1\x06:/\x8CE\x01O?\x10\xA9\xD2\xC8vT5\x93g3\xFB\xCF\xD7\xCA:Q\x1F\xBF\xBDz\xFF1!@\xBE\"\xF0RQ)\xF17\bWj\xA7\x05\x7F\x15\xAE$~\\\xAE\x01\x0F\x18\xF8{\x94\x16\xF9\xA6\x90\x7Fn\x9D\xC3\xBE\x9C\x92\xF8\xE6Y\xA3\xC0\xE6\x9A\x83I\xB4\xF8\"\xCA\xDD'\xB4\xFF\x1C3\x9A6/h\x06p\x911~\xE7'$\x91R\xA8\xEE2&\xEF\x83j4e\xC8?\xB1\xE2\xC2\xA0r\xB4n\xF9*\x1C\xB5\x8C_f\xE2\xB9x\x12\x7F\xB3\xFA:\xEA(\xAF\xA9\x921~\xDBd%)\xE9\xF7\x13\xFE\xCB7\x84\xFC\x13\xF8\x1Bn\x13\xC2-@\x8B\xEE\xDDo\xC1_\xDD\xE16\x1C\xADo\x96\xBC\xBA|\x97A\xAAf\xAF\xD8\xD7-\xD7\xF1\xC7\xCB]\xD5q\xFCE\x80c\x17\xF76C\xDBHI\xEAD\xE3\xEFc\x1E\xF7e\xBA\xD8\x02A=\xA2l\xDD\x9DI`f\x10\x11Y\x9B6\x01\x88\x10\x17\xA6\x88\x9D\x9E\xB78\x84\x99\xC6\x89J\xCA\xDE\x1A\x02'*+\xBDSC\by\x9C^Y\xB1\xE1/\x7Fq#\x90\xA7\xC9\xFE\x9B\xA9\xC7\xCE|\x85\x9D{\xB6XI\xD1\xBC\xCDb\x8E\xAA\x80s0\xC6\xA7YQ*\xD8\xEB[\x85\xF5^\r\xE0\x9C\x94]b\xFE%\xD9\xF2o~\x95>\xFFj\xFD<\xE2\x97\xCC\xB9\xB38\x01\xAC-\x1F\x88\xA2~}\x10\xE1\x13\x8B\xBF\x92`{\x1B\xBB\xF1E\xC6\xAB\x9CG\x81\x17\xF9=\xFF,\xE4\xE4Y\xBF\x9D\"\x96\xDD\x0F\xE0\x0F|\x97\v\x82\xC0\x9Eg\xCF\rZx\xD9_\xC3\xB9N\xA0X\x03\xF6<\xD9\xCCk\xAC\xAB\x01\xBD\xEE\xBA\xDE.\xF8\xE7f\xE0\x82sd\xFF\xFD\x01Py\xFC\xD05\xA2<\xD0\xE7\xD9m\xD4\xDE4[\xACP}H=g\xDE2&\xBD\xD2l\xC3+[\xF0\xC1%\ti\xFFr\x03\xF0\x00\xCD$^f\x80{_\xC6_\xE1\x12\x86\xBFK\x12\xEA\rC<\xAF\xED\xF9\x9AE\xDC\x8C|\xE7\xC4\xE2o\xACEV\xCE7Z\xA0Y\xE2o\xF3=U\\\xBFR\xE2&\x89\xFBE\xFC[\x91\x06,\xBC{\xFEj\xD4\x9B\xE19\xB1\x7FY \xA2\xAD/\xA4LzMO\xF0p~\xDB\xB2W\xD1\xFF\xDC\x02L\x7F\xDBi\x9E\x8A\x97\xFE}\xE7\x94\xF5u\xAA\xFDe\x1B\x95v\xE3Q\x89g\xAD\xF4\xD3\x8F\xD1\xACf\xA4\xC7\xCApX\x9A\x19?\x9C\xBB\xA4\xAF8\tO\xBE\xB5\x10>\xFF\xD9Z\x86\xE9\xABd\x98\xFF\xEC#\xCFb\xD6\x1B\x05\xA0\xE6|\xFA\xADq\r\xBE\xCE(\xD6\n\xCF\xFC=L\xB5\x7F\xC3\xB2\xD5\xDERF\xDC\xE1\xB0=\xD1N\x0F=\xBD4m9\xAC\xD6\x12\x04\xC8f{\xF7\xA5i=\x84v\x07\xC6\x84\x9D2\xF2\xDC\x89T\fE^FY\x02\xB8\xDD\xB86/\xE4\xCBk\x16\xF3o\x1F\xD8\xD4\xF0!\x94%\xD4\x01\x9E\xDD\xAA\xF7\xDF?\r\x02\x05?z\x07g=\xBE\x05\xE2\xDB\xDC\xAF\xB1\x8Ff\xE0V*\xF8\x19t\x92\x06\xEE#\xA8N\xE8\xEA\x11DU\b\xE9\xB4@\xB6\x92\xC7\x17\x9CE\x04\xAD\\\xCE\xF74\xE8\tn\xEE(J\xE1n\xEF\xB0\x94\x8B0s\x00\xAB\xB8\xB5\xE8I\xC5d\xA9,\xB7\x86\xDE\x9Ef\xAE\xDA+'\x92\xE6BD\x17\x95\x04y(\xB0l\xDC)u\r\xD5\xBF\xD9|\x04J\x00%\x11\x12o\xB0T5\xF0\\\xE9\x00\x1C\x7F?\x1B\xC5K\xD9\r\xB2o3\xD6\xB1\x0F\n|\x01PfC~\xE8\bcz\x93L\xFA\x13\xF8\xFBfzJ\xFC\x99q\x87\x07d\xAF}v\x8F\x89\xBF5<=\xD6$m6\xEA\xCFp\n*\xC0\xDD3\xCC\x8B \xF1\x9D\x87w\t\xFC\xFD\x9F\x13i\x18\x9F\xC7??\x13\x04\xCC\xC2\x98<\x94\x9AGB\xF3\xDF:m\xF8\xBB\x11\xB3\x12d\xCFJKU\x17\xF7\xF1!\xA0\xE0\xF4\x97Q\xF78\xEB%\xF6m\xEE\xD7N\x7F\x07s\x9A\x81\x7F\xA2P^f\x87\xBD<\x05\xFE\x9A\x1E\x02\xDC1\xA9\xAA\xF9\xB3\x91\xC1\xFAY\xA8F;e\x8F/\xB1\xE0o1\xDCM1\x11\x8D\x9B\x81?\x7F\x90P\xA0\xE8i\xEE\x99z\x82\xBB\xC5\xFAx\x88\xB4?\xB6\xE9D\xE2O\x86M\x07\xAD4\xA2\xFC\xD9>4\xB6\x1E\xB3%4N\xA0\x0Ej\x9C\xEBk2'\xAB\xA8\x9B\xFC\xD1\xF8\xE3\x0F\xE8\x0F\x02\x8FIi\xD6\xDA\xC1\x06q:\xF3\xF1\x8D\xD6k\xC8\xBF^\xD9k\xB7\xE9\xDC\xBDn&\xFF\xDC\xB1\xB8%\xF3\xB4\xCA\xC0\xDF\xB9\x11\x12\x07\n\x86\x99\xC9M\x9E\xE6;o\x13/\xEF\xD0\xF8\x89\x94\x7F\x82\xFE\x8BYrfE+f\xBC\n\xDB\x94[\x04\x0F\xD8\x12\xF2\xFC\xA8L\x90\x1B7Z\x7F\x1B\xDF\x0Fx\x1E<\x8C\xB2ww@|\v\xDC\xF4\xE0\xD9|\x15\xE2c\n\xF50\xEB\xF6\xC3\xE6\x92#\x1F\xA6\xDF3V\x85\x00O\x8F\xA4\x83\xCE\xC1\x9E\x9E\xA2\x90\xB9\xAF\xC3\xF2\x88\xC2a}\xFC6b\x19<\xE3\xFD\x96ao~[\xC4\x03\xDF\x1D?\xD0\xEDFO\x9BL{\xA8\xFBR\xAC\xE3\x04\xF6\x9F\xE0\xCF\x99\x1B\xB4V8\xE2\x91Nk\x8C\x8FC6\xF9\x97\xC6Y\xCD\xEA\xF6\xD5V\xF9\xF7\x88\x13p\x8C\x06Q|.\x9FN\x12K\xE1r\xFC\xDB\x04\x17\xAA+D\x02\x84\xA1fp;\x96\x04\x81\xCD\xBA\xFF.\b(\xA3-\x96\xAD\xF6\xE6\xA6\x82i\xC0\x10\xC3\xCA*\xBD \x95\x92D\x1FU\x1A[@\x8Cnw\x18\x06\x82'\x81\x16\xA0 \xC9\x97\xC5odF8\xFCw2t\xE6\r\x8E\xEF\xFB3\xCF\x1FW\xDA\x85`\xCC\xD6\x7FM\x98\x15!\xB1\xE5&u\x1D\xDC\xC7\xBD@A[\v\xEA?\x18e\x9D0;\x8Ds\xDF\xBE\xA8\x1Cs\xFB\xF9\vP\xD2\x96\x88\xDF\x85\xAC\x1F\x17\x06\x81\xAF\x8B\xBF\xA7\x1FZ\x01L\xAF\x965~\x16f\xE3\xEF\x15#\x03-\"\xAFv\x9A\xBE\xAE7]\x03\xE8\xF4\x07C\x96\xC3.094\"\xEA\n^\x8B\x8A]\xFC:`Z\x14\xCF\xF1\f\xE9\v/o[r\xC2\xF5\x17\x86\xBF\xDB\x8D\xDF\xBE\xC3>\xBEe\xE0\xEF=\xDB\xFC\xF1\x06\xCE\xD2\xD4\xA7n5\xB1\x8B\xA2\xCEr`Zx-\x8Ak\x98F3\xED\xED\xB5\xA8r\xFCK\x1A\v4\x9EO\xC6\xF1\xA7H%qZ\xBF\xC0\x86!Ng\x0F\x02jRV3\x9A\x96\xDD\x7F\v\x85\xF8g6\xBA\xFE\x1Au\xF1\xA5F\xD1\x03\xB5y\xD8r\xBE\"#\x87\xF7\xCC\b\x1B\xF0\xEE\xA7\x06\xE4\xD0W\x93\xF8\xC6\xDD\xEC\xE5M\x7Fg\xEF\x1F\xFE,\xF8\xBB\xC2\x80\xD9\xFF`\xDFxd!G\xE236\xFC\xDD\x80Y\xFD\xE4\xB7\x1C\x7F\xDF\x17\x1B\\=l\xFE=>G\x86\x942\xFC\xD5\x1D\xBA\xC8\xC1\x95\xCA\xAFJ\xFC\x9D\n}>\xD5\xFE\xBA\x9B\x96\xE1Gu\xCAO-L\x9C\x86\xD4s\x128y\x16\x89\xE3\xBFl\xAANm{+\xBC\xF0\xAB5&\xDB\xEE\x8F\xE6\xB9\xA4!\xD3%\x9C\xC3\f\xD7\x90Qw\xC9\x91i\xB8\x07\xB5\xEC\x1B\xEA\x0F\xE68\x15_K\xDB\x92\xF3^o\xA5b\x033\xF6\x98\x15\xC8i\x94w\x8D\xF0T\x9C\xDBb2/K\xCA\xBE\xBF\x15OS\x1CY\xEC^Zl\xDC\xD9i\xFB\xC7_\xE5\x0EF\x87\xD0^\xD5\xA9\x19\xF5\x84@\xB9%\xDBOd\xD3\x0E\v4\xE0\xAC\x82e\xAF\x02\x05\xB7\x1A\x85d\x95\x01\xB3\xD6\xEF\xD7i\xC1\xBC\x01\xCC\xF9\xA1\\\xFE\x14\xC5\x8C\xE7\x98e\x88\xC5Y|\xC0\x99C\xFC.\x95\x070\xF7k7\xE36Y\x03YwR\x9F\xF5\x85\xC5q\xBE\xB3yC\xDF\xE5'=+\x97\xB2\xEF\xC8\xCD\xD2\xFF\x05\xB9\x81)\xDBL\v\xF7EHkg\x94\xB3\x8A\xBA\xFDM2>L>Bl\x8D\x98\xFEn\x1AO\xAF4#y\x03\xBDZ\\f\xC1\xF2\xD8(\xC7\x94+\x1A2\x85\xE5\xFE\xAC\xD7Kl\x81\x00.\r\xA8\x18j\xB8\x1Epy\xAF7vi19>\xEE\x813\x15@\xE5A\xF9\xA7P\xCB\xCAu5J\x86/\xBB\x92\x80w\x9B\b\x12\xBB\x11\x15\xEB\x8B\xB1\x19\xA2 \x93\xB4\xEDQ\xB9\xEA\x01o\x98\xDA\xEA\x04oythh\nN\xD9\x82\xD99\x9F\xE9\x9F\xA8\xD8\xC0\x8C=n\x0FZ\xF0w\xFB\xD9\x98\xF9E\xD3\tGV\x88B\x87\xD5\xF3\x1A\xA2c\xB1\xA0\xE9w\x1E\x1F\xE6F\xC8&\xE17\xF5\x8CN\xD5\x7F\xD2;\x9C\xED#Qm\xEA\x86g\x07\x10\xA8\x19\x1F\x02<\x8F\x1A%\x0F\xD5\x97\xAC9\x85\x9EK\xF7\xA0v\xA3\xAD\xA8\x8Da\x07\xC8\xDA\xB2\x1E\xCD`7Vc\b,\xE7%\x9C\xF4\x1Cm\xE9\xCC\xD9 \x12\x15\xCD\x1B>\x16gFJ-\xFD\x93\xF0\x17\xD3\xF1\x17kB\xFD~S\x02I~\x1F\x04z\xC7\x87\xB7\x9A\xF8\xAB\xED\xED\x8E\xF3\xBB\x17\xF8\x83\xA3mJ\xFC\t\xA3&\x9BV\xCA\xCE4\xE5\x8E\x00\xD5\xB1\xD6\xED\x80\xBB\xD30[H\x9B5\xA7\xD5\x9D\xEAD\xF5\xB0\xBC\x90`\x03\xF3\x9B\xECI\xBA\xA5\t\x7F'\x1F\xFF$\x85\xEA\xE1(\xA22\xAA\x98\xB4\xCB\x17\x7F\xE3\xDE\xCE\xA8}\xB1&\xC2OZ\x9D\v\x7F\x9E\xDC\xF2\xEF8\x15\x1B\xD4w\x98\x15\xF8\x11|\x115=\xB9kDg!\xAB\xEA\xB5\xF8\xF8\xC2\x02\x7F\xFE\x8A\x86\x98\r\x7F\xA9\x18\xBF$\xD7\xF9'\r\xC6\x84\x1C\xFD'\xF07\x9E\x9D\xEF7d\xBB\xD3\b{G\xBFf\xF8{\xFEu\xF3\xE5Ys\n=\x1B\xFAM\xFC\x1D\xB7\x9B\x912|\xD4\x13\x05\xEA\xF7k:\xFED.^n\xFC\x99\x01\x89\xC7\xE2\x1B\x87\xAC+J\xD6w\x1C\x9D\xC2\x16w\x88\x9B\x0F\x03\xAE\xAF\x97\xA3.A\xBC\x1D\xD1(\xE7\x0F\xEB\x06J\xBF\x1E\xCA\xC6\xDF\xC1\xF1#[\xE3\t\xD3o\xDA\x93\xE6\xEE\xCC\xDF\v\xC3\xE9\x13\xF0'L\x9E'\xE8'\xDF\x1B'\x16\x8B\xC5\xA2\x80{\xB7\x11\xC2B\xBAL\x93\x8C\xE1\xAF\xCB\xC4_\x8F}\x1DI\xA2\x89\x9D\xC5\xB7Q\xC4\x99\x0Fs\xFC\xC5dL\xA5\x8E\xF6\xAA\x86T\xA4\x1B6\xFC=\xE2\x1F\x8E\xD8K\xE1\x9A\xEE\xCD\xDC+H\xC7\xF4\xC2\xC0) \x7F\xC6O\xA1i$5\xD9\xCB\x93\xE9\xA7\x1FL\xA2\xEE\x1E3\xB4\x93\xB4\n\x87j\xA1\xFF\xCA\x15\x9B\xCDH\xDE\x99\xDB\xAA|\x9C\xD7`\xAB\xB0\xAD\xA6\xC6\x9F\xF4\x0E's\xF2=X\xF0\x17\x06\x02\x9E\r\x87\x01\xCF\xE5\x03\xC6.\xFB\xED\xF8c\xF2O\xF6\xDF\xC7\xD4\x86?)^\x05\xFEDA\xEC\x9D\b\xF4r\xFC\x89\x98w\xB9\x18R\x7F\xD3g\xD3\x1F\x9B>p\xD6\xC6\xEA\x96kr\xC1%\xB3\x15\x86r>\xD3\x1C8x\x98\x9AZ\n\xA8oyY\xFF\xC5:\xB6Up\xF9\xF7#\x02o\xF5\x80\xF9\x94\xDF)\xE7w:\xBB\xE8_\x97Lt\x18\xAF\xA34O\xD9\xCB\xC9]\xF8\xC2Q\xE9'\xE1\xCF\x91[S\xCBT\xEE\xC2\x00\xD18\x19X\xC8d\x8FZdFK9)\x92\xB3\x01*_\xAD,\xCF\xAE\xDF\x90\x1E\f\xCD\xB0\xF6\xC3Qi\xF0\x91\b'\xD5\x14#\xFEby;\xC1F??6\xDF\xB8!\xE7\xF7\x83\xEC\x8A\xB9\xA6\n\x92;\x1E\xF8m\x99\xA1\xAF\xFC\x16\x98v\xE6Nh\xCD$\xD6\xD9\xDD\xCBd\xE2\xB4\x83i\x04\x06L\xB1I\xBC\xBF\x12\xC4\xCBo\xDF\xD62\xEBqc\xFCV\x1EL}\x83O\xF9\xDC\xE6|\x97\xBAC\x9F\"\xFFz\xF0G\x8C\xDF\xE1\x07\xD8\xF8\xBD\xED\x1Ec\x97\x97{\xAC\xE3\xB7\xF5\xB1\xAC\xF9\xA3\xD9\xB2\xFA+sj\xAA\xC5\xFCK\x1E\x83\xAF5\xCA\x0E\vC\x0Fi\xE1E\xA8\x1F\xF8\xC3\x93\xD4\xB6X\xB3=v\xE3\x80\x9E\xA0|\xAA\x9Dj'M#\xC2\x98\xA5&\xB7P0\xA7\x1Dj\xB1a\x15\xFE\x8F\x043\\\xC2V\x13\xB4\xDC\xA2(\x85\xA6\xDA\x0F9\xBC\xCDm\x9Fn\x04\xFFwv\x8C\x1E\x1Cm\xB0me\r\xE0[h\xBE\x86\x1B\x1F|G\xC3\xD7\xCA(\xB0\x86\x16,\x8E\xDF\xB2U2\xF8H\xE7\xC6\xDC\x04\xF0\x0F\x0F\x1A]r\xD6\xD9\xC7\xD3\xFF\xDB\xEC\xBF\xB2w\x17\xBF\xC1\xA9_t{f\xDE\xC0M?2\xBB\xAA\xA0X\x98x\xC2|\x85\x11Ym\x9E\xDE\xAE\v|\xF3$\x911\x0E\x86\xA4\x19P\xD3-\xF2/u\xC2\xC1\xDEoF\xDBJ]Il\xEC\xACJ\"\xDC\x19\xE1\f\x93)\xFFFY\x19\x83H\x9F^y\x04\xB8\xC7d\x84\xAC\x1C\x8A5\xFD\xC0\xE0\x8F\x80\xDF\xD7~\x9D\xB0M\xE5\xAC\x97\n\xAC\xBD\xD0\x8C\xED\x91\xA6\xE59&\xF7\x84AQ\xE9\xCF\x9En\x93h?I\xF0WF\x95\t\xCC\xEA'\x1A_ \x1F\x01\xC8\xD2\x11dW\xB5\xFF\x80\xD9\x83\xA9\xBE\x11\x1F&\xE3\xDC\xD4\xF2lH\xA7\xEA\x9Am\xDAWm\x04\x187\xED\xB2\xBA\xE5\xFF\xF1\xD1\x18\xD5+\x7F\xA2\xBEw\xFC\x885\xE4\xD0s\xD5\xF0\xE4\x93\xE6D\xEF1\nox4\xABY\x9A\x93\x15\xDD\xA3\x9D45\xEF\x8B\xA9\xE2@m\x90Lp\xFCU\x01\xE4H\xB7Uh\xE9S>\xD3\nzb\xFE\x1D\x88UG8\xC3x*\xB6]*\x12z\xAD\xD0*\x8DM\xE0\xD4\xB4\xCBZ\xBBz\xA9\xB1N_\xD5\xD0\x14\xB7f\xDA\xBAS\xF1\xD8\xFD&\xFE\xDC\xAF\xEB\x8A\x88\x9E8\x15\xC9i\xDC\xEA\x1AJ\xF7\xC9\x83\xBF4\xC3\xDF:\x8E\xBF\x1A\x80t\xF4\xA2 \xCB\x00>J\x8BBH\xD6\x8F\xAC\xC2d\xBC_\xE0o8\x15\xB7\xE3\x8Fi\xF0\xC9x\xBFi\x97\x8D\x7F\x94\xA2\x0E]\xFF\xAB_\xDEc\vY\xF7l\x18\x9E\xDC\x16\xB4\x19\r2\xEA \xFC\xE9\xF8k<\x99\xF0\xD7\x84\xD2 \x99\xE0n'\x89?\xC7\xA2l\xFC\x15&\xD1\x1BmM\"\x16\xE34\x07\xEET\xBC\xA7Z\xD6\xAA\x8D\xE8\xEE3`{\x8F\x19\xD7\xD2\xB0vo\xCC\\\x8D\xF2\xC7x\xD8\f,\xF8\x8B\xFE\xB0\xDF\xA6\xF4\x82\x134\xEBQ\xD9\x06Et\xE7I\x8D\xBF\x04y\x02\xB3\x12d\x1D\x9FsWR\x86?\x9A\x03\x7F(\x1A\xC0X\xDD\x88\x86\x8F\xE3\x94\xE3\xEF\xF2\x81\x8Fu\x06.\v\xFEdm!\x8E\xBF\x91\xF1g\xC7Mk\xAC~\xE4\xAA\xFDV\xFC\x15m\xD8=i\x99\xA6<N\xDD\xB4\xB4\xD7\x9A\xCE\x89\xBF\xA2\xE8I\x83?h\x18E\xA9F\xD2\xDC\xE8m\xA4 \xA9\bud\xAD\x15\x94P%\x84|JW\xC1\xF9\x83 \xB7 \x17x\xC9\x0F\xE4\xF0\x93\x13$\xC3a\xD1\xF7\rH)Z\xF4\xDA\xE9\x96\xD5\x00\xBAe\xB6E\xAAAI\x9E\x03\xCB\xF8\x95\x91\xCFs\xCD\xDAF\x06WG\xB6\xFE\xA7\xB4\x89\n\x0F'A\x9B\xA9\xA1\x1D\xDE\x88\xD2T.c?\x88{\x98\x16d\xCD\xBFOP\xF7j\xC4z\x86\xA3\xE8\x8Di\xC0\xA3p\xEF\xDE\xF9\x84,-D,\x910\x9D1s\xFC\x1EJ=\xDB\rW\xC8\x98NnxL0f\xC91\xE8\xDDk\r\x12s_\xA3\x8FU\xA36\x82Q\xA2!{\xFC\x0E\xA0\xF7$\xE9?\x7F\xBF:\x17\x15\xCD\xE4\tn\xDBo\xA6 \xB1\x99\xD4\x1D=eq\x9Dj'Q\v\xEB.S\xD3@\xD5,\x12\xCAX\x82sr\xF3\x98\x80h\xCE\x1C\xF9\xBFNq\x16'\x956\xA25\xE6\xD8<\x15\xDB\xEA\xA0\x1A\xBCv\"g\x87\xBC\rCd\x12-\xEB&\x8Bi\xAE\xE5@\xCDn\xAE\n\xD3<l<\x96n\xB4\x12M?\x8C\xF3\v[\xE7\x80\xB0n\xA0\xAB\x03\xF6\x87\x06,\xFBQ8\xCC\xBB\x12\x17\x92\xDCa\x8A\x13 K\x8A'w\x89\xA9\x92=B~\xD0\xC8\nU\x8C<W\xA5\x98\x93;\x1F\x01\t\x16g[]\xA4\x18p,n\xE3\xEB\x95G\x907\xDB\x92\xDFx\xC4\\\xB2e\xDF\xBA\xEA<Qt]$\xB3w\x8C\xE5Lvzs\xDE\xC8R\xF2\xDB0C\xCE\xD8\xAF\xDA\x94E\xEB~G\xF4k\xB4I\xCD</\b\xEE\x95\xDA\v\xB2X.\xF5\x9E\xA5Fp\xC40\xC3m\xFDG\xE6d\xF5_\x9Ef\xDEx\x18 R\xC0\x1F\xE1\xD5Y\xCF0\vK\x91\x0F_\xE8(\xE4\x7F:y\x89\x90Qc\xC9[\xE1\xD5\xFA8Yt-\xE0hC/<\x1FNd+\x18\xCA\x04\xE0\x1C\xBB\x03\xF5\xFD\xC0r\x14\xF6\xEB\xD1\x95\x00\x96W\x1A\xD36\xFBV3\xF3\xA5E\x98T\xFB\x81\x8D\x16\r\x94\xFB/M\xEFf\x16\xE9\xCD\x04?3\xBB\xD0\x1D\xB6\xC9f\xD4\xA6\xC7\xF2gNpW\xA8\xB2\x82?\fO'\\\x8E\xC2\x0Fdli\xE5o\x93\xE8\x85c\xB5\xDD= >\x1E\xCA\x8AW6\xE9[\xFA\xAD\xCC\xCD5\x15\xCBB<=\x8C\xBF\xEA\x06\xC0\xD3^\xDE+\xCA5Mg\xEF\xCES\f\x94\xCB\xF5\x83\t\x9D\x9EV\x15\x1A^7\x9C\xED]m\xD9\x13\xE4\n\xC0\xD3\xB6\x14\xA5A`=\x83\x8F\xA9\x03/\xAB5@\xC2\xF9\xB3g-O\xA0;\x104\x9C\xB1\xC2K\xC6\xAEaR\xDD\xE4e\xACS\x93.\xBD\x9C\x94\x95*\x97Ga\xC2z\x16\x1E\xBA+n7\xCD\x89\xC8\xB9c\xFD\xFF\x80l\x124 8\xE3\xB2\x10\xFE\x07\nL\xC7\x03:\x8D\xEA9\x1DLa\xB1\xEB\x02\xFAm\x14\x05\x19\x90t8\x1E\xAF\x1Ey\xCA@\x98\xBA\x1Bp\x7F8qP\x94k\xE2/T\x195\xFC$\xCA]\xBAo\x9B\xE1\x8F,\xC0$\xF2\xC7^\x88g{\xC9\xAEc(\x9E\xE0\b\x9B\x84\x9A\x84I\xB0\xB2\xB2\xC0\x86\xBF\xE5u/5\xA2\x86\xA1\xBD7\x13\x7F&\x9A\xF2\xB2\xF1'\xCB\x99\xB1\xDB\xB0\xB4l\xFC\xB9\xA9z\x87,\xD3\xE8\x18\xC5r\xF6\xD3\xFD(\xFCP\xEAa\xEA+\xAB\x99\xBDo\xE2\xCF\x8C\x86T\xF7\xA1.\xC3\xB9f,0]\xD2\xAF\xEE\x03\n\xA4\xF5\xF4\xE5\x8B\x96\x84d\x8DMQ\xB9\xC3\xBD\xA9\xBCW\xB0\xE5\xB9u\xFC\xC9\xEA\x1B&\xFE\x94r\xA0`\b\xDD \xF7\xEE\xCF.\x1E\xC2\x86\x8B\xBBm)\x1CA\xCE'\x1D\xB2\xE0\xEF\xFF\x98\xF8+g\xA8\x9By\xE9\x10\x8E\x17\xD9\xF0\xD7-\xAEa\xA2iz0\v\x7F\xB2\xD8\x17'N\xFF$\xFC\x95%\x04D\x93|\xEBq\x81?G\xBB\x84\xCE\xDC\x86 \x8E\xA3\xD0\xB4-y\xF2\x04\xB7R\xD5F\xCE\xB6j\xC3\x9F~\x1Bs\x83\xE4f\xC0-\xED\xFD\xE35\x87\x92\x9C\xFA\v\x92}/\xEFx\xA0[P\xFENO\xCA\xB7_'!\xB6N/\x8E\xA2\xC6E\xD2\x06u\xA7\xE2\xF5\xD9\xE37-|\xEA\xB3\x04M\xD8\x90\x85\xEC\xE9\xA6\xC7m\xE1\xD0\xAFl=\xAC\xC1\xD3\x93\xB0\xBAV'ET\xA2\xCB\\\x80\xCD$\xBDIs\x06=\x9D\xEC\xC9\x9C \xAD8\x15\xE7\xF3Qa\x14\x86\xF9s\xF0\xDFn\xA2\x9E\xE3\x12\x7F\xF3G\x92\xA8\xA1\xEE\f\xF9G$\xFE\x16\xD1\xA9\xE4\x1F\xCF\xBE\xD0\x93\xC6{\xA3WX4\x94\x10\xF0\xFF\xB2\xF7\xF7\xE1q\x94\xE7\xBD8~\xCF\xEC\n\xAD\xC4\xCB\xAE\x84)>\xF9\x19k\xB5\x96m,N\xC0&\xBF$$1\xDA\x951\xB1\xA5\xB4\xB1%,\x9C\xA4$\xE8\xE4\xB4Ws\xD2\x9ESL\xD3\x82Il\x8Dd\x07K\x82+\x96e\x99\xD0\x94\xE0\xC5\x98`\x89&Ns\x9A\xE6\r\xEC\xE5%\x98pz\x12\x9A&9\xF9r\x92 \xA8I\x88\xDB\xC4\xB2\x81 \xD9\xB2\xF6{\xCD33\xCF\xDB<\xCF\xBCH\v\xC4|\xEF\xCF\x1Fs\xADvG\xCF\xDCs\xEF\xB33\xCFg>\xF7K\xD5\xB9\x8F\xED\xBC\xDBiph\xDF\xE7\xABR\xAC\xB2'\x19y\x15i\x8EG\x82F'\xACsk\xF7)TF\x13\xC0\xAC]\x05\xA9,)@q)\x8C\xD3]\n\x0Fg\xF9\xE5\xC6\xAD\xFF\xB8h\x12&\xC6\x84zF\x07,2|\x9A\xAEM\x92r\xAEk\x1F\xACtF!\x85o\xA5';l\x14'\x98\xB6\xCF5\xFC\x9C~\xA7\xEA\xC1O\xAD\x9A\x1A7F\xB8%\x97\x82\t+\xFD\x94\xB4\xEA1I\xF7!>\x10W\\,\xB5d\xEDAM7^\xE5\xA7;\x7F5I\xA3v\x13\x1B\x00jF\x9B\x9D\x1A\xF66{\x078\xE7\x00\xC0;\x1Ds\r\xD3#\xC1\xE4Q]\n\x9A\xAD\xD4C\xC76\xF8\xEF\xBF\x9D\x00\x17\x8C5\x93z\xFF\xED\x16)\x82\xEF}\xD4\xFE%zUi.\x02<}W1\x05_\xF8J\xD1K/v\x1F\xC7$\x8E\x01\xD4PjT%\x91$c\x8C\x8Cl\xBF\x12\xD6NBq\xC9S\xEE\n\xD6\x18s]r\xBEk\xC6'\xAD\xF4\xE81\xEFI\xD1\x01h\xB7\x92\xEC\xDF\fzn\xB6\x05\xF2\xEF\xF7\x005\xDC\xDE\xC5\xA3\xBEcCM\\\xF7\xCF\x17\x00j?|\xFD\x8F\xBF\xE8\x84\n\xD9T\xB5\xEAC\x00\xE7\x8F\xB3\x07\x9C\x89\x9F\xB8\x9B\xDA\x03\xF0N\xAB\xE6C\xD7\xEF\xF1\xDF?\xAE\x07H\xFC\xF1O\xC8e\xF3U\xEB\xFCO\xC0;Y\xF6\n{\x12\xFD\xF6n\x80\xAEo}\xF2\x00\xBC\xFA\x0F\xDD\x84P\xBA\xF8:\xA9\v\riZ\x14\xE5\x1C\xA9<\x8A\xF9\x13xg7=\x10\xF7\xBB\xE6\xF7[l\xB9\xA7\xFA\x13\xD7\xF0s~\xEA\xA4E\xFE\xDC\xAA\xF9\xB0\xFBoW\xFF\xE5\x87`\x8FU\xF3!\xC1p:\xA8\x1C\x9CA\xF7\xBB\xBA\xDB\xB8\x8B\xB9\xF3\xEB\x0F|\xF2\xAB\x9AH\x0E\x04\xE2\xF7\t\x8Dk5!\xBF\xAF\x17L\xF0J\n\x19rg`pI\xACif\xFB\xC5\x9C\xDE~\x8Ei\xA7\xFAh\xD8\v\x00\xE4\xEC\x05A\xAE>\t\x19\xD2<\x98\xDC\x98Y\xB3\x94y\x00\x85\x94IY\x87\tE\xC8x-x\\\xBA\x9E\x12o%\xB5\xE4U\x15@\x7F\xA4\x06p\xE7\xDF\xFF\x12@\xD53o\xA0\xFF\x12\xE3\x00\x7F\xB6\xA0\xE8p\xCE,)\xCB\xE2-q\xBC\xD6\x15\xF9\x17.\xEDw\xF39\xDDE\xD1\x98\xE0\xBFI\xCE\x7F\xA7\xED\x05`\xAE\xBEj\x92\xFA\xCF\x98f\xFE\xFB\xF3\x86\x1F\\\xF3\xD2\xC9\xDC\xD2\t8Mn@\x87\x8A0|\xEA\xEA\x9DE7\xEAj\xA5\xC5\xBAH\xBAa\x88\x9F\x84\xF4\xE9\x97\xE0\xA2\x8296\xB67BE\xB4\x9A\xCD\x1F\x03\xA8\xBD\xF4\r\x9E\x7Fkw\x93\x8E\x94\xE3\x89\x19V\xDCj\x18\xC0\\\xEB\b\xC3M;O\xCF@\x13\xFDQ4Y^\x88%\xA9\xF2\x9F?^t[\xFA\x12Z\xB9\xD1^\x90~\xE7\xB7\xD7\xCC\x90.Eda\xCD\x12\xE3\xBAL\xF3\xD6\xFE+\xC6\xF6\x0F9q\x87ccVb\xEB\xD8W\x06\x8B\xEER\xF22\xAEh\xB8\xFB\xA4\xF7\xB0U\xD3|\xC8\xFE\xF2\x8E\x95\xF7DH\x9C?\xFF\x7F\x9D|\x83\xE7\x1F\t6?\xE4\xD4\xA11\xD72F\xCF\xCF\xBFc\xCB6@~\xDC\xF8\xAD\xF7\x1F\xE6\xBD\xCE\xABs\v\x16\xC0\x7F\xBE\xE3*\x80\xCB\xBD{\xE3\xD8\x96,@\xEE\x0F\x1E8\xB5z\x18j\xEAI\xD1\x96,7\xFF\xF2\xC7\x1F\xFA\xED\xAB\xF9_M\x00QX\xCB\x87\xC7\x8D\xD4\xB3_\xFF\xCD7\xE1\x87\xE4\xE3\xFF?\xCB\x89\x83\x84\xF3\xB4(i\xA5?\xFD\x14\xD4Z\xC6\xC7:\xAF\x8E\xD0\x9D\xBF\xE6\xB6{\xFD\x150_\xDFg\xE6E\x80\xAF\x11\xF1o\xB1=\xFF\x9A\x94\xF3\xEF;\xF6\x07n\xC4*7\xFF\xDE\xF5\xE0\x04\xC0\xFF\xEF\x97\x07\x00\xDE\xE6\xF9o\xE3\x86\"@\xF9[\x97?D\xE7\x1F\xDF\xC0\xA6<\xFC\xFE\xB6\x03\x9F\xECK\xBA\x1D\x9C\xC7\x9A-c\xFA\xA0\xBD\x12f\xF3\xAF\x871H\xB2\x90\xB6jr\x87\xA0\xBE`\x1E8\xF8@\x84\xB4\xE5\xF3\x1F\x9Fx\x83\xE7\xDF\xE2,\xC0s\xFF\xE4\xB4\xF31\xDB\xD9\xFC\xFB\x8E\x05\xE6o\x9D\n\xD4\v\x8F\x8Du\xC2\xC2q/1\xA4\xA5h~\xDB\xA3\xABd\xFE\x1D\xE0\xDA\x8D\x0F\xFE\xA9=\xFF.>zl\xF5\xFF\x84\xDA\xB1\x1F\x11\x1E\xBF\x8C\x1El\xE4\x81\xCB\x86\x9F:\xBC\xF7\xC8\x84\x13<y\xAA\xC5\x82\xB1SW\x1F\xF4\xCA<\xB7dI\xD3\x18^)\xFC\xA4\x95~\xF9\x98=\xF9\x9F\xBE\xED\x91\b\xF3\xEF\x9Co}L\xF10\xF8\xF5\xC4\x95\xDD\x00_#\x01\xE8\xCB\xBA\xED\xF9Wd\xB7?\xA3\xC9\xA9:\x9CYwz\x06\x16e=&\x92\x1B\xF7\x92\x99\xDF}p\x12\xE0\xDCU\x93^\x01~\x00\xB8\xE9\x91\"\xC0\x96\xF7|e\xEC?\x9E\xB5\xCE\xBF\xEE\x93\xE4\xFE\x91\xA7\x07\xEB\xA9\xED\xFB/\x87\xFE\xC4\xBE\xED\x90\xAE)\x8Bk\np W\x9B\x9Bt\xFD\x7F\xEE8\xD7\x85\xD8\x99\xFB{\xA0\xF6\xC0!\xC8e\xCD\x7F\x8C6\xFF\xEE \xE9\x98o\xF4\xFC\xFB\x86}k\xCB\x97\xCC~6\xFFz\xD8/\xAF\xE1{f?,\xA1\xF3/\x9F\xF5\xA2@R\x9F\xCD\x02\xBC\xF3\xED\x19\xAEwpv^\x11\xE0G_\xFE\xF3\xD3\xD7\x8F@\x8A\xA4\xD5\xF3\xF3\xAF\xF9\xCA\xBF\xF8\xC2\x0F\x0F\x1F>>\xE9p\xF13-\xD9\xC4\xCC\xA9\x87\x0F\xF6\xBB\xD4\x9C\x14\v\x14\x95\xEA\xC3`\xDE\xFFCh.&\x8E\x9E\x8A2\xFF\x12\x9F\xFC\x88\xB6\xDC\xE9\xEBw\xFDs\x12\xFB/*\x98\xDFf\xC5\xE9R\xA4r\xB3C\x8E/\xEB\xFC64g\xBD\xDA\xE8\xF5E\xD3]\xC9T\xA7\xC6\x01\xCEKd\x81\xF6@\x87\xE7\x8E\x8F\x03,\x9F\x7F\x8E\xF9'\xA3\x90\xEE\xEB#\x81\xEAl\xFE\xB5\xD4\xF6=\xFF\xB5?\xD9C\xD3\xDAH\x9F\xB5\x1D\xC5~\xF7\xD9\x8A\xC934\xE7\xAEcY\xE9\xC9\x05pe\xD1\x1C;\x18\xA5T\xF5y\x7F\xF7K\x7F\x05\xFE\xD7\xFD\xFE;y8\xEB\xDCW\xBFO\xE2\x0E\xE9\xFDw\x89S\x1C\xEC=\xBF\xF9\xDE\xF7\xEDO\xDD_\xED\x92\xEE\x84\xFBp\xF9\xAA_\xCD\x07x\xC7\x7FL\x02\xBCC\x98\x1B?x\xF0\xD7\xA7V\xF7X\xA9Ig\x0E\x95\xE8\xFD\xE3\xD1\x7F\xFA\xEF_\xB8\xF7+V\xCDZ'\xEEz\xEC\x81\xAC\xD9y\xF0\xC0\xD3\xEEc/x{\xD1-\x9B\xC0\xD6/cVU\xE7>\xC8u\x9B_\x1B\xDB1\x8E\xF4\n\xF1{\x82\xA1y\x92\xDC*Jy\x191qR\x11\xA0\x9C\x95\xEBJ\xB95\x93\xDD\xA8\xEA\x9C\xF4I\xCA\x84!\x00\xD3\xA0Q\xC6\xDC\xA3\xCC\x00\xBA\x9D\x81\xE8\xA9\xC4o$\x12\xBFp\x1B\x0F\x9D\xEB%l\x89R\xDE\xAF\xEA\x85\x93z\xD6?B\x01\xC0\xBCU\xE3\xBF\xE4\x04|[p\xFF/\x0E\x7F\xF9\xB1\x9B\x9F\x018w\xAA\x05\xE0\xDC[\xE1\x1B\xEE\xC1I\x03\xB9S\x01\xE5`\xEA\xEC\x15-\xE1\x9D\xD5\xF4\x1Ep~\t`\xC1\x9B\xED\xC0\xFD\x7F\xEB.A/uo\xD6\xE2\xFC\xEB\xAD\x11\xF6\xDE\xE9\x9F\"\xD3\x00\xD5bd\xB5SJ\xC6\xDE$-\xB1f\x929\xBC\xEF\xC0e\x83\xF7\x02\xD4\xDE\xF14\x11\t\xDDO\xC9\xAA\xADvl\x9F\xDE\xCC\xAB\xC1[\xD1\xD2\xAA\x93\xAB\xAF,H%]\xDE\x8C\xF97\xF97 \xCE?\x91\xDD\xFD\xAAAx\xD8\xF0\xAC\xDF\xDC\xED '\xA7Vulp7\xE9I\xEF\xD9\xBA\xB7\x96z\xE5P-)\xD2:\xD5\f\x90^K\v\xD7x\x99\x9DZ,\x1B\xF7\xEA\xE2\xA4\xBD\x01\xCB\x17\x8F\xBBu]\xDED\x18\xD7\x8FZ\xFC\xFC{\xC9\xA9\t\xCD\xE6_}!x\xFE\xD9\x8BY\xC9\x7F\xB5cc\xEE\xC6(8]\x8E\x99X\xD2\xB6\xE7\xF8\xD4m\x00Uw|\x1B\xA0\xEAV\xB7W2T]JZM\xFE\x89\xDEN\x9BQ9;\xAF\xF4V\xFF]\xEF-2\x96\xFA\xA6\xCD\xBF\x9F=\x07l\n\x80\xD9\x02\x17\v.*\x8B\xF3\xEF\x94\xDF\x7F9_\xD0\xC59C\x93\x00\x89\xE7\xA7\x9D\x9E\xCA\xE2\xEF\xB7\xD8\\E\x8A\xD8M5\xB9\xA2\xA8\xE3\xF1I\xAF\x82\x9E\xF6{\xA6\x8C\xFE\"\xEF\xF7\xF1\xDA\xE7Ko\xFE\xFD\xC3\xEC\xFCG7^\x88\xCC\xB3\xC4\v\xB0R\xF8\xFD\x0E\x88\xF3oL9\xFF\xC4\x92\xD3p\xEET\xD2\xFE\xFDv\x12\xC7\nw\x9C\xC4\xC7\x9E\xFB\xC6\xB1\xD3\x9F\x048\xFF\xFE\x19\x80\xF3\xBF\t\xEE\x03\x8A\xF3I=\x9Dk>\x11|\xFD\xFB(\xF1\x17%\x117\xDCS\x847=\xE27\xF1\v\xB7\xB1\x8A\xF3\xAC\xCA\xD8\xC0\xEEo\x04\xBF\x11\xE7\x9F\xC2\xDC\xB5\xA4{\xAC\xF0\x9D\xD4M\xDB\xFE{\x16\xA0f\xAD<\xFF\x0E\x8C}y\xEC\xDB\xF6\xC4<@R\xF2\x0Fr\xF7\xDF\xC0\xF9\xB7\x98^\xEB\x16\xD3\xF9\xF7\x8Dq\xC6\x12\xDE\xB4\xF9\xB7\xFE\x1F\xDD\x8B>\x99C\xC6\x87\xB8\xAA\xCA\xE4~2,<l\xF0\x13:7\\\x87G\xF5\xC9&\x80\x9A\x1Fv\x92\xDF\xAFp\xC7It\xFE\xF4\x9F\xC6\x1E\xFA8\xC0\xF9\xBB6\x10\xA5\xF4\xA7\xCE\xA7\xE7\xAF\xB57\xE7\xAE\r\x9E\x7F_,y\xAF\x9C'\xCC\x97\xC0\x9B?\xFF`k\x83[\xD9\x83\xF8/\xF1Ki\xFE\xFDv\x9F\xE0\xBFo\xF8\xCD\xED\x078O\xF4_\xB2\xFE\xEF\x01j\xAFtjM\x9E\x16\xEF\xBF\xE5C;\xFF\xE7\x7F\x00\xA4\xBF7\r\x90\x9EO\xEF\xBF\xF6/7\xFD\x8E\x99\xE0\xF9'\xBDzn\xD7\xEF\xC1\xFCC \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x84\x88\xA9\x96\x02\xC0\x14@\xE2\xE8T\xCB\xBA!\xEF\xBDu\xBB\x8F\x92\r\xD8\x9B\x93\x0F\x17\x01NZ\xE0n\bN>\\L<M>\x10Fq7\x1E\x12G\xC1\xFE\xC0\xF9\x0F\v|\xA3\xE8m\x814\xB5\xA5\xE0\x99FlQ\x8C\xE2\xB3e\xDD\x907\n7\xB2=\x8Am\x8B\xBDQ\xDA\xB2\xB2\x98x\x9A\xD9\xD2\xD3P\x02\xE8\x010\xA6{\xA0z\xC2}\xD5P2\xA6\xA1\xE1\xC8\x04gn\x8Dio\x00\xA0\xA9\xC6,\xB86\xDB\xAF\xC8\x9FM`o\xEA\xB7\x17\x01\xEA\xED\x03\xD5\xD3\xA3\xD9\xEF\xB5\x93\x0F\xDC\xFF\xE8\x06\xA8\xB1?\xAD\x11\x9C\xB3\x04\xEC\x0F\x9C\xFF\xB0?\xB8\x90nT\xE0l\x01`\xB6x\xA6\x11[\xA8\x19z[\x12\xA5\tH\xDB\x0EI\xD3\x91\xD3\x89\x12\xAC\xB47\x00\xF6\x86\xFC\xEF\x1F\xD0\x8D\x83\xAA\"|\x84\xD9b@\xC1\xDE\x00$\r\x80\x8C\xF7\xAA\x00I\x80B\x867\xD7;\xF3%5}\xDDw\xBB\x1F\xF4u\xDFM\xFE\xB4O\xFF\xEE%\xF5\xDB\xC7}g~\xE1\xF6q\xF8\xA0\xBD\xF1\xFE\xC3=sgCa\x7F\x01\xDE\x7F(\xCE\\\xF6\x9F}n\xDE\x99O\x88g>a\x9F\xF9\xC4J\xD5\x99\xFF\xC1g\x8B\xF0\x11{\xE3\xFE\x87\xEDl\xEF[\x00\xF1[\x00 \x06-T\xD9\x92,B;\xE7\xBF\xA4\xEB\xBF\xD5u`d\xA0\x8E\xBCJ\x16`5$[=\xFF\xD5\xDB\xAE;\xAF\x00\xE4\xD3'V\x9Cw\x8D\xFB\x81\xFD\x8A\xFC\xF9\x04\xD8\x9B\xFA~o\xFE\xE5\xE8\xD1r\xFDE\x18\xB47\xEEP\xE7u\x03\xD4\xD9\x9F\xAE\x10\x9C\xF3$\x9C\xE7\x9F\x7F\x8B\xB4\xFEc\xB6@\x82\xDAR\xF0L\xB3mag\xAE\xB7\xE5\xFC\xC7o\x82\x8B\x01\xE0g\xEF\xA6#\xBF\xFB\xFC\x12\xFC\xCC\xDE\x00\x9C/\xCC\xBF%\xCC\x96\x9A\"|A\xF2\x1F\xF1Z\xD9JOB\xD9\x82\xC4\x8C\xCF\x7F\xF6._-\x004\x02$\x92\x8F.\xFFC\xF7\x83G\x97\xFF\xE1\x85I\xB2\x01{s\xE1W\x8B\xAE\xB9\x8F\xD1\xA3=\xF6\xD5b\xA2\xF6\xB1\xAFz6\xD7-wF\x01xT\xB8\xFE%ay\x81\xF7\x9F4\x8A\x84\x8B\x97S[\xE0<jK\xC13\xCD\xB6E5\x8A\xCF\x96?\xCCx\xA3xpG\xB1m\xB17J[\x96\x17\x13\xB5\xCC\x96\xBA\xFC\xB8\xFD\xBB\x85\xC4\f{\xAF|x<1\x03\xF9\xE3\x93\xCE\x9Fm\x87K\x8E\x8B\x9D\x93\xEE\xB9\xE4\xC8M\xEE\x8E\x99\xD5\xCE\xB0Yh(A\x96\x1D(\xCF\x8E\x96\xCA\xF2gN\xA6\x9E3\x8A\xEEF\xB5H5\x8A\b\xCE\x16\xA8\xA6\xB6x_@T[.\x06\x85-\xC2(py\x843\"\x0E\xB3<[n\x060\x9E\xE2F\xB1\xD1jo\x1A\xED\xF1\xEC\x9F\xFA\xB4\x91l]\xEF\xDD{\x8E\x14\xB3\xB9\xF4\x8E\x13\xD3\xD0\xB0\xE3\xE5\x99U;\xC7mW\xDA\xA0G\xCB\xEF\x1C\x87L\xAE\xBA\xE4\xFE\xE9\x8D\xE2\\2\x18\xB2\x90\xF6\xFEe\x95\x05\xBEQ$p\xB6\x80\xB1\x9E\xDD\x07m[&\xC0\xB1E1\x8A\xCF\x96#7y\xA3\xF0w\xD3l\x8E\xD8\xD2`ilI\x8FC\x86\xF3\x9FhK=\x00l%\xA3\x00\xB1\x85\xF8\xCF\xDE\xE5Q{'r\xA9\xDCz\xD5\x07]\x9B[3\xAB\x9FY\xDF\x95i-\xAC\x87\x8C\xD9\x98\xEC\xB3\xB2\xEE\xD1\xF2\xCC1\xFDY\xB8\xB4\x8B~e\xDE(\x00[\x05\x8F\xACg_Y\x1F\xB59\xAF\x9B\xA2\x9C-p\x01\xB5\xA5\x00\xC4\x16\x80\x8C\x99\xDD\xAE\x1A\xC5gKk\xC6\x1B\x85N\x15g\x14\xDB\x96\x8C\xCE\x96T\x16.\xE5&\xACh\xCB\x8B\x00\x89\xFDd\x14 \xB6\x90\xD9\xE9|^pF\x99\xCE/X\xB3\xDC\xFDB\xD3\x8F\x0F\xDC\xD9\xBF\xF3\xF6\x15wB\xFA\xC8\xC4\xA4i\xFB\xAF\xC1\xFB\xEE\xDC_\xC1\x8Eqx\xB2\x7FG\x89\xBF\xDB\xE7}\xCE1\xEEd\xF3\xCF\xA4\x034\xE8\xE6\x1Fg\vTS[J\x86m\xCBr\xB0m\xB9U5\x8A\xCF\x96\xD6\x8C7\n\x9D\xA2\xCE(\xF6\xBF\xA4K\x1A[\xAA\xC7\xE1I\xEEZg\t\xB6\xDCj\x81\xF1S2\n\xA4o_\xCE\x99\x8B@ \xCEb\xFE\xEBl\x04\xBA\xC9H\xEB)5Q$\x9C3\x80\xFAJ\xA3\xF4\x88\x1Bo\x1DaLs\x97\x1BF7]~\xA9\xA6\x9B~\x8E\xED~\xC0\xCC\xF5#q\xCC\xCF\xB1\xFD\xE62[T\xE6\x8A`\xEC\xD8#]<\xDDd\xA4\xAB\xD6\x12\x98\x83Kt\xC6\x1D\xFE&\x91V\x90\xE8\x12\x1B\xC5\x107.\b\x97T\xD1M\x97_\xFA\xE9f\t\xE0\\\xFB\xD5\xB9\xE2\xC9\x9Ck\x96xs\x15hVpl\x9F\xB9\x9C-*s\xFDw:b.\xE1\xFBmV\xD2\xA5\xBEm\xC3\xDD\xC6\x12\xA8\xEF\xE6\r\"\xAE\xEBd\xA6\xCD+\x02t\x8EP\xBAT\xEF\x19\xD4F\xF7h\xAB/\x18MP\xEF\xF7\xDFb\xEED\n0\x12\xD3\x7Fj\x8E\xED|\xF0f\xF9\xAF\xCD\x99\xB1\xE9\t\xE5\x99\xD7R\xD7\xCD\x04\xFA\xAF\x8D\xCE{\xAD\xFF\x16\xD3\x05}\xB0\xFF\xCA\x87\x1D~\x94\x98\x91\xFD\x97/\xB9']\x16O\xA6\x9C\x0F\x99\x7F\xFC\xEFW5J9_JL\xAB\xFCW\xB6B\xFD\xD7\xEA\xB3%1\r\xD4\xA0\x0FX\x1Es\xE0\x90/\x02\xCC\x1C\xF6\xFC\xD7f\xEF\x1C<\xCAb\xE7Q\x8C4\xCA8O-!\xEF\\\x0F\x123)\xD3\xE5\x04Y\x89n\x1A\xA9\x82{\xD2\x8D\x12mI\x15\xF85\xA6\x02\xFCs\x01\xC5(\xF6\x00\xDBU\xFF\x97\xD3\xCE?jnYK7)\xE9\x9A\t$\x8A\xAD\xE2%W5\xCAb\x8EKjv)\xF7\xB9\xBBd=\x1An<\x95\xAA/@\x16<wr'\xAD\xBD\xAC\xCFX\xA1\xF7K\xE5(\x92-\x96\xC2\\y\xFEy\xBB\xB4:\x7F\ntS\"\xAD\xCE\x93\"\x81(\x02\xA3\x9B\x84\x05\xB6\x8AW\vi\x94\xC5\xCE\xEDB\xBC\xA0\x90]\xD8wb\x8F\xB2V\xA0\xE12\xDDlT\x1C\xC8\x99%\xF4@9\x8D\xFF2\x12\xC7V\x9A+\xCE\xBA\xCE\xE0\xEB\x1Fe\xC7.i\x15\xE8&\xFB>f4D\x11\x18\xDD,+\xA8\xAF4J\x13\xF5\xDFV\xE1;_\xCF\x8D\xE9\xA3\xE1>\xBA\xB9T\xC3\xB1\xA1\x8B\x1E\xE8r\x8D\xFF8^\xDB\xA85W\xF4\x9F\xEA@ \xAC\x1E\x1Cs]\xD2*\xD0\xCD\x10\xD2Z=\x0E\x10L}\xA5Q\xC8D\x97\xD91\xD9E\xF4\x9F@\xC3}t\xB3Q\xCD\xB1\x01\x1C^\x1B4\xFF\x9E\x94\xFC\xA74W\xF4_>\xF0I\x07c\xC7\xC8 \x10\x88\xB3\x17\x84\xC9y\xAFl\xBAY\xE2\x89qd\xEDX&\xD0DJN\x0F\xC1\x99\xFC\xBAg\xE0\x8C\xFD\xC1\x19H?\xE3\xECr&_H\xBCr&o_\xA1\xED\xCD\xA9CE\x97\xB92\xFAz\xEAP1q\x8C|\xE0\xFD\x87\xF7j\x0E\xA7\xCA\xDB\xC2\xDE\xA3\xB6\xB8\xC7\xF5\xB1\xE8S\x96\xBD\x00o)\xF2\x16\xB0\r{\b\xE8-\xF7\xBD\x85z\xB8AZ\xBD\x16\\)y\b\x16\xD7\xACZ\xEF\xAC_\x16\x83\xE9\xDE\xE3\x16\xDB\xD4\xC3\xDE\x10\x12\x02\xCD\x83E\x80v\xDB\xE6vj\xB8\xFD\xDE\x18\xF9\xC0\xFD\x0F\x8FP.\xB6f\xEF?\xDE\x16\xF6\x1E\xB5\xC5;.g\x86\xF3\x9E\x050\x06\xB5E~1\xB6\x94n^w\xFF}\xFCC\xCEI/\xB6\xCC\x0F\xB9\x16\ft\xC3]\xF6\x06\xC0\xF6K\xF3\xE0\xB8Kt>@\r\xBFlp\x1C\xBEbo\xBC\xFF(\xF0\xD6\xCF\xDA\x7F\x8F\xDD\xC4\x9D\xB9\xB3(\xAA)\xC1=\xF6\xC6\xF5\xD5\x1DE\x80\x0F\x8A\xFE\xB3\x17E\xDF\x86s=\xFF-\xA5f,v5\xB9\xD9\xFBO\xA7\xD7\x82#%'2\xB0\xB8~\xF5\x90s\xA06H\x0Eq\xEC\xB8\x8D\xB0c{s\xD9\x88\xF7\x9D\x0FS\xC3;G\x8AF;\xE3\xD8\x8B\xE9\x03\x8D\xB69\xCC\xBF\xA5\x9C-\x02So\xA3L\xFD\xF2\x11\xFF\xFC\xEB\xB4\xC0h'\xA4_\x9A\x7F\xEB\xA45\x8DC7\xC7\xA3\xFB\xAFN\xA7\xD7\x82#%\x9F\x97\x81\xC5\xFB\xDB2\x8E\xB9\xBB\xA0\xC6\xDDeWS\xC1\\\xBD\xAB\xC9\xB6\xD9\xDE4\x1F(\xBA\xAEc\xF4u\xDF\x81\xA29\xB8\xEF\x00\xB5\xB9\xC9;\xC1]s\x99\x7FM\xCC\x16\x0F\x9C-d\xFEQ[\x18\xF6Y`\x0E\xC2\xA5\x82\xFF\xD8(=\x97\x94\xD4,\xD0\x88\xE0?\b\xD4k\xE9\xD1vA\x80\xA4K\xAE/\x8E\xEB\xB4\x1C\x9B]\xF5z\xE6\xE2?\xCE\x16\r\xF5m\xB6\x02\x9EBp\xBF_6\n\x89SP\x91\xD6\b\xFE\xD3\xEA\xB5.i\xAD\x9E\x806W\x8C\xF5ql&\xC6\xB6\x87\xCB\xCBm\r\xA5\xE8Vi\xC1\xDB\"P_F\xA09[\x18;\xB1l\x02\xCDl\x11\xC9\xFC\xD6\xAB\nj\xD2Z\x0E7H\xAB\xD7\xBA\xA4\xD5\xCC\xC2.W\x8C\x05\xBF\xA4\xEB\x89\xB1\xC3\xE1\xF2\xF2.zU\xDE:\x07\xFF\xF1\xB6\b\xD4\x97\x11hf\vC\xD6\xB2\t4g\x8B\xC0\x8E\xF3\v\nj\xD2\x1A\xE1\x9B\xD6\xEA\xB5.i\xAD\x9E`b,\xF8$]O\x8C\xCDE\x94\x97!\x90\x91B\x14s\x99-\x02\xF5\xE5\tt\xD6\xA7O\xDB\x7F>\xC9\xE6\x9F\x11\xCE\x8E\x11\b\xC4\xD9\x85\xC4+\x0E)$\x8C4\xC2cpG\x00u\"\x83E\x02}\xE4\x84\xF3P\xEC\f\x95e\xF5z-e\xB82D\xBA\xE9\xD7k\xDD@\xE6\xA8w:b\xAE 2\xF8\xE4e\xC6\x89\x83\xCD\x95\x98:\xC5=\x0E\xA9\xA9\xF1Vd!K?\x97\xBA\r)T\xDF!G*Z\\\xEB\x1Dw\x99\xF8\xBF\xCB\xE8\x07\xED\x94\xA1\xC9\xA8\x1D\xE7\x17m\xCB\xC4Q\x9C\x01\xE8(u\x10\xCD\xDC:\x81\x164\tL\x93g\x86\x1F\x10\xFF\xF7\x03\xF5\xDE\xAD\xA3}\xD8\xCF\xD4)F\x9C\x01l*}y\x04\xFF9\xE1\xADnd0{\x8F\x84\xB7\xAE\x0E&]m\xC3\xDD\xBCAJ\xD4\xFB\x97\xFB\x02\xE9r\xB9_d\xFFy\xD1\xB8$\x90\x8F`\xAD\x14\x8D\xCB\xFC\xD7&-\x1B\xE9\x81\x82\xFCg\xACt\xE8\xDC\x85Q\xE7\x1F\xB8+\xDE\x14\xE3\f&8z\x99\xB3TZ\xDC\\\xA0\xCF\xCC\x05\x8C\xD2\x0F\xDA\xC7t\xFEk.\xFAHC\xA34@s\x1C\xFF\x81\x10R\nb\\\xAE\xE4?\xAD\xBC\xDCn\xFF~M\xF5\xEF\xD7\\\xED\x90B\xC2H#\xF8\xCF\xE6\xC9)p\"\xABE\x02}\xFC\xB4c\x1A\t\x0F\x0E6h\xF8\xB0\xCE\x7F\xF9\"?\x19\x1AA\xD6\xBB\xED]J\xD1\xFD\xC7h=\xFD\xBA}\xF22\xA3U\x12\xCBb\xF2\xF2\x80w\xFD[\xA2\xF5\x10\r\x0F\x0EF\xCE\xFD.\xB3*.\x99\x91\xCC\b\x8E\x89\x0E\xE1\x88\x10*/\xE7\"\xDC?\xFAdIW-/\x07\x9B;C]\xA7\b\xE1\xCE\xE6\xE8j\xBB=\xFC\xB4R\x0E\xF5\xAD\x9A\xF4\xAB\xBE;\xDC\xFBo\xA3\x8E\xB4rz\xEDN\xDD\xFD\x83E3\x03(\xF5Z`L)\x82\xFF<y\x99\x1B\xC5'/\xEB\x9E\x9CH\xE6\xCAj\xB8\x87\xF5]t\xEE\fG\xF0\x9FC}\x93C~\xD5\xB7\xB5\xB0\xDE\xFDB5\xA4\xB5\x8B\x93\x97\xB3\xBA\xF1\xB3\xFCo_AZ\xB9I\x18\xC5\x7F>\xD5\xD7'//\xA2;\x07\xC8\xCBYm\b\xB7qg?\xF1\x9A\xC3H\xC3\x7F\x10\x8E\x00\x9A\xE8\xF6\xAB\xBE\xB7\xAF\xB83\x98\xB42\xBAij\xFD\x17H7\xF3ia\xFE\x95#~\xDD\xC2(\ny\x19\xC2\xCCU1u\x04\x02q\xF6BR<\xF5tS\xB7\xBC\f\xA0\x9B\x84\x1DW\x8B\xD1\xCC%w\x8D\x14\x01D\x96U\xE9\xB5@\xF5\xDA\xDE\xEC\xDA\f\xF4\x02\x98I\xF2\xCA}\xAF@\xFE\xACO\x82\xFD\xAA\xAFXt\x13f\xFA\xE8Y\xF6\x15\x8Bf-\xF9\xC0\xFB\x0F\xB0Gq7\xC0^eC3<\x18'\t\xA1K\xE2Z>\x1A\xDD\x1Cb\x91\xD5M\\L\xB4\x19-\xEF\x84\xC8\xB2*\xBD\x16j*\xED\xBFn\x80^\xFB\xD3^\xBA\x8B\xF3*\xDB\xFD\xE6\xF8\x8F\xB2\xE3z0\xB2\x02\xDD\xB4\x87JZ\x95\xF3\xDF'\xE6\xDB\xA7j\x9E\xD3[\xFC\xC4|\xF7\xBDb7\xF9\xF3m\xE7@\xB6\xDB<\xA7\xAF8\x0E\xB0\xCD>\xE26z\xD8m\xC5q\xF3\x82mEo\xF1\xD9[\x9C\xFD\xFC\x93~\xBF\x8B\xE9\x9A\xA1\xAC\xE0[\xF1\xE9\xE6\\\xB0\xB8\xBE\x00J\xBD\x96=:`\xF3oK\xC3\x9Ag\xC4\xF9W\xF7\n4\x14\x8CW\xB6\xDD\xEB\xCD\xBF\xDB\xE8Y\xDEvo\xD18v\xDB\xBD\xFE\xF9\xB7%\xF6\xFC[bs:F\xE7\x98\xEB\x1A\x15\x040*\xEA\x1C\xBAI\xD8q\xDA\x8D\x06\xE7\xE4\xE5\xFCx4\xFF5\x15@\xA9\xD7\x02\xD5k{\xEF]3\x04[\x00\x8C\xA34l\x1F6/,\x18G7/\\3D\x82\x01\x92}V\xD1u\x1D\xD3%M\xAB\b\xB5\xF6\xC6\x1Dea\x01\xECQx\xEA\xB1\x99l\x17\x86\x9F\xB9\xA8\xB4\x96\xE9\xCC\xD1\xD2\xCD\b\xC8\x81\x90<\vR\xF2l\xC4\xFBG\x04\xBD\xB6\x97\x9E4\x9F\xBD\xEC\xEE\xE2d/\xF7\x85\xCB\xCBd\xAE\x190+y9O8\x9DH\xD7\x95t\x93\xA3\x1E\xE1\xA3r\xEC\xD8\x10\xA3\x99c\xAC\xDE\xDB\x14I\xC5\x92H\xDD\xCBr}\xB9\xECe'c\xF8\xC444X\x89\x99\xBEpy\xB9Wu \xB2M\x87Z\x9A\xED\xCF\x02t\x89\xFES\xD2\xCD8\x8F;\x80c\xC7\x17\x88\xD1\xCC\x051\x9C;\b\xBB\xC2#\xAB\xB7\xB0\\_.{\xD9\xCD\x18^\x0F\x190\x92\xB7\x85\xCB\xCB[T\x07\x8A\xF8\xCBk\xD81\x0E\xD0o\t\xFES\xD2\xCDX\x8F\x8B8v\\-F3{\xAAo\x04D\x88\xAC\xE6r}\xB9\xECe'cx\xC5\x9D\xF6\x81f\x9B\xBD\x9C\x8F8\xFF\x10\b\xC4[\x01\xCE\xBA\xD3Y\x15\xA4\xEA\x93\xFCZ\xD4\xB9\x8A\xCE\x9EK\x92\xF7\xE8\x07\xD2\x00\xCA\xDBO\xC6\xBB\x8D\xB1,\xD7\x02\xA9\xA2Ds3\xD91z\xA5\xF3\x88u\xD2\x8AQ\xC8I\xABma\xCB(fK\x85\xFD\xD7X\x02\xD8a\xBF\xDAAG\xDEA\xDE\xA3\x1F\x90\xFF\xBD\xFD\xAD\xE7\xBF\xC6\x92\xB9\xC0=\xF3\xD4\xCD\v\xBC37\x17\x903\xB7\xFD\xB7\xA0\xEF\xBE\xA2{\xE6\xEC\xF4o\xBF\xAFh\xBE\xED\xF6\xFB<\xFF\xED\b\x9F\x7F\xB7G\x98\x7FioE\x96\x87\xC4\x04[\x06L\xBB\xF7\xEE\xC4\xC4t/]\xF9n\x16\x87\xDAl\xCD\xCA\x7F\x9B\xD9\x006\x81Q\xDBB\xC1\xD9\x02\xEC\xCC\xDD\xF9\xB7\x05\xAA\xFF\xE5\x15\xFF\xFC3^\xB9=\x02\x97\xA4\xD3\xACg.\xF3\xCF\xF4\xCCM\xD1e\xAF'/;K\xE1,;iYo\x8C=\xFF6CP:k!e\xB9\xB6p+\xB7\x94\x05\xFD\xF6\x86\x1F\xCAv\xBB\xC7\x023I\x9EK\xBA\x13w\xD6\\\xD2~\xCF\xD9P\xFF\xDD\x16\xE8\xBF\xBC#/\x93\xA5d\xDA\x15h\xF9\xF8\xEC\xF4\xE9\x192\xCD\x1A\x15\x0F$\xCBq\xFC\xC7\\\xA7M\xA7&\xB6\xE4$\xE6\x95\x17b\xC5e.\t\xD5\x9B~\xA4\xA0\x9BQ\xB8\xE4\x0EPp\xC9\x8CPI\xE2\xF6\xF0 c\xF0\x11h\x9F-Ja86\"\xC8\xCB\xBC-A\xBB\xF46\x94\x8C\xA7h\xA8\xF2\r<\x97t\xCEu\xF6\\\xD2~\x8F\x8Cb\x80P=I\xFFP\x83\x1BE\x95\x9A\\\xFD\xF2\x8C\x8A\xA9G\xE7\x97a|\x9FO\x07V\xD5\xF6\x12i8e\x81\x1B\xBCP\xE5\xEBFx.\xE9:{\xFBl\xB9\xA4=\x00\x19\x85|\x83\xB7E\xF0\x1F7\x8A*5\xD9lL\xAA\x84a\x82\xAE8\xFE\xD3\xC9\xCBB:pA\x93\xBD,',\x14 \xE7\x85*\xAF\xF8g\x9EK\xBA~\xBEu\xB6\\\xD2\xBEQ\x91Q\f\x10\x92\x8A\xC3\b\xB465\xB9zbR\x1B\x87\xDC\x1F\xE7\xFE\xAB\x91\x97\xF9t`\xDE\x16\xEE\xFE\xCB\xD3p\x04\x02q\xF6\xC2\xA3(|E\xBB\x82HQz\x03W\xA0\x00\xA1\x94\"\x88.\xF9l\x01\x91.9\xEFe\x14\x8C*#\xB1;\xF2g\x12\xF4\xEC\x0E$V\xE4\xF2U^\xFBtU\xB7T\x86/%M\xAAa;\xAF\n\xFC\x9F\x92\xFFzb\xFB\xEF\xF4\\\xFD'\xC9\xF3\xCC\x7F=\xE1\xFE\xEB\xA1\xE1\xDF\xAF\x8B\xFF\x04y\x99<\x12 l\x8C\xFFS\xA4x\xFC\xB2[\xA4x\xBD\x81w\xB0X\xFE\xDB,\xD2M\xA9\x8CcA\xF1t\xDA\r\xB8*\xF9\x18\xA9\xCF\xDC\xC7'\b;V\xF2\xDA\xD9\xF8\x8F\x93\x97\xDFv\x8E\xED\xB0s8y\xD9\xFE\x13\xC4\x1B\xB8V\x1C\xDA\x1C\xB8\x82\x02\b\xA5dl\x94`y9/\xAE\xF95\xE2JX\xF6\x14s]9\xDC\x7F[\xA0\xFA\x99\x90\xF9\xB7\xA5a\ry$`\xBC\xC2\xC9\xCB\xF6\x9F\x1E\x9Ds\x19\x06\x8B\x06\x97\xD2\x81\x8D\xC0\x15<@4J\x16E^\xA6\x87\xCC\xF1\xB6\xF0\x1F\xE4\xE9+\xAF\xD8\x98X\x9B9=\xC9}Qz\x17\xF3L\x9D\xD7\x8E]\xD5\xB7z\bz\xF7\xAEy\x86\xC8\xCB\xAF\x18\xDE\xA56\xB9\xA5\xA1`\xBC\xB2\xA5a\xCD3\xDE\xA5B\xAC>\xC5(\x80\x1B\x1E\x1C\x9D\x95G\xAD>\x15\"/\xD3\xA7\x1Al\x97\xDC\xFC\x12\xFF\x01\xC7H\xFD\xAA\xAF\xFCE\xF5\x04NQ\x8F\xEF\xABG\x11\xE4e\xF2H\x80\xD3\xB1\xB3t\xC3W\x9F\x92X ]bk\x9F\n\xB1Y\x92\xB3fM7y\xBF\xEC\xF5\x87MK\x01\xCF\xC0\x18\xA9\xA8\xFA\xB2\xBCcC\xC7\x8E\x05\xBE\x1F\xCC\xB1'$y\x99<\x12\xD8\xCA\xC9\xCB4\v\x82\xAB>%\xB1@\xFA},\xD2\x99\xC1\xE8\xE6\xE5\x11\xFD\x17&/\xFB\xC3\xA6\xA5\x80g`\x8CTT}Y\xDE\xB1\x96\x1D\x8B|?\x90cgEy\x99<\x12pu\xEC.7\xCA\xDBH2\xFF\xA9J&G\x98\x7F\x8CnF\x9D\x7Fa\xF2\xB2?l\xDA\x17\xF0L\x19\xA9\xA8\xFA\xF2y\xC7\xA1Y\xBA<SWslQ^&\x8F\x04\\\x1D\xDB\x91\x97\x01`\x12\xC9\x03\x02q\xF6\x8257:\xA5m(T\x91\x03\xF1m\x89\xD2\xBB\x8Fz\xD4\x8D\xD4\x89\xB6idz(\xB2-\xC1E\xA0\x83{,\xB1\xFB\xB9\xD0\xDC\x88\x95\xFFr\x83\xB4\xB5\x07b FF\x91t+\xE2?\x8EK\x8A\xF228rk*\x13\xD9\x16I^vt\x97\xC6\x12O#\xA3\xC9\xCB|\xC9%\x8F\xEF\xBB\x8B\xE9\b\x04\xDA\xB14BxpE\x1E\xB3\xF66>u\x93}\xD2\xE6\x02I^\x06\xB2\x81\xD4M\x10E^\xD6\x9D\x16{\x8A\x13G^\x9E&\xF2r^\xE0\xFB\x0E\xE9\xD7\xCA\xCB\x92\xFF\xA2\x84\x07Wd\xFE\xED`\\R\x94\x97![\xB0id*\x03\xB7G\xB4e\x87\x82W\xC4\x9B\x7F\x9E\xBC\x9CM\xD1\x14f*/;\xA4K+/\xCB\xF3/\x82\xA4[\x99\xDFo\x03\xE3\x92\x9E\xBCL\xB8$4\x90\x1FQ\xF53\x91m\xD9\xA2\xE0\x15[\x1A\x84F-\xD1\xE4\xE5\xC4\x8C\xD7\x1C\x8A\xF1}\x97\xF4k\xE5e\x10\x9F\x97D\r\x0F\x9E\xBB\xFF @^\xCE\xB23\x9F\x85\xBC,\"\xBE\xBC|\xB3`K\x86\xDC?\"\xC8\xCB${9\x8A\xA4[\xA1\xF9\xC7\xDA\x12\t\xF22\xA4-c\x9A,\xF7\xA3\xDA\xA2h\xB4\xC4e\xE9\xC6\x90\x97\xB9\xE6F\xBC-\r\x96\x9A\xA9\xCB\xCC\xDF\x99\xE8\x11$\xDDJ\x80\xE3\x92\xA2\xBC\xECV\x826\xB3\x91m\t.\x02\x1DC^f\xCD\x8D\x04[2\x1AaX\xF5\xBC)\x92\xA4[\t\xF0m\x89\x04y\xD9\xFE\xCE\xEF$\xF3/\xAA-\xC1E\xA0\xE3\xC8\xCB\xB4\xB9\x91`\x8B}\xFF\x8D@\xA0M\x94\x7F\x11\x88\xB7\x1E\x18\xFBT\xB1@\xA9[P\x84\xE81\x8Fn\x82\xBFXVh\xB5\xE9)\x85U2Z\x02\xD9qx/\xA6\x1E\xFAP[\xC5\x8Ec\x99\xEB\xF07KX\xB4\x85\x84\x07\x87\xFBO\x15A\x1CU^\xDE&.\xF7\x95\xC8\x16\x03\xCC\x05NR\x13\xCC(H\xA7\x90\xD1\xB0\xE3X\xE6\xB2\x15\x80d\x90><8\x82\xFF\x14\x11\xC4Q\xE5\xE5\xCD\x11\xFC\xB7P\xF0\x9F$/\x03'\xA9\t\xAE\xF3\xE5\x1A\x95\xD4\xEC8\x96\xB9\xD2\x83\xF8(\xE1\xC1\xE1\xFE{\xBD\xE5e\xFA\xFBU\xC9\xCB \xF6\x12\x8A`KTy\x19\x02\x17\x86\x00\x11\xC3\x83#\\P\xFD\xD5\xA7**/\xD7\x14\xF9Q\xE4\x16I\xE4\xEBV\xA40\xE7D&\xE7\x97\x97]v\xAC2ws\xC4;I\xD4\xF0\xE0\x10\xA6\xD9\xE7\x8F ~\xD3\xE4e\xF0\xDB\xE2xR%/\xEB\x84\xE1`J\x11\x9E\x0E\x9CU\xED\x1CL7\xD7BP\"\xEF\x9C\xE4\xE5\xC0bYR\xA82\xF1\x8B\xD4\xDCH\xCE\xF5\xD5\x97\xB5\x8EV\x9C\xB8K\xFCB#t\v\x82Ht\x13^'y\x99\xB2c\x95\xBC,\x85*\xAB\x9A\x1B\xF9r}\xB5e\xAD\xA3\x95\f\xED\x17\xCB!\x84\x85\x07G\xF3_p\"\xEF\x9C\xE4eq\xFE\x05\x87*\xAB\x9A\x1BI\xB9\xBE\x12;V\x99k I@ \xDE\xCA\xE0\x9B\x1B\t\xD4w\xCAin\x14T\xA0\xCAk(\x94x%Bs\xA3\xCA\x80\xB7%\xFD\xAF\xAF\xCC\xD2\x16m{\xA5\xF8}\x97\xBC\xF0L7'\x93Q_Vi\x8A\xF4\x1D!\x05Z\xEE\xA3\xBB\b\rI\xCC\xED\xA4\x07\xCA>\v\xDC\r\x81\xD4\x1C\xA52\xE0m\xA9\xAD\xDF>K[\xB4\xEDY>\xFF\xFA\xF8\xAF\x1B`\x97m\xCB}\xD4\xA0]\xFB\xBB\xCD\xF7\xEF\xDA\xEF\xD4=2o\xDFw`\x1C\xE0~\xFB\xD3\xFB\xE9.\xF7\x1F\x187?w\xFF\x81\xF1\xCA\xFAoq\xC9=\xCB\x07\xA1\xF6\xE6{\x9C\x93^\\2o\xF8\xFCb7{\xF9\x9E}\xA3E\x80/\xD9f|\x89\xDA\xF2\xA5\xD1\xA2\xF9\x85/\x8D\x16\xC3\xDC\xB4k\x0E\xFE\xDB\x12>\xFF\xB6\xA8\xE7\x9F\xF1\xCA\xFD\xF7z\xDF\xB9V\xD2\xAD\f>\xCF\xD9\xE2\xC9\xCB\x92-_\n\xB7\xA5\x92\xF3\xAF\xC1\t\x0F&z\xAD\v\x1A\xFB\xEB\x1Em\xAF?\xD7\xD7\xDD\xC5\xCB\x18\xDE\x17.\xE9Vh\xFE5\xF0\xD1\xCC\xC9Y\xDA\xA2\xF5_|\r\x8D\xD7k5\\rW\xE8.\xD9}\xE1\x92n\x85\xFC\x07\xA1\xD9\xCB\x11l\xF9|\xE5\f\xEA\xE5X\xA0@Zs\xB4d\xF2.]\x81*\x961\xBC/\\\xD2\xAD\xD4\xFC\xE3\xA3\x99o\x98\xA5-\xBB\xC2ixTl\xD1\xC5Dw\xD1\x92\xC9\xBA\\_\x9A1\x1C\xA9\xFATe D3\xCF!{9\x94\x86G\x85\xA1\x8B\x89\xEE\xDF\xE9\x95L\xD6\x16\xA8\xA2bl\x94\xEAS\x95\x81\x10\xCD<\x87\xEC\xE5P\x1A\x8E@ \xDE\xD2x\xED\x91q\x80\xD7\xEC_\xFCk\xD2\xCF\xFE\xEAq\x1F\x1F\f\x0E\x0F\x0E!\xADP\x89\xF0\xEA\xD7\xF6z\xF2\xB2gn\xE2\x17\x92\xA4\x1B\x01\x11\xCC\x8D\x10\x13\xED\xDC\xA9\x1A\xED\rx\x1B\x0E\xF41'#\xBC\xF7\xE9F\xD9\x17n\xD0}\x81\x03D\xC5\xF6zp\xE5\x01\xCF\\3C\xFEd\xCDz\" \x96\xB9\xC16o_0\xEE\xDA\xF2W\xD2\xA0\v\xC6}^\xD3\x86\x07\xBFq\xFEK{\xF2\x8Ag\xAE\xF1}I\xD2\xAD\xA0\xFFdyYe\x90\xE9\xD9\x92\x92>1\xFD\xB3\xAE\xB1\"\x06\xCD\x05\xC4RA\xD2\xF557\x8A\x80Yf/+\r:\xCC\xAAO\x89\x9FP\x01\x94\x15\x9A.\xCF\xC1\xA0-\x10\xB7\xDE\x97\x12\xAA\xE6F\xA2\xA4\x1B\x01\xB3\xCC^\xD6B\xAE\xF8\xA4\xB9\x10V\xA8\xB9\xD1\\\xA0ln$\xFE\\\"`\xB6\xF2\xB2\x02)U\xC5'\xE7\x82\xE2\xD7\xCB\x82\xC3\x83#\xF8\xAFu\xAE\xFES67\x12\xCD\x8D\x80Yf/+\rRU|\x12\x1Fh\xB0I\xB3u\xAE_ha\xCE\xFES57R<.\n\xC6,\xB3\x97\xD5?\xDD\x82&\xF6W!\x80\xE6\xE7zA\xC9W\xC4\x7Frs\xA3\xD7m\xFEa\xEB_\x04\xE2-\x03\xA9\x97n\f\xBAiL3v\xEC\x84\x07+x\xAD\xB6\x8B\xD2\x19q\xE3\xBC'67\xF2\x14h_\xF0\xB5\xAB@\xA7w\x1Fe\x19\xC3'\xB5\x19\xC3t\x14\x01|LtT7\xA9l\xB9\xEFR{\x94K\v\xF1\xE9\xA6\x91e\xECx-\xED\xD3\xA3%\x8A\xF7]\xEA\xD7NT\xDA1k\x8ER\xE3\xF6\x18\x06\xB9\xC7p\x8D\xDB\xB4w\xA8\xA9~{\x11\xA0\xDEv]=\xF5\x9F\xFD^;\xF9\xC0\xFD\x8Fn\x80\x1A\xFF\xCDa\t\x98\xDD\xD1OZk\x8BS\\waa\x16ts\x9A\xB1c'<X\xE1?!l:\xAE\xFFZ\xBA\x01\xA6\xECcL\xB1\x84\x80C\xDD\x89_N\x1D\xFA\xCB\xBB\xED\xF9\xF7w\xBF\xAC\x7Fx\x1C\xE0e\xFB\xD3\x97\xE9./?<\x9E\xF8\xFE\xCB\x0F{\xD4\xA3\xE6P%\xE6_M\xDEk`-\x05\xE2J\xBD`\xA3\xF8/\xFC\x06\xCE\\W\xE6\xD6*\x1A\xFFm\xD1\xF9oJ]\x8A\x9B*\xD0\xA9\xFA\xE4\xCB\xE1\x19\xEBS\xB4\xB9\x91\xB8\xBA:'Bs#nI\xA7\xB3\xC5\xA9>\x15\xA7\xC3\x11a\xC7nx0\x1D\x9E\x84\x07\x8B\xBCVZ\xA3Ke\xC2v)\xF6\xA3\xE9\xC0\xAE}{\v\xBE\xE0\x7F^\x81\xAE\xFE\x97\xA3}4\xE3\xFAfm\xC6uCA\x15\xEF\xCD\x1F(\x02\xD8(\x92-\xF1\xA3\x99\x95\xEC8B\xF5\xA9\xB8\xDA1\x97+\xAD\x95\x97Y\xAEtp\xF6\xF2\x9CSH\xB5\xB6\xC8\xA5\xA5\"@'\fK\xFE\v.s\xB5\v \xAC\xB9\xD1\x16\xBD\xBC\xEC\x94\xB9z9JAj6\x8A\x88l\xAC\x93\xD6\xDA\xE2+-\x15\x01\xBAbY\n^\xAB-s\xB5\x05 ,&\xDA\xD0\xCB\xCBN\x99\xAB\xC6(\xF22\x1BE\xC4\xFAX'\xAD\xB5E*-\x15\xE9\xA7\xAB+\x96\xA5\xE0\xB5\xDA2W\xFA\xC8j\x8Eck\xE5e\xB7\xCCU\xBC\xE6F\xA2C\xE2\x95o\xD6\xF7bB \x10g9\xFF\xB5\xD7\xE3Z.\t+\x8B\xE1\x8C4\xB0\xFA\xD4J{\x14\xF1N\x1C!\x1DX)\xB2\x86\x93\x86(\xD9\xCB\x81\xE9\xC0 \xDA\x12ln\x8D\xD7\x8CW\xCF%!I\xB9d\xA2\x04\x90&O&\xD9#\xD5D\tV\xDA\x1B\xF7?\xEC\xFF\xFD\x03\xC9\x7FUE\xF8\bw-\xB6\xEF$\x8A\xBB\v\x97\x1FZ\x03:ana(i\xF84=8\x1BE\xCE\xBE]X\b\xB8\x8DI\xCDy\x82\xCD\xF5hAb\xBA\xFE\x91\"\xC0\xEF\xEC\x83\xFF\x8EZ\xF0\xBBG\x8A\x89g\xE1j\xCF\x7F\xE9\xF0\xF9\xF7\x07\x11\xE6_x:\xF5\x14\xE8\xEA\xF6\x84w\xE4\xED\x13\xE7\x9F2\xFB;+\xCC\xBF\xE0\xE6P\xC1\xE6\xB2\xE6Z\xBF\xD3qI\x96\xDF=\xA5n\xAE\xC5ZL\xB9\xAE\x93\xABO5\x16\xCD\xB7q\xCB\xC7\xF0\xF9\xA7\xAF|\x1D\xFE\xA4\xE36E\xF6\xB2v\xFE\x15\xC2\xE7\x1F3\xB7l\xF9\xCD\xF5\xC2\x83\r=\x97\xE4\xF2\xBB\x1B\xB4\x8CT\xA8>%\xA7\x8A/\xB4Ga\xFE3=\xA9\x96\xC9\xF3Bs(\xBE\xFA\x94O\xEC(D\x172X\xF6\xB2\x9C\xFD\x9D\x12\xFC\x97\x83\xA0\xE6P$\x1D\xB8l\x05e/G\xE5\x92;B\x19\xA93\xF5d\xE9\\\x1C\x85\x19$?\x80\xA0\x06\xE9\x85\xE1\xF0'E3b3T\xD5C')\x1D]\xB2Ej\x0EE\xE4\xE5\x94x\xD2\xEC\xEB\x8E\xD0\xDC\b\x14\\R\x13\xF0\xAC\xA9>\x95\x1E\xE7{\xCD\xA5D\x12\xE2^d\n\xBEt`\xA5\xC8\x1AN\x1A\xA4\xECe#\xF0@9\x85- \xEE\xA2\xCC^\xA6\xBBD\b\x0F\x06\x05\x97\xD4\x04<k\xAAO\xA5\xECQ\xD8_\xF4[\xE0Fi(\xF9\xF2k\x95\xBF\xD4p\xD2\x1A\x92\xBD,\x1EH\x95\x0E\f\xE2.\xCA\xECe\xBAK\x84\xF0`6\xFF\xC2\x03\x9E\xD5\xD5\xA7\xAA\xEDQ\xFC\x04:\x88\xFA\xEA\x9E\xD1\x86\xCF\xBF(\xD9\xCBb:zp\xC6p\x84\xECe\x04\x02q\x16\x93\xE0\xF0\x0F\xA2\x84\x07\xAB\xD8\x89\xA8tE\xA0\xBE\x01\xBB\x1C\x99\x00\xA0\r{fa\x8BH}\xDD]\xD2\xBB\xB9\x8Cfw\x17\xFBO\xFB\xD5I}\xC6\xF0\xC1\x03\xDC\xD1j\xB4\\\x92\xBE\xAA\r\xF7_\r\xED\x10\xCA-\xF7\xED\x959G7\xC3\xA9G\xC0.\x8FO\x80\xDB\xA1'\xDC\x16\x9D^\v\x1E\xDF\x87\x81\\\x01`\x00R\xC3M\x03\xB9\xB5C\xF4=\xB3\t\xC8\x9F\xF6\xAB\xE1}E\x80A\xFB\xCC\x07\xE9\xE9\x0F\xEE+\x9A\xCD\x83\xFB\x0E\x1C\x882\xFFzc\xCD?\x95\xC6Gz,1\xBA\x19N}\x03vI\x02M\xAD\f\xF5_\xF8\xFC\x1B\xC8u\x03\fX\xA9/,\x19\xD8\xF7\x89\xBB\xDD\xF7\xF6u\x9BK g\xFF\x99\xEB6\x97\f\xEF\x1B\x07\xB8\xC3>\xF3;\xE8\xE9\xDF\xB1o\xDC\xBC\xFC\x8E}/}S\xE9&\tQ\xAAw\xB1Q\xE8\xFC+\xEB\xE6_0\x97\fc\xC71\xE6\x9FV;f\xDF\xE5\xC0B2\xFF\xAAw\x1D\xDD\xBCp\xCD\x90\xC0\x8E\xED?\xEDW\xBB\xEF\xF5\xE6\x9F/c\xF8\xC1\x03J7\xC9Z\x87\x82\x95k\xB1\x99j\xF4\x8D\xFC\x00\x02]R77\xE2\xE9R\x81\x11'\x99\xDD\x1D\x9F\x04\xB7\xC3Q\xF8w\xA9\xD5k)S\x1F\xB0\x9C\xAF;\x934h\xD34\xAF\xA0\xBB\xF3\x1BH\x0E\x07d\f_\xAAt\x93\x84:\x05\xAB\xD4\vK6+\x97\xC2\x83\x9DL\x12F\xFAmV.W\x9F\x92\xE8:\x04\x06_GL\x89\t\xD7\x8Ea\xC0]bg\xD5]\x94lZ:\x1C1{\xB9\x82\xCD\x8Dd\xBA)*\xAD\xA4\xB9Qg #\x05\x15\xC7vv\xD9a\xDF\x7FwD\xFA\xFDj\x99:;\xD0fg\x97\xAA\xA9ie\x17\xA5\x06+1s\xB3^^~\x9C\xFF\x19T\xA8\xB9\x91\x8A\xD7\x8AJk.\x90K\xB2gJ\xEA]Z\v\x00\x193R\xDE\xB0\x11^r\xCB\xDD%\xB9K\xDDE)\x03F\xD2\f\x90\x97\x8BQ\xE6_\xCC\xE6F\x05Ui)\xB1\xFAT!\x9C\x91jw\xB9}9@:\xDA\xFA\xCF\x80BDy9\xD1=\xAD\xEC\xA2\x94.\x05f/?>\x1Fi\x03\x02q\xD6S_\xC6\x07\xA5Of\x1B\x1E\x9C\xF6sI\"/\x87W\x9FR\x91V\xD6s\x97\xBC>\x19~\x19&d\xD9%\xD0A\xE5\x9B\xA7\x02\xBD\x11\xF5\xA9\x01a1\xEEzRZ\xBB\xC4\b\xCFt\xB9$YU\xA5\xFC\\\x12 \x90Kz\xFE\x1BXT\x02\xD8i\xBF\xDA\xC9\x0Fn\xAE\xDC\xB9\xA8d\xAE$\xAF\x87\xC3\xFD\xD7\x9A)\x18\xC9V\xE7\xE6\x9F\xCCp\xEF\xB1[\xEF\x00\xDD\xA8\xCE#\xF2I;\x8CO\x18\x94\xF7_\x9C\xA1\xB83O\xB9\xDF\xB9s\xD2\x8B\x9E\x9Ap|0|\x7F\x11\xE0s\xF6\xE9\x7F\x8E\xFA\xE0s\xF7\x17\xCD\xF7~\xEE~\xCF\x7F;\xB9o\x81\xF7_\x93\xF3U\xD8\xB8+\x82\xFFl\xB2\xD7\xEA\xDCz5\xE5\x9B\x07T\xF3\x85\xAC\t\xEF\xED\x8E\xEB?*\xE8\xCB\x89\xD0\vc\f\xB5s\xA1w\xE6\x9B\xA1\xDA\xCF%m\x12|\x97\x9EK\xD2\xF9\xD7\xE0}\v\x02\xF50\xA6YzD\x94\xF9g\x02d\xF3\xCE\x93wo\xD9+\xC9\xA3\x03:\xD2\xDA\x98\x8A=\xFF@\be\xE0\x11k\xA8\x02K/VpI\b\xE6\x92\xAAQ8$Y%\xF5\b\xFE\xCB\xE7\xC7\xDD>\xC6\xFA\xF2\xCD:y\xB9\x1C'\x90~\xB38\x8B{\xE6p\x17\x1A\x80\xB0^\xBAQ\xB8\xE4N\bhn\x94\x8D\xFA\xFB\x05\b-\xDF\\\x99\xBC\xE3F\xCA\x02\x95\xF3/\x8E\xBA\xB4Y\xDFK\xD7\xE1\xAB\x81\\\xB2\xA4\x18Ep]\xCEi\x91$\x84Fh\x91j(\x19O\x05\xF4\xF5\r\xCA;\xCE\xC59\xE9F\x10\xD22\xB4\xB9\xBE1\xE9\xE6\x05\x8A\x8E\xBC\x00\xDB\xCD8\xA1\xCA\xA2-D^^\xEF\xFE\xE2\xC3\xFD\x07\x05\xD8\x10\xD0\xD77H^\xEE\x8As\xD2e\xD1\x7F\xF99\xCC\xBF\x80^\xBAn\xB1\xAC[c\x85*\v\xB6\x10y\xD9\x8D4\x8E\xD4\x97\xAC\x00\xB9\x80\xBE\xBEA\xF22\xD3\xB1#\x9D4\x02\x818\xBB\xF9/\xC4\xED\x16\x04b\xAEoO\xC3\x91\t\xB7[\x10\xD5f9\xBAi\xBF\xD2\xB7%\xA2\xA8L\xF5)Ms#\xC1\xDC\xF0]b\xF0\xFD\xC4Q\x99.9\xA4\xB5\xC0=>\xE66\xDE\x8D\xD9H\xF2tsu\xC6\xFE\xD4H\x92W2\xDD\xB4_\x91\xE1\xEF\xA0\x1B\xF7@%\xF3?\xB3\xBF\x06\xAD\xA8\xCB}\rs\xD5\x9A\xDBJ\xBB\xE4G\xDD%\x06\xDF7\x9Bd*#\x86\xB7\xB2\x03\xC9\xE1\xAD\x1C\xDD||\x82\xEC2\x9D\xA7\xDA\"G7\xEDW\xEC\x18\xF2\x81b\xFB/\xB8\xFA\x94\xCA\\\x92)\x15k\x97X\xFE\x93[\xDC\x8A\xE1\xAD\xEC@rx\xABppW4;\xAC\xD0\x16m2\xA5oKDQ\x99\xEAS\x11\x9A\x1B\xB5B%\xCA\x8F\xB8\xDA1\x18G\x1B!\xB4\xDBR\x0E\x14\xE1\xAD\xDC\x7F8^K\xCC\xA4L\x8FYpt\xD3&\xEE\xFA\xB6D\xEC\x19K\x85\xABO\t\xCD\x8Dxs\xF3\"\xC5S\xED\x12\x87\xEF'#47\n\xCE\xF5-\xF7\x81Ev\xC92\x19\x95kn\xD4P\x82L\x84\xB6D\x15\xAC>\xA5hn\xD4\x1FrFs\xE0\xFB\xC1\xDD\x82Xx\xAB\xBC\vG7\x8F\xDCD\xCAI\xF8eT\x87l$f\xF4m\x89\xD8YV\xA4\xFA\x94\xAE\xB9QV\xF5d)x\x97h|\xDF\x98\x8E\xDF-\b\xC4\\\xDF\x14\xEB\xEB+\xCB\xA8\x05'\x17%\xB9(|\x94\xCAT\x9F\xD257Z\xAF\xF2_\xF0.\xD1\xF8\xBE\x11\x12\xFB\xAB\x0F\x0F\x16\xFD\xE7\xA4\x03\xCB2\xAA\xE5\xDC\x7F'\xF5m\x89b\xCF\xBF\xE0\xEAS\x9A\xE6F\xBEvM\xC1\xBB\xC4\xE1\xFB\xD3\xC8 \x10\x88\xB3\x99\xFF\nz-\x8B\xD1\x1C\xC8\xAD\x1Dnr(\x8A\xFD\xCA[v{\xEC\xCE\xDE\f\xEF/\xBA\x8A\x04\x93%\x86\xF7\x17\xCDv\xF2\x014\x15ya\x93\xBFL\xC5-\x99\xC2\xD3%\xA5<\xCAl1\xDB\x95\xB6\x80$\xB2\n|u\x80\x9D\x91\x15\xAA\xB1x|\xD5]\vH\x061\x0F\r\xB4\xAC\xDBm\xB3cR\xAEk\xF7Q\xE6b\xA0\x15\xC7\x86\x1F\xF6\xFC\xA7\xAC\xDE\xB5\xD2\xF6_K\xB7_)l\xE9\x8E\xEB\xBF\x16\xE7\xCC\x13G5\xF2<\xB3%\xF1\xB4\xB6\x92\xD8@\xDE\x93\xF7$\xBE\xC0j0\x91\x93\t\xD6XZ\xDD\xE7%\xEE\x02R\xEF\xBF\xDC'\xBE\xB0d\xCA\x02s\xC9\xC0\xBEO|a\x89\xB3\x8B\x13\x1E\xDC\xED\xAA\xEB\xC3\xFB\xBD\xEAS\xBB\xE9!w\xEF\x1F7?\xB8\xDB\xFE\x00\x9A\xC6]yyj\xCE\xF3o\x91\x13\xD9j\xAE\xD4\xC8\xCB\x00\xC3\x0F8\xD9\xCB\xE6G\xD8\xE9\xDF\xF5@\xD1\xFC\xC8]\x0F\b\xF2\xF2T\xE0\xFC\xBB\xCB\n\x8Dq\xE8\xF1\xF8\xBEs\x03\x97\xF4Z\x96\x1E;\xB5p\xCD\xAE\xA3\x84\xE2m\xB6_\xB1]\x80V\x1C{\xF9\x1Eo\xFE1Y\xE7\xE6{\x8A\xC6\xD37\xDB\x1F\xC0\x82\xA2=\x8Ab\xFE-\x8C;\xFF\xCA\x94nj\xE4e\x80\xDF\xB9\xB6\x18O+m!3V%/\x93`\x0F\xF7I\x9B\xEB\xBA\x90\xF9g\xB3TO^\xF6\xE9\xB5\x9EhK\xC2\x833\xE4\xC9\x13\t\x0FN\xB2]Xt<\x91t\x87\xF5\x92n\xD1%\x8A\xBE\xE7M\xB1\xE7\x9F7JR'/3[j\x83\xE5\xE5\x01\x99\xC0\xB8'\xED\x9DQ\xF8\xF5\xCF\xE6\xFB)\b\xD0H\xB3\xE4\xAB`\x8F\x8Bz.9\xE2o(\xD4P\xE2\xA7\x9ER\xD2M\x8F\xBBSO~\xDE\x94)\xCC\x86n:\xB6\xE8$\xDD\x10[\xC0\x93\x977ki\xB8}FwY\xA1\x1A\xA9\x14\x9F-i\xA4\x8E\xD2\xDA`\xD9\x14\xEF\xC8\xA6\xA7\n\x1E\xAF\xBD\xC1\xCFk\x01B$\xDDt\x89\x97tA\xA0\xBE0K\xBA\xA9\x91\x979[f\xE2\xC9\xCB,{\x99\x9C\x91\x15J\x85\t\xDFg\xA3H\x1A\xA9\xA3\xB4f\xC8\xA7\xAD\x99\r\x1E\xAF\xE5\x1B\ny\xBC\xD6\xFE}\x04J\xBA)]\xF5\xA9\xD8\xF3\xCF\xD0w\xE4\xF5z1Q[\xACx\xF22\xCB^\xCEx\xD7\xA1\x10\xFF\xB9|\xDF\x1DE\xD2H\x1D\xA5\xD5\x9E9\xB6\xFFr\x1E\xAF\xE5\x1B\nQ^\v!\x92n\xF5\xB8\xA6\xFAT\xBA4\x1B\xFF\xA9;\xF2z\xBD\x98\xA8-[\xE3\xC9\xCB,{\xD99#E\xF6\xB2\xFC\x8C\xC7\xE5\xFBX\x04\x1A\x81xK rx+}\xA5\xD5\xCB\xD8\x07*\xBA)\xC5\xC7\xCA\xCA\xA8\xDA4\b\x92GWg\xF8\xE1c\x9B\xEB\xE7\xD8\x01t\xBDUg\xB3\x14^=\x00\xBA\xF0\xEAp\x83N[\x02i\r.\xA2\xDD\x1A\xAEfx\xE9\xD4:y\xFE\xC8\x047\xFCi\xC9\x16\xFAj\x96\xD9\xDF.]\x0F\x8C&\x00\x7Fx\xB0\xC3\x11U\xE1\xC1V\xA8AL\x88\x9C\xE2bz\xE9\x00b\xF9\xA5\x9E\b\xF3\xCF\xB6\x8A\xC8\xCB-\xE9m\xE3>s\xD3\xDB&\xF4\xF3oS\xAC\xF9\xB7@7\xFF\x16\xF8\xE7_\x8B\xB4\xA6\x89\x1A\x1E\x1Cn\x10{\x10?\x90*\xF0%\x94\x9C\x01R\xFE\xF9\x17\xBC\f\b\x95\x97yK%a8~\xF6\xED&\xC5(\x92\x9A\xAB\x92\x97#\x87\x07\x87\x1B\xC4\x84Hb\x90$/K\xF1\xC5\xAD\x10\xDE\xDA4\xEFU\x9BV\xCB\xCB\xE9I\x8EM4\xEA\xBE\xEE(\xF2\xB2\xFD\xD5*\xE5eELy.\x90\x11D\b\x0F\x8E\xD5\xDCH\xAB\xFA\x06\x87\n8\xBE\xF2\x9A\x1B\xE9\xE4e\x8B\xB3T{)}\xFD\xE4e\x99\xD7B`x\xB0\xE2g\xAA\xDD\x85\xA4\xB3\x06\x17\x81\xCE\x85?\x8C\xF1\xAAO\xE9\xE4\xE5\x1D\x13\xFA^L\xF1\xB2\x97\x15\xE6\xBA\x14EP#;\x15\xBBD\x0E\x0F\x0E\xFFB\xF9\xEAS\x85\xB0\"\xD0Q\xFC\xC7\xA8\xAFR^6\xB3\\\xF6\xF2V\x9D-\x97G\xCC\xBE\rn\xFA\xA4T\xC3!Nx\xB0\x15zA\xE1\xABO\x15\xC2\x8A@316\xD8\x7F\x01\xF2\xF2\x11~\xFE\xE5u\xB6\xCC2{Y\x9A\x7F*y\x19\x81@\x9C\xC5\xD4\x97\xC4\xAE\xD2K\xA4G7\x85\xF0V1`7\xCA\xF3\xF6\x80tVWJ\x1Em.\x00\x8C\x92WP\xEB\xEE2\xDA\\0\xF7\x93\x0F\xEC+\xEC\xFE\xB1\xB1\"\xC0\x98}\xF1\x19\xA3\x97\xAF\xB1\xB1\xA29F>`\xA3H\x18\x8D\xED\x03\xCF\x16s\xFF(?\n\xB3\x85\xB7@\xE6\x97$v\x9A.+Z\xB5\xD5\xBBb\xF9\xAF\xA5@Y\xB4\xAC\xD7\xBAR\xF2h\x8B\xE7?\xBF\x82\xEF,\x98\x8F\x8E\x1D\xF2\xFC\xA7\xCD\xB8\x1EUH\xC9S\xB1\xAB\x1Az\xB6$\x8EJ\x85\xCF\x18]\xD7\xFA\xCF\t\"\xA2\xB7\xC5\x1E\x8Fnr\x14Ojn\x14u\xFEM\x05\xCE\xBF\xA9f\xAF\xB9\xD1\xA8U\xEBV\x9F\x1A\x1D\xEB6\xBF4:\xE6\xB8\xC4\xFC\xD2\xA9\xB1q\xF7y\xC4C\xD4\xFA\x87\xC6\xC6\xCD\xAF<4\xE61\xA5\xA9\xB1J\xCC\xBF\xA9\xCB\\y\xF9\xE1\x83\xF4\xBD\x83\xE4\xCF\xCBJ\xD1\x1F@De\xA4Q\f\nH\x07v\xA5\xE4\xD1\x85\xDE\xFC\xF3+\xD0\xCE\xF2\xE7\xE8C\xF7z\xF3O\x9B1<\xAA\x90\x927\xC7\x9E\x7F\x07][\x8C\xA3R\xE18\xF6\xB8\xE3+\x96\x9E\x8E\xF0\xD4\xB7U[}*\xD6\xFC\xE3\x95VY\xAFu.\xA5\xA3\x96\xE7?\x85\x02M\x90\x1C\xB3<\xFFi%\xDDQ\xC5\xEA;~Z\x1A\x19e\xD4\x95\x97\xB9Q\x98-\xFA\xDF\xAF\x13\x1E\x1C\\}\xAA\xB2zm\x96\xFD\xCA\x02%\xDD\xECXxA\xEA\xD1\x8ATp\xE5m\xD1 \xE8\xFE\x11Z}J\fU\x8E\x80\xA0t\xE0\x13\xD3\xC1\xBB\xB0\x82\xD4\xB7E\xCC\x18V\x9C\x11\xCC\xCA\\\xA1\xA3\x93\x9Bw\x1C\xF6\xBC\xA9Un\x05\xA4\xAB\x1B\x15\x07\x81\xE9\xC0\xEB\x83w\xF1Rp\x83\xABO\xF1\x07R]\xC2ge\xAE!\xC7D\xB3t`3\xE0\xFE\x1B\xAD\xFATl\x834\xE9\xC0+\xEE\f\xDE\x85\xA6\xE0Fnn\xA4z\xE2:;s\xA7\xA5\x98h\xA9\xAC5\x02\x81x\x8B\xA19\x90K\xF2\x8C4\x12\xBA.*\xB8\x0F.\xBB\xC4\xF7\xE0\xA2BE\xED\x8E@3\xBA\xB4\x9FP[\x94\xE6\x02\x18\x1B\"\x9B\xDBB\xFD\xA7\xA8\x1D\xC3\xB5h\x8D\xEA\xBFKJ\x00\xB7\xD8\xAFn\xA1\xEF\xDDb\xBF\x07\x97\x94~\x7F\xFCGm\xB9Ee.\x80\xF1\xB3\xC8\xE6^\xE6\xF9\xAF\\\x91\xF9w\xCBy%\xD7\xF0w\xD0\xF7\xDEa\xBF\x07\xE7U\xD6\x7FS\x11l\xD1~Bm\xE9\xA2\xE6^\xC9\xCC\x05\x80\x7F\x8El.m\xCE3\xAAZ\x8B\xB2\xF0\xE0\xA8\xF3\xCF\xF4\\'6\xE7\x01&/\xFF\x1E\xCC?\xCA\xB7\xDEA7\xE5\xD9\xAEP\x82\xB9$\xCFH#\xF9\xCF&\xD0)\x1F\x81fBn\xA5\xB0y.\xFEc\xB6\xD0W)\xDD#\x81\xC8O!To\xC6\xA6\xBE\xEF\xA8\b\x81\x8E\x80\xC6\x88\xB6\x04\x83\xCA\xCB|s#\x10\xA21B\x10\xCC%\xC5\xE6F\x11\x90\xD2\x10h\xA8t\xB7\x96XI\xE82\x82\x9B\x1B\xC5\xEA\x0E\x1C\xCC%\xC5\xE6FQ\x86\xD3\xAA\xBE\x15\x9E\x84\xE5\xB9\xF8/\xB8\xB9Q\xAC\xEE\xC0\xD5\x81\\Rln\x14\xE5\xB4,\x9D\xEA[\xE1\xF9gD\xB1%|\xFE\x85\xD7\xACF \x10\x88\x8A\xD0Mq\xC3\xB1\xE3XKgN;\x16\x98\x12P\xA6D\xDA\\\x92\xE6\x19\x8D\xA9U\x19\xFE=\x12\xCDgor\xFDE70\x86E\xC7\xD8\xEF\r\x92\x0F\xE8\x7F\x844\xD0\xAC n\t\xA7\x9B]t?\x99\x1D\xC7\xF2\x1F\xA7\x1DS:'\x16>\xAB\x94\xFF\xBA\x01\x1AI4)k\xAA\xD9\xDF\r\xB7C\xAA\xFB\x8D\x9C\x7F\x94K\xDEB\xF7\xBBRb\xC7\xB1\xA8o\xB3'/\xEB\xE7\xDF\xBCn\xE3\xFD\x1D\x16\x18\xEF\xEF\x18\xF9S\xB7UB\xC7\x88\xFD\xDE\x88}\xE6\xF3\xBA\x01r#\xE3\x00\xD7\xD9~\xB9\x8E:\xE7\xBA\x91q\xE3\x83\xD7\x8D\xD06\xA6#\x05\x80\x0E\xF2\xBF\xF4@\x1D\xF3\n\xC6j\x98\xF7:\xCC\xBFwDt\xF1;\xE6L}9\xED\x98\xD29\xB1\xF0Yc\xAE`6u\xB8\xD5\x07\xA4\x04q7%a\xD1\xBE\"@g`A\xF4\xC6\\7@\x87%D\xD3s9\xE4o\x18(\x97\xECR\xAC\xCD\x1Cv\x1C\xEF\xD1\x01\xA7\x1D\xF3L\x9D\x05cvX\x05`\xD9\xCB~2_\xB0]\xE7\x15\xF4\xD6\xCA\xCB\x1D\x8A\x8Ca\xE9@o\b\xC4\xC7\x1Dsf\xC7J\xBDV\x1C\x85\xFC\xDE\xC8\x99\xEB\x9A\x1BqSO+/;S\x0F^\x7F2\x1Fu\xB9\x0F\x00\x1Av\x1C\xEB\xD1Kxs\xA3\x01\xB7\b\xB4/l\x9A\xE5\xFA\x0E\x86\xCB\xCB\x03\xE1\x07\xAA \"\xD0M\xE6?mLt$\xEA\x16\xA9\xB9\xD1\x06U\xD8tW\xD4\xEC\xE5\x88\x07zC\xFC\x17XO+?\xFBt\xE0\xE0\xE6F9U\xD84\x9F\xEB;\xAB\x82\xD4\xD8\xFA\x17\x81x\xCB\x80\x11\x98\x9C\x94-\x91b,fU\xC6\xE5B`f\xB6\xCB\\\b\xCC\xCC\x9C\xB8$\xCB)T\xD9\xE2.+\xBCQH\x12\\\nt\xCDQL\xCD\x81\xDC\x1D\v!'=\xC8\xFEl\x147\x1C\xF5e\xC3\x99\xDE\x00\x8B,!\xA5\xCDy\x95\x1A\xAF\xAC\xFFjJ\x00K\xEDWK\xA9\x05KkJp\x8F\xBD\xE1Nk\t\xDDp\xA8\xA1\xFE;\x7F[7\xCC\xB3_\xBD\v\x12.\x07x\xD7\xF9\x16\xFC\x14\xCE\xB7\xFF\xC5\xDE4\xCE\xF3\xFC\xD7!\xF9o\x9E\xDF\x7F\x1Cu\xB3\xC0\xF8\xE0u\n\xFF\xC9\xD4\x8D\xF9\xCF>\x1A\xF1U'\xDD\x108\xAF\xE6\xD13\xBF\xE8\xBB\x9Bn\xD8\b`\xDC\xB0\x11\xAA69\x95`6^T2n\xD8x\x119\xF3\xAA\x9B \xB7\xA7\bp\xBD\xFDo\xD7\xD3Q\xAE\xDFS4>r\xFD\x1Eo\x94\xA5\xF34\\\xB2\x83\x9E\xD6\x12\x85-\xEE\x99{\xA3\xCC[\xFE\x17\xF3\x9D\x1B\xFD\xA3\xD6y.\xAF}\xF4\xAB\xDD\x89s`\xB9\xEDM{\xD3\xA1 ]\xAE\xDB\xBA\xF9\x13\xBCN\xA2n\x16\x98\xCD\xEC\xCF\x0Eq\x15\xCE\b g\x94}4\xF6-p-\x82\xC9\xAB\x9C7\xFF\x96\xE6\xD6\x0E\xBB\\\x12R|%;7\x1B?5\x04K\"p\xC9E%\x80\x8D 4\xD7\"5\xC0v.\x12\xE6\xDF\xF5b\x8B)\xF7\x17\xE1\x8D\x92\xB3\x7F\xBF\x8FZA\xBF\xDF\x8E\x94G\xBA\xB4\xBF_f\xA9\xF6\xF7\xCB\\\xA7\xFD\xFD\xE6lZ\xC5\x862\xE5\xE46\x8E\x05\xD2JX\xC0W\xC2\xF2\x14\x93\xCC\x9C\xB8$\xD3]T\xB6\xB8\xF0Fy\xF40\xAB>\xA5hndo\x06\x0E\x974)\xB84\x0E\x85\xB9\x8E\xE5A\xCEX\x908\xC5\xFEd\xAE\x13\xB2\x97\xF9\x9A\xDF\x8F\x1E\x1E\xE7gq^\xB7$\xE4\xB8$T\xFB+a\x89g\xAE\xE5\x92\x1B!\x94K^\x1Fn\v@`s\xA3\x86\x92&\xEFX\x9A\xCE\xD4u\xDA\x03E\xC8^f_\x85\xCC\x02\xC9+\x8E\x05\xD2JX`\xF0\x95\xB0\\a\xB8zbN\\\x92\xC9\xCB*[\x1C\xD0Q\xF8\xEAS\x86\xAA\xDAt\xA4D^\xEEN'\x9Ct&'\xFA\xAF\x15\x82\x02\xC1s\r%\xBE\xE2\x13\xC7\x02-\x10\x85aZ\t\v.\xE0+a\xB9\xC2\xB0\x99\x9D\x13\x97\x94\x82\x8C\xA5Q\xA4\xA9\xCCW\x9F\xBA@UmZ\x9Dw,M\x9F\x19\xCDI_\xCAg/CX 8i\xC6\xCB*>q,P\x9C\x7F\\%,\xA8\xE6+a\xB9\xC2p\xF5\xC4\x9C\xB8\xA4\x14d\xDC\xA0*AEm\xE1\xABOU+\xABM\xEB\xBA(\xF1\xF3Ow\xD2O\xF2\xD9\xCB\x10\x16\bN\xA4n\x04\x02q\xF6\"\x05\xBEPG.v\x8BP<\x12\xCF\xA5\xD8\xC5\xDEX\xFA8(\xF6\x81\x92\xDD\xC9\x1C;TiM\x99\x82\xCD\xF4\x95\xCA\\~g3N4\x9A`\xCBvj\xCBv\xDE\x163\x03\xCB\xEA\vF\x13Y\xD7\xB9\\\xD2\x03\xC7%\xC9\xA7\xF6+{\x97\x9F*v\xF9)\xD8dT\xEB\xBF\xEB\x98\xFFF\x8A\xA1\x1Cq^\xA8R8\x8FZ\xC5\xD9b\x9B\xC6\xCCMy\xE6\x12#\x95gTi\xFF\xB9\\\x92\xAE\xA9\x19\x97$\x9F\x12\x8A\x07\x908\xC7\xBF\x8B\xBD\xF9\x8B\xF9>\x92\x0E\xC2\n\xDE\xF1\x95\xAAu\xB2\xC3\x11);Q\x17k\xE3{Y\xE5\xA8U\x9C-\x16\xF0\xE6\xCEs\xCD%F\xAA\xCF(\x8A\xFF\xDC\xEF\xD2X\xED\x9D\x1B!\xE9\xF4\xBB\xAC\xCA\xC0\xB2\xB7w\x9B?!\x1C\x9B\xD8\x92\x138\x1D\x97\x8E\xF9(\xDD\xC5/\x0E\xB9\x9CI\xDB\f\x8B\xF1\x9E\xC1CEw\xCDpJ*@\xD6\"\xD4\x067Tt\x89\x92\xAEG\xADP\xA1J\x9A\f\xB3Dc\xCE\xF1\x9F\xDB\\\x8B\xEB\xE0L\xF9\xFE\xB2e\x05sd\x14\xFC\xCD\x8D\xA4JX\\\xF5)\xF0\xED\x92\x95\xAAOi\xAF\x7F\xE6\x80\xD7\xFA\x9C=\x97r^\xD1\xE7R\xAA\xEASr\xA4\t\xB5JnnD?x\x94J\xC9e\xFEU\xCCh\xE6\x0E\xBE\xDA\xB4\x83\xA4\xA0\xFAf`\x99U\x80\xE4(Din\xE4U\x9Fb\xD7l\xAF\xFATF\xAA>\xA5\xC5\fu\x9D\x96nFh\x91\xC4~\x15rs\xA3\x94\xE5g\xC7,\xA8&\xB6T\xD6\xE1c\xEA\xC6S\xD2(\x84\xA7\x8C\x02\x84\xA9\x9B\\\xF5)\xDF.\xC6\xB4T}J+\xC7\xE5lv\xAC\xA0\x9B\x1C\xAF\xD0\x15\xCB\xE2l)\xEF\xF5w*\xD6g/'\v\xEAQ\"`\xC0\x9F\x0E\xBC\x95\x1F\xA5z\x02\xF6\xD0\x1E\xC3\xC1\xEAfJ\x95\x19\xEB\xED\xD2/U\x9F\x92\xC0W\x9F\xCA\x86q\xEC\xC6p\xA55\xA7\xE8T\xAC\xCF^\xBE\xAA\xA0\x1E%\xAA<*\x9Ctb??\x8A\x99\xA5\xF2r\x98\xBA\x99Re\xC6\xBA\xBB\x18I\xA9\xFA\x94\x04\xBE\xFAT6\x8Cc7\x86+\xAD9E\xA7b}\xF62-\x1A\x19_\xAF\xF5\xA7\x03\x1B?\xE5G\xA9\x9E`\xF22\x02\x818\x8B\xC1\xE8C[}\xC1\xDD\x90\x15w\xA7\x8At\x91\xF7F\x8A\xA1\xA3\xD6\xC7\xB8\\/\xABg\xD4\xAD*\xA3\xB0\x857\xA3s\xAE\x8B\xE3\xE0\x01\x88$D\x16E9\xFB6\xC1\xDEck\xA4\x0E\xCA4_O\xFFu\xFF\xBE\xFA\xEF\xFA`\xFF]T \xFE36tA\x95\xFB\xA8Y\xCA\xFE\xEEh\x16\xFC\xC7*\xD0|\xFD\xCB\xDD\xEE\x86T\x9F\xEA\x1C\xF3\xD4%\xA1\xFA\x94\xBB\t\xC1\xDB\xE3\xCC\xBF\xB7{\xC2\xE6A\xA8u+d\x7F\xC3~\x8Fl\x98\xFF\xC8\x99\x7F\xE5u\x9E\x7Fn:\xBA\xB1\xA1\xDFJ\xF5k\xFC\xD7\xCD{\x8DE`?\xB0\xAC\xE0nH\xF5\xB8\xEB\xD4\xD5\xE3\xDCM\x98Ob\xCC\xBF+\x96\xF9+\xD9\t\xB6\xB8\xAE\x93l\x99%\x82\xBF\x00\x92\xBDl/\xBC\xB2\xA2\xBC\xCCe/\x8F\xA6\n\xBC\xD7D1\x96%\xC1%;5\xD5\xA7\x80I\xBA\x01\x883\xFF@]\t\v$ax\xCC\xAAD\x1D\x96\xE0/\xC0\xCB^N\xCC\b\xF22O\xBEG\xA9\xBC\fAt3\xCB\xBEn\xAD\xA4[\x190.\xA9mn\xA4\xB4\xE5\xF5\xF0_\xBF\x15(/\x83_S\x97\xE2\x90Y\xF5\xA91\x8D\xA4\vL\xD2\xD5#\xCEr\x7F\x8F\xA6\x12\x160axL+\f\xC7FXs#u\xA3%\xEE\x8C\x18S\x07?\xDD\x84\xF0\xEAS\xD0\x15a\x12\xCE\x86n\xCA\x92.D\x11\x86+\xED?M\xA3%\xE0\x8Bc\v\x1D\x9D\xA48\xE4\xF0\xEAS\xC0$\xDD\xCA\xCC?M%,\xCE\x96\x00a86\xC2\x9A\x1B)\x1B-\xF1g\xA4\xEC\xE8\x84@ \xDE*LX\xBBF\xEFT\x84g\nz\xA3\xFA\xF9s8\xDD\x94\x14,\x9En\xCE\xC1\\i\xE7\x8EY:\x86\xDA\xC2\x9B\xEB\xB2\xE3~\xB6\xDBh\xB8A\x0F)\xFC'\xA4\x90\xC6\xF5\x9FK7\x03\x8A\x8DiO\xFA\xA1\xD8\xFE\x1B\x9D\xA5\xFF\xA8-\xBC\xB9\x0E;66\x80\x82\tk\r\x1A\xB3\xFC\x06\xCD\xC5\x7F\xAC\xFA\x19{X-\xF9O{\xD2\xA3\x11\x97\xC4\xA0\xB0t.\xFEs\xCDu\xD8\xB1\x99\x93\x16\xD6\xC1\x06\xE5,\xBFA\xDA\xE6F]\xE1\x96\x11\xAF\xF5[A\x92\xAE\xF6\xA4\xCB\xB1\xFDgT\x84)\xF5[\xB37hF\xF4_ps\xA3\b\xFESV\x9F\x12\xE9f\x14y9Bs#\x88Vq'\xD8\xC8.\xAE8\xB6\xC3\x8E\xD5u\xB1+\xD3\xDC\xA8?B\xCF!U\xF5)\xF2\xD4\xCF\xF4\x7F\xABZ\xC4jn4\x97\xFB\x87\x9F\x1D\x1BO\xA9\xAEWQ\x9A\x1B\x01Djn\x04\xE1ts-\x04\x15\xCB\x8A\"/G\xFC\xBA[g\xE9?eql\x97\x1DoU\xFD\xDE\"57\x82H\xCD\x8D \x12\xDD\f(\x96\x15I^\x8E\xE6\xBF\xD9F\xDB*\x8Bc;\xEC8\xB1_\xF5{\x8B\xD4\xDC\b\"57\x8A\xE0\xBF\xE0bY\x91\xE4\xE5h\xFE\xCB\xCFu\xFE\xF1\xB5\xBD\x1Cvl\xFC\x14y\x03\x02q\xF6\"'\x06\x7F)y\xAD\xF8\x1F\xBC\xDE\xE8\xA1\xAD\xBE`41\xD5w\xD3\x82\x82\xBDY\x93q6\xF6\x85\xE2\x89M\v\nd\x03\x00\xF6{\x1F\xBF\xA7\xE8\xB6\xBB\xBF\x99\x1Ap\xF3=E\xE3\xE9\x9B\xEF)\n\xA3\x80\xD3H\xD5x\xC2{\xCFx\xC2\xE9\x88j\xBF\xFA8\x1D\x80\x8D\x02\v\x04}\xC6\xB5\x85\x1C|M\xC6{oM\x9D\xF3\xE7&\xA8\x0E\xB0\x85\r\xE5\xEELl\xA9\xAE{\x82\x8D\"U\xEFR\xF2\xDA\xD8\xFEs\xFAG\xE5\xD6\x0E\x81W\xFD\xC7\x8D\xE0t\xAB\xFF\xAC\x1D\x82aUL\xAF\x98\xB19\x90\xEBvsP\x07,0\x978\xEF\xB1\xEA?\xB9ns\xC90M\x1Ce\xD9\xA3,q\x94\xB7\xA5 V\"Z;\xEC\xFCI\xFA\vima\xF1\xC5\x03\x8B\x9E\x9Ap\x12GwB\xEA\xE4J\xF2\xDE\xCEEO\x9D\\\xA9\xF2\xDFh\xB0\xFF\xDE^\xF0\xB9\xF8\xEBo/\x98?b\xAA\xAFs\xE6\xFB>q\xB7\xB3\xB1\xFD\xB7\x84\x9C\xF9\xC0>r\xE6\x9F\xB8\x1B\x86\xF7\x8D\xFB\xCE\xFC\x8E}\xE3\xE6\xE5w\xEC\xF3N\x7F`\x1F\x17\x13mry\xB3\xE0\xD6`2\x9Bv\xD3\x93\xE6\x1A\xEA\xE6\x84\xF97\xB0\xA8D\x13e\x9Fr\xE5er\xE6;\x1D\x97\xA4&`\xF8\xFE\xA2\x9B2\xCB\xF2f?w\x7F\xD1|/\xCB\x9B\xDD\xE98\xDB\xE9\xE8Dsx\xBDfN*\xA2\xAD\x92\x98\x1C\xFF-\xF3W\x8F{`Y\xC1\x1C\x01\xAA\xD7:\xBD\x88\x03\x7F\xBF\xBB\xEF\xF1\xBEs\xED\xEFw`\x817\xFF6Y`<\xE9\xFCf\xEE\xE96\x9E\x04\xFB\x03X\xD0m<\xC9\xE6\xDF_q\xBF_a\xFE\xEDtl\t\xFA\xFD\xDE\xA5\xB3\x85\xFD~\x07.9r\x933\xFFn\x81\xEAM?#\xEF\xDDr\xC9\x91M?\x93\xAAO\xA9\x88\xB6D\xA1\x96\x85W\x9F\x1A\xB0\xC8\x95\xAB\x90\x01Z}*)T\x9F\xCA\xC0\xB0\xE5]s\xB4\x19\xC3\xA4\x8B\xD2&\xEF@I\xDF\x81\n\x90\x1C\xA6'\xCD\xAFY\xC5\xF9\xE7\x8CR\x90*ae\x9C?\x89\xE4\xAC\xB5\x85\r5`\xEF\xEC\xD9\xC2r\xA03I\x89\xB4\x1A\x10\x9A<\xCB\xEB\xB5\x1A\xEA\xEB\xA5Igi\xF5)!\x82\xD8\xA6A\xC3\xD4\\\xAD\xBCL\xA6\x9E\xE1\x1E\xC8\xF0\xE5\x1D7\x94 \xBB;\xC2(\xF4\xB4\xF8JX\xAB\xDD\xDD\xC9)D\xB0e'\x1B\x85\xCB\x81^m\xC9\xA4\xD5P\xF1Z\xD1\x7F{\"U\x9F\x02(\\\xF8\xE2$\xD0\xEAS[\xF9\xEAS;&`8n\xC6\xF0\r\xF2\x81\x1A\xAC\xC4\xCC\xB0J\x18N\x8B\xF7\x0F2\xCA\xD2\x92X\t\xEBH1\x9BK\xEF\x98\x00\x03\xAA\x03l\x11r\xA0\xB9\xBC\xE3\x1B\xD8(\x12iU\xF2Z\xF9YPh\xA8\xF2&\xB2K\xDD\xEA!Z}\xCA\x8D \xEE\xA2M{?\x1E\x9E1\xBC\x89?PbD>P\x06\x8C\xE4\xC7U\xC2\xB08s\x9CQr\x96X\tk\xF53\xEB\xBB2\xAD\x05\xE8\x81 [\x80\xB3\x85\xCB;\xA69\xD0\xAB\x9FY/\x91V%\xAFU\xF8/\xBC\xFA\x14\xE4/X\xD4\r^\xF5)7\x82\xD8\xAD>u$~\xC6\xB0\xF1\xCF\xF2\x81\xD2%\x98T\n\xC3\xD5\xE3~s\x17\x14\xC4JX\x8F\x0F\xDC\xD9\xBF\xF3\xF6\xE5\xCE\xFC\xD3\xDA\"\xE6@S\xEAKs\xA0\x1F\x1F\xB8\x13\x19\x04\x02q\xF6\xC2[\xD1\xD6)\xB9\xA4\xB3\xA2\xA5\x7F.\xB0/<\xA41kKz\xDB8y5\xD9\x92\xB6`\x12\xC8\xC6GZ\xD91\xBC\xA5\xB3;\xA8\xC0W\xC19\xA4H75\xA3\x00\x1D\x85\xB3\x85\xEEBma\x7Fr\xE6\xAAv\xD1\x1C\xC8\xF3\x8Bh\xAE\xE0\x17\x97h;\xD5\x7Fl>3L\t\x8C\xC4b\xD8\x9F9\xD6]9\xB3:\xE3\xF4^v\xBA+\xD3\x16\xCB\x03\xBAD\xD4\x01\x9A\x88:h3\xB4A\xD1\x7FwX`^\xCE\x98\xEB@\x84tVm\xA7gU3h\xDB\\\xD5.\x03\xB9\x12\xC0\x1D\xC4\x02f\vy/WbLX\xC5\x8E]\xA2\xE81\xFA\xE1\xA6\xBB\x14\\\xD2a\xF4\xF4\xCFV\xFB{k\r\x9C\x7F\x02\xE9\xF2\xBEP\x9Btm\xBA\xC7\x8B\xE9\x1D\xB4\xBF\xBC;\x02\xE7\x9FC\x00\x03\xE7\x1Fg\x8Bn\xFEI\xE6\xAAv\x19\b\x9F\x7F\x83\x81\xF3\xCF\xED\x8Dud\xD3\xCF\xD8\xFC\xFB\x1B\xBA\xDF\xDF|\xB1h<\xCB\xFEl5=si\x1D\xB9,\x97\xCEO\fJy\x06i\xCB\xD4\r\xF6\xFB\x7F\xBF\xA4\xFA\x14K\xE7\xD7\x8E\xC2\xD2Y[S\xDE\x8FS\x9B\xBD\xCC~\xDD\xE5\xC3\xC7'\xD5\x97/u\xDE1/\xC6\xDE\xAC\xCA^&\x1D\xB0[\x8A4\xC8\xB8\x90QrI\x97\x91R\xFBXs#\xDB \x92}\xEB\xE5\xD7\xBAR\xE8&E\xF5)\xA9\v\xDA\xCD\x87\x8B>\xD1\x82T\x9F\x82|\x91?-e\xF5):\n\xB1%Z\xF6\xB2\xFBu\xABv\xD1\xE5\x1Ds\xC1\x00\xCA\xECe\xFB=\x96\xBDL\xB8\xE4]\xE1,p\x01\xB0\xFC\xDA#7\xC1\xCD\x02\xAF\xCDD\x15\x86\x17Y\xA1\xA2m\x84Q8[t\xBBp\xF22\xA5\xBE4{Y\x16\x86\xB5\xA3(\xB3\x97\xA9_<F\xFA\xB2\x92K:\x8CT\xD4k\xDD\xFC\xDA\xD6\xF5P\xCFg\xC6\xBA-\xE6\xB5\x89\xBC,\x9A\x99K\x07f\x04\xC6\x02\x9EnFH\x07\xCE\x85\xD3pN^\x16\x8B@\xAB\xA2\x995\x81\xE0\x9A\xECe\xFB=b.e\xA4\xDBU\\\xD2a\xA4*\xBD\xD6\xE6\x92/\n\x99\xB1\xEB\xDD/4\xB4\xCC\xD5\f\xA5\x9B\f\xA4\xFA\x14\xFBV\xCB\x11\xD3\x81\xA3e/\x83\\\x04\x9A\x97\x975\n43\xF7r] 81\x972\xD2[\x95E\xA1\b#\xE5\n7\xB0\xFC\xDA5\xCB\xE1V\x8B\xCB\x8C5\xEE\ff\xC7|4s\xD6\x17\x87L\xAAOI\xBD\x98\x829\xB6\xBES\xB1\xAA\xB9\x91X\x04\x9A\x97\x975\n437\xA7\v\x04\x87\xEA\x12\xF2\x07\x04\xE2\xADA\x82\x83\xE9fK\x10\xDD\x9CT3\xD2\xC4\xB8\xB7\xCB\xB6\xF1I\x9B\x02L\xB2cp\x07\xA2\xE2\xAEl\x8B\xAC=\x91?\xAB30\xD5B\xFA\xCF\xA4w\x1F\x9D\x82\xB4+I\x92\xFE=S-\xEB\x86\xB8\x05\xEE)\xDF\xA27q\xCCY\xF9\xBA\xFFAF\x19\xE2\xBB\x009\xE7\xE5\x9D4\x1B\xE0T\xE0r+\x02\xDDl\r\xA0\x9B.\xF5\xF51\xD2d\xC6\xDBeu]\xB2\xD5\xDE\xB0c\f\xF0\x02\x05_\x15\x98\xB3E\xD6\x8E\xC9\x9F\xA9!\xAF@\x95\x99!\x05\xA9\x05\x8E\xE3\xF5:\x8A\xDE\xDC\xC8\x9C\xCF77r\xAA\x82ts\xACH.\x8E\xAD\xF4_\xF8\xFC\v\xA4\x9B\x93\xEA]\xFC\xF3\x8F\xB9N;\xFF\xA2\xF8o\x1E9\xF3\xAA\xFF\xF4\xFE\x0E\xABJln\xE4\xF5:\"\xCD\x8D\x16\x8577j\x84\xAA\x8C/\xD4\x82\xE6\x11,\xA2_@p\x8C\xFA\xA6\xF0\xEAS\x1C\x97TU\xC2\xA2\xB3\xAE%\xF0B\xC1\\'\xCA\xCBI\xE9\xBB\x1C\b\xFC\xFD\xBA\x05\xAAR\xC3M$|\x80\x7F\xC6\xE3E\x18Don\x94\xBA\x9Bon\xE4T5\x13\xE6\x9FT\x1C[\x85\xD9V\x9F\xF2\xB8d?c\xA4\xC0\xB98=\xE9\xEDr\xFC\xF4L\xF9\xF0\xF1\xD33\x9B\xD4\xF22_U\x99W}e\xED8\xE3\xF0\xC4\x0E\xCBqq&)f\fs\no\x8C\x82\xD4\x19A\xC7\x06\xE0\"-\x03\nR\xFB\x15\xF2\b\xD5\xA7$\xBA\x99\x9B_r\x1Ewd\xD4\x8C\xB4\x9A\x1B%cs\xECL\x04y\xD9\xAF\xD7\xFA\xAAOu0yY\x97\xA5\xDB\x19N\xE6;,6\x8A\x06\xD7\xA9FQ\xD1\xF5\x88\xD5\xA7:\xD5\xBB\xB8\xD4\x17dFjLx\xBB\xEC81\xDDcsl\x9D\xBC\x9C\x95\xF5Z\x81\xB4z\xDA\xF1\x8E\t\xA7\xFA\x8F\xBBK\xD5\x94\x94\xA5\xEB\xED\x02q\x9A\x1BUM\xFA\xA4\xEE\b\x05\xA9\xE5\xC7\x1Ds\xA3\x9B^\x16\x93\xB4\xCB\x05Eo\x97\xD6B\x7F>c6&u\xF2\xF2zY\xAF\xE5I+\xD5\x8E[\v\xAC\xFA\x94\xFDs\xDD%\x17\x81vw\x89\xD5\xDC(9\xE4\x93\xBAc\xE7\x1DG\xAD>\xA5\xD9\xC5]\xBF\xF8\x18i\xF5\x84\xB7\xCB\xED+\x92F\xFA\xC8\xC4\xA4F^\xE6\xAB*\x1B>\xD2J\xB5\xE3\xDB\x97\xB3\xEAS\x90\x87D\xF7\xB4T\x04\xDA\xDD\x05\xE247Jt\xFB\xA4\xEE\xF4\xEB\x90w\x8C@ ~\xFF\xE0\xB2@p\xA9 \xE3\x92\x10\xCE%Y\xF9\xD7)q\xC3\x8D,r\xC9`\x90\x07\xBF=\xCE}\xB0z\x82\xBEgLC\xC3\x91\x13\xF6=\xDE\x98f\xE3\xB1\x03\x81\xD8\xBAV{ \x8E\xFA\xAA\xCD\xE5Ga\xB6\xC8\xA0\x01kd\x17\xBEp\xB5\xC0%!\x9CKr\xE5\xAF\x01\x94\xCD\x8D@jn\x14\x8CT\x95W\x90z\x1E\x18\xEE\x89\xCC\xAB\xB2\xEF\xCEUF\x81\xDCg\xD77\xCES$\x06\x8Bu\xA2\xB5\x07\xE2\xA8\x1B\xE8\x9A\x1B\xD1Q\x98-2\xAA\x04s\x1B/\xF2\xDA:m\x84*w-J\x9A\x1B\xC1E\xDFu\xFF$\xCD\x8D\x96(\x9A\x1B\xC1E\xB4\xB9\x91\xDA >'}I\x04\xFF\xCD/\xB9\xF4\xE6\xBF\xC29\xEE\x8D\xF4\xBF\xCE\xB7o\xE0\xF3\x9F\\a\xDF\xA2\x8D;\x1B)\xB7\xE2\x9A\x1B\xE5\x84\x8E\xB2Z\xFFq\xD4\rt\xCD\x8D\xE8\xF3\x12f\x8B\x8C\xF9\xDE\x8Cx\x97\xFDji\xAE@\x87\x12\xB8$P.\xA9mn\xC4\"\xB5\x1B\x01T\xCD\x8D\xBC\xF0\x86\x88\xF3\xEF]\xA6\xB7\x04\xF377\xB2\xC82,\xDBA\t%\x97\xD8%2M-\xD5g\x8F^\xF4\xCD\x8D\xE8(\xEFJY\x9A\x8CC\xB18\xB6\xD0\x96\x88\xE7\x92\x10\xCE%\xF9\x16I\xA0ln$\xD7\xB0\n\x06)\xDF\xACnnt\xFC\xF4\fyPA\x9A\x1B\x81\xF8\x00\x02\xC4'\x1D\x83\xDA\xEC\xE5\xC3E\x9E#\x06\xCB\xCB\xC4\x16\xE5\xFC\x13\xE5\xE5\x0E\xE0\x02{g\xCD%7r\xA3h\b\xF4\xF5\x11W\xA0\xBA\xEAS\xE4\xCB\xCC\x86\x17\xEE\xAAP\xF62@h\n$\x91\x97\x074\xD5\xA7l\xD2\x1A\xC6%\xB9\xF0`\xD0\xF4\xF5\x95\x9A\x1B\x85\\\xFF\x02l!\xF7\xDF\xC4Lc\x83\xBF\b4H\xC2\xB0\xF6\xF7\xCBU\xFB\x85\xE8\xF2\xB2\fQ^\xD6U\x9F\"\xA45\x84K\xF2-\x92 LF5#\xA6\xB3\xEAlYO\x9E(\x94\x15E\xA0Ad\xEA\xFA\xECeN^\x86\xE8|_\x86(/k\xAAO\x11\xD2\x1A\xC6%y\xBD\x16\xC2d\xD4\b\xFE\xF3\xE7\xD72[\xC8\xFD\x17&\rE\x11h\x10\x99\xBA>{yG\x88\xB9jyY?\xFF\x00\xFB\x1F!\x10g5\x1C\xBA\xD9pD\xA4\x9B%?\xC9\x94h3c\x95V,\x8E-\xD2M\xC9\fqE\xD1\xA3g\xC7\xDC{\xBC\xB91\xF8~\xE2\xA8\x92\xEF\xDB\x9B3\xBC0\xEC\x1A\xE9\xCA\xCB\x05\x90\x1F\t8t\xB3J\xA2\x9B\xE0_\xE4K\\\x92\xAD\n\",\xB7\xB4\xCD\x8D\xB8[/\xA3\xBE\x94\xD6\xEA\xD91\xDDE47\x02\xF8\xE6F\n\xBEoo\x969\xE6:\xC2\xA6k\xA4\xD4i\x97\x15\xC7v\xE8\xE6\xFC'E\xBAY\xF2\x93t\x85\xCA\x13\x95W\xE8\x9B\x1B1\xEA\x06\xD4\x16\xFA\xDE\x7F\xD5\xB3c\xBA\x8Bhn\x14\xFF\xB9\xDD\x95\x8D\xD5\xACZ\xB7\xFB\xE8\xE0\xDA\f\x90\xCD\xB2f\"l\xD6\xDE\r\xA3\x16\x98_\"\xBB\x8C\x8Eu\x9B_\x1A\x1D\xA3\r\x84iq\xECV\b\n\x0F\x8E\xD2\xDC(\xDC\x7F\xFA\xE6F\x8C\xBA1[t\xE3\xBD\v\xE6P\x03\x87\xF9\x8Fkn\xA4\xE0\xFB\xF6fYs\xC1\xADE=\n`:\x15^F\x9B\v\xE6~V \x8D\x15\xC7\xF6H\xBA&<8\x90\x01E]\xD7\xE9\xE5e\x15K\xD0\xB1'\xAE\xB9\x916\xE09\x1CBs#\x05\xDF/d\xA0\xCBr\x12\x9C3r\xDE1[|\x8E\xD1\xE2\xD8\x11\xC2\x83\x83\x11\xAB\xFAT\x04\xBA\xD9\xA3\xF0\xA4v\x97Y67\xD2\xF3}\xFBV\xD4\x05\x9C0l(\xFB\x1D\xB3Z\xDE!\xE1\xC1:3\xE2U\x9F\xD2\xCA\xCB\xA2_dyY\xF1\xE078\xE09\x02\x064\x15\x9E]\xBE\xDF\xB0c\xC2Kpv\x85a\x7F\xBFc\xDB\x7F\xF4\x91@Xx\xB0\x8EK\xD2W\x91\xAAO\x15\xC2{\xE9\x86\xE6\x1DC\xB8H\x1D\x01\x86\xA6\xC2\xB3\xCB\xF73\x9C\xBC<$\xE7\x1D\xF3d^x$\x10\x10\x1E\xAC\xE3\x92\xF1\xAAO\x15\xC2z\xE9\xE6 4\xEF8B\xC0sT\xFF\xF9+<{|?}dB\x14\x86\r\x7F\xBFcM\b7\x02\x818\xDB\xA0\r\x0F>\xA3\xE5\xBF-1.\xD7gt\xD47\x8A0\xDC\"\xD8\x12L\xC3\xA3(\x03\xF6\x02\xF25K\xB9\x80tC@\x95\xF2r \xDF\x17\x9A\x1B\x19\xED\xAC\xB9\xD12\xF0b\xE4d\xCC\x8B\xD3\xDCHG}9.\xA9\xF5\xDF<\xC1\x16\x156\xC6\xF1\x9F\xA6\xDA\xB4\xB1\x01\xC8\x06\x84\x12\xE0\x1D\x8Ae\xA3\xCA\\\xA1\xB9\x91\xF9\x15\xD6\xDCh\x99\xA5\xE3\xBF\xCDq\x9A\xCB\\\xC6\x9A\x1By8xY\xC9|\xF8\xE0e\xA5P\xFF]\xE6\xF9\xEF\n\xDD\x1E\xB1J:\xE7rY_\r\xE2\xFE}Y3\x07\xB9\xAC[\xC8\x9947rF\x16\xAD\xD2\x16\xC7\x16\x9A\x1B\x99c\xAC\xB9\xD12\xC5(\xAE\xFF\xE247j.\xA8\xEAl\xF3\\R/\xCC5\x87\xCE\xBF\x83q\xFCG\x9B\x1B\x81\xB2\x199x\xCD\x8DT+7mqlmxp\x97\xFE\xFB\x8D1\xFF\xBAt\xC5\xB2x.\xA9\xFD\xEF\xA2o\xB5\xEE[\xCD\xC5@?'/k\xAE\x7F\xA3*y\x19\x82\x8Ack%\xDD.\xABb%\xBB\x83\x85\xE1\b\xE5\xC37V\xEE~\xA9#\xD0\x19i\x9Aic\xA2eyY\x17\x1E\xBCG;\xD3f\xDB\xDCH \xADRs#%D[\x82ix\x04\xA4\x02\b4\x9F\xBD\xAC\x9A\xD9Z\xBE\x1F\x10\x1E\fa\x02h\f\xBA\x19\x90\x0E\xAC\x7F\x00&\xDA\x12L\xC3\xA3\xF8/\x88@s\xD9\xCB \xEE\"\x1Dh\xC6\x9Fx\xEB\xBE\x92\xC3\x83!L\x00\x8DC7\x83\xD2\x81C\xE7\x9F\x11N\xC3#\xFDt\x03B\xB8\xB9\xECe\x15\xF9\x8EP\x1C\x1B\x81@\xBC\x15\x98\xB06\x9A9\nX\x12\xDC#\xE3\xEEr\x81-\xB7^\xB3\xDF\x83\xAB\xC7\xC3\xE8\xEBT\x1C\x8E=\x15q\xD5\x12\x7F\x97\xD7,H\xFC\x82\x99\x1B\x8C\xEB\xE24\x87\xD2C\xD9-\x88\xA3\x9B\x91\x9A\x1B]7/\x86$\x19\xA1/Tnv\xBB\x90N\xB6pQ\xB43\x8F\xD5\xDC(\xC0\x0Eo\xD1\xD1\xA5\xA6\x9B\xFC.\xFA\xE6Fq8\xF6h\xC4e||\xFF\xF5[@\xD8q\xB4\x13\x8F\xD3\xDC(`\x95%tk\x99ms\xA3|\xA9\xA2\xFE\x8B\xB0\xCE\xE9\x9A\xEB\xF5/Vs\xA3\b\xD7\xBF957J\xC5Z\xA3W\x02*\x17\x93\x02_\xB1\xE4e\x80\x18\xE1\xC1!\x17\xE4\x8A47\x8Ar\xA0\xDF\x8F\xFBo\xAC\xE6Fz\xA8\xAAOI\xA3D\x90\x97\xE3p\x9C\xC6\x8A\xDC\x7FUpR\x93#\xDA\x12\xAB\xB9\x91\x1E\xAA\xEAS\xD2(\x11\xE4\xE58\xB3\xBD\xB1\"\xF7_\x15\x9C\xD4\xE4\x88\xB6\xC4jn\x14e\xFE\xCD\xA5\xB9\xD1N\xEB\x8D\xF6\x9Fj\x8A:\xA9\xC9id\xBC\b\xC4\xFF'\xA0\xD1k\x01\xBCt\xE0\xC4Q\xB7@Uu\x86\xBB\xF0H\xFD\x85X\xC9\xE4\x9C\xB6\xB9\x91\xB3\x11G!\xDB\x051n\x1D\xACX\x96\xCF\x16\x7F\xF9\xE6\x9C\xB6\xB9\x11\b\x05\x91@2\b\x14=\x96t\xD0\xE8\xB5\xE0D\xB6\xDA\xF7\x96\xD5n^ d8\x17K\xD5k\x88\n%\x95\xAC\x95\xE4)r\x8F2,\x98\x0FS\xEC\xBE\xE5\xBC\xEA\x8E\xB3t.\xB8C\xF9m\x81\x10[\x98<E\x06\xA8V\f\xCF\xDE#\x03\x9C\x13\xC1\x7F\xCD\x05M_\xE4\xE6v\xA7\x18\xD5\xFE\xA9\x96n\x80)+}7\xA7\xAEO\x1D\xEAN\xFCr\xEA\xD0_\xDE\xED>\xCA94\x0EpZ\xAC>u\xFA\xD0x\xE2\xB7\xA7\x0F\xD1G/\x96\x97\xF2\xDE!=H\x89\xF5\xE8\x85\x94\x1A\x06Ab\x92\xAA\xFD\x9E:\\t\xB9\x15\x13Jg\x0E\x17\xF9j\xBFe\xDDS\x9C)\x91\x9C\x9D\x8A\xE8\xBF\xD1@\xFF5\xD2\xF0\xF4\x01~\x8A\x1A\xAB;\xDC)\n\xB0h\xC4\x9F1,\x8578)\xCCV\xD5|.\x11\xDA\xF9>\xE2\x847,\x9DW\xF0%BK\xE1\rKt\xB6\xB0\xF0\x86F\xD0h|\x1B\xC5\x87\x03\xD7Ga\xD1j\xBD\x16h:p\xB2\xD1i\x8B\x95\x1A\xE2v\x91\xAAw\xE5\xF6\xF93\x86\xE5\xEA]\x00\xFEQ\x9C\x7F\x8E\xB3t\xCE\x15|y\xC7R\xB5x\xAD-R\xF6\xB7*T~@\xF4\xDF`\xC4\xA7\x10\x81z\xAD\x93\x82+\xD7\x8D\x92Z\xAF\x86g\f7\x86W\x9F\x8A\xBAt\x0E\x96\x97#\xD8\xB24\xFC)\xC4\x12+\x9At\xA4\xD3k\xC1K\x07N\xCCt\xA8\xEAF\x89\xD5\xA7:\xC3\xABOu8\x1C1\xA8\xFAT\x94G\xA7\xE1\xF2rgx\xF6r\x07h\xA4ZF[:-\xF0\xD5\\\xD6\xDE\xD0\xD4\xA4\xB5\xD5-\xEA5\xA0\xAA\x1B%V\x9F\x1A\f\xAF>\xE5f\\\x07U\x9F\x8A\x80\x81pyy0<{y@\xE7?\xF6H`0\x8E\xFF\xD4\xA4\xD5M\x07\x9ET\xD6\x8D\x9AE\xF5)\b\xAB>\x05\xB36W\x1D\xAA\x1C!{Y\xFBH\xC0\xC4\"X\b\xC4[\x10\x94\x05.\xA8\xF6jp.`\x1FV\x03\xDC\xC4h\fc\x9A\xF23\xB78z\x85j\x14\xA9z\xCD\x02\x95\xA1\xD2\x11\xA9\xB9\xA9@s\x83\x9F\x18J\xC4x\x16\xE6\x1A|\x13\x90\x90\xFCd\xC64e\xB6\xD3\x12\x8B\xB4\x86V\xEF\xD2=L\xE7\xFF\xA4\xE6\xB2'\x9F*sU8-\xF2\xDA`^\x16b.\rr\xEF\xA9\x12\xF2\x98\t\xA4\xFC\xE4)\xBA\xF2\x95\x03\xCB\xE7\xC5\x8D\x17\b\xAE\xDE\xA5ZSK\xE9\xD4\xF3R\x96\xFB\x1E\xCB\xF3\x92\xFA\xF7h\x03\x13\xD8qO\x85\x17w\x9E\x02PsD\xC7\\Z\x03\x8C\xE4'\xDF\x02A\xF9\xC9\xE4\xA4\xFF\x1F\x15\xDB\xC9\xC5\xD5+\xA4Q\xE4\xEA]\x8A\x7F\x93\xD2\xA9\xFFm\xA8\xE0\xBE\xC7\xE6\x9F\xD4\\+j\xF6w0/c\xAE+\xAB\xCC\xA5,p\x9E\xE9\x19\xAE\b\xAF\xE6\b\xFE\x9C\xAF\x7F\x1D\xE1\xD7\xBFy\x81d\xC0]\xE7y\xE15\x82\xBC\xCC\xEB\xB5Q\xB3\xBFC\x8A\xDB\xD3\xFFh\x14\x9F\xF1\x80(\x89\xE7\xF2\xFEx\x1F\xC9 \xD6\x98Z\xD6\\c\xC7\vH\xA3\xC8\xCD\xA1T'-\x9E%\x91\x97S\xE2\x8F]\xFA\xBA\xB5\xC2p\x9D\xF8\\jI\xEC\xE2\xD8\xDC\xD7MW\xE1\xDF\x13\xF57\xE7:\x94)\xF8\xD2\x81\r\xD5\xA59\xB6^k\x04\x1E\xE8\xDF\xAC\xD0\xFB\x87R^V\x98\v\x81S9\x17\xFE\\ \xC4\\\xCA\x02Yx5\xC7%\x1BJ\xBC\x00\xAA\x12\x86!6iU\xCA\xCB\xE2\x81T\xF3OJ\x07V\xCA\xCB\xE2(Q\xB3\x97\xB3\xE1_\xB7\xFE@t\xFEE\xC8\xAFU\t\xC30\v\xD2\x1A\xA1\xFA\x94\xFF\xDF\xF2\n\xFF\x05\x8F\x125{\xB9!|\xFE\xCD9\xEF\x18\x81@\xFC\x9E\"\x05\n.I\xB6\xD5\xE0c\xC7Z\xBA\x19\x85\xFA\xBAz\xAD\xF1\x04\x8B\xF0\x93\x1A\xDD\xB0bY't\xEC\xEE\xE4\xC3E\x80\x93\xF6\xC5\xE7$\xBD\x02\x9D|\xB8\x98x\x9A|\xC0FQ\"\x96\xBCG\x8BeI\xB6H\xC33\xD6\xCBqI\xCA\x89%v\xAC\xA5\x9BQ\x9Fw\x92\xAA4\xCC\x02\xAFz\x8D\xFBg\x8DY\x00\xA8\x11Wi\xF6{M`z\xBB\xD4o/\x02\xD4\xDBf\xD4S[\xEC\xF7\xDA\xC9\x07\xEE\x7F\xE8\b\xB9\x19\x83\xA9S[\x9A$[j\xCC\x82\x8FZ\xCA\\\xD2\x99\x99\x9E\x81=\xE1t3\xD6\x17\xCA\x04Fir\xD58\xF2\xB2=\xFFDy\x99=\xA3\xA8\x7Fx\x1C\xE0e\xFB\xD3\x97\xE9./?<\x9E\xF8\xFE\xCB\x0F{+\xFD\x9AC\x95\x98\x7F5\xAE\xBC\x9C\x98~M\\\xE9K\xD1\xB8d\xB9*sIq]\x97\xCA\x14|\x14T\xA2\x9BQ\x96\xCE\xAE^k\xACf\x02\xA3\xF4\xE8`*Yp\xA7\x1E[~\xD4%\v\xB0\x1A\x92\xF4\xF7K\xE7_N7\xFF\xA6\x92\xBAi\x96\x8C1\xFF\xA8-\xAB%[\xEA\x92\x85\xB0\x95\xB9\xE3IJ\xDD\xE6\xE5+Q}\xCA\xD3k\xCD&\x16`!=:\xA8\xE9\xF7\n\xCA?\xAAc\xC7\x17\xD2\x82\xF2\x8F\xE9\x9A\x93\xD5h\ty\x1C\xA6\x9E\xA6\xC5\xEE$[T\xF1\xD9\xCA\xEAS)\x8B\xFFSN\x9E\x8D\rN\xAF\xBD\xA4\xA4\xE6.u\xCB=\xD7\xB1\x03\x95\x96\x17\x12\x00\xCB\xE9\\\xFB\xAA\xE7:&\xE9\x96\xAE\xCA&\xA0Dw\xA9\xFB\xAA\xCE\x84\xE51\xCC\xF5lI\xC8\xB6\x94\x96\xFB]\xA7\xAC>E\x97\xD8\x8F\xEEU(\xAD\"\xDD\x8C\xF2\xE8\x85U\x9FJ\xF2\x9D\x0E\xE4\x8E\xBC\xC1e\xAEr\xE1\xF2r\xA3\xF6\xAE\x16\x8B\xA9s\xC5\xB2\x04[\xA4\xF8l}\xF5)nn\x84\xD2\xCD\b\x18`\xD5\xA7\xAE\xE2;\x1Br\xA3<\x1A^\xE6\xEA\xB1py\xF9Qm\x91\x818\xE6>\xCA\x15\xCB\x12l\x91\xE2\xB3\xF5\xD5\xA7\xE2\xB4\xDB\x8D\xBA~q\xAAO\xD1\x05\x9F\x8Fc\x87\x1E(js\xA39\xCF?\xBEX\x96`K\xAC\xF8l\x04\x02\xF1{\n-\x97\x84\x95\xFEnAZ\x16x2^s#\r\x01T\xD6\x89\x16IC\x84bY\xF2\xFFB\xE8\xA3\xECY\x9A{&\x90KB\x92\xAEE\xC9e\xD7\xDE\\\xCC\xAE\xC2\x89\x12\xAC\xB47\xEE\x7FX\xD1\xA9\xAF\\IGE}k\x18\x85r\xEE\x18\xDE.\xB5\xDA\x03\x99\xE3\xC2\x7F\x88\xAFTOp\xA3\x9A\x9B\xD7\x99Kd\xDD\xFAG\x8A\x00\xBF\xB3\xAD\xFA\x1D5\xEDw\x8F\x14\x13\xCF\xC2\xD5\x9E\xFF\xD2\xE1\xF3oa\x04\xFF\x85\x7F\xA1\x8C\xFA\xB2\x98r\xE7\x15\xA5\xBE\xB5\xE1\xF3\xAF&|\xFE\x19q\xE6\x9F\x118\xFFft\\\x92\xCD\xBF):\xF5Xs\xAD\x8B\xABJp\x83\xBD\x89\xFE\xFB\xA5\xBC\x96\x11@\x89\xD7N\xD5\x17\x00\xDA@P\xCE\xDA\x1C\x8B\xC2\x7F\xBF\xF5\xFE\xDFoy\x0E\xBF_6\xFF\xCAV\xE0\xFC\xD3qI\xD6\x9C\xAC\x862/-\v\x8C\xF0\xFB\xAD\xB3yrF\xA2\x8C\"\x81n;\\\xF2\x1C&\xF9\x80>\xEE\xF8\x80\xF6@4\x9A\xBE-\xDC9\x8B#\xF8O\x9D\xBD\xEC+\x8E\xAD\xE5\x92\x8C(^\f\x1AF\xCAX`\x84\xDFo\x1D\x84\x96ofSO;A\xDA\xC3\x0F\xD4\x16>\xCD\"\xF8O\x97\xBD,\xCB\xCB\xB9\xF0\xF0`&\xE0iY`\x84\"\xBCu\xE1\xBC\xB6UU'Z$\r\xAB\xC2\x8B\x15\xB5\x86_\xE6\"\xF8O\x97\xBD,\xCB\xCB\x8F\x85\x87\x07?\n\x10\x16d\xFCX\xB8\xFF2\xE1\xBC\xB6\xAC\xDAE\x9C\xA73\xE1\xC5\xB2\xD8Uo\xABn\xDF\xA6(\x92F\xA8\xB9KaN\xCD\x8D\xA2\xD5\xB0\xE2\x9E\xF1D\x90\x97\va4<V\xB1\xAC\xBC\xDE\x96h\xFE\x9B\xA5\xBC\x8C@ \xCE\x0E\xA8\xA3q\xE3\xD4f\xD667j\x11\xA2Ig\xD5\xDCHPP#\x9CL\xB8v\xCCq\xEC\x96\x82\x9ALi\xFB\x1DK\r\x84\t\xCE\xA5\x1B\x0E\vK\xA1ti\xA17T\xD5B?i\xDD\xBC\xB0`\x1C\x85\x85\x05\xFE\x8A\xEE\xE3\x92\x91\xE8f\xBCj\xB5\x11\xB4\xE3\xDEl\x01\xA0\x97\xBE\xF2\xDE3\x93\xEC\xCF\xBEb\x11\xA0\xCF>\xF3>z\xFA}\xC5\xA2YK>p\xFE#x\xFE\x99\xE1\xF3\xCF\xA4\xF3\xCF\xF4\xCF?\xC9f6\xAF\xB4\xCD=\f5\xDD\x8C9\xFFj\xC2\xE7_\xEF\xCAnWY>\xF1\xB0G\xAAO<\xDC\x9Dx\x92\xFD\xD9\x17./\xF7Z\xC23\nm4i\x04\xBA^e\xEF,\x8D\"E\x93\xB2\xF9W\xB64\xF3\xAFGC7\xE3\xCD\xBF\b\xDA\xF1\x89\xF0\xF9\xF7r\xF8\xFC;!\xF2Km4\xB3\xDE\x7F54\xF9]\xDB\xDC(U\xF0\xF9J\xDB\xDC\xC8P\xA8\xC8R\xB1\xAC(\xF3/\x15\xAA\x1D\xF7\xEE\xF5\xFC\xB7\x99^_\xB64\x14\x8CW\xB64\xD0\xDF\xEF\xBD\x9E\xFFn\xA3F\xDEvo\xD18v\xDB\xBD\xFE\xDFoc Q\x8C\xDA\xDCH\x1EE\xE4\xB5,\xA8Z\xDB\xDC\xC8\x80J47\x8A\xA0\x1D\x933\xDF\x02A\n4s\x9D6c\xB8W\f\xD3\xD0F3\xE7\xC2\x97\xFB\xFA\xE6FiA{\xEF\f\xBF\xFE\xA9\xF3\x8Eg\xA1\xD7\x06\xD8\xD2\xCBv\x11\x15hF\xE6\xFB\xC2\xE5e6\xFF\x82\xA3\x99/\x0F\xA7\x9B\x8D\xE1Dq\x0E\xCD\x8Df\xA7\xD7\x06\xD8\xB2\x99\xED\"*\xD0\x8C\xCC\xDF\x16./o\x169b~.\xF3/\x9C(\xCE\xBE\xB9Q\xA5\xD2\x81\x95\x1C[T\xA0#d\fK\xD9\xCB\b\x04\xE2-\x86\xD9\x84\x07\xBB\x85\x84bqII\xAF\r\xAE\xFEs*<K-L\xAF\xAD\x9E\xD0\x1F\b\xC4\x03\xCD\xE2\x81\x01C6Fx&\xC7%!\x95\x89\xC7%!+\xACEw(\x86\xDF!\xAE\xC8n\x0F<\xB7\x82}\xAD\xDF*\xDEz\xB76X\xC6\xA4{\x13\xA8\x1Ew\x0Et\"\xF0\x8C\xFA\xC2\xFD\x172\xCA\xCA\x18\xF3\xAF\xF7\xEA\x12\x00\x89\f~\r\xD2n/\xCE\xD7\xAE.%~\xF6\xDA\xD5\xDE\x8D\xAA/\\^\xDE\xA13\x88\xBDw\xBB\x15\xAA\x91n\xCDxk$.\xE2.\x03\xB4\xC9j\xD2\x1D\xAF7p\x94\b:\xEC\tq\xFD7\x97\xF9\xF7Z\xF8\xFC\xFB]\xF8\xFC;\x11>\xFFNF\x98\x7F\xF6bG\xB1\x00\x9A\x06\xA7\xF0hb\xC2em\x15\x99\x7F\xFAQ\x1A\xE2\xCC\xBF\x06\xCA%\xA1z(\x1E\x97d\x0F\xC0zu_\xE8\x16\xF1\xB4\x82\xCF\xAD\x10\x96\xBDl\xC1f+T\xB4\xB8-\xDC\x7F\x9B\xA1b\xD2\x07\xC7%U\xBDt#r\xC9\x1D\xA2\xAFT\xB8\xDD\n=\xB7|H\xF6rzR\xAE\b\xAE\xC2\xA2(\xCDP\x03G\x89\xB3\xDC\xE7\xB8\xA4\xD8K7\x02\x97\x04\x91K\x06W\x9F\xEA\v\xCF2M)\x9E\xCC\xF2\xF1\xD9\xD5\x13\\\xF0\xBA\x16\xB9\x88\xFE\xD3\x8F\x12\x87nr\\R\xEC\xA5\x1B\x81K\x82\xC8%\x83\xABO\xDD\x16\xC1\x7F!\xD9\xCBf\x96\xCB;\x86\xB9>o*Td\xFE\xF1tS\xE8\xA5\xFB&T\x9F\n\x93\x97\xAB'\x02::\x81p\xA0\xB0\x93\x0E\x1D\x05\x81@\x9C]\xF0\xE9\xB5\xC1\x88\x12\xCD\x1C\xC8 #\xD3M}A\xEApy\x99\xDA\xE2\x99kL\xF7\xD8WB\xCE\\\x05\xAF\xD56}R\xD9B\xFD\xF7\x04\xA3n\x11n\xC1at3\x88\xE3\xBC\x1Ck\xB9\xBF\xB2\xE0\xE3\x9C'\x88\xA5\xA2\xB9\xB2-\x8E\xFF,\xC9\\cr\xAB\xCD\x849s\x15\xBCV>\x90\x92\xEF\xFB\xEE<I\xC8jz\x17\xCE\x86n\x06q\xEC\xDEXt\xD3\xB6J\xE2\x9C\x0E=\x14\xCD\x95mq\x16c\xB2\xB9n\x04.g\xAE\x82\xD7\xCA\x07\x12\xBF\xCB\x13\xEAs\xE3\xE3\x05\xA2\xCC?J7\xD9r\x9F\xA7\x9BA\xF3os\xAC\xF9\xB7\xD0\xFB\xCE\xD9\x9A\xDFQ\x1EEse[\x9C\xC5XI6w:o3a\xCE\\\x05\xAF\x95\x0F$~\x97:\xBA\xC9i\xA4\x11\xFC\x97\x0F\xAF>\xB59p\x05\x1A\x99n\xD2\n\xE3B\xF5)^\xE4\xCF+\x18\x8B\x94\xBD\\p_%f\xCAVz\x927W\xFCV%^!\xA5\x99\xF3|\xDFw\xFD\x9BV\x19\xA4_\xAEV\xAE\xFAT\xC8\x81R\x05e\xF5)9\x11:8{9\xCF\xEDB\x99\xBAb]\x1C\x1C|\xCD\xF3}\xFF\x83+I/\x83p\xBAT\x99\xEASQ\xE9\xA6x \x90\x8A\x15\x05g/\x03\x97\xC8K\x99:1W\xF4\x9F\xF2@J\xBE\xEFCH\xF5)\x1F]\xAFX\xF5\xA9\x10\xFFix-D\x91\x97}\xD9\xCB\x06\xCF\xD4\x89\xB9\n^+\x1FH\xC9\xF7}\xD37\xA4\xFA\x94\xCA\x7F\x95\xA9>\x156\xFFB\x85\xE18\xD9\xCB\xD3\x12SW\xF1Zm\xD3'\x95\xBC\x8C@ \xCE^H\xE1\x99gZ\xD6\r\x05H\xBA\xF6&Bx\xF0\x99\x96B\x05L\xD3FV\xC7\x92\x97\xCF\xE8x\xED\x94\"\xCA\x9B#\xE4-\xF6(\xE1|\x9F\xE8e\x8C\v\x19\x94\xD60*\xC67\x14*\xF0\r\x85L}s\xA3\xEE\n\xF8O\x9B1\xACjnd\x8677b\x85\xCE\xAA\x8D\x92\xBB\x91\x9E\x9Ar\x1D\x8E\x8C\"\xBC\x8D\xBFa\xFA\x17w\xA4|\xD5\x89\x95\x05\xFE\xD1A\xDB\xBC?\x9D\xEF\x94\xD9%\xBDu\b:F\xBA\x8D\xF7w\x8Ct\xBB\xBDu:G\xC6\xDD\xBEF\xAC\xB9\xD1u#\xE3\xC6\x07\xAF\x1B\xA1\x89\x94#\x95\x98\x7Fm\x17\x95\xDC\x16:\xAC\x8F\xCE\xC6\x8BJ\xC6\r\x1B/\xF2\xCE\xBCsO\xD1m\xAB\xC3z\xEB\\\xBF\xA7h|\x84\x95e^\x07\x9Af\xD0\xAC\x02\x17\xFB_\xAE\x12\xF4\xBC\xA2\xD1\xCE\xADYm\x02\x93\x03\xBF<%\xCD\xBF\xB6y\xD7f\x9C\x03\xB1\xDF/\xD7P\xC8\x9E\xF2\xD7\x1D\xF2\x1A\ni\x7F\xBFm\xF3*1\xFF\xD6\xD1\xE6FS\xFC\x99\xF3\xCD\x8D\xAE\xD7\xD9\xC2~\xBFm\xF4\v(\xF3\xDF\x82\xBB\x91\xBC\xC6\x11\xA2|1q\x8A\xF3\x9F\t>\xBEJ\xF8\x16\xD1k\x99\xEA\xDBvx\xDD3\x8E\xCD\xEC\xF7{&_H\xBCr&\xEF\xFD~;-\xCFf\xED\xEF\xB7-_\x91\xF9\x97\xF7\xFC\xC7~\xBF\xBC-\x10`\v\xFB\xFD\xB6\xD1\xA9'\x8C\xE2n$\xFF\xF1\xFA\x07\x19E\x98\x7F)\xC5\xFCS\xA5\xE0\x9E\x01\x9D\xA4k_E\xD9\xD7\xAD\x95t\xDB*R]\x86\xB7\x85B47\x82-\xEB\xC2Ga\xBF_\xED(=\xA0\x89\xCF\x96\xC2\x83\xDB\x1A\x8E\xDC\x14 \xE96X\x91\x9A\x1B\xB5\xC5I\xDA\xD0\xFB\xAF\"\xCD\x8D\xDA@\x9D\xBD\xCC\xF5\x18\xE6\xAEz\xECUz\x9C\xCF\x96O\xE9l\x91\xC2\x83\xCF@k&@\xD2\xCD\x90\xAF;4<\xF8\fTd\xFD\x12\xDE\xDC\xE8T\xB8\xBC|\x064\xCD\x8C\xF9Q\xC0\xFF\xE4)e\x8F\x12\xCC\xF7m[|\xE1\xC1\xAD\x99\x00I\xD7\xE6\x83s\xAA>\x15{\xFDR\xC1\xE6F\x12\xAFUe/s\x1As\xB5=\n\xF7xL\xC7\xF7\x11\b\xC4\xD9\x8Bp\xBD6^L4\x84\x06\x19\xAB\xF4Z\x10\xC5X\xBD^\xFB\xBA\x99+\x94\xCDJ\x1C\r6\x97\x98\xE6\xD8\x92\x12\x9A\x03(\x11\xA79\x8F\x011\xD2Kr\x02\xBF\xECW\xD0\xCD\xFE\x1C\x98Y\x8EnF2\xB7\x14\xD3\\\x99\xDD\x01\x18\xABC\x84\x07\xDB4\xC7\x16\xAAQu\xE8\xBF\xD0\x18l\xAC#x(j\x86\xC4%!/\x88a9\xB2@\v\x9C\x7F\x1D\x15\x99\x7F\x1D\xE1\xF3\x8F\x99\xAB\x9C\x7F&\x84\x1A\x94\x9A\x95A\xC1\xFE#\xAE\xD3\xCE?\xB6\xD2gz\xA3ou\xA8C\x9C^8g@\x90\xDE\xC0}\x95\x98V\xDB\xA2:\x9A\xD0\x11z\xCE\x06\xB1\xE6Zs\x99\x7F@\xF5\xDA\x14\xE5\x04\xAA\xEASs\xFE\xBA\x99\xEB\xB8\xECe\xA2\x86\x07\xFE~\xCB\x16\xF8*_W&&:B\x90\xB1\x96Kr\xDF\xB9W}*\xCBh\xB8\xAA\xFA\xD4\x9C\xA1jn\xA4\xDC\xCF//\xBB\xD7\xBF\b\xE5tb77j\r\x9F\x7F\xB2\x8CJh\xB8H7\xD7Jz\xAD\xA2\xFAT\x05\xCD\x15\xB5\xE3\xAC\xE4\xBAN\xD5.\xE4@bs#%f\xD7\xDC(\x82\xFF\xB6\n\xC7X\xEF\xA7\x9B\x86L\xC3#\xC8\xCB\xF1\n\xF2\x83Z;^\x1Fln+\x13\xCC\xD3\xE1\v\x82\xD957\n\xFE-\xC82\xAA\xC8%S\xA0\xD3k_\x8F\xF9\xE7\xD7\x8Ey[r\xDA]\xB0\xFF\x11\x02\xF1\x16\x80\x92\xE2\x89\x8C4\xCAZ4\xBC\x12\xD6\n{m\xB6\x82]\xBEH\xBD\x16\xB1@\xCB\x95\xFDE\x80+\xC5\x82\xB6Rs\x8F\x15\x15Y\xFA\xF1\xB6\x98\xEE\xA3\xE6\xA8\xB6\xB0\xE2\xB0z\x8A'1\xD2\x88\xCF;\x83+<\x1Byo\x17\x87>\xB8:N\xE2\x15\xA0b\x8Ey\xD8\x93t\x99\x186s\xB8\x9885s\xB8\x18z\xA7\xCB\xC7iC\xCC\xD9\x92~\xC6\x9D\x02\x11ma\xD5j\xF5\x14/\xF6\xFCk\xA3z\xA3\xB6\xAF\xEF\x99\xFAn\x803\x16\x95\x98\xEC?\xDB\x86\xBB\x8D%\xE4\x95c\xDF\xB0\x17\xD9\xCAj\xED~`x\xDC\xB8\xFC\x03\xC3\xDEr\xFF\x8C\xBE\x88q\x8C\xF9w\xE6B/\xB2u\x1D$]\x8E\xBD\xEE\xC2\x92\xB1\x12.\xF4\xF8\xD6\xCC\xEE\xA2\xEB\xBA\x0F\xD2C~pw\xD1x/\\\xE8\xF7_\xCF\\\xAF\x02m:\xBD\x96\xF9o\x05\xAD\xF0\xCC\xEA:\xB7\xD5\x17\x8C&v\xE6\xEF\x18.\xBAevY\xAD\xDD\xF6\xE1\xA2\xD1\xDC>\x1C\xFE\xFB\xAD\x8F1\xFF\xDE\xCD\xD9\x92t\xA5n\xC9\x96w\xE9la\xD5\xA6\xFD\xC4\x0Ex\xBA\x19\xCB\x7F:\xBD\x96\xFD \xDA\xEE\xF4lv|p\x9E}\t:\xAF\x00O\x90W\x8E}wz6_Im\xB9\xF2\xCE\"<mo\xDCQ\xB4&\x9C\x17c\xFE\xB5\x9D\xC7lI\xB8\xD7\xBF\xA8\xB6\xC0y\xC5\x98\x8C4\x8AA\x10\xAA\xB42\xD79\xBB\\R\xF2\xED\xC2\xCC}#\xE4e\xD7\x16M\xF6r\x04[\x18\x94u\xA3b\x19\x14^}J\xDE\xA5\xCA\xF2\xED\xD2\x1EA^\xAE\b\xF5h\xD3e/G\xB0\x85\xC9{\x92\xFF\xE4\xBAQ\xB1\xD6/\xE1\xD5\xA7VH\xBB\xBC\xC7\xBF\xCB\x95\xE1\xF2\xF2\x8A\x8AP\xDF\x15\xBA\xEC\xE5\b\xB6H\x93P\xC5H\xE3\xAB\x9B\xF1\xAAO\x91\xBF\x17\x94f\xD7\xDC\xA82L]\x93\xBD\x1C\xC1\x16\xD5\xFCC \x10g\x1BdF\n\xFE\xE6\x1EW\xD2\xBB8\x97\xAF!\x12\xC0\x05R\xF5\x15SL\xE7\xB27\x9B\x92Y\x80\x8C\xBF\x04\xCB*Hz\xD7\xE2\x9Bi/\x12\x11\x1C\xDDT\x8E\x92\xCC\xF2\xA3\xB0&\xC5,\xD4\x11L\xE1\x91rJe.\b\xD9g\x8D\xE2\x06D\xCEN\x990\x18\xF9\x92\x1B\x19,\x95\xCFe\xB9s\x84\x00\x9Ec\xC9\xE1\x99\"\xF1\x14\xAB\xAF\x90?\x99\xDEco\x8C\xFCW\xDD\x01\x04\xE5,q\x1A\xF2_\xA5ts\\\x95\x13'\xA8F\xF9\xA2\x7F\x94\xBC\x9F\x91J\x95`$y\x8AT\xA6\xE5\xD6\xBB\xF6JF\x92\x84\xA6\xA8K\xCA\xE2\xB3u\xA6\xA6\x91x\xDB\xB2MV\xCE\x88\xAB*\xC2b\xDA\xEA\x85\x9E\x113\"\x8B\x91\bL\xB9\xDF\xE2Y4QV8\xBD\xDB\xDEL\xD5e\x01V\x97\xE4\xE5\xAFQ\x0Fu\xDE\xCC8e\xD3%\x7F\x87\x19\x9E.9\xA3X\xE2\"\xB0.\xCB\x8F\xC2\x94Q\xAD<\xDA\x9AR\x98\xCB$!J\xE1\xDB$\xBF\x88\x1C\xBBs\xA4\b\xB0\xC2&\xCB\xEB\xC0\v\xD4d,z\x1De\xD1WR\x02\xCDX\xB4L\xA0iwo\xD6\xF6\x9B\xEB\xEEmo:.\xC8\x02\\e\xF9\x96o/\xC0\x05\xDE\x99wR\xBA$\x82\xA3K\xCAQ.\xC8\xF2\xA3\xE4@\xB4\xC53\x88K\xBBl\xA1\xE6\xB2\x9F\x8B\xFD'\xD7\x8C|\x80.4\xCB\xDC\x8AQ\xE0\x88\x83\x03E\x91\x05\xD2\xFDl\x16\xB8\x82\xB1@\v|,P\"\x80\xAD\xE1\xD7\xBF\x81\xED\xA1\xD7\xBFA\xFA\xB8M{\xFD\x1B\b\xBF\xFE\xB5B\xE8\xFC\x03){\xD9\xF4K\xBA\x9B\xC0/\fK\xBF\xDF\x9B\xED\xDF\xEF:\x89\x91*\x96\xF1\x1F\fg\x81\xAD\xE1\xD7\xBFM\r\xE3\x00=\x96,\xF4\x193\xD0\xE0\xD9\xFCW\x87\x8B\xCA\xEB\x1FwqS\x8E\xD20\xCE\x8F\xD2\x1A\xE1\xFA'e/\xDB4\\\xBA\x7F\xA8\x84a'q\x99\x96=\x9E\xB1\xBF\xEE\bA\xC6\xED\xACz\x92\x10\x1E\xCC\xA1\x85[\xD5S^\xCB\xD2\x81\xEDc4\xD2\x01D\xFA\xC0qI]:\xA6\xDC\x8BI\x1E%\x95\xE5w\x91m\xF1f\x84B^\x16\xCC\x15s\xA0\x95y\xC7\"\xC7\xC9Y\nF\n\xFE \xE3+\xA9\xFF\xC4\xF0`\x90\f\x92y-K\x07\xB6\xD9O9\xEDqq1y\x96\xE3\x923\x8C\xAE\xEBvQ\x8E\x92\x1E\xE7wQ\xCA\xCBb\xAEoJE\xC3\xC5\x1C\xE8E\x10\x9AT|\xB9mn\xA4 c\xF0\xB1@Z\x05\xC4\xBB\xE7\x05\xF2\xDAt\xC9>\x90\xC7%Eu\x98\xE3\x92\x8Cn\x82n\x17\xE5(\xD5\x02#\x8D#/\xF3\xE6\x8A\x92\xAEF\x18\x16\xE7_\x16\xF9\x03\x02q6#g)n|t\xB9\xD5H\x1Bjh\x9B{\xA4T\x85G\xC5\xB5\x80\xC7\x8E\xADl\xCA\xE4)(\xCF\x8E\xC9\x95Y\\\xD7e\xEC\x15#[\xD7i\x99z,\xD5\xB7\xD2P\x96\xA6f\xB5\xAD\xF3\x1E\xBB;\xA3\x93\x84d.\t\x8A\xF0Bgu\x98>=\xD3C\xC3o\xB9\xD5aC\xC9]$H\xBC\xD6\x11|\xE9\xD2O\xD6\x8E\x15\xB6\xBC\t \xB9_\x9D\x92\xFF\xE6Q\xBA$\xE9\x8D\xE0\xD7\xF8d.\t\xE0\xE3\x92.;6\xB3\xFD9\x96\x86,\xB1c\xFB=\x89\xD7\xAE\xDE\x95%\xE4\xD6\xF3\x95\x8E\xA9\xC7R}_\x97\xDF\xAF<\xFFhs\x9E\x81\xF3\n~\x16(j|2\x97\xF4\x88'\xC7%]vl\x94nZ@\xDF\x93\xD9\xB1\xFD\xE2*\x91W\\\xF5\xB9\xACCn\xDD\xE3\x86\x7F\x97o\xD6\xEFw\x89\xEE\xF7\xBBI]}\x8A/\xF6\xC4~\xA6\xDA\xF0\xE0V\xB7\x84\xF0\xE9\x19\xA7\xA5\x91\xF4\xFB\xB57\x03\x12\xBD!\xCB\xFD\xBD\xE4\xD7M\x93\xDAuL=\x96\xEA[i,\x91x\xADx\xFF\xD0U\x9F\xE2\xAF\xD9\xF6\xCFO\x1F\x1E,2R\xAE\xE7\x90\xC0\r\x9C\xFBG\x8F\x15\x14\x06\xD1\x16\xCE\xD4\xDF\x048\xB9\x87\x92\xFFD\xBA\xA9(\n\xC5\x11\xC5\xF2\xDERPx0\x99\xCE\x0E\xBB\xAB\x9A\x9A\xE6z\x0Eq\xEC\xD8\xF2\xFEW\xE4\xB5\xF9\xFE,oK\x04y\xF9M\x80\xCCkEr\xDB\x18RU\x99\xCC\xB5BPx\xB0\x03\xB2Kr\x17\xDFs\x88\x8D\x92\xF1\xAEz\x12\xAF\xCD\xDA\xFC\x128\xD57T^~\x13\xD0\xA0*\xAD\x1C\xAF\xB9Q!,<\xD8e\xC7\x89\xEEi\xA9\xE7\x10\xCF\x8E\xC1\xC7k\x1Bv\x8C\x8B}}CmA \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\xF1\xBA \x95\xB1\xB6\xCD\xAC\xE93\xE1\xA6\x05\x19\xB06e\xEAnj-g\x07Nn\xEDY;t\xF4\xA6\x05u-;\x1B\x9F\xCA\\\xFC\xD7?\xEB_;\xB0\xEC\xDFg>6dm\xD8\x93\xACy\xE9\x9A\xD5k\xFA\xE0\xA6\xFE\xD6\xDD\xDB\xAFZ\x99\xFAF\xF7\xFB\x8A=\x89\x1D7\xA57=u2\xFB\xB9d]\xDF{\xA6\xFF\xAA\xDF\xDA6s\xB4\xE1\xC8\x89r\xE3\xA2\x97\xCEL\xE7\xDE\xF3j\xE3S&l\xCBl\xCF]\xF5\xB9\xAC\xB5\xF6[\xD7Ld\x17\xF5UO\f\xD5\x9D{\xF2\x9A\x99k\x92\x05+\x9B\xAA\xED[t\xF7\xFFix\xA95\x95\xCBX\xD9l\xB9\xF8\xD9\x89\xBD\x99\xAB\xB6=\xFFJO\x12Z3;\xAA\xCB\x9F\xFE\xBF\xB7\xBC\x07z\xCB=?\xDCg4\xB7\xD5\xCF\xAFK\x19\xE9\xBEE\xC7r\xEF*\x15\xB6O\x0EZ\xE5c\xA7\xFE\xB6T\xB8\xE9\x9A\xAB\x1E\xFF\xE2E\xA9\xFCxo\xD3\xFB\x8D\xC1\xB1\xBB_N\x1D\x99\x98|G\xFF\xC2\xEB\x06s\xF9_M\xF4\xA7\x1AN\xD5\xE5r\xB0s*\xB9t\xE7\xE76\x99\xEB\xEAnm\xCD\x98\x97\x8Cg\x1E~\xF0\xB1\xF45\xFDK\xEB\xD7\xDE\xB4=wqy2{\xF4\x82lo\xB9\xC7\xACnnI\xF7VOg\xD7\xED}\xEC\xE2\x99/\xF6\x99\x1B\x9As\xEF\xBD\xBF\xEB\xA2\xBA\xC6+\n\xD9U\xCD\xED\x97f\x7F\xBD\xB6/\xDB\xD7\xBF\xFB\xF8\xE4\xFA\xA6\xBD\x8F\xC1P\xD3\xFB\x9E\xBF\xE6\x81\xF2\xE7\xFF\xCF\x99\xC5=\xDF\xBB\xB1\xAB\xEB\x8B5M\xBB\xF7\xF7<u\xEC\xBD\x07~\xB5\xA7k\xE3\xCC\x17\xD3/\xFEa\xFF+\xA7\x7Fu\xE9`\xCF\x99\xC5\x93{_9\xFC\xD2\xE0\xD8\x8D?\xDA\x9E\xCD^]\xBBc\xE6\xE1T\xFA\xC5\xC6\x7F1;\x1A\xA6:{N\xAD\xC9fG\x0E\x1D\x9F\xB4\x1E4\x93\xBB\x8C\xA5?J~\xB6i\xDD\x81ugn<\xFC\xFC\x93\xEF\xB9\xE0\xB5\xD1\xD2\xE9\x9F}1\xF1\xC2\x853\xA7\x0E\x1F\x1D\x1A\xEAyj\xFBg2\xD9\x86u\x93\xAB\xCB\xC3\xEB&\x9B\x16g\x92\xAD\xF3\xCA\xDF9\xFE\x9D\x99\xD4\x85\xE3\x9D\xFF\xB05\xF1B\xE3\x86\xD6du\xF9\xDE\xD5+G\xDB\x87su\xE3\xBD\xF5\xAB\xBFu\xCD\xD4\x82}\xBB\x1F\xD8\xD2r\xF1c\xC9\xA9\xAE[j\xCE\x9D\xBA17\xFC\xC1\x91\xC1\\\xDF\xD2\xE9\xFE\xD5\xBB\x16_:6o\xE9\x15S\xD3m\xEF\xBDv}\xD3\x86=Y+\xDB\x96\xEE8\xD3p\xCBg![.\x0F\xCD\xEB\xDCpp\xEF\xC9\xEC\xE1\xE9\xD4\xA0y\xEC\xDA\xFA\xAE\x89\x83\xC7\x0F<\xB8e\xDE\xF3fU\xE7=\x97\xEE}b\xE0\xE9u\xBBZ\xAF\x999\xF8\xCD\x83SFk\xFE\x85e\xB9c{\x8F>8slx\xDD\xD8\xEA\xD5\x87_x\xDF=\xE5\xD1\xEF\xBE\xEF\xFBuu\xCD\xB7f\xFFj\xE0T\xF63\rkw\x9E>V\xFEfr\xF7L\xD5\xF05\xA7\xA7\xCBu\xB9\xDC\x99\xDC\x8A*\xA3\xDC|\xF8\xC4gz6\xDC\xFFG\xF7}bW\xFE\xE0\x7F{j\xE4p\xCF\xCF\xFA7X\xC6\xE9\xEF\xDF8T\xD5S^\xBB\xF8\xF9\x9A\x8E=\xB5\xD7\xFE\xF5\x86\x13\x9F\xFE\xED\x99\x99\xDA\x86\xA3K\x8F\x96\xBF\x95\xFB\xE9\xBD\xA7G_\xC8-l\xABz\xE0\xAA\xC9\xC6y\x97\x9E\xFB\x99\xDF\xE4\x8FO\x95\xFF\xFA\xCF&\xCEL\x8F\xFD\xC3\xAB\x8B\xBF\xD7\xB5\xBE\xAF~{j\xF9\xE7\x1A7l\xF8\xD6\xAA\xE1U\xED\xC3k^\x1E\xAE\xBB\xF0\xA5\xA7\xB2\xC9=7\xF5\xCE\x8C\xDC\xDF\xB4\xFB\xB1\x0F\x7F\xFE\xF1\xD3\xFBRu\xED\x07\xFA\xCB\xBD\x7F\xF4\xA1\xBD\xAB\xAEJO\x1Do\xCD\xBF\xD8\x96m\xD8S>\xFDD\xD7{\x0FN\xFD\xC5\x1F_\xF8\x1F\xD74\x7F\xF4\xBD\x13\xBBS\xBF\xCE\x1F\xDB\xF4t\xEE\x8A\x17;\x9B\xDE\xFB\xA5\xE6=O\xDF\xFC\xF0\xBC\xFB>\xF5\xEF\x9D\xFFzfO\xEE\xD2\x03\x03\xD6OF\xAE8\xFD\xEC\xA7?\xFE\xDC\xE9\x99o\x8C\xDC\xB8\xF1\xC7\xB9/\x96\x1Em\xEE\xDF\xFB\xCA\x8A\x9B\x1F\xC8\xEC\xBC\xB5v\xE3\xE1\xFFH\x8C\xBDx\xF5\xFA\xBEk\xAF}g.7\xB2\xA6|\xFC\x85\xFE\x8Dk{?\xB5\xAB\xEF\x1B\xAF\x9D\xEC|\xA2\xBF\xD8[\xEE\xA9\xDDy \xB7n\xA8\xFAL\xD3\x15{\xBF\xDB2sI\xFF`W\xF3\xC8\xD8\xC1\xEB\xF7\xF4\x1C9\xB5m\xE6\x81\x05\x17L\x1E\xF8\xCD\x85/\x14\x07\xA1\xEE\xC8\xC9\xCE\x9D\xCF=Q\xB3\xA1\xEB\xBDo\x7F\xF6\xCB\xAD\xEF.?\xDC\x9F\x7F\xA8\xF3\xFA\xA6=\x99;[3k\xC6\xDA3\xFD?\xD9\xF3\xD1\x8D\xBF\xE8\xD9;\x95\xEB\xEF\xAC_z\xFD\xD7\xBB\xCE,;u\xE3\xEF\xEA-\xC8m\x1C\xFE\xFB\xFBV\xF5\x8C4M\xCD\x1F\xDB\xF9\xEF\x9B\x9E\xC8\x0E5\x9Ex\xACg2\xDD\x9F=\xD5\xF2\x98\xB5\xFAk\xCDc\xA3\xCDW\xFCh~o\xD3\x8D\xA37>\xD0v\xF15\xC7\xB74\xB4\\\xF6\xFCt\xFF\x1E\xE8\xEB\xF8\xD4\x8A\xAA\xE4\xD0\xC8\x9A+\xF7\xDD\x9A\xDD\xD3\xB0wr{Kmzr\xA5\x95\xA9m\xFBhy\xD7\xD3/M\xF6\xF7\x16v\xFDx\xAB\xF1\xD8}]=\xA9\xCF\x9E\xF9\xE7\x91y\xA3\xED{{ve\x07\xDE\xF5G\x8F\xAC\xBF\x06\xFA.\x1C\xED9\xB4\xF1Hrt\xC3\xCF\xF7\xB4\x9Dx\xAE}[\xEDL\xFB\xF0\xB6\x17g\xCC\xC2|s\xEC\xF0\xCF\xBF\xF1\xA7\xB9\x8F\x8D\xD7\xF5\xD7\xC0\xFA\x05\xB5cc\xE6\xE7\xBB\xCA\x7F|\xCB\xCFK\xBD==u\x17\fo\x18\xDB\xFBj\xF3\x8A\xC9\x07\x9B'\x07\xAF\xBD\xE8\xC3'\xBA\xFE\x87U\xDD\xD6\xB2\xBFPuMK\xE1\xE2\xB5\x89\xDF^\xF1jWG\xD3C-\x0F\x9Eho\xAD_S\xDB\xD2\xFEO\xFB\x96M\xB7\x0F\xAFi\xCE\xECJ\xDDa\xC0k_\xADM\x94\xEA\x1A\xAF\xB8)\x99J\xED[\xB4\xBE\xE1\x99\xDEk\x8E\x95w\xAD\xDE5\xFD\x87\x8F\x9D\xFB\xEB\x99\x9E\x91B\xDF\x99C{6\xEE\xB9q\xD1\xB1\x07\xAFz\xEE\xE7\xBD\xAB\xEF\xBF\xFB\xCE\x87\x0E\xFE\xF9K_\xFF\xFC\xAB3\x9D\xB9\xBA\x8B\x8E?s\xE8\xD9\xC5\x7Fy\xFA\xA3\x7F\xFAb\xEA_\xF6\\V8=\xF3\xD7\xD7\x1D}\xE43\xA9\x8B\x9F\x18\xDD\x0F5W<\xDFs\xC5\xBF\x9D\xCC\xECm[\xF3\xE2;f\xAE\x1B\xD9\xF6o3/^\xF0\x83\xA9\x9Ew\xAEy\xE5\xCC\xF4\xB1/\x7F\xFB\x81\xEFe\xDAV5\xD7\xA6\x96\xAD\xEB\xDA\xF0\xF3\xEF\x1C\x9F\x84c\xC3\xD7\x8C\xDF\xDD\xBC\xFBh\xF6\x13\xD7\xEF\xF9pM\xFB\xBC\xEA\xED\xBB\xF7/m8\xDAje\xE6\xEF\x1C\x82\xDF\xF6>\x06\x87W\xBD\xE7\x9A\xE7_\xCDd>\xBB\xF8C\x1B\x1F\xB9\xF1\xF4\x8F\xBB\x9A\v\x03\x7F\xFA\xE1O\xFF\xDB\xE9O\xFD|\xE4G?n\xFEM{\xFFT\xA9y\xE9w\xD7\xEF\xB9\xED\xCE\xDA=}\xDD\xDFn:0\xF9g\x0F\xBD<9\x06\xD9K\xBF\x97z\xEE\x9B\x89\x7F;t\xCB\xF7&z\xFF\xE6\xD3_\xEF\xBA\xFE\xC7\xE6ga[\xAE\xF9\xE2\xA6\xEB\xFE\xE6\xC0\xD7\x9F\xEDX\xB8qp\xB0\xA3}\xDD\x9E\r\xF0\xB1R\xC3\xFF\xBEe\xA4\xFA\xA9\xDB;G\x9E\x1B_<S\\\xF5\x8D\xD7N\xB6\xEF\xEF\xDF\xBF\xEB+=W\x8C\xFDm\xF6\xF8\xF0\xD8\x96\xA6\x1F\xEC}\xACe\xE6\xA3;\xCC\x0F\xEC?4\xB6\xAE\xFDk\xEF\xDB\xFD\xDF:\x92=\xA9}\xD9\xEC\xF3\xCB\xFBrc\xADukN$\xAB\x0F\xBF\xD0\xDC9\xD2W}\xF2\x01\xB8\xF8\xD5KG\xBAZ\xDA{\xDAS\xE6\xE2\xBA\xA65\xEF\xAA5\x0F\x8C\xD8\xD7\xBF\xFC\xC5\xFF\xB2\xEA\xFD\x1BV,\xDD\xB0\xA7\xEB\x91\xC6\xA9\x1B_\xE93\x9Bs\xCF\x9D\xDA\xFF\xE3\r+.\xBA\xB6\xBC\xEA\x96\xF4\v\x8B6\xEC{\xB8\xF5\xF9'zN\xED+\xF6O\x1E\x1E\xB7\xFA\x0F\f\xB7\x8F6\xFF\xE5\x13\xC5\xA1\x91\xA5oox\xA0\xED\xC6\x1F~\xFC\x8F\xFE\xB5<\x96\x9D\x9CLA_\xDD4\\q_a\xE8\xB3\xF5\x7F\x7F\xEB\xFE\xE4`\xE7u\xE5r\xFF\xB6\xC9\x95\xAF^\x04\xF7\xB7\xE4\xAF\x1C\xFB\xCE\xCCX\xFF\xF6\xD6=d\xFE\x95\x07\xAA\xCElx\xDB\x9E\xC9\xC1\xE1\x9E\xF3{k\xF6\x7F\xB2\xB9\xAF\xF5c]+\xD6oiY\xF3\xDA\xFF\x18\xEDj\xB9\xA8\xF0\xFCs\x83_\xAB=x\xCE\xF7\xB6\xBD8\x9D*\x8D\r\x8F\x1E\xEA\xB9\xE2\xC1\x97\x7F\xB4zw\xA9\xB7\xBE\xF3\x86=?\x1Cl\xFE\xBB\x8F\r\xFE\xF1-\xF9\xF1\xDE\x96\x9E\xBA'3\xD9\x83\x7F\xF7|\xA9\xFES\xE9\xC1\xCE\xB1\x17\xDF\xDD\xB1\xBE\xB9}\xF8Z\x18\xD9\xB0v\xA0s\xAC\xEB\xC6G7\x96\x7F0dY\x93c\v\x1E<\xD1\x9E5\xC0Z\xB6\xEA\xDD\x0F]7\xF3q3=V8\xAF\xBFoK\xCBK\x0F\x1D\xEBy\xAE\xEB\xDA\xC3\xE3\xFD\xE6\x82\xAF\xAC?z\xFE\xFA;\xBF0\xD6\xF3\x9F\n\xBD\xD3\xF3\xF6-\xFA\xF5L\xCF\xE1\xF1m\x0F\x94w\xDD\xF8\xAD\xE7\x96~\xEF\xE5\xBA\x9E\xF2\x9E\x1F\xFD\xFAT\xF3\xBE\xE3\xEF\xFB\xC4\xA7\x1Eyu\xEBX\xF6\xA2\xAE\xF2\xE4\x8D\xFFr\xEDg\x9E\xFB\xF0\x9F/\xEE\xEC\xDA\xBF\xC3\\6\xDD\xB5\xE9\xE9o}\xE6\x17\x17?\xF1\xD0\xCA\xCE\xAAk\xA6\xFE\xF7?\xDC\xF1\xDC\xE4#\x7F\xF4\xF9_\x9D\x9E\xB9\xAE\x7F\xE7\xE9\xE9\xD7\x1A~0\xF5\xD1\xFD{\xBE\xDB3s\xF0\xEB\xF5\x8B\xDB\xDE_w\xE4\xAA\xCFu-\xFF~\x7F\xB6\xFC\xAD\xA3u\x1B\x96\x99\xE9\xD3C7\xFE\xEB\x8Bw\xE4\xFEs~\xE9\xC4ps\xDE\xDAv 7o\xFF}\xB9\xE7\xEB\xC7~\xDB\xF9\xF3\xE1\x87\xA6\x9Ek\xBBj\xC7\x89W\xAD\xDB\xAB\x16_\x7F\xE3%\x1F\xFE_\xFF\xA7s\xF9\x7F\xA9\xD9z\xCD\x85\xE5\xA9O\xFD\xFB]U?n\xFE\xEF\xAB\xCC\xD3\xAF5\xE7\x7Fsr\xCF\xF0\xCE\xEF\xFF3\xB4\xBCg\xF5\x81y\xAD\xEF{\xF5\xD4#5\xB9\x07:nX\xFD\xB7\xD7<~\xD7\xC9c\x87\xDE7s\xD9\xAE\x1BN\x7F\xBF\xD6\x82\xDE\\\xEE\xC2?<=s\xE9\xD7.\x7F\xCF\x977\x0E\xDE\xD9\xF1\xF4w\xDF\xF3\xD7\xEB\x0F}r\xEF\x91\xEB\x7F\xF4\xABgV\xE5\xEE\xB9\xF1\xC7\xD7\xCE|}\x95}\xFF}nl_\xEF\xED\xF9\xBD?\x98\xBA\xFC\xCF\xEA\xF7M\x1FX\x93\x1E<\xF4p\xD7\xE7W\x8Fn8\xF4\xE5ucc]\x1D\xCD\xDF\xEC\xCF\xCD\x1F\xEBh\xFA\xCD\xFAm\xE3\x83\xB9+\xD7M%\x97\x1E\x1E?w\xFD\x8F\xAA\xCC\xE2\xA6\xE6\v\x177\xFF\xE3_\x9F\xB7j\xCBXs]\xFB\xFD\x97v}\xFC\xCB\xCDc{\xFE\xF1\xFF\xBE\xEB\xE6\xFC\xFD{\xBA6tu\xB4m\xF8z\xD7\x8B\x8B\xBB\xEFz\xB0v\xFBU\xABo<\xD1v\xFDX\xE6\x93\x0F\x94\xF7\xBF\xFD\vC\xA9?\xC8\xFD\xFA\xE3\x9Dw}\xA0\xB9h\xF5\xDF\x9C\x1F\xEF\xDDPU_\xE8\x9D\xB7\xA8i`\xC3\x81\xFB\x9B\xAA\xDF\xDF\xB1\xF7\xF9\xF77\x0F\xFE\xFD\xFD\xED\x7F5\xD3\xDC\xBC\xFF\xC2\x99\xFD\x87_\xC8\x0E\xD5\xEE\xDA~Sv\xC3\xFF\xCB\xCE\xF9\xC76u\xDC\x01\xFC{\xF7\xCE\xF1\xD7\x10\xF4.\xAE#e\x1BJ\xCE\xAEK~\x8C\x8A\xB4\xDA\xB4\x90Z\xCE\xC5\t,IicB\xC2F\xA7n\xD6\xB4N\xEA:\xB5\xF9\x83\xAA\xA9\xD4\xC1\xD9\x98\xF6\x81\x980\x19tae\xE4G\xBB\x92\x05T\xD1m\xD2P'\x85\xB7@\xB7\xA5\xD5\n+HL\xD5&\xCC\xC6\x1F\x88j\x9A\xE1\x9FB`\xC9t\xCF\x04\x81V\xB5\x89h\xD6V\xBA\x8F\xA2\xE7\xBC\xE4\xE5|\xF9\xDC\xF7\xC7\xBDHyk\x92\xC3\xF7\xFC\xDD\xD995\xF6\xF4\xB2\xC9\xDAH8\xB4s4\xE7\x8C\fwe\xBF_7\x94nW\xDB\x02\xD3\xDD]\xBF\xBD\xDA\xD6\xF5\xD2\xA2L \xD1\xB1\xD2m\xDE\x7F\x8A\xBF\xF2\xC6\xBE\xB7\x8F^\xEC\xED\x9E\xD9\xC5\xE4;<+\xB7v\xB7\xD7n\xB8\x94\xE8n\xAF=|hqd\xC5\xD5\xD0\xAA\xD7\xE50\x0F\x96n9\x17m\b\x86\xBA:\x9E)\x97\xE9\xA5K\xEF\x8D\xF1\xD1\xAF\x97\xFD>\x99\xDD\xB8\xF9B\xFF\xC8\xAA`\xFB\xDA\xBA\xB7\xFA\xE5\xFA\xF1D\xEE\xA1u\xD8\xF3\x9D7{\xCEv\xF6\x8F\xBC<\x9D\xC10\xE98\x9D\xA1#m\x13\xD5\x91uu\xDF\xA5K\xC6\xA2\xAD\xA3\xBFh\xDA?\xFA\xFA\xB9x\xE7\x9E\xB5u\x17x\b\xEB\x92\xC9C9\x95\x9E\x98\xC9\x8A\xCCTk\x06\xEA7U\r\x9C\xB8rpr\xCF#G\x06\x0F\\\xEBZ?39\xFC\xA7|\xC3\v\x91\x7F6>\x19-\xDF\xB0~l\xEC\xC0\xB7f\xA6\x9F\xFA\xE0\xDA\xE6\xB3{\x1Fx\xFC\xA5/\x9C\xBE\xFF{\xE1\x81wwMn\x9A\xAE\xFA\xF7\x85\xD6\xD83\xFE7\xBF\xF9\xD8\xBDc\xA7'\xFF\xFC\xF3++\xAE\xE2:\xA5\xD2\x7F;Pub\xAAn\xF9\xFB\x8F\xF7D\x97\x1F\xB8\xFC\xF0\xA9\xED#\x91\xD6]\xEB\x97\xBD\xE6\x88\xC9#\x17\xEA\xC5QZZ\xB1\xFF\xA9\x9F>\xBDC\xB4\x9Czt\xE0\xAFq;\xFB\x93wF\x0F\xFD\xE0\x81x\xD3}j\xE5\xD2m\xC3\x99\xB6\xC1c+wN\x1D\x9C9\xFC\xD6\xD8{\x07\xD9\xDE\xF7\xCE\xFC\xAE\x7FM\xE3\xA6\xC1\xFE\xA1\xE6\xE8\xA3_\xDD\xB0\xA9\xEEk\x13t\xB4\x1BW\xBC\x7FuOx@Mw\xFC\xF8\x8D\xC6\xD7\x9E\xFBc\xFF\xBB\xBFl\xD4\xFB\xBF\xBAV\xE2\xBF\xCC\x83\r\xEA\xE5\xE9\xC8\xEE\xAF\\;;v`8\xFD\xC4\x13w\xB3\xBB\x96m\x7Fu|x\xF37&\x02\x81?t\xEE\xEEx$\x1E\x1Ctw\xABC\xA9\xC8\xF6xOO{\xF7\x9EDh\xDF\x80\xD8\xE9<9\xD5S\xFB|\xE9\xCF:\xED\xB1\x91\x1F\xFD\xA6\xF3\xE8\x85\xA3\xD3{m\xA7-:>\xD2\xF1`\x7FYx\xC5\x03\xD33\xDB\xA6\xB6\xED\xF8W\xF2\xF9_\xBDj\xEE \f\x86\xCF1\x84Q\x07\xAB?(\xEC\xAB^\xE9/p\xE3c\x9Et\x0E\x9E\xBF\xDA4\xB3;T\xE6\xCA\xDA\xF3e3F\xC8<i\xED\x7F\xB8eLm=S\xD8\xB7\xF3\xD7\xD5\x97V\x1B!\xF3d\xE3\xE0\xF9\xE6\xA6x4x\xF7\xE9H\xCD\xF1\xB2\xFF\x18!\xF3\xE4x\xFF\xEAg\xC7\xB0\xFC\xCC\xE5\xF1\xC4\x97\xAB/\xBDh\x84\xCC\x93\xEE];\xDE\x8Eo\xF6u\xDD}q\xA2\xF6x\xD9cF\xC8|\xF3\xF7\xC5U\x0F.\xC7\xF2\xB3S\xE3\x89\xFB_\xB8Tn\x84\xCC\xF7\xEF\xF7\xC3\xD9\xF6.\xDC]\xFE\x97\x8B\x89\xEA\x7FDL\xFF\x9D/w-\xFB\xE1\xB3\xDF\xB6_i\x1C\x1D_-v4F\x8D\x10\x83\xC1`0\x18\xFE\x0F$\xD12\x12\xEE\x80\xD1\x90\xCFH\xB8\x03\x86\xB8\xF1w'\x14b\xB6\x91p'\xF1g\xF2\xD7\xF83\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0|\xB6A\xA2>\xFDI\x90;|\xF8U\f*A\xC1-\x83P\x90\x1Fv])Vx\xAF\xFE\x0F\x9B\x03\x01`\x8C\x80\xE4@\xA4\x04\x06 \x19\x10W\"\x00\b`\x14\xC0\xFB\x1A'\xA0\xC7&*\x87\xFA;\xC0\xA8\xFC\xD4\xB4Q\xAA\xDA\xB0\"\xAD$E(\xAE\"\xAD$$\x7F\xBD\xC4v\xF3\xD7+\xFD7\x16\xB6PI\xAD|\xDFs\xF6\xB1B_\x98\x02\xCF\n\x9E\xE0\xBDq\xBF\x95\xEF\xDB\x8C\xAD\xC1H3o)\bE\x89\x04\x04\xAA\xCDA\n\x04\x05\xA9\xF0\xE6\xFB\xDC\x14\xCB\x91y\xAF\xDE\xF1\xF6\x7F\xBE\x8B\x11\x02\x05\xED\xAF\x97\xDBD\x8A\x18\xA3\xB2\xB7a1\x80D\xDBr\x05\xFA(\x14\xEA\x99\xE5\nN,W6\xD8\x00\xB9\x1A\xB4\xDC\x82\xC0O\xDE\x1F\xFA\xC1\x9A\x01\xDE\x86s\xF1\x17\x8Ff\xA4\xA4\xC8r\xC2\xFB\xC5\xC2\x16\xE5\xB8\b\t\xB00J\x00\vJ\b\x86)\xE5\xD9\x04R\xC8j\x7F\x8E\xA88\xC6\x9D0fx\x16\xB5\xBF\b\x97\\HJ\x85\x17v\xFAC\x81\xFE\xFC\xA3\xFD)\x00r\xDB\\\x18\xB5\\\x19\xB7-7YI\xAC\xBCb~*\x93\xA8\xFD\xC5\x01d\x01}T\xF2z\x1B$\xE7>\x02\xBDH<\x7FT\xE68\xFB\xE4\xF3\x17Q\x0F\x89\xCE\x1C\xFC\xA5\xA7\xDB\xEF\xA1\x12\x18\xA3C\x9E?\f\xFB(\xE7A\xA4\x80alV\xA9R i\\\xB3\x95\x96A3R\x02\xDA_N\x94'v\xB10Op\x85\x98\x88DB\xA8\x84\x10\xD4KK\xCB\xED\xAD\xF4\x83\xEA[\x0E\x00\x0EVe\xDC\xBE\x98?\x9D\xEA\x8Da&\x1C\x8D\xE0\x96\xFC\xED\xFE,\x97s\x00%o\xF8\xA3R2\x1F\x81\\\x94\x10)\xD9\x12\"s\xB8\xD8\xCA\xA7P'-\xFA\xA8\xE25\f\xA4\xD4\xFEN\"\xB1\xDC\xA2\xBF\x85H\xCB\x98'\xCE\xC7>vp\n\xD0\xD6\xF6ErD\xD7\x1D\xD7\xF3\xC7\xC3\x04DC\xC4\xDE\x92\xE7\x95\xDA_}\x95\x9B\xE2][\xADs\xD0lo9\xB7\xB4\x89\x02\x1F\x12\xC1\xC4Z\xCF_\x1Fb\"\xDC\x8D>\x90\x82{\xFE #\x1C\xAD\xC9\xB9\x9F\x82\xCCa\xB0Ed#\x98V\x0E\xD7\xFEB\xA8$Gf\xCD\xFA\xAB\xB0A\x8A\x98m\xB9\x85\x06\x9B\xBA*TB\xA5,\x9D\xF5\x07\xE8#\xF2pl1\xA8$\x02\x91\x02}\x16\xF0\x1AF\xF5;Yn\x12m\x90\x9E\xBF\x05yhaG\x93\xBF\x00Pu\xE2\xCA\\\xFC\xC5\xE9DN\xC7\xDF\xF0u\xA8rA\x84\tH\x16\x81\x04\xE7a\xBF\v\xE0\x02T\x88.'S\x8C?\xA63\xF9\xA4\xE0\x89\xFBX\x9C\xB7\xE4\x19bss7RP\x02\x8B\xF1\x97\x11*b+\xE5D(\xC8!\f&<\x7F\xD0\xCB1\xDD\xDC\x8DL\xA9\x14ZzU+<\x7F\x84\xC8T\x94iC\x84\xBA\xBD\x15\x8B@\xCAP\xC0r\xB9\xD7C\x90\xE9\x03\x01\xA5\xAB\x90Jq\x1F\x05^\xB3\x84*.(\x81$\x12\xED/@%g\v\xE0\xAF\x8D\xE9\x8AC}\xC994\xDE\xE9\x80/\x9A\x04\xC6n\xD4?\x19&\xA0X\x13$\xB8\b\xEB6\xA7\xE3O>d\xDF\xEA\xCF\x11<Q\xC6\x04O\xC8\xA2\xBF\x10% \xBC\xF6\b\xA8\xFD!\x14\xFD\x9D\xBC\xE9\x0F\x8B\xFE|\xC4\xAB\x7F)\x80h1\x7F\x89\x1Ab\x8C\xA8$\xDAT\x02\xA7 e4\x00\xAA\xE8/4\xEBO\xF7_u\x98\x07(\xF0\xE8\x12\x02*\xEA# \xB4?\xBEp\xFE\x96j\x7Fs\x88?}m{ \x9A\x02\xC6@\x89z\xB0@\x85\t\x81,E\xCF_\xDA\xAB\x7F\nt\xC3\xF5\xFA\xC7\x0E\xAF\x93\xE8SG`Fd\x11\xA5vEA\xD0Y\x7FN\x04\x95\xEA\xD3\xFE\x9C\x9B\xFE\x9C`@)'\xA4C\xA8X\xFF\xA2\x00J\x81\xF6\x8E\x8C*mC\xE9\x96\xAD\n\x8C\xE8X\xB6A\t\xADXp\xAA=\xD9D\xD6\x88\x00\x05\xC1\x96\x80\x92\x9E\xBF\x98\xBE\xA4n\x91n\xCC\v\xE0/\x1E\xD5u\xA1\xD8\x11?>\x7F\xF1\xD8\x00P\x04\xD0\xFE\bT\x12\xAB\xD0G\xFD\xE9\xBC\xA8\xF4\x13\x95\xB2\xA0\x04d%o\xD1\xFB\x97\t\xD8\x18\xA6$\x9Fi\xD2\xFB\x17\xE1\xA7\xBC\x0F\xFDJ9\xCD\xD4*\bR\xCC\xDF-\xC5\xFE\x81\xDA_V\xFB\xD3\xFD\x03zKK\xBC\x9C\xB6f\xFBG\x05XJ\xEA-\x9D\xE0ZD\xCC&\x00:/\xA1\xB4\x04\x94\x9E\xBBr\xA3\x96VW\xDC\x0ER\x10\"@\\\xA9W\xB9>\x86\xA0K5\x01\xB1\xBC\x14@\xD6/\xC4\x96\xFCK\xAA(gN\x17{\"\xF51\xF5\xBF?\xE3~D\xE6\xDFz\" s\xEB\xA9\x030\xBB\x7F\x16\xA0nY\xAD\xD9\xFE\xFB\x19\xBF\xA51wu\x86\xCF\x01\xFF\r\x00\x00\xFF\xFF\xCB\x9Day\x00\x00\x0F\x00")));
		compressedFontAlpha12r = (new sliceType($stringToBytes("\x1F\x8B\b\x00\x00\x00\x00\x00\x02\xFF\xEC\xFD\r\x8C\x1C\xC9u'\x88\xBF\x8C\x8A\xAA\x8C\xCA.v&\xDB4\xB6-\xCC_\x93l\xF7X\xD5\x94\xED\xAD\xF1_\v\xB4wub\xB2\xA7(\x16\xDB#\xA9f\xCC\xDD\x1D\x1C\xD6vY;k\x10\x87[ \xE5\xD5\xDE\xB5\xAC9\xF1uO\x8F'I\x8FG54g\xDD\xD6\xC9V-M\x03EZg7\f\xED\x81w\x10\xEC\xD2\x88\xF2\xB4\x84;['\xE8\x0E\\`q(\xCF\xCE\xEDq\x8D]\xBB<\xBB\x87\xAB\xF5\xF5\x91\x87x\x91\x99\x95U]\xFD\xC9\xE6\fg\xE6\xFD\x10\xC8\xCE\xCE\x8C\x8C\x8C\xFC\xC5\x8B\x17/^|\x140\x1E*\b}\xF0\xC5\xE0_}.\x98\x97\x07\x88s\n\xFB.b\x01@a\xB4\x1F\xFE=yx\x99\xB0)\x00\xF8{\x8Co!\x94\xEE\xEF\x8D9\xA8\xDB\xF1iH\xC7@\x82g\xFE\x97\xF1\xBF\x01@`AE`\x9D\x18\xD0\xE7\xF9\xF8\b\x02\xE3[\x00J\x82\x97\x83\xBA5\x94\xF8\b\xEA\xDB\xE4\xA2\r\xD0V\x88\n\xB1\bP\xDA\x96\x7FCu\x85\xAE\xD4\x01|\x89\xE6VB\x17\xFA\x02B\x17=\x17C\x17C\xFA.\x05\x806\x84\x02z6\xF4\\\xEC\xDB\x10\xD90O\xEF\x8Al\xBAhC_aD\xA1/\x01-\x9D\x9A\x07\x80\xF4l\x85N@Ac\x9Bz\xEA\v\xA8\x1D\xA8\x82\xFB9-i\xBE\xC4\xBAB\xC3|\xE4b\x05\xA0\xE5\xE8\f,\x01@I\x97H\xA7\x04-\xF3\x96<\xD4\xF3\xF0\x8C\x1D\x9F\x9Bc/9\xA9\x83\xFEF\x9D\x9A\x00,$\xE5%q\xA4\xBC\xFCLyAZ^y\x92\x7F\x17\xFB\n\xB0\b\xBE3\xE0\x7Fs\x98\x7F}\xB4\xE8{\x85\xCE\xCC\x92\x83\x01]l'\xFC\xD7\v\x10\x01zJ\x1F#\xA5\xDF\xEE\x01\x04\n\xA3<\xD4\x14\xD6\x14 U.\x8F\xF8\xDFHh\xF7\x93\x13E\xFC\x1B!1\xFC\xD7\x00P\xC7\x1F\xAA\x11\xC10\xFF\xED\x03\t~(\x91\xF8\x07pP\xD1\x95;\x005\xCDa|\x0E\x12\xA2D\xFE\xD3\xD7\xB5\xE8\xA3Rd\x8B~-9\xE9\x15\x93B\xC9\xC54\xA6\xE5\xD5H\xCB\xCB\xF0i\xCA+\x0F\x91H\xE4\xBF\x00~\x11\x9B\xDB\xC8\x7F`i\xFE\x83\x84\xFFV^\xCBF`\xE9\xA2'm\x00\x91\x03\x91\x05\x15\xA5i\xD4\xC4R\xD50\xF4\xD6\x14\x10\xFF\xFA]^\x11\xF0H\xCA\x7F\x1C\xA1\x9E\xD7\xF5+\xB0\xF4W\xA7\xFC\x07\x89\xFC\xEF\xC0\x7F\xF3@\xF2\xDF\x96\x10\xE5\xA9\x16\x1C\xC1%\xA1_r\x9B\xF8\x0FD\x86\x7FG\xF3\xEF\x8BAh)\xE8\xBBZQ\x876\x84\xB6\x16*s\x12\x02\xAC%R\x14\x15\xB7}\xAD\x97\xC9\x80JN\x91\x14\xEF9\x85\xE8b\x1F\xB46\xE8\xA6\xFC\xBB\x9D,\xFF\b\xFA\xD5\x81i\v\\lY\xD0\xA2\xFA\xD5N\xF9\x17\xA0\x04\xD4'b\xFEC\x1B\x02\x17=\xC0\xB5\x11\xFE\x1D@\x07\xDB\xDB\xF0o\x1A\x82\x9E\rK6\x046\xAC\x17\xA0R\x04\xFF\b\xAC\xEB\x8B\xA8\x8F\xA9\xBE\x12\x19!\xD9'\xFF-\ta\x9EThIWO\xC3\x7F\xC5\xC5nI\xEB%\xCD\xFF\xA4.\xA0\xEE\xA4\x96\xB1z>\x0E-\xFA\x04Tqq\xD4R\xCEU\xFA9\x189\x10\x17J&4\n:\x84\x13\x90\x96W\x98\xC4_W\x18\xB9\x98\xD6b\x7F{\xFB'\xB0t\xC5\xE9\xD9\x14!\xAF\xC5\xDE\xB4M\xBE\x8B\xE0\xEA\xB6@skC\xBD\x84=\x01\xA1\xAD\xE5_\x8B\xB1\xA5+W\xA8\xA0\xE6BOA_\x80W\x8A\xF9\xEF)\xEC\xD9\x9A\xFF\xBAC\x95E\x82\x1F\xB7_q\xDEz\n7\xA8\xBC|'\xAE/\x1B\n\x03S^\n\xBD\x12\xF8\x16\x1E\x90\xFFI\xA8\xBB\b\x12\xB5\xFC;\xD0\xB7I\xE6\xCD'+\xBCC\xAA#\x14\xA8,\xA8I\x88\x06\\\r\xF1\x7F\xA7\x94p\x9E\x87vr\x129\x90\xC4\xC2r\xAAc)~\x94\xC6w1\xAD/\x1B\n\xB5\xFCS\xB5\xEAku\x01\xFDI\xE8\xE6:\x1F%\xE1\xD7M@\xAE\xD3u;\x9B\x94B=#\xFFe\x19\xCB\x7F\x9Cm\xA9\xF9\xF7\x01\x9B\xA0\x95|D\x15+\x00\xF0\x04\xB4\xDDD\xFE\x8B\x18\xCB\xBF\xD2\x19@\x85-@\xC3\x7F]\x90\xED\x11\xCB\xBF\xAE\x17\x91KTSy\xE9V\x89r\xAB[7-c\xFA)\xFF>\xE4\xBF-\xB5,i\xFD\xE3 h\xC6\xB4\xFC\xA7\xFC\x9F\x8F\xA3\xE1\xB4\xC0i5\xE0\xBF\xAB\xA0\xE7\xEA\x10\xCB\x7F\x92+\xA3\xC0\xCDI\xAF\bK6\x9A\x10&\xFA*\xE6?\xAD#\x00\xEDL\xDD\xD1\x8F\v\xCDI\xAAl\x87\fN\x11_\xF1$\xD4e\xAC\xFF!\x0F\xE5\xBCntF\xF8\x0F\x00\xFB\x80\x91\x8C\xF9\xF7\xE9\xD5\xEB\x03\xFD\x83\xB1\xFEO\xF8o\x8E\xE5\x9F\xF4R\xA4 \xE6\xDF\xC9\xF0o\xE9\x8B\xBA\xBE\x14\xE3\xD6\xFF`\xFC\x87R\x9Bj>\xE8V\xB8\x9F\xD7\xFCG\xE9]\x85e\xFA\xDB\xCFC\x99d\xD8p\xD8wqT\xFF\x14\x07\xF2\xBF\x910\x89\x19bG\xE2\x0F\x11\x1E7\x16:h\xFBG\x80\x91\xFFQ\xFE\xDDN\xCA?\x004eb\n\xE6\xA1\xE7`3\xB9^\xA1\x8AS\xA7\xB7{\x8A\xF8W\xE8\xE7\xC8\xFE\x01}1k\xFF4\x8D\xFD\xA9\x10\x9D\xD8\xFE1F\x17J\xAD\xAC4\x92\xEF\n\xEC\xB8\xBC\f\xFF=[?X+Ry\x15\x10\xEF\x83\x7F_\xEA\x94\xB5\xFE\xD7\xEA\x14c\xFB\xDFE\xF3v\xC3?80oik9\xC3'n\xA7\xFF\xB3\xFC\xAF\x15\xE3\xD0\x1E\xD1?\x19\xFE7L\x9C\x02n\x14\xB4\xF2\xD7\xF2_\xD4\"\xDB\xDF^\xFE\xFB\xAE&|-m \x8Ap>\xE1\xDF\xD7\r\x8A\x96\xF6\xBE\xAD\x9B\x00-]d\xF6+2 \x97H\xCF\xF7\\D\xB2\xFF\x1B\n\xFBd\xFF\x9B\x7F}\x1B|\xB2\xC1\xFA)\xFF\x05\x8C\xDB_\xD0\xD1\x9A\xBA\xF9\xA0\xF8\xA0S\xA8\x14P\xC7\x87\xFBj\x7Fa\"\xE9\x05l\xC5d\xC2?\x80\xCA\xA1\xB2\x07\xBC\xDD\xB4\x87\xEC\x9F^\xC6\xFE\x89O\x04\xE0\x04\x9C/\xA0\t\xF5\x91\x868\x1B\xDF\xC4\x01\\\x87X\xFEc\xFD\xA3k\xE5\x10\xFF\x9B\x19\xF9\xDF\xAE\xFF\x1B\x8C\xEB\xB4\xFA\xBBw\x8DqL\xFF\xD7\xCD\\${\xBB9\x88=|\xEB\xFE\xFB\xBFc\xA1\x86m\xC5-\x9E\x99=|\xC9\x9E\xE3\x93*0]\xE0!\xEA\xC6\xC9\xFF;\x00\xEAD7\xC6\xF2o?\xB0\x97\xAA\xED} \xFBu\xB6\xC8\xDD?\x10m\xF6~1\x18\x8C\x87\f\x12\xEF3\x01\xD3\x845\x0F);\xFE\xC3\xCC\x95\x05\x9E\xC4\x1Au\x8E\x8C\x81\xB4'~\x12gu?\xE9}x\xC6\x92'\xCF^-7\xB8\xE5'\xEE\xBEJ\xFA\xAF\x05\x15\x8AP\xCE<n\xA2U\x92\xA6G\xFF[LZO+)\xD3\xD2 \xD9\xDAp1y\xC9\xB3\xE6z\xAD8\x94~=q5W(\xD4M\xBFoTH\x82-_\x19\x1C\x16\xC7e\n\x03\xE1L\x83K\x96p\x0E*bTHj\xBAPp\xC4Y\xEA%\xD9\xD2]\xDA\xE4\xDFP\x91\xD9ii\xDA}\x01\x15\x89\x15\x80\x1E\xD9\x1B!u\x1F\xFA\xA0/\xD6r\xF1\xBF\xA1\xD0\x89G\n\xEA\xF9\xF8\xF1\x90\xF8\xFFWTp\x91\"+BA\xA3@G\t\rr;C\x8E\xDC)\xC9\x1B\x9B\x12\x97\xE8\xA5=\x80F1~{\bP)\xD2\xEB\n\xFAX\x17I\x1E\xF2\xD0\x94\xBA\xE7^\xCB\xE9P\x17\xE0\xD1W\xD7r\x10\xD8\xD0\xB71\xD0\x9D\x0E\x04Wwl\x97\x00\xFA6\x849\xF4l\xD4\x19\xB0!\x92\xFA\x15m\xEAp=KC!\xA1$\xDB\xC3\xC5\x00`I@\xBF\x18\xC0\x11l\x16\xC8\x97e\xBA\xA2\x94\xAC\x96\xAB<\r\x7F\b\xDD\xB5\xC4\x12\xDCt\x00\xE8\xBDM:\x8E\f@\xD4\xC9\xC9\xDC'\xB3\xAD\x92\xD3!\x84\x84\xBD#\xD8\x11\xFA3[\x13d\x9C\xE7\xF4\xB9o\x1Ch69\xDE\x8DD\t3v\x835\xAB\xD3wM\x0F\x91J\"Gw\xE9\xDF\xA8`\xC6,t'1\xA48\xC6@\x8DH$\"2\xE1\x1A\xD4\x95\xD3G\xAA\v~I\xA7QQ\xB0\x01\xF1#P\x84\x16\xBDT\x97H!~\xBB97}\x07}\xCCC\x94\xE4\x01\x8A\x14\xD3H\x1D\x15\xB7O\xDF\xD5u0\x92\xD8)\xE9\x8E\x12H\xDD\xEB\xAC\x01(\xEAf\x96\x95\xE6\xDF\x17p\xC5\x01\xBF@\xFC+\xBCb\x86\x9C\xC8\r\x05\nZ\x12Zy\xF0\x8B\x81~\x97\x83d\x9B\x1BW\x8CN6\xE5_Wa\xBA\xD2\xA6!\x83\x8Aa\x18\xA0\x92\x1F8H\xEB\xE4\x190\xFE\xB1T\xF1F\xA6g\x9D\x83\x8A\x83-2\xEC[%4}p0\x1Ec\xFA\x90\x88\xFA\xE0i\xE8\x01\xD6(\x1B}\n\xE6$\xBD\x8B\xA0\x85\xBC\xAF\xC0\x88}z\x8C\x00\xE6\x01\x9A$\xFC\xBEa^\xE9\x0F\xAF(\x84\x12\x9A\xFE\xD4F\xE6]-\xFD\"\xFDo/\x93rH\xCC\xF7\xA5>F\xB0MpcA\x05\t\x81@\x94\x10HP\n\xA4\xC42 \xBD\x9F\x1C\x14&'Bg\xC9\x97\xD0.\xE8<\xAC\xC5C~T\xC1\xA5\xAE\x9E-\t~\x11\r\xFF*\x1D\xE6P:Y\x9F\xF8\xF7\x05\xDC.\x81OW\xEEL\x12\xC3\xA6\xB7H_T\xCF\x04#\x15\xCF$\x1F\x12\xA9\xF8cu\x85\"\xFE\xF5W\x93\v\xAE\x9E\xD3\xD1B\xEA\xE3\xD7\xC9\x15\x90\r5\x1Bk\xB6\xEE\xEFgCzW\x9F+\x88&4\xB7\xD9\x10\x1DA/\x07\xAD\"D)\xFFE(K-\xFC\xEB\x0E\xAE\x97p}\x02\xDA\x13\x83tZy\x9DH\x1C\xD2\x94m\xF0]\x1DB7\xE33\xC9\x84\xBA\xC2:9\xFAt\x90\x10f\xF8_2\xFC\xDB\x03\xFE\xA3\x92V\x98\xAD\"\xF8\x8E\xE6\x7F]a\xB3\x10\xB4\xF3Pv!\x02\fE\xFC.\xBF\bWt\x95\xC1+\x16h}\xAEU\x10\xAE\xE7\x89|\xE2\xBF\xEDh\xFE\xD7\xF2x\xC7\xC5\rr\xBF7\x8CcD\x91\\\x99@L\xD6mh\xD9\x80\x05 \xE7I\xFC]\x9E\x8B\x15\x07o\xDA\x9A\xED\xB6\xC2\x8D\t\xF0)\xDA\x9AM\xC3\x85\x14P\rBM\xE1\x1D\xF2\xC0\x9B\x7F{j\xE8.*\x8C&\xA0_\xC2\xEC\xF0\x90/\xB4\xFE\xF1,\xE88$o)\xFF%h\x94p\xC3\xC1\x8D\x92\x0E\xED\xD2\x80\xC9u\x07\xA3\x12\xF6J\xFAh\x92\r\xE9\xE8\x93\xF0\xFBr{\xFE-m?\xE8P\xD2J\xB8gCX\xD0\xFCG\x93X\xB6q^\xE1\x92\x8B\x8D\x1C\x86J\x8B\xB4o\xEB,\x85\x02\xDA6n\xB8\xD8,\x06m\x07+\xE4S\x8A\xAC\xF8E1\xFF\x164]4.,\xCF\x82\x8D\x02\x86\xE4n\xEA\vhO\xE0\x12\xE9\x9F;\x93Z\xC5)\x01\xFE\xB8\xBC\x19&[\x02\x91\xDC\xBC$\x8A\xE4\x82\xB3\xC0s\xB4\xEEB\x85w\x8A\xB0QB\x9F\xA2\xAD\x15\xB1\xAF\vE\x1F1\x1D9Pf\xC4\x16\xD1\xC5\x1E\x05s\x92\x92\xBF\xA6\xB0_\x1Ax\xF6F\xF8o\x95\xA0\x95\xD5?\x92\x1C\x98E\x8C\xC8\x8D\xB9\x96\xF5(N`O\xE9\xC8=\xA5\t\xD4\x1C\xD21\xE6dr\f\xFF\xED\x8C\xF3\xDF\x8C\xDA\xD4\x84\xA6\xA5\x96\xD7\xFC\xA3\xC42\xE5\\)\x92\xFFb<\xB8\xD3*i1n\xE7u\n\xCDb\x9CH\xA4\xC8hI\xF8_3\xFCK\xE8\x9B\xBA\xE3j&|\x89F\xFE\xD7\xCD\x98]\xC2\xFF\xD2X\xFE\xB52\xD1\xA1g\xC3:%\xD8q\xE2O\b\x05x\x13\xD0v\xF4\xE7\xB7\x1D]\x05\xEA\x14\xADM\x9C\x98I\bc\xF8\xCF\\A\xA5\x13\\\x1B&p,\xFFM\x07\xBA#\xFC\x17c_\xF7(\xFFTSLP\xD6 \xEC \xFFmr\xFE\xFB\xA4pL\xD8\x8E\xFF\x88(\xF2\x89\xFF\xA6\x93\xE5\x1F\f\xFF=E#\xBC\t\xFF\xCD\x84\xFF\x80\x1C\xAD\xA1\xD4J\xCC\x93\xB1\xFC\x0F\xF1\xEF\xC6\x89\x8Ff\xCF\xD5L\xF6\xE9\xBBn\x92\xE4\xB7J\xF1'([\xF3\xBF>\xA1\xFFm\x97\xE2\xF1\xE2\x96\x03\x1BN\xC2Lq(\xA9\x84\xFFa\x9Dcg\xC28\xFE\xDB\x12\x9B\x16D\xC5\x8C\xFEI\xF9W\xA3\xAF\xA0\f\xC4C-\x91\x1A\xA2ZK\x1D\x85A\xDE\x92p\xDBA\xBF\x80~*\x15\x19\xFE#\xE2G\xF3oC\x96\xFF\xB2\xD0Y\xF2\x15\xB6e\x86\x7F\x97\xDAA\x9D=zW\x11\xD6\x89\xFF\xD0\x8CS(\xF0\x94\x16\xA7\xBA\xD1\xFF\xA0\xA9['C\xEB&\x15\xC4Z\xC2\xFF\xDAp0\x99l9\xD8\xD4j\x1F\x9B\x89\xFCG\x801\xFF6\xB6I\x92\xFB\x14m\xA3\x84Q!\x0EYguO\xD7\x0E\xECk\x1Bx\x10B\xC04\xC4\xD5j\xD8\xC5\xFD\xDDIl\x18\x8D\x17\xCF\x02J\x8E\xC3\xB4\xA7\xF1\x97\xF2)\xF9C\xE9\xF8\xB98\x84\xA4\x81\xB3!\xD2l\xA0\x9F\x8CI\xF5\xA5\xC9-\xA9/[7\xD9\xA1\x8D\xF3\xA0s\xAE\xDBV\x1B\xEAE\xF0\xC8\x87\x1F*|Fj\x9D\xDF(\xE8\xCE\x8B\xAF\xA0\xA9\xE3c\xD9\xBC\xAB\xA0\xDB\xCD\xD0\xD2\r\xA5~VA\xC3\xC5\x90\xAE\xC7\xF6\xCF\x11\\r\xA1?\x19\xF3\x7F>\xC9\xEA\xF9\xE1`\x98\xBC\x99\x87\x86E\xB6M1\x1Ds\xC7\xE6\x11\xBCmk\xEA\x9AF\xD8(Zh\xA7n\xD7\x9Dz\xCD~26j\x82\xAFp|\x04\x89P\xD4\x95:u\\g\x9D\xB1\xA6/Z\x16\xA3\xCF\x06r4\x1DO\xEC\x96\x8D]|\xC8h\x06\xB0Z#\xB3\xCEJ\xE9\xC4\x0Fm\xF9\xAB\x8C\x1F \xED\xDB6\x93\x14\xA2\xB4#\x9F\xCF\xF4\x82\x05\x82\x18\f\xD0\xEC\x047\xB6\xB7\xE3qj\x85i\xCA\x83\xD9'\x00\xA8F\xE8\xD9\xD1Ya\xC7!\xB0\xB7\x89\x90\xD3\xBD\xA78\xCD\x91\x14\x93\x02\xF6\xAC-\x83\x11j\xB4,\xB6\x1B\xBB\x19dc\x0F\x03\x07&\x03#2\xB0\x95\x7F3\xD2\x91\x0E\xB84\x92\x14\xC2\xA4\xC8\xB2\xFC{\xD4;\xF0\xF6\xC2\x7F!\xCE\x86\xB1\xD3\xC0\x1E\xA4\xCC`0\x18\xEF\r\x84\x00K6\xA6S\xB8\xDF\xEF\xC8\xEF\xFB\x89&Q\xB7\xF31\xEB\xD3\x1E\xDF\xD8e\xDB\xAC}\x03\x1F\n\xEA\xC4\x98\x86\xD5\xB7\xE2\xB9g\xBE\xC2\xCA\xF6cR4\xF7\x0F\xCA\xC6{\\\xD8\xDFkkEr\xB8\xEDx4\x1E\xBC\x1E\xF9\xB4\xD7\xC9Z\xE8\x93i\xD1'\x03\xAF,\xD0?\xD8\x10U\xC1X\b\xC1\x96\t\bd\x8A\x14\xE28\x8D\x02t\xC6\xCFS\xC8\x8C@\rO\x1AI\xEF\x1A\x0F\xFC\x10\xCCX\x89\xA0r'k\xAD\x9D\x9A^ym\xAB\xD4\x15\xD6\x05\x94i\x8C\xC9\x13\xB1K\xBF\x9E\xA7\xC1\x11\x1B\xC7\xDA\xC6!\xB9\x91\xEBE\x9DB\xCD\f\xA0\xD8\x89\xE5C\xB6\xE8\xED\x9D\x87\x1A\xC9s\xBE\xC31\x82\xD8\x1Bl\x1C\xC85\xF3\x81f\\\x80\\\xDF@\x9E\xEDh\xBF\xC6Uq\x8CEz,\xAD\x98\xC5x>\xB0/F\x8Dc\x7F\x84\x7F\xB2\xC9\xCB\x99\xE1./Sa}{PL\xBAh$\xD6L\x9Ay\b\x8A\x03\xFE\xEBy\xF0\n\xC4?\xCD\x87,\xD3\x10\x8F'\x92\x89\xF1\xC9L3\xDF\xDAe\x84\xB4\" \xC8A\xCD\xCA\xF0\x0F;\xAD\x13\xF1\x13I\xEE\x8F\x0E\x01\xC4\xCE\xF9\x88\x14\x84O\xC6\xB3qhGy\xFD\x81~\xE2\xE5NC\xB4_\xF9W[\xF8\xCFX\xD7q\xBF`O\xFC\xC7_\xB1\x95\x7FE\xAA#;\x16y\f\xE2\xB9\xA3\x9A\x7Frb\xD4\xA9\xFD:_@\x8F\xDC\x9E\r\x07}\t\xF5t|*3\xD1\xCE\xDF\x86\xBD,*40\x17X\xD4\x9BN\xE4\x7F\x87qp\xE3\xB26\x1E\xFE\xD8\x8Do\xFC\xF3\xC6-o\\s\xE4\x93\xF7\xDC\x84\x7F\x85\x9E\x8B\xF5\xE1A\x81\xC8\xD65w\xEF\xDC\xAF\x17p\xDD\xCDL\x927>\x04\v\x8C\xBF\xA2\xAEp}\x82\xA6\xCD\x17\xB0A\x93\x18\xA3#Pw\xF4[\x96\xA8;\xAF,X\x9F\x80J\x01z\xC6\x1B)u\xCE{\x12o\x17\xC9c\x90\xCC\x9B%\xFE\x01\xC8/\x11\xE5 \x92\xFA\xD9\x80\xE6'w]\xEC*Xw\xE3\xB5B5\x89u\xA9uN=?D\xA9/\xC6/s\vmH\xD7\x98d\xC7\x9B\xB5\xE6\x91\x18\f\xCB\xFF\x0E\xC8:\xFF\x87f\x8A\x92[>\xF6\xD8\x90O\xBEBn\xFF\xC8\f\xC8Z\xFA\xC1\xDE\x16\xCF\xFC\xDE\xF9\xDF(\xC6\xD3V\x9B\xE42\x8A\x9DW\x16\xF9!iE\xC3\x86\x19_\x98\x80\x16M\xF6n;x\xFE\bl\xD0<\xD86\xF1\xBFQB\xDD<\x15\x01\x05\xF8\x0E\xF8E\bhIW\xDDA?\x1F\x7F~%\x07\x15\x95\xACw\xA0\xF9\xFCM\x1A\nl;\xF8L\x1E\x9Equ\x82\x03M%5\xF9\x8D\xBD\r\xDB\x9Br\x19\x99\xF0\xB0\x91\x0EM\xA6\xFC\xEF6\v.vY\x93\x87?\xCB\x7F\x8F\xDC\xF2\xB1\xFB\x94|\xF25\v\xFA%\xDD\x16D6\x04Z\xDB#\xBAC\xFC\xFB\xFB\xE1?NYi=\xDF\x07\xFCH\x01*\"X'\xFE1\x1F{\x17C\xCA\xCF\x92\xD0:\xB9\xEDh\xB6\xDB.\xAE;1\xFF\xA8\x00\x01{4\xB6\xE2\xD3\xD0v\xE0v\"3\xA1=\x9Fxe-\x1A\x97q\xE1\xBC\x82\xBE\x05e\tM\x11\x0F\x854\xF2Z\xD5\xB4\x8A\xD0\xB6\xF1`\xC6\x98\xAE\x17bH\xFE+\x19O\x85g\xEF\x89\x7F\xE3\xB2\xDE:S\xDD\xB8\xE5c\x96\xC8'\xAFr`\x96\x0FD\n\x03\t\xE6\xA9!\xFE\x8B\xFB\xC8\xBC\xA9;jB\xF3\xAF\\\xAC\xD3\x10@dcS\xE1Z^\xAB\xB2\xAC\x7F;L\xF9'\xAFu\x96\xFF\x96\v\x8A\xA6dh\xFE\xA5Y\x04D\v\n\xC8\xBBh\xF8o'\x95kZB\xD3\x86\xF9\tX\x9F\xE8\xD4\xF3p\xDE\xC1\xA6C\xE3\xF2\x07\x9A\x8C\x14\xAFL\x1C\x17g>\x91\xFF`7\x9B\xC4\xB8\xAC\xC7\xE8\x1F\xE3\x19N\x86\x06|\x89\x9E\xC4\x94\x7F\xA4[8\xAC\x7F\xFC\xC2>>\x04\x8D\xFE)\xC5\xFA\xA7I\x8B\xD7\"\xD2\xFF\x91\x80\xBAy\xA9\xC0t\xB1\x89\xE1\x7F\xCD\xF0_\xC4\xB5\x89\x98\xFF\xA6\x19\r\x14\xD0\xB0 \xC8S\"f*\xBEC\x03X\x16\xD4R!!\xF97CQ\xEB\x13A-\x0F\x9Fup\xA3\xB4\xED\xCA\xDC\x9D\xF9\xF7w\x9D\x94e\xF8\xDFU\xFF\x90\xCB:\xF6\xF0gB\xEC\x967\x8Ew\xF2\xC9w!\xE6?\xA4\x99\xF0\xE6\xA9!\xBF\xFD~*o\xB8M\xFB\xEB\x99a\xF1\x02\xE9\x1F+\x9EW\x7F'\x8F\xCF(4\x9D\x91\xA5<\xCD\x9F\xCF\xC7\xFCG.\xF4\x88\xFFu\x1B\x03\x81a!\xE6\xBF\xEF\x82*`\x98C\xAD\xFF\xE9Ef^\x81g\xC3\xBC\x8D\xE7m\xAC\xE4`\xDEA\xDD\xFE\x1E\x88\xFFp\x0F\xFC\xEB\xFC\xCB\xFD\x9B\x85c\xDB\x1A+\xB1\x9F3\xEE\xE4\xD1\xF6]\xED\xBF'\xAB\x06\x06\xBF\xE9\x114\x15R/\x1E!\x1D)\x104\xA5D`\x90\xF4\xD4h\x0E^\x80NR\x95\x1Ch\tl[Cf\xB6'\xC1\xAC\xEE\x19\xE4\xAA\xA8\xD31\xA6\xA9\xA2\xB5\xCF\xFEA\xBB\xDEc&\xE4\x8B\xF1\xF2\xBF\xC3\xCA\xF7\xBD\xC3\xAC\x84\x85\xC9\x01\xFF&\xE5Fa\x1B_\xC4\xBE;\x01\x83\x1Eq\xC3\xCC\xB6\x02\x04k\xF0-\x15b,]\x02@\x12\x88(\x07\xD9\v,Zf>\x9Clh\x1A\xD64W\x85\x01\xFF\x15\xB3\xA83w :\xECq\x16\xA95\x8E\xFF}\xED\xA8\xC0`0\x18\xEF\xA8\x0F\xD6\x87m}\x1D\x07p\x86{\xB4\x8E\xFB|\xB6Y\xB4\xA0\xBC\x97l\b\xA8\xE4u/28\x02u\x11O\xB4~O\xC2\xA7MQ\x8C\x13\xBB\x9E\x87:\xB9\x07\xEBE\xF0m\xF0r\xD0H\\\xBF\x8F\x1C\xB44\x11\x82uZ\vl\f\xB6\xF3\xBB\xD9\x03\x95\x9Cny\xEB\x00\xB5\xBCn\x1F\x1B\x0E6l\xA8\xEF\xBA\x00p\x8B\xA7\xC5\xDB[\x1Eo\x1F\xC1}\xC5\x1F}\xFC\xBE\xF9\xF7hS\x94\xBE\xDB\t\x05\xD4-\xF0\x8B\xDA6\xA8\xCB\xA4\xFB\x99\x98\x1Cr?k\x19TF\xFE\x03\xB2d\xFC\x84\xF6\xF5\xC2.\xF37\x9E\x94\x01\xE4h\x89A\x8Efw\x9B\x8Dn\xF2\xBB\xB0\xEA\x91\x07~\xA9\x80K\xF4\xA2\xF3\xE4\x7F\xE8\xB94S\x88f\x1CE\xD4\xAF\xD4\xDD\x1C\x17\x80.\xFA\n\xDB\xE9\x14\x05\x12\x95F2W\xB9\x91XM\xFD\xB1\xEF\"'m#\xA7\xBBN\x86\x9A\x90<\x0F}Z\xEF\xEC\x97\xA0\x9Dl\x9E\x13Rf\x14$\xBB\xC4\xEC\xDAk\x10\xF1\xB1N1\x1Br`\xE1\x1F\x84\xFFT\x89\x89\x81\x9C\x04\x13{\xB0\x87\xF3\x10\b2&\xC9>\fr\xBBkE\xFF\b\xB6\x01Z\xB4*\x9F\xA6\xF7\xE3\xED|<\r\xDB\xCC\x85\x8Bh\x07\f\x88g,\x83ON\xC5\xB6q-\x92\xFB\xF46\r\xF6\x99\x05>\xCD\xA4\xD7\xE0\x8F\xAB/\xC6\xED\xD9\x94x\xCE\n\"\x11/a\xA8\x99\x95\x03\xC9\xAEDm:\x8F\xE8$\x84d\xAD\xB7\xB5[_L\x1C\xCE(\xA1w\x9Fu27d\xC9\xEF\xC5\x15c\xE6P\xF9\x02=\xB3VH\x18\xAA\xA1\xAE\xC03\xFB\x1E\xE4\xE1v\xCA\xBF4\xD3A\xA1M+kR4\xC9\xF3\x19\xC4\xB3\xB0p\xE7\xF5KM\x9A\x1Az\xCE,<\xA1\xE5\xC9\b\x10I\xADC\xDA\xE6\x8A\x80\x9Am40\xF6E\xEAm~;\xB0\x13\xFF\xF20_\x94\xAD\xCEe1\xC4\xBF?\xCC\x7F+\xAF+E\xCC\xBF\x18\xE2?\xB4a]B\x94l)\x10L@S\x92[Fa\x10\xBBe\xB4\xBEZ\xA7\xFAb*N\x04\xB0\x9E\xEB\xF8\xD4J\xA6\xDB)\xA0\vk4p\xD3\xA6\x99\xA2\xEB\xB6~u=\x0F\xEB6\xB4]\x1D'\xCCA\x94\xC3\x07>Q\xC1z\xFBz|C\xF2o\xEB\xB6\xDB\xF0\xEF\x89x\x86s\xDD\xA5\xC5\x14\x02:\xC4\xBF\xA6\xCE\xA5\x1C\xD2\xAE/mR>\x91\xC2\x8D\xCC\\k,aOB\x93\x1C\x80\x15\x1A\xD4\x88\xA7\xEF\xE6!\x99\xB8\xAEu\xDD\x069\xF7|\xA2\xDA8$\xBB\n\xDAJ7\x9D\x9A\x7F\x077\x9Cxw\x97\r\x05\xBEC\xFBuX\xB4\xCD\xC5\x83$\xA4lC_\x1C\xDE\xB2\xC3\xFD`>#\xFF\x9A\x7Fwh\x1F\x9B\x16\xB9\xA0\x8DR\x8A\xF7\x8E\xCB\xC7\xCB\t\xA3\x02D)\xFF\x05@\x85MifGc@\xFC\xA3i\xAC\x87\xF9\x8FJ1\xFF\xED<\xA4\xB3\xF77\\\xDA\xF9\xC4\xA1\xC5\x1A\x0E=.h\xA1\x90\x80:\xED\x9F\x13\xD90\xFF I\xA8\xEF\xB7\xA9>\xC4\xA2\xCF\xE8\x7F\xCF2#8\x03\xFE\x9BY\xFE\xC9\x9D\x15&k\x8Bt4\xC3?5\xD9\x86\xFF.\xFD\x8BY\xFE\xC50\xFF2\xE1\xDFN\xF8\x9F\x84\b\xB0-h\x8D\x9EM\xF5\xC2\x06\x9D&\r\xE4\x85\x86\xFF\x07,\xFF\xFBn\xAA\xEF\x0F\x95\xED\xF9/'\xFC\x9B}\x87\xA2d\xADV\x94,\xCA\xF3U\xBC\xB6e\xCD0_\xC4\x8DX\x92\xB1\x99\x073\f\xB4\x95\xFF\xF2V\xFE\xF3f~\xBB\x96\x7FeA[\xE2\x92\xADK\x83\xF6\x81\x84t\xA1D\x9D\xF4\xCF\xC1\xF8\xF7\xD2I\xC2\"\x99\x980\xD6Rr\xE3\xCE\x1A\x8Aq\xBEP{`^\xEE\xC3#\xBA\x1F\xFBg^\xE0<\xE5\xD3,\xD7\xED\x99\x1D\xC0\x8C\xFDov\xED\xA3q\r0#\xAD\n\xFD#\x18\n\x9A\xB7/h<B\xC4\x1B\xF54\xA8\xBC\xEE\xD0\xBFu\x1A;\xF0l]_\xC2<\x9D\xD0r\xDD\xD0L\x90\xA0Y\x07\xA1\r\xCAN\xF8O\x17\f\xD1\xA0\x7F\xBC_\x90\x80\xC8\x85\xB0\b\xE1\xFE\xDB_?Y\xED\xEES~\x8C7\xDELU\xF2\x05,9X\xCBi\xB5V\x1En\x82\xCD\xC6\xA4\xA3\xDA\xC9\x98\xC1\xB4\xCB\xD0\x0E\xD8\xDCC?\xD7\xA4pX\x8AN\xA5b\x93Y\na\xB6\xC1Lg\xAA\xFB\xF9qv\x85\x88\xF7\x9E\xF5hN\xBB\xF9\xB7\xE7\xEA;\xBDa\xBF\xBA\xBE[<`\x079\x96\x7F\x9Aq\x11Z \x05\xED_'\xE2\xBEsE\xD2\x8C\x11\x177\x13\xF9\x07\x01K\xF6\xF0\xB6BT#\xE2\x1Dz\xF3\xBBt\x03\xD5\x1Ez(\x95C\xD5cY\xFE\xBD\f\xFF\x1E\xDD3\xEF\xF2\x15\x8E\xE7\x9F6\r\xD0]\xC5\x84\xFF\xF1\xD9\xB6q\xBFS\x13\x19\f\x06\xE3m\x86\xF7.\xC9gf_\xF4\xB8\x1D\x0E\xE4\x03x\x8Dz\xB0\xD6t\x90O\x1A\xB5\xC4,\xF4\xB7N\x99P\xEF\xF0\x14\xFD\xEC\xC4\x86fb\xFF\xAC\x15\x12\xFF\xB0\xDB1\xFB:\xB6T\x10\xED\xDF\x88\xDD\x05\xDBL*\x88\x12\x8Fz\x94t<\xEB\x99\xA1\x8D\xF4<{R\xCB\x9C\x0F\xCC\xCB<\xF4%\xCC\x93};_\x80\x16-\xEE\xD6\x1Ds\x17z.V\\\xEA\xDF\xD9\x10\xE5hB\x8E\x8Bf\xD3~\x9FfL\xB5\x1D\xEC(\xC4Ih\xDA\b\x80\xFB*\xAF \x1F\xEF7\x1E\x97{\xB2\xE1I\x9D\xA4y-\xF1\x03\xF7\x01n\xD2>3\xC6\x91\xBBF\v\x16\x02\xE3\x1E/b\xDB%sZ\xC1K%\\\x03P%m\x89\x05d\xFB\xF5i'\xFF~\xE2\x016\xBE\xE5\x9A\x84\r:\xBF\t\xD0M\xA6m\xF73;\xAB\xDCIb\xA2\x8A\xF7z\xA2mL\x10r\x99}6T\xBC+Q=O{\x98\xD0\xF6G\xE9.4f&\xB99O\xAF\x9B+MZ\xD0m\xE6\xBA\x8F\xF4b\x022\xAE<\x07ZfC\x1E\xDD\xEF\x03\x9ARK\x93\xF7\xA8\xBBw;3\xCF3L\xF8\x0F\xA8[\xDD\xA6\xDD?v\x90\x9913\xB7\xF3\xD0\x95\xF1\x89G[\x8E\x07\"\x9E\xC4\xDE\xA3\xCD\xA5\xFD\x84\x8A6y\xA4\x8DS\xB7I\v\x16Z\xE6b\x01\xC0\xD1yK\xBB\x1E\xC7\xA0\x03\xB6.\x1D3g\xDE\xF8\xE4\xD3\x07\xDB\x00w\xA4\xBE\xD8\xA4\xADoZ\t\xE7~\x86\xFFZ\x86\xFF\x1A\xFD\xEB\x93\xD7.^\ra\xC2\x91dZK\x9E\xB60\xB2\x89\xB1|\x1C\x94Y\xFCK\xE7\x83\xEB\xE6J1\x11\xB6\f\xFF}\x1A$B\xDA\xC0\xD6\xF0\xDF\xCC\xCC?\xD4\xFC\xD3\x1E\xF2\xCD\x01\xFF\xB13p\xC0?`{xY\xF1\xCE\x1D\xD5Q\xAD=\xEC\x976?|`\x96N7\xE9h\x048\xA5\xF1\xCB\x86:\x11W\xEDh\xB8\xC1\x8A@\x17\xABq\xC8\x07\t\xFF\x8A\x1EY\x07\xA8O\xC6\xC9\x1A\xFEM\xA5\xF53\xDAc,\xFF\x9A\xB7-\xFC\x9B\x99\xFF-\x92v\x95\xE40\xA4\xCCD\xC9\x1EG\xE6\xD8\x1D\xDE\xBChd\x14@W4r\x1F\xF9\xB4\xD9u+\x07\xAD\xE2\x10\xFF!\xE0Z\x11[rh\xD3\xFE\x01\xFF\x931\xFF\xA1\xD1W6\x18\x7F\xD4\x88\xBE\n\xB3\xFA\xCA\xD5\xFA\x8A\xBA\xF6\xB8D\x1B\x02T\n\xB4\x17P\xB2\x9Du0\xA9\xF3P\x17p\xB3\xA8\xE3\xB4'h\xDB\x1C\x07\xA3\x1C4\x8B\xD8,\xE2\xCD|\xE2\xDA\xCA\x03\xDA\x9A\xD8\x14k\n\x83I\xDD\xD9G\x17\x03\x9A\xA1\x1D:\xA8lh\x15\xA1\xE5`Cb\x83f\x9C\xB6&\xB0\xA5\xD5&\xADzpi\xD6:\x85\xDA$m\x10A\xBE\v\xB3\xD7\x99\xEF`\xDB\xD1\xD5\x7F\xB0\x174U\xBA\xC1V?\xE4|\x88sH\xA9\xC5{A\xD8p'\xDE\xFCgh\x96\xB2\x99\xFB\x9D\xE5\xBF\xAC\xA0G}[o\x02z\x02;\x86\x7F\xDA\xB1\xBF\xEE\x82\x9F\x83v\x11;\x92\xF6\xFDH\xF9\x17\x9A\xC3\xB6\x83a\x11{6\xDE\xB1i\xCB\x11\xFA\x04SL\x99\xFA\xA2\xAFl\xAD/\x91\xC2\xF3\xC9\xA4_]\xEE\x05Lg\xFE\x87\x12\xFA\x0E\xA9\xCD\xA2n\x95z\x8EN\xBC\xED`_b\xBD\b\xCD\"\xDC\x9C\xD0$\xB4)2\xD2\x86cY\xFECi~\xD1\x03\xBAR\xD3\xE8\xD3n?\x1D\x07\xBA\x13\xD0\xA0\xDF\x01\xE9\x15\xA1\xEB\xC0\xBA\x03m\xF2\xCE\xF9fO\x1Br\xC7\xD5d\xCC\x7F4\t}\xA9\xDF\xE8\xDB\xD0.i\xD5]s1rc\xFEo'\xEB&\xD6\x85\xCE@\x9Fv\\\t)\x9F\xA1\x05\xE9.17i\x1B%\x05\x98\xDD:\x06\x00\xEEd\xF8\xEF\xB9\x9A\x7F4N\f\x07\xDB\x02[\xE4\xBE\xEE'\xE3G!\xE8oo\xC9\xF4g\x11\xC0\xB7\x89O0s\x92\xD18]\x97\xE2\xF1\x0E\fs\xB0V\xC4\xEE\xD6\xF2\"\x0E\xC3I\xEC\xE54o}\xFA]\x80n!)w\x89\xDDb\xBC\xC3L\xCD&3 \x0F7]\xFD\xA2\x9BEZF\xA7\xA5K\xF3_7\xFCSL\xDA\xD1hH\x8F\xB5\x8B\xFAq\xDA0\nLE\bmP9\xDA\x95h2\xFE)\x8A\xA6\xAB\xCF\xDB\x13\xD0.&\xB3\xEE\xF3\xD0\xA7_f\xA9I\f\x8B\xB0\xE4`T\x84\xC0\xC5\xC0\xD5\xFC\x87\x8E.\xCA\x1Aq\xD2\xB7\x13\xFF'\xAD\x9B\xE8\xD2\xD6\xE2\x11m\xC6\xE5\xDB:\x9FJ\xE8<\xB4\x8D\fO\xE2\xCDI\\\xCAiI3a\x89\x98_\x9B\x1C\x95\xFF,\xFF\xCDR,\xCC\xA9\xFE\xDF(iy\x8E\x92m\x82|\xC0p\x84\x7F9\x88o\xCA\xAB\x99\xD5WE*/{\x10\xFF\x0Em\xF7T\xA3\x1F\x8B\x89\xDF+\xB1\x19oO\x845\x89-\xDA\xA4\xE8\xE6\x84\xB6\xBE\xBEo\xB6B\xA2\x91&cN\x8C\xF0\xDF\xCA\xF0\xBFA\x8FG\xA6\\\xC8\xAB\xDF\xA6\xED\xC8\x9A\x0E\xACO\xC4\xD6\x88\xD6?\x0E\xA4\x8F\x1B\xFE}\xBAU\x93\xE8\xD9P\xB6\x89\x7F\xDA_H\xB7\xBFE\x92\xFFd'\x99%\xE2?\xDD\xEA\x07\xE9\xD7\"\"\xF2s*\xDA\xFDl\x83\x06\xBFt\xE4\t\x1D\xF4\xC5b\x12hJ\xEAZq\x94\xFF@\x99}\x8A4\xFF\xD1\b\xFF\xB4\x14h0<\xA7\xE2\xDA:\xE0\x9F\xEC\x9F\xB58~\xBCt(\x1A\xD4\x17\xF4\v\xFA\xE2\xD6\xF22?\n\x90\xF2\x1F\x95\xB4\x84\f\xF8w\x88\x7F\x07\xBF?1\xE0\xDF\x10e\xAE\xC7\x04fl\xAD@\xD2\xA2$\xA9\x9B\x98\x01\xFF\xCE`\xDB\x1F\xB3'g\xCA\xBF\xF1K\x0F\xF6\x8FR\xFA\xAEgAYh\xFEMd?\xF9\xB5\x9A\x94\x7Fe\f\xC2d\xAB\x1F\xCC\xEC\re\"\x98\x9D\xD6R\xC6<\x18l\xF2c\x9C\xABY\xFE\xFB.\x96\x15\xD9\xFF.6&`]\xC4\xED\xA6\xD1\xFF}7\x1E\xDFI\x17\x82\xA1\xD9\xB4_\xD1\xF6w.\xE9\x93I\xAD[\xCE\xDB\x14?m\x7F\xB3\xF1A\x9F\f\xE2\xBB\xB4\xAB\xBF\xAD\xE5\x7F\x89\xDE\xDB\x9C\x80u*\x11\xE5j\t\x0Fm0\xA3x)\xFF!\xBD4\xCC\xC5D=\x93\xA7\xE6\xDB\xD8\xD8\x99\x99W\xBA\xFFE)\xA3\x1A\xC8\xFFW\x9D\x8EI\xD0\xD0[\x93dN\x10\xFF\xC6\xA3^1\xC9\xBA\xF8\x92\xEA,\xD98m\xD1\xE8I1\xD9\xC0\xD3\xC1\xA1\x9F\v\xB1p\xDA\xF0\x9Fl\xF5\x93.\x820\x05\xBAus\xA4\xAE;\xD8:\xC9\xF0\x7Fg\x12w\xF1\xF7\xEEa\xBE\x84\x1A7\xD2\x15\x8D\x1D\v\xA3\xCE\xC5\xD6\xF8j\xB8Kk\xE6\xE0\x8D\x1FPSC#>\x8A\xB4e\xEC-\xC9\xF0\xAFJ\x98\xFC\x88\xC9\xE0\xAE\x84\xC0\x17C\x1B\x1C\xA9\xF8\x87\xAD4\xD5\xF1\xD2\x06\x9A\xC6#\xE3\x05\xA9\x83\x98\xC9[P\xD1\xC2\x10\x95\xEE\xFB\xB7_\x7FE\xA6\xE3\xB6'\x87\x8F\xD8\xA3\xCF\x1C\xF74\x16i\xC3X\xFE\xBD-\x9E\x9Cp\x9B\xF7\x86\xF6P\x96\xB2\x9Cg3\x7F\f:#\xFC\x9B\xE1\xE8@\x8E\xE1\xDF\xC4\x8CWIl\xC3\x7F\xBA\xAFQ\xC5\x02/7X\xD5\xE8\xED\xD7_a\x0F~`\x91\xC1`0\x18\x8C\x87\x05\xE2P=\xF6\xEF*\x18[. #\xA4A\x0E\xBDp\x9By\xEF\xBB\xC0\x81\x90\f\x88\x06\xED\xFC\xEF\x91%\xD1W\xDAl\b\x04\xDC\xA4\xDF\xF3\ni\x91\xAF\xEE\xEB\x91a\x8C\xF4\x93\x91\x01\xD9(\x15\xFA)\xD5\xB0\x94\xB1\xAE\xCC\xEE(\xC9\xAF\t \xCD10\x9E\xC6\xD4\x16\xF2\x92\xE2\x9B\xA6\xBD\xEE\xDF\xBD\xFC\xB7\x86\xBD\xE2\xFE\x81\xF8\x8F\x1Ch\x99\xFD\x84\x8B1\xFF!m0\xDB\xA2\x0E2\x92\x1B\xB0]\x84V\xF2\xB3\xBFhCYa\xCB\xFC\x1E\xB1\x88\x7F8u,\xFFf\xAB[\x90h\xBC\xBB\xA9\xB3:\xE5\xDF\xD7\x9D\xAFw1\xFF\xE6\x87\xA7S\xAF\xF8\xC1\xF9w3\xFCOR\xEF\x9B\xF8o)\xEC\xC8\x01\xFF-\x1A\xDCA\x9A\xCE\xD7\xCA\xAC;k\xDB\x19\xF9\xA7}E\f\xFF\x81\x91\x7F\x19\xFF:vV\xFE\xD7\xB3\xFC\xE7\xDE}\xFC/\xE5\xB0A\xABf\xBCIh\x15\xA0\xE5\xC4.\xF1\x03\xF0\x8F\xB4I~\xD3\x05\x9C@\xCF\x85\xF8\x17\x1E%\xFA\x93\xD0\x12\x18\xA8\x98\xFFu\xF3\xDB\x946t\xC93\x9C\x9D\x8B\xD5\xA6\xAEb\x8F\xFC\x9F\xA1\x82u\x07\x96\x1C\xE8L\xA2\xAF`\xDD\xC6\x96\x8BM\v\xD7r\xB0N{m\xB5\x146'`\xC3\x86\xC6\x049\x01\x8A\x9A\xFF\xE0\xDD\xC6\x7F$\xB1U\x88w\x18h9\xD0ub\x9F\xD8\x01\xF8\xEF\xD9\xF1f;x\x04\x96\x92_\xD8\fr\xE8\xE7\xA1\x95\xA3y\xC86\x96i\xD5C\x8B\\4M\x07[jh9X\x93~'\"*\xC2wI\x8Fm\x1C\x81\xE6\x11\b\xC8\x1F\xBE\xA1\xF0\xBB\x92~\xDFV\xE2\x06y\xF8\xBFK)D\x89\x03\xBFL\xB3\xFB\xE6\xDF\x85\xFC\xB7\x1D\xA8\xD1\xFE!m\x07\xDA\x93\xB0\xA6\xA0| \xFE#\x81e\xDA9\x1C\x8F\xD06>\xB4\x15\t\x02\xF1/\xE8\xF7|-(\xE7\x88\x7F\xD0\xD7\x9B4\xB4:\xBA\x1C\x8F\xF8o\xD2\x068\x11\x8D\xB6\x04N<4\xD34\xFC\xD3O\xDC\xB6i@-\xCB\x7F\xBB\xF8\xAE\xD4?\xE67e\xCA\x12\xBDB\xEC\x12\x8F\x8A\xB8u\x97\xEC=\xE9\x1F\x9AT\xACu\vm\xEC\x8F\n\"\x1B;\xB6\xB9\x18\xF3\xAFt\x1B\x8D\r\xE2?\xA2\xF6\xB7\xBD\x03\xFF\x138\x9E\x7F\xF5\x9E\xE3_\xA0g%\xFC\xAB\x03\xF1?\x11\xF3\xDF#\xE6c\xFE\x01+\xC5\x98\xFF\x1A\xCD\xC3Wnl\xFF\xA0\xF9\x89\x8Aq\xFCc\x11\x9A%\xE2\xFF\xC8\xB0\xFC\xE7q\x1DpM\x9BI\xD0\xCE\xD3X0\r\x8A\r\xF8\x87we\xFB\x1B&\x9BU6\xA9\xBE\x9B\x7F\xF7\rI|\xDAf!\x9B\xB6\xC6C\x1A\vS\x05\xAC\xB8\x18\xD8P\xB1!rQ\x91\xF2\xAF\x98\x05k@^\xFD\x91t\xF2\xD8\xB7q\x8D~\xAD>r\xA0Q\x84\xA0\b\r\x1A\xECk\n\xAC+</t:\xCF\bX3\xBF\b\x008]\xA0\x0EE\x01\xDF\xED\x1D\xB1CJ\t\x93=\x82\x06\xB6\xE4\x96w\xED\xF8|\xBC\x9F*bb|\x1A\xAB\xD33\x8Et2\xFE\x95\x8C\xEDO\xA4\xF5\x8C\xEF\x81m^\x0E\x8D\x7Fk\xB8st\x80\xF2#\xFE\xA7\xE9\xF7\xB8Ai\x9B\xCA\xF0?m\x1C\xE994?Nm\xAE`24\xC0\xDB\xEC0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\xE3\x00\b\x1C\xE6\xE0P!\x13b\xCD\x1F\x1B\x96\x00|\x00Pt\x04\x04\x80z\x01\xC0\x82\xBA\xD0\xFFT\x8A\xFA\xAA_\x00\xC8A\xC4\xEC\xDD?\n\xF1\xDF\x96\xF9\xA3\x10\x01<\x00\xA5\xA0\x0E\x00\x96\xE6\xBF\xAD9\xC7vA\xF3\xAF\x94\xBE\x12\x14!\x90\xC8\xFC\x1F\x02\x84\x96\xFC\xD0\x86\xB6f;\xE6_\x01\x84\n\xEA\x13\xB1\xFC\xB7\x8B\xD0\x04l;\xD0\x04\xA8\xE8\x8B\xBA\x16\xF8@\xFC\x97\x98\xC1\xFB\xE5\xBF\x05\x10)\fcmc\xF8G,B(1\xE6\x7F\x12\"@\xA4\x98Jah\xA3\xB2\xD1\xB7\xA0\xC7\xFC\xDF\x7F{jC\xCB\xD6\xFCW\xF2\x10\x02>cc/\x0F\x15\v\xBF\xEB\xC0m\x89\xF5\x1C\xD6\x15F\n\"\x1B\xB1\x80=\x85Ja\x04\xA8,\b\xA990\n\x8Aq`T\x14\xFA\x0E\xAA\x1C\x94\x1D\x8CrpSa\xE4\xA0r\xB0]\x84\xDB\x80m\x89m\x85\xF3.\xAC+\xECO@\x94\xD7\xFA'\xB2\xA0bc[R\xFB\xCB\xFC\xDF\x1F\xB4>qP\x01j\xFE\x01\r\xFF\x91\xA3io\x03\x05\x855]\x050*`$tM\x89r\xA0\x8A\xD0\x96\xAC\xFF\x0F\x01\x9A\xCF\"\xA4\xFC\xB7\r\xFF$\xF6\x11`\x1D0\xB2c\xFE\xEBB\xCB\xBF>\x01T\xD4:0\xFF\xF7\x8FP+\x7F\xCD\xAA'\xB5\xAAG\x1BB\xDD\x16cdC$u\xBD@\xC0\x8A\xD2\xFF\xD6\x05\xDD\xB2\xA1\x0F\x18\x15\xC0\xCFA\xC8\xF4\x1DJ\x15(h\xFE\x8D\xF1\x1FS\xAA-\x1F\xCD\x7FMaH\xB7\"\x00\xDFI:k\xBAj\x98\xDE\x19\xE30\xAA\x80\xA5k\x81\xE9\xFC*s)G\xD7sP\xB1A\xD1\xAD\x10\xC0/A|\xDB\xD6\xFFzL\x1C\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1xH`1\x05\x0F1\x04S\xF0`Q\x93\x88\nPA\xA0\xA0S\xC2\xA8\x00\xBE\xA0P\x02P\x10)\xD4\xA1\xA4O\xE2\xEB\x02|\x88O6\x1C\xF4\x14\xA4\xD7;\x02z\x14\xBFm\xEB\x7FAa$\xA0/\xA0,\xA0\xADP?ea@/\xF5\x1D\xFD/\x03\x00\xEAy\xE8\x94t\b\x14\xB4&\xE0\xBByhi2\xB1<\x01JA\xB3\bM\x85\xD1\xC48\xFEs\xB0n\x83o\xF8\xB7\xA1Q\x80u\x01Q\x11n\x1F\xD1\xFCWr\x00y\xB8\x9D\x87P@E@\xFB\x88&<,`\x97^Za\xFE\x134\n\xD0rt\b]h*hIl\x10\xB7\x15\xA5e\xBB\xE5@7\x0Fu]\x05\xB0-t\xD1\xB4\xE2R@_ \n\bL\xB98\xD8r \x12\xD8v\xA0\xED`hCYG\x80\xDB\n\xB5\xA8\v\b\x89\xF0\xB6\xD2\xF2\xEF\v(\xDB\x102\xF5\x89\xFE\xD1B^\x84\x9A\xC2N\t\xB1\xA0E\xB7Q\x80\xC6\x84\x96m]5\xF2P\x9F\xD0\xAA&\xB4\xA1!\xB4<\x87\x12\xC2\x9C\xA6\x11\x05\xF8EMo\x9B\ne=\x07ZS\x1D\x89kJ=Oj\x87t\x91\x91\x7F\xBF\x80ujS\xF4\x15\xA6>\xD1?\x91\xA3\xC5\xBB\xE6`kB\xB3\xDD\x16\xD8r\xB0E\x1A\t\x95\xD6\xEA\xED\x12\x11h\xEBz\xA1\xF9/j\xC2\x1B\xC4\xBF\xE7\xE8\xEB!\xA9 \xD2\xFF\x89\xA6\xB2\xF5I;\x1F\xAB\xAC\xB6\xB9ha(\x00\\]\xC5\x98\xFFT\xFFD\x0E\xB6\x1D\xAC)l*XO\xF4\x8F\xEF\xE8&X7\xCDZ\xFF\xC0\x1A\xC9\x7FE \xC9?\x86\x05\xAD\x88\xB4\xFC\x97\x10\xEC\xB8\tX\x17\x99\x96\xDA&\xF9\xA7\x93X\xFEu\xC3\x11\xCB\x7F\x8B\xF9O\x10H\x92\x7F\x07C\x97\xD8\x96\x89\xFE)\x82\xE7\f\xF8\x8F\x8AZ\xFF\x97)\xF8\x16\x95\x8E\x03F\xFFC\xA2R\xA2\x1C\xB4\x9D\xA1\x96\xFAv\x1ER\xFD\x1Fj\xCE\xD1\x83\xB8\xB0X\xFF\x8F\xF0o\xB4\rJ\xDDt\xEA\x16Y\xA1*\xD2\x15mR\x0E\xDB?&\x90\xC1\xE3\xC3\x80\x7Fc\xFF\xA41\xB5\xFDC\xE7\r[\xCB\x7F[@\b8\xCF\xF6\xE7n\xFC\xC7\xF4*m\xC0\x8F\xE7?\xB5\xFF\x05x\x19\xFES\xFB?\xE6?9o9\xD8V\x9A\x7F\x9F\xE4\x9F\xF9g0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\xC6\x83F\x00\xE0\xED!\x9Ag\xED#M\x0F\xA0\xBE[\xCA\x81\x04_\xEC\xF4\xBAz~\x7F\x1F\xA22\xE7i\xCA\n\xA0,\xD0$h\xDE\x98&\x9B}{\x1A-\xBD\xB85\x85\xF8\xFA\xB8\xB7\x8C|\xC8\xD6\xEFJ\xAFx[#K\xF0\x13n#\xBA\xDBO\xE2d\x19\xF0\xC5P\x11\xF4]\x1C$\xB85c\xC4\x9EI\xD9D0w\xFB\x99\x98&5\x1F\xC6\x97\x82!\xAA\x9C\x91\x90z\xE6E\xE6\xBC\x92\xC6\xCE\xEB\xF82\x93N=\x0FU\xFA\x9Cs\x80\xF5\xBC\x8E\xE9\x8B8\xCD\x96\xA3\xAF\x9B8e\x18\x8D\x96~\xF2\x98\x14('u\xA1\xDF\x9E\xC6\x89/\xE6\xE3\x8BA&\xE5l\x91\xF9\x0E\xF4\x94\x0E\xBE\x05\xBE\xC0\x1E\fB_@\x9F8\xEF\x03\x84\n\r\x1B\xBE\x03\x91\xD2\xE9DJ\x87\x10\x06\x17#\x05X\xD0\xFFbA\x07J0.\xB8\b\xE2\x00Bs\xA2\x8F\"\x8E\xE0\v\xE8Q\"=\x8A\x19&\f\x9B[\xE6\xED}\xC8\xA4`>D`\x94H\x88\x89\x1Ce\x1E\xAC\xE5\xE2\xA70\xAF\xAFH\x01\x95\x1CTl\xFD\xBD\x9E\x05m\x19\x9CSx-\x1F@N\xC7\x8C\x14F\n=K\x9F\x84\n\xFB\xA6\x8A\t4\xD1\xDA\xF9\xA0B\xD1<\xCA[8\x9C\xC2<\xDD\n\x84\xCE\x89\x97\x87V\x1E\x9E\xA5L\xEA:e.Z\xFA\xA2\x11\xE6(I\xB9\xE5\xEAlG$-\xA0\xA0FAs\x02X\xCB\x04pu@\x00-\xD0\xB6N$t\x11\x88g]#\xE8$\xAE\xB6*\xE1_\x10\xF9B\x87\xC8\x04\xD0\xC7\r\x88C\x99\x82!\xC7\x94\x02P\x9C\x9E\x8B\xA6t\xA2\xB4V\x8A\xA4\x0E\xCA8\xF3&\x94\x05\xEA*\x96OJ3)\xD0\xA1\xC2\x95\xA8H? %\xA5\x00j\x12k\n\xEB&e\x07!\x1F('\xA8H\x04\x89\xA1\r\xA1\rmG\x9F\x80\x1D?\xA2\xD3\x89\xA3a\x8D\xA2\x19y\x88\x86S0\xB7@\xC6\xE2\x04\x0E\\ItE|QG\xA6O\x12\xBA|M\xCA\xAD\xBC.\x1D\xFD9\xB6\x96|\xC3\x7F\xA8%p\x88\xFFX\x84l\x1D\xF4y\x8E\x1EQC\xC1T\xFCHA\x93\x82a>\xE6\x9Frr\x1B\x06\xE4o\x90\xDC\xD6E\\\xB2=\x92\xF9^F\xB6Cb,LB_\x8E\xE1\xDF\xE8\x81h\xC7\xD0'\xBD\xE4\x01\xA0\xA4\xFC\xE5 \x98\x84H\xC6\xCC\x18\xA5W\xD6\xDF8\xD0\x8D\xA1\x1D+\x04\x84A\xAD'\xAD\x88\x90\x9C\xFB&\x93IEX\x024'\xCF\x9A \xF4q\x8D\xE2\xB4\x85.\x88+\x00_KNt\xCE\x15\x1A\x81\xD4\xFCK-\xFC\x11`\xCD\x05\x13\"\x1Bj6f\x83a\xBE\xA7\xB0\xA7\xE8\\\xEAc4AA\xE9c\x7F\x02\xFC\x02\x84\x05h\x16\xA1E!\xCB\xFF\xED#:\xB4\x8F\xC0\xC6\x04\xB4\x93\xA0\xE5*\x1F\xE7?r)Ld\x02\xBD1J\x82f\xDE\x8D\x83\xD1\x12\x91B*n\xDC9(\x17=\n\xEB\x92\xB4\x8A\xC4\x8E\x84&\xA5Y\xCF\x04?9\xFA\xA4\x9A\xCC\xBF8\x1C\xFA\x14\xD0\xD6_\xEA\x17\x06y\xCB\x86+\x85 \r\xCDB`\xF2p\xA5\x18dC\xA4\xB0\x9E\x84V\x1E\xA2\xBC.\x8E\xBE\xADkeH\x01\x95>\xCF\x064\xC1\xA5\xA0\x10%\xA0\xC2\xA8\x84\xFD\x12j\xF2K\xFA\xDC\xD4\xCA\x96\x03\x1D\nY\xFE\xDB\x0E\xC6\xA14\b1\xF3&\xE7\x86\xAE\x12\xF6J\xF1\x11\x93\x9C\x98\xA0\x99O\xE5\x7F\v\xC9u\x85\xED\xE1P'm_'e\xEES\xD8\xA0\x82S\x12\x82\x12\xAC+\x8C`(\xD4\x93\xA3\x0E6\x98\x7F{\x99\fdC\xAC\x7F\xC6\x15\xF7Z1HC\xB3\x18l\xBD\xB8V\f\xEA\n\xFDb\x86\x7F\x85>E\v\x07l\xC3\b\xFF=W\x07T\x80\n\xE8\x1C\xD6\x14\xF6\xE9)M>\x9D\x98\\uJ\xD0\xA2\xB0\x95\xFF\xC8\xD1\xCC\xAC%!\xCB|/\x0E\xD0\"\x03\xA0\xA5tURT\xA1L\xF0\xE5\xB6\xFC\x9B\x0F\x19\x141\x85\xD8\x92\xA1\\\x05\x14\"\tm\x85K%hP\n}\x1B\xA3\xED\x02\xC4'\xE8\xC6\x1FnB79\xD9\x81\xFFfq(\x8C\xBD\xA8sU\xD0\x9C\xFBY\xFE\x8BYi\x87-\xF2\x0F\x14\x8C\x00h]\xBA\xF5\xD5\xA9\xFC7)\f\xE9\x7F\"?r\x06\xE4\xAF\r?kRnQ\xC3a\x8E\xCA\x1A\n\x19\xFE\xE9\x91\"\x05\xC3?\x89\xFA\b\xFF\xDA\x02\x14\xE0\x171\x90`\x82\xE6\xBF\x88\x91\x84N\x92\xF9\xFE6!\xB2\xE3\x93\xE4\xABG\xC3\x8E\xFCC6\x8C\xBD\xE8\x17\xD1\x07]\x05\xFCb\xCC\x7F\xDD\xC6\xA80`;\x1A\x11~;\xE6'V\x80\xA4\x7F\xB4\x84\f\xBF:\xB4u\xAE\xF4K)\xA4\xE4\xF7\xED!\xFE\xC7f\x1B]@W\xD3n\x9Aoj\xD0\x87\vW&!\x07Q\x11\xC3\x82\x0E\xA6\x14\xFC<\xF8y\xB8\xED`6D\xA4W\xFD\xC2\x80\xC3Hb\xBB\xA0\xF9\x0F$4\xD3\x12\x1C\x17\xFA\xC9]\xDC\xBF\xFE\x19\xE5\x9F\xD2iN@6\xC4\xC2_\xD0\xC1\xF0\xDF\x04\x9Df\xCF\x8DChC\xCF\xC64\xE8F\x9F\x98\x8F{U\xBA\xFD\x85\x10\x86\xDE\x9BZ\x0E\xE9\x95\xBE=xjlV\x8D\xB1gBLQ&d\xEF\xEA\x92\xCD\xC5A\xBF\xA5\x90\xBC\x8EJ!f#?\x1CL\xA9\x816PM\x88rZ\xAB/\x11\xFF-\x1B\xA2\x02n\x1B\xEC\xF8$\xFD\x84\xAD!tq$\x87&4\nC\xC1\xE4\xB0\x91\x87l\xD0\xC2o\xD3\x11\xF0&\xA5\xD3\xB0q\xA4\x1B\x9B=\xCF\xF6\xA0\xCB\"\xEE|\x81\xC2\xAC\x1F R\x98\xED\x80\xEF\xDC\xD1\x1EsQ\r\xBB\x06\xB6\x87yp\x90\x8D]\xDC\r\xB8\xD3\xBF\xEF\x14L6\x14\x0E\xF2\x93vi\x05\xF4]\xAD3\xB3\xE7\xD9\xEEv\x9D\xECUHza\xE9S\xA1=\xE43\xE9'\x8DT\xDF\x1E\xF5\xA5\x98\xBB\xA3~\x9B\x84\xFF\xF8)w\x8C\x9B%}0\r\xDB\x95\xE6\xE0_{\xF0`?\xF9wW\xF7\xCBV\xC1\xDB\x1Am\xEC\xDD\xBD\xA4\xA0\xAF\xD8\xF1q\x90\x1F\x9B]\x8C\f\x06\xE3\x9D\xC7\xF9\x02\x1EJ\xFCwK:\xFBM\x7F[l\x97\xCE\xDE\xD2\xAF\xE4\xE0\xBBG`\xA3\x84\xEB\x13\xE3\xAF\xEF1~\xA3p8\xE9lw\xFD\xC0\xF9?@\xFA\x91\x8B{\xA110C\x1E\x13\x03\x97xz\xBD\x92\xA3\xEB&\x1D\xB9\xD3H\x93't\x9F\xB7^\xD4'\xDF=2\b\xE9u3\x9Eb\xC2H\xFC;\x93\x98\x06_\x0E\xAE\xA7\xF1\xFB.f\xD3I\x13\x1FI\x07&1\r\xDB\xE5'\xB0\xE2\x80bp\xBE\x97\xFC\x8F\xE4s\xBB\xF8Q2\x94s\xBE\x80!@3O\x9D\x8E\x1C\x9C\x9F\x18\\\xBFiSW\xEE\bl\x140J\xCC\x9E\xF3\xE4\x93\xBFi#d\xAE{\x82\xAE\x03\xB4\v\xD8\xA3Q\x00\xC8\xA4\xDF\xCC\xEB\xF4C\x8B\x06n,\xDD\xABB\x1A\xC58\xEF\xA0\t\xDA\xCCN\xAEk\xD9v\xE2\x00\xDB\xC7\x0F\xC4\xE0z\xBD\x18\x07\xE3\x04K\xD3I\xE3\x8F\xA4\x03\x0E\xC6!\xF3\xDE\xD1\xFC\x88\xD8\xAE3\x03\x85\xA9\x8D\xB7k\xFE\xF7x=t\xD18\xA5u\xBD\x10\xFAV\xDD\x02\xB0`=\x19\xA1[\x9F\xD0\f\x9Cw0\x92X\x9F\xD0\x9C\xDF>\xA2?d\x9D\x8EZ\xC0\x94\xEE\xF0\x9A\xEB\xBEE\xD7\x95N\xBC}\x04o\x8Bd\xA8\x8B\xD21/\x8D\xC4\xD0\xB0 Pa\x99pgr\xA8\xD2\xB5\nq\x80\xBD\xC57\xE5\xDB\xCC\xC7\xA2\xBE5\xFE\x18Ui\xC2p:\xDB\xA5\xBF\x1D\xB6\x8B\xBF\xDF\xEB~^w\xF4\"3\xB2s\x04\xB36\xBC\xBE\xAE\x00\x87\xC7\xBBC\x9B\x06L%\x04\xC3f\xBF\xE9\x9C\x9E\xDF\x92\xCF\xB2\xD0\xD7#\xAA\x0E\xD9NtY`\xDB\xC1\xF3\x05]:\xE9E\xF3\xDE\x96\xA35<P\xF1\xA5!\x1B?+\x96\x9E\x05\xCD\"\xD4sZ*\xB2\xE9\xA4\xF1G\\\x13 H\xF8\v\xFA\x98\xBD\xBE5?\xEB\x13Z\xFESw\x07l\x9F\xFF\xED\xF2\xB9s\xFA!%XW1?\x06:\x11:\xC6\xFCC<\xAA\x95\xED\x91\xC5\xC3\xDF\x16\xA4>\x16\xE3!\xD4Tg\x8A#J\n%M\x7F$?\xE7\v\xE4H,\fyx*\xB9\xF8\xDB\x01t\xCB\x95\x86\xF9\x1C.\xD9xsBk\xBF\x11\xFE\xEBI\x15\xC8\xA6\x93\xA6?\xCA\xBFE\x832E}\xCC:3\xB7\xE6g\xA3\xA4_d\xCE\xB7\xA6\x93\x8D\xBF]>wN?J\x12\xCC\xF2\xAF\x13\xA1c%\x07\xF39\xEC\x0Fwr\x87\xF8\x1F\xCEO=\xAF\xAF\xA73\x01\xF4\x8B\xE8\xB8\x1D\xFF\xF3\xB9AH]I\xE9+\xCC\xEBF\xBE7\r#\xFC\xA7a\x84\x7F\x13\xC6\xF0\x9F\x84\x11~\xD2\x10)\x9D\xA5H\xED\xC4\x7F6\xFF\xDB\xE5s\x87\xF4\x07\xFC\xBBhx\xF6\x87\xE5v \xFF{\xE3\xDF\\\xF7\xF7\xCC\x7F6?\xA9\xFF\xF6\x1D\xE4\x7F$\x1D\xF2\x94\xEE\"\xFF\xA3|\xEE\xC8\xFF\x98|R\x82\xFDD\xFE\x1F\x1C\xFFZE\xD0\xC5\xB5\"\xA6al\xFE\xF7\xC8\x7F\xAC\xEBD\x9C\xF8\xA1\xF3\xBF\x96\x19v\xC9\xF2\xBFk\xFE\xF7\xC8\x7F\x9C\b\xC4/\xDA\x95\xFF\xF4C\x8Cmv`\xFEu\xEB\x93\x84l>\xB3\xEDfZ\xA9w\xE0?+\xF6Y=\x90M'\x8D0\xD2nf\xF9\xCF\xFA9\xB3\xE9k\xB3\xDC\x8EI0O\x19G\xE8v\xF9\xDFAN\xB6K_\x07J0\xE5\xDF\x1B\xE6\x7F>7\xD0\x1B\xE9\x87x\x96\xCE\x8C!'\xFD.3\x982\xC2\xBF\x99\x88e\x1A\x85\xB2\xC0\xDB\x07\xF3agF\xE4\xDE\x01\x0F\xFA\x9E_z\x88\xF94jx_\xE9\xA0z\x80\f<T\xFC\xA7\xBAq\xBBv\xC7LlK\xC3v\xF1!\x99\x17\x04bt2\xA7\x91\x7F\x95\f\x9A\xF8\x07\xE5\x7F\xBB\xF4\x19\f\x06\x83\xB1\x03\xCC\xE83NBc2\x19\x89\x96\xF1\x8C\xEEw\x04c\xC6\x88m\xDC\xCC\xC1\x12\x00\xB8\x9D\xCA\xC3A\xDA&\xC4\xB3\xD3\xEF\x1F\xAD\xA4]CrF\x05\x00]\x05~\xE9\x00)\x1D\x8E\xD9\x10\x90aY)$\xA3\x00\x0E~M\x05\xAB\x12o\xE5a\xC9\xED\xD4\xA8\x14\xC0=\x84w\xD5\x01<\xF2\x84\xD7\x8E \x1C\xD9v\xFAGM\xA2\x9F\x87s\x12Z\xD4-\x02\x07\xEBf\n\x90\xB1[l\b%\xD6\x8A\x00n\xF2\x00\xCDH'\xB1\xE9\xEC\x89\x7F\x92\xF9N\t:\x12\x82\x02t'\xB51\xE4;\xFB\xFF\x1E\x1BC\x17+\x005\x1B:\n\x9F\xB5`^\x06}\t^a\x7F\xC9\xF4\xC9_\xBDQ\x8C\x87Eb\xFEUp\xCD\xC5U\x15\xD4\x14\xD4!8\x94y/u\xF2\xB1\x83\x80\xA6D(&\xD3\xDA\xB7\xFA~\x9Da\xFE\x15\xD6\x9D\xCCL!\t\xDED\xA0{\xAC\x13I?\xC5\xC1\x03\xF0\xDF\x15\xFA\xA4%\x12\xF9\xDF?\xFF\r\xDD\xBD\x85\x9A\xA5\x05\xA6\xA5\xF0\x8A\r\x81\f|\x1B\xCA\xF9\x83\xA8\xA0\x8E\x85A\xEA\x8B6\xFC\xE7a\xC0\xFFa\xA0\x0EP\x11\xBAgz\xBB\b uq\x87\xE3D\xA5\x9E\x87\xC0\x81\xB6\x80z>\x00\v\x82<\xD4\xC5\xC0`\xCE\xF2\xBF\xE4\xD2J\x04;\x19\x95\xDB[%5:?(\xD1\xAC\xCER\xA2\xFF\xF7\xCF?\x16\xB5\x12\v,8\xEFvZ.~\xCD\x82@\xA2_\xC2\xF2\xFEu\xC5\x96\xB9d\xC4?\x10\xFF\xF20\xF9\x1Fyi\x7F\xDC\xAC\xA1\xA1%xf\x12r\xCC?\x86\xB4\x86\xC5\x13AY\xE1\xD2\x04\xDE\x99@\xB0u\x85\xF5\xDE\x89&\t\x1D\xCD\x7F\xF7\bl\x92\xFC\x7F\xCD\x86^\x1E*\xF2A\xF1\x7F\xE0NVhk\x15\xB7\xE9v\xC6\xF1\x8F\xE32\x93\xB9(\xC1s\xB0\x9E\x8B\xBF\xD8\xACn0\xFA_\x11\xFFfm\xD1;\xD2\x01\xBC\xE9@{\x12\x03\x07\xCF\xDBp\xDB\xC5\xAF\x15!p;\r\x89^\xFE>L\xA0\x1C4\x86\xF9_\x151\xFF\xC1\xA1\xCB\xBF\x8B\xB1\xFC\xE7\x86\xF5C>\x18\xE2\x9F\xE6\x81\x9B!\xA1\xBA\xD6\xB1\xE0\xC5\xFC\xC3\x9D\tlS\x83\xF5\x8EX\x8F-\x07\xD6'\xA0\xEB\xE0&5U_+\xC6\xF2\xBF\xDF\xF6wh\x9E\xA4\xC4f\xC2\xFF\x15\xC3\xBF\x15\xF3\xDF\x7F\x00\xFAg\xAC\xFE\x1F\x9AN#\xC0\xCF\x0F\xF8\xEFC\x86\x7F\x07\x96\xDCx\xFDKpH\xFD\x82@\xEE\xA3_\x10\x96\xC8|u\xF0\x19\t\xEB\xC4\x7F \xB1!\xB1.\x0F\xCE\x7F}\x12on\xC3\xFFa\xC9\xBF\xE9P\xDC\x86m\xED\x9F\xEF\x1F\x19\xBC\xCA\xB7 HM/Z\x12\x8B\xC9\x1C\x18E-f\xBB\xA0\xED\x9F\xB5C\x91g\xE2s\xB4_\xB0\x03i%l;P#\xFE\xDBG\xF0Z\x91\xEC\x9FI</\x0FU\xFE\x01\xEFS\xFF\x0F\xF87\xD3~\x8C\x91\x9FN\x03\xCEC{\x8B\xFD9\xC8\x98\xB1\xFFE\xCC?\xD0\n\xCA0\x91\xFFtm\xE9\xE1\xF0O\xABcF\xFB\x05\xDB\xC7\x9Fw!t`\xBD\x845\t\xEB\n\xD7lm\xFF\xFBG\xA0-\x0FG\xFF\x8F\xF0\x7Fh\xDDm:6\xF7\xAB\xB2\x14\xC2\xD8v\xCD:<}N\xB3>F\xFB\x05;<`<\xC3\xA5\xF1\x97\xEF\xD7\xFE\x91\xF8\x12\xE8\xFE\xEF\xEA!R\xBF\x7F\xC3l\xC0\xBF\r\x90\x7F\xC0~\xA1I\xE8\x96\xB6\xF4\vv},\x95\xF6\xA4?~\b\xC6p\xC6\xFF\xB3dt\x02\xBB\xED\x18\f\xC6C\x8E\xDC\xFD<\xDC`\xFE\xEE\x172ia\xE5\xE6H\xE366\xFA_\x93y1\x19\xFF\xD7<\xF8{E\xA6\xF0\x044\\\xDDx=j\xF5/\xBC\xFE\xAF>\xF3\xFAs\x7F\xF9\xEF\xEF\xFE7\xAF?2\xC8\xA3\xE5\xCF.\xD3|s<\xB77\xC3.H\xC2s\xE3{,\x0F!\xFF\xCE\x88\xA9\xD3\x02\x18]\\\x00n\xF4\xC3\xC4\xDA\xD1\xFB\xE7\xBF \x9BA\xE6\xBC&U\x00\x12\x9A\xB3+\x91\xBFR>}\xFA\\y\xE5\xE0\xD38\x94\xB6I\xB55\xFA\x1C\x94\x02P\x0F\xB7\xFE\x99\xDF\x81\xFF\x8DQ\xA1U\x86\x7F\x1F\xEF[\xFF\b\xE5\xE1\xE0\xDC\x7FY\xFF\x9B\xE5\xFF1\xEB\xE0V\xA1g\xD5-\b\xFC\xE5z\x03\x8E\xF9\xF0@\\\xAD\xD6@\b\xEF\x13\xD5\xD1\x8A\xB0\x13\xFFwfZY\xFE\xEF\xA3\x97'\xBC\xE3\x99\xF3\xA3\x96w\x14b\xFE\x8F\n\xE2?\x1EuL\xF5O\xFD\xA8\xAC\x9Fx\xE1\\m\xD9\xDBC\xE7\xA8\x06\x18\x04AP\x87Y\xEF\x01\xB9Z1%\xE1\xBE\x13\x8A\xD1\xDF\xCA\xFF\xF5\x91W\x88\xC8\xF0\x7F4\x13\xE7\xA0\xFC\xFB\v\x99\xF3\xCBE\x7F&\xE6\xBF~\xD4\xAA\xCD\x9D>7\x93)\xDC,\xFF\xA7\xF7\xF0\xD2@V!\b\xEEu\x83\x1AT\x95| \xAE\xD6{\x1D\xB8\xD09\\\xFEG\xB8\xD6\xA9\xDF\b\xB6\xF0O\xD2\xE4\x1C\x02\xFF\xCF\xFC_\x03\xFD\xF3\xCC?\xFA\xE5g\x1E\xC3]\xF8wD\xF3\xC4\v\xE7\x16\xF6P\xE9\xEEu5\xF9A\x10T\x01e\xF5\xC1L\xD5\xA3\xAD\x1C\x1E$\xFF\xFA\xDF/\x8D\xF2\x7F'n+b%x?\xAA\xF5\x9A\x13d\xCF\xF5\xBF\x86\x7F\xC7\xAA\xCD-\x8C\xD1?{\xE7?\x80\x00\xAAU\x1F\x03a\x818\r\xEFJ\xF9\xB7\x9A\xE3\xF8\x8F\r\xA2\x13&\xAE\xD5\xBB\x8F\x06,\xD3\xFEZ\xD3G\x97\xA7\x8F\xC6\xF2\xEF;\x10\x1D]\x18j\x7F\x89\x7F_Z\xDE\xD4\xCA\x9E\xF4\x8F\x0F\x01\xAC\xD4\x00\x02K\x80\xF5qx\xB8\xF5\x7Fu<\xFFB\xDB6\x97\xB6\xE1\xFF\xEF`l\xB7\xDC\x87\xFE\x91~\x9A\xB8\x98\x9DY\x98\x9D\x89\xE5\xDF\x97\xC4\x7F\xD6\xFE\xCC\xF2\xBF\x97\xF6\xD7\x83\xC0\xB2\xEA`\xD5a\x15\xE0u|\xB8\xED\x9F\xF9m\xF4\x8F\xC6\xC5\x11Y\x13\x7F1bC\xDEG\xBFcv!\xC8\x9CW\xF5\xBF\xD4\xFF\xF2%|\xF9\x07\xDE\x18\xEA\x7F\xED\xDF\xFE\x0F\x04t\x01\xBA\x10\xECq\x86\xCB\xFB\x0Fjz\x193\xE7Q\xE6\xDFC@\xDA\xFFe0\x18\f\x06\xE3\xDD\x8A\\\x17\xB6\xBA&\b\x8D\x1F\xC2\x87\xDC\xBD\xFBP#\b\x00r[fi\xB9\x9B\xA3\xA6:l\xE5?\xD0\xCFB\xEB\x04\x82\xF3\xB0\x7Fe\xEFa\xE6\xDF6\xEEq;\xC3\xB9\xF0\x86\xFEM\xF9\x17i\x17\xC1\xF0\xDF\xF5\x11g2\x937\xE4~\xBA\x03;,\x12\xC9\xE5\xC0z\x9D\x12\xAC\xED\xD5$}\xF4\xF5\xDE\x0E\x1D\xEDq\xD6\xE9\xDE\xBA\x11\x0F\x18>\x82\xC2\x98\xFFG;\x00v/\xE6\x7FX\xE2\xB5\x86\xC9M\x83Hg\xEE\xB4\x00Z\xFE\xB2g\xF8O\xC6\xC2`\xD2\xCE\xF4\x98\xC4\xF4A\xF8\x7Fq\x93\xA6\xE7t&u\xEF\t\xD4j\xB0G\xE6\xFD\x1D\xB8\x12\xF2\xA0\xFCO?h\xFEOb\xB2Z5\xA7\xFC\xB4\xC4\x8572EJ\x7F\x80\xBC\xF6\xF8JZ,\xC4\xFF\x8A2\xFC\xFF\xE0X\xF9\x97\xB3\x07\xEB\xD4S\xD1TB\xD0EyT\xF8{p\xF5(\"t\xFBVH\x8A\x83\xF2_~\xD0\xFC\x1F\x05\x80\xE7\xFB\x86\xFF aZ\xF3?\xEC\x8B\xA8\xD2\xFC\xAE\xC5\x85\xF4#[`yG\x85\xF218\x9A\xE1\x7F\xC8\xA9\x11-\xEC\xFC\xEA\xB1\xCECs1\x95\xFF\x99=\xF8W\r\xF3;\xF2\xFF\xE9\x83\xF2_{\x1B\xF8\x9F4\xF2o5\xF5\xB7\x1B\xB5\xAF\xF9\x0FF\xF3\xA1\x82\xD5\x99\xB4\x92\xEF\xCE\xFF\x19\xB5p\x10\x9F\x10e \xD5\xFF\xD5-\xE3\xCF\xDB\xF1\xBF\x93\xFE98\xFF\xD1\x83\xE6\xDF\xD1E\x10\xF3\xBF\x83\xFC\xB7I\xFF\xAC\xCE\xA4#\xA9-\x10\xCA\xD1\xFC\xFB\n\x07\xFC\xFB\xD9I\xFDr\xF5\x00\xF2?B\xE2\xDE\xE5\x7F\xA7\xF6\xF7\xC0\xFA\xC7Ro\x03\xFF\xC7\xE3\x8Fn\xED\xA0\xFF\xDB\xD4\xFE..\xA4#\xA9C\xFC\xA7\xED\xEFg:\x99~B\xEE \x997\x85r\xF2\xC5\xDE\x85\xD77\xF7\xA5\xFFw\xC2\x81\xDB_\xF1\xC0\xF9\x97\x00\x89R\xE9\xEE`\xFF\x18)|\xFC\xF9\xCDDh[ \xA5\x14\xEA(h\xFE\xC5X\xF9\xDFU\xB8\xC6\x99\x96\xFE\xB0\xDD\xBBw\xFBg\x7Fblo\xEE)\x8Bv\xFFm\xE0\xFF\x91\xB8\xFF\x15\xEC`\xFF{[\xFB_\xC4\xFF\xE4}\xF4\xBF\xC6\xF2\x9Ff\xC2\xC8\xFF\xDE\xED\x7F\x13\xFF]\xD7\xFF:(R\xFFC\xE7\xFF\x0F\xEC\x7Fx\x07\xF9g0\x18\f\xC6{\r\x8F2\x05\xEF(\x1A<m\xE3\x1D\x05\xF2\x0E}\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1x\xAF`\x12\xBA;\x04\x7FE\x8D\t{\x9B\xA22\xFE\xD9-a\x8F\xF9|\xD4\xEA\xED%\xBC\xEB\xF8\x7F\xFC\xF9\xE9\x1DBP\x95c\xC2\x1E\xF7c\x1A\xFB\xEC\x96\xB0\xC7|\x1Eni><\xA8V\xDF\xFCd\xF5\xD9\x9F\xAB\xBE\xF9s\xD57?y\xFA#O\x9D\xFE\xC8O\x9F\xFE\xC8\xDF\xFF\x96\x0E?}\xFA\xFB\xD5\xEA\xAD'\xAB\xB3?[\xBD\xF5\xB3\xD5?~\xF2\xF4G\xCE\x9A\xBB\x9D=\xF2\xBF\x1ATg\x83\xEA\xB3Au\xB5Z\xAD\xD6\xAA\xD5\f\xED\xAB\xFB\xE5\xFFpS{x\xF0\xE4\xE9cOU\x9F\xAD\x9F\x96\xA7N\x1F{\xEA\xCC\x93\xFF\xE4\xCC\x93\x9F}\xFD#\x9F=S\r_\x7F\xF2\xB3\xDF\xFA/_\x9A\x9B\xB9\\\xFEtsnfen\xE6\xF2\x87\x17\xFF\xDB\x0F/~\xEDw\x7F\xE2k{\x1B\xA7{\xA9\xBC\xF2Ry\xE6\xA5\xF2\xCA\xCB\xE5\x15,\x8B\xA8\xBC\xF0\xA5\xF2\x1B/\xEBp\xF5\xE5\xF2\xCA\xE5\xB9\xA9W\xE7\xA6^\x99{k\x8F\xF9<\xDC\xD4\x1E\x1E\\)O-\x97\xAF\xFE\xD6\xDC\x1B+:\xFF\x8B\xAF\xCC9\xCD\xEBO\xFF\xFA\xDC/\xBE2\xB7x\xA5\xFD_\xAC\x96gV\xCAW\xBF<'V\xE7f.\xCF-^\x9C[\xD4w\xF7\xC6\xFF\xE5\xF2\x1B:\xCC\xE9\xE3jy\xE1Ry\xE1\xD5\xF2\xE5W\xCA\x97/\x97_k\xCE\xBD\xA1\x19+_\xBDT\x9E\xD9c>\x0F7\xB5\x87\x07\xAB\xE5O\xFFr\xF9\xEA\xF2\xDC\xD4j\xF9\r\xE2\x7F\xEA\xD7\xE6\x9En^_|e\xEE'\xAE\xB4o\xAC\x96\x17t\x15\x98{m\xB5\xFC\xDA\xCB\x9A\x7F\xBA\xBB\xB7\xB9x/\x97/7\xE7f~\xAB\xBCr\xB9|Y\xA73`l\xE5%}\xF1\xEA\xAB\xE5\x85\xD5\xF2^\xD7,\x1Cnj\x0F\x13\xFF+\xCBs3\x9A\xFF\xB9\xA9/j\xFEg\x9A\xD75\xFF\x97\xE7\x16\x7F\xED\xFA\x89\xD5\xF2\xCA\xCA\xDC[+s3\x91VA\x8B\x17\xF5\xDD_\xDA#\xFF\x97\xCB\x97/\xCF\xCD4\xB5\xC6\xB8\x9C\x91\xD87^.\xAF\xAC\x10c\x97\xCAWW\xCB+{\x96\xFF\xC3L\xED!j\x7FO\xCB\xA7N\xFF\xC7\xA7N\x1F\xAB\x9D>v\xEA\xF4\x93O\x9D\xAE\x9E\xFB\xD6s\xE7\xBE\xF5\xE4\xD3\xA7\x9F\xAC\x7F\xEBGW\xE7\xC4\xE5\xF2\xCCe\xCD\xBFO\xFAg\xE1\xCA\xF5\xA9+{\xE3\xFFW\xCBo\xBC\x14\xF3syun\xE1\"1f\xE8\xFAr\xF9\xD3/\x97\x17.\xE9B\xDF\xAB\xC6>\xDC\xD4\x1E&\xFE\xFF\xE3'\xAB\xB3\x9F\xAC\xBEY\x8B\xED\x9F\xE7~\xFA\xF4\xB1\x9F>\xFD\x91\xA7O\x7F\xE4\xEF\x9F\xFE~\xF5\xF4\x9BOVg\x9F\xAC\xDE\xAAUo\x91\xFDCw\xF7i\x7F\xFE\x83!\x13eu\xE1@\xF6\xE7\xE1\xA6\xC6\xF6?\xDB\xFF\xDC\xFFe0\x18\f\x06\x83\xF1\xB6Al\xBF\x87\xB9\x00\xBF\x00\x8D\xCC\xD1\x9C\f\x9D\x8F\xC47\x91M\xFC4ZA\x9F\xEB\xC8\x85\xB7\xF1\xF7\x1A\xEEm\xE7\x17u7\xEF\xFDi\x1C\xB6\xDE\x1C\xFD\xE9\xFC\xF8G\xDD@\xC6g:\xFF\x05h|\xD0\xEA\xEE'/\xDD\xF7!\xFF\x97\xC7\xF5\v.\xBC\xBE\tJ\xE2\xD9\xD9\xCBOV\xA3\xEF|5{\xCB\xFCnRw2\x13\x13\xC0\xEA<\x92\x18\xC6-G\xFF\xBF\x06\x00?\xB4\xDC\xFFI\xB1\x9F_\x96\xCEM\xBF\x0F\xF9\x1F\xBB\x16\xFF\xC2-\x19\xF3\xBF8\xFB\xCA\xD9c\xC3]\x8F\x16\x00\xF4\x8B8\x88\t`w\x9EM\f~\xEF\x07\x93\xAD\f\xFC'6\x97V\x97\xF6\x91\x15)\xDF\x87\xFC_\xEBl\xC3\x7F\xF1\xCD{\xDF\x9E\xBD\xF7\xEDcW\x17\xBF\xBA\x95\xFF\xBB*\xCE\xE1I\xEA\x8B=\xFA\x8D\xD5\xF4\xDF\x1F\xC7\x98\xFF\x1Fyb\xB3_{\xEEP\xF8\xBFw\xEF\xDE\b\x87\xB9\xDEI\xBBw\xE1\xAE\xDB\xBD\xEBv\xF7\xC2\xFF\xBD\f\xDE\x1D\xF2_|S\xCB\x7F\xED\xA5[OV\x87\xBB\xB4\x9E&$\x9A\xCE\xF2\x7F\xE1\x8Fe\xFA\xE0\xCF\x05\xF1V*g?tw\x7F\xFC+\xB1\xED-\xF7\xDE\x16\x19>Y\x80\v\xC2\xED\x16\xDCn\xB6,\xCC\xB9\t\xE6J\\Fn7w\xEF^\xC1\xED\xDAq!\xDC\xBD7\x8An\xF6\x9F\xB7\x8D\xFF\x8B;\xF3\xBFE\xFF\xC7\xFCo\xC8\xB1\xFF\xDE\xBB#\xFE\xA8\xF5\x00\xF8\xDF\xA2\x7F\xB22\x0Fp\x12\xE0\x02\xB8]\xD0u\xE1$\t\xB0\xE6_\xE8\x7F\x1B\x85\xA4\x8E\xA42\x0F\xBA,\xEE\x02\x95\x85)\x17\x13\xCD\xBEgJG\x1F\x1F\x06\xF9\xD7\xFA\xE7;\xA3\xFA\xDF\b|*\xFF\x86\xFFQ\xF9?\x98\xFE98\xFF#\xBA\xBD\x91\xA8\x9D\x91\xF3\x84\xFF-m\x81H\x94Oa\\\x9CwF\xFF\x9B\xF6\xF7\xEC\xA8\xFE7\xFC\xA7\xFA\xDF4\x07c\xF5\xFF\x03m\x7F\xDF3\xFC\xEFb\xFFl\xD1\xFF\xC6\xE0I\xED\x1F\xC3\xFF\xA8\xFDs0\xFB\xF3}\xC9\xFF\xD8\xFE\x97\xB6\xEA\xB7\xE9\x7F\x19\x83?\xB5\xFFMw`\xD4\xFE?X\xFFk?\xF6\xFF{\x86\xFF\x03\xD6\x9A]\xFA\xBF\x07\xC3\x01\xFB\xBF{\xE1\x7F\xC7\xF8\xEF>\xFE\x19\f\x06\xE3}\x86\x80\xF7\xD0{x\xF8?\xF9\xFC\x98}//4\xE1+\xDD}\xA7;\xB9\xCF\xF8R\x9Bj]s\xFCA\xCAUn\xF9\xFE~\xE5\xF6\xDD\x81\xAE\xB3\xA5'2j\x98\x85\xD0\xDD\xFF\x8F\r\x1E\x85\xFD\xFD\xFC\xD6\xA4\xBC\x06V\xCF\xB1\xBF\x0E\x96w\x02\x82\x02@\xE9\xFD\xC7\xFF_\xDDyck\x8C\xE7*\xF0\xCD\xEEA\xF8\x87\xFD\xF0\xFF\xA8Z\x00\xABw\xD4\xBDk\xF8\xCF\x03T4\xFF_~\x8F\xD3\xEF\xDE\xFD\x7F2\xDC\xDE\xFB\xB7S[\xA3\xF8\x15\xE8\x04\x07\xE1\xDF\xDA\xCFS'#\x01V\xCF\xFFb\xCC\xBFD\xF8\xE1\xE5\xC6{q\x03\xDB\x91\x0Er?;\x8B\xEC/\xFE\xE2/\xB6Fy\xA4\x02\xDF\xC4\x83\xE8\x7F\xB1\x1F\xFE/l\b(\xFC\xBB\xE0Sw\xA1\xF0\xD5\x1F$\xFE\x7Ft\xB9\t\xB9\xF7\xBA\xFE\xB1z\xD9\x9F\x92|\xFC\xF91\xFE\n\xAF\x02\x9D\xFD\xF3/\x01>\xBA\x1F\xFE\xEF\xBD)\xC1\xBD\x8B\x1F\xBA\v\xC5?\xF8\xBB\x81\xD1?\xDE{_\xFFX\xBD\xECo(\xF8/\x1C\xDB\x1A\xA5T\x81o\xC2A\xF8\xAF\xC2\xBE\xF9_\xFD\xD0&(q\xC3\xD7\xF6\x8F\xAF\xF9\x7F\xCF\xEB\x9F\x9B'2\xB2\xDD\xB8\xF5\xE6\xD6(\xAA\x0E\xFF|\xFF\t\x9F\xC4\xFD\xF1\x7F\xE15\x05\xEE\xDDO>\xD1\x07u\x15\xFD\xE0\x11\x80\xE3\xCB\xFE{_\xFF\xE4\xA6\x1F\xCF\xF0\xFF\x99q\xF6\xA7\x8D\xF0\xC1\x07/\xFF\x7Fk\xD9\x03\xFB\x1F\xFC\xAD\xE5\x1E\xD8\xFF\xA0\xDB\xE9|\x14\xE0\x1F.\x07\xEF}\xFBS\x0E\xCD\xA2\xDFq/\xFD}\xF3?\xBF\xBF\xF8-\xEA\fv\x01\x82\v\xDF\xE8\xCC\x03\xFCk\v\xDF\x07\xF6\xFF\xC3\x82I\bh\fD\x1F\x1F\xA5_h\xE0]x\x19\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1\xB8\x1F\x94\x1D\xE6\xE0\xED\x80\xBF\xCD\xF5z>>\t\x99\xA3w\x02)\xFF\x11s\xF1N\xC8\x7FK \xF3\xFF0\xF0\x8F\xCC\xD1\x83Dc7\xFE\x03\xE6\xE8A\xA2\xB5\x1B\xFF>s\xC4\xFC\xBFw\xD1\xDE\xCD\xFEa<P\x84\xBB\xF1\xCF\xF2\xCF\xFD_\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x18\f\x06\x83\xC1`0\x1E*\xE4:\xE0v \xF7:\xCD\xED\xA9f\xEF\x1C;\xB4w\x04;\xDE\xD2w%\xFD\xA3\xEE\xF7E\xE9\xCCH\v*;g&H_\xAD\x8F\"\x18\xBE\xA2\xF3#\xB7y\xBC\xB4\xFBG\xED\xE5\xC3\x89mk\x0E\x04\x80\n \xF7<^\xE8\x00\xAC\x1C\x02\xFF&\xDF\x8F\x00\x94\x00\x94\x05^\x10\xE4}\xCD\xAD\xA53\xE3+:\n}G\xB3t\xD4\x0F\x8A\xFA\xEE\x14\xC5\x98U\x00\xC22\x91K:\xA5N\xF6{K:\xAB\xE0+\xFD\x9C\x0Et\x1B<J\x07r\x9B\n\xA0\x92~\xAF\xC4\xDA\xF0DU\x19\x17KP\xF4\x03\x15\x04\xC5\xE3p\xDC\x07q\\\x1D\x0F\xC0\xF2\xC1\xF2\xB1\xA8\x8F\x94\x99\xC0\xE4g\xCA\x13J\xA4$\x06%\x9F^(\xFC)zs\x90\xF7\x9F$\x89\xF1\xE2<\x10|\xF4\x93\xF2\xD7\xC8\xFB\xDB\x8A\x07\x04\xDD\x94\xFF\x89\x0E\xE4,}\xCF\xB2\xB2\xB1\xCB\x07\xE4\xBFC\xD5\x8A\x82\xFA\x86:\xEA?#\xD1\x13B\x9D:\xDE?\x19\xF8E\x1F=\xF4\x85\xA5\x8E\x9F\xEA\x7F\xEC\x14x\x18(\x8C%_Y\x9Ez\x8D\xF8\x17\xEA\xD4\xEC\xD4\xE7\xEC\xCB\x9F;\xDE{\xF4\xF8[\xFA\xCE\xCA\xDD\x9F{\xEC-aw\f\xFFGc\xFE+\xDEr\xDF\xB3\xFA`\xC1\xC7\xC0S\x10\x1CI3!\xA0\x06$\xD5\x00\x17\xBA\x9A\xC2\x94\x7F\x85T\x04\xCB\xE0#X\x96:\xFE\xC3Py\xBE\x7F\x01P\xADJ\xD4\x99\xF9h\xCE\x87\xDAYu\xF2\xF5;\x9E\x98\x15\x00';\x01,\x83\xE5O\xF9b\xEA\xD4\x876-\xF7-\x80)\xCB\x0F$>\rVG\x81w\x01c\xFEO~\xB3\xEF/\xFB\x9Ar{\xD3\xD2\xFF\x82\x1C\x9E\xA9,b\xF1h\xEA\xDC??\r+ \xAA(\x00\x1C \xFE\xED\xCDC\xE1\xFFBf\x82\xD6\x17\x8E+\xEF\xC5\xEE\x17\xC0\x97\v\xEA\x14\x02\xF8?:\x898\xF5\xA9\xBB\xF7\xFEL\x1D\xF7\xBD\xDC\x87\xFA\x17\xE0g]\x00\x17zngSYpw\xE6\xA33\x16\xB8+\xEA\xD4\xEAT\x11\xA2\xA2\xEFY8\x050+\x16\xF4\x95\v\x9D\xDA\x17^\xF3/ \x1C\xED\xC0\x99\x8E\xA6\xD4C\xCF\x03\x0F,\x10\xE0_\xC0 +\xF0\x15\xC0\xA3\xB1Pj\xC1\xBB\xD0\xD1A\xF3\xAF\x8B\xE09w\x19|{\xF3\xC27\xD4q\xEC\x94te|Y\xBD)\x11\x9Es_\xEC<\x87P;\xAB\x9F\xF3\x84'r\x9Bp\xA6\x0F\xCB\xCA[\x9E\xF2\x85:\xE5\xCB{H\xD5\xDA\x0F$<}\xA1;\xAFt\xB9\xEB\xFC\x9C\xA4\x8A\xA2\xF9\xB77AJ+\xB7\tA\xE7B'\xC3\x8B\x05\xC7!\xE5\xBF\xFF\xFF\x932\xC3\x7FW\xC0V\xFE\x0F\xA8\xEB\x95\xAE\x86\x9DI\xE8\x9C\x04T\xF6\xAD\xE7\xE0\xA3\xB9NP\x9C\xBD\xFB\x95\x00\xE0\xC5^_\xD3\xE2\v\xEBc\x1FB_.\x83gw\xFB\x00\xE1\x8B\xEA-\xD7\x97\x80\x9E\x84\xBF\xF9\xE2\xFC\xB1\xEA\xDD\xAF\x9C\xDD\xF4\x96\xC1\xEB\xF8\"\xF8Q\xCDDU-\xABG\x04\xD4\xD4L_\x81\xFF7|\xFF\xAC\xEF\xDB+\xE0\xA1\xFFO\xD0W\xF6|\x0E\xFB\x1E\xE0#[rb\xF4\x87\x05A\xA0\xAB\x80\x7F\xE1\xFF\xBC{\xEF\xF5\xCD{\xB0\xEA-\xDF=\xD9\x91p\xE6\xEE\xBD@\x80\xAF,\xF8\x83\x89\x19\x19\xE0\xAA\x87\x81\x04\x98\xADF\xC4\xBF\xA9;J\xF3o\x95\x8E\xBF\x06AG\x02*\xFD\x96?\xBD{\xEF/7\xC1\x07\xE2\x1F?\x18\x90\xC21\xFCK\tR\x9E\xEC(\bD\x10\xA0\x97\xD1>^\xCA\xBFP3JX\x16\xC8\x95@\x00:\xD0\x12\x80\x17^\x1F\xE2\x7F\xFE\x80\xCDy\xDF]\xF1\x82\xA0\xF28T,\x88\x945;u\xA6\xFB\x05@oU-\xEB\x1Cz\xD2\x02\x1F\xBA\x93g6\xFES\x10(\xEB\xA3?\xD0\xA1\\\x05RB\xD5\xC6\x9E\xB7\n?q\xAA:;\xAB\x96\x95\xE7\xBF\xA6\xFCV !\x98\xCF\xE1O\xAE\xDE\xFD\xCA\xB7{';5\xDDFX\xFE\x0F\xCD\xF8O\xF9\xBE\x14\xE0ax,\b\x95U}\xE4\t\xF9\b\xE0\xA7\x87\xB2\xE2K\xCA\x8FDU\x80 x\xA2/\xC1\xB7`A\xE9\xF7J\x7F\xC5[\x00\t\xA7\xD4\xF1\x82h\xF8\xCA\xB2n=\xB2 \x83e\xE9c Em\xB6\x1A]\xF8\xCB\xCDGrZ8\x15z\xB0,=\v>&\x1E\xF98h\xFEg\xAC\xCE#\xA03\x06\x01x9\xCD\xFF\x9D'\xBA\x96\xD5\x873\x9B\x86\xFF\x93\xAB\xF2(x';C\xFC\x07\xA9<X>\buz\v\xFFrX\xFFW\x0F8\xCB\x1F\x7Fh\xC1\v\x02]\xE5E\xEEMwyf*\xF0,\v|I\xFC\x83',\xF0-\x7F\xEA\xB8:n\xDF\xBD\xF7\r\xF0\xAC\xF0\xC7\xA1\v\x81Tp\xB9d\xA1\xBF\n3\xC7W\xAA\x86\xFF\xAB%\x7F\xA5:+\x82\xAA\f\xAAR_\x11\xB9\xFE|n\xE6\xC2rx~f\xE9)\x7F^\x8A\xD0[\x8E\xA6OE\x7F\xC7Z\x99\xF5\xDF\x9C\xF9F\xC3\xDA\xCA?(\t\xDE\x07r\xFD \bd\xAE\x9F3\xFC\v\x19\xACz+\x86\x7Fku:\xF0\xC4\xE4\xEA\x9D@\xC2\xCA\xB3O~\xF1\xEE\xBD7j\x10(\x01\xC1\x0F\x88\x86\xD0-\xB9\x0F+\xD2[V~\xAE\xBBD\xFC\x9F\x12\xFE\x8C\xE1\x7F\xB9\xE3a\xF7^\xF7\xA6B\xDF\x02u\xB2#\xFD\xE5\x19_J\x1F\xE5Qh@ \x83'\xFA\x8F\xC6*\xB1s\xB2\x93\xE1\x1F\xBCZ\xB4\x85\xFFa\xFD\x93C\x00q\x80\x95.\xBD\xB9\x19\x15\xF8!,\xF7$\xE0\xF4\xC2\xCC\xCC\xF1;\x1F\\&\xFE5\xF3w\xFE3\xC3\xFF\xB2:\xAE?\xD2\x9F\xB1\xA2\xC7s\x1E\xF1\x1Fy\x02\xFCU\xFF\xDCqQ#\xFE\x83U'X\xA9\xCE.TW\x94\xBFb\xF8\x97/\xD5\xF2\v^\xAE-_\xBBr\xDC\xF7e.:\xB6\"\xBD\x05YZ\x16\xD5\xE3\xD3g\xAC\xE60\xFF\x1EY/5\t\x8DO\v\x05Z\xB1\xF8y\xC3?\xD9e\xC2\xF0\x0F\x12\x02O@\xA4PY0\x9D\x03-\xFF\x80\x9E\x80\xC0{mZh+\xA2a\t\xE9\xAF(_@@\x0F\xE2\xAAwJ\xD4fWjG\xA1\xE2\xE1\xBC\xCAm\x18\xFEu\x99,\xCF\xF8U\xE9\xA3:\n\x81\x96h\x8Cf\xE2\xCCt\x12y\x80\x8A\xE6\xBFU\xAF\xC6\xFA\x1F\x00'\xC7\xF1O\r\xF6\xFE\xF9\xB7\xDA\x8B3j\xE1x\x04\xE8\x97\xAC^y\xC6\x9F\x99\x99>\x8E\x9Di\xA9\x96\x05\x04b\xFA\tK\xFA\xD8\x9D<5\xFF!\xFD\x91\xC1,I\x14\xA0R\x80\xBE\x843\xAB\xC1\xDF\xFD\xED\x0F\xD4f\x97\xBE\xA8z\xA7\xA4wJ\xCC\xCC,\xCCZ8m\xAD\xEA+\x1FT\x97j\xD5\xD7\xBC \x92\xB9c\x1F\xEAt?\nR\xE1\xAD\nJ\xF5\xBC\xA8\xFDYoQx\xC3\xD9\xEF}P\x1F\xEB\xD2j\x89\x98\xFF\xC6\x0F\xC1\x8Aw\xE6\xEE\xBD\x8E\xD252f^\x01V\n:\x13\xCA\xD2!\x90\xE0\xC5\xFC\xEB\x12\x02\xCB\xBAm\t\xE1/\xC8\x94\x7F\xA8)\\\xADV\xABUG\xB7t?\xA2\xA0\xA9\xC0\xD7\xFA'P\x96\x98\xF5W\xF5\x17]\xE8\x06\xF4])\xFFi}\xD4\x86\x19@\xD0\xC8M\xA7\xFC\x03\xB4r\xD68\xFE\x0F0\xE1_\xB4\x9F\x9C\xA9\xCD\xD2\x87L\x89\xA86\xEB/\b\xF0\xC1\x97\x9A\x7F\x19\xAC@\xA0\xF9\xF7\xB5\x16\xCA\xF0\x9F\x83\x8A\xE1\xBFv+X\xFCG?R\xA9\xBE\xF4\xCA\xC5i\xCD\xBF\x9CY\x98\x9D\x81F\x01\x9E\xD5W~\xF8\xA2\x9A\xAF\xAExASZK\xC7\xAD\xCA\x19\x90\xB0<[G9\xFD\x828\xEB\xE3\x94\x98\x12\xE3\xEC\x01\x19w7\x02\t\xAD\x9F\x87\x15/\xF0\xA5\x16\xFE\x94\x7F\xCF\x82ZQ\x93\xA5\xCF\x05\xF1o\xE9Gb\xFE\xC5\xCB\x1F\x172\xE5\xDF3_\x03\xB5\x85\xD5\xF2\x82\x04\xF8\x90\xAEMujY\x14\x04\x9E%f\x8FKmGX\x10X:\x9DHl\xE9\x1D\x11\xFF~\x00\xB1\xFD\xAF\xF9\xB7\x89\xFFQ\xFB\xFF`\xFCo|\xE4\x14N\x83W\x80\xD6\x8C\x88jU\x7FAK\x8C'\x84\xB7`\xF5Oj\xDA\xA3\xA3\x10H\xC3\xBF\xFC\xD8\x13]-Q\x8FX\x9DX\x16\xAF~\xEC'N\xCDZ+\x97\x9E:}lF\xF83\x86\x7F\x9D,]\xF9\xB8\xA7\x9E\x90\n\x03ay\x96U\xAE\xE2\xB4e\x95=\x9C./\xCB\xC7\x7F\xF8\xCB\x9E\x9C*\x8Dk\x8F\x94&\xD3+\xE4\xFA\xF7\xFE\xB5oY\xC2\xD7\xFC7J\xD0\x99\xB67/t\x1A%h\x14\xAC\xD5\n\xA2\xD2\x17\x1B%\x1D\xBFQ\x00m\xE8\xE8\xFC\xD8wKAP\x92\"\x98\x15\xC4\xBF~P\xF7.\xB4\xFD\x19\x88\\\xA7\x7F\n\xB5\xDE\xB1\xFB\xF7\xBA\xEAd\xA7!d\xF9G\xB4\xF1\xDF\xB0\xEC\xBB\x05\x9D\xB2\x1A\xEDE\x8BL\xC7<\xE5_\xFA\xB9\xE7I\xD5\xAC\xDC\xB7\xF9i5\xA9'\xD7\x98\xB6\xA6O}\xB3\xF2\xF8r\xE7\x11\xE8\xB9\xA0,\xD1x2\xD6\t\xE1\xA4\x85\xD3\xB0\xF9(.\xB9\xBA\r\xEB}\x10\xBA\xD4\xDC\xCC\xBB\xCB=[\x80\xF5\xCF?\x00\"\xFC\xA4\xEC>\xA2\xCD\x8C\x0E}/\xC4W\xA0a\xE3\xB4\r\xDAd,@g\x1E\xBA\x05\xE8y\x8D\xEE\x845\r\xB7>\xED\xAE\x96\xC6\xF8\x1C,\xA8h\xFE\xBB\xD3\xFA\x9F\x86]x\xE4\x9B\xE8\xCB\x1C\x869hh\xFD\x8F\x95\x1C\xCE\x17D'\xF8\x82\xFDg\xFA<\xCCA\xC5\xC2\xE9\x9Cn\t<\xE2*\x84\xA0B\xFC?\xFA\x8D\xCD\x93\xCFc%\x17\xEB\xF3\x12t,\x98\x87\x8F\x83M&+X}8\x85%Y\x99\x97r\xD2B\v`:\x87\xD3VezW\xC6l\x04\xBB;\xCE\xFF\xC3`0\x18\f\x06\xE3]\x8D@\x90\xD1bAP\xD4\x06\x97\x04\xE3s6=r\x1C\xE7\xE9\xC8\xF5\xD2\xD3\xA3btE\xF2IH\x1E\xC7c\x80\xBC!\xC5.\x98\x84`J\x07\xBF\x18\xF3?k\xF8\x17;\xF0/\x06\x8E\xC3Gs7GnN\xE5\xA6\xE3\xC7\xDF\xB7\xFC\xE7z\x17^l\xFA\xB2\xFFb\xAEw\xE1\xF9\xDE\x85\xD7\xBF\xFEKg\x9A\x9F\x7F}\xF3?<\xDF;.\xAF\x9D\x85\xE0\xA8\xD5=\xF9\xE2\xE6d\xAEwRK\xF2n\xFC\xCB\xE0\xCC\xAAw\xCA\xDD\xF8\xFC\x9F\\\xFB\x9C\xAD\x93\xFA\x9C\xF0~\xEA\xD6\xD7\x7F\xE7;\x9F\xFC\xD4\xAD\xAF\x1F\x15\xED\xBF\xB1\xEC\xFF\xC07f\xCFt\x82\xE3\x10\x1C\x97\xDE\x14\xC0I|\x7F\xF3\x0F\x9E\xC2\xA6/}\x14P\x05O\x06\xD7\x9C\xA0\xE9\xE8>\xA3\x17\xF3/<iy\x00\x9E\xAF\xB9\n\xA6`\xE9\x83\xE0\x17\xAD\xCEOn\xC3\x7FUz\xA7D\xCD\x11\xD7\x8A\x80\x8B\xD5\xE6\xD9\\\xAFVm][\xAC\x9D\x95\xADGs7\xBDe\x7F\xCA\x9A=\x05\xC1\xE3\xCB\xBD\xCF\x14\xBC\v_\xBC\xFB~\x97\xFF\x84\xFF\xAF\xBC\x06\xD5\\\xEF\xB93\xD7>\xFFz\xF3\xF3\xAF\xB7\xEF\xBD\xE1\x9D\xB4\xBF\xFE\xB9\x84\xFF\x93\xE8\x9D\xB4|gH\xFE\x03oe\xD6[\xF6\xEFu5\x81\xF7\xFEt3\xE5\x7F\xE1\xE5\xDA/M\xBE\xF9K/\xAE\xFD\xD4\xAD\xE6\"\xE2\xD2\x99\xD6\x9B\x9F\xAC}\xCE\xFE\xBA\x84\x80\xF8\xFF\xE8)h-.\xA8\x8B\xC5\xB2\xCAMO\x8A\xDAO\xBFV\xBB\xFB\xC5\xEF\xDF\x1B\x1E\xF6z?\xF1\xDF\xF6\xA5\xFF\x82\x80\xAA\x80\xA0:\xBBP-/\xC8\xF2\xCA\x8A\x96\xFFEl\x9DX\xF1\x1C\xD1\x96\xB9\x9Eo\xF9G\xB5\xF0\x07SV\xF7'c\xFE?\xEA-\xFB\xD2\xBD\xF3\xD7\x9F\xBAs| \xFF\xE5\x85\xE8\xDC\x82\xBA\xB6\xB0:\xBBXm/.wk\xD5\xD6\x8D\xC5\xF6\xE2jk\x12\xBA\xE5\x95\xD6\tqma\xD9[\\P\x97.\x96?(\xAF\x1D\x15O>\xBDP+\xBFpl\x16\x03\xEF\xFD\xCB\x7F=Z\x19\xE2\x7Fu\x81\xF8_\xF6N\xACxGE\xDB\x01\x8F\xF8\xCF\xEA\x9F\xC0{C\xCB\xBF\xB4\xD4\xCC)\x95\xE5\xBFZ;\xB7\xA0nT\xAB\x9A\xFF'\x17\xBC\x94\xFF\xA3\x96\x17\xF3\xBF\xA2\x88\xFF\xEAq\xCD\x7F\xED\xE9\x85\xDA\x87_\xF8\xEC,\xC2\xFB\x95\xFF['\xED\xE8\xFF\xA6\xF6\xF7\xB93\x9B\x17^\xBFu\x81\xDA\xDF\x93\xF6\xD7\x9F[P\xD5S]\x7F\xB5\xFA8z'\xED\xFE\x90\xFD\xE3nj\xFD\xF3\xC5Mi\xCD\xFF8\xF1\x7F\x17\x03\xB0\xFB\x17^\xBCu\xE1O\xCE}\xFEO\xFE\xFC\xC2\xEBk\x9F\x7F\xFD\xD6\x85\xD7\xBC\xA53_\xFF\xABO}\xF0\xB93_?jy\xD5\xD5\xE7\xCE\xDCz\xEE\xB9'\xFA\x8F/\xF7>\xFB\xF1\xE7\x8E\xE7\xA6'\xDD\xCD{\x7F\xDA'\xF9g\xFBsw\xFB?k\xFF\xDC\xFD\xE2\xB5\xBB\bC\xF2\xBF\x15V7c\xBEvGn\xD2\xC0\x8An>\x8C\xFC3\xFF\xFB\xE2\xDF\xD8?\xD2Rb\x07\xFEw\x87\xE6\x9F\xE5\xFFA\xF5\x7F\xF7\xC0?\xF7\x7F\x19\f\x06\x83\xC1`\xEC\x05\xFE\x8A\xDAk\xD8\xD9\xA8\x10\x99\b\xE2\xE0\xEB&\x1E\xB5z{\f\xD4)\xE8\x1D\xEC-\x93\xD0\xA5\xF0\x10\x18\x824\x99rOag\xAB0\x7F\xAE6X\xECp\xEDm\x90\x87\xFB)\xE8\xC7\x9F\x9F\xD6\x01\x1F6\xFE\xDF4\xC7\x9F9}\xECgN\x7F\xFFgN\x9F;[\xBD\xF23\xA7\xAF\xFC\xCC\x99\xEF\x9F:}\xE5\xE7v\xE6\xBF\xF8\xF4\x1F\xA5\xFB\x14\xAB\x1B\x0F6?\xA7u~\xA8\xA0\xE5\xC1\xDER\xADV\x83\xEAj\xED!\xD87\xFC+s\xE2+so}enj\xB5\xFC\xC6W\xCAt^\x16/\xCCM\xBDR~\xFA\xD5\xB9\xA7/\xCE=}\xB1<\xF5\xC2\x89\xA9?*O]\xDAy\x97[\xF7n\x94F(\xCE<\xD8\xFC\xCC\xE9\xFCPA_> \xFFg6/\xBC\xBE9\xB4\x1A\xE2\x1D\xC2\xF2\x9Ch\x96\xA7^\x99\x9BZ\xD5\xE1\xAD\xE59q\xE9\xC3\x7F\xAD\xBFw\xEE{\xAF\xCE}O\x7F\xEF\x87\xBF\xF7\x9B\x1F\xFE\xDE\xAB\x1F\xFE\xDE+\xFE.\xF2\xFF\xC5\x01\xFF\x7F\xFD`\xF33\xA7\xF3C\xFC\xB7\x0E\xF6\x96\x17O,\xAE\x96W\"\xFF\xE1\xE0\x7F\xEE\xADW\xE6\xDE\xD2\xDF[^\xF8\xCA\xDC[\x97\xCAW_\xB8\xFE\x81W\xAE\x7F\xE0\xD5\xEB\xFF\xB9\x0E\xED/\xBDp\xE3\x03\xAF^\xFF\x12\xEE\x9C\xDB\x89/\xFCF\x1Aab\xE6\xC1\xE6G\x9F\x7F\x89\xDA\xD1?9\xD8[VO,\xFEr\xF9\xAD\xAF<,\xFC\x8BW\xE6\xA6.\xCDM]*_\xD5\xF267uQ\xCB\xDB\xD4\xABsOS\xB8|\xF1\xC4\xD4\xAB'2\xEA},\x8E\\\xFE\xFD\xF4s\x8E\xCC<\xD8\xFC\xCC\xE9\xFCP\xF4\xAB\x07\xE4_\xD7\xA9\x99\xEB\x0F\x05\xFFo\x91\xBE}\xEB\x95\xF2\x1B\xAF\xCCM\xD1\xBF\xBA\xB2\xFF&\x85\xDF._\xFE\xED\x13O\xBF\xF2\xE1\xEF\xFD\xD1\xDC\xE5\xD5]\xF4\xCF\xDF\xBEx\x18\xFA\x7FO\xF9\x99\xD3\xF9\xB9\x1F\xFD\x7F\xE1V\xB5\xFA\xF1\xD9\xB3\xC1\xC3i\x7F\xBEy\xAAzlk\xD8e\xFDQ\xF1\xEF}\xF10\xF8\xDF{~\xEE\xC7\xFE\t\xAA\xD5ju\xF3S\xC1\xBB\xC9\xFE\xDF\x85\xFF\xFC\xB1\x818\xE5\x8F\xB1\xFD\xCF\xFD\xDFwE\xFF\x97\xC1`0\x18\f\xC6;\x03w\xD8\x0F\x95\xB1\xA9\x8DE\xFFw\x87\xEF/H}\xF9\x9C\x896\xBA\xA3\r$+V\x83\xB1f\xC7[A\xB2\xEBM1}\xFB\xC1\xAC@\xE7\xBF\x160\x8F`\x81\x07\xA8\x02\x93FY\xD8\x9D\xE7\xCCD\xA1\x9Aj],\xD4\xFF_P\x80Q\xB0\x9C\xF9\xB6\xA0\x84\x81\xA4]g<q\x06^R\xEB\xBF\x00b\xFDWb\x83M\x06U\xE1WWkW\xF3\xC19\xD1:\xF1B\xED\xC6\xF3\xD1\x97\xC1\xD6=\xBDZ\x01&~9\xDD\x8D\xC9\vh\xE9h\xF6C\x1BN\xEB\xC0\x9D\x80\xE1\xE2\xF8\xC3\xF4\xB4O\xC7\xA5\xE1\xD8\xFF\xE9o^\xCE\xF0_\x1FI\xEB\xE7\xCD\xDC\xA8\xC2\xB8\xCCX(\x02\x887\xC1)\x9E\x88/\x1E\xCCY\xED\xFE\xE1\t\xF1\x85\x7F\xB7\x85\x7F\t\x01m\xD7D\xFC\x17\xEB\x8F\xC11+\xB8rj!~\bA@k\n[\x02|\x89\xBE'\xAE\xE1%\xD5~\x15\xC4\xB7_Z\xDB\x8E\xFF\xD5\xDAU\xCA\xB0\xFAj\x11\x9C\xB3fk\xAEkc\xF9o\x1E\x98\xFF\x91]\x05\xE4\xD5\x11\xF9\xFF\x95\xE1\xE9f\xB5\xD9\x15\xB3\x8C|\xAC\xFC\xFF\x9A\xB9P\xDC^\xFEs\x1F;\x04\xFEE\xF9\xCF\xDFP7v\xE4\xFF_\x8E\xE5_3\x1F\xCB\xBF\x9C\xC5KG4\xFF_\xBA\xD8\x1E\xE2\xFF\x13\t\xFF\x9F\xB8\xB1\xFA\x89\xB7\x81\xFF\x8F\xED\xCC\xBF\xF2G\xBB\xCC\xBAR\xD8\xF4\xCD\xF2\xB7F\x12\x8B\x9D\xBA\xEA\xB7\xC6\xCA\xBF\xCE-\xAD\xC7\x06+]\x88\x7F\xA05\xDE\xCE\x8D\xDF\xFF\xFD\xE8\x7F\xF0\xE1\x8D\x97\xCB\x8F}\"\xEEz\xFF\xC2\x89\xEF\xBD9\x19<&\xBE\f\xE7\v?\xF5\x9D\xDF\xFB\x97w~\xF6\xB17\xCE\xFD/O\\9{\xE6\xFC\xBFY\xF9\x9A\xE6\xFF\xC8\xB9\x7F\x1C\xA8\xDF\xFC\xC4\xD3\xFF\xF8\xC7o\xFD\xE6\x8F=\xF2\xBF\xDEZ\xFB\xDD_\xFD\xEA\v\xDF\xF9\xE3\x1B\x97~\xEF3/N\xCF\xFE\xCF\xD3\xBF\xA8S+_\xFE\xD5+\xFF\xC7'\xCF\x9D\xF8\xEFN\xBC\xFA\x89\x1BW>q\xF5\x17V\xBF\f\x85\xF9+\xAA\xF2\xB7k\xD5\xCF @\xBE\f\xF2\xE6'4o\x11\x00\xFCo\x01\xFC\x1B\x04\xC8\xFD\xB3\xEA\xE2\xCD\x83\xF2?\xE2\xC9\x19\xE8\x9FM:z\xC3\xFC\xFF\x9D\xE7o\x0E\xE4_\x8Djo\x19\xEC\xA4\xFF\xFF\n\x01&\xE9V!\xD9\x1B\xC9~\xE4`\xFC\xFF\x8FW\xCB\xFF\xDE\x87\xCB\x17\xCB\x8F-^y\x8A\x92\xFC\x8D\x1F;\xF1\xEB\x17\x97\x1E{\xED\xDA_]\x9C^Z|\xE3\xF7?\xFC\x8B\x1F\x9A9w\xBDz\xE5\xA9\x85s\xAF.\xDC\xF8\x0F\xAF\x7F\xF4\xD7\xBE\xF3{_\xFA\xCB\xFF\xFD\xC6\x9F\x7F\xF5K\xDF.\xDF\xF8\xCE\x1F\xFC\xDE\xB3\xD7n,\xDE\xF8\x17?v\xE27/\xDE^\xAC^{\xEC\xC4\xB5E\x9DZ\xFB\xEA\xA5+\xAF\x9E=w\xE2\xC6\x8D\xDFY\xBCqm\xF1\xEA\xABgf?\xF3\xED\xDA\xAB\xB5\xDAO\xFDJu1 \xFE\xF3\xDE\"\x02\b\xAD{\xAF\x07\xF0\xAAV\xAA\xCF\xCC.\x1Et\xD4u{'\x96Ys\xF5g\xE3\xC6\x89\x16V\xC7?rj\x87\xE6\xD4\xBAzh6\x83\xF3\xB57\xAE\xFE\xF8\xEFv\xE1\xF2\xC5\xF9\xB3\x8BW~\x9E\xF8\x7F\xF1\xC7>p\xA5\x18\x9C\xCD\xCF\xDEX\x9C\xAD\xBDt\xED\xFA\xD9s\x8FU\xD7\xAE\xAF\xAE\xFD\xFC\xCA\xB9WO\x9F\xB8\xD1\xBEq\xF5F\xFB\xD2E\xFF;\x97\xE2\xE3u\xFB\x91\xFF\xE9;\xFF\xFD?;\xFF\xE7\xD0y\xF6\xACl\xD6.5\x17/\x96\xCF.\xB6_#\xFE\x9F\xBEq\xE3[\x8B7^\xBBt\xE5\x9FV\xAF]*\xD7\xFEE\xBB\xB6x\xB6|\xB6\x03P\xA8@\xC1\xF0\xEF\x0F\xF8\xCFyS\x97\x0E\xCA\xFF\xC8&\x1B\x99M\xE2~\xA0\v[\x7F^sI\x1A\xFEis)ye$\xB1\xD0\b~i\xECfq3\xD7\xB5\xA8\xD0-U\xDB\xB5\xF4w\xAC\xB3\x1F\xF9\xC3\xDF)\xDF\x04\xF8\xF5oW\x7F\xEA;\x7F\xF8\x0F)\x9F\x17\x7F\xEC\x84\xE1\xFF\xFAK\xD3gK\x86\xFF\xE6u\xD9\xFCya\xF8?\xF1Z\x86\xFF\x1B\x97\xAE\xB5Wg\xBF\xBDx\xE3\xCA\xF5\x13nn\xA5\xB6\x1A\xD5\x16\xA3\xB3E\xAFv\xA9\xF9\r'\xBA|\xB1\xFC\xD4\xE2\x95\xD7.\xE9\xF0j\xF5\xDA\x8A\xAA\xFD\xBD\xEB\x9A\xFFX\xFE\xB7\xF2\x0F\xCD\xCB/\xCC\x1E\x90\xFF\xFC\xB6\xFC\xD3\x1BF\xF9\xF7\xA4i\xB4i\x04\xD6=7\x92\xD8+\xB1\xE2\x19\xFB\xA3\xB53\xCB\x87\xC5\xBF\xFB\xFD\xDF\xFD\x9D\xF2\xBF\xED\xC2\x9Bg\xAB\xFF\xD5\x89\xABOS\x16\x7F\xE3\xC3'\xDE,\x06\xFF\xB4\xF0\xE5\x1B\x8E\xBF\xE8\xB4\xAF_|\xE6\xB1\x17\xAF\\\xAF~\xED\xE9\x95s\xAF~\xFC\xC6\x8D\xF6\x89\xAB7\xDA_\xD2\xCC\xEB\xE3\x97.\xFD\xC1\x8D\xEA\xEC\xF5\x9A\xE6\xBF\xF7\xFF\xB1\xF7\xF7\xD1q\\\xE7\x99 \xFEt\xE16\xBB\xBA\x01\xA1\v=\xB2\x07\xCE\xD1O\xBCh6E\x10V\fI#\xFF\x96\x93\xD5\x12\x85VQl\xB48j\n\x86l\xC5\xEB\x11aYq\x14ON\xECx\x93\x1D\x7F\xD0@\xB1\xD5\xA4A\xD8+\x82=p\xA4\xC9\xC9\x88M\x18\xB4\xC9\x96\x86\x9C\xF88;^\x8D,\xB6h\xD8\xA24>\x96\xA3\xE3\xC9\xCE\xC9\xD9\xB5K\x10d\x91\xB0\x96\xA4x\xE8\x04\xA2Z\x85=\xF7\xA3\xBE\x1A\rJ\x9E\xCC\xD9\x7Fr\x9F\x03\x82\x8D\xEA\xAA[\xF7>\xF5\xD4{\xDF\xFB\xDE\xAF\x1F\xDF\xFEyk\xFEO\x07\xE6\xFF8i\xFC\xC9\xF4\xCCQ}j\xF1`\xFF\x1F\x14g\xE7\xA6\xD8\xCF7\xAC\xBF('\v71\xFE\r\xCF\xFE\\\x1F\xB6?\xAF\xB1B\xED>\x1C\xFFo\xE6?J0y\xB6\x85\xFFB\xF4\xF4&\xAFy\xB5\x1A\xAF6\xE2\xEFoI\xEC^\xA9\xFF\xB6f({\xCA\x04\x12\xFC\xD1\xA4\xBDT\x13\xFFM\xFE\xBF6V?\xD6\xFFA\x8A\xCA\x88U\x1E\x98+\xF2|~\xBA\xFE7\x95\xA4\xB9O\xCF\x9Dx\xE1\x86\xBB_<y\xF0\xF5\x076\x9F{\xB8\xFE\xC8\xD9]\xF9\xB1o\x14\x98\xFD\xA9\xD6\x8F\x7F\x861\xCF~OO?u\xA2\xF2[\xC7\xCF~\xEBO\x1E\xFE\x9B\x98\xFD\xE9\xE1\xCA\xE3\xF6\x8B\x8F\x0F'\r{z\xE6\xB0>U>\xD8\xBF\xAF8[\x9D\x9A\xFD\xB3\xB3\xFF\xFB\xC3[\xC8\xF4M\xDB6\x7F\xFA\xF6\xFF\xF1\x801R\x13\xFE\xCF\x14\xE7\x9F\xD5\xBF'M\xEErt\xCC|2\xBE\xED\xBF\x0F\xFFh\xD5\xBF\xD5V\xFF5\xFE\x1Fi\r\xF5\x0F\x9A\xEDl\x9A\xF7h\xD9\xDBA\xB8\xE7\xA9\x17\xFFa\xF6\xE7\xE9\xE5\xE3\xC7\x7F\x9B\xB6\x0E6g\x7F\xEA\xBD\xF5~\xAF\xA2\xF1\x03\xE1:\xEA\xDF\x1E\x98\xAE\x01\xC9v\xDDx\xA6\xC1\x17\xA8\x83\xE9\xA5\x16M\x96\xFCq\x03\x9Bk\xDEN\xF8kF7\xFDC\xBB\x11\x92\xD1\xFA\xB5#\xF4\xD1\t\xBC \x1F\xE3\x82\xF8\x06o\x96%\x1EjI\xEC\xB9q\xE9\xEA\xB4C\xEF\xE1q\x80\xF0\x85\x7F\xF4]\xFF0\xFE\xA7\x7F\xE7\x9C;\xE2\xACS\xA15~3\x9F*f\x8F\xFF\xA6\x8DT\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x05\x85\xFF\xEF\x10\x93\xFFk\x00\xE1\x1F\x8C\xD0\x97d\x9D\x8B\f\x9B\xFD\xEEf\xBFLq\xC0?\x93_n\xF7\xB4\xBB\x05;Y[/\x1F\xB6\xC9\x93\xD2\xDEs\xC6\xD7\x9EIdf\xFC\xFB\xFAE\xA1~\x06\b?\x8D\xC8\xA2\x99\xE1\xCFm\xCAk\xCB\xBB\xC4\x82\x14\"4h\xD0a\x1A\xD1\x83\xF4Z4\xDB\xD1\xA3iW~\x91v\x19\xFFi\x17i\xD7\x00V__\x010t\xC8\xCDU\xAC\xD8!W\x9C;d\xF3\xF39t\x9ENO\xC0\xFFL\xC0\x7FG\x130{\xFC\x9C|u\xA5\x85\xFF\x8E\xC6\x1D\xF2\xAF\x84;\xF9|s\xF2\xF9\x950\xFF\xD9\x16\x8A\xE5\x1D\x7F\x8A\xF4q\xC6O%(l\x16\x18\x02\\\x96\x13s\xB5\x81\xC9}+\x82\xFF\xC9\x06\x86\xBE\xDA\\u0\xF9\x1C;y\xF5\xA2\v\xED\xA6U\x87\x7Fxo\xFC\xFBe\xA1ev\x97I\x07=\x1A+K\x1A\x0E:V\xFA4\xC9\xF0\x96E#\xAB\xE94/\xB2\xE4\f.r=j\xB9\xB4\x16z\x8C\x9A;\xE8`\x13\xD0\xC7\xFF\xCA\x95\xB7\xF1\x83]\xC1\xC3\xF2\x1E\x8C\x96h\xF2\xFC\x1B\x1B\x1B \x98b\xDF\xD9F\xAEbm\xF7D\x15\v\xD8\x96\x17Q\xDB;\xA2W'\x1B\xBE&\x88\xF7h(?g\n\xB1\x95\x80\xFF\x0Ewo\xC2;\x95P^|]d`rqW+\xFF\xE9\x9F{\xF20\xA0\xF532\x17\xC7\xFC/\xDFv\x90\x07\xE6E\x1El\xC44\x833\xCC\xD8\xD3\xF9o\"\xF5o\xA3\xF3{) \x05\x9B\xC0\x14\x0F\x82\x00\xAB\x0E{\xB8\xAB\x17]v\xC4\x91\x0F\x9A}\x88\xF0\xEFfy\t\x05\xFF\xC6>\x03Z\xC1\xE7\x9Ff\x8D\x813\x1E\xFF1#\x9B\xBD\xC4\xB9\xCD\x1Ae+\xC4\x7F\xB6\x1F\xB8\xD9\xF1\xF9\xE7_i\x97B\xFCw\x8BL\xAE:\xE2\xFD\xA5\x06|\xFEi\xAEbQ\x8Fs-\xC4\xFF$\xCF\xA7ez\xFA\xD4\xAB\x96\xF7\xEA\xAFj\x16+\x97\x13\xE6_\xF7\x04\xDF\x84f\x06V\"\xE1\xAE\xBE\xDE\\ux\xFE\xD3\x97L\xEDO\xD6\xE8\x7F\x14\xECm\x024\x03\xC9\x02\xBBc\xA1\x1A\xD6\xFF\xAA\x8D*\xE7?\x06h\x84\xE6\xCA\x85\xC9\x86\xE4_\x17\xAF3{mm\xA4(\xE3?&\x8F\xF4\xC4\xF4U\x87+$f@\xD3\xA9\x1D\x18\xAB{\xCD\b\xFFf\x05%\x07\xC3@_\x9Ce\x83\xE6u\x90B\x1F\x91\xFC\x9B\x96q\xB7\xE5\x96\x96x\xFE5=\x9F3\x84\xA8h>\xC4?\x99+\x00#\x14{8c;\x97\xCA\xFC`\xC80\xC6.I\xFD\x03\x89\x86\tn\xCEv6\xA6x\xCE\xCD\xD5%\x8Bz6\xE7\xD74\xB0?I\xFE\xBBB\x01=\xDF\xC2\x7F\x8F\x96\v\xDB\x9F\x1ELA\xD3\x03\vML\xCB4\x03\xFDk\x85\xF7I\x839s\xE4\x91\x05\x00\xF5\x88A\x1FE7\x91\xFC\x13\xC6\xFF\xE4\x0Fo\xF7\xBFl\x02\x05\x1B{9\xFF\xCCx&\x9A\xEF\xD3\n\x82\xBDU\x07i[\xEA\x9F\xDA+He'\x1B\xF8\xF2s?'\x9AP\xB5\x91\x84\xE4\x7F\xE8\x91\x15js\xD3\xCAy\xD8\x13\xE5\xBFt\x05y\xCA\xF9'9\xF6\xED\xB1\xEB#\xFCW\xDC{,\xDD\xB4\xB8$\b)\n\xFE\xE3\xEE\xE4\\.T\x84\x07K\r\xC6\xFF\xBD\xFC\xA2\xC2~\xB4\xF2\x9F\x96\xA5\xE1\xF5\xEF\xE7\x80\x9Fn\xB4aI\xFD\x9F\xCD\x1Dr\x87\xCE\xE6\xC5\x19\xEF3=\xB6=\xFEY>=\xFE\x85\xFD\xE9e\xFC\x13\xC0\xFC@\xC0\xFF\xA3\x8C=\t\x1Ddo\xEEP\xD3\xD7\xFF\xFB\x06\xDD_\x8F\xCB\x1A\xC4~\xD4j\xE5?\xF9\x84\xD4\x7F\xFA\xA7\\\xD1\xB0L\xFFQ\xE2k\x0E3\xF5\xBC&29\xE7\xD6\xE4\xF3M\x91+#\xED\x1A6\x86\xF6\xB1\xFB\x0E\xED+\xA0s\xB1h\xC2,\xE5\x89\x86\x8D\x809L\x93`\x1F\xD0!\xC9\xA7^\xB5(\xA4\x91\xF2n\xD1\xF8:\xCEp\xFE?\xF9cF\xA9\x9D\xCC\xA0\xEB\x9E\xBE.\xEA}k\xFC\xED.\xBD\xB1\x8B\xF3\xAFk?\xBA\x99\x17\xB3\xCB\xB0\xB5\x10\xFF]\xD9\xB3&^\xA0\xF8k~\xD1\xD9\xAF[\xE2\x1Ci+\x1C\xDF\xFEW2\x1D+\x04\xBB\xD0Q\x80\r\x8B\xEB\x9C>b\xE5*V\x9F\xC7y\xCE\x06RE\xF1y\x84\xB6\xF2/4\xB3\x01\xB8\x97]k\xBE\xCF\xE3?\x15\xD3B.\x95\x01\xDD7\xF8L\xFF\xBF\xCE\x17\xDEg\x8B\xC2\xCFthk\xF8\x0F\f\x91\x81\x04\x93\xC4\xE4\xC2\xE7\xFCc+&\n\xA6\xAC\x7F\x99\xB5/\xB9\xC4\xB4\x84\r7bL\xDE:\xE7\x9F\xEE\xEBG\xF7v\xC6\xFF\xC8\xE8\xEA\";\xDE\x83\x85\x11\xF9\n\x1A\xF4\x90\x1Bv-\x84\x8AR!\xFB#\xF4\x7F\xF4\xF6\x9C\xB4Q$?Z\x91\x17\x97\x96\x8C\xA2U\xB0\x84\xFE;V\xF2\x9B]\xA9\xEDp\xFDKn+\x9A\x81\xFE\xCD\x8A%\xDE\x91\xD6\xFA7FR\xC2\x7F\xEB\xB2\x98\xE7\xF0\nW\xCE\xD7\xF3\x9C\xFF9q*\xB30\x1E\xFF[\xFD\xF7TX\xA4\xF4\x13\xA2\xE6\x8A\x01\xB7j\x04\x89fO\x84\x7F\xCF%\xD3(tS\x1A|\x9E\x8D\xF7\x95\v\x1F\x165\x13f\xBA\xB4]\xAD\xFCw\\BzE\xF2\xCF_I\xEB\xEE\xA6\xFF\xE5\x94\x8D\xD5\x06\xE6|\xFEm\xCB\xAF\x7F7>\xA7\xF7\x01:\xE7\x96\x96g\x00\x14M|\xF9\x851h\x8C\xFFTB\x1F1EUK\x87\xA6\xB4U\x87\xEB_\xCFz\x1E\x05zB\xFC[!\xFB3\xF4\x9C\xE0\xDF\xF2\xBE5\x8A\v\xFDy\xC1?\xCC\x1D\xD2\xFE\x1B\x93g\xF4\x10\xFF\xC5\x113\xB0\xFF{\x96\xAC5\xF6_\xF2O\xA4\xFF\x9C\x87\r\xBBOXNsK\xC5\xEAKf\xE0[{\x8F\xFF\xC0\xFEx\xFEO\x85\xFA\xF6\x9F\xD9\x1F^:\xEE\xD1i\x1A\xB0\xDB\xE3\xDF\x04&\x88\xE7? \x9E}_\xA2\xF9\xB3E\"\xA4uK\x96\x9D_\x8F\xB8\xCF\x06p\x8B\xB4?\xBC\x12\xDF\xC8,\x9C\xC4[\xC0TX\xFF\x89\xA6\xD0?\xE1\x15\xE5v\xC0(s\x15\x95w\xA3ce\xB2\x81Tz\x97\xE0\x9F\xC08H\xB9;\x91vI\xE7\xD5*\xE5\xFA\xEFl\xC8\x17a\r\xFFy\x1B}\x84\xF3\x967@\xCAcV\x88\x7F\xD2k\xB6\xF2\xAF\x93;\xA7B\xFC\xDF\xB5\xDBf\xFC\x0F#\xA4\xFF\b\xFF\xA2\x82\xF3\xF4\xCF}9\x9F\x7FJ\xAC\xBE\x94|\x1Do\x00\xD0y\xB5=\xFF\x98\x11\xFAg\xAFF\x96\xF1\xDF\xE7}\x95b\xFC{\xF9\x89\xDB\x8C+\xCD\xAB\x7F\x93\xD9\x0F\xD3\x9Fv\x13\xC1\x7F\xC6\xCC\xE6\xD7\xF0\xEF\x00\xDC\"\xE8\xA3H/\xB3\x17\x02N\xE0\xFFP\xA6\xFFz-hU\xF9\xF6\x1Fy]\xF3\xF8\x97\xAF!\xFB\xF9<\xE3\x9F\"\x85\xF1\xC3Tf\xDE2\xCD\x8C,\xC8^_\xFFAuPA\x81\xA2\x1C\xE5\xBFbU\x02\xFEs\xBA\xCF\x7F\xC1\xE7\x7F\xD7\xF5!\xFE\xCB\xBBm\xDC\xFD\xEE\xFC\xEB\xB7\xDA\x92\x7F\xF6B\f\v\xFE\xC1\xF8\xD7C\rM\xEFs+\xFF\xB1\xA0\xFD\xBB#\xC7\xF8g\xB7\x8B\xB1b\xDCZ!\xE8\xF0\xBE\xD4\xC7\x19Wq\xAFx\xC9\x9B~\xF6j\xE1\xC3\x15\x91\x81\x8C\x99e\x89_\xA5\xD1Fc\x87&\xF9\x8F1\x19\xDC\xD0\x11|\xD9\xA4\x98\xA2\xA8\xD6\xC2\xADZ\x93{\xD1@\xE5vV\vWZ\xF8g\xAD\xD9>\x8A[\xF7=\xDE\xE3e\xBEB\xCD,\xE5\xA65q\xC6g\xDEw\xD0\xCC\x8A[0Q1\xD1G\x98\xDF\x18\xAB\x18\x88\x93\xA9\xDC\xB4\xCF\x7F!w{\xC0\xBF%\xF8'q\xFB\xC1\x10\xFF\x95;M\xFC\xCBq\x9F\xFFJ\x84\xFF\x98\xC3\xFD8\x00\x9Fk|\xD6]u\x18\xFF\xDD@\x07\xB7\x9C\xAB\x17\xDD\xA1\xE7\x9B\xAB\xE76x\x955\xA0o\b\xFB\xFF\x01\xFF\x1B\x02\xFE\xED\xA5\x1B\x90v\x87Ee\f4\x1E\xDA\x86.\xEF\t\xEA7\x02\xE6\r\xFA\x84\xFF\xF4I\xD7]\v\x9F\xE2\x16\xBE\xAB{\xE89W\xE6(\xB0\xFF.\x12\xA2~\xF9\t:X;e\xF2y\xBF\xE6\xC2&\x07\t\x07'\x1D\xA0\xA3q\x03pC\xACqC\xAC!\xDE\xD3Db\x81\xB5\xAA\x96\xBC\xF6/o\x8F\xB0\x0F1\xB7\xE1\xA0\xF1G\x1B>%^g~\xC9\x0F\x1C|\x9D=\xA2\t\xBF\xFDe\xD3@\xFF\xC36z)\xFA\x12\xAC\b\xDD\xC4@\xBCw*wY|{g\xC5--\x9D\x19^pE\xD3f\xB8\"\xF9'\xB1r\x88\xFF\xDE]\\\xFCQ\xFE]\x15\xF7RPPPP\x88D\xEE\x99\xD3ah0\xDE5\xD8\x1E\xBE0\x16\n\x8A\xC6\xD06\xD2\x1Dj\x02\x83\xF2\xF4\r\xFFx\f\xFD\xAD\xA1\xFB\b,\xEF\xCC\x8A\x97\xAA\xB8\xA3\x11\xEE\xA7\x88\x05\xE9\x1B\xE1\xAFx\xCE\v\xDE\x8D\xDA\x14\x99\xBC+1\xF6{!!\x88\xFC\xEB\xB6\x11\xED\x95\xA02\xF6\xC2{Ib\x11\xA2\x9Cp\x1B\x7Fp\x11\xD0\xDC>\xED\xFAl>\x92B7\x90\xD5\xF6\xAE\xDF\x11b\x88&l\x1F\xB0\xC9f\xBF\x07\x1D\xF4\xE7\xFDL\xBB2T\xEE\x9DL\x1F4\xB2\x9A\xC1\x9A\xB4\x9A\xCB\x1B\xB6\xCEV\xAD?\xA7\x99\x83\x8D\x96\x1E\v\xAF\xA9\xAB\xE5\x06\x1D\xDE\x04\xD6,\xE1\x1F\xFESmw\x1F\xF0O\xCA\x06\xB4\xDD\xD0\xDC\x7F\xCA}\xCE>\xA0\xA7\xE32?m\xC6\x8F8m\x14\x01U\xAD \x8E\xF4inkXCss\x9A\x7F\xA3\xE6`\xD8\xFB\xE2'\x0F.\xBA7\xD5\xE4\x9F\xBC\x81\xC8\xFC\xAEM\xD9&b{y\xAE\xAC-\x0E\x06\x17\xBF\xC0\xCB\xD2\xDF\xA3M\xB0\x04\xCB\x11\xF6r\x1A\x85\xD6\x84\xD6\x0F\xCD\xC8\xF1@t\x9F\x17\xBF\r\xF5\x10q\xE67\xAD@3\x86\x163\xD9l$\x85\x1E`\xF0\xCC5:\xA2\xA8Hp+E\xCEd\xE4S\x8A\xFE\xFC\xA3\xDE\xB7\xCC=\xCEe]\x9F\xFF\xC12\x86\x169\xF3\x1Aa\xD9\x8E\x19[;\xDC-\x8B\x13\xAD\xFDF~\xABA\x84\x88Y\x01u\xC1O\x8F6:\xE8\xC0(\xBB\x9C\xFFr\x86\xFB\x8D\x9B\x1C\xF4d\xA7\xF9i3\xF0x\xA66\x86\x1C\xCE\x7F\x87 \xB3?z\v\x17Zy\xCB\xA2\x7F#\xD2O\xA3O\x87\t\xAF\xBCM\xF2o\xE4L\xD9\xEE\xBBcNg/-\x05\xB4r\x8E59\xA7\xA0\x95\xA1Y\x1B\x99\x80\xCB-Oy\xCB\xAB.\xB4\n:.\xA0\xC3\xDDB\x19?C\xBC\x14\xFC\xF1\x85#\x15\x18\xCE\xCD\x80\x18\xC3\xC4\xC8\xC7#)P\x1B\xE1\x90\xF6\x9An?\xB7\xC4\x13\xDCa\xB2\xD6\xE2\b\x85IQ\xDC\xB1\xEC}\xCB\xF8\xB7re\x11\x00A\xDC-\xECw-\xE6H\xBB \x04\xA4\fM/-\r\xEC \xE5V\x03\x14\xBF\xE2\xA7?,\xDA,q\xD7\xE4\xFA\xCF\xEE\x1F3\x81\x9Ce\x80\xEC\x05)gY\xCB\x11\xBB(\xB6\xE6\xA6\xD9i\xC4\x85\x17\"\x9El`7\xE5\xF1.~d\x98D\xF9'6H\xB9@<\xFEI\xB3@#\xE5b9\xB7\xCA\x05[~+\x8A\xC0\xDAk\xF3\x06\xB41Vj\x82\x11\x13\xA5\xD7X\xBB\x18q\xB7\x87\xDD\xBA\xBCg!\xA2\xDE\xC2\x8E\x1CH\x13\xA4\x1F\xC4\xB0(\xF2\"\x92&b\x98$\xDCS\x80=K5\xC6\x7F\xDC\xDD\xB3\x14Ia\x8Fym\xFE\xCB\xA2q1\f\x88Xw\x89b\xC4\xAA\x87\xF9\xDF\xB9\xE4\xF5\t\x11\x14*\x06\xE3\x9F\xFD,\xF1l_\xB9\x97\xB8#\xC4{@>\xAE\xF3nI\x8C\x9D\x0E\xE7\x9FX\x82\xFF\x9C\xF5S\xCBD\x7F\xCE\x05\x99\x01)\xE7L\xE4l\xE4Ml\xB6\x96\xF9c2|\xFEm\x8A{k\x00)\x88##9w\r\xFFn\xE9\x87\xDEABJ\xE1<\xF0\x9C\x17*\xEE\xDD\xE2 \xC9\t\x9B\xFA\xCF\x1CX\xF3.\xB4\xE3\xECa\x91\xDE\x11\xCA\x93e\xCC\x9B\x9B-\xF6\xD4\xF2V\xE4.E\xC6\x7F\x85\xF3\xEFZ5\x94\x1C\x19=f\xF7\xF2b\xCB\xBC\x05\xBA\xF7\xB9\x9B\x9B\xE8j\xBE\xF4c\xE3\xB9\xAE\b\xFF6\xC5\xC2\x1F\xAE\xDFd\xEB*?\xC7\xFF\x7F\xC9AC\xFC\xA68\xBB\xCB\xE3\xBF\x8B\x95b\xE1f\xBC(\xFF\xB4^z\xC3X\xE8\xA2\xE8\xBA\x05]\xF3\xE82\xA1\xE7\xFF\xBA\xEB\xF8\vo|\xBE\xD5\xC2\xC5=\xFE\xBB\x8C\x05\n\\\xE7\xA2\xCBz\x9ES\xF1\xF0\xCD\xBB\xCFR\xFC\xFE\x8F\xAB\xB8\xCE@\x97\xFB\xD9\x1A\xE3\xFF9\x1B\x9F\xBCn\x80\x9D\xC6\x0EN\xF8\xFA\xFF\tK\xA1\x80\xAEQ\x00?\xDC\x15\row\xEDEW\xE5\x87\xBB\xBC7\xEF:\xF7\xB9\xC8\xB7\xAC\xC8?\xEC2\x9AB\xFF]\xB9\x05n\x88\x8A\x14\xBFx\xAA\x8A\rc/9\xEC`\x03x\xE1\xE6*\xBA\xD8M\x7Fo\xD7\x04\xBA\xF0\x8B\x1FW\xC3\xC9<\xF7\xBFM\xA0\xAB\x89\xAE\v\xE82~Q\xC3\x82\x8D_\xF0R\xBC@\x83\xFED\xFE|\xAD\xE1\xDC\x02H\xCE\xB4\x8C\xE1\xDC--d\xEC \xF4\xBD\xE8\xDF\x84\xD4\x7F!\xD0?\x7F\x8Bs\xEE\x9E\x86\xBCK\xC12JK\x13 \xF7\x83\xCC\x83\xEC\x02\xCC\xD2\xD2\xF1a2\x9A_\xDF\xFEX\xD4\xD3??\xF0\x1F\x17\xEE7\x81y\xAB\xCAU\x87\xA3\x14\xF7\x99\xB8\x078\xF5\xDA\x00\xB7i.\x88L\xACh\xB2\xF7\x9D\xEB\xBF\xCA\xEDO\x94\x7FBA*;,/\x1E\x12\xD7\"y\xE0\x97\xE4sF\xA1&\xB3q\xFF8\xFB\xBFL\xB9\xFESc\\\xFF\xF9;\x1D\x94\x96DNf\x9E\x9Cg\xA7\x8DF\xC3\v\xF7\xFE\xDE\x82\xD4\x7F\x9C\xE9\x7F\x8F\x83?\xA0\x9E\xFD\xD1\xBE\x10\xE6\xBF\xB44\x0F\x92\xB3,c\xD8\xBA?\x9C\xC2\xAA\x83\xE1k\xF1/\xED\xFF0X\xE2#\xBC\n(T\xEAQ\xFB\xAF\x7F\xC6\xF4\xF9w\v\x953 \xB3\x9C\xFF\xCF!\xD1\x1C&\xEE0\x19m\xB5?\xF1\xB1V\xFB\x13wE\x1A}\xE4g\x96\x89-\v.\x7F\xA9\xC7\xFAxl\xFCN\x07\xD9J\x9D\x9Bz\xC3\x0F\xB0\x14Mv\x9C\x1D\x8C\xCF\xF2\xF0{\x94\x7Fv<\xB7gi\xC6\xB7\xFFQ\xFB\xE3\xF2K\x9E\xB8G\xF2\x8F;\x1B\xD2\xFF\xD95_\x85\xC6\r\b\xB1M\x13\xC3D\xDCtfk\x8E\xE5s\xCFRD\xFF\x1F\x8D\x8Fy\xF6?k\x99\xBC\xBEp<\xFB\xA3E\xF5O\x8E\x83X\x96\xD5oVf[F\xFB\xC8\x8E\x83u\xF4_\xF0\fZ\x9EJ\xFB\xB6k\xFF@\xD4\xFE\xEBE\x9F\xFF\x9C\xB1\xFB\xABy\xC43\xDC\xFE\x9B\x809L\x06\x86\x97>o\x99\xEB\xF2\xCF\xF5\xEF\x82X;y\xCE\xB7\xFCp4o\x8B\xFA\x97\xF1\xBF\xA5\xC1<\xE4]\x14\xD9J\x91\xEB\x7F\x1B\xE2y\xDF\xFE< \\\xFC\rS\xED\xF4o!\x9E)\xEE\xF0\xED\xBF\x15\xAD\x7Fw\xF3Kf\xBE s\xBEw\x97\xE7\xFF\xDC\x93s\xA1\xB9\xAC: \x13\xA6\x8D\xD2R?\xBF\xA9\xBB\xA92\x01\xE2\xDE\x15\xADev\xFFp\x17\xD3\x7F\xFC\x1C\xC8\xD8}&>\xE6\xD9\x7Fvy\v\xFF\xAC\xE6\xB2\xF2\x95\xFE\xE1\xFD\x99\x16\xFE\x87\xC9\xBB\xF3?\f\xD9[W\xA2\xF8\xE3\x1D\x11\xFEM\xE2\xF3_\xB8'g\xEC\xAE\xE4\xB9$\b\xE3\x9F\xDDq`\x98h\xBBZZl\xF1Q_\xA5\xBE\xFD\xB1\xA8\xD0\xFF\xEEa\x1B[\x16n\x01\x19\x10\xFA\xFF0\xAF\x7Fs,Y\vd\fdb\x8D\xFDa\xFC\xE7+-\xFC\x9FE\\+Z\x9ESD\nQ\xFE\x99\x11\x1E\xB1f\n\x9Er,\x9E\xC3\xDB(\xEE\xCBU\xA1\x19\x9C\xFF|\xC9\xE1n\x15\xBBi\x7F\x96e\xC0\x90\x1D\xF1\x1E>\x16\xB7\xF8[\xF9!\xC4\xCF\xDEgr~\xC4\xE8\x91V\xFE+\xF9x?\x88ug\xC5\xBA\xCB\x8A\xA4\xB0\x89\xBDb\xD3\xEF\x89\xFF\x06\xAF\x05(\xF2\xB9V\xFE\xEF\x96^\x9Cn\x12\xC3\xE4\xF9\xE4\xFC\xE7\xA1\xE7-k\xD70!w\xB6\xF0\xBFa4\xAA\x7F\x03\xA4\xE2\xF1_\xBD\xCBD\xCE*\x80\x14Af\xFB\x80\x85q\f\xDB\xC8\xCD\x97Ar\x88W#\xF6\x9F][\x01\xF9.w&[\xF8\xDF\x062^\xF2_m\xB2-\xCA\x7F\x81Y\xEF\xDC\xA5\x11i\x7F\xF6\x8A\x1C\x16)\xC68\xFF\x16\xF3\xAC\xF2&\x13g\x91\xDF\xD4\xCAYy\x90\x87G\x17\"\xFA7?mq\x01\x14\xD8\x13\xAC\xC9\x01-\xE0\xB6\xDA\x1FO\xC2\xD3?\xB0k\xC3\x8F\x10w?\xF1{\xE5\xFB\xA3O\xF0\x0E\xC6\xFF\xE5\xF7b\xFF\xF3\xA2\x16\x1E\xC7\xAE\xDCO\xC2V\xB4\xB4\xB4-\xEF\x89y\xCFk.\xAF\x7F\r\x90\x1B@\xB6#\xD6\xB8\x7F\xF3\xD40\xE9\xFD\xC4xK\xB2\xF9\x88\xFDg\x12\xAA\b\xFBSz\xBD\xFB~\x8A\xFE\x1F\x1E@\xFC\x00\xE2\xEF\x1F\xE4\xED\xDF\x07\x80\xFE\xDF\xDF\x00\xD2\xC5S\xBEK\xF2\xDF\x10\xF6_C\x9C\xB9W\xF7\xB7\xF8\x9F\xF1\x1F\x81\xDC`\xEE/\xFB\x7FF\xEC\x7F\xFC\x00+T\xA2\xFB\x01*\xF5/r\xF8U\x07\xD6C\x7F\x06\xCD\xBD\x9F\xD9\xFF\x89a\x1B\xA5\xD7\x1E\xE5\xD5S\xB9?7\x81\xF8\x81<\x89\xB0W\xAA\xEC\xE2\xF9\x9C\x02\xB9\xFC/D_\x00\xBF\x8Bi\xAB\x90\x97\x82\x82\x82\x82\x8A\xFC\x87?\x07N@4\xA4/\x86\xD5\xCD\xC064/\b\xAF\xFD7\xDD\xC5KP\x17\x1F\x92\xAD\xE9\xE8\xE1\xC0\xFE\xDA\x00;\xC7\x14\"1\xFF\x96\xBB\x84\xAF+\x90\xF5k\xBA\x98w-\xB1E\xAF\x81\xB9\xE6\x04\xD1}\xD0&o\xC0\xEE(?\xF2v<\x1D\xDF]/\xC4\xDA\xDC6H$\xCBZ\xC1\x06\x8F\x88^\x12\xD1`h\x14\xDA\x85!\x1E)\xED\x03\xA0\xED\x15!\xFD\x1E-\x07m/\xB4\x19Z6\xB6\xF6\x19\x83\x8BFV\xDB\x96\x8D\xC6Z\x07\x1B\x80\xB6-\x92!q\x82\xE6\x0E\x9E1\x82@\xB7\xFC0%\x03\xD7\xAD\xC3\x9E\x83\xEC\xF9#)\x07\x1D\xDC\x98\xA5\x83\x0E\x06\x05\x99|\xA8\xAD\x17\xD3\xCE\xB4\x04\x8D\xA1-\xF9\x076j\x85\xDC\xFA\xFCo\xF5\"\xED\xB92+Q\xD8!\xDF\xE2\xC8N\rq/\xC4.\r:@\xC7\n'A\x14j\xCC\xEF\xF8\x90\xF1d\xBF\xAFA\xF3\x1E\x99V\xE8\v\x87\xBB\xC5\xEF\xD8Y\x11\xB7g\xF75y\xCF\x02K_\x87VE\xCC\x85\xB6\x1DZ=WC?\x151j2\xE8`+\xC5\xC6E\x17\x9A\x05\xED\x89\xC1W\xDD\xDC\xB0\xDB\x9Fuo^\xB46-F|\xAD~\x96\x9A\xC5\x12\t\b\x99\x13\xBD\x00\xFDy\xD7\xEFF\xF2\xB2zA|\xD8\xEA\x85\xC4\xBD|>\x8B\x10\xED\xF0:\x17n\x9B\xDB.\xBA\x18|\x9E\xBDt\\\xB4\x94Q\vR\xA0\x8F\xB8C\xCE5\xF8\x97\xD7n\x7F\xD5\xED\xEFp\xC3I\x89\xBE\x1E\xCE\xB9HS\xCF\xDA\x82\xDE)A\x1D:d\xCA\xE2\xF7\x80\xE9\xF7)\xB8\xF2\x92\xD09~W\b\xB4~tL\xF8Y\xBD\x87\x07\xB1\x99\xAB\xDD\xD1dm%-\x87\xB8\x05r\xA1\xE0\xB7\x14\xE2$o\xE3\xEE\x1A(\xC9\x81\xECE\xFC\xB2\xB9\x7F`\xCFb\xB9\xB4d\x14r\xE5\x96\x9E\x82R\x83;\xFCZ\xA8\x99C\x9E\x15\xAD\xB0\xD2B6\x88\xA7\xC9\x16\xE5\xD40/\xC7\x1E\x8AB\xF8\xBD\x0F\xB5\xF5Fk^\xCA\x0E\x1E\x98\xA7%\x07\xB2\x89\x14_\xF1\x87\x01#\xECo\xF3F\x13\xE2\xF3\xFE\x81\xFB\xAC\x82Y[\x97\xFF\x92\x17\xAB\xB1\xE6\xABw/\x18\x88W\xFC\xAF>\xE2\xF8Qz\x9Ef\x82G\x87\xE2\xAE\xFC\xE1\xF7\x12-\xA91\x9E\xF9{\xA9\x97\x01\xD6\x16\xF0^\xC9x!\x88\xAB\x88\xA8\x14\xBB\x9C\x87V\xE2E9\xAA\x96X\xAC-\xB6a\x03\xA7.\xC72O\xEA\xBBk(\xD8\xBC\x8D\x16gt\x8DPlY\xC8\xF1\xD6}\xF5\xCE\xD7\xFA\xAD\xF2\xDEB\xC5\xBD\xE7\xB5\x89\xD2R$R\xCAh\x8C\x1B\xD0\x96C\x84p\xFD\x93\xBF+\x04a\x96\xB2l\xEA\x92\xA9a\xAF'\xA2\xD4h\r|\t\xEC\xF2\xA8\x1B\xA1xy\xDE\x1D\xA1\xF8\x98\x13\xF0,\x9BK\xE1x\xA3\xE0\x8A\xF8C\xBC0?\xEF\x16\xD7\xE7\xDF\xF2b\xF5{\xE6\xDD\xA2\xE5\x82\x04\xE3{G\xA9\xD7J\x15\xE9\xEB\x1AK'^d*\x95w)\x04\x914@\x06x\xC3\x0F\b\x92\xBDp(\x00\xF1\x01\\7&\xC2}\x00\x16L\xA0\xCBz\x99\x02\x9DMtU\xD1\xED\xE2\xBAm\xE8\xAA\xFF\xA2\x86\x17k\xFC\xDB\xEB\xE8Y\x8A\x97\x1C<\xB4\xCB\xE5\x01\xF3\xF2\x8B7\x0F\xFC\xE2\x97x\xE9\r\xE3\xEC\xCD8{\xF3X\xB88/5x\xD8|\xC3S\xA1(:\xD7\x7F\x97\xFD\xD2\x8F+~\\}Ad\xA9\xEB\x97\"\x12~\x96\"\xD2\xF7{\x9D?\x00\x1C\xFF\xD9\xABr_\xA0x\xE0\xA9\xB2\xE8b\xE0\xD76\xBD\x10\xBA\xECb\xF0c\xF8\xA2\x97!\xD0\xFF.\xFB\xAF\xD7\x8F\xDD\xBE\xF4\x86\xBCv\xE1\xE6\xEA\x7F\xFE\xB1\x81\xAE@\xFF\xFF\xA7\x1F\xA5\x17\xE9'\x9Ey\xC9\x01\xAE\xBB\xCA\xFE\xEC\xFA\xB1\xB8\xD7Y*\xF3\xCF~\xCBB\xCD\xB2\xBB_\xE7\xE9\xBFk\xF6\x17N\xA4C\x81\xE50\xFE3\xBF\bw\xB1\xE7[\xFFH\x8D\xD9y\x90\xA7\x99#\x12\xFF\x1B\x90\vV\r\xC5\x1A\x7F;\xE2\xDBET\xF9\xDB\vbV\xD5\xF2\xDDK?\xB1\x8Ana\xBF[\xC8\xB9\xA5h\xAC\x95\xE9\x9FT\x91\n\xEB\x9F\x0F\xBE%OX\xBE\xB4\x88\xED\xE9\xD6\xC8\xF3<\x17j\x88\x04\x9F\xE3\xCF\xB6\xB5?\xA3\xF3\xEE0\xF0\x808\x12'!\xFB\x13\xD2\x7F\x9C[\xB9x\x10\xBF\xCDU\\s}\xFE\xEF\xAF\xC8{\xED9\xE6\x16\xE2n8\xA9\x8F\xFB\xBDTB\xB7d~X\x18\r\xE2\"\xFE%\x91\x7F\xA9\xFC\xD0[\xC02\x10\xBF\x10\xD2\xFFM#4\xEA\xCC\x91\n\xE2\xDB\xFDWu\x17c\xCC\xF8xM\xD8\xFF:\xE7\xFFz\x90\xB2U\xC3\xDD\x8E\xB0?\x05\x932\xFB\xBF\xD9\x9A\xE0A\xE0z1\x87\xD2\xA2Q\xA8TKK\xF5\xC2f\xB7\r\xFF\x11\xFB/L\xE5bi)\x18\xF6_\xF4x\x13\xF1\x9C\x07j\xBC\x97\xB6\xE5\x91\x89\xE0\x95\xF7\xF2\xE6\x81\xD1\xF92{\n\x82\x7F>.\xD4{\x8E\xD55\xB7\vj\x84\xFBvT\x87\xD7\x1F\xDB\xF2Y/\xF8_\x98'\xF7,Ux<|\xAD\xFD\x17i\xCEs6\xAE2\xDE6D*\xB2\x87\xC5\xDC\"Y\xA8&\xB7\xD2\x956}\n\xB2\xD6h\"~\xD6\xFF\xD3\xF2\xF9\xD7\xC0\xF9\x9F\xE0\x91\xAE\xF2\x03\xDC\xFE\xF3'>\xB1\x93\xB2w\xA1\x8F\xE4ywm\xAE\x98\xDB\xFB\xB9\xFCXi\xA9\x9A\xAF\xD4K\xD1~\x01i-#\xFC\xCF\x8A*\xF5w\xFD\xD8\xD7\x86zA\xF6\x85\x95w\xF1<\x8Fz]\x12\xDE\t\xC13\xF5;\xA4\x86M<0\xCF\x1E\xDC\x1EYwk\xA2\xC7_\xF4\xDB\x86ng\"2\xC1\x04\x95\x9B\xDC\xE2\xFA\xFC\x17\xF6\xCB3\xEF\xD9\xE1\x16\xE7\x9B\xE1\vC\xF6\xDF\x10\xF6\x87sUD\xFC\xCF=&\x8D\xB0\xF2=1T8\x81\xFE\xCB^\t\xE9\xBF*OH\x88\xEAc\xDE\xAB1\xDD\x8F\x8D\x03\xF1&\xB7?y\xDE\x7F]\xB6(\xC6\xB8\v\x84\xB8\xBE#\xAC\xFFx\xEE\xEE%\xA3tft,\xE7\xE6+\xEE0)Db\xADr\x02N\xD8\xFE\xFC\x05\xFF\xBD\\\x9C\xF7\xBB\x99\xDC\x8Fx\x1FDe:j\xCA\x90\xAC\xA7\x93\xC0\xFF\xF7&\na\x8C\xC2\xCC1\x19|\xC4\fz\x07$\xFFa\x1FL\xD4\xBC$\xF0\nV\x97\xAA\xD6\xFA\xFC\x97~)\xDF\x9DQK\xE8?x\x95\xFEg\x7F\x8E'\x91\xFE's\x12\xE2\x97A\xFEP\xB8.\x88\xBB~\xE0\x9D5\xC6\x02\xFD\xF7\xB7\xD7?\xF1\xF5\xCF3\xC9\x8D\x18\xB7\x18\x06{\xD6q1\x1A$\x0F\xF2\xB0\xCF?\xD7\xFF\xF5B\xFF[s\\\xFFd\xA0@\x8CB\xB6:\x96+[\xF3\xF5=K\xDB\xD6\xD8\x9F\x87\xD1\xF1\xD4\x1A\xFF\xE7\xEB%\xDFR\x91\xFA\xEEq\xA9\x7F\x11\xCF\x1F\xAD\xB5\xF0\x1F\xB4\x97\x1E\xF6\xC4\xF3\x100\x9A\xB3J5\xDF\xFE\x8F\x86\xEC\x7Fx\x14\x87\x98\xE0\x19x\x05\x84\\\xCB\xFF)Td\xAE\xF2\xF3V\x811\x134\x04E\xDD\xB4\xD3\xF6\xF4\x1F\xBF~\x8Cw\xF8\">\xED\xD9\x7F\xD9_#Dr\x1F\xF5\xF4O\x8A!\xFE+\xC3h\xD1\xBF\x85xA\xF6>\x03\xBB\x05\xFF\xE3|\xBC\x193\x1D\x13\x88\x1F\x009\xB0g\x1C;\x85\xFFO\x1E4\xC7Q\x18\xC7&\"\xEC\xFF\xCB\xA5\xD7\xDC\xD2\xE2-;\x97\x0E\xDC\xBFT\x1F\x8E\xFF(\xD2\xD7Fy\xD8\\\xEB_c\x90\xBFc\xFA\xA3bH}\xA7\x1D\xB1\xFF{(vFz^\x02\xEFq\xA7\xF7(\xEEl\xE0\x93\xBFW.\x8C{\xF6\x9Ft1\xF6\xE4+\x7Fs\xE8v_\xE7\\UC\xFCW\xEF\xA5\xEF\xEE\xFF\xFF\x8B\xDC\xCD\xA5\xD77\xF0\xF1\x00\x9E\xEB\xCB\xAF\xBA\x7F\xDC{\xBF\xF49\xDE\r\xF1\x06{\xB9\xE2\x1BD\x07\x81\xD0\xF6G\xA8\xECk\xF0\xE4\xFDh\xC8\xFE4\xF7\xB4\xD8\xFFxY\xDA\xFF\x90\xAF\xAB\xA0\xA0\xA0\xA0\xF0\x8F\n\xC4,h6b\xEB\xC6\xC6\xA9\bn{\xF1s\xE3Zi\xD9m\x82\xEA\xDEQ\xBE>\x83\x98\xDC\xDA.\xB0O\xC2K\x8E\xB4\xC6\x8A\xE5\xFCJ\xF1G\x8F79],@\x94\n\x9F\x13\t\xDD\x9B\x91\xA1\xDD\xEBC\xF7\x02\xF8\"\xCFm\xBB3\xBC\x95\x91\x8Ch\xD1DS^2\x13k\x93\xE9h\x12\xD1\xF2zA\xEFB\x96\x8F\xD8\x1F\xB0\x81\xE8\b\xFFA\x07}\x1A\x1D4\xD9\xB72~\xAE\x8DA\x8BT\xD9\xE1\xB8\xEE\x1D\xF2\x9C\v\x00\xB6\xE6\xC7>\xE4\x00\x1A]ul$\x9AC\xB6\x99\x89_\x9F\xE3\xFCo\xD9w\xA9\xC3A\xA9\xC1\n\xBE\xD1\xCF\x86\x19tH0\xFE;\x1A@\xA3;\xEDN\xC6.%ls\x8B\xED\xF3\xDF\xDB\xD3\xB1\x92\xF2\x1E\x04\xE3\x7F\\\xCCX\x94\xD3\xBD'\x1B\xF8\xF2Kb\xB6\xA39\xF9\x8A\x81D\x13|E\xA3\xA0-\xC0\x97\x9A\x91k\xCE\\tW_\xF1\xF8\x8F\xB91\x18\x1B\x1DW\x837 \xB0\xE3r\x88<\x97\xF3l\x80\x9F\xD6\x9E\xFF\xD8\xF6\x1B\x1D\fu\xC8\x85e\xCCD\x13\x89\xE6dC\xC6\xC6'_|FD\xF0l\x8A\x8D\xE9\x1B\xC5\xBA\x01\x93\r\f-\xBAb8\xFAv\xC6\x7F9\x9Cr\x1F0\xF8\xAA;`\x07\xE3\xD5yd{\xB65\xDA\xEF\x9F\xEF\x04\x0Fz\xE8Nw\x805\xA8i\x86OZ\xA7\x87\xDCjn>G,\xA4]Z6\x9A\xBC\x99\xF0\xC7\r\xF8\x1D\x139\x1B\xBF\xF0\x06\x9F\xBC-'\xCE\x9B=0\r\xDB\xA0\xB6I}\xFE;\x9C\xD5E],\xD1 &\x8A\xBEm\x8B\xB9\xA2f\x85\x02\x89f\xD1D\xD14\xA1\xCF\xD9\x83\xAE\xB9\x85\x8F\xEF\xD25$\x03\xF1\xD9\x94\xFF\xF4k\xFCw\xF90\xB5\xD3\x9C\xC0}:\xDD\xA7\xBB\x95B\xB9\xD2\xEF\xF9\xEDz\x10\x03?r\xAEZ\xB1\x81\xA4\x8Bd\xF6\xC8\xF9H\xBC\xE5\x90(u\xD2=r~a\xB6\x86>o\xDE\xC7\x97\x17,\x10\xBE\xD0\v?b\x95\xE6\x05\xFF\xB5\x1Az\x92\x19\xDE\x1E\xB45>\xB8N\x04\xD9\x98#\x1D\x9F\x888\xC6\x0E\x86\xE3c\xEC7\x85\x18\xF7\xC5CO\xCD\xD6\xDE.\x0F\x9F\x90\xE70\xFD\x8F,\x15\xF78!\xFEm{\xD4\xB2\x86\xCE\x14\x00\xD3\xB4(\xE1\xFC\x9Bf\x10[Xup\x98\x86\xED\x0F\xE3\x9F\xDA\xE6\xD0\xB8A\x0F\xB9\xAC\x14\t\xB1\n\x10z:VD0A\x84\x17S\x9CO\xA4\xDD\n\x1FK\xCF\xF8\xDF\xD9\x84>w\xFAx\x9E\xE9?~e\xF5\x9C\x86\xE4\xD5\xB0]8]\xC3\x91\x0F^\xDDGq\xFA\xC9\xDF\x99l\x98\xC2\x8E\xFD\xCB\x1C--e,\xAB\\\xD8\xAC\xAD\xED\x83\xC8[U1\xD4\x1F\xF1\xECptl\xCF\xEFz-\x9A\xE21\xFD\x81\x10\xFFE\x8B\xF1\xCF\xA3\x97|\x10\xA9\x99\x13\xFC\x1F\xA6>\xFF\x8D\n\x05kI\xF1 [\x89\xB6v\xB5\x8EP\xECy\xEDOFx\x00\xC4\x8B\xEC\x15d0'\xDC\xDA\xF5K&\x9BEuv;\xCB\x1D\xB39\xFF|%\x10j\xCFd*\xF3\x16Lt\xACL\xBE\xC4\xDE\xCAR\x03_n`\xB5\x11\xC8\xF2\b\x8D\xEA?\xED\x9A%\xD7\xD4\f\xD3\xE4k\x92H\xFD77jr\x1C\xE3\xA4-\x1F\x9C\xCD\xD7 \n\xF8\xB7,$\xB3L\xFF\x83.\b\xB1\xFB.\x85\xAB\xB7K&r@V\xD3\xDFj\xA0\x87O\xAB\xF9\x03Q\xB2\xFC\x1DI\x9A!fy\xD0\xF1\x05\x16\x84P6:.\x9F\xEF\xDFD\xEC\xEAF'\xA2\xFF\xB4,\xC2\xD3\x9D57\xE3\x84\xF8\xDFq\x05\x89&\xE3\x99\x8F\xE4\xBF\xD7\xD3\xFF\xB4\xCF\x7F\xAA\xF8U\x07\xCFu\xCD\xBCX\xC3Y\x8A\x97k@\xD7\x85p\xCA\xFFy\x1C\x8D\x0F\xFD\xEDK\xC0s\x14/\xD6\xBC\xF0uWD\xFF\x93!\xFB\xFF\x7F\x8B\xCF\xFCv\xFF\xE5\x8D\xEA\xCF\x85\xFE\xD3\xCC\x02\xD3}z&~}\x05&4\xBD6\xCFT!\xF4\xEF\x87eN\xD7\x02\xFDO\x8BQ\xF1z\xFE\xF4\xF1\xFC[Y\xDD41C=\xFE5\xA3\x87\xAF\xA4\xC1\xF4oK\xC3\x15\xF0\xCF\xED\xCF\xEA\xEBM\xA4n\x1C\x9A\xCAO:&\xE2W\xEC>#\\\xF7%\x1C\x10\x13\x93?X\x89\x01\x1B;\xBE7d\xCB@f\xDC\xB6\x924\x13\xE166\x10\xD8\x7F\xB3\xBA\x91\x95\xAE\x82X\x96\xD8\x91x{R\xFE_\xD6\xFBR\x0F\xD8\xE8\xD3d\x8Ckz\xC7\x98\xD4?\x7F_|\xFDW8\xFF\xAC\b\xC9\xD1+\x14{\x96\x98\xFEK\x0E\xFE\xA8&\xA5\x1B\xAE\xC1K\v\x95\"\xFFV\xB6\xA0I\xB9\xE5\x1Dy1\x14W1\xED \xDA\xB0\xC7rG\xB9\xFD\xCF\xC6\xB2\x88\xD1\xA1\xAF6o\xAB\x10\xBE\x0E^{\xFE\xA9\xDD\xC2\x7F\rz\x9Et~\xFC`V\x9F\xCA\xEAa\xFE}\xFD\v\xFB?$\xF9\x9Fc\x7F\x12k\xD5\xE1\xFA\xBF\xEE2=\xE4\xF2\xB5\xCE(\xE3\xBFc%\\\xAA\xDF\xB2\xB1\x90\xD7\x13\x8E\x9CV\xF6\x01\xDB\xE3\xBF\xCF\x85\xD9\xDF\x96\xFFt\xE3i\xCEs\x05\xB1\xAB\xBD\xE3\x11\xFD\x8F\xC8\xFF\xDD\xF4+\xE7\xC6\x98\xFD\x91+\xBDT\x19\xFF\v\x1F\xF3bwa\xFD\xBFy\xFE\xB2X7\xE9\x1B\x14#\x04\x05\x1E\xB8f\x85\x8A\xF2\xBF\xC7\xC10i\x16\xF9\x10\xD61\xBF\x9B#\xDA\xDB;\x16\xB2?\xC3N`\x7FF,c\x0F\r\xF8\xCF\xC4\xB2\xA3;\x9B\xC9\x18E\xC7\xCA\xD0W\xA5\xFD\x99l\xC0_\xB2\x8F\xB6\xD6\xBF5\xE8s$Y\\\xB6\x18\xFF\x1B\xFDu\x175\xA3\xC7\xE3?\xA2\xFFd\xC6\x8E\xD8\x9F\xCCP\x85\f-XH7\xF9\x83\v\xA2\xA9WM\xFC/\x80u\xE7\xCAU\x13\x93g\xF4UG_\xE2\xF7M\x9A{\xD3\x8E\x81F\x7F\xFA5\xBF\x80\xF5\x90\xFFS\x97\xF6'\xAE%\x1A\xD56\xF5/\xF3K\xA7\x9E\b\xD9\x9F1\xC6\xFF\x92\xCF\xCF\x9E\xC2\xBCo\xFF\xED~n\x94\x93\xA3\xDF\x18\xC7\xE4\xD2\x05\xA1\xFF\x12\xE3?b\x7F\x86\x81=K\x95\x92\x83{)vz\xE1z\xC4\x07\xC2\xE7\xEC\f\xD9\x9F=\xA1\xAE\xA8\xC9%\xAE\x7F\x92\xCD\xF7Q\xCE?\xAD\xF6Q\xC6?\xFF\x9C\xB1\xD9k\x9B\x01\xDE\xE7\xFB\xB1v`$\xEE5\xB9\xDA\x93\x99\xA1\xAF}|\xDA\"F\x85\x04-\x02o\xB9B\xDF\xFEO68\xFF\xA9\x94\xA8\x85\x19\xFF%\x17\xC9\f\xDD\x7F\x85\xEE\xE4\xFD 1#\xEC\x7F\xDEk\xE2\xFD6&\x1B\xE6GlX;\xDD\x9Cm\x88\xF5TF,k\x98\x18wZ\xFDz\xCE\x1F$P\f\x8A\xB6T/\xC9\t _\xBA?:\xB7\x8Bx\x81\xB5=\xAF]\xE0\x93\x05\xBC\xD1,\xBF7\x86\xF8\x18\xE3\x9F/+\x17\xF6\x7F\xEC~M\xAC\xA4\xF4\xEB\x1AFr\xF5\xFBL\xEC\x00\x8A\xB5h\x14\x97\xFB?\xC5\\\xB3\xC8\xBB\x00>n\xB6\xD7\xFF'B\xFA\xBF\xCF\xAF\xA3\xB9\xFE\x1F\b\xF8\xCFf\xFA\xD8+\x90d\xEFB6\xD3\x97\xCD\x98HRd(\xAE\xF7\xCCW\x86\"\x13\xE6_3\x90\xEA&]\xBF\\\xF6\xF9_\xD3\x98\xCAx\xAD\x00n\x7F4\xAE\x7F\xC2\xF5O\x90\xBC,\xF5\x9Fh\"\x96\t\xEB\x7F\xB7\x89\xDF2\x91:\xE4\x8E\x8Dc\xF2\xAC6\xD9\x90V\xEF\xDE\x1C\x19&\xFD\x9F\xB0\x06\xFA\xFB}\xFE\xF3\xA1>\xFA\xA7GDGR\xB2hU\"\xE3\rV\xBD\x8E\xD4;\xC9\xF1Q\x13\xC39Y\x8E\xF1\xF8\xE7\x11/\x8Ey\x96s\xCF\xE6\x9C\xEF\xFFK\xFE\xBB~t`\x1C\x9FXxz\xCCff$\xBF\xC6\xFE\x17k(\x1E#E\xDE\v<l{a\xF6\xA8\xFE\xC3#\xF6e\xF4\x9B\x07\xC6\xEF\xDB\xE1~\xBE\x01\xE8\xD9r6\v-+\xD0\xE3\x7F\xA6\xE8\xA1\xC8R\xE4h0\x06,\xE3}\xAE\xB27Q\x87\xAE\x11=\x7F\xB0_\xDBT\xD0b\xFE\x88\xAC\x8E\xDE[\x1F\xE9\xBD\xD5\x96]6!\xFF'\xE0\x7F\xDAb>?\xD3\x7F\xC9E,\xCB\x87f\x05\xCFn\x86b\x91\xE26^\xA7X\xF9\xB9\xF9ZC\xF4^\x1C\xEE'\xFBt\xCB.\x14\v\xFD^([\x0FZC_\x9D*\x1Fd\x16#\x83\xD4\x97\x1E\x99\x1Ak\xA3\x7F}v\xFF\xC8\xC3#\x14\xFB\xFA%\xFF\x8F\xEBy\xE6B\xD4\xC0\x05\x80\xCAf\xAB\x95\x7F]\x9B\xA2\xB8;w\xE0\xAEq\xFC~\rw\xD5\x10\fY\xF1\xF8\xBF\xE7\xF7\xC8\x1E^\xF9\xDE#\xDF\xB2r\xAB\xFEC#\xF6\xFF\xA5T\xC2O\x00|j\xA9~'\xBB\xC5\xF6G\xDE\xB8\x11]\xDB\x7F\xF0\xC6\x8D?x\xE3\xC6W\xDE\xD8\xCE?o\x7F\xCE\xC1+\x0E~\xE0\xE0y\xCF|\xFD\xC0\xC1\xAB\xDE\xE7?\x1F\xE7\xAB\f\xE9\x1BV\xCF\xDD\xF5o\xFB\xB5;\n\xDA\x06\xBF\x87\xB1kC\xE3\x0F74\xF8M\xABTV\x1C\xB6\x03\xE8\xDD\xEC7\xE92\x1B\xF8\xF3\x85.\xE8\x1B\xFA*]C\v\x04\xDD\xDB\xD1ucx\x8E\xFF!\x07]\xC0sol8\xE4`r\xE1\xA9\xCD\x8F \xC1\x9F\xE6#Iw_\xB2\xBC\xEF\x85G\x0F9\x9E\x0E:7\xF8W=\xFE\xB0\xCB\xEC\xBC~\v\xB4\r\x7F\xF1\x07\xD56\xFC'o\xFB\xB7\x03\xDB\x0FR\xEC;w\xA3|d\xE7\x18\xFFL\x15\xDD\xEC\xC8\xE9S\x07\xA4\xFD\xF4Z\xDF\xDE\x12\xA9\n\n\n\n\n\n\xAD\xB1\xEB\xF5z\xADi\xDB@yL~E\x00\x1Ak\x13\xA2\x05_\xF7\x87\xC6t\xB9x\xFD\x9A[\x18k>\x847\x110\x88\xDD\x9A\x9F\xB8\x19\xBE{l\xBD\xDE\x88\xE0O\x83F\xCAgP\xCD\x18\x0E-Cd\x88\xAF\xC4J5rT9_''t\x8E\xEF\t\xC7Z{\x04\x8C\x9E\x98\x11\x03k\x82\xC5\x80\xFB\x88\xB1\x86\x1E\x99\xCE\xBD\x9A,5\xD5\xBC5\xD8\x1B\xD8Rqu\x8A&=\x03>{\x14i\xBE\x18\xA3\xF7\x01\xD11~t\xB0\fm\x028\xB3\x97'\xD4\xCB.\x04b\xEC\x91\xD4\x06\xCF\xE4\xAC<\xED\v=\x1ERf\xDF\xA6\xCB|\xC1\xF6\f\xED\v&\xA7\xAFP~\v\xE6\x18,B\xD3\f\x91H\xA2l\f\x96\xC5A\xC9\x7F\xFALs\xCB\x84\x91+\xCFo\nE\xC8\xD3\x8BH\x89\xD3x\x0Ecg\xDE\xBCn\x91\x87xD\x86\xCB\xFF\xDA\xC1\xBFv\xDA\xF1\xAF\x15\xAE\x93)\x18\x9B\x16\x8D\xE14\x8F\xD8\xA4\x7F\xCAC\x02\x85V\xFE\xD3?\x85X\xAA(\xB1\x82D\x84\xFF{\xD9\xB73\xCDGVF\xD23\xEC\xAB\xEE\xD1\xFB\xFA\x8Cw8\xFF\xF7\x02'\xD6\xF0\xFFVzF\xDC\x85\xF1\xAFI\xFEu\xCAcG&h%\x9B\xA4\xE8\x1Bd.\xE8W\xA8\x1C\xA9\xF2\x0E\rMm \xC1\xC0\x98c\xFDU\xA4\xABHg\x84\xCF\xFF\nE\x1Fc\xF8evI\xFFh\xAE\\}g\xF0\xE5\xD0\x83\xE7\xA7\xE9,\xC1c\x83/\xBF3\xE8\n\x97\x18\xC0A\xCAo\xC1J>\x80\x8Ee\xF69>\x00}t\x95r\x1F/\x96\xF2<\xB4LO\x7Fuu\xF0\xE5wr\xA3\xA1\x1E\xA5i9A[\x1B\x15wy\xEC\\]&\xC5\x98\xB9z\x90\xB2\xF4#\xFC\xA7\x8D>\xBEb\xD2\x1FK\xA7\xD1h\x0E\xCE|\x91p\xFEu\x1E\xA5\x17\x8B\xA3\xF2'\xF2\x16\xFFA\xDC`\x7F\xB2#\x06\x92\x86\xFF\xAD8\x01\x9AQ)\xEBo\xE1\tvZj\xEC\x1B%\xF7\x18\xB0\xFA\xD2\xCC[\xC0\xBD\x89\x9F\xB6\xF0\xBFe\xD1\x80\xCES\xEEp\x87\xB8R\x86^u\x05\xFF\x05\x13\xD4\xCA\x1E\xA4\xE8\xEBc\xCC\xFC\x17\x8F\xFF\xCDa\xFE\xD3\x01\xFF'\xFA\xAB\xECxL\xF2\xDFG1\xEC]r\xB4\x7Ft\xF2\xB9\x8CH\xC7\xBB\xF0evZ\x9A}{\x825\x85\xE5g\x96\x13\xEA\r\xA0J\xD5A\x06z(\x90,\"\xFD\xF2\x8E-\xFC\x84\xF4\xB2\x1C7\x98\xA8\xBE3X=\x9C\xAB\xC6\xC2\x8F5\xBD,\x9E\xB8\xF7\xFB\xF2\xE5\"\xE7?\xCD\xD7Y\x89\x8F\xBEEY\xFA~\xE0\x82?)\x97=brf\xA7\xD7i2\x92\x9D8\xB4\xE4\xFA'\xF4\xC9H\xC5\x84\x98\xFC\xB2S\xF4\x89h\xFC'\xD1\xE4\xAF\xBC\xFC\x16\xE0\xC3\xE0\xD3\xEE_\xBD\xBARz\xEDA$&\x90r\x07\xF6\x19\x9Fu\xD0\x97\x9F\xF8\x98\x83\xD5\xE5\xED\xAD\xFA\x1F\x94=q\xA7\x964s\x13\xFB`\xE6\xAA:_\xC1\xA9`\xC2,eG<\xFE\xEF\v\xF3\xDF\xE1\x159\x16\xF0\xDF7\xD8\xCA\xFF~\xCA\x97\xA8e_\xBD\x9C\xD4\xAA}\xD9\xF0\x84\xA0\xD1\x13\x9E\xFE\xFB\x06\xAB\xEFly\x19\xF1\xDB|\xFD\x07\xFC\xA7_\xDCJ\xB9\xAA\xB5\xCC\x88\xD0\x7F\xBC\xE8-\xD9Q\xBD/{\xDB;\x9B2\x11\xFD\xA7\xEAH\x85\xF4\x9F\xCC\x1C\xFA\x7F>\x03\xBFO8\xFE\xB7\x1D\x14\xB1@\xFF\xDCRi\x19V\"\xBDwX\x1A\xBD\xCCH>s\xB0\x9F\xDF+\x95\xE1\xADi\xAEm\xDE\x0E\xED\x13\xAFOJ\xBC\xE9U\xD6\xF6\x17\xB2IH\xF1\xFC1\xFF\xB62\xA7\x7F1{=\xFB\xAA\xBB\xDF\xBAs\xE5\xAF(\xDE)U\xDF\xA28\x11\x96\x8A\x10\xED@\x15I\x96\xD5\x139M\xAC\xF4[\x10\xFC\xC7\xCA\xC7M\x98\xB9\xEC\xADa\xFE\xB9\xA8Xn\xC9\xE8Z\xFE\xDF\xC9e\x18\xFFB\xD8\xDCL\xBD\xE3\xDB\x9F\x81\xCC\xEA\x1B\xA3\x11\xA2B\xFA\x7F\xA7\xBFz,7\xEA7\xB4\xDF\xF2\xEDOz\x19\x98\xDEA\x81\xAE\xCF \xFD\xF2?\x17\x99\xBF\xEE3\x1F\x0F\xE9\xBF'W\x8Dm\xB9\x86\xFE_~\xB3\x83+\xBF\x9B\xF7\x9Bt~\xE6\x1D\x8A\xB7\xDB\xF2\x1Fs\xBE\"\x8E'3\xDB\xCEd\xCE\x7F0\xE3\xF3_\x19\x94{y\x88\xBC\xDDK\xF9(G\xBD\xCA\x9EB\xA2\xC9~\x87\xC6Z\x8B\x17\xF9\v\xDF\\\x19\x19|\x9C\x9F\xE3\xAE.\xEA\x9B)\x8A\xF9\xCC\t\x8A\xB76g\xD6\xE8\xBF*\xB2\xFAV\xBF6\x95c\xFCO\xF5W\x85\xFD\x991qz>\xDBC\xF1\xCE\xE0\xE5\xB0\xFEWih\x11\x06-\xA4\xFF-\\\x12\xB1\xCC\xAA\xA7\x7F\x96\x19\x1E\x12\xEB\x1B\xC8\x18\xFB2\xC7\xB2\xA1Fz*\xB0\xFF\xFB\xFB\xAB\xC7\x98\xFE\x7FK\x86X}\x89\xA6\x06\x90^^\x15\xEB4\xA7F\x9F\x17\xE6+^\x94\xC3\xA4\x91\xB9o\xE0\xCF\xBF\xD2\x1F}\xAC\xFCL\xF8\x93\xEF\x92\x99\xC7\x96\x06\xE4{\xC1X\x1A8Aq\xA2\xD6\xC2\x7F\x96\xF1\xDFm\xCA\xE1\x88\xC9\xEC\xF3\x83\xD5\x13\x94_\xDE\xC9\x98!r\x9F\x14v$\xC6#T\x8C\xFFD\x861O\xAC\x16\xFE\xDF\xE2\xFA/\xD4\x8C\x91\xEC/\x19\x1B)\xAB2\xE8\xFEs\x8A_\xB34qbK\xAB\xFE\xEB\xD9\x8C\xD0\xFF\xBD\xFD\xDA\xD4VV\x01\xCCl\xCDp\xFE\xCF\xDC`b\xAA\x92\xEF\xF1\xF4\xFF\r\x8F\x7F\xC6jrtm<\xB0/We\xD5qG`\x7F\x82\xFAw\xF0\xE5\xA1\x97^>\x16\xB5\xFF1\x8F\xFFw\x06\xCB\x8C\xC3\xF4\xB7\xE4{\x14\xE6?\x96\x8A3q2V\xBF\xF2\xDB\xA3B\xFF\xC1\x1B4\xF0g=\x83\xD5\xFD\xED\xF5\xCF\x07*t^>\x9C\xFE\xDB\x80\xFF\xC42#a\xBC\x95\x7F\xF6\x8Au\xB8\x92\xFFt\x96h\xD9\x13\x83\xC2\xFE\xB0;N\xFE\x80\xF7\xEE\xF1!\xB81\x8A\xA2\x10U,\xEB\xD9\x1F>\x908!wC8!\xF4\x7F\xCA}';\xC3J\xD7]\x9D<\xA3\xFF\x90\"\xD7?\xF7\x16\xC5\xD5\xDFn\xD5\xFFU\xA6\xFFE\xFE\xE04\xC2\x1D\xA0L_\x96\xBB|\xD9M\x0E\xF4J~\xAB\xC7\xFF\xB10\xFF\xF0\x94\xDC\x1D\xF0\xFFN?\xE7?^\x15\xFCK3B\xF8\xB5\x03\xA3g\xBF\x99\xB9\xF5\xA6\xB0\xA32\xFA\x8Eg\x7F\xF6o\xDEp+\xD3\x7F\xD6\x0F\x99\xBE\xE3\xDB\xFF\xEB>\xF3\x9A\xF0\x7F\xD2/\xEF\xD8,\xFC\x9Fi\xE9\xFF\xA4F\xDF\x19\x9C{\x87f\xDE\xC9e\"\xFA\x17\xCA\x17oAWu\xF5\x95T`\x7F\xC8\xC0U\x1AZJ\x9D\xFB\xC6\xD0\xF2\x8C\x7F\xE4G\xA5\xFE\xF3\x93g\xB2\xCB\xFDs~\"\xFA\xAEi\xFFM\xBFJ1\xCB\xB2=\xC7\xFE\xD4\xB2\xAC\xEA\x14\xD9\xF6\xEC0K\\\xCB\x16Nd\xEA[&\xD8i\x9D\x13\xFA\xCE\xE6oQ\xAC\xBE4\x97\xA5\xC8nYlm4\x9D\xC9\"\x99\xE5\x91C\x8DPV\x03f\xB3\x82\x7F\x8D\x9A0\x1E)\xE7((\xAF\x17rT\x8E\xE2\xE6\x03\xDA\xCB\xBE\x1B\x1F\xE8\xBF\xBF\f\xBD\x8Cd^\xF4\x8BM\xD1\xA0\xA50?\x90\xD7\xF7\x97\x1F\xA6!G}C\x9Ez\r\xB6\xE6f<\xCC\xEC\xBF|\x94\xB3\x14r\xD7\x86\xF4\x1C:\xA6\xE7\x85\xFF\xA3i_\xD9\xCCO\xE8\xC8\xEB\xF2\xDB3F6k\r\x9E)|\xF0L\xC4\xFF\xDF\x10\xF2\xFF;\xE6\xF4\xC1\xC5\xE0=M,\x8ER9\x81\"\xE0\xBF#\xBF\x9F\x97\xC8\xE7\x9FX\xE5\x94\xE0_{\x90\xF1o\xF2y7|\xC5\xFBi\x11\x1Eg\xCC\x9FA\"\xCBx\x88w\x89\xAEz?f\x8E\xF4\xDC\x17\x073?\x19\xC8@\x9FC*\xA3\x17\xA6\x1F\xA4\xD0\v\xE5\xAB\x14\x0Fo\xCE\xB6\xF0\xBF\x92\x9E\x13Y\xBDJ5lb\x1F\xB6\xE7\xF2\xD4\x044b\xDA0\xEC\x8A\xE9\xF1oQ\x19\xFD\x9E\xA2\xDE\xF2\xFBbX\xBB\xFF(i\x19z\x051-\xC2?_\xCA\xEF\xA9\x813\xC6\xC1\xFC\xFC\xA6\xD0:j)\xCE?\x7F|\x95\xAD\xDA|.\x8F\xA4\xEC\xE8\xC9\xF9\xFC\xEBY\xC4\xF3K\xDC\x19C\xBC\\\xD9\xCA3\x7F]\xF6\x16\xF9v\xE4o\xDFL\xAC\xFE|a \x94l<\x8FT^|\xCB\xF5\x7F\xE6\x16\xF1\xD4Rs\"\xC1\xE3&\x8E\xFB-]\xB1!K\x17a.M\x07\x91\xDD\xA9I\xD2[\xA8\x18\x85\x8A\xFF\xD4\x8Ca\xDD/\xE9\x94\xC9G\xE6k\x04\x9A\x85T\x85\xF1 \xFA\xDA\xBD\xCC\xAF\xF0oG\xB6f\xED|\x96\xE9'\x955\x86\xF5^\x13F\xA9BM\xCC\xEFh]UW\xDBA\x90b\xD7\xCE\xC8=\xDF\x00\xB3\xF2\x03\x1B\xE8\xDAv'\xF0)\xF4\x9A\xE3\xA0\x0Fm\x90#\xDE\xF5\x03\x8C\xAEq\xA0\xCB\v\x83\x93`\xE3\x0F\xFA\xFB\x1B\x90~\x1C\xB1\rc\xDC\xC0\xAE\x8C\xA39\x0E\xC4\xD8%\xF4\xC1\r\x9F\x8Am\xA0\x7FxSp\xE3\x8E\x03\xEC[\xFD.\x00_\x7F\xD8\xA5\x0F\xFD\bI\x99\xD4\xFD\xE2BF\xD7\xA7\xD1\xF9\xFF\xEFb\xB7\xFB4\xF4OW>\xC5o\x1A\xDB\xD0\x10\xF5o\xFAG/?\xFC_\xF7~\xF6G\xCDO\x85\xE6\x1At\xDE\x04\xDE3\x80\xF4/\xF9]nj\xBC\xC4?$\xDF\xCF\x13\xBC\xE9\x98\x8Dc~\x10\xA2Kt\xB3\xF4\xDE\xEA\xB0\xCF\xB32\xD9\xC7?y\x88\xFD\xF0\xA7\xF9u\x00\x9F:\xC0\xFB\xB6t\x96\xBD\xB7l\x1C\xB4\xD99\xD8\xD0\v\xAD\x17]7@\x17\xB3\xD7e\xE6\xFB\xF8\xB7_\xFA\xEC\x8F\xDF9\xB0\v\xF1]H\xFD\xF8S\x07ny\xC5\xC6'\xA7\xFE\xEB[6\xFA\xBE\xFA_[\xF8?<\xF08:\xEF\xE7)o\x8B\xD9\xDB\xF8\xF6\x14\xBD*\xD8\xA5\xA0\xA0\xA0\xF0\x8F\x14\x9A\f\xE6S?\x14\xAF\x01\x9A\x8C\n#\x06\r\xF4\xBFKg\x82\xCE>\x99!\x9F\x809\x01bCO\xDD\x94\xA1\xFB\xF0,\x00c\xBD~\x87`B\xF6\x7Fw\xD0v} \xD0#]\t\xF6z\x17\xC8ocH\xC9\xA9\xC9\x11\x18\xA0r\x83\x03\xFB7\xE3?\x13\xA3H\xD7\x82\xEDY/\xB6\x0E\xA7\x97\xC1\xC3\xD00\xFB\xD5\x8B\xAE\xD8\x87N\x8C\xC3\x07\xEE\xE8!\x96\x8E\xB3\x92\x7F\xD9\xA1`\x13\x98\xDC_4-\x1B\xC3\x14F\v\xFF6\x887n0\xD6\xF8yo\xEC\x12\xD2Olr~\x0E\x8D\x8F\xF9M\xDC\xC8\xF2\xD9qA\x8CA\x9Dl;\x90\x80O\x90\x17\xDF\xCA\x13\x12n\xF8\xC3d\x90I~B,\x17Z\x17)\xE0?\t\x19p\x9E|\xBE9i\xDBo\xBF\xEA\xFES\xEFv\x9B\x1C4\x13W\xD0\xB1]\x86Fc@\xEC\xE7\x03\xB6\xE4?}qb\xB2A&\x9D;\xD2\x17]\xC3\xF6\xF8\x7Fde\xB5!\x07]\xC0_\x9D\x86\xFF\x0E\x06\xF9\xA7\x9F\x95\x9F\x05\xFF\xFA\xB7\xD8\xE9\xBC-d\xEB\x91\xF5\x9F\xF6K\x89P\xFE#\xF3I\xF5\x19[\xBA\xCA\x86\r\x13\x89F\x0F\xB1V\x13\xFA\xE4Kb\xB6\xBEh\x1F5W\x9D\xBD\xA5\x06+~\x1F\x1F\xEBh\xF0\xA7\xE9\xF3\xDF\xB4\x91\xF0v\xF1\x9BHd^]4\xA0W\xAFn\xC9@+|\xC5\xE1\xD1\x8C\xF4\xB3\xE8\xAA\xCB\xA1\xEAm\xE5\xCCg\xD7\x16h\xE8\x04B\xBD\x0F\xBB\xF3\xEC\xC5\x13\x8D\x8B\xC2\xBC\xC9;S\xF8\xF3\x92\xB7L\x04\xC3\x8C\x8D}\xFE3!\xC6!W\xCF\x06K%l\xA3\xB8\xDB\xA9\xB0\xA6M\x8A{\xB4\x1B>\x81\x98\xB6\xFA\xBAK\xF8\xC2>on\xCD\x9B\xA5\x9C6H.\x99:=D'_b\x07/\x95u\x98\xB8\xE4\xF3O\xB2&k\x1Cib\xD1~\x88\xE9\xD2\xF1\xBC\xFC\x1C\xDB\x90\xED\xBB\t\xE9\xEF\xF9\xFC\x1F\xF9\x9A\x8Bd\xB3\x95\xFFT?\x92+\xEC\xC7\xE3\x7Ff\x84\x9F\xD3\xD9<$fR\x10\xAB'\xA6W`\xF2y4\x9C\x7Fb\xF5\xC0\xE4\x13\x9C\xCDI\xBEd\xAB\xD0\xBF\xBF33\xD3\xBF\xB7\n\x96I2\xACq\xAEW\xB3\xB9\f\xE2W\xF8H\xDDQ\xD6\xE4\xD4\x97\xAF\xC5?\xDF\xB1\xB7\xD8\b\x8F\x9Foz+y\xCE\xECq0\xF9\xC1\x9F\xF3L\xBE\xB8j\xE3w\x1Dv\xB0\xAD\xFE\xC5\x9Ez\xA2\xB9\xD4\x03;\xCC?\xA5\xF8B\xAE\x00]C\xA7\xD8\x0E\xD3Bz\xB1\x87h\xABK\xEC\x058\xBC5o\x8E\xE4\xC8V2c\xEAt\xE4&\xB1\xEB\xEE\f\xE7\x7F\xC6\xE7?\x9E\xE53\xA6/\x8FP<(\x92M\\\x86\xFE\xF4\xA4\xE4\x7F[\xB6\xB4\rz\x8D\x9D\xCEi\x9F\xD1)\x92\xC1\xE6\xAA\xDF\x97\x1D\x19{\x91\xECG\x8A\xF8\xFCO\x89\x9E\xA7\xA4q\x90\xD3\xB3\xBA\xC4\xF9\x8F\x15\xF8\x19R\xFF=\x1D+\x97\xF9\xF6\xCD\x96\x89\x8BN\x1B\xFB3T\x96dL.\x8D\x96\x07]\xA4\xAB\xD9\x9B>\x0E\xBDzX\x84\xC5X\x93S\xEA\xBF\xD4XW\xFF\x13|Y$o\xC9&\xE2\xAD\xDD\xF1\xF3\xDD\x14\xE6\x00\x1F\xC9\xA6o?&B\xBEa\xFD\x87\xE7\xA9\xC5\xE5f\x82\x86ie\xB0R\xDC\xD4\x1C\r\r\xDB+f\r\x1E#\xE2S\xB7\x12\x9F@r`rA#$\xE0\xBFwknf\xE7\xD4\xEA\v\xDB\x04\xFFG^]\xD9\x1B\xE6_\x9F\xFB7\x14\xD03\x07)\x0F{\x8Aqw\xE9\xFA\x9C\xE4\xBF\xF1\xE0>f\xFF9\xFF9\x8F\xFF\xB5\xFA\xFF):\x9B\xB8\xEE\xE7\x92\xFF\xA4\xB1?\xC5\xAF\xD7\xCDC|/\xDA\x9E\xB4\xDB\xD7\xA7\x93\x98\x98:$\xF5?P\xD6\x999\xE2\x83\xE1G(z\x81D\x88\x7F\xB7\x81-e_\xFF\xA3Ws\xCC\xE6d7\x7F\x14i\xDE\x87\x95\x10!\x17\xC9\x7F\xC1\\\xDF\xFE\x8CG\xF5/\xD7.\x18\xD8\xE3`\xCF\xAF\xF8\"<\x9Dg\xBF\xEF\x88P\x7F\xD6\x9F\xD6\x17\xE6\x7F\xF5\xE2\xB3\x9E$\xFA\xFF\xC9s\xFA@\x96\xF8\xFC_\xA5(\x0E\xBA<FdI\xFD\xC7\x8B\x84h$\xB9\xE8\xF3?\xFEBn\xC6\x9A\xC2VGl\x1D\xC1\x98\x8F\xF0\x9F\xFF\v\xCE\xFF_\xFA\xBD\xA5\xE9\xCB\xC0\xC0\xAA\xFC\x8Co\xC6(\x90\xF5\xF9?\xF2B3\xAC\xFF\x7F\xD7\xF0\xF5\xAF#)\x07F\xD2\xEE\x1B\xCB\x9D\xD2\xFE\xD8|&K\x0F\xB1\x16.\xBA$\xA6\x07\xFB\xD5\x12\xCB\xBAse\x8F\x03$\xB3\x16_\xFC\xE4\xFD\x00i\x84\xF4_C\xCE\xE3\xBFT\x19-\xE7V\xA0W\xDD\xDC(bz\x8F\x88f3\xFD/_\x8B\x7F\xAE\xE7\x11\xBB\x9D\xFE\xE3\x03\xBB)F\x85\xFES\x85c&&j@|9\xE0?\xE4c\xE8\xFB\xFA=\xFEu:\xAC\xF7\xE4\xAD{\xBD\xDB\xF5\x99\xF8bA\x83v=\xF8\xCE\xC5\xBC\x8F\xA6\xBE\xBA\xA4\x11\x11\xE7\xE4\xFC#)\xF8\xA7\x93\xCFq\x03r\xC8\x85\x89\xC3A\x86\xF3\x06\x05:.\xDFH\xFD\xE5#\xAAH?-\xBB\x05c\xC82\xFFg\xCE\xE7\xFFp[\xFD\xEB\xBB\xB9\xFD\xFF\xBF<\xFB\x83\xFD:\x9F\x86\xA0\xDB\xDFoH\xFBOb\xBA\xD8\xF5\x1E\xBA)\xB2J4\xBDX\x03:\xAF\x8A\xC5\xCDz\xF8\x1E.\xC1&\xFE3X]\x94\xFC\x17\xF6\xBF\\\xCEM!]\xCDo~\x19\x1DW\xFE\x7F\xC2\xFE#\x8B\xD4\xB4\xE0\x7Fd}\xFB\xB3+2\x7F\xCA\xE7\xBF\xB0\xC7\xC1\x03\x1F\xE4$w\xFE\xF8\x98\x18~\xCC\x87\x16\x1Bf\xAB\x9Fyk~A:B1#\x97\x9F\xFA@\x88\xFF\x13&F\xEE\xBE\x8A\xF4\xAC7-\xD1D\xE2\xC5\x82\xA5\r\xED\x93\xFCO\xBEp\xD3\x10\xD7\xFF\xD0AJ\xF8vB3\xFB\xB07\xC2\xFF\x1C\x93\x93\xD6\xB5\xA9\x86O\xF9\xF6\x9F\xDC\xE4\xD9\x7F-\xDBA\xA1\xDD\xC8\xF9\xBF\x19\xC0Q\xE1\xEA\xB4\xDA\xFF\xDDL\xFF\xFA\x94\xCF\xFF\xD4\x14\xFF\x9C\\9fJ\xFEW\x17\x99\xFD\xE1;xz\xFB\xD5\xBE\xBA\xC2\xF8\xD7\xF3\x93\r\xE9\xFF\x90\x90s\xDF\xB4ag=\xFE\x1F\x1De\xFC\xEB\x99\xFC\x87F\xD1\x9D9,z\x13\x92s\xE8\xF6\xEC\xCF\xFA\xF5\xEF\x18\xDFxT&\xEB\xDB\x9F\xC4\xCF\n&v\f\xF0\xB7-5\xB6j\xE2K&\x10_b\x99\x97\x19\b\x16\x80\xFA\xD1\xCD\xB7y\xFD\r\xB5|ew\xAE\xD2\xFF9\xEF\xE1\x1C\xB7Q\xB0uh:\xBAg\xE5[\xD3\xF5\xD0\x97,\x8Dr\xFEg\xB7\xE6\x91\xBC\x83\x8E\xE4gvN\xD1\x83\xF4\xF6\xEB8\xFF\x8F4-\x93\x8F\xF1\xF6\x06\x87\xA4\x19\xFF|\x97\xE7@\xFF\xB5\x11\x9F\xFF\xDF\xCE\xA2\xD3\xF6\xFD\x9F\xA3\x9Dn\x98\xFF\x832g{\xB9\xFE\xC7|\xFEg\xEE\xE6E\xEB\xD4\x03\xFDk\xBA\xB4?\xBA\xBF_\xAD)\xF4/ho\xE1\xDF\xB0q$+\xA7\xE2\x1E\xB4?Z\xCE=\x8Edf\x9A~\x14\xDA-\x8C\x7F\xFD\xCF\xD0}3\xB4\x93\x92\x7F\xBA\xAE\xFE\xBFa\xE3\x88\xC3~\x84\x9F,\x87p%\xAF\xFF\xAE\x89\xD9:_)\xA5\xF3g\xFBL\xD4M\xF9\x82\xF7\x89\x07\x14\v\x9C\xEC\xDE}ge?\x06\xC6\x87\xA7n\x19\xAE\xF4\xFE\xB5\xC7\xFF\t\x1B_\xDCg 5%\x87\xC7k:\x12\v\xC5\x8AF\xF71\xFB?;x\x0F=\xB8\xC0\xF87uz0\xDB\xC5\xF7\xF9\x9D)\x13\xC6?\r\x05\xC6M@\xD3t\x13R\xF3\xE4;\xD0\xE7\x02\xFD\xF7e\xD1\xCD\xDFF~\x07\xE6\v\x87\xF8?\xEC7nS\x04)\xD9\xE3@\xD3\xAE-\xB2\x9F\xD4m\xE1\x7F\xEA\x16!:{\x04>\xFFi\x97\xA4\xDD\x8F\xF0^\x83U\x07V;\xFE\x0F{=\x18St\xE6\xEA\xB92\xF4?\xBB\xEA\xCC@#\xFFn\x1C\xAC\xAD\xA1\xD7@\xCE\tK1\xD5\x96\x7F\x9E\xCFy\x8A}\x80\xDCa>\x99\x93\x05Oe\xBFjcV\xDA\xFF\x07\xE7M<]\x03\x92\xCC\xFE\xBB\xE2\x04\xED\xF6 |\x0E9\xE1\xE2\x03\xFB\x1E\xDF`\x9E=`>\x94\xF12\x995\xF1\xA2\xE9 5\v\xC2\xCF\x8F]\x02)~\xF1\xAB.\xB5\t\x9Fki\x9A%BKe\xEE\xFFg\xFF\x19\xE7\xFF\x92\xAD\xEF5q%\xC8po\xCCfm.\xF6\xDB[X\x10\x1D7z\x9F\xDDM\xAFlG\xD2\xFD\x8D\xDA\xBF\x1B\xCF!\xDA\xFE\xF5\xF8\xEF\x12\xFCO\xC8\xE1\x840?\xCA\xFB\x05\b\xDF\xB5A\xF0\xEF\xDB\x7F\xD7\xC6\x11o\x13\xE3\xC4\xAB\x86\xA6\xBBH\xEFNu\x18\xE8h\xBE\"\x06A%j\xE0\x9By\xD9|A\xFE6\xE8tE\x13u\xC8\xF1\xDA\x9B\xDA\x83}\xA2\xBBA\xCBo\x1B\xC7\xF6\x7F\xC5\xBB\xA1Sg\xF2&\x12\xAC\x12\xBC-\x88)t,\xF8\xC9\xDC\xD1!\xF3\xE4\xFC\xD1\x86m[6\xF4n*\xDF\xE0\xB1\xF7\x87\x14][n\xC0\x86\x07Ax\xA3\xBE\xBB\x1B\x89\xCB?yH\x1B\xE2\x81\xFD\x98m\xDA\x94\f5\xCA\xB1\xC6\xB6!{{\xE3\x15^o\xDA\x9FC\x03\x84\xAA\xC8\x97\x82\x82\x82\x82\x82i\x04A\x0F\"\x02Z\xB16a\x7F\xB3\xDD\xFE\xB9\xAC&\rG\xBB\x13\xF2L;\xBAN\xBE\x1F\xED\xBE6\x8C\xF5\xBB)\xE4\xB7z\xBB3cA\xE0\xC2\x94#\xED\xCDkwz\xC0\x9F:\x17\xF3\xAE\xD2}\x1AB\xBB\xFD\xCA\x05km\x7F\"\xC0{FhU\xA5\xD8\x9A\xCE\x82\x10\x8D\x13>\xFF\xDD0\x87l\xB2\xEA\x98\xB1\x86\x19k)@G\x93g\xF2\x8E\x98\x19\xF6|>\xC1<\xAEq\x8F\x7F\xBE y\f\xD8\xC8|~{\xA39\xB5\xEA \xE1`\x88\xBB\x0FC6\x86\xF6\xAD\b\x8F2\xC1\xAE\xBD\xE3]\xF9\x9Ft\xC4\x99\xDC\xD3\x83+\x96\xDFI\xCA%\x1A\f8\x97\xF8\x824\xAD\xFCw\x01_\x84NL|\xB9\xD1\x9E\x98/7\xA0\xB1\xD4\xF8%\x89\x9F\xFB\xFC\x13\x9F\xFF\x9A\xC8\xB0\xCB\xF8\x8F]J;\x92\xFF\x8E3\xD7\xB7o\xE7\x85\xBD\xAFD3\xCD}\xC5\x1Bk\x88\xF1\xBB \xF1L\xCC\xEB,\b\xF8\xA7\x90K\xF4\xA7u\xA4'6\xF2'\xDE\x93v\xE9!b\xD3\xE6D\xDA}\xB3\xB5\x9F\xC6\xE2\x1Ef\xFE\x15\x1A\x92P\xB7\x05M\xFF\xFBC\xEE\x92l]2m^t\xB0T\x9A@\xB7\xFB\xCA=S\x84\xAF7\"Z\x94\xD4\x06\xDD\xAF\v\xFE\x99\xF7\x9Bh\xC7N:\xB2\x00\x8EE\x03?\xF9\xE9?:\x8En\x17\xDD\xE4\xDC\x87\xF8\xD0\xB8n\xF7\"o\"]\xE6'\x9C\xA7\xF8{\xE9\tO\xBC\xE9`$\x8D%\x13\xEB\xADy[4\xB1z\x91Q\xFD\xBA\x03\x90Q&\xA4\xEE\xBD\xCC\xBD<\xE4\xFA\xCF\x9De\xF8\xD1\xEA\xAA\x83\xD5W\x8CE\x1BK6K\xF9\xCA`\xB5m\x82\xE7\"\x8D>\xF2&\x9F\xE2\xB1T\xC3\xF9\x0F\xC9U\xA3E\xDEB\x8B\xE00\x96\xD0m\x88&\x12\x92\xB6\x98\xE0Om\x93\x1Et\xED>b\xC2<\x9C\x8E\xEE\x93\x95vY\xE3.i\x1F\xF5\xEF\xC3<\xE7\n\xE2Wf\x93\x987\x03\xFD\x9F\xA0\x98?8\x8AT}\xAE\xE8\x0E\xD9\x98\x8D\xF2/\xDE\x85Y\x8A\xF61\xFB\xA4\xDE\xC2\xFF\xAC\xC7\xFF7\xA7\x8F#e E\x9E\xAD\x8B\xE1\x9A\xD5\xA3|H\x95hO\x9D\xA0x\\6lw\xF7P\x14\x0F~\xE1Ig]\xFE\xBF\xDC\xC0\xCCVvv\x92\x8F\xEE\x9E\x11\x05\x01N\x9D\x97\xFA\x17\v\x89l\x99\xAEV\xF9J\bs6N;@\xD2x|\x1D\xFB\xF3\x1F\"A\xBF\xE6c|\xBB\xE7y\x1B\xC7\x8Ar\xD5h\xB1\xB4HX\xFF\x8C\xC6\x94\xEB\xF1/\x17\xF10Ms\xE8 9\xFD\xAD)3\xD1<rNk\xD5\x7F\xCC@r\xE2\xB4\x97\xC8\r6\x90*C\xD7f\x938]\v\xEC\xE9\t\x8Ac\xC9*:\x07\xE6\x8BSz\x88\x7Ff\x7F\xF6\xAF\x88\xE1k|\\e\xBB\xDDl\x93\xD1M\x87C\xFC\xCF\xA5\x04\xFFK\xF5\xBA+\xF8?\xB1\x85\t\xEA\xDF8\xF2\xA6\x8F\x89<$gz(\xBE;\x92\xFA\xDE\xFA\xF6\x875\xDBO\xE4\xF9\x9A\x1B\x8C\xFFY\x13\xE8,0N\x92\xB2\xBD=!V\xF6\x98v\xAB\xCCf\x1A\xA7\x1C\xCC\xDB,o3\xDAD\xDB\xD4\xE6Z\x12gf\xF1\xEC\xB7\x1D\x1CM\xC9U\xEBE\xB4\xEDwBz8\xE5@\x8E\xA6f\xFC\xEF\x15C\xDCN\x7F\xBBI\x92\xC4\xA6\xBB'\x97\xAC\xC3\xFA\x1A\xFE\xE1 \t_\xFF\xCC\xE6\xA44t\xAC<v~oM\x06\xEE\xA4\xFE\x8F\xBDp=RE\x9F\x7F\xA1y\xC2\xFF\x89Q\xA1L!^\xA7j\x94\xFFl\x8B\xFE\x1F\xF3\x1E\xF7\xB3\x03\xC7Y{65_\x97\xFAw\x8F\xF1\xA0\x9B\xD0\xFF)\x07\xB3\x92\xFF\x1BW)\x1E\xDF\xFA\xC6\xF1\xF5\xEB\xDF\xC9\x06\x9EH2&7q\xFB\xCF^\x9C\xD4-\x9C\x7F+\xAC\xFF\xDCt\xF5\x88\x03\xBA\xEFR\xBD&\xF8w\x1F\xBB8\xD36\xC1cQ\xFB\xCFcM\xFA36N-\v{U\x10\xD1\xA7\xA5P\x96NP_\xFF.\x92\xFA\x07<cO\x92\x96M\xA9I\xAC\xC3\xC9\xE8n\x83\x89&:z\xC3\xFC\x13\x99\x821;b\xCD\xCB\xCB\x19#\xF5\x1A\x8E\x8F\x18H\x8D~\xBB\xA8\xAF:\x8C@\xE2\xD5\xD7\x93\xCF\xAF\x88x\xC5\xAC\x1D\tp\x85\xF8\x8F.\xA5^C\xD5\xCB\xD8+\xCB\xF3\\\xFF>\xFF\xD5\xA3\x89g}\xFE\x8F\xC2\xE7\xDF\xE8\xA1\xD8\x92\xEC\xAF\x9B\xC1\xE2~kQ\xE5\x86\xCE\xB2\x818\xD7A\x8A\xE5\xFC\xF4y\x19\xE7\xFF\x04Oju\xB9Z\xE5f\xD3\xE3\xDF\x98A\xFB\xFA\xF7\xA9\xC8\xCE)\xA4\xCA;\xF5\xE6k8> \xDEqK<\x86\xDC\xBA\xFA7\x1Co\x9C\xFC\xEA\xF9\xDC\x11\xEA\x9A\x89\xE6\xE1d\xA6\xD5\x9D\xEA\xDA\x80\xE4D\xD4\xFE[\x00\r\xF8\xE7&\xE5\xA9q\xD4\x19\xFF\xD5g\xEEf\x7F\x1E6eu\xC6\xFB\x16%\xE7\x8C\xFF\x8EvK\x1F'#\x9B\xB3\x9B4\xE0\x1F)\x9F\x7Fi\x7FN/\xCD\xF9\xF6\xE7(|\xFBc|\x80\xA2q\xBE\xFF\x84\x19\x99\xBB\x1A\xC6\xAA\x83\x7Fs\x9E\xE5dj\x1C\x88_\xCF\xED\xCF\x01\xAE\x7FY\xE41\x9E\x94=P\xFD\x8B\x06\x86\x0E=[\xAFI\xFB\xBF\x1E\xFF\xDF5#B\xE5\xB1e\xFD[5\x9CZ\x16\xF3\xF5\xDCo\xAC\xB1\x84!\xFD\xEBH\xD2!^\xCC\xA1GV*[\xC9\xE1M\xE5=\r\xB3\x95\xFF\x8E&:V\x90\xD4\xE6<B\xD8%)\v\x1D+!\xFD\xB3\x1B\x1F\xA7\xF8\xCB\x91~\xA4\xE6\xE6\x8B\xFA\x90\xCD\xF8\x17]\xF9]\xC0\xD0!W\xD6\xBF&\xD0\x9Dz/\xF6\xDF\xE7\x7Fhz\x1E\xA9mH-=S4\x84\xFD9\xCA\x97U\xF7\xEB\xDF\xD9qi\x7F>L1tp\xD7\xF1\xF5\xF97 \xED\x0F+\x02\x99c\xB7H59\xFF\x0FI\xFE9\x9FG\x06\xEA\x8F\x01\xD7\xF7\xCF\xD5\x1D\xEE\x90&'\x1E\xBB8\xD56\xC1\xF9\xA8\xFE\x99\xB5\xE98\xFB\x8C\xE9\xEB\xDF|\\\xD4\x80\x8D\x16\xFD\xEF\xF6\xF8\xCFK\xFF\xA7\xAC3\xFEo.\xCF\x98\x8DV\xFBs\x1D\xE1\xFEO\xC0?\x15\xFCk\xFA\xEC\x88\xB5$\xA7\xF9\x8C\v\xFEk\x87\xFA\x91\xCA\xCE\x17uj\xE3\xB2\xC7\xFF\x87y\xF7\x96\xA8\x8B\x19\xFF\x9A\xFE\xAE\xF6\xFF^\x8A\xAA7\x81\x88N\xD7\xD1=\x86\x14\xF9\xB6\xE4\xDFh\xE5\xDF{\x82\x1F\xA1\xA0\x07\x8B\x8C\xFFub\x8CC\ri\x7FX\x11\x88}\xD8\x96\xFE\xCF\xE2A\x99%\xB1\xA8\xD1\xE1\x81\x1F\xCD\x02\x8B\x85\xB9\xA7\xA8\xB4?\xB3\xFD\xEF\x81\x7F\xA1\x7F\xAD0oz\xFAGM\xD4b\xB4\xD5\xFE\xDF\xE2\xF9\xFF!\xFE?K\x8E\xD0\xF2\xCC\xF0-o\xB6\xD4\xBF1\xCE\x7F\x9A,\x85VlCw\x05\x9A\xBER\xAA\xE8\xB2\xCF\x82\x99\xD2s\x14\xAF\x9A\x16\xBA\xC9\xD2=\x8C\x7F\xE2\xF1\xBF0\x0E\xD2\xD1+\xF2\xB0B\xD7\xE1?\x1D\xD9}\xFD\b\xC5\x15\x9F\xFFC_B\xAC\xCA\xFC\xFF\x93\xBCP\xDD\xC6+\x89\x93a\xFF_\xB6\x14\xD2\xC6a\nzh\xFA\x9C)&\xEF\xB4\x1B\xE5f\xE2\xF2\xA0\xC7\xBF>~\xD9\xE4\x05\x01HI\xC6\xFC\xF7\xF1\x9B\x1E\xF9P\xF9\nE\xDF\xD4\xDC9\x8As\xCC\xA4\x1BW\xFAg\xDB&\x18\xAEX\xA1\xE9WL\xA6\xFF\xD7j8\xF7!\xB1fc\xAF\x18\xED\x13\xE6\xFF<\x05\xBAE\xAF\xDD6`\xBBo\x7F\bn\xB0\xC7\xDD\x8D?\xE9N\x9F\xEB\x8E\xF2\xCF\xED\x0Fz{i\xC8\xFE\xE0qt\xAC\xE8\xE6\x81[\x84\x03\xD0\xCD.\xD1\xC7\xD1\xD5W\x06z\xBB\xC6\x99\xFD\xE9m\x04\xF6\x7F\xF5\x8D\r\xE2\x1D\xD4)\"k\xE2E\x1A\xE3\xA1*g\x1C\xBD\x9Ek1\xB4O\xE3\x96\xE3\x86$\x95\x93\xFD\x13\xBCA/\x1A\xC8iG6\x84\x01\xA3\xC7\xC1\x90\xFD\xB8\xDE@c\x9D\xD5ub6:x#\x9A\x15A\xBF\xB1\x8B\xF2\x85\xDD\x80^*'\xD7\x1C\xA0\xE2\xEEn\xC2\xC1\xDE\xCF>\x9Bv\xC4\xB4y7qq\xB1\xFD8\xAF\xB0y\xEF\xDA\xC0\xF7?\xE9\xED\xA6\xD0\xC5J}]\x1B:\xECV\xFB\x93\xF4\xA6K(((((\xFC#\x87\xF6\x9B\x05\xEA#\xE8i\xED,X\xBB\xDB\xABA\xDA\x84\xBE\xE9\xBA\xA1\xF3\xF7\xD0g\x11\xE3'\x8A~\x01>h\x8D_e\xB7Is\xED\xE4\x02q\xF7\x98\xDC\x92 Z\x99\xAE\xDBhh\x13\xD1\b\x17*&\xA34X\xA7\x97\xC4G\xC1\xEB\xC4\x98\xF1\x17FJ8\xD0v\x06\x01\xB1\r\xF4\xD3\x82\xFF\xB4\x83\x8D\xCE\xB53&\xF8\xCF\x01{\x01WP\x9A\xB0\xBF\x0E\xEF\xF24\xBF|\xA3\x13\xE5?\xCDGT\xA6y\xB3\x86\xCA\x8E\x80ng{Z\xDE\xEB\xD1\xF7\xC8\x7F\x87\xC7\x7F\x0Fs&\xCB\xC03\xA8\xCD\xB7iU\xD0\x89D\x03\x04M=\xB2t6\x8D\xC5V\x88\xD82 4 ?\xD7.p\x94vh{\xFE\xC7\x03\xB9\xF2\x89\xFC\xDC\xA5L?\x9B\xA4\xD7\xE4?\xD6\xCA\xFF\x15\x8A\xF0.vo\x9C\xEA\x15N\xE3\x9B\xC0\xA2\x1D\xEEpY\xA7Es1\x87\xB4\x85n\xEE\xA6\x02\xE7\xEE\x91q\xF2W\x80s\xFC\xF2W\xD27\xFA\x97\xF3!p\"d\xB8\x9Dy\xC2%y\xE3\xC5\xC1\x17\xE5\xBD\xBA\xAF\xBE;\xFD|\xD2D\xD3\xE6\xA9u\xB3\xCFo_\xBC\x8A\xEE\xCA\xC5\x8Bm\xC2\xAA\xE7?d\x9D\xB3\xB1z\xA1\xE2\x9E\xACFR\xB8`\xAD^p\t\xEF\x118\xE7\xB1\xDBv\xA7\xE67\xBB\xDD\xB6\x01\xDB\xD7\xBD\x93\xFF\xBE\xC1C\xFA\xE2\x1C\xBD|\xD1\xB9V\xCE\xD1\xFD\xAC_\x04x\x01\xC9\xD3\xAF\x07\xE9\xCF\x9Fx(O\xE5q\xBF\xC1{\r\xFD?\x98\x9C@r/R.\xBAY\x9B\xFA?|P\xA6{\xDA\xC1\x93\xFC\xE37\x93\x86\x1F\r`MZ\xA1\xFF\xC4\x12o\xF5\xCBFe\xBD^\x94\xF7\xEA,\xBE;\xFF1c\xDE\xC6|\x8D\xFD \xC5^.:=\x8DT\xE5\xF8t\x1B\xFD\x9FZn\x9Ev@R\xCDj=\xC4aJ\x9B\x9D.\xDFW,\xAE\xF2\x9E\x82\xBF\xA4\xD7\x92\xD9c\xCB\xE5`?\xEBp\xCB\xD7\xBBj\xD6\xC4Q\xD3\x8B\x9F\xA4\xCBs\xD7\xC8y\xAA\x88\x14\xD7\x7Fj\xFA\x84wl\x96bn\x7F.\xC4\xBF!\xF4_\xA5<R\xE1\x85m\xD7\xC3\xE9\x17\nHZH\x95\x91:\xCE\xCA\xFB\xA2\xED\xB7\xB2\x8F\xF3\x8FO\x9D\x98\b\xF8\xB7=\xFD\xF3\xDD\x0F\xE7\x0E\xCA\x98\xCF|\xB1x\xD2\xF1r\xF8\x1E\xF4\x1F\xE2\xDF\x1D\xB2A\xBF\xB6\x8C\x94{j\xFA\x99\xB5\xE7\xD6RS\xF5\x1A&_\xAC<Q\x0F\xAF\xCA\xD2|\xECk\x13\xF7\x15\x97{lV\xB4S^\xE9\x0E\xB73\x1D\xB3\x03n[\xFE\xBF\xE9\v\xB8!bt\xA2\xFD\xF8;\xA7\xAF\xA1\xFF\xCE\xAB\xE8\xE4K3u.\x9F\b\xE9\x7F\xEED0\x17\xFB\xF4\tW\xE8\xBFJQ\xF7\"\x00\xDD\xEB'\x99M\xBAR\xFF|\xD8y-\xF5\xB8\xAF\x7F\xC1\xFF\xD1\x17\xF2\xBE\xAEB\xFAg\xA7=\xF5\x07\x9F\x96\xFA\x7F\xF2\xEAq\xEA\xE5\xF0]\xA1\xE7O;8]\xC37\xF9\xDA\x1D\x04x{\xB9\x8E\xCE\xDA\xF1\xBA\xDDN\xFFn\xBD\x06:\xDD\xA2\xFF\xCAL\n\x7F\xFA\xE2\xE8\xAD&\xB39~\x7FA[\xFE\x99\xFE\xE3ck\x8F\xD7\xBD\xABf\x81o\x85\xF4\x7F\xF4Z\xFA\xCF\xCB\x15ZR\xF5Sf\xA0\xFF\xA7\xFE\xD5\x8FB\xFA\xA7b\xC1\xFF#N\xC0\xFF\x87\xD7\xF7J\x86\x98\xFE\x81\xD4\x8CH\xF9\xD4\x8B\xBF\xF4\xF5/^\x9Fo\x1D\x9C\xF0\xCB\xF5\x17\xCC\xFE\xF3jS\xFF4\xB7?yO\xA5E\xC9\xFF{\xD1\x7F\xE7\xD5\xA3<,6o\xB3\x82\xB0w3UG\xEA\xD9\x93\xF56V\xFAh\xAA\xFF)\x07C\xD3\xE6\x13u+\xAC\xFF#\xCB\xCB$\xF5\xCB_P\f\xD9\x81\xFE\x8F\xAC\xA7\x7F=\xBF\xF6\xF8\x93\x8D@\xC0u\xB1A\fK\xF9\xE9S\xD7\xD6\x7FJ\xE8\xFF\\=\xC4\xFF7C\xE6\xE5\xE4\x89\t9F\x1C\x01\xFF\v\xE3\xD7\xD0\x7F\x81\xDD:\xE5\"\xB5\xC2\x98\xBC\x9B\xB6\xD8\x9F\xEF\x1D\xCC\x1F\xF5\xCA\xC5'Y\t\xFE\xF99[e\xB9N.\xFB\xF6\xE73\xEF\xC1].\x9Cr0\xDF\xC0\xF7\xC6\x99\xFD\xC9\xD9x\xFBW\xCBH\x9D\xAD\xD7\x8Dv\xFA\x7F\xF1\x04EO\xCA\x9D\xA9\xEF\x8D\xE8\x7F\xA0\xBE\xCAC\x94a\xFD\xB7\xAD\xE6\x1E[\xBE\xBEm\xFD\x1B\xD6\xFF\x7FtD\x8F2S\xC2\x89k\xF8?\xA9it\n\xFDO=\x19\xB2?O\xDD\xD9\f\xF1\xFF\xB2\xD8\xCA\xFC1'\xB0\xFF\xD7h\x11\f\x9D\x9F@R\xE3\xFAg\xF6\x7Fn\x9A\xB6\xD4\xBFG_\x98\xF8E\xC8TB\x04\xB7y\b\xEE\xC4\xC8\x1F\xC9^\xD4\x81\xCF,\xCB>\x94\xE2{\xF1?OP\xFC{\x93\xEB6U]u0=0\xCD\xF4\x7Fw;\x96\xEA7\x9Cv\xB0\xFA\xABrT\xFF\x95\xEA\xF4\x95\xDC\xDD|\x13\xA8\x90\xFE\x87\xDA\xBD\xE6\xB3w\xBB\x88\xB7\xE9|9\x15\"\x90/\x9E\xC3\xED\x7F\xBA~-\xFD\xA7\x96d\xCFK\xE7\xECw\xBC\xC7w\t\x98/\x07O\xFE\xCA\x89\xD1\x19\xD3\xAB\x97\xBD\xFC\xBC\xBD\xBE\xFD\xA1#B\xFF\x8F\xA3\x9BS\x9A\x92\xFC\x1F\x85\xD4\xFF\xB7N\x18\xBE\xFD9,\x16r\xF7\x96\x94\xFF\xA6g\x7F\xEA\xF5\x9F\xCB{%\xEFyw\xFA\x13\xCD\x13\x14\x7F%V\x98I\xB9\xD4\xC6\xF4\x07\xCF 5u\xBCxK;\xFE?3g\x83NW\xA3\xFAoV\xA7\xBF\x9B-\x1A\xF7\x9AL\xF3\xFEJY\xB4]1\xFF\xBCh ~\xA5M\xCD\xEE}\x98\xA1\xF86\xD3\xFF\x94\xB0?\xD7\xB2\xFF\x9D9\xA4\xC4i?\x9B\xF3_:\x13\xAF\x86\xF8\x9F\x1F\xFC\xA8\xE0\xFF\n\r\xFC\xFF\xE9\xF5\xDF)Z* \xAD\xA1;'\xD6\xDE9w\xCF\xFD\xBE\xFF/B\xDF+\xA7\\\x9F\xFF7\xA3\xFC/\x1D\x92\xFC/\x95\n\x9A\xEC\xC7\xFC\xC2\xBB\xF3O\xC8\xF9q\xFCRD\xE6\xBB\xAB\xD4\xC6\xDB\x17\xBE\x83\xEE\xD97O\xB6\xA9%\x97OM/\x99\xA0\x8F^v/\x84\xF4\xDF\x8D+'\x97\xFB\x1E}x\x8F\xC9|\xCEs\xF6\xB5\xF8\x7F\xF3\xD1\xFE\xC8\x16\xDB\x1E\x16=\x02\x7FM\xB1Dyg\n#\xB6\xFC\xCA5\xECO\xF7\x00\xBA\xF9\xCB\xD6=\xB7\xE8=?\x9D\xE2\x86O5C\xCD:ccC\xB6\x8B\xFD\xF6\xEF[\xD7h\x7F5&\xF8h\xAE3\xA2I\xB5\xE5\xE8\x01\xBF\xFD+\xA6\x8Aw\xC082\xEE\xB7%\x81\xE4\xDF\xF9\xF6\xA7w\\\xC6\xFCSsw\xC9\xF6ol\xEA\xBD\xE8?\xC6\xC7\x00\xF0\xED\x9F\xFEl\xC8\xC64=\x00,\xBE\xBF\xAF\xCD\x10)}\xFC\x96^V\xC9v\x19\xF6\xAEP\v\xC2\xEDu\xEA+\x9F<`\xF2I\x7F\xDD\xE3\xD7\xB2?\xDD\xE3?\n\xCF\xC8\x0E\x82\xFD\x1E\xCF\xEF\x1B\x17=\x11\xA2\xFDu }\xAD\x85\xFD_F\x87X\x1A\xF4\xCCuj\x16\x80\x82\x82\x82\xC2?z\x10\xBB\xFD\x98\xD8\x98\\\xA5\xA7mU\x91\vG\xF2u@\xB3\xF9\xEA7-)\x9B\xAD\x7F\xB6kJ\xD05\x99\x91\x81w\xDDn\x8D\xE4\xEB\xA1[h\xC1%\x85P\xE0\x9D^\xA3\xCDB\xB0\xCE\xE8\xC7\xB6q\x0Ev\xF7\xDD\xA1\xCF\xBFi?\xC5?\x88\xFF\xB4\x83\x98V\xE0\xF3\xFF\xDE\x8D\xFF\x98\x9Bt\x90\xB2\x91r\xD6\xF0o\xB7\xFE\xA9A\f\x8E\rO\x01xf\xED%_n \xD1h\xC3\x7F\xA7\x13\t\xBC\x87\xF9\xF7F\xB5K_%\xBD&f\xF8?\xD4Z\xF9\x8F;\xB8\xC7sW\xBE\xE2\xA0\xDB\t\xF9i\x8Cs\xF7\xCB\x8D1\x9F\x7F\xC2C\xAF\xFFS\x83\xAF\xD2\x83'\xFC0\xB2\x88n\xC9\x0FkZ\xCA\xFE\xA6\xC3\xE1\xE0\xF9\xDA\x8D\x89\xD7^x\x8EO8]\xC4:\xC3\x95\xBB\xBD\x83\xDDM\xA4\xB5U\x8A_9X\xB5\xD1\x12\xFD^u\xDAd\xA6\xC8\xFC\xF6\xD03\xED\xAE\xAD\xBD\xA4hb\xE9\x1E\xF7B\xE8r\x91\xF2\x1B6\xBBKK\xE2\xAB\x17\xDC`(\x8E\x97\xF2\xDA\xF1\"\x8B\xB5\xD6\x92\xBE\xDF\fb,;(\x96\xBD\xCF\xAF\x89\xFD\xC5.X\xC5\xD2\x15\xFF^\x93|\xC1\xA2_R\xA0[\xE3k\x86\xCB-\xBD\xC4\xC2\xDD\xB6X\xCETo]y\xB8\xC2\x8F\xDB\xFD\xDE\x9A\xB4\xFA\x9C\xD8\xFF+\xBC\xC5\xD8|;\xFD?\xD9\xC0\xD1d\xE6\xB4#G\xA8\xAEiJ\xE7\x82\x0FI\xF7\x04E\xDDf?OG\xB8\fZ\xD0~\x80qN\xE8?\x15z\xA6\x9D\x91\xE7+\xD6\xED,\x9A8\xB5\x9C\xFB\xABP\xA6D\xBB\xF2?9\xF0#\xE7\xC7\xBCg8?\xCDr\xF8\xEDF$\xB5\xB5q\xE0z\x8D\xF7\xB0\xA4\x02\xFD_qP\xF4^\x93I\x07'\xBDK\xC4\xB5\xC7\xA7\xF7\xAE.?!\xC3Y\xA2w&f\xB0\xAF:]9\x80V\xF0\xCF\x17\x8C]\x8F\x7F\xB1\xCC\xEF\xC1~/\xAE\x92\xCC\xB0\xD3:\xAF\x86#\xBD\xA7\x1C\xACmb\xD4M\x9Cz\xCD\x98\xA7\xEB\xF1\xEF\x06\xEC%\xC7\xBE\xCF\x83\xA5'C!\xD3\x96 \x89\f0:\x1E-\xA9\xB96\x8FR\x04\xA0\x1A\xD2\xFE\xD4\xEBnxt\xDF1\xFE\xB9N\x03\xFE\xFD\xB1\xAFs<\x87\xF2\xE4T\xDDg\xBB\x05\xDF\x17\xFAO\x05\xC1\x84S5\x9C\xF4N+\xD8\xC1%\xF3\xFC\xC3\xE9e\x8BN\x7FW>\x91\x86|w\xD8CO\xCD\xA2sQ\xF0\x7F\xC4\xE3\xFF\b\xE5S!\xD6\xC4\xCFgk\xEC\xF8\xE9\xBA7\xE45\x95:\xCD\x17\xBE\b\xEB\xFFD\xBB1\x81L\xFF\x89\x95\xD3\x8DV}\x06]9\x81\xFE\xC7\x8EQF\xAC\x1C-\x1C\x95\\\x8B\xFEk\x94\xBF\xC8\xA9\x90\xCDOE\xB6>\xFCnMV\x94\xF5z9|\xB5H\xF9I'\xB8\xC5\xB7\xBD\xAFO\xFF\xCA\r\x9EuJ\x0E\xAE;\xB5\xA6\x86\xAC\x89\x8D\x86S\xC1\xDEv\xF3\x0E\xCEy\x89L\xAC\xD1\x7F\xFDIw\xE8k\x0F\x88#\x7Fe\xE2?\xD5\x002\x7Fz\\\xE8_n\xE9~\xD8\xE3\xFF\xF0:\xFA\xFF+\xA1\xFF\xAD\xDE\xF1\xEB\xFE\xAE\"\x96k\x0E\r\xB2e9_3&\xF08pzI\x9B\xC7:\xFA\xF7\x1FJg\x13\xC9\xBD\xDF\xE7\xD1\xE6\x93\xB5V\xC2\x9FZ\xA3\xFFSb\x9D\x9FT\xC8<\xA7\"#oOy;\xBC\x9F\\v\xC3Os\xDE\xD3\xBFov\xFC[\xCDO\x8FI\x15\xB1\xD4\x8E\x87\xCF\x8F\xBCY51r;\xD0\xFFS\xB5\xA0\xFE\xFD\b\xC5\t\xEF\x92:\x15\xFA\xAF\xD3iY\xFF\x9E\x10\x1B\xE6&\x9E\xE1\xFA/\"U\xF3\xF5?=\x10\xE2\xBFu\xE8>\xFE\x86\xE2Qf\x7F\xBC5\xE1\xF9%\x8C\xFC\xCEL\xC4\xB4\xAE\xD9c\xF4\xA4\x83\xF9\x9D\xEE\xB7\x9Du\xFAD\x02\xFD\xD7\x914\x8E9R\xFF-\xFC\x1F\x8F\xBAN\xB3<h\xC9\x8D\xC0\x13\xEB\xD9\x7F\x91@\x0Fp4U>f\xB6\x9A\xB2\xD3\x0EN\xD3V\xE36?\xFD\xB3\xE0\xCF\xF5\xED\xFF_\xD6\xF8\xB8\xF4T0\x92\xF6\xBB\x0E\xA6\xBC\xD7\xE4\x81\x1A\xBEC\x83\xB2\xF3\xD8\xE9\x85\xA1\xAF\xC9\x87\xF5\xFDq~m\xCC\xF8\xB6\xB0\xFF\xE2.\xBA6Cq\xF8\xE6\x1B\x05\xFF\xD3\xDEN\x07-\xF6\xFF\x1B\x14\xA7\x8Fg\xFD.\x18\xBE\x84K\x11\xD7E\xF5\xBF\xC6\xC9\xA9\xD7\xF0\xED3\xFAwj@\xEAo\xAFi\xFFO\"\xE9~\x9F2\xF9\x9D^c\x7FZ\xFE|\xCC\xEFl\xED^^\xCF\xFE\x88K\xDEvpj\xD9\r\xF3/\x1EeX\xFF\xF5\xC0\xFE|4\xA4\x7FY\xD2\xB5\xFD\xE0'\xA5\xFD\xFF;\xFF\xC8k\xB5\xC0\x89\x1A\re\xFE\x84\xA7\x7F\xB3(\xEDO\xDD\xF3\x12\x9F\xA5\xA1\xDDg\xB8\xFD\xA9\x1D\xD7\x84\xFD?\xDC\xB6\xFE\xE5\xFD\xD4\x87\xFB\xBD\xCD#\xF4\xE2ai\x7F\xA2\xFA\xD7\xE6\xDB\xE8\xFF\xCE\x95:\xB3\xFF\xED\xFA\xA4R^}\x91\xFA<\xBA\xAB\xA2\xB7\xB1VCK\xA5W3[\xF5?o\v\xFF'\xB4\xDDs\xE7M\x91\x1ECH\xFF\xE7\x9B\xA9\xDDO\xD6Z\xF5\xFF\xA4\x83\x93\xB4\xF5\xE1\x1E\xAF\x8F\x05\x7F\xA6\xBE\xD7\xD2?\x18X0\x8A\x8C)\xB7\xE8\x11\xF8\xF7N\xD0\xE7\xFB@-0Y\xA2R>1p\xE1\xED\xE5+\xFE\xBDn3\x81\x8E\xDEo\xB2'x\xD5\xD7\xFF\x11\xBE\xA5\xAC\xF0\x7Fj\xACb\xBD\xAD\xB5\xFB\xAC\xC6\xEC\xD2\xE1\x0Fzw\xD5?~D\xF8?\xC9\xE0\xCC_\xDAr@B\x8B\xFF\xFF\xFA\x19}\xD1\x06\xBA\x8A\xD7\xF2\xFF\xD3'\xA1=\xEDR\x9C\xA3X\x0E\xB9\xD02\xB0\x1F\xE5\xFF\x8A\x89%\x9B\xFB\xFF\xB1\xD0l\xA3\xEE\x88\xFD?oJ\xFE_+Y\xAF\xACI\xEA\xBC\x89_{\x8C\xF9\xDF^<9\x1B\x04\xE4\xBDF\xD4\x855Y\xFE5\xC5+6\x90\x0E\xBA\t\xB4Z\xD0\xE7\xFB\x9DF0\xA4\xE7\x1C?\xE8\x9Ez\xBAX\x92'\x9F3\xF1\xD7\x9C\xA5e\nt\r\xA0{\xD4\xF7?m\xCF\xFF\x17\x9B\x11\xB7\xB6\x93\xF9q\xF1\x8C\xF8%yyZ\xE8\xCC\xDEq \xF9\xCC\xDA\xF6o\xEF\xA6\x95\x8D\x0E@\xDA.\xF1\xE5\xE9_\xABC;\x90\x1A\xC7-\xE3\xE8\xA1\xC8D\xF9\xD7\xA2\"L4\xB0\xD1\xE1\xFA\xD7B\xE6\xAE#b\xFA\xFE\t\x95\xFE\xE7\x07\xFA~gc\xC8|\x89\xD9\x07\xDD\xA1\x8D\x9B\x13~\v|\x9Cy\x89]\x82\xFF\x0E\xB9\t\xEF\xADk\xEC\xFF\xC6q\xDC1\x0E\xC4\x82\xEDQ\xEE\xA8\xC1\xF6Z\xD3\x8FP\xCE\x83\x8C\xF9\x8B\xBE\x83\xEC\x97\xCFH\xFB3T\xC3\x1D\xCCK\x7F\x86\xEF\v\xF6w2\xCFi\xD7\x1E\xC7*\x9F\xAE\xFB\x0Fi\xFF*(((((\xAC\x0F\xB3]\xED\xDB\xBA.\xD0:\x9F\xCD\xE8P\xFC\xF5\xD6\xD21BW\xBD\xEBJ\xFF\x91P\xB7\xD6z\xFE\xBB/\xD7\xA3\x9Bm\xF2|\xED\xBE\x89p\xE0?\x16\x8A\xAES\xDB\xDF+`\xDD\xFB\xC6\xE4\xE6\xB6F\x8Fw\xC7\xF0F\xFCrmC\xAF^\x16\xF5u8\xB8\x1D&d\xCBW\xDD0\xFF}\x01\v\xEE0#\xA6K\xFC5\xCC7\x12\xF5\xBBa\xD8W\xDA^\x8B\xB8\x84\xAC\x93I~\\^E\xF2b\x18d\x1F\xBC\x05l\xB5\xAE\xE0\xCCq\xBE\xDErh`p6o\xCA\x1D\xF1dN\xDA\xDCb\x8B\x03\xF35w\xD0\xF3\x8B,\x7F%av\xEB\x07\xD6\x9E\xCF\x12\xD7r\x00v\x9E\xD9\x9B\xF76A6\xB9\x83\xB7e\xB1{\x98\xF2E\f|\xFEI\xAA\xCF+Bk\xB1\x1Cx\xC57\xA01\xFE\x87\xF9q\xDE^.\x8AY#\xDF\xE8\xCFC\x1F\xE0\xED\xB2\"\xDF\xAB+\x13\xC44dK3\xE0\x9FV\xBCf#\x8F\x9An\x1E\x0FJ\xCD\xF9\xFF\x9C\xCF\xBF\x8Cl\x92\t\xF0\xA5\x80\xA1Y;\x97\xF4\\e\x1D\xD7\x8B\x17\xB0\xE4\x88=\xE0\xF2\xC3\x1E9r\x85U\xEDs\xFE\x89;m\xC9\xBF\xFF\x0E\f.N\xF8\x9B3\n%\xB4\xE91\xA2(\x91@-\xA6\xC7^_cMG\x91\xFF\x82\xF1\xB5\x9D\v|\xDDT\x91\xBE\x10CN\xBBTr\xB0'<\xAF!\xEEn\xE1\xBF\xD7\xA6\xB3\x933\xC7NN\xCF@s'\x1B2\x91*\x8F\x97\x8A\x05d\xE6\x9F\xBC\xCA\x94\xDFyY\xEC\xF9x\xFAD&\x88\xA9B\xFC\x0E\xF3\xEF\x0F\xE9g\x077\xD7Z\xF8\x97g\x8E\x04\xFC\x97\xE5\xD2\xE7\xDAC;rz\xAE\xB2\x9EEa\x05\x1C\x11\x1E>q\x05\xFF\xD9\x80\xFF \x03\x9C\xFAg\xC3\xFA\x1F\xD6\xCAQ\xFE\xDB\xEB\xBF@\x9A~c\xAF\xE4\x84\xF5\xDF&;\x8CU\xFE\x1C\xF7,\xF6\x97jR\x1E\x05\xFE\xA06\xE7\v\xC3\b\xF4\xDF\xC7\xF4\xA0\xF3l[k\xD3\x11\xEB\t\x8B\xD7\x1FZ\xAE\x07\xC8\xF3\v\xBF\xC9\x03\xD1b\xFD\xD8\xD3\xC7\xF3\xD0\xB3\xD0\xAB\"\x82]\xF9\xE0U\xD1w#\xD6\xA5g\xEFH\xA8\x83\xE0R\x94\xFF\xBF\x0Fv:6\xF8\xE4nI\xD4y>7\x84\xB7g\xCA\xB2CJ\x1B;?h\xDC\xFE\x93u\xF8\xEF\x9E\t\xD6\xB3\xEA\xCE\x9F\xE7\xC9\xE6L\xFCJ<\xDFt\xC0?k\x04\xA5+\xE1\x19+\xCF\xA5\xAFF\xECO:\xBB6\xF9+\x14\xE7\xBA+\xFE\xB2ZW\xBC\xF4\xDED\xB4?\xCE\xC3\xFB\xBC\x9B\x9E\x1F\x9CY\xB4\x81n\xF6|\xC5`\xB9\xB7\x06?t\xD1\x81\xDF\xC2\xFB|\x03\xE8>\xC7\xB3\xDD\x86\xFF\x02\xCF\xFF\xEB\r =\x8Btn\xA3\xD7\x96\x17\x1D1\"\x9C8=\xE8\xA2\xB3\xCE^\x01>?bu9%\x04 \x9A\xE7-\xF6\x9FV\x8C>\xAF5\x07\xE0\xB7\x83\x05\x8D{\xD9\xB3&rT\xDB\x88\xE3\xCD\xA8\"\x9F\x07p'#\xCD\x1A\xB1\x8C\x7F\x91\xDB\xBB\x8E\xFE\x9Ba\xFB\xB3\xC3\x94\xB7.\n\xFEC+ -\xD9r\xA3@?zf\x96\x8BQ\xFD[\xED\xED\xCFRe\xCB\x1A\xFB\xCFj\x84v\xF6\xFFO\x1B\xF2\xA6\xA5\xC5\x89]\xE3\xF2\xF5\xBC\x87g\xA6_\xBB4B\xB1\x83\x86\xFAkH\x9D\xBD\xEC\xA4\xBE6\x1D\xC7\xBF]|\f\x9A\xDB\xE3\xBD\xD1\xCC\xAA\xA4\x8A\"\x00\xB5z>\xC3#\xC9\x19A\xE9a\xAE\xFFzM\xEA\xFFpt\xD1\xB0\xBE\x1D~-f\xCA\x9D\x9Ae\xA9\xAF\x1F\t\xBD\x83#\xFE\x8C6\xE2\xED,\xA9\xB9\xC3\xE4\xF6\x039k\x1D\xFE+!\xFB#\xED?\xA5>\xFFA\x18\xC4\xF2\x02V\xBE\xFE\xAD\x07\x8Bb\xDBD/'\xFD\xEB\xD9\x1F\x7F\x90\xA7\xCF?\xCB>Yh\xA3\x7F*o:\x92\x1D\x1D\xF6\xAA'\x91\x19\x9A'%\x07;\xC2\vb\x90:\xB7\xFF\x99\xB5\xE9\x88\x82|\xAC\x01\xC4o\x87\xC64#L\xDF\x14\xD7\xBF\x90\x10#\xBC\xB3\xCA\xED\xFFm|\x01\x96T\x10\xB0\x95\x13\x13B\xFC[\xC6'\xC3\xF6?\xA8\x7F3-\xFCo\x96\xFC\xFF\x96\xC7\xBF5L\xC6\bY\x8F\xFF\xF9\x10\xFF\x13\"\xDB[\x1A\xB8{\r\xFF;Xyg\xC3\xFC\x13\xEDK\x11\x97Uk\xC3\xC3f`7\xA9\xF8\xFC\xFB\xB5'\xD3R\xBCM\x96~\xCD\xEC\xFF\x14\xE7\x7F\xE2\xCE\x86\xF4m\x04\xFF\x83\x8B\xEE\b\xC5Hx~\x1CY\xE2\xD9nS\xEF\b\xB6\xC7Ln\x7F4\xF4@.Kr\x88w\xE5\xD4x\x82'\x99\xFD\xCF\xF0\t2\xCB\xCC\x1C=yUt\xD8\xED\xA3\x9E\xA7\x14*]\xD62\xE4(k\xE1\xFF\x84j\xBDu\xF8_\x14\xBB\x11A\xB3\xF2\x95\xEA\xE4\xC2:\xFC\xF3a\xF6%'\xE2\x7F\xE6L|F\xF0\xDFq6\xD0\x7FC\xBE,~\xFD;T\xBE+\xD2\x85\xA7=\xD4\x86\x7F\x8A\x8F\xB5\xB3?}h_o^\xEF\xF9Q\xA5\xC5\xD1\xFF\xD5\xF6\xF4o\x06\xFA\xFF]\xEFL\xBE\x9A\x10Y\xCF\xFF\xB9\xD3\xF6\xF8\xD7n\x866\x91\xB3Q\xE2\xAC\x1E\xA4\x81\xFF3\xC5\xF4_g\x95/\xEF\x17\xFE?\xB8\xFFy\xBA&\xC3\xE3\xDF\x89\xFA?\xB7\xF5{\xF6\x9F\x1F\f-\xD7.\xF8\xAF\xF8\xFCo\xB3\x03\xFB\xC3\xF8\xEFX\xC8W2\xEB\xEA\x9F/b9\f\xBE\xE6\xBBg\x7Fn7qV\xD8\xB7\xAE@\xFF_\xA8\xC9\xBB\xF8n\v\xE9\x88n\x85\xD4\xD1f\x89\x9B\xDBk\xB0r\xCD[\xD6\xD8\x9F[\xED\xF6\xFC\xB3\x87\xCB\xD3)lr_\xF0|\xFB{\xF8U\xB7\xDFi1\xFD\x87=\xD5\xF82K\xB9\x9D\xFE\xFF\xD4\xF4\xECOz\x1E\x1D\xF9_\x8CK\x8F\x88wFK\xFF\xFF \xF3\xFF\x8B\xBC_\x9E\xD52S\xBC\xBF\xDE\xF6\xF6\x85i\xB1\xFF\vQ\xFE\x17|\xFB\xDF%\xFC\x9F\x8A\xEF\xFF<'c\xF2,\x83\x8E\xC9\xDC\x83\xA5\x92A\xBA\xD7q@\xBBo\x17Q\xFD\x06_\x0EH\x84\xF7\x9Fo\xF8{\x0E\x04\xFC\x9F\xB5\xBDu{|\x06\xBA\xF2\x11\xFE\xBBn_\x9B\xFC\x82\x89\xA5\x0F\xA1\xE1\x07\xF9\xBD\xD3\x9F3\xDB\xFB-\xC4K\xE7\xD2\x87F5[.\xDAy\x89\xCB\xF5\xCC\xAE\xDCy\x8A\xF34tfw\xE6%\x7Fa\xCF(^\xE0\xA7]\xE2K\xDF\xA3+O\x80\x8B\xF47o\xFF\x86\xE2\xD5\xBD}^\xFD\xCB\x0F&\x82H\xBB\xC1G\x8EIV6:\xBE['\x96\xC4\x07\xF0\xF5^j\xAC:\xEB\xAD~sF\xB4\xD3y\"\x131\xAF\xE9\xAC\x8B\xFA%\x16d\x80\xAF9\xF0\xF5\xC8\x10,g\"\x1AQ?\xB36\xF5\x04E\xE2\x15\xD7\x1F\x9F\x1F\x8D?\xECj\xEF\xFF\xF3t\f\xE7\xA3]\xE3r\x84\xBF\xE8\x9E@\xA3+9\x8Ed\xB8\xFD\x85\x07\xD7\x8B?\xC4<6\x18\xFF\x98`\xAF\xD5\xB8\ng)(((\xFC\xA3\x86\xA8\x83\xB4\xF5\xA3\xF1\xD7\x8A\xBF\x9B\x9E\v\xA4\xBD\xA7\xF3c\xFE\x10\xAF\x18_\xBDG\\\xEE-\xDAC\xDAt\x19\x18\b\xBA\f\xBCP|,\xE4\xB4c\xFDu\x84\xE4\xBD\xACPV\xE9\xBAa\xF9P\xE6\x89\xCDw\x10\x88\xF4r\x98~\xC7D,r\x8D\xE1\xFD\xF0c\x1A]\xA7\xD7C'\xC1\xDE\xC7&\xDF\xFBX.=TrxC>\xFDl\xD6D\xDA1V\x97\xA2C6\xC4\x82\xF0D\xAC\xE3\xDD\x8C\xB3\xE6\x03\x8F\xCF4\xE4\xEEf\x9E\xFFl\x96\x16\xB7\xB3\xE3\vF\xD0\xDC\xE3W\xEDy=2\xA67\x1F\x1F\x95A\xFE\xF8v\xD3F\xD6\x04\xC8^\xB3B\x07\x1D\x9F\xFF/\xE4\xE1\xAD\xC6CL\xDF\x97\xB6$\x8F\x82\xFF\x1BE\x19%\xFF\x84\xCA\x05%Z\x1Co\xC1\xBF7rc\xC9\xC6\x8E\x85\xC8\xA6\x03\x93\v\x05\x90O\xF8\xC3\xDA\x83{\xED\xBF\x90\xE7\x9F\xDFf.\xDF\x94\xF4\xF1\xBC\x8E\x89a`g\xC3\x1B\xBD@\f\x10c\xA8b\bN\x86\xB5\xED2\xDA\x104\xC1\xCC\x8E\x06\xFA\x92k\xF8\x8F\x8B\x9D\xA1X\x83\xA8\x8F/\xC6\x925Q\xC8\xB9\xA9\x96\xD8\x91XP\x82o\xF3\x04Ra\xACj\xCC\xE5.\x98rw\xB3=^\x17@qp\x8E\x1D\xB7\xDC \xDC\xCA\x93\xDA\x1D\x8D\xF3\x94\xCE\x8F\xC9 szn\x8F\xC3[\xFDZ\xB9\xF4\xFF\xB2\xF7\xEE\xC1q\\\xE7\x9D\xE8oz\xCE\x00\x8D\x06\x84i`\x95\x98\xEB\xAB\x12\x1B\xC3\x061\x84\x18A\xD6*\x15z\xA3%\x1A\xC3&1\x18\xD1\x02\bC\x96\xE2\xD5\x8A\x10-'Z]\xDFHQrwe\x85\x19\xB4\x86C\x11\xA2\xB5\x024Km\x9C\xACK\x1ABC\x13\x1C*B\xCAq\xDD8\x8AB\x8E(\xE8\x11n\xCA\xF2\xAAT[[\xB7RN\x13\x02M\nv\b\x8A\xA1m\x88\x1A7n\x9DWw\x0F^\x96\xB3{\xFF2\xBAXP\xAB\xA7\xFB\xF4\xE9_\xFF\xFA;\xDF\xF9\xCE\xF78\xEF%}e\x98\xA4\xFA+\xD2\xA8K\xB2\xFE\\\xB2\x8B\x1BL\xEA\xB9\xCB\xC7e\xFE\x8A\x17\xF9\xCC7\xE6\xF1\x04\xAA\x82'\x01y<\xF1+\xDB\xA6\\\xA4\xCD\x1A\xFE\xDB;\x17\xB8U|\"\xB4\xF4@\x1F\xEA|g\xFFy\xBA?h\x00*;\xA8\x98\xBC\x9D\xBD\xCC\xE0Og\x85\xDA \xB44=H<\xF3\xA0\xC71\xD9;_\x94-\xF8\xFEE\xD6~P\xFC\x17\xE7\xBDp\xAD\xAE\xC5\xD9VR/,\x8DL\xB1/t\xB8\xD8\xFD\x80\xF1\x87\xD3\xB5\xF8\xF3L\x11\x82\xFF\xAF\xEE\xB4\xA4}r\x19\xFF\xEF\x981\x18\xFF[C\xFC//\xE7\x7F_bR4\xA8l\x1F\xE2\xFCW\xF7\xA7Kin\x10x\x96\xD9|\xD2\x96\xAC'K\x1C\x9F\x93\x7Fb\xE1\x1E\xB9\xFC\x81\xD8}\x00vZ\xE8\x13\x96\x8D\xB4`)9\xB2\x02\xFF\xA55\xEC\x8C\x03\x8Ej\x88\xFF/sT\xDFZ\xC6\xFF\xCF=pDNyJ\x82\t\xECq2E\xF0j\xA1\x88\x95\xD1x\x96\xDE\x9A\xB4v\x1FLrL2%Q)5s\xCC\xB7\xEER\xDA\x1F]\xCE\x7Fr/\xE7\xFFE\x87\xBBl\x1D\xB9\xEA S\xB2\xAD;k\xE5O\x03+\x81\xC6\xCA,\xA2\xB9\xB4\xB3B\xA7\xB7b\xDA\xC8\\\xC8.T\xC4;\x9Dc\x0E`\x17\xEF\x14I\x12>2\x84w\xDC\x15\xBB\x86\xFF\xF3<\xCDV3\xA0M\\u\xF0!\x9B\xAD\xCF_z\xECCHc,)\xCDWd=\xD3\xF8~\xDF\xC5\xAE\xDF\xC5|E\xF2\xBF\xFE=0!\xF0Gbf\x9D\x16\x9E\xA8K\xDC\x99\xB8-H\x1E\xFC\xB3\"\xFE\xF1\xE1\x9A\x1C&\xF6\x9Ds\xFC\xD1&E\xDE-A\xDAs]\x9D?d\xDEt\x8C\xFFL\x02ko\xA3\xF9\x15\x00sE*\xAC\xFE\xB1\b(\x19\xA8\xDBY2+\xCFd\x853.Z\x98\x9B\x123\xBEK\xF3\xBA\xFF\r\x12\xE0\xE1yo\xE4\xAD\xAA\xB0SE\x17X\xEA\xAD\x01\xEE2\x97a\xA1\x01\x88\x8Fv\xB9\x98\xBFtm)\xFF\x1B8\xFF\xCB\xFCC\x9E\x95\x9F3\xE3\xFFP\xC0\x7FE\xBD\x83e#\xEF\x9F\r\xCB\x1F\xBA3x\xA8\x96\xFF]\x9E\xE0\x7F\xFC\xD4\xDD.\xE3\x7F\xC4K\x97\xB0\x89\t\x86\x16\n\xC2\xABi0\xA8\xB9A\x8C\x88\b\x85V\x8B\xBD\x94\x18\xA7\xF4\x10\x8F\x0F\x12u\x00c\x1E\xE2\x87W\xE0?\x0Fg\x90\xFC\x9F\xA8\xE0\x8Ec\xD5Z\xFEk \xDF\x05O]\x12\x92T\xFD\xE7/}\xEE\xCB_\xE4\x8E\xA6\xE2\xCB\x8AeyO\xFA]\f9\xEC\xE9\xEA\xAF\xA2\xF1m\xC4\x14\x90\xD6\xC5\xF3I.\x9A\xFAg\x05\xFFS\x07\xBD0\xFF\xDB\x96$\xDBW\x95\xC3\xED\xDE\xE9\xA2\xC2\xF1g\x99\xB47\x98\x0E\xFA\xCC\xFDK\xE5?w\xCB\xE4\xF2'\xA6\xF4R\xA92$\x06\xF50\xFE\xF1S}\xECB[\xD6\xD5\v\xC6\xDF\x1F\xD5\xD5\xE0\x9FL\x89\x81VI\xDCkq#\xF3\xC0\x1D\xE7\xBD\xAD\x15_\xFE\x97\xFA]\xC9\x7F\xB2?\x90\xC9\\\xFE\xC7X\x89\xDB\xF8,\xE7\xFF\xCF\f\xB9d\xC0\xA1^S\xFE\xFF}\x11\xFD\xE7k\x1C$\b\x99\xE3\xA8\x8A4b\xD2\xFE\xD6\xB3S\xB9\xE3\x9B\xBA\xB0sr\xF9\x1FO\xF3\xC6S\xEC\xD1\xFA\xB9C\xBEv\x0F=H\xBC\xF211X\xF4\xD4\xAF \xFF\x17]\x8A\xFF\xC8;!\xF9\xDFx\xED\xAFK9\xA7\x83~\x9Ew\xB8\xCCp\x1A\xFF\x81\xE9\xE0s\x0F\xD8K\xF5\x1Fus \x18c\x8F\xD3q'V\x10\xC3.\x83Z\xBA%\xA8\xFD\xF3s\xF4\xF8l6\xB0+\xB2\xAB\x06w\xDCS3\xFE^LI`w\xDD\xED\xE2\xA6\n\x15}\xE9\x98\xD2\xC6KNPqD\xF9/\xE5?|\xFE;\x0E\xD3\x7F8\x99#&\x80\x1DE\x98E\xB9d\x16\xFF\x9FX\xBE\xF0$\xF4\x1Fa\xE8;`\xA0\xF7\x8D\x9AE\xB7\xC5\xD9N\x8E\xAA\x94\xFF\xFE\xF8\xFB\xF8\xE7\xBEL\xF7\xFF\xA2(\xF9\xAFd\xF9\xDB\xD9\xCB\xD4E\x8AC\xF4]4\xCE\x82\f\x80\x94>fh\x7F\xC1\xC5\xE7\x1E\xF0\xF9_\xAE\xE1\x7F\\\xB5\xFB\x14\xA1eke(\xAA\x91\xF7\xBA\x1D\x9B/%39au\xB8\xF8\xDC\xEF\xEC'K\xD7\xCE\xAC\x10\xFF3\xFDr\t\xB2\xCF\xAFn/+/\xF4\xA5(&\xF61!\x003\xC3\x00y\x9E\xE2\xBF{W\xB8\xB9\x9D;\x16$\xD3\xAC!\x8Bk\x93\xA9;\xCE?\xBE\x99\x01\xBE\xD7Z\xC2\x7F\xCFg/\xE1/\xBD\xFE\xFB~\xAF\xFA\xFD@W\x8A0\xAF\xE9\\\xCB\x7F\xBEXC\xAA~\v\xF6\xCE\x9A\xA7\xEB\xDBu\x95g5\xC9\x1B\x81\x87\x00}\x8A\xF6LO,#\xF4a>;\xA2\x9A\xF0~\x1E \xB9W\xF8<XPR\x88\xFD)b\xAD$\xB6\x9F\xF7)\xE5X\xF2\r\xEAa\xFC\xEF\x8F\xA9v\xDF\xA7\x85\x1C\xD4\xCA\x88.\xFCf>g\xB0Qc\x88\xC7\xE3D\x17ns\xF0\xF0\x8F\xEC\x91%\xF2\x9F\x0Fa\x82\xFF\x99\xDFw\xC4\x91\xBE\nx\xAA\xC3\xDD\"c\x89\xD1\xF7\x0E[74\x05\xFF\x07)\x92\xE3\xB4'\xEF\xD7\xC44\xED\xE4\xF5e\xEB\xF6#\xBA\xF0\x05\v\xBF\xC1\x82\x9E2\xED\x99mE\xB9\x18]\xE7Y\x06\x1E\x16\xFC/\xFB\xC6e^#^\x98\xA1\x99\xE6\xF6\x07\x96\\y!U\xE1\x18\xD0T\xDB\xF9\xEB~\x12\xE6\x7F\xB7\x83\xFF\xF8\xC6W\xC2\xBF\x9F~\xC9\xE6\xEFW\xB6\xE3\xCB\xFF\xC7\xF7\x9E\x7F\\\x1A\xFF\xAB\xE2\x8E\x8C\xFF\xBFeQ\xBDk\x98\x1F\xA1\x07\xB7\x82x#o\f\xF1O\xE3\xDE\x17\xC5\xC3\xEE\xBC\xB3F\xFE\x1F\x8D\xA9#\xAF\xB9\xAD>\xA4\x11]#\xDEo\x1E\xA4\xCFvU\xC4#[\xD3\x0E\xDE6\xF6\x93\xE6\x95\xF8\xCF\r\xDA\xF1\xC7\xDF\xB0\xC4\x91y\x88\n\xD1\xE2~\x91\xC4\\\xE2\xD3T\xDB\xB9Y&\xF3\xB1\x84'\xC3\xACU#r?\xE0I\xF0\x9B\x92\x80\xF53\x8B\xAF\x1AXW\xBA\x1E\xAF\x14}c{\xF2\xC7\x06\xA6\x85BR\xF6m\xF2\x84\xA7\xFA\x17\xCB\x00\xB4\x913\x96|9\xCDi\xD1\xCF\xC8\xF6\x95:\x9F\xF7[\x98\xBE3Yk\xDB\xCF\xF0\xF6e;\xE2^W\xBB2\xB3\xFD\x8A<n\x89\xA6\xD8\xAF\x17\x1D,88+\x96\xA2\f4\x9FEs\x99\xB0\xF2a\xB3V\xF0\xB0\v\xB9\x1A\xFE\xB75\xA8N\x84$\xC4\xD8X\xA4\xF87\xE74\xB6\xDCY/]\xD6\xEB]\xA8\xC3\xBB\x17\xDD\xF2\nC\x18Ok\x13\xA9k\x90u\xA3n\xA1\xA2\xA0\xCE\x0F\x12G\xF3\xF6\xF8\xCC>\x96\t?\x1B\x9A\xEC\xB3\x1As\xFD52\xA1a^6\x18\xF7Pa\xAB\x06q\xEF_\x9C\xAB\xAB\x0FL\xE8o\xFE\xCA\xB0t\xC2\x8Fx\x10\x15\x93\xE8O\xA4\x02\xDF\xE5\x9E\x99\xDF\xA5\xE5?\xF2\x8C8\x12\xE9\xAC\xB5\xF5s\xC9S\xF5[\xA8\xAFx\xB5\xB6\xFDw\x81\xAD\xC1\nBD\xDC\xAB\xFE\xDC\xE3\x1B\xDA\xBC\x9A%\x8F\xB8\xC7\x97\x1E\x9A\x87\xE9\xBF\xD6\xA2\xEF\xBD\x7F\v\"\xDE\xE2\xB9\x1C\xCF\xE6\x1B\xEF\x12\xED7\xDF\xEF\xF9}\x18\xA9\xA0\xEB\x83\xAC\x83\xEA\xEB\xE1\xF9\x97\xFB\xE4\xE2\x85\xAD\xEB\xB6\xAF\xF5m}[\xDF\xD6\xB7_j\xFB\x7FHaX\xE6\xB1\xE1DdU`\xDF\xCD\xA0\x05A>|\"L\xD9b\xA0G\xCD\x0Ejw,?\xD9>\x91\xEB\x05\xEC\x88\xA5/IP#\x8DT~S\xB2\x1Dg\xA5x\x00\xCBX+i\xBF\xBFca\xA9I\x7F\r\x9F\x7F\xFF\xE9\x96\x1F\x0F7\x12B\xCBA\xEDS\x18\xEA\xCF\x89)\b4\xB4\x15\xF0\x8F{\xA2\"-\x9C\x1E`\xC7\x85*\x89.\xD4\xE0\x1F\x1F\xA7\xD7\xC6=\x86\xFF\xED\xCCI\xFB\x17\xC3\x7Fc.\xEB\xE3?\xEE\x88\x1AI\x00\xBA\xC4|\xD0\x01\xACO\xB9\xF4\x92g]\xBFA\xA7\xD7E0\xE9\xE6.\xA6\xC42H\xD6\xBF\x91U\tY!\xD8\xB4\xC5\x9A\xD6\x99\x95\xDE\x0E\x8A\xBB\x914W\x8Dz\x80\xB0\v\xF4\x0E\xDF\x85\x83\xD4\xE2\xCF\xA8\xD2\xCB\x9D\xDF\xA4\x8D\xB4wV\x05I\xCB\x89\xC3\xCD)\x07-$\xA4\xDC\x12\x8A\x7F\x0F\xD0?\x9B\xEDuk\xC2BvTX\xBA\x03aR\xB6j\x92\x14\xC5=\xB9o\xB5\t\r\xAD\xFAU\xE0q\x93\xC4\x1D\xB5&\x81\xBF\xF6\xBC\xE4\xA7E\xEA+,H\xC1\xF2\xED\x1B5g\xFA;\xF5U?\x00sq\xDEk\x8B\x17|\x8F\x97EWxt\x8B\xE2\xBC\xAE\x98\xDD<\xD7\xE5-\xCE{?\x99\xF2\x1Bt,\xDF\x8B[:t\x81d7\xCD*\xFE\x8D\xFA\xE9\x11\x99J\x85\xCD\xADz\xC9J\xF83h\xFB\xDDPk@\xCA_\x1C \xD2\x03GXW\xB2\xD2\xA2\xE2\x81\b\x9Fj\xDB\xA4\xF8\xCB\t\xB8\x99)bq6\x8C\xBF\xF0\xF0\xEF!i\xDB\t^1\xF7\xC0\xF4\xE3\bx\xCBz\xF0z\xC6\xC5\xC4?*\x8C\xA5\x99\xA3\xA4\x0F\xC8tT\x1F9\xB0`\xD6\xF0\x7F\x86\xF5\xD0Z\xBCP\x1D\xA9X\xB4\xC1h\xB5Ar\xB0e\x19\xFF\xD9\x91b\x83\x8C\xDB\xD1\x1Dg\xE4\f\x9D\x0E6`\x1C\x11]w\x90\x97}8]d\x1Frl\b\xC4\x1C\xE8Q\x93O\xE8-\xA9\xB4!\xAD\x1C\x97\x19D\x1F\n\xB6\xB0\xE6\xE3\xA9k]\x8A\x8F\x1C\xFD).{\x1A\xA7\x80\x7F\x18O\">D_h\x83\x1F~\x9B\x01\x19\xF5\xDB\xF9P^{%\xE4B\xCF\x1D\xBD\xC4\x830\x13\xD0OX\t6\xBFB\xDC\xD5\xAE,\xE2YI9\xFB'\x15\x90xh\xF6\x177[X\xCBW\xE2\xE9\xAB\x0Es\xBB\x92\xDB\x02wz\x8Fs?\xEDB\r\xFE\xE4HR\xD8\x93\xC9Y\xB6\xF3\xBB\xE7\xC8\xE7\x80\x8C\x99o\x80\xDAQ\tL\x01,\x7F\x85\xE4\xBF\xC5\xF0'R\x8C\xD7\x07\xDE\xC5fx'\xA2\xEB\xD2\x16m\xEEX8\xDB;\x01\xE0\xB6\xFC\x11D\x17.;\xF0=e;\x1D\xE6/Ml\xC4\xDE\xFB\xD4\f\xC9\xDC\xD9\xFC\xD3\v\xF7\x0E\xF2^E\xD4A\x06\xD1\x1EAon^\xCEe\xDA\x03\xFC\xE9O1\x9F\xFF\x14\xFF=\xB17\xB9\xCD0x/\xB1\xFD\xDC4\xB4\x07\xA1\xD6\x80\xCF\xFB,\x8D\xE9\xDC\x94$\xF0g\xFE\xB7wq\xEBwLL0\xEF>\xAF\"\x96\xBEN\x9Co\x0F:\xE8>\x18\nQ\x8F%?\x03\xDC\xEDb\xA8={\xD70s;\x94\xDB\x00\xF7\x02\xE5\xF2G\x19\xAF\xC9\xB8\xAB\x16\x04\x86\xD1\xEA\x1E\xF6\xC8gs\xF9\x93@\xD9\xBCZ\x17\xF7\xFCr\xD2t'\xFEu\x8A\x7F}U\x83E\xFA=\x8A\xBFj\xC9\xCA)\xF6\xDEe\xB5<\xA8xW\xD4\xEE\x1E!\x01\xFE\xE1\xA8\xFE\xF93\xF4C\x9E~\xB0\x80\xEB\xEA\xEEv\x833\xFF\x95\x83\x7F(2\xF9\x13\x1B\x1A\xEA\xF5^8:4\xB4sH\xD4w^\x19\x7F%\xD3\x9E\xDDX\t\xE3/y\xCE,\x84{b\xDB(nt\x02\xEB\xE3/\x80\xDA\xC3\x00\xF7#\xE1\x07\xFD\xB7H[H\x87\xE4\xCF\xA80\xF9\xC6\xB2\x88\x89S\x86\xDAU\xC4\xD4\xDBx\xB7c\xD3\x83\x0EH,4\x90\xC6\xBC\x8D\xAC~\xE5\xDD\xE7Sw\x19\xA2\xA0\xA7xq.\xEE\xF6\xE5\x0F\x1B2|\xD9\x8B\b\x92\x8E\xE0?\x97??x \xFD'\x0E\xFE\xD4<\xF2/]\xA7/\\y_\x19\xE6\xFC\xD7\xE2\x9E\xE0\x7F\xDC\x13.\xA0\xF5U\xBF\x06\xD1]\xF2\x92\x92CO\xA8\xC8\xE99\x89{\xC3\xFDO\xB3\xAA\x82:\"\x97\xC7C>\xCC\x86\xC3\x1E\x91\xD8\xA8\xAF\x16\xFEn\xF4\xD1\xEB\xFE\xBE\xF0\xD6\xBD\xFBD\xF7\xD4=~\x14\x15_\x13\xA1\x7F\x13\x99\xF6`\xC4g(\xF98\xD3\xC3{?\xE0\x1F\x82S\x8B\xBF\xE3\x03~\xB7\xBB\x1C\x7F\x9D\x9B\x19\x05\xA0\xCA\xCB\xC2u96\xB8\x04\x7F\x91\x93?v\xDF\xA0\x83\xC5\x0FB\xC5\x13c\x86\xE1\xD0\x96\x07\x0E\xA6\x9E3\x96\xF2\xFF^W\xE2\xAF\xEE\xA2\xE7\x06\x06\xF3\x85\x9D\xC2FW\xE5\x96\xA4\x06$\x1B,h\xEDC3m\xD5\xF7\xE4k\x1A5\x80\xF8\xF3,I\x8F\xD5\x02k\xD1\xE5#\xAF\x04\x81X>\x98\xF9\x9Ab\x91jwN\x10o\xE4L\xDAf7\xF8\x15X\x88\xD4(\xB7\xDD\xBC\xA4\x0E\x95\xFF\xD3\x84,l|\x82\x90\xD8\xD0i\xDE\xA0\xA2\xF3B\xDE\xCF\n[\x12\x83\xA7\xA1\xF5\xF0\x16\xCB\x1F\x7FYru\x893\xAB\xE6\xFCl\xC3~4\xDC\xC2\xAC.r%\xB4!\xCD\x87W^;\xF5\x1B\xB2\x93\x05#\xECu\xE0\x04\xFC'\x93\x00\xFE\x8B\x054\f\xCA\n#\xF8\xE3\x0F\xB2h\xC8\xAA\xF2F\xFF\xA5\x025\\\xBC\xBEa\xF7\xA2\x8B\xE7\x80\xF1\xA7\xB2\xCF\x19\xAC\xDE\xAB?\xC4\xF2\xF2\xAF\"G\x90S\xE3\xF9S'\xF3qDT\x8E\xE1\xC6\x8A\xDEb\xA0\xB5\xFD\xB6\xA6\xCD\xF9A'\x18\"\xA1\xECc\xF8\x17[P\xD4Pd\xE8\r\x8F\xC8\xB5`_E\xF6\xB3\xBCP\xF1\x12}\x9B\xC8\x14\xEED\xEAB-\xC2\x18\x15hJ\x86\xC3\xC6\xA3\xB8\x87\xD8\xD0\xE2,Z\xAF\xAB.^\x90\xE1rQ\xDD\xE5\xD5\x94\x84\x91\x8B=o\xB3\xF2\xEE\xCD\xC1\f\x82\xFE\xD4,\xF1g\x16\xCBs\xCD\x04\xCD\n\"*b\x0F\xC2\xB7\x97\xB2\x05\xC1Y\x06\xF8\xAC\x84\xFD}_\xFE7o\xE3/H4[7)R\xB24\x0F\xA2Y\x1AxoN\xA1Y\xEA\x84\xCD\xF6\\\x11\x8B?\xD8\x10Z7|$c\xE1\x82\x8B\v\x97\xD2w\r\xCBUr\xB6]p\xF1\x9E%\x97\xD4\xD9]b\xA1\x97#\xF6\xEBF\xBF\xC7n}\xD91Z\x80\xD6\xD9V\xC5J\xFBz\x9A\xEA\x00\xF5\xD7#\xA2#\xA2\x1BO\xE8-\x11\x9D\xE1<.9<\xE1\x17\xFAl\t\xB1\x1AJ\xDAN\x8B\xCEw\x8FNh,K\xD0\xA2[\x04\x1C-\xF4\xA6\x16]^'\xB4\x88\xB8\xA7\xC5\xFE~\xF1\x1C!\xA4$?(\xF7\xB3\xACW\x9F\x11\xAF\x83\xADLE\x95[7\xA5>#/\xA7;Q\x89\x7F\x94J\xD7[s*\xA2\x04Q\x1D1\x89O4M\xFF\x17\xB8\x8D!\x7F\x9B\xC4\x7F[\xB0p3\xC4_\x90h\x96\xE5\xC9\xA1\x9AIt\x10Q\xF1\b\xB7mJ!\xAA\xCA\xE1\xD2N8\xD0s!{f\xD4:k\xE1\xB3\x06n9\x906\x9D\x1A\xF9\x7F\x9B\xC1\x14\x8C\xE8\x9B\x9C\xE7\x006\x04\x137W\xEE_\x8Es.\xA3\xD2\x06$\xD4}\x11\xE7\x96]~\xB16\xCA\xEC\rPT(\xAA\x9DR\x8D\x9C\xFA\x19JoU\xE0/\x8B\xFC\x86GvbP\xFE\xE7;\xE4RTD\xFF\xCC\x01\x8AF[t\x03\"\xE43\x0E\v\x7F\x90\xAF\xEC{,\xC7\x11\"\xFAg\x0E\x0E\x19\x07\xFF\xFE\xFF\x88nH\t\xFDG\xECH\xFD\x9F\xAF\xF9\x92\x8C\x99\x8A\xCB\x07\xE8\t\x87\xB1\x90m\xCC\xC9G\x05\xD9\x00\xB8\x81\\\"\x8FsO|.cm#\xBCZ\xC0\xA5w\x01\x11z\x82\xA8 \xAFL\xCA\x15\xED/\x80\xA4\xA4\xFE\x9F\x02Q\xC5\t\xC4\xB6\x8B\xD8\x18\v\xA5H\"\xA9\xCFV\x90r`\xE5\xD3C\x8E\xCC\x9F+\xF5\x7F\xA6\xFF0[7\xBB\x8B_\xFC\x1D\xF1\x1B\xC5~\xBC\xF92\xFB\xB2._\xC0k\xC0\x99\x86\xDC\xF6\xFA\xCA=\xF2\xB4\xC7h\x97\\4\xD5\xA1\xA9.\xB7\xB5\xAE\xF2\x95\xBA\xCA0\xAB{\xCB\x7F\x96\xE5n\x01T\xE4%,:`C\x93|\xC4\xC5\x1F4U\xBERG\xF1o\xAAC}\xB52\x1C\x9C\xE9\xBA\xA0\xCALS\x1D\x9A\x9B+\xBF\xE3\xB5<5\xE4\xFE\xA8N\xF0\xBF\xB9nw\xCD\xFC\x8B\x11\x96l\xF8\xDAl\xF6\x11\xF9\xC51\x94$\xFE1\xCA\xB1{\x92\xE3 .\xEAo@\x83\f\x07 \xDFE}\x13m\x87\xF5\xB3W\x8A\x9D\xDE\xF0\xFC\xB7\xAE\x89w\x86=\x91'\"\xB5\xE9<N\xC8\xFF\xFE\xD9,\x887,\xE6\xBF\xF7\xDD\xE3b\xF8oC\xF2\x9Fd\xDF4\xB0{\x98\x9E\xF6\xC7.\xC6B\xF3\xAF^\x17\xA3\xBE\xFEY\xD7\xB4n\xFEZ\xDF\xD6\xB7\xF5m}\xFB%6\xFF\xEB\xCB\f\xE65\xFB\x91\xB5\x17\r>\x81\x89[6\xA2\x7F\xA2+B\x86t\xE3\x7F!\xC5>\xB1\xFEW\xA1a\xE1\tz\xA4\x16\x13\xE5\xE74\xAB\x87\x9E7\xFD\tn\xA2\x05n\xF3a\xFF\xF9\xD0>\xB3c\xDFp\x1FU-\xB2b\xEEOX\xEAT\"\vE\x91\xDB}\xBB\xC7\xC7\xBE:Q\xE1\n\x89\x15\xD2\fW\xC5\xBF7\xA4!\b\xB3|E\xE0\xDF\xBBF-!\xB2V\xFE@;\x04\xD4\xDEZ\xCF\xE7\xDE\xCA\xCF\xC7\xA5w:\x9Bb^|;\xFD\xEEQ\xFD\xE7\x12\xCF[r\x9F$\x86\xEF\xF2\x1A\xE0\xC6z\xC5|\xC5W\xC5\xFFN\xDF\xCF\xB0\xDE\xF3u\xAA`\x87\xCFAB\xE0\xF4\x99C\x99\"Uk\x85*K\x98\xAEKd\xA1(?q()\xA6\x8D\x9A\xC7\xCFH\x9D\xBFk\x95\xC0pq\xB2\xB3\xF4]p\xE5\xFCc\x17\xF6Z\x14o]\xE3\xC7\xB0\xD5}\x8F9\x18\xFEi\xE7'\xF84v\xDAi\xE6q\xEA\xF5\r\x87\xE2\x11HBd\x12\x90\x1DN\xE5k?\xD1\x98\x88\xD4\xD8\xBB\xE6\xF3fJ\xD2\xCF\x87\xA8\xDCN\xCE\xD4\xFEP'CI\x8C\xAF\x1AX\x9C\xBF\xD7+\x02\xF1\xACH&\x13O\xFB\x06v\xB6S\xF2Wp\x1E\x97\xF8\xF33\xAF\xC9\xF8\x8B\xA7\f \xBEj\r\xC3\x9F\x86\xB0\xE2\xB9U\xB9\vt\x9B\x83\x1F\xAF\x81U\xFC\xDE5\x00\xBC\x1A\xBApq\xBE\xA6.\xDBO?\x01\xFF\x7F\xF2N\xF6\x8AE\xFB\xFC\x91\x81\x1F\x8B\xA7\x1E@<q\xC5\xA9]Z\x9A\xAFM\x9A\xDAl\xF3^]6\x80\xE6U\v)z\xF3>\xFF/\n\xA7n\xDF\xA2\xB8L\xFE\xDC\xED\xA2\xAF\x9D\xF1?&\xA7r\xC2\xF6\xE8\xAF\xF4\xC9>\x90\t\xDFL\xCD'\xDD\xBB\xE5\x9A\x17sY\xBF\xB4Z\x7F\x86\x9C\x1A\v\xAD\xCF\xFFG+\xF8\xAD5\x8A\x94\xC5\x06\xD6\x00\xB0\xC6\xEAXK\xC5\xBB>\x01\xFF\x87v\xA6\x19\x87\xF7\x7FnX\x9E\x1F\xFB>\xC8%\xDE\xBD!\x99oj\xB0T\x9B4\x98\xD8\xBCW,\xD5\xC9\x95O\xC0\xFF\xC3!\x83y\x88\xFF\x91 x\x7F\xC8@\xFFy+C\x1B\xCCJ\xFCY\x1E\f?\xD1\x8A\x9F\xB9\x8B\x94\xBF\xEA\xD4<~\xA6$\xF8\xDFi\x01\xB1\xCE\xD5\xFA\xF3\x85P0\xF8]F`d.\x15\xB1\x16\xC4a\xC2,\x070lu?\xAF\xAF\xF6jV}}od\x07\x1C\xFA\x8C}\x06\xEE\x12\x81N\x0F\x82\x8C\x0E2\xE4\xEF\x93\xF8\xEF\x9D}u\xA9\xFCax\n{\xF5\xCF\x97\xFF\xD7B\xFC\x0F\x91$T\x8B\xE1n\x17{b\xFB\xE9\x1Dc)i{\xCF\xD4\xE2\xEF\x7F\bs\xDF\x1D\x0E\f\xDD\x14\xFF)\x19\x91\xE1\xAC\x85\x7F\x18dN\xB0=\x86\x18\x7F\xEF^c\xFC\x8D\x9D\xF9\x84\xFC\x1Fj\xF7V{5\xABv)\x96\xA6\xB7\x8E\xDD\xD6\xEF\xFA\xFCO\x83\\\xE2\b\xD8\x12\xFF\x81%Y\xE3b\xAD\x88Y\x92\xFF\xAB\xE2\x9F6\xA5x\x8Fu\x06\v\xD3\xE1\xB2\xFD$\xA8\x90\xF2\x9C\x81\x17>0\x0F\x17\x81\x86\xEC\x11Q\xA2\x94\xE1\xEF\xAF\xA86H\xC1\xDEP\xF6_\xDB\v\xAC\x9F\x7F:)\fV\x05\x8B\xFE\xBAZ\x7F\xFE8\x04r\x81\xDD\xE2\x85\x8APs\xC7\xD7PA\x1B\xD6\xE2\xFF\xB3\xE1\xF6?0V\xFBi\xB5\xED\x85\x0F\xB2G\xE8#\xBF\xFD,\xF0\x1C\x7F\x95\r\x1E\x1A\x12\x05\x86\xBC\x9F\xB2\xFB\x8F?X\x12\xB1\xC5J\x81\x8B\x95\x88U\vy\xFF\xD7\x13\xAFH\xFCM4\xCB\xA7h\x0E\xAF \x07\x849oa\xE6\xD7\xBC\xB9\"\xD0\x9C\xBA\xCA\xDF{3K\xAD\xD3,W\xFC\x83BH%\x7F`\xE2\xF9\xC3\xE7|\x9F\x07\x17h\xFE\xDD\xD5\xFA3\x1B\x82g\x96\x01\xFE\x81\xCC<va\r\xFE7\xA7\xD6\x000\\\x86i\xF6\xE6\x9A\xC8\x8B\xB9\xE2\xCF\xC7\x7F\xEEe\x85\xDE\xBA\xF9\x86EWt\t\xCDi4\xFF\x07\xDE\x9F\x0F\xE4\xC7uy\x89\xC7x\xBC\x95\xE7\xBE\x9B_%\x11\x9Cl\xDC\xE7\xBF\xCD\x8D\xE1\xCCt\x1Cz\x9CP\xC8\xD2m\x0EnM\xDCrk\x05\x88fE\xC8It\xDA7\xB0#\xBC\x84\xA3\xCC\xFAK!<\xA4wk\x9Bh\x87\x1E\x8F&W\xEB\xCFo\x84\xB0\xEAf\xFB[,q\xD5-k\xF0?\xBA\x16\xFF7\x85\xDB\x7F\xBFf\x94\xEC\xFC\x04\x85G;_\x1C\xBC\xAD\b(\x0F\x99\x166\x8B\xEC[\xA3P\xCA\xB7:A\xF7X\x16\xACZ\xFEG\x1E\xE7\xBD\xDAbP4Vk\xFC\xA6\t\xC9\x7F\xF5lh\xFE\x15\xC6\xFFrx\"c\xB7\xA7\x07\x1Dz\x82\x98\xD4\x90/\x06\xB3\x80\xB0\xC9=V\xDE\xE8\x8B8\xF6\x8C\xE96\xD1\xCE\xC6\xF0\xF9\xCB\xF5\xFF\x10 <'g_E\\e\xAD\x81?Y\x8B\xFFa%\xDF67\x84\x7F\xDA\xF7\t\xE4\x7F\xE6\xD8 \xD3\xFF\x0F\xF7:\xF8\xA2\bt:\x82\xD8\xAD\xBB*\xC1\xF0\xC4\xA6\t\xB5\xFD\x8Bf\xB8cR\xDF\xB0\x1C%W\xD6\x7F\xFE\x87\xD8k\xBC54z\x86\xCC\xD1\xCD\xCD\xC1\x84\xC8\xC0=o?\xB9\x9B\xE2\xBF\xAB_\x84\xEA\xB0\xD29\xB1g\xE4\x85\xB2\x8E\x12\xB9\xD5uk\xA6?\xE9\xDFm\xF6\r\xFB\xC1\xF9k\xCE\x7F9\xE0=\xF2\xAA5\xE7\xBF\xBB\xD6\x000\xAC\xB8\xF6\xCE\xFE \xFC\xD3\x9F|\x02\xFDg\xEFl\x13e\x05\xB9\xE5\x9Ea<%\xE6_\xFB@\xFE\x8E'\x7F\xFB\x82l\xFC\x0E\xB3v\x92\x15{\x1C\xE4%9\xDF_u\xFC\xDD]*\xAC[\xBE\xD6\xB7\xF5m}[\xDF\xD6\xB75\xAC\xFA\x915\x8FD\x96]\x1C>B\x02\x93\xF8\xE4\xEA7\xE5N\xEFVM\xF6~\x85\xC7\xDD\x06F\x83\xB6\x90J\xAC-k\xC1wF\xF5\xFF\x86\x7F\"\xF2_(f\xC1\"\xB5\xFD\xF4=\xE4\xFD\xCC<\xF2r,\xBB\xDC\xBF$\xDCH\xB8\x03+\\B\x82sX\xD5\x00v\x8D\xE1\x07\x87\x8A\f3*\xC8\xA5\xFEZ}\xE3\xC3ex\xF5\xD4\xEE\xF7\xCBZi\xDC\xF2\x1F\xD6\bw\xF2P}\xA2/O\x89\xDC}h\x01\xC0G\xF5\v\x1C\xFF\x91\x8Au\r\x96\b7\x8E.\xCC\xCFlgY\x89t\x7Ff\xD7V\xEF!\"\xFE\xF7\x81\n\x9D\xDD\xF0\xA4\x19d-\xFCk\xC0_\r\x7F\xB2&\xFE\xE4\xE7\xE3o\xAD\x8D\x7F\xED\x99\xAB\xE1/\xD3b\x90r\xCF\xEA\x96\x81\xE5vu\x91\f\x87e\xC7\xE5\xA5\xE8\xC2K\x1B\xF7\x15!r&\xC7\xBE\xB8\xB4\x15Ge\xFE\x8Di\xE1\xFF?\xE65^\xA8J\xC2[\x9Dcg\xDAx\xFC\xA9\xCC!\xFF\x11QXb\xF02w\x00n\x83x\xDDDFt\xD2v\xE6\x83\xBFbi\x83\xFD\xAF\xFF\xCF\xCF\xAB\x19d\xE3\xF1\x8BC\xF1<\x9C\xECx\xB8P\xD4\x88\x8B\xA5\x97\xFB\xA5\x96\xE7\xBD\x9A\x00U\xBF\x03\xB5\x97\xD4\x9C\xC9\xFE7\"\xFD]\r?87\xCE\xF8\x1FW\x11//)\x97|e\xD9T%|\xE4\xB2!\xFA\xF3\xB1\xF4!\f[\xDDgE\xB1\xE3A4\x8F.\x13b:\xC3\xFF\x19\xA8\x14\xE2\xBCeiVZ\xA4\xB7\x8A{\x9D\xF9\x02\xBD0\xA2C\xBA\x96\xDF\xFD\x96\x07\xE5\b/S\xF8\x7FW\xE8\xE4\x9A\xFB\x82\xB2\x14\x01\n\xFF\xE7$\xFD\xBFl>\"\x0F:\xC9\x14\xFB\xAB@\xA5_\xE7\xF8\xA4\xE2$s\xBE\x930/\x8E\xC6\v\x92\x16\xCB\x19\xFA\xBF~\xA1RV[\xAD\x98T\xF2\xF4_+/\x17\xE8\xC8l\xB4\xCFv\xB2\xBC\xE5\xC2\x14\xD6\nUy6y\x18\r\xAD\x8E\x81\xF1\xCEB\xE9D\xE2\xD9\xCE\f\xD4\x1C\xAB\x8E\x9A*\x17y\xCA\x8E\xD6\x02\xC3\x84\x88U\x0F\xAB\xC6\xF2\x19\xCB\"\xE6\r\xD6\xCE\xE7\xC6\x96\xF1?l\x90\xBC\xDB\x153A\x9F\xFFa\xAB\xE3^>O\x8Ce\x97\xAF\x04)\f\xEA\x96\xA8\x82\xC6+\x9F\xAA\xC0\xE9\xF2\xAE\xB7\x06d\x18\xFB@&\x7F\x84>\xA6\x92\xF0g\xD6\xBFg\xEB\x88%y\xC9\xD1\x8C\x85>C\xF0\x9F\x05\xE3(P\xFF5T\xE5\x89d\x0Ej\xEAt\xD1\x92\xF8S\xB4\xBF\xDAp\xE5\xB4a9D9=\xA9p\xF9v\xE2\xA6k\xA7\x8FW\xFD\xC2\x859V\xFF\x8E\x12\xB2\xF1\xDA\xE9\xA3\x03\xA7\x8B\x18\x99\x93#L\xA3\xF7b\x11/\xFE\xF0\xDA\xE9\x93\xD7\xF6\xF4\xDE\x80\x86\x84\xACC\x81=\xC0\xE9\x17\x17^\xA0O\xC7\x92\xDE\xD4WA\xAA\x8Bse4\\\xB9\xBB\x82\xBB\xCF\x97\x17\xCF\x93\xD3O\f \xBA\x8D6\xF8\xFA\x02\xBD\xAA~+\xE2\xC5?\xAC\x04\xF2G\xDF!\x933\xB0d2\x88\xA5\x10\x1B\xFCB\xE5\xE7\xC8\xFF/\x86\x18\xFE[\x16\xEE\x1E\xAE\x91\xFFa\xD3\xEE].\xFB5\x96\xE4.\xC453W\xD0\xA9k\xDBuW\x00\xDD\xB0\xD0=\xAA\x98\xFDRn(\xE9\xCC\x81\xA7O\xB3L\xDD\x90AU\xB1\x9DU*\x8B\x9A/q\xCC\xEF\x18\x16EK\xD9k\x02\xA2\x15D\x17\",j\x8C\x05&\xB0\xE7\x8A\x98\xA8\xAF6\x00G;\xAA\xDDo\xBDj\x1CX\xE0\xEFw\x97\xA26D0!\xF9\xAFX\x94\xCC\xCCU\xD52\x0EUM*\xA3\xA5\xDDF1\xFE\r\xB0\xCD\xD65X\x05C\xE7\xB9 Z$\xF1Z\x94t\vd\xB5eE\x05!\xC6\x81\r\x88\xE8\x03\x16\xF6(\x05s\xF4JK\xDC\x83\xA2\xB6\x00{\xFA\x99\x11F\xC9\x80\x9Cj-R\xFC\xB9\xAC\xD0\xAD\xE5\xFC\xCF\xFE\xDB\xE2\xCF\x91\xFFK\xF8\xCFM\xF7\xA6#r\xA1\xEC\r\x8F\x0E\x06\x86\xC4\x92\xC4+K\x1AYt\x1FcZ\xCDV:\n9\x884^k\xB3\x1C\xC1\xFF\xEB\xAE>\xB4{P\xE1\xF6\xBD:!\n>\xB6\r\x90\x12/\x99\xED\x18\xB8\x1F\xF8\xA8\xE2\xE3\xBF\x8D\xC7\xEB\x05\xF9\x93#\f\xDC\x98\n8_\x05\xBA\x89MH\xA9\xDB\x11\xE3\xFB\xBF<\xB0\xA0\x1F\xA8v\x87bC6rT\xA3\v\xDDy\xD2da\xEFk\xBEA\xAC\x9A\xAE\xC0\xE8\xAF\xB6D\x17\x9A\xAC\xFD\xA83|\xFC\x7F\x0FX|\x7F\x81\xEE\xD7\xA5\xB9\xCE\x80\xEB\xBC\xEE\xFF\xF4\x13>d\xFC\xC7i\xB7\xDB\xC1\xE2\xB9\x01D\xBF\xD3\xED\xA0;\xC7<\xE4\xE3\v\x88\x9FYt\xE9\xE0\xC5\xB5\xC4#\xBE\xFCo`\xFCo0\xD108\xBE\xBA\x15=\xB0\xE4\xCB\xED\x1B\x96\xB0\xF3\xA7-\xC1\xFF?\tY]\x9Es\xF1\xBC\v4$\xF9\xB8Y\xC3\x7F\x16\xE9\xF73F\xD7\xD7\x988\xFAh\xC7cR\x97H\x9C\xDD\xB1\xC0\xD3Ys\xDFK\xFA\xD4\xBD\x1E\xFD\xC6\xB5\x12\xB7\xBD\xBF\xC3\xD3\x16q\xFC\xA3\x15\x96\xE4\xC1\x8AP\x05\x95E\x1F\xF0P\x8B\xD8\xF5\x80\xD3S_5\x88M\xEAJ\x86#\x14\x18w\x9F:\xF2&\xF1=[RLs\xE6!\fj}\xF5Q\x07\x96\xBF\xF6\xD4\x94'\xC0\xCFl{q&\xFD\xFB\xEF\x94\xD0X\xF5\x93\xA5lt\xC1b\x1F\xC0\x0FR\xFE\xC7\x14\xDA\xA6\xA2\xEA\x16Zwl\xA0\x9F\xD2\x81\x05(\xAA\xE1\xE0\xBF\x7Fi\x81\xFF\x04\xF5\x94\xE1\xD07\xC8\xF9?h\xC9a\xF1:\xF6\x98\xCDY4g\xE7\xDD%D]\xCB\xAE~\xA1\x82\x19y\x1A_\x12\r\xFFz\xDE\xA0C0U\x1A\xE3\xDF^&\x7FX\xD5\xAA.J\xD7\xBDt\xEC\xB6\x8C\xA7u\x991\xC3\xCAX:\x8B\xB2y\xC0\xB7\xCD&\xA6\xF3T;j>\xC5\xAD\xDD\xA9p\xD8\x82\x02\xC4\x1D\xC4=\x96\xE6\xEB{\xAD~\xE5\x91\x86\x04\"\xD5\xC7au\x1F\xAAv\xFC\xEDK\xDD\x07\xAEr\xF9\xD6\x9DSIc\xC0\xFF\xAFZ\xF4Ur=jq\x96\xD4\x03#~\xCE@R\xA5t\xED\xAD\xE2\xC0\x02\x89m\xE0\xCA\x00\xB7\x00\xFF\x13\xB0u\xCC#~\x96\xA1\xE8\x02=y\x9E\x92\x84*<?\xFA\xED\xEE|\xE9\x1F~\xF7N\xD4{\xDD\x0E6\xC6o\xEC.\xF2\xCCo\xC5n'H\"\x1A\xE8?\\\xCD\x8B\xA6\x10\xD5;k\xE5\x8F\xBE\xCC\xFC{k\xE8\x84\xDB,a\xE7\xD7\xA5\x916\x11\xFA:\xBA\\\xDCLa\xEC\\^YX\xE0oPN\xF6\xB0\x88$\xE3\x80'\xFCX\xE2^f\x8A?\x9A\xEA\xA7t\xBBv\xC7\xF7)z\xCC\xA2\xCE\x8Bw\x04\xC4P\b\x97?-Q\x1D\xD1t\xAB\xA2\n\xFC#\x15D\x89f\xDBF\xDE6Q4\x9C\x14/\xACm\x1CX\xE8\xCE\x11\xBF6O\x9F\x03\xC3\xE1u\xBET\xFDP\xF5\xD3\x0E\n\x199\xFE\x92\xFC\xAF\x00\x93\xCE\xE4\xED\xB9\xB4\xBD\xF3\x01.\xFF9\xFF\xEF\xB2\xF0\xFA\x83\x99\x0E\xC7\xCF\xB2RD\x93\xDD\x02\v\xEA\xE1\xA1\"\x86zF\x8D1\xAF)\xBA\x00\x95~\x14\xA4\xA1\xB5\xD5\n\xF8\xEFg.\xBD%\xA5\xD6\xC8\x7F\x92\x02\xF1\xEE\xA8\xC5\x7F\xE3r\xDBi\b\xE1\xDE\x8A(\xC6\xB1Q\x14\b\xA8\x91\xFFwY\xB8\xAB\b\xC4\xA6\x97\xCF\xBF\x96\xE2\x0Fk\x93eH?\"\xEB\xEE\"\x9B\xB0(\xB7\xF9K\xCCf\x9A%\xB9\x92\x05\x172\xC5Pp:\xC5?G\xE5\x0F.\xA3iW\xC2$ ,\x1D_T\xC1uDK\xA7\x8C\xBC}{4A\xE5Ot\x03_S&\xD1\xA0\x04U\xC1bG\xD8\xEB\xDEH\xC8\xCC0\x9E\xCD\xA9>\xFE\xA6\x83\x13\x07\x12\xE6\x81\x05\xBBO\t\xF3\xFFO\flh\xBCv\xBB\xBFP\x1EM\x80<f\xE4mD\xD4\xFF\xEC\xE0\x88uK\xB7c\xFDz.\r\xA5\xDCm\xC1\xEE\xBBr\xCE\xA9\xE1?\x1FD\xD2\xB6\x94?\"\xCFj\x16DO\xD7\xE6\xA5w\x97\xC9\x9F\xDE\x90\x84\xBFgX\xE0?\\\xC1\xB7*X\xE2u\xB6\xCB\x80\xED\xB2\xCAG\xCB<1n`\x05\x16\x86\xCFU\x10\xA9\xEC\x00n\x88T\xBEb\xB82\x8DO\xE5{m\x95\x1B\xE8\xD0v\x86\xA7\xBB\xA4s\xDE\xFB\x9F\xA6|&O\xB3kq\xB6\x88`\xAD\"R\x05<D*\xF5\xF5M\x80\xF5\xFAE\x05\x84\xDD\xAE\xC9C\xA4\xFA\x1Bn\xA5\xFBP\xF5\xF5\x1F\xDDH\x85CS\x1D\x95?c\xDE\xE2\f\xE9\x0E\x05\xA9\t\xF9\x13]\x18\x9Enj\x02n\xFF\xD2\x82/\x7F\xA6\x87\xF1\xDB_\xB9\xF1\xDF<]7\xF2\xB6\xC7\xB3\x0Fq\xFE\xFFg\xA0^\xAD{\x9D~\xDDle\xA7i;bOV\x1E<\x83\xBA[\xBE1\x8C?~\xBDR\xB9\xBF2\xFD\xA5\x05\x90\x97\xFE\xC9\xC5\xD3\xC9\xBA\xDBY\x88\x04\xD4S\x95a\xD4\xCB\xB2\xC5N\xE5\x9Eu\x9B\xD7\xFA\xB6\xBE\xADo\xEB\xDB/\xE9\xA6P\xED\xC1H\xB1\xEAaP\x98\xB6\xA9\x10+H\xE9_\x9B\x81G\xD8.\x84\xF94d$_\xB1\xD8\xE5\xFF\xAE-d\x10\x0EU\x01X\xF5d\xDE\xCFO\xE2\xFD\x1FN\n\x14\xA4\xEEWVX\xDD\xD0\xD7,F\xAC/\xB1+J\xD3\x9E\xB5\xFCZ\x12\xDCN\xF7\xF1\xB7R\xA4\xE3\x83\x1BI\xFDLKt\x01\xB1\x14\xE1S\xC5\x00\xFF\xC0Z\xDE\xC7\xF1g\xED%\x87\xC3\xF8\x07\xAE\xE0\xDD\x17\xAA\xDDoy#\xAFWG\xDE\xF2F\xDE\xE2\xA6\xE0\xEA\x88Kg\xFA#\x17<\xD4{#\x17<\xBE\x13dLe;\xFC\x04qZh\x02\x18^R\xA1\xFA\x95\xB2\x16\xFE<\xE8\xBE\x8D\x19\xDF>\xB5\xFC\xE7\x90_Y\xC7\xAC\rE\x17U\x9C\x14\x93E\x00\xABmJ6e\x80(u]\xCCP S\x00\x19\xDC\x9A\xB7\n\x87C\xEBD\xA1\xFD\x9B'St6\xA4\xE8PS\x9B\xD8]6\xB9b\x95\xAAk\xC6\x14W\xC5s\x8B.\x16\xFA\xF3\xC6\x96}\x8B\xB3\x89EW\xC5u\xB9\x17\xDC\x00\x7F\x93\x87N\xCB\x17\xF8\x11\xC7\x9F=c\xBBLx\xC2\xDA\t\x1C*\f\xC36l\xC5J\x11\xCBV,\x9B\xBFEb\x19\xA0\xFFL\x05D\xB1L\x85\xEF\x88\x1C>2\x99\x0F?A\x9C\x86\xC0>\x9C7\xB2\xB5\xF8o_\x03\x7F>/\xEBf\x89\x8EW\b\x9FQ\x83\x96M\x93\xE2\xBFET\xB6M Z\x81\xA2&\x94\xD4\x88\v;\xF5X\x1B\x9B%\xC9\x04\xE3\xA95\xF1\x0F\xDC\xC0\xDA^\x0F\xDE\xAF9\xE5\x99\x06\x8B\xA4\x88{[\xD9]\x12\x860\x9B\xB4)\xB6(O\xACl'\xC0\xD8\xCC\xF6\x89\xBE\xEB\xCDC\x9EF\xF9\xBF\xBD\x87\x82\x9F\xE6\xEA.\xED@\xD3.??\xC9\xE7X~$^\xF8\xA06p9\xBB\"\xFE#\xD3\n\x7FG\x96A\xE9muP\xCE[\x1D\xBF\x18\xFF\xF3]\x95O\xCE\x7F\x81\x03\xE3\xB9\xB5\\f4\x04\xDF\xA9\xD9Q\x85\xE2\t\xFCcU\xCA7%\xDB1\x93\xE2\x19*\xB6\x18hseb\x10\xC5[\x9A\xDC\xFE\x13\xF0\xDFt\x18DJ\x01\x11\x9D\x9B\x05N\xBA\x82\x12]\xEF\xCB\xA5%E\xE9v(\xFF\xFF}\x7F\xBA;\xAF\x8CTT\xC4\xCF\xC4\xA7mf\xFB\xA5W?m\xD4\xC8\x9F\xAF\x1A\xD0\xE4W\xE9\x89,\xA9\xCC\x02\x1A\x0F\xECvF\x97g\xF4\n\xF9cq\x84\x891\xC2V\xCAFf\xE9\xC5#\xB3\xF9\x81\x83&b$\x14A3\xCA\xB3\x16\xDB\xED\xE6\xA0\x85=\xED\x01p%\x07y\xC3\xF6\xF1g\xD9\x87\xD6r\x9F\xE2\xDC8\xCA\x92o\x9F.\xAE\x85\x7F\x87\vh\x85)\x11d\xCD\xCC\xCB\x8AZ\xEA\xCC\x8E\xB8 Z\xFA\x98\x85\x13\xFE\xA9\x9A_Mf\xA5M\v~:\xA1\x05r\xE0\xF8|\xE9\xA8\xC3~\xAD\x1B\x7F\x91\xF5\xAA,\xF9\x7F\xA23\t\x8D\xD9<\xE3gL\x07\xA3\xE9\x92\x19\xB9\xCD<4\x93\xE9?\x05\x92\xBBh\xDB )\xBF\xE6_8\xA5X\x1F\x02\xFC\xB78!\x89\xAA\x06\xF8w\xBBv\xF7\xB4e)\xAAM\xF4\x11\xEEx_\xEF\xF5\xB0\xA2\x00)\xC6\xF9A;\xFD;\xB3\x93\x94r>\xFFYb\xF9A\v{\xDF\xA2\xFC\xDF\xFB\x83\xE0k:]A\xDE\xB4k>\x7F\xED\xD4\x1A\xF8\xF3\xEC\x07SgT\x91\xAAb)\xFEAQ\xE6R\x97\x07\xADpBx\xF4\xE9\x94\x90\xDAh\xA93m\x01\x9A\x96=\n\x8A\xBF \x9Ef\x86\x1D\xF2\x97\xE1\x1F|\x1ASsA\xA0\xCD\xAB\xB9\xC4\x04m+\v\xB8/\x15k\xF8?5\xD7)\xF0W\x12\xDD\x0E\xAE\xA5\x8F\x18=\xD3#\xF9\xD6\xDF?\x93\x00)tM\xA7\x98\xFF\x81\xE1/\xF0\xF9\xABu\x1C\x7Fn\x9F\x12K#\x9C\x18\xEA\xD7\x03\x04`'\x88\x95V\xD4\xBD\x07\xDF\xB5\xDA[9\xFF\xF7\x18\x14\xFF\xBD\xB3\xA3\x88\xE9\x99\x83^\xFA\xA0\xB7\x9C\xFF{+\xB0\xF3\x93\x94\xFFfP\x8A\xB7l\xD5\xE0\xCF\x16\xBC\xF2k\xE1\xCF\x1E\xB0\xB8\xF3\xEA\x8A\xC6C\xB1\\\xC2\xF17\x9C\x10\xFE*\xC3\xFFT\xA93\xBD\xB7\x82_?ls\xFC\x85\xFC\xD1L\xC8\xE4-+\xE1\x1F\xD8\xA2&C\xDFBi\xAAZ2\x00-\x85\xE8\x86\x17]\xC9\x7F\x97\xF3\xFFMh\xAFp\xBD\xC5t\xF0T\x7F\xBEk>Kz\xE7\xAC\xFES\x88\x9FM\xA7S\xC04\xAF_L\x9F\xB7\xE1\x8A\xEF\xEE\xFEq\x18\xFF\xE1\x10\xFE\xF1`\x85\xCB\xA8\xAF&b\xD5\xF4\xF4\xB4M\x86\xF6\xB6\xBF\xC7\xF1\xBF\x9B\x19-\x07\xDB\xAB\x88\xBD;2\x9B\xBE\xFB\r\x85\xF2?\xC0\xFFmn\x8A\x1F9o\xEE\xAD`\xEF\xF9\xC0s\xFB\xB4\x8B\xC5\vU\x1F\x7F\xFAQj\xA3k\xE0\xCF\x1F\xB0\x94\xA6\xE3\xCE\xEF\xAC\xE0b\x13|G\xC7\xCFQ\xEA\n\xF9Cv\xD1\x0FY\x9B8>\x97M\x01\x95\x87\xEC)\x17S\xAE\x1C\x7F5/<p\xAF\xC5\xFF\x1F\x06\xFB\xDF\x9Ch\xA5\xA0hY4\xED\xE2\xDE\x1A\x94\xFF\xE23\xB9\x1D\\Rq\xFDgg\xD3\xF0N\xB28\x9B\xA3\xFA\x8F\xA2,^d\x8B\x12,\x91 a2\xF3Y\x89\xFF\xA4\x81V\x88tm}a\xFD'Tl\xDA\x82\xD5C\xEC~r\xDB\xC8\xF4={\xDA7\xF0\xD1m\x8FA\xE5\xFF\xDE\xD9\x04\xEA\xEE\xDD\x15\xF3\x1E\xDD\xC9\xF8\x1F\xC8\x9Fop\xA8\xD3wx\x19\x07\xE9]\x81\xFC\xF9\xC0@\xDE\xB4j\xF1\x1F_\x03\x7F\xEEw]bK\xAB+\xE4\x05\xD5\x02\x9F\xE4\xD2\xA6*\xB4\xC2\xD1\xB0\x13\x916Q\xEA\xB4S@\xF7\xE1\xD4\t\xF6\xB0\x01\xFF\xA3\v\x9F\x84\xFF'B\xFC\x7Fu\xC7\x91\xE3.\xE7\xFF\xC2I\xF6\x96O\x0E\vz\x1C\xD3\xA6\xC5\xA8\xA1(p\x90\xDC\x89\xD2N\x1B\x87'0\xE6!~\x86M\x1Cn\x81\x9A\x10\xCEN\rW|\xFC\xFF\xCEB\xABA\xFF\x85\xA2\x8B\x99hk\xEC\xAC\xC1_\xB5GU\xC5V\x8F\xEC\xD9\xC2\xEE\xD2@\xFE\xD8\xC5\xB3\x06\n[\xAAh\x188<\x9A.\xF4)h\xA8\x86r\xC2PJO\x18x\xE1\xED\xD1\x11\x17cg\x83\xF5\x82\xD3\x06\b\x02\xF5O\xA7\xF8O\xAC\x81?g\xEC\x15\xE6\xDF\x927\xD6\xC2\xFF\xEA\xCD\x84\xCA\x1F\xFF\xBB 6\xE2\x14\xFF\xD3.\xD4\xC3\x8Fr\xFC%\xFF\xD7\x96\xFF\xC1\xD7z\xE2p\xC0\xC3\xD2\x9D*\x93?Ty\xE6\xFC\xFF\xC8b\xFD\x07^\xD4\xD2\xD0\x92\x1C\x7F\xC3A\xBAOI\xF4\x99\xC6\xE1\t#G\xF9\xAFS\xFC+\\\xFE\x7F\xC6\xA1\xFC\xF7\xE5\xCF\x13\x0EUby*\xFBQ~0\x9AX\xF2\\\x0E\x1Cg4?\xBA\xE5L\xFE\xA6\xD6\x17\xB8/G\x03\x197\x18\xFEI\x03j\xE1[\x0F\x8E>\xFB\x94\x075\x8F\x06\xE9\x96\xAFR\xFC\xBB\x8A\x98\xB4.\xE7\x1D\x8Cf\x82dH\r\x06\xD4\x10\xFEtx\x8D\xAF\x85\xFF\x01\xF6\xA4QG_\x19\xFF\x90\xFC'\t\x82x\xE1\xA30\xFE\xEA\xA9j\xD7\x99\x1C\xD0\x18\xA73\x9D\x05\x9F\xFF\xF1\xE9\xB5\xF0\xF73+\x02\x1F\xDD\x19\xBC\x8B\x1FO\xDCV5\xA8\x86\xE3+0\xB9a\x91e\xEE\xEA3\xDBD>\xB4\xF8\x9B\xFF\xC2\xC1\xD7\xDF\xF6\x8C\xBFm\xFA\x17O<\xD9\xF2\xC4\x06\xC4\xDFlx\xA2\xC2,\xD4\xAE\xC8\xE1\xA3\xD69rQ\xC0\x03^w\xF1\x1Ak\xED\x90\xD0\xDCn\xA4\x7F\xEB\xEE\f\xF0\xAF\x87\xF3\xA5\xBAzw\xDB!\xF7\x16\xE7\xF5\xEFr\x13\xFDF\x17\xF4\xDF\xFB\x1E\xA2\xCDJT\xFD\xD5\xFB\x15D\x15\x91\x06J&s3\x86\x11\x7F\xAB\xF9\xBF\x0E#~\xE6M\xBF\xB5l\x05\x8F`\xBB\xAF~\xBFN\xE1\xBDq\r\xFC_e]\xBDaxx\xC5\xC5S\xA8A=\xA0\xF8\xFBU\xC0\x8B\xF8\xF3b*H\x13\xF5\xEE\xA3\n\x15\xBE\x1E\xAFA,g\x10\xF6Z\xF2'\xBC\x16!\x8B\b\x00h\xDE|\x86%>\xDAEE\x02cE\x93A\x1F\x07\xC0\x86\xFB\xDFD\xE8\xCC\xF5m}[\xDF\xD6\xB7\xF5\xED\x97x\xF3\xFD\xA8\xB9\xDD\xDBw\\\xB7\x98kA\xF8\x9C%\x97\xFC\xA2\xC6|\xAC\xA8\x99\x93U\xBAD\xE0\xD7\xF0]\xF9v\x91\x9Aku\xB2jk\xCB\xAD\xFAX)M\x90U[\xF9h\xD5\xC5\b\xB2r\x8D\x00\xAAv-\t\xA5\xA8\x99\x86\v;R~\xE9\xB5\xDC\xD3UMA\xD1\xDB\xE4<1\x9F\xF0\xECdj\xD3h\xAA\x8D\x1BK\xD9\xC1\x0EW\xF6SM\xFD\xE2\xCB=^\xDE@\x97+\xBC\x0E\x96\xDB\xED\xB1\xACK\xF48\xF7qb\xB7\xBBy\x99J\xD3&\xCE\xE1\n\x92\xC1\xDBY\xA15\xE5\n\xED|\xC5\xAF\xDA,&\v\xA6\x83\x8EJ\xCD\x049a\xD1\xCBo~p\xD9\xD3)\xFB\xE9%Iq|/Kg\x9A\xF7\xCD\xD7\x84W\x98\x1A2\xF3i\x86\xBF7\"\xBD\xD3[\xE8,ua\xE4Pu\xB1rCP\x95\xB8\xFE\xD5\x1A\xFC\x85\x19\xDF\x83\xE2u\xC9\v\x17gFG\xE6=\xB3\xDF\xEB\x9A\t<\x8A\x85m\x92\xCEV\xBC_\x1C\xFF\xC2\xA2\x8B-\xCCk}\x89q~\x05]\x91u\x899\xC2\x05e\xA7\x12\xCB\x80\xED\xE2\xBEX\nkN\xA9\xFA\xFE\xF9\xCBn}=\x7FY]\xA1\x9FF\x98+{\xD2\xA8Y\xA0\xE9`\r\xDE4\xB5\xEC\xE9X\"\xEE\x11\x19\x1DP\x9C\n\xD7\bH\x80\xD8\xB4od\xA8O\xD1Y\xB1\x03\x9EW\xDE\x92\xE7\xA8\xC8\x93|\xAF+\xCD\x05:\x90'+\n\x13EO8\xE0\x85\xF9\xF4\xDC)\x00\xC96\xBD-\x84\xC0\x16#\xF4\xBE~q\xFE+\f\x01\xCBZ\x8A\xFFj\xF2G\xF5\r\xEC\x8C9\xCB\xF1O\xF0:\x86\n\xCBC\xA2\xE4\xD5\xD5ZS\xCA\xFCe\x85\xF9\xDF\xE9\xD0\xFF\rG\xDFCE\xD9B\xDAY)F\x9E-\x88$R\xC2\xC2p'\xFB(3>\x1B9\xFE\xCA\x90\xC9\x1C\xADu%\xC0\x9F@\xE2oK\xF9S_E\xFD\xAB5$\x111#U(C%K\xC0\xDB\xA2Q\xFE\xFF\xE5\x8C:57\xEA#\x10\x18\xDA\xEAO\xFD\xC2\xF8kN\x018\xC1\xE6\x95K(:RYy\xAD\x90\x19\xFC\xB3\xFE\xFF\xBE\xBC\x8C\xD8S\x9C\xFF\xCC5\x17\x9Ap\xEC\xBCPY\xD9J\x90p0\xE5\xD6|t\xC7]\xD4\xAC\x12\xC4O\xFDY\x91N-_~hnY\v\xB90\xFF?\x9C?%R\xEBK\xFCY\x04\xC4$K3N\xF1\x1Fq\x84\xE4d\x8F\xA6Z\x94\xFF\xFE:\xCE8H\xA2FHr\xFB\x9E\x92\x8664i\b\xFEw\xCF\x8D\xA6\x1AZ\x8B\xF5\xD5\x89\xC3\xCC\x81\x90\xCD\xC1\x8F\x8B/n+\xC8\xC4/\x8E\xFF\xA9\x8F\xA5]\xF1p-\xC1ZV\x18)ua\xCF\x11F-+\xA8\x95\x1C\xDA&\r\xD0\xCEi\x8C\xFFZ\x9E\x7FV\xDFY>x\xB2\x97\xD8QA\xC9\xAA\xB9\xE9\xD1%\xEFT%\x93\xC05\x03'K\xDA\x8Av\xCE\xBE\xBAA\xC9\x7F5\xC8\xDE\xAF\x8E\xFA\xF8K\xFE\xDFhI\xFC\x89\x94\xFF\x01\xFF\xE9t\xFBT\r\xFE~\xB5h\xED\x95)W\xF0?\xA1y{\xFF61uQy\xE9!^\x82\xF9*\x95{\x9C.\xF1\xD2?\x8B\xFF\x13\x85\"}\xE4\xBD\x9F\b\xFF\xCB\x92\xFF\x9E/\xF1V\xE4\xFF5\xF6eq\x888\xFF\xA7\x9D\x15>=\x00\xE5bM\v#\x15zy9\xFC\x01\xD4\xBF=\xE5\"\xEAb\xB2\xBCL\xFEk\x8C\xCC?\x14\xB6\xD9\xB9\v!\xFE\xFB\xF87\x0Fq\xFEo\x9CI\xF8\xF8\xB3\xBA\xC6\xB0\b\x16\xDF\xA8\"\xC2cCTD\xF4\x95\x94\x844\xB4\xF1\xA2!\x96\xD8G\xCE\x8E\xA6\xE2^\xF9x\xF5\xC5\xB3\xA7\xFC\xF1W|\xBFJ\xEA\x9F\xC7\xFF#E\xDA\xC2]2^`\xAD\xF1\xD7\xB7gjA\xD9\xCDrq\x05\xFE\x9F\xA4\xF2\xE7\x12\x07\x99\xF3\xFF\xB8\xB32\xFF'Q\xC3\x7F\xC2\xD67k\xDAl\xD8~\xC2\xA0\xFC\x7Fyf\x99\xC1\xAD\x91%\xB6JI\xFEg\xE8\xE3\x0F\x16k\xE5\x8F\xD2i2\xFC\xDB\x94\xC4\x88#\x02\x8Bt\x19u\xE9\xC4L(\xBF\xCA\xD8^E\xDC\xCB\x1B+\xC9\x7F\xED;\xC7\r!\xDB'\xB4S{\xDFN\x95K\xA5\x972\xA3>\x03\x05\xFF\xEB\xF4\x7F\x1E\xFF\xAF:(\x1B\x94\xFF\x04?o2\xB1\x92\xFC\xFF\xE6\xF0J\xFC\xB7\xC0C\xF3(\xFF\xD9{\xFC\xAB\xE1\xE5\xB7\x16\xE4\t\xCB\xFFn6\x1C\xD4|S\xF1\xB7\xA7*\xB8\xC3E\xF9\x9B\x17\x97\xB5P\x00\xF0\xEF\xA4\xD3>i<\x15$\"\v\xC6\xDFN\x16>i\xB5),Y\xBB:C\xEFRa\x1E 6\x9CX\x151\x16\x8B\xD4\xA4-\xE3\xBF\x9C\x7Fi\xEF\x1D\x93\xFC\xEF>;\x9A\xD32S\x17\xAA\xA5\xC3g!c\r\x84\xFC\xAF\xD7\xFFy\xFC\x1Fg|\xB3\x8BKU\xF4\xED\xAB\xF8*P\xB1!\x8AP\x1B+\xF2\xFF(\x0F:\x10\xFC\xE7\x81}x\xA7\xB22\xFF\xCBEL85\x1F]\xA9X\xF3E r\xF3Gli\xE3\xF4\xDC\xE4\x8A\xF2\xFF.[\x1C\xCFwN\x88J\xC7\\\xFFT9\xFEh\xC6\xF7\x00\xAB'\x9A\xF2\xF5\x9F3\xDC\x03\xC7V\x9C-@\x83\x94\xF6q/\xEF.\x9B\x7F\xC5=\xC4\v?\xA5\xF8'\xA8\xFC\x8F\xAB\xB9\xC6k\xD7J\xA5\x7F\x1A\xCB\xF8\xAE\x0E\v\xBC\xFFZ\t\xEA/\x8E\x7F<\xF1\xAC\x85EV\xF4\x7F\t\xFE\x89\x15\xF0\xA73\xA6[\r9\x9Bl\xA2{\xFF\xB4Lf.\xBA\xA8Z,\x04\x06@\xF3\x04O\xDF\xF7\xC4*V\xFA\x8F\x8B\xB8\x12z\x83\xBF\x02xVm:,e\xF2k\x0E\xBEha6\xF5\xEDe-$\x01\xFC\xCD!\xB1\xD2\x94g\xE5l\x9E/\xFA\xF8\x93\x94\x01\xC4\xF0\xEB\x07\xD2\x88{=M\xC4\xC7_\t\xF0W\x10a\xDF\xBDB\xA0\xA85\x12@=#g\xB5\xE3\x18\xE6\x15^\xD0}.\xDB}\xB1N+\xBDt\xC3\xFD\x81\x04\x10\xE9\xFD\x95,\x1A\xBE\xF9\v\xE3\x1F\xD9\xFE\x13\x03\xEA0\x1Cc\xA9\xC0\xDF^Y\xD9V\xCF\xCA\xE6z\xBE\xFA]7\xBC\x82=\xC1\x94\xE5\x86\xA1\xBC\xF4\x1C;\xE1\x85\x15F\x13z\x82:\x8C\xA6p^2\x17\xB1\"Z\xC2\xEF\xB4)\x1B\xB3`\x1B\xD8\xB0ufY\v\xDF\x05\xF0\xE4\x83\xDF\x15\xEF}\x96\x8A\xA3\xBF0\x02\xFC-\x03P\xBD\xE9\xAF\xECb\x01b\x1B\xFC\xF9\xEF\b\xD3g\xBA\x0Fx#\xAE\xC7\xA2\x15\x98\xFC\xF7+&\xACo\xEB\xDB\xFA\xB6\xBE\xADo\xBF\x94\x1B\xC1J\x19\x06\x95\xB0\xB5\\EMR\x9D\x90\xC7\xA9\xC2\xFDp\x83\x9F4\x18d\xA9\xB1]\x15#\xFE*\x16\x86\xD0F\xF5\xDB\x88b$V\xE9\xAA\x01\x19\xAB\xC8<\xFC\t;\xC0r\x07\tw`%8Q\xEC(\xF2\xB8R\xF3X\"\x01\xC5\x92\xCE\xF3\xF3k\x1D\xAD\fy&\xBD\x84\x04\x07C\xBA\r\xC5P\xF4\x84\xD4\x9E\x1F:\xC1\n\x97B\xE0k\x10:\v\xB4\xE4\xF8o\xAA\b\xAB\xE6g\x84\xC7\xEFv\xDF\xBA\x0E%\xDD\xED85\xFD\fRVz\xF4\xBEJ\xBA\xAB\"\xDC\xB0;s\xA6p\x96V\xF6C\xB9\x97]\xAEv\xCDx>\xFE\x1Dn`\x01\xEExM\x97v{~I\x06\x8A\xD7\xA6\x15W\xCC\x93;\xF2\x8Eg\xC4O\xE9\xCE(QnP\x89\xD7\x03\xCBt\xFE\xFF\xC5_\xF9\xDF\x8D?\x9DzU\x9A\x18\xFE^\xDC\x15\xF8\xF3t7B\xFD&\x96\xC8\x17\x19?\x13\xC6\x1F\x87\xAA5\xD6\xFE \xF3\xBC\xCE\xD3\xEC\x14-Q\x19bq\xC6\x94&q\x1B\x8A\xDD\xE6\xD2\xF7\x92L\x00q1Y6\x8D\xC0\xDEn\xF6{PB\x99\x18\xA3\xD7\xA0\fu\xCDl\xDF\xE4\xAE\xBC\xF0\xD4=\xA3F\"\xFA\xC8;\x13:Qz\x1A2w\xF5\n'v\xA6\xE0y\x815&\xE4\xD6\xCE]\xD9y\xF4Gp\x02\xA4\x8B{\xD8\x07^\x9E\x1F\x9C\xE3\x06-\xF0K\x16e\xFB5\xBA%\xB0\xC8\xDD\xE9\xE3\xDE\xE2\x05\xFAO(\xA8\x17B'\xB0\xDC\x14:0\xDF\xFC\xC89`\xFERn\xC6\x91\xFCg\x1F\xC35K\xB4\xFC{\"\xD7\xA5\x80\x85\x03\xB88Kjd\x85\x9Fx\xB9A\x07\x19\x85\x92\x9E\xAA\x88\xE5\xA1\xCE\\V8\xEB*\xFB\x11\xCF\xB3\xD7\xD7\xDA5\xB3\xFF\x93\xF1\x7F\x12\xCA\x86D\xFFtu\xA5\xA5?B\xEC\x94\xA2\x8E\xBC\xF5*Q,cT\x19\x9B\x1B4\xF3\xC1\x12)\x97J\xA9%k\t\x04i6\x91O\xB1\f\x15\xE1\xF0\xE4t~T|\xC85\x99\xC8\xACt>\xE1\x17bN\x89\x16\x84\xC1\xC7\"\xA3\xC2\xF1\x918i\x88\x99,\xCF\xBA0\xBE\xD3\x04q\xD0\x80\t\xE2<g\v\xC7\xC0\xD1cC~}\xD5'\xB4#h\xD0\r\x16 \xD0\xE5\xA2-\xF1J\xC2\x81>\xE61\xFC\r\xEEf\xCCZ6\xC4z\xA8\f\xFC\xFF\x88\x17 >T\xAD\xC5\x7F0x\x11\xF5\x1E\xA2\v\x94\xFF,\xA5\xC6w\xE7\xD3\xC2Y.>\r\xED\x14\xCF\xFB\xB4\x10\xB7\xFD\xF2\x97U#\xC8\xD1tu\xC7\x02\xE2\x87\x83f\x9B_F\xDC\xBB\x92\x19znE\xFC\x95tNQ[\"\xFA\xE2\xFC\xA9\x9E\x06\xE5\xD9\xAD\xFBv\x9A\"\x1A\xAAGV\xFB\x95\xF8\xCB\xB5\xA1X\xB5\x9F\xA5\x96\xDE\xEBJ\xFC\xFD\xB4'\xB3\f\xFF\x98Wc\xC5\xAA\xF7\xD2\x87\x02\xFE\xB3\x94\xFBsw\x9C\x17.\xE5#\xE7\xBD\xBF\x11\xE9\xDF\xAB{\xE9s}\x1F\xC0\xFF\xC5\xA6{\xD5\x9DU\xD4\x7F\x1Fq\xEF/\xCE{\x17\x0F\nF\xFD\xAC\xFD\x0F\xFC\x84\x00\x8B\xFF\xB8\x1Dq\xCF\x02z\x88\xCE\xFC\xC0\xCB\xFD.\x16\x99\x89o\xE4\f\xED\xE1I\x01\xFB\x06\xF1\x89E\x9F\xE6\x8D\x9C\xA0c\xEA(\xE5\x7F\x8D\xFC\x19\fv\x98\xEB\xE6i\x17\xD0\xF6s#\x89\xB0$k\xFB\xA1\x15\x99\x03\xE4\xC4\xD4\xDC~\x16`\x05n>:.\xA7\xBAS3*\xB4\xD02G\xE3\x02\xB4\xA1\xA9\xF9{~\xEC\xAC\"\x7F\xCEP\xFC[\xD4\xD1DL\xD9\xD3\xF9?\xFEh\x96\xD7\xFB\b\xF0\x97\xAB!~^\x05}\xC0\xDC\xCEk\x8B\xF3\xB49~z\x84\xF4A\x9E\xF2\xA85\xF0\xC1f\xA5NGf\x03\xFE\x0F\xB2\x9A\x05YS\x9C\xD0C\x06\x8F\x89`\x99\xEB\xE9O\xDA\xA0\xCF\xFF\xFF|\xDE\x04\x19\x8768\xD1;\xF47\xB3\x82\xFF\xDF\xFC2\xF1\xCB\xDA\x16N\x96\xD0\xD0y\x198x\xD1{\xCA\xC0\x13\xC9\xF2\xE1\xA2\x90?v/eKY8:\xEE\x12\xF1!M\x8F\x86\xF0_\xCCwTkV\xDB\xD5\xC1`\x87, \xEE\x1D\xA583\xF9?\x97\xDE(5!h\xDF`\x0E\xC0\xA7\xCA\x19 ._\xA8\x11\xD8\xBB\xCAS\x1E\xB4\x97C\x06.\rZ\xE1X\xE7\x0F\x9E\x1C^\x01\xFFE\xD7J\xC4\xBD\x96\xC8\xAB-\xF1\xD1\xEB\x15%\xB1%C\b\x17 \x16K\xD4\xFC\xFD\x10\xFF\x83\x8A\x06\x0F\x97\f\xFE^\x1E\t\xD7\x8E\x04\xFA\x9FL\b\xFE\xC7B\xD1d13}\xD0\xF3\xDF\xD1\x17\x05\xFF\xC5\xD7\xB4\xF7\x82\xF77\xA2\x10\xC0O\xEE\xB3\x80\xC6\xF7\x00|\x89\x7F\xD4t$z\x1E\x8D\xDF\xAF\xEE\xF4\xCE\xF7J\xFE\xB3\x02\xD0<!\xD8\x95\xB2\x90\xFF\xE7\x9B\xF5y\x17\x17.\xBD2\xE7\xE3\x9F1\x03\xF9\x03K&F\xB0|\xEB.\xB4\xD1\xD3E+\xEC\xB9Z\xCB\x7F\x03j\x8A\x9D\xE61\xAB\xA0\xACJ\xAFy\xD0&\x19\xFFGO\xCEy~\x83\xC7\xAC0\xFF\xD35\xFC\xD7\xE6\xD0\xE8\x1Dw\xAD\x15\r#$\xEE%\x14u\xF1\x82\xBExqT\xCD)\x89\xCE\xC1\xC5Y\x8E\x7F\xDE\xE7\xFF\x0E\t\xBB\xCF\x7F\x8B\xE1\x9F2\x84\xA1\xD2O\x1Eh\xF1\x18\xC2X+\xEAG\xC3\xF2g\xF4\xC9\x84\xCF3\xCE\xFF/n\x16\x0F;`\x0E\x1E\x13\xF8\x1B\x9Fw\x01\x95\x8A\xE8\xDD\xECS}\xD2\x1E\xA5#\xA66xp\xE7\xD0\xA9\x07\x84\xE8>\xC6D\x1F\xAF\xDD\xF0\xC2|\t1\x8C\x03\xED,\xE2\xAFM\xC9m\x95\xFA\x8F\x9D\n\xE1__}\xD7\xAAY^g\x00\x1E1\xC7<\xE1\x04\xB2T\xFE\x0F\"VE\xE3\xB5-\xF4{\x1C\xA0\x82\xA8\x9C\x95>\xF39h\xA7\xB8\x03\xF6\xE4\xE1\x82\xDF\xE0\x94\v\xE9r\x8FRo\x15ZH\xFEk%\xCA\xFF\x8E\xEAHee\xF9\xB38C\xE5\x0F\x89\x9F\xD2\xF3\x8A\xDD\xE5%\xCC\xA5\xF8\x8B\"\xAD~]\xA4\x98\xBA\xF7\x98\xC7\xC5\xCE\x9EZ\xFE\xBF\xF0\x86'\xDE\x94:\x1A\xE6\xFF\xD8\xC1\xDB|\xF9\xBF\x97\xF2\xBF\xF3\xDF\xCA\xDAU{\xCF{\x7F#\xE4\xCF\xF6\x01K\x98\xC7\x7F\x9F}\xAA?\xDB\xB9\x19\xF5W\xD0\xF8\xFD\x1F\xF7z/N\x8B'\xFD\xE6!\xCF\xC7\xFF\x8Av\nqo\x188\xA6\xE9'\fL\xCDy\x93F\r\xFE\xAF\xC8u\xFCV+d\x8Ef\xEA\"\x94\xEB\xCD\xD1\xD4\xAA\xF87\x98P\xD2\x14\x7F%C\xCF\xCF\xA5\x83\x98\x91\xC6\xD1\x0E\xAA>\xA5o\x9A\xF3\xFC\x06\x13N\xA0\xFF$2\x19(?\t\xE9?\xB3\xD0\xBC\x8EY\xDB\xB6V\xC6_Q\xD4\x16E\x1F9\xA3\x1A\xF9\xDCP2\x95\xB0\x01U\x87\x9A\x7FB\xA6p9\xCC/T\xAF\x97\xDD\xFB\xC1x\x1FU\xC0\x0F\x02\xE3V\x8D]t\x94{\xCF\x13\x1D\ra\xF9S\x85:9\x11\xD6\x7F\x1A\xE6^N\x8A\xEA(\x93\xE9\x01\x11\xAC\xD4\xF0\xEE\xF3\x15 ~\x05\x00\x97\xAA\x93\x99\x05\xA8\xADhh=2\x8AW\xD2\x82\xFF\xD5\xD1\x07\xFD\xE5\xC2g\xFBK\x88]o\xB0za\xFD.z\b\xFD\x12\x05\xFEg\xB6B\x98p\x01\xB2\xBB\xB5\xB2\x1C\xFFD\xFB\x12\xFC\xE3_\x90\x0F\xF8\x05\x86\xFF=}\x15\x91u*\xC0_\xC9A9\xC2\x02\x90=#W\b\x1A,\x06\xA6\xFEM\xB9t\x8D\xFE\xAF\x94\xA1\x14\xDA\xC8Z\xF8\xB7):\x89\x8F\xF6\xA4\xF3\xE3\xE9\xD4\x9EQ\x86\x7F\xC3\xA7\x9F\x90\x8B5\xDF\xE2\xF8\xA8\xBA\xEFL2\xBE\x85\xE2?\xEA\b\xFC\xFDu\x818\x8F.l\xF4\x10\t\r\xF6\r\x89\xC1>\xD3O\x8Dx\x90\x1D)'E\x0F\x0F=5tL\x14\"\xB9\xE1Y\vP\xBF\xC1\x03\"\x00$\xD3\x06\xB4\x02\xE23?~j\xE8\xA9Q\xC1\xFFC\x17K\xFE\x82\xD1\xD5\xA4\x89\xF8\xE0=\xC0\x9F\xD7c\x18\x18n\xA4\x7F\r1\xFF\xA5=1e0\xBB\x98\xFD\x91\xDD\xBE\xBA\x0E\xE5\fQwA\t%\xABQC\xF3\xAF\xC8V\x9EC\t\n\x1D\xB2\xDBsY\xDB\x8F\x99U&\xB6\xD2\xD7\xA7v\xCCx~\x83\xDB\\l\x95\x04\xDB\xBA\xEF\x9EZ\xFD\xFF\n\x14\xAFkv\xB7]Y\x15\xFF\xD7\x88N\x145\xDB\xFF\x9D\x0F\xC7\xBC;)\xBF\x1EA\xC3\xCCF\x17\x88~?4\xBD}\xC4\xF7\xD8\xD9x\x8E\xB6\x7F\xCB0\xF4\n\xC2\xCE\x87\x8F\xBC\xEF\x89\x07\xA9\v\x15\xD1P\xB7?\x95\xD8\xE7\xBB\x18}\x87>\xFB\xAF6\xBE/\xC2\r\xB6\xED\x1B\xFCkaA\x98\xB9q\x18h\x1C\xF7C\x11\xAA\xAF{ )4l~f\xDF\xE0\xF6/\x89\x10\x83\xA7\x0F$\xFCx\xB4O\x8D\x9DB\xE4\x1B\x87\\\x8C]\xF4^p\xF1\x02\xFB[9\xB0\xB0n\xFEZ\xDF\xD6\xB7\xF5m}\xFBe\xDDB\x86\xE5\x88\x9A\x88p\xAB\xA9\x1E\xF1\x1D\xD8y.Y\x91\xAC&\xC8\x96\x13\t\x1BskM\xB8\xC1pj\xAC\xB6\xE2\x80`Aa\x95\xB8B\xE2\xDFUAm\xE5`#\xB4\xB2\x90T\xE0\x970v\x80%\xA9xd\x98\xBC\xA3K\xEB\x1A\"a\xEF\x7FGz\xF2\v\rH\x97;\xCCi\xD0\x19\xF8D\xF8\x19\x16\t\xBA\xB9<\xBAA\x97\xB6h}\x95\x15\x16\x96\xB9\x97k\\\rj9\xA2\xB3\xD5\x8F\xD6\xAF\x1A\x87\x11\xAD\x8E\xBC\x93\x1Fy\xCD\xF8\x10@\xB3^\xB3\\\x127>l\xF6\xC4\x1AA\x9C\xCDm\xB9y\xB99\x8Bf\xEB\x92\x8By\x17\x97\\VC-d5\xE2\xC7\x17]\xEC\xB5\x02\xFC\xE3gTD\x16P\xBF\xB0\xF15\xAE\xB6m\xF0\xB8b\x0E\x13\xF1\x89\x1B\x1E\x9EI$\xA8:\xA1w\x9D\x016\x88\x97\xAA<&\r\xE3\xC96\xC5\xEB\x98Iw\xCD\xE8P\x9C\x0E\x17]3\xCCy\x1B\xE8\xC8e\xDBx\x16P%\x9B\xC8\x89n\x9B\x16\xDA\"A]\xA76\xC52\x86\x01e\xFB\xF5b\xC1B\xBF\x9E\xEA\xC3\x06\xD7\xB4\x93\x07$\xFE\x11'\xAC\xA3v\x1F\xAAq\xFC6\f\x8B(\x1C\xFFm>\xF2\xE6\xB2\x85\xAA\x84p\xE1\xBE,U\xCA&\x8A\x7F\xE4\x11DT\xC4=\xF1\xBE\xE2\xD9M\xE7T\x8E\x7F\xA4=\xCB|V\xF2\xE8\xAF\xB6\xD0v\xBEP\xC3\xED\xC8\xF6O\xCDL\"\xFE.\xDBO0\x90Y\x80\x80bA\xC9u\x16\x914\xE8\xC4\x81\xE5\x0E\n\xF2Qt\x16\xD1n\xA0\xDD\xE2\x1Et\x16\xAF\xDE\xA5\x8F\x9Db\x9DT\r\x91u\xD3\xE5\x86\xCA\xC5y\x0F\x8A\xD9\xF2\x94\x99\xE8\xFF\x9F\x00\xBC\xB4\r\f\x8B\x15\x1FV\xD7\x98Uv\xF0,\xA2\xDBf\xDA2\xB3 \x9Em mz\xDC\xC2\x99\xB6;\xFBgY\x83$u\xDF\xEC\xF3\x82\xD6\x0E\xF6\x9E\x0F\xAC(\xBD\xB3^\xBF\x03\x903C\xC2j\xE7\r\x9D\x7F\xD0/\xA0y\xDF\xF9\xFB\xE4\x89\xC3\xE2\xD6\x82\xB05U\xED\x8C.oq\x86\x99\xFE\x98\xCB5\x9F\xB9w\x04\xB9a\x05\xFD\xBA\xCEx\xFE\xC7\xDEFu\xF2G\x10\xF5\xE8\xFF*\x04\x11\x19\x8A\x12Q\xAB=b\xA5\x80\x99F\x19\xFE=&\xC3\xFF\x8Ba\xA3\x04\"i=7\t\xF2\r\xFE.\x98\xB1:'\xD7\xBC\xBC\xCE\"\x9D\xE1\x9A,\xCE%\x8C\xFF\xCD.\xED\xD8\x16\x03wZ\xEC\xBBc\xFC\xECV\xD4\xA0x\x01\xBD\x85\xF0(n\x81\x81\x86t\xB6!\xB9\xC8\x1A6\xC7\xDE\x16\x8EG\xAA\x015-\n\n\xAB\x9Dc\x17\xF5|2\x9BK\xEBhP\x0E\xB9\x18M\xB6>\xC5\xEE5\x9E\xEC|B\xE5\x1A~6'\xCD\xF6\xCFYx\xA2!\x88\x13\xCFo\xC9\x8F:t\xB2\xFCBQLj^8q\x89\xB5\x7F\x18@\xE1\xC4*\xD5c\x9F\xA8\xC1\xBF\xC3\xB5\f\x06\xB2\xC5>g>sL\xFA\x9F\x8BL\v\x96H\xB1I\x1Cs`f\xF8[ \x05\x10fU\xF6\x1D\xB1\xE2\xEA\x89~\x8Fe0\xD3#1U\xC8\x9F\xB7\xAAL\xFEps\xA8\xBCu<\xFDa\xF3$\xA2\xCC\xFF-\x9E\x80Z\x90\xF2\xC7B\xB3~\xC9\xC59&m>0\x80\xE6?\xF0\xBB\xEA\xB2\x8C\xD0\xF3.>\xA4\xF4\x10\xD9\xE0\x95\xF8)\x16;\xAF\x963G\x02\xE1\v\xB4\xD4'A\xAC\xC1\xFF\xB3\x98`\xCB\n\x8B\xAA\x05\xD4\xC9o0#W?ho\xEB\xDD\xD1\x88\xA3#\xA2\\o\xA0\xF1\xA8\xC7\xAA\x8F\"~nH\xA6bK)\xCE\xB8?\x1E\xC5\xAC\x00\xFFO\xB9\xD58\xED\xC9=\xF2\xB3\xF6\x90\xD0(-#t\xDE\xB4\xD1\bW\x03\f$z\xB7S\x93}\xA5hX\x063\xFC\xA6\xE2\x9E\x8F\x7F\xE0$\xAF\t\xFC'2\f\x7F\xE6\xE4/l\xC5j\x01\x8D\xD7\xA8H\xAF\xAF\x8A\xD6c\xD9\x8F\x1C\x87u[\x8D\xA8\vP`\xAB\xC4\x8A\x199f\xF1\xA8\xE1\xBF\xAA\xE6\x92\x93hb\xFF\xAB&\xE8q>\x9DW\xF7C\xF5\x0E\x171\xE6\xE2\xB0\xC3j7\x84\x9C\xEC\xC6\\\x1Cr\xF1\x9F\x86\x19\xFF#*_\xF8\xA3\x1FZ\xE35\xD4W\xFF\xE3\x05\xEE\xD7\xD7\xC4\xE5\xFF\xC8\xF9\xDB\x00\xE5\x8F\x9EJ$\f\n\xBB\x1D\xC8\xFF\xEDP\x9E\xA1_t\x05P&\xDB\x94q31z\xF3>\x0F\xB8b\x1A\xE8\x9Ch\xE5\xC6\x8D6\xA5\xB3k\x86\xEB\f\xD9\x9B\xDF\xF7\xFC\xB5\xD4\xF6\x1D\x81\xFC1\x13yJT\xC5\xED\x16>\x84\xE5n\xF3]\xC42\x882\xBF\xC7D9\x00?v} p\"5\xFC\xFF\xF3\x8E*\xC7\xBF\x87\x85qp\xF9S\\\x86\x7F\xE9!\x86?s\xF2\xA7\xF87f\xD9[\x1E\xA5\xF8GZ\xE5\xF8\xAB\xBF<\xEC\xE0\xD0(\xEA\xDF~,\x97\xE4\xF8/\x9Eg\xF8s\x83\xBF\x1F+\xA8n\xCD\xA7K2\xB0f;\xDD\xE1\xFCW\xE9k=\\\xA4\xC2\xE1\xB0\xC3DDC0\xFE>e\xD0\xC1\xFEkE\x9C\x1D\xE6C\xB9\"\xF3\x89\xA5\xA1M\x943\xFC\xCCG\xB8\xFCO\xD5?\x88\b\x19h,\xFD\x0E\x93\xFF\xFB{\b\xCF\x87\xC0\x92T\x83g\xBC\x07\x99\xEC!\xCF\xDB\xA6\xDAC\bH\xA1\xD7E\xA6\xE4q\vs\x0F\xE9\xEC\xE1%t\tI\xE5\xC5 \xD8\x03\xDCafB\xF2\xBFz\x07\x1DD\xB6g\x84\x0Fs\xD9\xFE\xB39\\\xE7\xF1:\xC5\xF7\x1D\x93g\xC6\bb\x81G\x86\xB1\xAB\xA6\x94d\xD9\xC0\xC6\xB3L\x9F\x88\x06\xC7\x03\xFC\x1B\xC5\xE3\x1F\xD36\xF8\xEA\x10\xB3\xD5OC\xD9\xCD\x07_D\xF4\x16\xE9\r\xD2\x02\x07\x8EJ\x8F\x8F\x95\x10\xF5\x16\xE7\xF3N\x97w\xC5\x02\x9A\xBFP\xB3\xAE\x1D\xCF\\y\xA6\xC4\xF3\x81S\xF9C\xF9\xCFdQ\xB3\x87\xE6B\xA0\xFFP\xF9\x13\xC8\xFFyv\xFC\x1F\x87y\xB2q\x81\xFF\xA7\x0F,P\xFC\x95\x1B\xCC3\x8C\xFFQ\x87\xCB\xFF{+\xB7\"~\xF1\xBE\x07\x93\x0F\x8D2\xB9:v\x11\xF5\xEC\xC3hJ\xF1\xEF\x8E>t\x93\xF7\xCE\x8F\xC6\xDF\xFAQ\xF6\xB5&\x0FMW\xDE\x00\xCE\xBE\xA4\xF3\xCCM\xEF\xFC\b\xAF5=\xCF\xBF\xA73O\v\xFC\xFF\xD6\xC5\x7F\xDF\xFA\x90\xDF\x9F\xCA\xD3\xD6Y\x03h\x1A?[\x14_\xDEt)C_\xEEus\x00\xDE~I\xF2?\xA6\xA0!\x90E\xDD\xB5\xB6\xA9\xA3\x86E\x18\xFF\xED\xDD\xBB|\xFD'pq\x97\xE9h\x8E\xF2l'L\xD2M\x182eJ\xDD-\x94\x87~z\xB1\xB8\xD7B\x87\x11B\xBF\xB8\x94\t\xA2\xE4\x8D<\xB6$\xAE\xA7\x14\xE5\xCA\x98\xAC7\x1D9\xDC\xA2\x94\x84\x06\x1BI\xB0EX\xF6})\x03|\xFC=\xCAj\xBC.\x19\x7F\xB7\x18T\xFF\xB9\xA9\xC8\xE4~\xD4\xE5o\xF3\x02\xF8\xF8[j\x91\xCA-\x97\xFF;\xE2C\x88\xA0\xE7k\xC5o1\xF9\xBF\x9F\xAA\xE6\\1\xCDqS\xEA\x1E\xCA\x7FJr\xDBT{g)\xFFw\x1A\xB8\xA3\xE4\xF5W8\xFF\xB3}\xB3\x82\xFF\xF7\xE5\x85\xFE\xD3\x07\xEC8\x18\xE6\xBF\xC7\xF8\xEF\xC9\x18:c\xEF\xCEY\xA6\xFFP\xFD\xF1\xCE\x9D2\xE1U\x83\x82\x86\\\xD8\fX+\xFF\x8DV\x8E?K|\xD6\xBA\x84\xFF\x12\xFF\xD3sI\x7F\xA2$\xF1g\x1A8\x95?\x01\xFF\x17]\xBB\xCA\xF1\xEF\xA5\xF8\x13#\x1F}\x8D\xE3\xCF+\xE3\xA4\xFC\x99Zk\xA2,>\x87\bKN\xA2\x1C\x96\x0E<zg\x11m\x16\xC5\x9F\xA9\xE8\x7F\x10\xC6\xBF\xC3\xC5\xAF\rs\xCFgC\xF0\x7F\xCC\x03\xBE\x87zUV}\xAA\xE3\t\x94\xBE1\xFCuDSG\xB4\x89\t\xE6N\xA4w\xE4B\xF8\xD3W4\xE0\x04\xF8\xF7\x10\x1B\xE4\x8A]D\xDA\xD4y\x01\x9A>[\xED\x13\xF2\xC7N\xCD\x8E\xFB\xF8\xEF\xDC\x19\xE4i\xB1\x0E\xDA\x83\x06@\xF4\xCFK\x97\x03\xDB\xB6AL\xC4f\x01\f\xDAR\xCE7\xA8\xE1j\xC8\xAD=f\x8D\xFE\xD9F\x06\x98\xA7\xFF\x10c\xDA\x00k*\b\xED\x94i\xA9\xDA\x94N\xBE\xBE#B8\x95<\"&\xFD\xA7\xE8\"\xE0\x9AM\x16Z`\xA2\xEB\f\"3\xCD\x9D\xD7(u^#P\x12\xC9\"\x8B6\x82\xFC\xCB\xF077=.\xB2wF\xF6\xD1a]\xF0\xDF\x86\xD2J\xF1\xAF\xF8\xFC\x0Fi\x0E\xAE\xE0?sP\xB18\xFE3\xC3*\xA2i\xFA\xE9\t\xFEo\x1B\xE5\x86z\xA7\x13\xD7\x99Gn*%\xEC'\xA9j\xD2gK\xFC\t\b\x9D\xE9\xEC\xA0\xFC\xDF-\xF17A\x88m!\xDD\xEE\xED`\xCF\xBE\xC7T\xFB\t\x8B4!\xA6\x9D\x175\x88\xFB\x81\xDFj\x7F,\xC0?\xBF\x8D\xE1_\x18\x10\x11=9\xFB\xD8\x1CH\x99\xCB\xFF\x94/\xFF#*\xA2\x01\xFE\x03\xED5\xFEqF\xBB2\xCE\x86\xFC\x12\x1BY\xC6\x8D%\xF8\xDB\x12\xFF\fd\xA1v\x81\x7FL\xA1\xFF\x9At4\xE9\xAF\x895w\xFD~\xDC\x00CA\xB3r9\xA1\x00\xDBH\x1DY\xFC\xD1\xD6w\xA8\x90dF\xF2&a\xC3G\xDD\xB6\xB7\xFEQ\x01ng2\x9F\xED4n\x15\xAB\xF6M\xDE\xD9\"\xDE1\xF0\xDD\nh\xB3MAn\x9C\xD7\x80\x7Fp\xF1\xB7\x06+\xD8\x12\x17\x8EOM\xD1\x054\xED\x02F\xEF\xAF\xE3\x81\xB1\x15^\xD8h;\xDEDD\xFD\x9D\x8B\x0F&\xC6\xE8\xF8\xAB\x7F-)\xF1\xDF\x80\xD8\x9B\x00v\x1B@l\xB4\xFF\xBC\xD7?\xEB\xF5\xCF6\x81l\xE85\xD0?\xAB\xDF\xCB\xA6J;H\xF6\x91\vl\xAAK\x9A\xEE9$\xE6\xBC\x8F\xB8\xE8\x89\x05\xAB\x8D\xFD\xE7\xDF\xDC\xC1\xE4\xCF\x0E\x91\x82\xEF\xB1\xBDf+b\xDB\x10\xBB\x15\xC0\xE76?*O\xBC\f\x12T\xA3\x1E\x1B\xAD1\xDA\x1B\x17\x17\xE2\xB9\xED\x00\x0E\xB8T\xF0\xF1(\x90\x00\xFF\xA8\x10\\mQ^\xFBxAT\x06W\b\xD4\x05\xFAo}[\xDF\xD6\xB7\xF5m}[\xDF\x02\v\xBBN\xC4h\xA7\x07\x0E\xFC\xA8\xDD\x13\xBBI1\xADSV\xB2m\x8B\xF3\xF4\xD0q\xAB\xC6\x96\x1F\x11\n\x86T\x92\x1C\xEE\xD7\x1D\t\xB7\x13\xD1k\xEB\xF9\xAE\x90\x879d\xD4WImx\xB5\xB8\x834\xF1\xF8\x89}\x96\xA5\xFD\xA1}\xAB-m\x1C\xBE\x91\xBE\xEC\xBE5G\x88\xD0\xD0\x8Dp\xE2 eI\x0F\x15\xF6\xD7\xB1\xD6J%\xCD\xF1Wt\x93%\xAB\x17\xAA\xA9\xA2B\xC9nbv\xEF\x06i\xC7\xEE\x9AI\xFF\xE1\x8C\xD75\x93\x14V\xEEZ\xFC\x83\x1C#\x8A\x97d\x97p\x9F\x9F\x04,n\x12\xFF)K\xFC\"\xD1aI\x93\x94\xEDP\x9C\x04=\xD3j\x8B\x7F\x1D@\xC7\x85jB\xF1\x8Cs:\xE0l\xF2\xBD\xF2\x96\x14zP\xB2P\xBC6e\x9B0O)j\"%\xFC\x19:*0\xA9\xE2\xC7\x16\v\xB8\xF7\xA9\xE2\xB1\xFFX\x04H\xA4n\x85\x92\xF0c0\xDB\x00\rV\x9B\x92\xFDX\xBAg\x873\x99C\xD1\x855)\xD8Z\xFD\xA9e\x97Ko\xC4<mL\x12\xF7\xB8\x1F&\x94l8\xA2\xB6M)@\xD9\xBE\x85\xCE\x89(\xFE\x1D33k\xE0\xDF=\xE3u\xB8\xA8R5\xD5`\xCA\x92\n%e\xB2\xF9\x88\x9E3\xB8%\xB1MIg\x129#\xE1\t+w\xD4\xC3\xCAk`z\xD7\f\x8B/\xE0]}G8\xFC\x9B<i\fs!F\xDC\x1B\xA9\xB0\n\x02,\xF5P\xF2\x99l\xA2\xA1\x8E\xE7\xE7\xDF4\x93\xEB\xAA\xAF\"\xBA`\n\x9Fj\xAF\xC6_\x85OI\x94B{\xCA\xE6S-\xE6k\x94\xF2W[\xD8\x8A\f\xCB,:\xC3\xD7b\xF4\x0E\x16\n:R\x81q\xE0,\x94\x82\x9Fb\xA3\xCB\xC5\xC7\xF3^\xF7\x8Cu\xD8\x10\xE4i{?\xEC\x18\xE3mI\xD4\xDE7\x1ED.$\xD9L\x87\x01e.\xBAE\x91\xADBI\x99\xE1Rt\xEF\x9B\x88O\xD0\x19\xE8\x05\x0Fq\xCFL\x94\xD7\xC0?\xAD\x14\x92,]6}\x89\x82c\xA9d\x07\xCB\x86t&\xC5\x99\xD6\xA6d\x1FJ\xE4\x12\xA9N\xC1\x7FR\b\xB7\xD0\x15|\x99z2\xA1\xFB\xF8'\xACqN\x9B\xCD\x16_\x06\xE2~t\xBC\xDAZ+\xA2\xAD\t \xE9\x14\xBA\xE6\x19\x81\xCF_5\x13\xB9\xB6\x88\x0EEM\xFA\xF2\x87,\xE7\x7FaK\x82\xAF>\xA4\xA1\xA4\xBAf\x02\xFE'\xA9\xE2\xAD3\xF5\x9Bc\x92eV;\xBB\xDFB\xC7L\x06\x8A\xED;:N\x1A\xD0\x907S\xFB?v\x85\xC7N[\xA8\xA2\x07\x14\xFD\xA6\xA5\xB1\xE6A\xE4Bg\x11\xB7r\xA72%k\xF7\xBE\x8A8\xC7$\x1BN\xF4\x94\xA0}\xDB\xCE\x96E,\xC0\xE9\x98\x99[\x03\xFF\xFE\xB3\x85I\x03}\x16\xA0\xA5&\x1C@S\xA1e\xA7\xA6\x19\x85:\xF9\xD3\x91c\x99\xD1?\x9D\xF3\x8E\x1E\xF6\x84\x95\xA3\xB1Pk\x95\x92{\xD7y\x7F\xDEI\x11\xE0\t\xC0'\xEC#\xDC$\xD2n1\xCFR\x1E\xDA\x10]\xA0r\xA0\xBE\x15\xDA\xC4\x84\x85rq\xBC\xCC\xFC\xFC\xBEm\xDA\xE5\xCC+G#:\xA2\v\"B\xBD\xBE\x8A\xA6m5}\xD5\x00\xCD;\xCA]\xDF\xE9\xB7o\x1E\xED\x14\xFC/\x02S\x15L\xCDy,\xDF5{\x81Z\xE2]\x96\xDA\xE8\xAB\x16\xBE\xDD\x99\x81F2\x92\xA2\x7FY\xC1\x1FNWK\x19\xCA\x7F\xEEd\xFB\x97s!\xC2k\xD9\x13\x9D\xD9\x9A\xFB\xD6\x1F\x81&\f\x11\xE5\"JE\xB0T\xF3\xE9\x91i\"R\x01k\xA9\xA3\xA1\xD3\x8F\xFF\xD0D4Q\x04\x8E\xBF_E\xBD\xF7\xED\xCE\xB5\xF8?\xAA\x15\x8E\x1B\xD8V\x01\x1AS%\x07hT\xD1\x98*2\xABW\xF7\xD7\xF8\xB4\xAEz\xA2sT\xD3\x9C\x97\x1F\x9A\x94V\xA6k\xE1\x16\xFE\xC6\n\xF8?\xD5I\x1F\x84{\xCE\x97\xD2\x05\x8E\xFFm\x16\xBEm\xF8Q6\x9C\xFF\th\xA9\x92\x85\xF2D\xB2|\x82>\xDAKf\xE9\xE8\xE1\xDC\xD4\xBC\x07E=\x1E\xA49\x1A\xAA\xE9kc\x16Z\xE1/\x7F\xC8\xA7\xF9\xDF\x83\xB6aJ\xE6\x87\x99r)\x92\x93\x9D\x05\x96\xEF\xBD\x93\xE3\xBF\x87\xCEL\xAD]\x16^\xBA\xE9\x1A4\xCB\xE7\xFF\x9F\x03\x1A\xC9\x97\xCB\x94\xFF\xDC\xC9\xB3\xD4\x19\xE2\xBF\xA6\x9F,\xD7\xA6\x83#\xA3~\xDA\xF3)v\t\xF7\x00\xA7\xFC\x8F\x16x\xC7N\x87\xF8?y\xB8\x80\xBA\x89)\x17\xDF6\xC6\x11\xC1\xD4\xDCZ\xFC\x1F;[8f\xE0-\x03\xD0\xCEp\xFFshg\x8Al\xF1\xC58,<\x8C\x8Fj\xEA\xAD\x9D\xC5\xA3\x1A\xC7_\xAC\x19\xF9\xDB1'\xC0\xFFD'E\xB7\xC4\x18<\xF9\x84\xCEM\xE2\x95a\x96\xC7#z#\xE7m\xB7\x03\xC4\xBF\t\xAD|\xCCE\xB9d\x97\xA7(\xFE\xC7\xCF_?\x91y\xE5(\x1D}\xD4\x80\xFF\xB1B-\xFF\xCF@\xFBV\xE9&\x86\x7F4\r\xED\x07'\xA4L?\xC1\x98|\xFClA\xE4\xDBg\xFD\x1Cd\xFC\xFF\xAD\n\x8E\xCFe\xA0\x95k\xE4\xFFl\xF5\xC4M\x96c\xD0o\x81\xDE}.Dx\xCD[\xCA\x7Fr\xC4O\xBB}\xC2\xC0\xB7\f\xB6\xFA\xD2\x98\x1E\xA9\x14\xD1\xCC\x13b\xA7\xC2\x89>\x8E\xCFy\xD0\xB6O\x00\x94N\xD1j\xE9\xF0Z\xFCW\x1B=\x11\xE8\xA1e\xBF]d\x99C\xB4\x14\xB7iw\x1F\xCEr\xFE\x1F\xD5\xB2\xAF\xCD}\xF3(\xE7\x80f@\xD9]\x83\x7F\xD0O\x8F\xF3\x9F\xFB\xB7\x9F\x9E\x01\xCF\xFBM\xB8g{\x93\x13\xA8\x85\x8A\x85\xC6O\xBFdar4W>\xB1\x8F6R_-u\x96\x8F\x12;\x90?\xC4^\xDAW\xDA\xB7\xFF\xF7\xF8\f\x93?Mu\xD00%q;a\xE0\xB4\x8B\xE2aO\xE4\xDBg\xC2j7\xFD\xE8\xA8\xD8\x9F8|\x16Z!\xAC\xFF\xB4\x12\x1C\xD5\xBCQCX\x8FK\xE1\x04pZj\xB2\xB36(\xA1~\"\xCC\xFF\xA2\xC5\xE8\xA4\xA5I\x97\x07\xA5\x89_R\n-\xDA\x97:\xCBP\xD8\x99\x07\xAF\xC7u\xE4\xF8\xDCZ\xF8\x13M?n0L\xB4\x14\xE5\xAD\x96\x82\x96\x9D`\xF6m\xA2\xF1\xCF\xD0\x9A\x9AS\x89\xF6\x9D\xE3s\xFC\xBB6\x97\xD4\xE4\n\xF8\x0F\x8B\xF3\xFF\x84\xC5E\xA5\xC5\xF1o\xE5\xF8\xCB\xA47\xBC\xFC14\xED\xDB\x16NXV\xF9\xC4\x04\x13Y\xD6\xD4\\\xF9\xF8\x07)\xC0\x92Io\xAAK\xF3\x04\xD1\xBE\xFD\x97RBZ\xD7\xB5\xEC\xD1N\xD5\x87\xA5l\x89\x85\x8F\x17\xB5i\xFE\xB2\x14\xD6\b\x01&\xBE\xF6\x10\xB4\xB2\x8Fi\xBB\x05R\xEF\x9D\x9E\x1B\xC8\x1B\"<\xE1\xF8\x0Fk\xE4\xFF\xC9\xB2\xBAt\xFCm\xB4\xFD%\xB0\x84\b\x94\xC8.\xBA\xD2\xAFI\xF3\xFE\xAA\x86\xFF\x05\xC0*\x17q\xFC\x83+\x88T'\x0F\xAF%\x7FZSI\xC3\x00+Y\x9B2\xB9\xF1YA\xA2\xCDd?1\xFC#f\x9B\xA2\xB6\xEE0\x84Y[\xB1\xC3+\xD4\x00\xB6\xF8 E\x12]\t\xDB7\tv\x1E5\xB9I\\\xE7\xFA\x0F\xBF*b\xD2{\xC5LD\xAF\x99\x16\xDAz\xCC\xCE)\xE6\x92}\xD44\x13\xAF\x98\x89!DL\xA1\x7Fr\x9B\xF92\xFD\xA7\x83OC\"&\x94\xD4&\xA9(&\x81N\v|\x86\xD2\x9EJs\x9D\xB0\xC5\x02\"\xC6>\v\x89\xDC\x17\xA1\xBC\xD9*\xFB\xD9n\xA0\xB5\xC7lS2\xDF+\n\xFD\xDF\xC8\xD9a-\xB7s\xA2V\xFF\x8C\x10(\xF7\n\xFD\xC7@\x83P\xE7\xD2\xAD=\xB2\x87\n6\x87(I\x15\xCE\x88\xD9Y\x84\xF1\x84\x81\x88\xD91\xA3\xAC\x81\xFF@\xC26,\f\x18\f\x7FW\xE2\xFF\x86\xC2~J\xF1%\xB96E\x1DH$\xDA\xB8\xD8Q\x0E#V\xD3\xE0g\xFC[\xC7\"\x06\x8B\xEF\xE0\xF8\xFF\xABv\x85\x87i\f\x18\xEC\x83\xE1W\xC5\x14z\xAF\x98\x06E1-$\xDA\x95\xCE\x13T\x84\x9A;\x153\x913\xCD!\xC4\x14\x81?\xB7\x99/\xD5\xFFsf\"#~UR\xED\t5\xAC\x96s\xC3\xFBg\x13\xDB\xF8\xC9\xECF\xA4X\x849A/\x1C0\x82\xB5\xA1\x81v\xA5M\xB1\xC7\x87\x85\xFE\xDF5\xF3X\xF8-\xDF4Q\xCB\x7Fv/\xBE{\x93\xF4w\x82\x92\x1Eh\x97=TL#\xB4R\xD91\x93CL\xA1\xF8\x1F$\x88)Fn\xAD\xD4Ic\x07rm\x0E\xC6\x1Cz_V\xB8<K'\x02\xCCX=\x96c\xD2U]hS\xBC\xB1\xDC\x8D]\xEF\xF3\xCCTW\x96\x98\xB27\x05cI\xB5-\xD7\xE4\xCF\x7F7?\xB8\x00f\t\x1F\xE3Q0\xFC*u\x81\xDE\xABa\x01JS\x87\x8B\xAD\xC9\x85\xEEs\xDBi\x9F\x93\v\x1D3Ov\xB8\x15\xA8\v\xC2\xA3i\xB9\xCD\\\xD9Eg\xB5\xFB\x9E\x14\xBF*\xD9-gT\x7FH5\x1Clb\xB7k\xE3\x85\x06\x94,\xBD\x91zm\xA3\x83m3\xF4\xC21'\xE8\xF0\xD8\xE8B\x9B\xF2\xE8\x98!:o\x1Cx2\xFC\x96\x93\xFBj\xF5^v/\xF1\xA2\x87\xD1\xEBp\xFEg\xC7Fe\x0F\x953]\b\xF3\xDF\x83\xBA\x90\x1CF\xD7E\x8AU\xD7\xFB\xBF\xBAn\xE6Z\xDF\xD6\xB7\xF5m}\xFB\xA5\xDE\x1C,\xB3l\x1B\xCA\xAA\x89\xFD\xC3\xA6x=\x14\x18\xB0\xD2$B\xA6\xE2\x0F.v\xA0\xA4\fb\x85\xCC\xF5\xCC\x12\xAE\x04\xC1\x06jp\xB5\x88\v\xA0J`\xBDc\xC1\xE2\xF7\xD1\x95\xD0\x12Dm&\x7F\xD3\xF7\xE4W\xE5-\x14\x8B\xE7\xDE\xB7VZ/\xD0\xFD\xDB\x85\x9D\xF6#K\xC1A(A\x81!/\\ZD`\x89\xFDre@\x1C\xFA\x8F\xAF\x86\xB0\\\xBCi(\xFA\xA6'F\xB9E\xFD\xF3.6*\xDC\x8AUL\x04\xB9\xD0/\t\x8B\xF4\xA1\xAB\xD2\xE8\xED\xFFdp\x9B\xFC\xE7]al\x14I\x84\xA4}\xD2\xDC\xD7j2\x0F\x87~n\xEA\x8F\xBF\xDA\x02l\xCEo6S\xFB\xA5\xBB\x8B\xC7\xF17{n\xDC\xC2\xD3\xB9(\v\xDCU{\xD3\x99#PTf\xD1\xB5Y\xE6\rk!\xA5C\xF1\xB6\xCF\xE8\x8A\x1F\xAF\xA1h}\xCC2)\x9D\xC7J\xA2Z.s?n7ER\x1D\xBD\x886XK\xAA\x06\xB4q\x9Bm|\x1C\xCA\xA5\x0EW\xB8\xEB\x93\xD0\xCA\x05\x7F\x1C\xA3\x18\xE0\xDF\xF1\xCE\xA9.\xD7H(\v|!\xA0m\xAD\xE9k\x1A\xB5Y\xEE\xF96\xE4\xC0,\xE2\xA6\x19\xFD7]t\x16q3\v[\xB8\xFD\x99NnG\x1D\xA53\x0E\x9E\xE4\xFFT\x87L\xF1\xCDs\xB6\xD3\xE7\xCA3\xA7\xDF\xFA\x90\xF9]\xF1x\xCA\x9Ak\x06\xFC\xF0a30\xA9\xA1#\xE7u\x9C'\\\xF3OP\xAD\xCF\\t\xF1\x9B\x17\xBF\xD353$K\x1E'ytF\xD7\xFC\xE5n^\xC1\x93M\xCD\x92\xA9\xC2\xB5\xD4\x10\xE2\xA7\xE8$\x8E\xFC\x1D\x80\x91\x19o\xEC}\x0FJ\xB9s\xC2\x1B\x99\xF1;\xA0\x1Et\xA5\x86,\x8B\xF0r\xD3q\xB7\x8B\xF6\xD48\xF7\xC3_t\xD15\xEFu\xD6fm\xA5\x1D\x88\xB2\xF8\x11\xA5l\x1A\xC2]\x9F\xBFG\xDE7\xEE@\xDE%\xDD\x02\xD9d$q\xEBq\xAFk&\xD9\xF9\xA2\xE7\xDFh\xE5\x8D\xD9\xBA\x97\xBF\xA0\x17\\t\x17\xB1\xFDE\xEF\x84\x85_/\xA2\xF3E\xCF\xEC\xFF\xBE9\xD1\t%\xC7K3\x8F\xEC\xE0I>K[\xDB\xF4\xA5\xFC\xCF\xA5\xB91\rQY\xE7N)p\xCCy\xAE\xA4\xDF\xA8\xC8\x0E\x13Oj\xBCz\x92%\xA0\x18\xE3k\x13q\x9B\xBE\x88\xB1\t3\xF5\x95\xA5\xFC?x\xDF\x16\x00\x8DU\xDE\xF3\xAE\xD7=\xF3K7R\xFE[@\xC3\xADT\x06m\xCA/\xA4\nP\xAEm\xDEW\xE8S\x0E\xFB\x04\xB8\x95\xCE\xCD\xEF\x13\xC1\v\x8C\xFF<\xF8\"Ag^U\xFE9\f9\x94\xFFK\xF0o\xE3s\xF6\xF8\f\xE7\xFF\xAF\xB1\x07\xC9\x87\x88\xD4\x1Dz\v \x87\x19I<\xB3T\xFA\xB5\x87\xBD\xCE\x892\xB7\xF9\xAFn>[\x99\xFF1\x16\x90\xB2e_\xF9\x15\x87\xB6|\xF3L\xB9\xE3Lgij\x94'\xE6\x1D\xB0p\x96\xBB\xA66\f\x1D\xF7\xF9/\xED\x83\xE6\x18\xCF\x96\xF0^\x90.C\xF3>\x965=\x01|\x9Bu\xBBd\x002\xBE\xE7\xC59\xEF\xE4\x1B\x94\xFF}\x06\x8B\x01o\xC8\xEE\xB10u\xF1\xD4Q\xCD\x16\xC6\x1C\xAD\xCC\xFD\xB1Ot\xBCw\xDAe\xFCg9\x9C'3\x85\x8F\xCF\x96\x10?uB\x96Z\xDE{\xB6\x9A\xCBx\xD0\x8E\x94\xCB\xDE\x88o\x96o\x9C\xCC8@\xE3\x7F\x90\xFC\xBF\x1D\xC0;\xAC\xE5\xD3.\x8EY\xE3\xDC\x04\xF4\xA7\x0E\xA6.T\xA7j\xD18f1\x0FLe;\xB4rI\x1A\xFC\xF9{\xE4Fcn\xADzYdz?K\x1F\xF3X\xE2\xF4\x97\xB3''\x1E\x9C\x9A{e\xC54\xC8!\xA0=n\xFD[\xB2\xDDW\xA4\x8D\x9F\xD2\xCA\xDC0X._*\xF5\x8F\x9E\x9E\xD8\xC0\x13SO[x<\xC3\xB0\x8D\xBF\xF7m9\x85\xF7M|\x8B\x1F\xF0l-ih_\x94?\x15x\xB2\x05\xFE\x16\xB8\xCD\xF6/]\xA0I\\R\xEE,\x14\x19\xFF\xE3<\xC1{\xBCd8\x98\x98*N\xCD\xED/\x19\xB2q&\xCC\xA7\xCE\x0F\xD1\xDE6V\xA1]c\xAE\xAA\xDE\xE1\xCCv(\xEA_\xB9@\xDD\xAB\x00\x063\xF9\x8F2\x05hW\xFF\xE2\xA1B_\xA7\xE4\x7F\xE3w\xAA\x14\xFFLX\xFE\xFF\x16ky\xC2\xC0\t&\xFFK\x0EnqP\xEA\xD1\x97\xA0AAn\xF4\x10\x9F\x80v\xE9\xB8+0'r!\x8C\"\xCFL\x97\"'\t\xCB\xF3S.\x9F*\xF7\xA6\xFF\xEC\xB7_:\xCA\xAA0L\xAD!\x7F\"\x83\xBC\xD4\xE6\x92m\xBA\x88\xB2\x83\x93s\xDEI\x97\xEE\xBC<\x97>}\xF1\xBD\xD2\xA1\x07\xD0\x98\xE5\xEE\xF4\x99\f\x93\xF6\r\x1B\xA6\xDE_X\xC2\xFF|;\v@hx\x0F~}g\xAD\x10\x91\x1F\xBB\xBF\xE0\xC5L\xCA\xE2\xF7\x93s\xDE\xD4\xDB\x067\xAD\xD0\xDE\xAA_\xEF3p\xFA\xE2\xA9\x92&3xkB\xB4N\x8C\xCD\x9E6\x80\x864\xE7\x7F\xA9\x9C\xFB\xBD\xC3\xD3\xA8\xAFNQ\x96\xBA\x8C\xFF\x9EA\xF9_\x9E\xD0\xBC\x919\x99\xAEJ+\xB3\x15\xBA\xC1\x82\xC8\xF9@\xF1\x7FX\xF2\xFFe\x96v\xE38Kt\xFF\x97\xEFxK\xE0*Y,\x99\xB9:\x01\xAD\xF0\xE7\x8E\xE0?\x7F\x8F\xFCL\x1E\xC0\"\xF9\xFF.\xDD\x9F-\x9D>\x9F=y\xB2\x93/\xA8\xADe\xBE\x89\x94yV\xF0\xA5\xFC\xB7\xF0\xD7E\x9C\xEA\xD4\x7F\xC6v\x8Ei^y\"Q:\xAB@;\x03`O\x05\xF7\x9Ce\xFCo\xFA\xE6\x84\xAFc\xC8\xF0\x81\xD3\x0F\xB2\xE5-5\x11\xD4Z\xD5\xBCG\xD9+\xB6\x87\xE1\x17\xE5\xA1\xC0\x92\xFD>\xFF\xCB}T\xB3\xE8\x1Bf\x9Di\xDC\xFC\xB1K\xF9\x7F|\xCE\v\xF8\xCF\xFC\x8AK\xF7\x9B\x94\x9FZ\xDA\xE7\xFF\x9Ff\xEE\x03\xC8\xA4%\x16h\x063\xD6d\xA6\x15\xDA\xB5\xA9\xB9\xF1tYj\x83\xCA\xB5\xC7\xD9\n5O,\x83\xF8\xAB\\\xD6Q\xF4,\x9C\x9C\x19\xE4\xFC/\x18H\xE4\xD4%\xFC\x17\xD9\x8A\xE2\xA7x\xFD_\x8E?_\x8B\xE4\xFC\xE7oA\\\xA5\xB0\xA0\xA1\xC6\x7F]\xDE\x99\xFE\xB3}\xC9RF\xF7\xC5\xD4*\xF2\xE7WW\xFC@z\x8AT\x0E\x9C\x9C\xFB\x1F{\x98@\x9E\xFA\xE1\xF8\xCB\xF3\xE3\x7FfY\\\xFE\x10\x80\xF0\x14\xFA\xB0\x8E\x07\xFC\x97\x11\xB2\xC2\x01\xD8\nbz\xB5!\x12\xF2r\xE1\xC3M)\xB4D25G&R\xFB\xC0\x02\xF3Xg,\x02*\xFF\x8BZy\xCA\xE7?S/\xFF\xCA\xB1(\xFF\xE3\x1E\xB4N&\xFFs\xF4\x93\xAF\xAF\x9E\x14a\xAAx\xE1\xACW\xFAo\x1E4}\xB2\xD3{\xF8\xBFI\x01\xA8\xFC?l\xD5\xE6\xFA\xB1\xA2\xEF\x1A\x84\xCF12LU\xF0\x8A\xB5\x9B\xF3\x81\x00]\xEF/,A\x83\x82L?d\x8B~S\x86\xC0\x8A\xAFE\n\xFE\xF3Es\xE1\xEA\xF0w\xEC\xB8U\xEE\xCB\x1E\x85uz.XN]e\xFC\xB5V\xFC@\b\xF0\xD7\x16^\xEEL\x1Ea;\x7F\xA5y\xE5\xC9\xF2\xAF\xF7\x98\\sk\xB5\xD0\x9A\x9A\xE3V\xF4\xCE6\xD3\xD71\xC4\x8A\x00\x1B\xCE\x98e\xFB\x88\xFCi\x88\x1B\xCFy\x99\x1F\xAEx\xDF\x14\xE2\xBF\x11\xF5\xBA\x98_u\x8B\xC5,\x8A\xCC\xC8\x9Fx\xC2hO\x95\r\xBF\xF1&\xFA\xEA7\xB7\x99I\x83\x05z+\x94\xFFf\xCA\xFBB\xEA>D\x8C\xAD\x15~G<\xA5dt\x85@\xC9v\xBD_8\x92\xDA*\xD5\xBC\xAF\xB0\x15\x8A\xC4#\x8E\\\x1A\x90\xE1\x0FI\v\x1D\xE7\x84\x1BL\xAB\x85MO\x18K\xB4\xC1.^\xD3*bB)l\x925\xA9\xF9\xB5\xED\xEC/\xAF\x88\xD4\xC0\xD9\xC7\"\xD07E\xCC\xEE\x8B\xE3\xDD\xE7\xCC6\xE5\x16\x00\x9F]\xA3\xF4\x1C\xEB\xC9r\xFD\xA7\xD5B\xA7\x85\xDF|\xFF,\xDF\xE9\x9A\x19\xBFy~bs\xBB\xC2\x19<`` 1!l\xFBoH\x1B\xBB\"\xDC\xA7\x07\fW\x1A\xBDs\xBE\xFE\xC9\x8D\xE7\xFCo\xB2(V\"@\x84\xABH\"eon'\xFC\x04*\x9D\x98\x91\x7F\xF3\x1B\xA4=U\x16\x8E1\xCA\x10\xF7E1\xDEP\xBA\x99Y\x1EJ\x82%\x052\xC7'*\x88\x916K,\x10$S\x85\x81\x94\rEO&\xBCC\xB9\xB3\x12\xFF\x12[\xA1x \xEE\x1B\xE4e\xF8C\xD2\x82\xB9\x93p-q\xC0\xA0\xFBK\xD4u\xDA\x01Eg\x8FS6\x1D\xA1L\xF2ko\xF3'2\x90yJc\xB4\xA9\xF6\x9DJ\"\x95O\xECT\xBAf\x86j\"LW\x90?\xCA\x8A\n\xEA\x80A\x0FnI\xD9bG\x19\xFF\xCDc\xC3fr\x81\x93|\xCC\xC1X\xEE\x9B\xDC\xB2}sR\xCA\x1F\xE5\x06\xB1\"0v\xA30z\x13\xB9*\xA1<\xCF\x8D\xE7\xFC\xEF-\xC3r. \xF5\xFF\xAD\x89\xAD\x9D\x93W\xF8\t\x9F5\x84\x91\xBFs\xF2\xDA\x96/y\xE2\xB9\x94o\x81\xBCG\xA9\xA2.\xD0#\xEA\x15D\x7F\x02\xE0\xF6}g6\x1E\xD8\x0E\xF5\xDA\xE6a\xB1@\xD0;\xB1u,\xB1\x15\x8A\xD75S\xD8\xB6O\x86\xB9E\x1Fb+\x14\xDF\xB8\xEC/\r\x00c\xAC\xE5\xAE\n\xB6\xA5Y\fc\x91\xDE\xBD\xE3\xED+K\xF8\xBF\x8D\xD7\xCBS\x17\xA0\xBC\xB9\x85y\xEF\xD0k\xD9\xDF\x0E\xFE\x97\xB5\xD9+j\x1B\xD1\xA6>\x9B\\\xD8l?\xBA5\xB9\xD0\xC6\xDC\x1Bn\x1E^C\xFE,\xAC\x88\xFF\x98\x83n\x037'\xAE\xF0\x9D\xAE\x19/\xD1\xF5\xEA\xBA\x01l}[\xDF\xD6\xB7\xF5\xED\x97s\v\x9B\xE8Uf\xDF\xE6\t\xD8#\xCC\xF3?\xE4?\xCF=N\x03\x9By\x9B4\xE9\xD3\xED\t\x15\x0EtGm\xF9D\xF74\xFEW:\x1C\t\xAD9\xC8D\xFAz$X\x9EXq\xCD\x02\xC0\xE8*\xC5n\xF4\x95J\x1B\xEBa\xF7~\xC5\xF1o\xAD\xC3b\x7F\x95p\xF2y\x95\x84\xEE\xAB\xAF\xD0\x07\x1D\xDC\xDA\x8F<{\xF6\x9A\x13\xF6\xFA\xB7Ut\xD5IP\x1D\xDCH(\x06\"mG\"\x06\xD5gx\xFA\xA5H\x97\x87xaq\xE6zn\f\x04\xF0\x1C\x0F\xCF`\xA3\xBCwt\xAEz\xF4\xED\x1B\xA7\xE6Z,Dx5L\x9E\x9B\xFD\x1Do\xE1a?d\x9Eg8\xB9\x1D\x90\xE5\x15\x94,\xAF2fQ\xAD)\xCBS\xCA\xF4\xBB\xF0\xFD\n\xFC\\\xB5\xBD\x15\x96\x99\x93\xCF\")i\xC6\xF9\xAFm;\x16z\x80\xFEY]dU%\xBA\x7F\t\xC8-\xFD\xD3^\xFF\xECc\x96\xAD\x1B\x15\x80\x8C\xDA@\xEF\xF2I+\xF1co\xB9\xD3~\x9D0\xF3\x12\xBD\x7FV\x00\x95rh\xF7\xAC\xE9j\x1B\xD1m\v=D\x87\xB2\xBDw:\xD5?\xEB\xA5\f\xD8d\xD4\xA6G\xB2\xF3\xB3\xF4I\xF7L/\xC5\xDFx\xA0\xD5\xCAWA\xD2\xEC\x9F\xD1\x97\bN\xD8\xF4\xDA\xE5\xA2\xAF&\xC5\x9FW{\xBD\x11Wd\xB9\x1F\xB9\xD4\xBA\xE8\xC2\x93V\x91\x11\xD7\x82Z \xF1\x02\xE2\xC2\xFE\xC9g\xFA\x1E\xBB\xBC|T+\x1D\xD5\xF4r\xF9\x8F\f\x84\x92\x99R\x8AD\x97\xE8\xC9\xF5\x95\x10\xFE\x84\xE3\xDF/3f\xF7\x00\x96\x11D\x19\xFBy\xB0-+\x98V\xFB\xF8\xA7\x816\xC3\xD8\xEBR@$\xFE\xD9>\xFF\xDB\"\xDF\xB5\xECI+\x9FN\xD9^\x07[C\xD9\xEB\xC2^\xA1\xC4\xB3'\xB2M\xF2\x97\xCE\x825XNo\xAF\xCF\x14@\xED\xA5\xF4H\xF5\x92<\xC7\x7F\xA7m ~\xC6\xB6Si\xA2s\xFC{g\vPZ{\xD8\xC2\xD3\xBF\xB3\x97V\x8D\xEC\xC8\xB7\xF6\xCF\xAA\x14|:\xE3\xF0\x06S\xC1\tfB\xBD\xD3\xE7\x7F\xECQ\x95\x18=@\x8AP\xF9\xD3\xA3\xD0\x0F\xB3\xC5\x11\xF2'}`\x01\xF1\xF1\xEE\x9C\xEE/\xC6}\x14\x92?\xFF\xE1\xD0\xC5\xEA\xD8\xDB\xD9C\x0F\xB6\xF8\xC2\x859\xEB\x8E\xBCUU\xFC\x94)\xF5UV\xC8\xC0B\xDC\x13\xAE\xD2q\x828=}\x86\xA5\xBE\x01p\x0E\xB8b\x04\xA5\x1F\xE6$\\\x17-\xA0Y,\xEA\xCD\xBB@s\x81G\xD2~\b\xEB\x1C\xF0a\xB3w^\x98\x80Z?\xF0\x11n.\\\x19\x9B\xBC\xFCL\xFA\xC3;q\x95}}\xB3\xC0\xD5\xE5\xF87\x17\xC4\xC18\x9BW\xC6\xD9]\x9Au\xC4\v\x1F\xDC,\x80\x9A)\x02\xF1\xD4\xD5\xE6\xD2G\xF3\xDE\x0F]\xD0\xE3\xA4p\xB5\xDF\xBB\x18\xD7\x17]\xCC\xCFo\xBFxs\x01\xF1\xD6\x1E\x96\"\xEC\xC7\xFDK'f\x97\xC7\xBC\xCB\xCF\xE8,\xDE\xB9\x8Afkv,p\xAB\xBE\\_\xFD\xD0\xFF$\xE3\xDFX\x9C5)\xFE\xB6\x990\xD0\x93\xF0\xB6\x18h6\xF0U\xF6\xE3\x9D9\x15\xAAg\x8C\x05\xD9\xF2\xA7BkF'\xCFo\x8F~p\xDF\xE7\xE7N-\xBA\xE8\xAE0C\n+_k\xD9\xE4q\"\xE5.!\x96\xA9\xB0ob)\xFFS!\xFE\xF7\x84\xF8\xBFK\xC2\x95\xA6\xD3\xEA\x81\x10\xFF)\xA2wT\xD0u\xE9Z\x8F\xCC\xA8\xCFn\xD1\x1A\xE2\x7F\xA1\x87L\xF6\x90\x8Ce\xF3\x85\xE1\xB2\x8D\x15\xF9?.<\xBB\x98\xE9C\xE4\xF8\xA5\xF2\xA7\xD0?[\b\xC4 \xC9\xDA\xE4H\x1B\xC1=T\xFE\xE4@\x8EP\xF93\xAD\xA7\x80\x81Xg\xDA,@I\xFCt\x96W'\x1C_*\x7F\xF2\xAAu\xF0]\xCA\xFF\x88\x0E\xB2\x7F0\x15Je\xD3\xD0\x1A\xE2\xFFC\x84\x04\xF8\x7F\xB5K\xDDb\xE0CW\xC8\x99\xF4\x8B\x8C\xFF\xA3\xE3K\xF8\xCF\xCD>\x89C\x17\xAB_\x1B\xCD\xE6\xD2\x83\x0E\f\x8B\x89\v\xC9\xFF;.\xD4\xF2\x9F\x1EO\xAE\x81\xFF\x8A\xF2g\x80\xE2\x7Fo\b\xFF\xAFsse\x9B\xB2\xBB\xBF\x12\x96?5\xF8\xF7\xCFN\xF6\x90gl{?E\x98\x94{++\xCA\xFF\xAA4F\x1D\x0E\xA4\x10\xE1\xF2G\xE0\x9Fq\x98\xFC9\xEF\xB5\x11;m\xA1\x7F6\x87h\x93ERi\xDBH\x19\xD8I\xCA\xBD\xA6\x07e7\x97?\xCB\xF1\xEF\x98U{g\x87(\xFEq\x0F$\xDF\x17\x8Ac\xEA8\xA7\xCF\xF9]\xAA\xDFN\xECd\x8F\x81\xC7\x0F&?\xB2\xD0\x97\xD2~\xC6J\x94\xA6\x99\x84\x1F\x99P\xA1\x1E1\xC6\x8E\xF8\xE3/_!\xCA\xB2_\xB7\x1D\xD3J'\xB4\x81\xE3s\xD9\xA2\xC4\x9F\x01\xBB\x938\x19;\xD0\xB4\xD2\xF9\x01\xC6\xFF[B\xF8[\x92`*\xDFIY\x01\xFE;$\x98L\x02\xE7Cl\x1C\x17\xF8\xA7.Z\x14\x90\r\x12\x7F/4\xFE\x16z\xCC\xD2\x0E\x1B)\xDB6i\x7F\xBE\x95\xB6\x82\xE2\x17!\xFCe\x15J\x85-u\xF0t\r\x8C\xFFK\xF0\xB7\xF3\xF96bg8\xFF\xAF\xBB\xC2\xF0\xCF\xEE4\xF0\xE5\xE9\xCCN\x93jD\xAB\xE1o\x1C\\\xB0\xC8=L\xFE\xA7AFS\xA1\xA4\x90F}5\xC4\xFF\xEB\xC9A\xBD\x87\xB6?\xDEF\xF1?\xBB\xC5\xA2\xFA\xCFc\f\xE1\xF4Q\x8A\xFF\xC5\x8BG\xFC\xF1\x97\xE3\xFF6\xFBu\xFA\xD8\\\xF5\xE4\xDC\xC8K\x87\x07\x8BR\xFE0\xCF\x07\xFB\x90\xF7x\xAF_\n\xE7\xFB#\xE7\xFF\x9E\xE1?|\xAB0\xE0\x10\xD4\xD1\xE7\xDD\x07\xA0\x8E\xE2\x7F?p?\x1D\xB3\x05\xFE\x0FH\xDD\xC0\xB6\x80\xBA\x12\xDF\xBF\x9F\x9EL\x9F\xF1!\v\x9F\xB1\xED\x07,\xDC_w=/\x82\x80:\xFDA\xFF\xD9\xEA\n\xF7o.}yWu\xF8\xB7\xED\xDB\xE8\xE5\x13\x0FYx`9\xFEu%Q\xFC=\xFA8\xFB\xCB\xD3\xF2\xE8\xA8+\xFC\xFB\xCD\xA2\xE7\x0F\xBB@]\xEA\xCB\xF9\xD2o\xFC\xC0\xFE\xF7\xF4vt\x14{\xF8\x07\xD9\x87\xDF8\xF3e\v\xEF\xEC\x1A\xFC\xF2f\x1D\xD1\xEC\x87,\x7F\xC5C\xBBJK\xEEp\xCB\x93\xF6p\xDD\x11\xD4\xA5q\xDDU\xC4F\xBF\xF4~\x10\xC7q\vB\x95\x0E\xE2\xE5h]\xAB\xE5\xA0\xC7l5\x1C\xA4\xC7H\xD2\x81'\xF5\xE2/\xF6{\x88\x8F\x9E\x9E\x1A\x85&x\xC8\xAB\xA0f\xD9\xAF\x9F\xEE\x1B*}n\xF7D\xEF\xACg\xC9zN,\x1D\xD9\xC8\x1BH\xFD\x7F\xEC\xFD}t\x1C\xD5\x99'\x8E\x7FT*u\x97Z/\xDD\xF6:s\xBC\xBB\xFCp\xA9]\xB2\xDA\xC2\xB1\b\xEB\xCC:Y\x8EUj\x97M\xAB\xED\xB1\x1C\x8D\x80,\x9B\xD8B1/vXLXf\x86a5\xADr#\x8CpX\xDB\xF4j\x023'\x07\x9AF\x18\xBBa\xEC\x19\x96\f3l\x8Ei\x84\xD6\x18\x0F\xC1\fC\xB2\xEC\xFEr\x92\xA6-l#\x8Ce{M\x10F\x94\xBE\xE7>\xF7\xDE\xAAjIvf\xBF\xDF?\xA3:>r\xBFT\xDF\xBA\xF7SO=\xF7\xB9\x9F\xE7\xB9\xCF\xB3Vf\xAAW\xE39c#\xA5{\xCA\x96\xB8\b\xD4\xAB\xA8\xB5DR\xA1Z\x8D'\xE8(\xD8@\xBD\xC0\x7FDr\\\xA3&P'\xD4&\xE5\xF4`\xF8\x1F+\xA0\xF8\xD0\xC5\x11\x13\xAF\xD5\xCE/\xF0\x06k#G\xDD\xE1\xD4\xBE\xF8\xDA\xFA\xA17\x97Y\xAF\xBDe\xB1\x9F\xD7\xBE\xF0\x8F&Ff\x92\xC6u\vFEg\by~\xE9\xDA\x95\x94\xD9I\xC8\xFFp\x16\xA8M\x8D\xFCl\xC1\xE8\xB2\xC4Q\x13\xC7\xCF\xA4Q91\xBC,~\xB4>~\xD4\xC6\x9A\xF5\x997\x96eP\x1F\xEF8\xC3\xD0:\xB6~:\xFE\xA7\xCEXo\x9C\xC9\xA0\xCEa\x8A\xB6\xFE\xF0[\xCB\xBD\xA8\xE8S'&\xE6{\xF6\xBF\x190\x9A\xDBl\xC4\x87\xD8\xDFo\xE7j\xDBlf\xFF,\xA4\xD3\xF3m\x1A%}\xD3P\xFB\x96xvx\x9AG\xFAy\xF7\xBA-C\x1Dw\x1E\xB6\xFA\rS\xA6\xF5\xD4\xD8tiUOZ\xEB\xA4\xFCW'_\xFD\xF8W\xEC\xCBz]\x9A|*\xD7*e\xF3\xAF\xED\xE9\x9F\x84\xEE\x93\xFF*\xCDg\x8Dgx]!} \x1E\xB7\xD9\x83o\x8A\x04>\xB1\x84\x17\xF7\xFEn\x9B\x9Ak3\x12\x1B,+\xC6\xF4Ov\xA3\x8DY\xD2\xDAWi\"\xB2]\xD8\xFF\x94\xF3D\xED\x82\x1Ai\x93\x814\xF1,)\xCFgU\xC3H$\xB8\xFE\x81\x197\xE2\t5\x9E\xB0\xB1F\xCD\x99l\xFE\x8Ds\xFD\x93\xB8\xCD\x98v\x05\xC3\xB0,\xE3Z\xA6\xCA\x99\xFE\x1F\x88\xAF\xF6\xE4\xDF\xD0\xCD\x8D^\x87\x9B\xFFe\xEC\xC8N\x13\x8F\xDEy$n\xE2\xC1\x9E\xF9k\x19T8A'\fd/\xA0jE\xB0e\x054\xA1<>\xA7\xFE\xF2\xD9a\xE1\xD3\xC9\xC9\x03]\v\x86v9\x94\xDB\x8A\xDD\x99\n6M\xFF0\xA4\xF6'\xA5\xFC\x87:\xB3\xDA^a\xFFx\xF8\xEF\x12\xF3\xAC\xC4\x7F\xADO\xFF'\xDCZQ\f\xC0\x15\xDE\xBDP/\xF0\xBA6\x8B\x13\xF1\xD5\x84\x7F\x9B\b\x14\xB1<\xFC\xD5\xDFk\xAB\x8A\xB6\xA9+M\xAB\x9F\xE1_\x15]mz7\xD4\xA7\xFFWH\xFC\xE3\x9E3\xAF*\xE3\xC7\xDF*\x10\xFE\x0F9\x86\xA1\t\xFC\xC3\x8EE\xF8\xAF6a5FM\x8B\xE1\xBF\x83\xF0\xEF\xAAJN\xC7\xBF\xF1\x82e\xF0\xF9\xCB\x84:\xD0\x96\xF6\xF6/\x18-^\x00<\xAA&\x8A'\x94't\xFC\xF55\xCAz\x1D\x8F.\xE9YH\xF6\x0F\x15=\xC6\xBFn\xA9\x876<Q\x1Av\x8Ds\xBE\xB9\xA3\x8F\xFE\x9Eh\xBA\xB0\xF8\x9AR_\xD3\x855\x94a\x8F5\x19`\v\xC9\xBF\x1E^h\xC7e\xA5\x06\x1Ci=\x11AE\x01(\xDE\xCAUn\xE0*\xD4^\x10\x15~)\xBF\xD0k\xC0\xFB:\xDC\x84\xFC\xAF\xC9\xBE\xBDi\x03\xB5\xE2\xBA\xEC\x84\xBA'\xF9\xAF\xEEj(\xFC\xB2\x1B\xC7\xCFDDE\xDE\xBA\xF4qw\xFE\xAD\x8D\xBC^\xA7\xBCVw\xA4\xB0~g7S_\xAB\xDE\xD2qt&\xFE\xB5\xC3w\x88\xCE\xD0E\x03\x0E\xFF-j#\xAF\xC9@\x8E\xF7\xD9\xD5\x9D\xC2\xA3\xDA\x1D\x9F8G\v\xA0\xCF\xCD\xF7\xDFJ\x1D?\x93zK\xC7\xEB\x9F\x9Cy\xEDQ\x07\x81\xD4\x8EZ\x86\xFF\x893\xF7N\xBB\xC2\x1Dg\x947>qP\xA7\xB0\xB1\xD7>\xF1v\xC0K\x88tG\xD1\x9Cc\xC0\xE6\x8E\xB9c\xEE\x98;~W\x0F\x97\x00\x87^V\xC2\xD5\xCF\xA3\xF6c6\x82]\xC1\x15\xC2\xFF\xF1\xDB\x82\xE4\xDD\x06\xF5\xCB\x9C<\xBDe\x7F\xC7*f\xBF\x84.s\xFE\xD0\xBCf\xFBO0\xBD\xC1V\b\x86_AD1\xA1\xFDvw\xC3\x8CM\xDF0~\xDB\xA0\xA4G\xE5\xB7;`$y\xA2\xAC\xFDw\xA3\xBA\xAF\x84\x9F\xAF\xFA\x80[y\xCA\x9F{\xA4\xCA\x89\x9B\xF2\x13u:\xE9\xFA\x9D-\x80z\x7F\xDB\xB4\xCF\xE9\xED\xA6h\nJJ\xB0^\xEA|\xA8Y\x8F\xD8)\xEF\xD8\xEA\xFF\xE1@=\xEB:\x028\xB7\xC3i\xF96\x95\xEF'\x8D|\xD7Wms3\xC5\xD5\x19\xCC\"5\xC5J\x81\x9A%\xCAB\x10\vm\xEA\xA5\xCD\x1F\xCD\xE7\f\x7F\xD4\x8AD\xD78\xEEf\x89\x8E\x02:F\xEFwy!\x90\xBF\x80\xE8\xA6\xC4f\x1B\x9Bl/\xB4\t\xAA\xC1N\xE6\x1B\x1F\xE8o\xC7H\xAF7F7\x15\f\xE7\xCA\x94^\xB7\xA0\xE1\xE6\"6\xD3V}\x1FO\xE2\bVJ\xB9\xFF\x83F\x86\xCFjQ\xE2\xB3\xD3'\x04\xFEj\xCB\xEE\x0F\xA3d\x8AS8\x96:}a\x7F\xC3CG\xA0\x0E\xB8.\f\xF9\x934\xB3\xDBsq(qau\xB3\xDE\xFE\xD4#y\xCAo\x16\x99\xCDyw!\xC6WO\xFC\x9En\x1E\xE5\xF9|\x9Co\x15\x05\xD7\xCA\x00\xA7R\x9BSEt\x8C2cr\x93,\xB8I\xF4\xE9E\xDE\xE6\xE6\xD1h\xE7\xA1w\xD9u\xAB\x9C\xE8\x1A\xA7i4\xEBB\x910\x910\xFA]\xB6\x96_\x91\xF5\xAA\xCA\xB1L\xBE\n\xD3\xDC\xBE\xB1\x85\x80XC\xD1o\xAD\x01o\x8C\x1E\xFEg9\xA7\xF4-i\xF7\xAE\xD1\x91<\xC401=\x9E<r^\xF0\x0F\xE67Z\xD8#.\xF8\xF0\xFA\xF7<(\xDC\x1A\x16\xF5><\xEB)yT=\xE1_?=\x8E\xE5\xF4\xEE\xEF \x1C\xF9\xA0\xAE\\\xFE\xEB\x19\xFE\x17\x0E\xA5\x10N}V\x94\r\xD6\v\xF9??\xCD8\xAF\xD7O\xEFvP\x7FVp\xFE\x92\xEB\x1E?;\x1F\xC0\xE8\xEEW\xA8c\v.d\x81z!\xFF\x1Fm`M<\xA6\xE3\xC2nv\xA1\x12\t\xC5G\xC2e\xC0\xE9\x85t\xB1~\xF0\xC2#\xF3\xD9\xDBp\xF3gg\xAD\v\x1D\xCE9y\xDD\xF1\x02\xA6\xC6\xA5\x92#w\xC3x\x01\x1F\xB0\xD78\xAD\xE3c\xD3Wu\xBA\xDE`'S\x7F\xF8@\xC6\x8F\xBB\x109\xEC\x9F\xC0\x8DnJ\xB8\xD7\xCD2\xF1\xA1\x89\xB3\xB4\x8F~\xCC\x9C\xA9\x7F\xE2\xA5\xC6\xA8\x1B\x86Z\xAE\x7F\xDC\xFB\xEE\xCB=\xA2\xDE\x9E\xC0e\xE5\x7Fc\x7F?Tg\x8D\x15\x99E\xFF\x90\xFC\xEB\xEE'\xB2V\xE6L\xF9\xBFa4-\xE4\x9F\x9A\xE7\xEC\xE5\x1A\n,O\xAC\xE1\x1Ds6e=\xF9\xB7\xC8\xF74\x8F\xBD\xB8\xE4\xEA\x9F\xF6\x02\xFD\\\xE8\x1Ft\x8CX\xD6\x9Ew\xD9\xDB\xAA\x98\xD1\x9F\x89Z\xB9\xCE\xAC'\xFF\xED\x86\x84\x8E\xF4[\xC2\xE6\xBA\xABts\x91\xAE\xEE>\xFE\xAA\xE1\xCA?\x1FH\xC2\x92\xF94T\xDBW\xFD\x99s\xDA\x96\xCB\x8Aw\x14\x91\xCCE<\x90\xFD\x9C\xAD\x92\xBA\x8E\x9E%\xB9\x96\xF7\xE1_%3Q\xFBs\xEF\xA8y\xAA\xFAz\xCB\xAC\xF8o\x1E}\x0Fjf\xCD4g\x1CgHr)(q\xA9\xFF3\x9C\xA9\x06\xF0\xADi\xF2\xAF&\xCC\xFE2\xFD\xCFo\xD0\xE6Q&\xFF7\x0F\x91\xBEU\x16te\xBDj\xA7\x9BG\xD3<\x8C6a0A\xDA@\xE7w\x9AHf\xE5\x10T'a\xE1\xDB[\xE3\xE4aln\xF9\xD0i\x19\xCD\xAF\xD3=\xFD\xDF\xEE\xCE\xAB\x94bw3w\x7F\xA8ySp \xD7y\xA0\x15\xC0E\x80\xC7yv\x8C\xE6}\xFA\xDF)\xD7?\xBD\xAE\x8Ak\x03\x92\xC37\x95\xEB\x7FU\xCA?\xC6\xA9$h\\\xC8\xFF\xFB\xBE\xC0\x88\xF8,\xF3\xAF\x1Amg\xFD\xBCn\xD6\xF9\xD7\xDAy\x13\xD4\xCC\xBA\xA1\xCCL\xFC7\xE4\xD8\xBD\xF6\xE9\xFF\xA1\xD9\xE5\xBF\xCA\xE9\x18\xDD\xCB\xA7\f!\xFF&\x97\xFF\x14\xC5R\x93\x90U\xF6v\xD9TC\x96?t$\xBD*C\xC3\x93\x7F\x81\xBF\xBA\x96w aE\xDAj~\xC3n\xBA\xFA\xB6\xD1\x9F\xD1\xD51\xD7\xCBc\x01\xEB\x9E\xFD\x95\xBF\xABkx@\xB5:\xB6!\x8B\x9BY#\xEF\xB9z\xC0\xA4\xB8zO\xFF\xABo\xCB\xAF\x86<\x94\xF8\x8BJ\xBD\xDD\xE7\xC8\xD8\xF0L\xA6\xCC\xD8\b8\xB7\n6>\xA5\x12\x1B\xBFE\x04\x9D\xFAD\xBDr\xC2=\xD9\xC7\x9C\xDF\xFE\x03\xF7\x12\x81\xFD\xD3\xF0\xEF\xFA/]\b8.\x85.\x7F\xF2$\x80m\xCF\xA4P\xA9\t\xD6=\x90qK\x1B\xDC:\xDD\xFE\x19\xEC\x0E8\b0\xFC\xEF\xB4\xE1\xD6\xB6\xBEm\t\xBB\xE2\xE6\x93\x1A\x9F>\xEE\xB3\xBD^m?\x92\xE6\xDB\x88\xBA\x97\xB06{\xE8W\x7Fd\xE2\xFBE \xB0\x86\x13\xFB\xDB\x8F8\x1DE\x93\xE4\x1F+v:\xFF\xF6d\xDE\xBD\xEF\xDB\x8B\xD8zG\xA7\x7F\xA4\xDF\xCBb\xAB\x0E\x04\xF2\xDB\xB2\x84X \xE2:\x176\x17\xE9+\x19)\xBD\xF9\xA4\x94\xB4\xC0a\x0F%\xFE\xA2\xDE\xD9*\xF1\xEF\x01\xB6\x1D\xFC\x85\xBBO\x84\xB8&\xF5\r1\x15\xC6[\x1F\xB5\xDC-T\xA8\xEF,\x0Fd\x10\xA4\x96\x8F\xB9\xCA\xFF\xBA\b1\xD7\xD4N\xCF&t\xBA\x7F\x10\xB5\xB1\xD7j\xCB\xE5\x9Fx\xFBw\x0Fj\xA8O\t\xD6\xBD\xD6A\xAD`\xF9\x7F=M\xFE\xEBRo|\x12Am\xDA\xED\xD2Q\xEA\xC5\xF13\xEC&~\xC0iA\xC5\xF9\xB9\t\xD4\x8A\x90\xF8\x91\xF5B\xFE\x8F/c\xFD\xF9\x15\xE1\xFFs\x13Gm\xA0\x96\xF4O\xED\x93\xAF\xD5^{\xA2r\x82\xCD\xBF\xF5\x93\xA7\xCEdF\x97\r\x9D\x90\xE0\xBC\xAF\xE3\xCD\xAF\xCAQS\xCF\xDF*\xD0\xA5k\xC7\x8E\x9B4\x89KF\x0E\xB5\xCEG\xC0\xCF\xA8\xE3| \xA3\x7F\xE5~5\xE0\xA1A\x9DGe\xA7\xCB\n\xBEQ\xC0\xB1\\Fx1\x84\x98YR\xFF\xA4T\xF5(\\'\xB5_\xFF\xBB\xF6\x8F\x8C-\xA7\x07\xE4:\xA2\xE2#\x9C\xBB\x9E\x86\xFF\xBA\xD1'\xA1\xC6\xE2\xFD\xD3\xF4?\xC3\xBF3\xEA@\xD1|\xFA_\xF5\x88\xE5ree5.\xE4\xFA\xA7\x8B\xBA\xB4Y\x14V\xD8K\xE9\xFD\ts\xC5\xB8\xD1\xB5\x81\x01\x8B\xEA\x8CL\x15\xD1n\x90\xFE\xA1Kl\xB4\xA9D\xBB\x98\x7F\xF7\xB6[]kL\x13\xEA\b\xD4\x88\xD1\xEF4\x8D\x8E&\xE5\xFC\xDB\xAE\xA3\xE3\xC3N\xBF\xFD\xBF:K\x05\xB5\xD5\xFC:>\xDB\xAA\xD7\xBA\xFA\xA7\xBD \xD6#| \xED\x86D\xA6j\x15\xB7\x19<\xB5\xACls\xB5\xCD-&6\x90\xFD\xE3\xF3S\x1B\xAE\xFD35\xBA\xD2\x87\x7Ff\x16\xF9\xF7\xA7\xFF\x12\xF6?\xC7\x7F\xFAz\xB0\xAB\xCA\x84\x9A\xB4\xA6\xDB?\xE7\x18,Q\r\x8A\xF4z0\xFCE<\xF9j{\xA6\xFDo\xF8\xF1\xE7\xAB\x806j\xE4[\x06O8\xB9\xF0&6?\xFEX\xB4\xF0\x90\xD4\xFF\x86\xE2\xDAK\xDF*\xC3\xFF\xDC\xB7\x1A3\xFF\xBE\xC5a\xE6\r\xC3?b4\xE6;\xDD\xF9WG\xA2\xF1\x17\xF2\xEAlN\xF9N\x16k\xD8\x18s\x1B\xB2TY\xDB5?\xD4L\x87\xC4\x90\xD7\xD2\xED4,\xD7\xA1\xE3\xC3\x9Fw2\xEE\xAA\xB86\x1B\xB7\fg\xCA\xF0\xAF\xAD=.\tp\xB5\x8EM\xFAB\x1D\x85\xEB}\xEB/\xE92\xABK\xFB\x94\xC9\xEDD\xC5s\xFD3\x9D\xF4\xFE\xA7OV\xA1n\xF7\xFB\xCB\xCA\xF1\xA76\xDF\xBA]C\xC0\xD9\xC2\xB5N\xED\x8FP+:\xF7\xCBi\x11\xF5\xB5\x917\xCE\f\xA3v\xA7\xDB%\xDE\xCF\xE3\xE3\xAC\x91\xD7ki\xA1\x1A8;\xA2{Z\xF1\x97w\xB1\x17W\x01\x85\xBBj\x05o\x0F\xFC\xA2\x9B~^w\x91w\xE0\xF5\xDA\xC8k0Q{\x04u\xCE\x1Dg\xAE\xBE\xE3\xCCu\x059\xB8B\x01\xC7\xCF\xC8\x0E\xD3\xB8^\x07\xFE\x17k\x7F\xDF\xB1,\xDE\xEF\x06\xEA2\xAE\xFE9W\x14\xFD\xE9&$G~&\x91\xA9M\xF1>\v\xED\xCA:y\xBF\xABm\xDE\xEE\xC6\xF0\xCE\x88\xA7\xE4\xE7\x8E\xB9c\xEE\x98;\xE6\x8E\xDF\xF9\xA3\x9CB\x88\xC0\xE3\xBD#W&\xF3U\x1F\x19\xAE\x96\xB7V\xF1\xCF\xBBt\xC5os\r\xF8s\xCEW\xC0K\x813\xED\xF7\xD3X\x90\x90\xED\x9B\xFD\xCB\xFB\xE3\x16\xFC\xF5\x87\xFDW\x95\xF9\x114\x91\xFC\x07W\xCEr$\xBB\xE49)\"\xD2CaOsL\xF0nh\xF6\xEC\x0E\x0E/6OIq\xEB\vj\xA2\xA3\x80\xD5b\xA5$\xE8\x0E\x97(\xF8n\x11\xBC\xD2Y\xFBH\x19\xFE<)\x90e{\x94~\xC7\x8C\xB9~\x1A\xD5\xE0g\xFE\xBD\x8D\x8A\xCC\x00\x9E\x05\xFF6 \xDA\x16\xD9\xE4o\xA1\xE2z\xFE\xFF\x8D\xD9\xB2\xE5s\xB2?\x82\xAA\xB5\xFC\xDD\x86l\xD9\x85\xAC\x87N\v~@59\x99\xB3\x812\x15\xB8\xBFE\x95f\x8A\xE4?zG\x11\xABG\"\xDC\x98\x9FW\x00\xD4\xDE/9\xC7^\xA0\x8D\t\xC0y`\xB54\xA2\xE2jd\xC3h\x04\xE1\xC3m\xF5\"u\xCC\x1F\x16)\x1A\xB3\xEA\xECME\x98\xB6\xE0R(\xA2r\xC8\x8F\x8C\x87\x89\x12\x17\x8C\x16\x15\x86[o\bv\xB7\xBD\xBB\xECNY\xBA\x88\xCF\xF1G\xBCO\x15\x05\x1F\xE2g\xCCfF=%\xB3\x97\xBD\x1DM\xBE\x00N_\xB9\xC3I\xFF\xC9-\xE3NY\v\xE1Q\xFE\xFFM\xD92\xFAh\xD3\xA8\x83\xAAo\xFB\xAF\xE8^\xA8\x8F\xD3eU\x0E\xD4\x14\xD4\xAE\x84\x89\xB8\xEE\xEB\x86\x9A\x80zX\xBC\xADr\xDA\x808;\x93\xFDd\xAA\x9B-%\xD6I\x7F\x10\x07\xF3\xF1\"\xDC\xDC\xDC}\x1F:q\xC3AH\xDF|ZX\xA4\xDF1\xE9BU\xCD\xB7f\x89\xFF\xA1\xDF\x12m\xF8\x80\x1F\x99QW\xFE\xC3)\xC1\xF3\x87#\x1F\xDA\xF8\xA0C\xB8$\xDC\xD0z~\xE6\xA8\x8Eq\xBA\xE9\x9Fvx\xF2\xFF\x98.X\xF1\x8F\xE8\xED\x05\x1A\xF5\xA9\xC2t\xFCO\x95\x9B\xFA\xA3\xBE'\xF5S\x17\x84z\xC7K\xFC%W\xB8\xBC\x1B\x17VO\x9C\xF4\xB7 \x85\xDC\xDF\x0E\xC2\xC9\xB1\x83\x11\x84E\xDD\xAE\x8F\xA9\xD9Q9\xDE\xA3\x07i%U?\x84\xFA\xF7P\xBFp\xBC\x80\xB3E?\x02\x0E\xEA\xB5s\"\xADP\xE7T\x11Sg\xF3\b3\xFC\xBB\xA8c)\x99\xAF\x83\x0F\xF6\x82)<\x14\x00\xFE\xC7\xF2\xC8\xD9\xB3\x11\x84\xBFs\xE1\xA0\x90\x7F\xD6NXA\xF8\xEC\xA6,;\xF3S7\xD7G\xFD[~d|\xF2/\x17\xCEj\xEA?\x00k\xFA\x85\xEC\xFD\x81\x1C\xF2:S\xE8\x1F)\xFF^\xDD\xCFV[\xC8\xBF\x90|\xFB\x9F%\xFF\xFE\xB0\xE4\xA6n\x8F\x18AP\xB2\x91\xE1\x97\xDC\x13:\x8Ah*ie-\xC8-\x1E\xED\xFE\v\xA9\xF7o~\xD6A\x95\xA8a\xDDY\xDE\x93Nc\x80\x0F\x90B\r\x9D\x84\xC9$\xD9\xEB\x86\x9AFU\xEAf\xA1\x7F\x06\xDBut\x1A\xAFpL\xFE\x8CB\xD9\x7Fn\v\xF9\xE7W\xDCS\xF4\xD6\xB3\x7F62\x19otP\x8D[\xF6G\xDD\x0E\x93\x9B\xA3\xF94\xC9\xBF(\xCFmO\x97\xFFr\xFD\x9F\x11\f\x8C\x8D\r2\xF0\xDB\xBD\xC4w\xA9c\xDF\x82\xD0\xFF7m\xF1\xE4\x7F\x9E\xCB\x87\xD0\xDBogg\xC7\xBF\xB3\x9C\xEA\xF7\xABA#\xEBs\xD6\xA8\x92V\x95\xDB\xF0y7\x8C\xC5\x13\x7FX&\xFF\xC6,\xD3\x8Az\x95iX\xA8\x12\x8Cq\xD2.;as#\xDDYu\x98TP\x17W\v>\xFD3\tu\xBE\x98\x0E\xAAV\xAD\xEB\xC6\xCD#i\xCE\xB4\xDCH\xEE\x80?6\x85\x14m\xE8\x16\xFA\xBFCJrr\xA8\x7F\xC3\xA8\x82\xF0*\xABC(\xCF\x8DY\xEAa\xD5\xD9M\x05t\x9A\xE2*\x9DE\xA0\xEAm\x7F\x87;\xFC\xFA_\xC8\xBFsK7V\x8F:\xD3N\xE0C\xFFnQ\x98\x0E\xF7\xA9\xF1\xCB\xE9\x7F\xEEY\x9E9\xFFN\xA3z\xDA}\xB7\xE3\xEB^<\xEA\x00\xAA\x1E\x95\x12~r\x9A\xFC\x97\xD5B\bO\xCCr[\x03\xF7lz\xF6\xAC\xCB\xA2[v\xD9\x85:\x87\xE8\xF3*.\xFF\x99$9\v<3@\xED\x87\x9A\xBAY\xE0?\xDA\x06\xFC\x91%\xBC*\x0E\x9B\x7F\xCF\x06\xE5\x18\xB9\xFE\x7F\xAA(\xE4\r\xC0-\x1F:V\xFF$B\xCD\xFF!'\x18!r\xDCO\xA2\xEA\x9B\xB7dqsQt\x92>\xBC\xFFF_\x87]\x8E\x1A\x95)\x04H\xFE\x03\xFAv\x1B[\x03\xF64~\x9E\x13\xC5[\xB2\xD2!u\xD2s\xFE\x1A\xA6\xE0\xC3\xB7\xD2[\x9E\xCF\xAC{\x86\xFC\xDFU\xFE\xC9v\xDF\r:\xE5\v\f@\xE0\xD2t\x02\x10\xB8U\xC7\x8A\x16g{\xD9=\x15\xFA\xBF\xEC\xA6\xD4:\xF7\xEE\xB3\\\xFC\xB9\xA2p\x7F\x95z\x8En\xA8\x1AG\xA0\vU\xAC5\xFEO\xDE\xBB~T\r\x88\xA2\x9C\xEA\xE1\xEDE\xFC\xFA\xA4\xC5\xB7*\xAC\xD1\x81@d\x95\x04\x84\xFFd\x14\xE4b\xE0}h\x8An?\xC9\xEC\x9F\xEE:\xD1\xF9;\x99\xAA\xE9G\xF0\xD8MY\xDC\x97\x15;V\xEE\xEDf\xED\xF85\x83\xC7\b\xD5\xC7Q\xABr*\xE9\x98\x8D\xE3g\x9Ci'p\xB5\xFF\xB3n\x8CQS?_\xE65\xF2\xEB,\xB8-r\x9C\x9E\xC7\x7F\xA2\x9F\xCC\x8C\xBA\x7F\xAD\\\xFF\xBF\xE9\x13\x83\x06\xF7\xE4\xFA\x01\xD75\xE99\x80\xE8\xEE\x8F\x7Fx\xB1,\x926(\xBE\x1D/\xD3?\x91_\xFD\x81\x83\xB0\xF0\x9C\xBE\xAB\x97]\xE8\xDD?\xE0\x95CS\xE4\x80\xC8\x1C\xCBb\xD8\xF6q\xF2\xB5\x93\xA8?\xFC\x8F\x82\x883\xDE\xD4q\xE3\xFA^\xCE\xC8\xF5Q,\xEE\"[\x00rT\xCEzo\xC9'z\xFC\x93\xE4\xFF\xAAs\x10\x9C\xFC\xB5\x8C\xAD\xFDU\x91\"\x04\xEA\xAE{7\x8B\xFFY\xC4\xBB4\xF6_\xD9@\x9Ds\xA28\x9B\x12PR\xD2\xFE\x1C\xE8\xB0\xD1&\xD5\x8B{\xB3\xB8\xAE\xEB\xCA\xE2f\xD2D7Z)\xBF\xFD\x7F\r\xB5\x19\xEF\xF6\x042>c\xD7\xC9\xDAi\xCE\x02\xDF\xED\x88\xEA>\xF9\xAFqf\xCA\xBFi\xA2\xA1\xE6R\xB9N\x13\xDF\xC6\xF52\xFB\xB3\xD3\x8AA]\xE0?\xC3\xFD\xD5\xA65\xEFI\xFB\x9F\xCClz\x96}\xFA?\x06u@\x8C\xB7\xCA\xE9(R\xB8\v\xE9\xFFE\xE4\x05\xE0\x9E\xB8\xA4\xCE\xF4\t\x1F\xF5\x1F\xBAN|c\xB2c4\x07\x98m\xD2iB\xDB\x97\xFAQ\xF5v_\x96\x81\xB6)+\xF5\xBFz\xEDzsV\xFB\xC7\x90l\xB9\x167\xD1\xDE\xD89Mis\xF9_\xA3\v3\xA6k\xA4L\xFF\xF3\xAA\x1D\xDC\x89\xB0\xFA2\xF6\xBFY\xB8\xAC9\xB4\xC4[\x04\r\x88\x9A\xFE~\x07\x10\xB5\x165\xCD\xB2H~\xF9m\xD9\xF6F5\xB2i(\x89*\xA1\x84y\xBC\x81\xAB\xE1;\x87\xD6\v\xB3V\xCDC\xCDl(\xB0f}\xF6O\x12j\xA1Kx(\x86\xDAu\xF4\x18\x16\xD7\xFF\xCCnT\xBB\x14)6\xFC\x9C\xA9\"\xBE#G\xD41\x1AiW\xF3\bN\xB6\x8B=!\xB8I\xE8\xFFd\x926\x00\xFA\xF4\x7F\x97\x7F\x1E\xF4\x9E\xE8\xC00jy1_\xE7\xD7\x05\x1C\xFF\xE47\xD3\xF8y\xAE[\xDE/\xE0\x9F\xE8\x93\xFF\xB9\xACL\xFE\xBFW\x14\xDF\xBA\xD5\xCAgF\xDD\x1F/\x7F\xFB\x0F>\xFC\xB7\x16\xE0#\xCF\x8B3\xE5\x7F\xB8\x80\xBB\xF4\xC2\xF1\xD9\xE4\xFF}\xFFm\xAD\xBD\xF6\x9F\xBE\xBA\x1B\xF5\xC24\xFAG\xBD\xCC\xC5\xF9O_}\x91t\xCBu\xA8kF\xAD\xF3\xFF\xD7\xF1\xBEN\f\xBF\xD09\xBB\x11^u\x82\x83S\xB7\xEAx\x11o\xFD\xCC\xE1^\x06\xA6\x97\xEB2\x019\xAE7\xA4\xFC\xBF\xEE:1\xBF\xEA\x1C?s\x12(\xFCS\x83\xE8\rS2\xE1\x00\xEA\x1E8o\xB3\xAB\xFC\x82\xAE\xF2n\x91\xB5\xF3\xCB\xEE9\xDEk\xEE\x98;\xE6\x8E\xB9\xE3w\xF4\x90\x95\xE2\xAD\xDF\xCA\xCF\xFBX\xFAiur\xBD\x19PU\xA0BW\xE4&\xE0\xA8G \xEB^:MD\x98-\xA7\x88:\xAAQ\xE8\n\xA7\x97\x15\x91\x17\xA2\xA2\xCA\x7F\xB2\xA0\xD6\x1B\xE8_\xB4\"\x02%2\xCD_\xA0\x88\x1D\xE5\xA6*\xC3\xFEUQhx\x16\x9A\x1D3\xEA>\xE9e\x04\xBD7\xA1\xEB\xB26\x19\xA0\xAB\xAA\xBBQ\xDA\xF4*\b\x97\xCD\xFE\x97\xDDIw\xE5lG\xCD\x9C\xA8\x1F\xB9\x12\xFE\xDCl\xFB\x96\x17\x9Bj\xB9L\xD7\x86\xD1\xB3\x9B\xCB\xF1_\x10\xCEF\xAF\x8C\x7Fe\xE4g~\xFC\xC3\xD9\xEB\x94\x8D~\xFC\xBF,\xC7\xBF3x\x94\x17\xD4\x93\xF8o\xFC3\xF9\x15O\x02yo(\ve\xD4\xC5\x7FC\x96!\x13\xAA\xDF\xE4\xE1\xAF\xA8\b\xAA\xD7\x9Ad\x87+\v)\xA0\xE3*T<\xC1\xED$}\xEBZ\xA8;u\xD7\x14\t\xED\xE4\x9Do\x18\x91\xC0*\xBA\xA1\x9A\x02 \xD54d\xF1f\xF7\x13\xA2\xAA\x04\x02}oL~6\nTN\xB6\xF6;&\xE5\xBE\xD0\xF9\xAE\x01\"\t\x83\xD2B\v\x9F\x9A\xA4\xFA\xCE&\xE7{;><{\x05\xFCe\xE0\xAB\xBCG\xA117kS\xBB\x91\xBF\xB1\xE8Y\xE0\xC1\xD7\x9D\xC7K\xAB\x16\x8F\xAF\x02\x98Q\xBAx\\\xE6jVV\xB9\x99\xBA\xA1>\xF9\xB5\xE0\xAF\xA0\xD0W\xE1\xC3_\x9C>\xBCn\x9C\xD8\xB0\xD0\xE1\xE7\xE9\x84y\xF4\xAB/\xA4\xAD\xF8\xC5\xE8\x06f\x97\x16\xF1e\x11_\x8C\xFF\n\xE1_\xDD(\xBFr\b\xFF\x1F\x96V\xA1j\t`R~'\x98Yf\x90\x7F\xE1\xF6\xB6\"\x82\x1A\x03\xD5\x06[\x02\x84Gy\x9A\xEET\xB0\x88z\xB2\"\xC3\xF7|\xF1_\xFE\x0E\xE1\xF7\xBFpM\xF1\xBA\x95|8Q\n4\xA5\x9A\xCE\xAB\x9AFSb\x97\x84J;G([\x94\xFC\xC4\xA1\xF5BJZ\xE0f\xA6\xE30\x14U\xEFO\xF7QhY+\xEF\t\xBD>//r^U\xCF\x87\xAFB\xB8w\x1B\xDD\x91\x8F\x97_I\xFE9\xCF0\xBA\xC7\xDD\xE2\xA1~$\x118;~v\xAAL\xFE\xB5\xC1\xB8\x11o3\x10f\r^\x8AKj\x94F-\xFC\x86Z\xE4\xCD\xD3\v\xF8'P\x8Ch\xC7P:N\xAFC[\xF6\xD1\t_6\x1A\xF09\x19;o8\xC6\xA06\xD1\x0ED\xAD\f\x94\x05_\x9A\x1E\xDD\xCA\xAE\xD21\x84\xC0(\xC2\xCE<\x8A\x93/\xDAL\xA9\x86\xAAFe\xF7\xF7\"\xB4\x00\xCA\x82\x1D<R\x8E\xF6Y3%\xC2\xE5_1\xA35:\xD4\xBD\xDE\xAE\xE9P\x96{+'\xC3{\xC5\xED\v\x17&\xC3\x03\x9F\x8A\x81\x98\x136\x10\xCE\xBA\x19`\xD8H\xC31\x84e!K\xD5\xBC\x90\x18\xE4\xF8\x9BT1\xD9\xE4\xA1Y$\xFF\x8F\xB9\x8E\x92\xE0\xE4S\x1F\xDD\x83\xEA\xBD?!l\xDB\x1F\xBA\x92\xFCo\x10!\xD6\x97\x97\x7F\x17\x7FU\x1B\x8C[]m\x16O$b\xC4\xE5O\xE8m\xA7\xC8\x92\xB4\xB7\xB9c\x94\xE9\x04\xBA/\x93\x89\xA1\xC9\xB8\xBC\x17t\xC2\xDA\x96\x11\x86\xAA\xBCD\xDC\xEA\xE4\x95D\xFE\x14\xF8\xD2\xCA <z\x93\xFC\xEA\xCF\xA8cJ\xF2=\xA2\xA0\xB5z\xDA\xA7\xD3Z\xC4\"\xF6\xD4\x18\xEEB\x98]+\xDC\x7F\xCE\x04\x82\xFD\b\x0FJ%\xCE\x7Fl^\xAA\xD6\x11\xF4\xE1_\xA7s\xFCu\xF5G\x02\x7F%\xD54\xB2W0\x9Cj\x8Ail\xF5\xB0\xC7f\xA8)\x7F\xCC\xB9\xAA\x9A\x99\x0E\x86\x7Fk\x7F\xBAu\x94\x92 \xB5\xF4\xBA\xF2\xEF\xE1\xAF\xAA\x83\xED\x11TG\xB8\xFE\xF7\xB0\x9D\xED\xE0\x04\xCE\xBF\xAFr\xF5\xFF\x90\xAB\x016\x8F\xE67e=~\xACod`\xF0\x86\x91\xF7:,(\xFD3\xF1\x1F\x10i\x87S\xCE\x1AK\x14o\r\x8D\xE8\x1D\xFDF\x07\x15\xC7\f\x8FL\xD2\t\xBD\xBA\xEFd\xA0\x97\xE4\xFFN\x13\x95E\x1C\xD8SB\xC8\xEAu\xE5\x9F^Lv<\x81\x80\x83\n\xEDk;\xCE\x01\xC8q\xF9\x97a\xEDT\xE7\xC5Bh\x88\xB2\xD0\fA{\x94\xF5\xF3\x94\x83\xCA\x85\xBC3\xCF\x8F;P\x9F\x9C*\xFA\xD9\f&\xAB\r\xFD\xB7\x88\xB7Js\x83\x1A\x93hg\x16\x17\x81`\xCC\x17\xA8oA]\x06UD\xC0N\x9Dr\x9E:-\xE4\x9Fc~\xB8\xD1\x93\x7F\xF7*\x8F\x05'/vt!,\x8A\xD7l{\xD6\xF9\xAD\xFA\xDF\xDBbP\x7F\xD6\x95\xFF\xAE5N{\xD1\xB7\xD1/1\xF0\x985\xF8\xAD\xC4\x02(L\xCC\xBE\xB1\xCEM\xD6\xBD\x80\x89\x92\xC0_i\\\xD3\x85\x00}\x15\x1A\xFC<1\xD8`\x11K\x16\xEAz\x88N\xB0\x0E\r\xBA\xF9%\x00<\x14\x0F\xF1\x8A\x15\x93:z\xDA\x9B\x11~\xCFu\x94O\xD1\x8B\x03\xC9!T5\xA3\"R\xB8\xBB\x9E\xE3\xBF\xB9\x1B\xF3\xEB\x0F{\xFA_1\x10\x1E\x8Cr\xFDCz\xAFM\xD5QG\x14t0q\xA9\xDD@0\xE3\xD5\xCA\x0F\r\xF1\xFD\x9E\xD7\xDFAA\x95Z\x1A\x95\xF9o\x9C\x1A\xFB\x81\x98\xE1\"\xDF\xB4\xA9\x0E\x05\xF0'\xA2$k/\x82I\x04\xA5\xFE\xD7\xCCs{\x0E\xA3rR\xEFwZ\xDF`\x98\xE7\x1A=\xD9v\xE5\xFF\xB3\xA29\xD8\xDE\x85j\x87\xA7\xC2\xFE\x87\x93W\x92\x7F\x1EH\xBF5p\xD6\xB5\x7Fn\x93\xBD\xBD\xE1\xC8\xDE\xED&x\x1A\x7Ffj\f\xEC},\xC1\xF1g\x90\xB6'e\xAE-z\xEAE:\xF1p\xEEO;\xDE\xE3' <\xD8\x96\x18\xFC\x9C\xDF\xA6\x9A.\xEE\x1B\xED\xDD?\xE8\xCA6\x80\x0Fo\x18\xE3\xB7\xE3!\x1D\xAF\x8E\x8F!\xD4\xE5\xEA\x7F~#\x0Et8\b_\x02\xF6\xB6>8\xC1\xF3\x92eMLyO\xF4\xD5\b\x04\x10\xDAy\xAE\x1B\b\x1F\x816H\xF8\x17\x85!Z\x97\xC8\xAF\x1B\x82\x9Aq\xD5\x1D\xEA\f^\x95\xD5\xAAzW\xC8\xAD\xEAt\xA8\xF9\x9B\x85;~\xD3z\x9B\x1C7\x80\b\x10\xAF\xB2\xC8\xBD\x1Es\xF1\xB7m\x8D\xCB\xBFN\x14\xDC\xAA\xC6\xD9\xF4\x7F\xD8\xC9<\xD2\x85\xEA\xC8\xAFI\xFF'_\xE8\xBD\x02\xFE\"\xF0\xF5L\xDEe\xE3]\"kt\xBDCa\xF9\"\xE9S56\xFE\xF5\xC0\xC0\xC6G4\xBEe,\xB1\xCB\xAD\xEB5\xC0C\xC1\xF9\xB3\xB0wW\x02\x01\xBE7S\xBB\x7F\xCF\x80n\xD3\xEB\x9A\xC4 \xF7\xD2v\f\xF8\x16&\x18\xDA5\xC4\x1D\xA6\x9F\x9AP\xAB\r\x84O\xBBD%\xB7\x7F&\xFA\xB3\xD0\xBA\x80,/M\x954\xD1Z@\xA4\xDF\xC5\xFF\x1C\x82W!\xF4\xE3\x86\x02\x10\xFA1\xC2;\xC5\xF6U^\x91\xBF*q\xE9\x0F\xB6 \xFC\xEEu~\xF9\xE7\xF8W\xDF$Bv\xD4\\\xFB\xE8\xD0\x9F\x8Bm)\x1B\xD7\x15\x81jv\xA1?\xE7?\xA9vP\x9Dd\xFF\xF8\xAF\x91}\x8C\r\x9F\xF4\x7F\x81\x8C\xF0\xC6^w\x81\xE0\xE1_\x11y\xAC\xBA\x17\xD5\xA2DZ\xFB\x15\xED\xFF8\xBFGC\xEE\x1Cm\xAEq\xE5\x7F\xC4\"w\x80\xB0\x9E\x03\xE8~\xC7&\xFC\xA9^\xC3@9\xFE\x02\xD2\xD0@\xEF\xAE\x04B\xB4\xEF6\xA8\r\xD8\xDA\xFE=G9\xFE\x17\xE9\x84\xDE\xC4\x80\x9B\xDF\x89\xDD\xE2~\x86\xFFQ\x1B\x836\x9A~8\x04%qT~\xD5K\xC6\xDB\xC6]?E\x90\xD9\xFFST6\"o\xC201\xCF\xD5\xFF\xE1\bB\xA3\b\x8F\x1E4\x81\xDAQ^\x9Cz\x87\xB6D\xC4\x14U\rD\xDB\r`\xFE6\xBF\xFC\x93m\xD0_\xCD\x05|\x12Zn\x8F&\xF1\xAF\xDE8`O\xC3\x1F\xA8N\xB1\xBB@\xC7\xFC\x86\xE8\xAE\x83\v(\xB5NZ'\x17\xF0\xAAF\x8F$?\xEF\xC3\xFF|8\xE2\xEA\xFFN\xE3J\xF2\xFF\x1D\xBA\xD0\xBAg_qg\xA8u\xB2\xB7\xD6\xD0J++m9\xE0_\xEEx\xE2_\xB4-X\xDD\xB1\x02\xB5+\x00<\xD2\xB1B\xE2\xCF\x9EzQ($48\xCF\xD5?\xA1\xC1G\xD6\xAC8\xD0V\xA6\xFFGH\xFF\xBB\x8E\xB0\xEAv6\xB5}\x8D\"7\x8CP\x1Ej\x97[\xFB\x80\x8B\xC1\x81\xB6(\xB0\v\x15\x7F\xAD\xD2\xFE\xDC\x1Ff\x99^\xAAW}{\xF6C*\xB4\xFE\xACI\xA9j)\x94b\x87\xA6\xCB\x9D\v\xDAd\xC7\b\xAA\xA2C.\xFE\xE1\x11\xFE\xF0>\xB2\x83W\x9AV\xA1\xE5\x1E\x89\xE5\xBE\xC2E\xAC\xFA\x1E\x86\x7F\x05\xEB\xF0WDu\x06\x03\x15I\xF6\x8F\xFB\x8F\xA2\xD1\xA1\xFD\x83\x02\x7F\xEE\x02hWf\xCA\xFFy\x143\x8F\xCCw\xE5\xFF\xE7\x9F\xA4\xAF\x80\xFF\x1Bt\xEB\x8F\xDE\xE5.I\xCD\x7F\x94\xFA\xE7\xFDO\x8E\xBC_\x84X\xCB\x00\xC5\xBB\x03W-\xE9Y\xAF\x0Fs\xEE\xFF\xF7\xF5a9\xA8\x12\x80]\\\x84\x02=\xBF\xAF\xE7\x10\xE8!\xFD\xD3\xF3\xFB\xB1\xE1\xDB\x17\xD3\xEBPi7\x9D\x10\x8C\xB1\x93o\x97K\xE7\xEB\x960=\xFC\xB6\x8E\x9D:\xA6>~\x11\xD5\xB9#\xF2\xAB\x14\xAFU\xB4|\x15*^D}\xFDU\x84\xFF\x8Fu\x86\xFF\x0F\xDE\xBE\xBAl\xFD[\xDD\xAF\x9B\x1C[\x958\x13\x89\x7FP3L\vZ\xCE\xF0\xF8\x03\v\xB8\x07\xC0\xB5\xB7\x93\x9B7\xB0\x10\x95K\xBEv\"*w\xC9\xED\xFE7E\xF0\xCE\xDF\xC6\xEFH \x8E@\xCA\xCDY\xF4\xFA\x99UG\xC7\xF7\xA1rrj\xD4\xE1\xFA\xA7b\xC0q\xF1\x0F\xBA7y\xFC\xEA\xDA\xEE\xAB\xAF\x1C\xD68w\xCC\x1Ds\xC7\xDC1w\xFC\xCE\x1E\xF3.\xE3\v\xA0\xD9$2kF\xFD\xF2\x19E\xF3e\xE9\xFF\xADG\x19\x85\xAE\xFA\x92\xE7D\\r\xD2\x9EI\xAA\xCFR\x8DW5/\xDF\xA3\xD9\xC63o\xB61F\xF96\x01\x05>2\xF0\xB2M\xA9\xF64|\xA6\xF5\x81\x1B\xAA&'\xADU\x9EO\xA6B\xAC\x92Z\x1F\x16\xB9\x9A\x81H_\x81-^\x82\xA7&+\xEC\b*'\xE7\xC1K\xD6\xD7Z@\xF8\xC4\xC4l\xF8\xA7P9\xC1\x1Bi\xB5S\xD5\xBC\x02\xEC\xC3\x93T\xCELC\xE5DE\xA5\xFC\x15\xCF\x01.\xE3\xA9\x16\x15\xFD>\x8A^\xC0\f\xDC1\xC9\x8B(\x85\x8B\x11\x15\x89\xBE\xE2\xFD|\xC8\xF3*'\xB4nJ\xCEo\xA3\xF5A\xA7\xD5.\xC7?8IY\x95\xCE\xF6\xBD\xE6\xB8cw\xF3\xAE/*F$\xEB\xEE\xF0\xEC\x10\xBC\xB6/\x8F\xE1A\xC5\xD5.\xFE\x15\xB0x\t\xB6\nu\x12\xE8\xCDsT\x89XVL\xF4\xB1\xC5\xC5,\xF8\xD3(\x1C\xD5F}\xD1\x99\xBE\xC5#\xE8\x85\xCD\xF7\x15\x18\xFES\xC58*'\xD5\x8A\xC8<\xA0uG$\x9C\xD6(A\xB7\xC8U\x8Ep\xC44\xA1\x9B\xB8h\xE8\xAA\xCD\xCC\xB6\xBE\xB7\xEF\xF102\xF1\x81\xA2\x89\x18\xB3\xA0\x83\xB0#r\xC8\x84\xE7C\xD1x#\xFA\x9E8\xAF\xD7\xA0\xF7\xAB\xCC\xF8\r\xA7\xA0h\x9F\x954\x11\xBB^\xA1\x01Y\xC8\x84*%W\xAA\xEB-\x84-TN\x9C\xA7F.QJ\xF9S\xE3)s\xF9\x00\xC2\f\x9F\xBEa\xED#\x1B\b\xFF\xDDgE\xE8iE\xB7\x05\xF3\t\x11\xA6\xAER\xC5\x87\xA8\xD9!\x12A\x8C\x17\xF1\xD9\x88\x90\x8E\x0F[\x9C\x8B\x82\xF7H\xF3\xF0-nj&Dx\xF99\x97\x16\x9B:{\x96\x1B\xECS\xA5~\xD4[\x8BE!\x89\xFD\xBC\xC1\xF5\xC3\x9A\x97X\xC6w|\xA8\x03\xF5\xF9\xA9\"J\xCB\xD3~\x86m\xCA\x97\x98\x88_\xB7:8\xA9\x06'\x19\xAA\xC7\x9D\xA9\"\xF4\x87\x1D\xBD\xE3p\x99\xFCW;\\\xFE\x07\x9B\x9C\xD1\x8E\x18\x93\xFF\x90\xE9\x97\xFF\xA7+'d!E\x13\xD5\x91?\x17\xCF\xD5|O\xFE\x1F\x89\xFF\xA9\xEE\x93\xFFj\x13\x95\x13\x8FUN<kJ*\x92/KI\xFEs.\xFE\xA1K\xA8\xEE\x05\x12?\xBAA\xC8\xFF\xE3c\xE9\xFD\xD5\x89\xBE\x8F#\xA8\xA6j\xDD\x95\x13\xAF\x92\x83l\xAF\x94\xFF\xC7\xDC\x07 \xC4\xE4\x7F\xAF\x0ETG\xFB\x8E\t|\x9E5\x91\xB9A\xC8\xDE\xB3\xED\xC6\xE3\\\xFE\xABS\\\x0E\xA7\xFC\xF2O\x01\xEA\\\xFE3\xBB\x84\xFC\xE7\xCDI\x84z'Md\xB3\x80\xC6\xF0\xCF\x99\xF8\xF7\x0FN\xB0k\xCD8\xA8\x94\xAD3d\xE3\xE0\x98\xA8\xB8\xCA\x8F\xA7Q&\xFF\xA6\x89\xBEQ\xABu\xC4b\xF2o\r1\xF9\xEF\x8F\xF7\x95\xCA\xE5\xBFZ\xC8\xFF\xE3\xA3\xFA\xFE\xF6#PT?\xFE\xBA\x89C%Y\xC8\xB2r\x12\xD5\x91\xBF\x10\xF8G=\xF9\x7FD\xE8\x1F\xBD\x9F\xD2\xAAT'\xA0h\x8F)\xDA\xD3\x92\xB8\x86\xB2\xDF\x95\x7F\xAF&c(\x86j\va\xE71\x835\xF2M\x13\x99\xE6\xDECojf\xB3C\xF7\x05\xC9\xB8v\x802\xB4?.\xE5\xBF\xCF\xC3\xBF\v\xAA\xCA\x10\xAE>k&3\xEE\xD8\x9F*\x8A\x15\xE5\xA1\x8F\x8CAA\x14\xC49\x0E|\xA9\xDB\xCE\x81\xA2\x00]^\xF9\xF7\xA91!\xFF\xCF\x9D\xEEG\xC8:`\xE2\x90.x\x83CE0\xACjf\x91\xFFW\x8B@(z\xA8\x88\\s\xC2_\x97\xF3\xD5\x19\xF2\xDF\xDE4i\xDC\xC0\xE4\x7F\xEA\x14\x13N\xFDa\xE7\xBDCN\x99\xFC\x93\xFEi-\xE0b\xE3_f\x97\xAEd\x8B\xB8\xB3^l[_\x11\x1F-v\xE5\x7F/\xAA\x9D\xC7\xF8\xB5\xAA\xD7\xFB\xE4\xDF\xFCX\xCA\xFFf[\xE0\xFF\xD4\x89\t\x81\x7F\xF0\xA7B\xFF\xD0\xA0\xBC\x12\xC6\xF5G\x10f\xF2\xFF\xD4)\xF6y\xC9Df9\x9EmO\xF5\x8De\xB8\x1F\xAD\xF9\xC1\x89\x03l\x98\xFB]\xF9_\xEA\xDE\xBB\x1A\xA6\t\x19\xC2\xD5\x98\x92\xA5\x99\x0F\x15qQ\xCA\x7F\xAE\xDAy\xBCX.\xFF\xF4\xF6\x16\xFEP\x84\xDFs\x89\xA9\x8BI\x8B\x7F5d8\xA8\xEF\xFD\xDC\xA6\xD2\xD2Z\x8CW\xDB\xFC\xEEqG\xF8,\xCA\x8F\xA1,\x93\xFF\xFD:\x0E~\\&\xFF\xEC\x85/l\x92\xE1ox\xF2\xCF\xBA1\x1A_\x13\xF5\xF2i\xC4+\"\xA8\xBE\x9Aw`py\xE0\xD4q\x9AK|W\x8C\x00\x07\xA2\xA6\xD0\xE4a\x07a7q\x99\xCFz\tw~UJ\xE6c&\x95\xF3\xA8\xB9t\xCE\xB2\xCA\xBD\x1BD\xAAK\xB7\xA6\xD0!$\xFF\x17(\x81\x86a2$?\xEC\xD0\xCC\xFA\f\x97\xFF\x10\xCCO\xA8@-k\xA7B\xAB\xF0\x87k\xD4[@\xF6\xB3\x02\x10\xBEz\xE8\xA0\x90\xFF\x8Ft<^\x10{\x97\xC6\xC7!b\xA0\xC3\xA2\xCC+'\xE6\xEE\xCCJ\xF6F*\xED\xC7\xDF>\xCB\x15\xD1\xF8\x07{\x11\x8A\xE4\xBBq6\vNlN\x15\xB1-\xDF\x89\xFAY\xBC\x84\xEC\xD2\xF5\xB1\xF1\x02Fw'\xFC1\xD8\xA4\xFF\xBD\\\xE8)W\xFE+\x98\xA8[&\x1Ekr\xFA\x88$\xFF?$u\xF1[#\xA8\x8E\xAA$\xE7\x8F\x9F\x98\xCC\xB5\xF7\xA2\xD2i\xDD\xE5\r\xB4\xB5\x88\xFCs\x93\xE2\xF9\xAA\xD0P\x1D\x11lRu\nag\x8A|\xFD\x1F\x7F\xD4\xB5\x94\x87\xA4\x8E\x1F~\x8A\xE9\xE4\x8DP\x87\x9E*%\x84\xAA\x0F\x8B\x82\xD7\xD3\xE5?t=\xC3Y\xD1\x1E?\x95\xE1\"\xBA7\x14{\xF5#l>\xE6\xB0\xFB\xC2Zs\xFE\xBB\xCE\xD4\xE9\xA0\x8E/J\xC7\xBF,\xE2U7\xD43d!\xF8S\x92\xFFR\xEB.\x81\xFF\x01\x1D{\xF78R\xFESO\xF9\xE4\x7F\xAA(\xF4\x1E\xCF\xA6\xC2U4\x87}0)\x12\xB5\xBD\xB4|\x12!6\x15\xE6\xB2\xA2\xAB\xCF\xEA\xD8\xFCfrv\xF9\xA7g0g\xE3\xD0\xC7ee\xC7\xA9\xE4\xF7\xE12\xFD_4Z\v\x06*\x1DU\xD1\x98\xFC\x97T}\xDD%\x00i\xDA\xB2\xF2\x9F\xF78\bG\xFB\n0u\\\x8C\xAA\xB9v\x15jF\xDF\xED]\xB1]\xC7\vw\x9AB\x930\xFD\xBFR\xEA\x9F8`\xAA\x04\xEC\xAE\xA5\xDFn\xE7!\xA9J\x94\r\xAA\xBA\x13\xCA\xFE\xBD\x1D\x8E\xC0_\xD1\x84\xA7\x92\f\xE0\xBC\xA7\xFF\xEFD\xF8.TN\xFCxh\x90w\xF5\xF1\xB3\xB1|{\xCAd\xF3\x02\x93\x7F}\x07\x15\x10W\xD5\xC7\x8B\xD8\xB5l`>MR\xF2\xB7\x0E\x90%\xFCC\xC6.\xC7\xD5\xBD\x9F\xBD&t\xEFso\xC63\xFCF\xD3T>O\xEE\n\xDC(\xBC\x87\xAA\xAB\xFF?;\xA6\xF2r*\xCF\x95\xF6\xA2\xDE\x123\x85\x9C\xAA6\x9A\xE6\xAC\xFA\xFFP\x01\b\xC5\xFF*\x8B\xBF\xA7\xBB\xE3Nj\x7F\x97\xF5\xE5\x8D\xE4\xFAG\x8Fi\x88\xA16:ubB\xB7\xA1?8\xD9:\xCC\x1A\xDFM\xF8\x93\xFE\x11\xF2\xAF.\x9E\x1C\xED\xD0\xA0eZw\xB9,.\x1E\xD1qz\xF1\x84@\xB2.\x84\xEA\xF7\xA4\xFC\xC7\xA1\xF46\xED\xE0\xF8o\\\xCF\x9F\xBERt\x11\xFB*\x03uh\xD0\xCC\x8A_UN\b\xF9\xAFd\x1D{\xC1\xCB\xC1\xB8\x17\xD51(\xDA\xE0\xD0\x00\x97\xFF\xC1\xE6X\xBE=\xDE7\x16\xE3)\x07[w\x9C\xCB\xBB\xF2\x7Fb\xEA\xBB4Iysw\xF80\xCD\xBFc\xC6.1\xDE\x9C\x8D\xC1\x07\x85\xFE\x7F\xA5=5\x98\x95\x8E\x12j\x9Co1{\xCA'\xFF\xFFHL\xE6c!\xE7\xE7\xF4\xE2i\xC5A\xA8\xB7\xAF\x80WMa\xAA=\rlf\xFA?6\x13\xFF\x97\xC8\xFE\xC9\x15ph,\xE3\xDF%z\xD0\x9C\xA1\xFF\xF5k\x17\xE2Z(\x9DzZk\xB51OQ\xF5\xD5\xAC\xF1\v\xA7\xDF\xA7\xB4<\x11 \xFE\xAF)5\xA5\x16U\xF7\xB7k\xA8\x88\xEA\xB6\x87\xFF|\x1D\xFBuSl\xE1\xAC\xD0\x10\x9E\x7F\xDE\xD5\xAB\x95\x05\x83\xEE\xF5\x85\xF1\xCC\x0F\xE9\xB3]\x8B_\xA0\xAF\xA2\xA8\x88^X\x1D\x1D\xCDJ\xF9\x17\xA9\x14\x99\x94\x9C\xD6}\x18\"\tE\xBB\xF8\x91\x90\xFF\x8Bzr|<\xFE\xF4\x86$\x07M\xEF\xB7\xC6H\xFE?+bWT\xD9h\xFB\xE4\xBF>\x89\n\x9D\x19\xF1\xE1Z\x1E\xFF\xC3\xF7\x99\x86?\x11\xF2\xFF\xC1\x9E\xF8\xE7b\xCE2\xB8w\x8Ck\xC8\xBD>\xF9\xE7\xFA'|V\xC8\xFFGk\x00t\x99&X\xB7\xA9\xC3\xE3E\xEC\x8Dk\xECZ3\x8E\x13T\xB0\xE3L\x16\x1F\xD5w\xF9\xCB.\x97\xB2@\xD5\x82r\xFC\xDF]\x82w\xA1\xA4\xF5\xB4\xA6\xDBX\xA4\xA8z\x9C5\xAE\xD4\x04\x00|q&\x02<Z,2\xF9\xBF\xF6\x04\xAD\x7F\x95\xF5\xAD;<\v\xCA(@\xDB\xEE,\x14+\xA9\t_\xE2\xE2\x14jW\xF1\xB1\xCF\xC7\xEE'\xA8\x03\x7Fs\xB7N\xBAt\x15\xEAW\xE1\xAD\xAB\x17\x16\xA5\xFCs\xFD\x13\xBC\x8A\x8D\xD7[\xFF\x1EA\xC5N&-\x03=\\D\x83\x1F\xEC\x84\x9D\xFA\xE9\x07\xBB\xF9\x92\xB3u`X#\xF9W\x99\xFC;_v\xFB\xE4\xBFb7\x02:k\xAA\xE2:\xB7\x0E \xEB\xE4\x0E!\xFF\xF5\xDD)E\x9C<\f`C\x01Qz\xBB\xC8'\xFF\x8B\xC4\xFA\xB7\x97oH\xF9\x171\x07x\xB1\xAF@\xA1(a\xB1\xAA}\xEA\x8D\x8B\xECZ3\x8E\xAB\xD8#\x93\xAAd\xC3y\x11\xC0\xB5\xBA/\x8C\xA5\xE6m\xFF\xFA\xB7o\xBC\xFE\xB5\xF1zT\x9Ei}p\xA2\xD5F\xF1\xC4d\xEB\xEB\x13s\x1C\xD7\xDC1w\xCC\x1Ds\xC7\xDC\x81\x191\xF3\x03\xB0*\xB8\xF7^a\xFF\xE6\x951\xDE\t\x95\xC2}U\xC1~\x9Bn\xF6\x98\x8A\xCBP\xFA>n\xDF\xD4\xE3*\xBC,\xFD\x11\xF9\x82\xC7\xD5{iy\xDCj\xBF\xAA(lu\x85\x825\xDAt\xCF\x00\xFF-\x190Q\xD9\x8E2\xFBx5\x1F\x15.\xF7\x11\x94CQ!a\xA0\xDFE\xE6\xD1\xBE\x80i.\x03u\xF6\xC1zcT\xA6_:\xC2\x96\x1E\x15\xE7$\xC3i\"x\xD8\xCB\x7F\x02\xAC\x1B7\xCES\xE88\x94UPV\xCDS\x9Ft\x7F?\xBA[\xE2\xAF\xE8\xAA)\\\x14\r@_:\xD5\x00\xE2\xD8\x15\xAAv\xAA\x88\x8C\xFAMEY]\xD7\xC5\x9F~\xA2\xDB\":Q\xB7\xD1T4\x9B>\x98P\x95H\x8B\xDC\xBC\xDC\xC0YS\xC5Qa\xF6\x15L\xF6\x13Q(\xB6\xB7\xA5\x80\xC5\xC3\x92\x9ER\x1C(\t\xF6\x95\xA2/f\x97\xBE^/ps\xD7\xC3\xBFo\x98\r*\xAA\\\xD5\xE4\xE5\xED\x978+Z\v\xD5\x1Dn*\xA0\xA1d\x1AJ\xF9\xD5\xC9\xAAl\x90N\x19\xF67\x1E\x99\xA7\xC4\xFBU\x9D/\xDC\xC4\xB7J\xAD!G\xBA\xB8\xC8\xBB$\xF2a\xEAi\xB6\xE6\x85r6\xAA8\xBA\x0F\xFF\x96R\x84\x86/\xEE\xBE\xDE\xE1@\xCD\xB1\xF5TH,\xE4\xE7/\xD5\x1E\x1F\xCF\x81\x07\x90\x84sS\xE3\xEFz\xBC\xDF\xC7\x8EJ\x15\x96\x19\xFE\xF0\xF0W\xD3\xF3\x1B\x88\xC3\x81\xA2{\x84\x83\xC0y\xA5\xE0F\xC6\x1D\xC2?%?\x9F\xCF_\xE8-\x8E\xBES\x9B*E\xA2\x92\xB9m\x10\xD8jS\xE3\x8E\xD9\xE1\x10\xC2d\x84+\x86nB\x8F\xBB\x00\x1A\x84\xBF\x06\xC5aK\x03\xC5h\xE2e#\x14\xD1\x81\xC5EX\xAB\x19\x1A-\xC3\"0Z\xF7o+V4\xBAP\xDC0\xF1etSS)Uvu\xB9\xFB\x86\xB7C\xF8\xEBS\xA5\xB85,\xFCJ\xE2[\xE5\x1E~g\r\x9Bv\x91+\xFB\xA1\xEC\x1591r\xCAT\tPv\xBD\xD2\x93\x17\v\x04\xBAt\x83\xE2\xB4\xFA\xDC4\xBAi\x13\xFE\xA6\x8B\xFF\xA5\xA5\xCE`\x8C\xF0WWA\x89\xCE\xF3%e\x1D\xDA\xB5\x7F\xAA\xC8$yj<\xCBL\xFD\xCAI\x1E\x12\xAF\x8Eg>+\xE2\"[\xFD\xD1.\x98\xB0\xE0\xC1(l^\x90\x83u0?\x1BOqB\xEC\xB3\xA2\xC8\xAB\x7F\xCE\xC69\xDD\x9C\xB0\xF7\xAA\xE1\xC8\x05)\x99\x9F\x9A\xC4\xEF\x855!\xFF\xE1\x01\x84\x93|1u\xC1\xC6\xC5\x0E\x89\x7F\xD8@8A\xDF\xEAt\xE9!\xAA\xF9\xBB\x1F\xE1\f{\x9C)\x9A\xBD\xEFmZ!v\x18\xDC\x1DC\xCF\xFC;\xF2\xE7\xA9\xCF\xA9\xEE\xF0E\x13\x8D-\x17&Z\x04wM}K\xF3\xB85N\r\xF1\xE2\b\x9F\x8E\xA7\xE6\x85\x9D\xA7\xB4\x18\xD7'\xE2\xDB\xB0\xC9\xF7\b\\\xB4qI\xE7W\xFF1\x97\xFF\x8B\x87\x94\xFAp\n\xE1]\xCF\xEC\xC9_\x12\xAC\x17\xBB\xF4\xF90\xC9\xBF\xA6H\xFDc\x93\xFE\xE9\xE5\x05\x8Ei\x03K\xE43\xBE\x87E\x8D\"|xQ\xD0\xD3?\xE3g\x0Fz\xFAG\xFA;\x1B\x00-:\xBFA\x97\xF2\x1F\x9C,\x97\x7F\xF1\xDB\x15\xF6;$\xFFi\xF9\xB9\xC3\x1F[\xBDiR\xB7\xBB\xEB\x94LTV<akU6\xF5D\xEA\x83\x93\xA6\xF9\x0E\x94\x01W\xFE\xD9S\x16\xED\xF5\xC9\xFF\x06\x92\x7F\xDD\xD0)\xBF\xBAXngx\x07\f\x13V\x9C\xF4O\xDC\xE0[\xEC\x99\xACV&\\\xF9o\xA4\xBA\xB7M\x054F;c\xD1\x07|\xF2\x9F\xE6\x1A\x86\xAF\xB8\x9B\xE9\xEF\xB2x|\x91\x12\xB7\xD4$\xF7\xD74\x88~\x9AK!\xE4\x9F\xF4\xCF~(C\x82\xF1\xC8\xDD\xFB\x15\xD6\x99|N\xC97s\xFC\xE9\xD2\r\n\xC5\x1F\xBA\xF2\xDF6I\xF2o\x11\xA9E$\xDE\xD2\x88\x90\xFF\xCA\xC3\xD0r~\xF9\xDF\x7F\xCD\x85z`\xEA\xD4d\xBD\xA2\xB3e\xBBF\xF8\xDB\xB8\xD6\xC3\x7F\x15T\xAB\x1C\x7F\xA1\xFFG\xBE\x97\xD0\x87\xFD\xF8kB\xFF\x8FZ\xFA\x8E'V\xA43\x8B?\xD8\xE8C\xA0\x17J\xE4\xEB\xFD\x96\xB9\x9Ak\x18\x81\x7FK\x11\xB1\xA8\xE5\xD3\xFF\xF7\xD3\xB7\xABb:\x100\x18\xBC\xC1\x04\xD3l\x1E\xFEl\x98F\x8F\xD1H\x18\xB2\xDBT\xBB\xD6\xC5\xFF6\xAA{\xA8\x03k\xA2\x9DMQ\xC13\xFC\x91\x9C\xD7\x96\xEA\xC2k\xD9@O\xB0\x11\x8F\xCFS\xE2\v\xE2\xBBkM1)\x10\xFE\xA9\xA5rf\x91\xFAg\x04\xC0\x96\x02\x9AJ\x9DF\x9A\xE1\x7F8\x9A\xDF\xC6\xF1\xA7K7*T}F&i\xD1W\xAB\x12\xFF\x88\xC4\xDFy\xFCt\x8E\xFB\x07\x98\xFE?\xE5\xE1\x7F\xE8\xD8\xC1\xAF\x90\xFC\x7F%@\xF8\x93B\xBB\xD5\xC4\xC8\x91\xF9\xB7\xEA\xD8b\x02\x81(\xC3? 8\x90;\x8A@@\xE8\xFF\xD6G\xAD[\xD7Z\xEC\x04PMX*>\xDBmc\x8Bju\xEF^;r{f\x8B\xE4w\xA8\xDA\xAC\x85\xC0\x8A\x91;&\xFB\xDE\xB2\xD8\x99\xB2P\xE0\xAD:\xB6-\x91\xF8\x07\f\x04\x12\x14\x07\x18\xDF\xCE\x907\xA8\x03\xFB\x11X\x88\xE0B\xDE\xB1\xBE#\xEC1\xBD-\xE0\xF0*\xB4\x94f_\xAA\xAF\x80\xD6\xC7\xBA\x97\xEA\x06\xFE\xE2d\xE7mK\x04\xFE\xFF\x915\xB2\x9E'\xE7\xD9B\xE7\xDEN\x04\xDD\xEDk\xE3\x8B\x02\xA9\xC5#\xE6\n[\f\x8D\xD2\xD4'x\x8C\xE2\x16\x13=:\x15\xCC\xA5\x18\xEF\x1BMt\xEF\xEC\xFC\xF5\xED\x1A\x02\xF9\x13'\x9D\x07\xB2p=\xB0\xB7\x9D\xCC\xF4\xF9\xE4\xBF\xF5g\x93\xA4\x7F\xBA\\\xFB\xE7\xF9\xF1\xC8\xA7\x9C\xC4\x0ENB;\x1C\xE9\xF7\xF4Oi\xF7i\xC3F\x1D\xDE1\x1E&\xFCi,?\xD0\xA1\x06\xA2=:\xEE3)0R]\xEF\xE2\x7F\x8F\xED\x85?*\x88\xF7\xAC5\x10\x98/6\x17\x04%\xFE\xC1\xC9{l\x13\x81\xCC}-N9\xFE]\xAAj\xA9\x95\x97\x10p\x10  B\xC6\xAD:z\x02\x83\xE5\xF8k\b\xC6{L\xA0&\xC5\xE0\n\xD5#\x10C\xE0\x05\xD61\x13\xBC\xBA\xC1\xAD\x01c\x8B\x04Ml\x81\xA1\xDC\xD7\x07(z{{\x11j\xB0\xF3\xB6%B\xFF<W\x00\x02\xF7\x00\xD8\x96\x15\xF8\xF3]\x18\xB7\xADM\xA9\x81\xF8H\xD8\xE1\x06\xE7]:\xAF\x11\xFCm\x17\xFF\xFFT\xE4\xF8?\xC1\x13\x86t\xEF\xEC$\xD9\x18S\x03\xF9|7\\\x0F\xECm\x81L\xD2\xF4\xD9?m\\\xFE\xBB|\xF3o\xE4\xCFE\xB5p\x13\xE1\\\xEBq\xCF\xFE\xF9\xAB\xFCA\xCB\xC4\x82\x1D\t+\x99#\xFC\xD9\x84r \x82\xA9\x8F\xA3/\xEA\xC4\x9C\xD7\xC4\x81\"j\xC4>\xAC\xFD6\x10\x92\x9B\xD4*'^Z\xA7\xA2\x86\xCD\x07\x7F\xC3>\xEF\x07\xF0\xD76^Ba\xFF\xC3\x93}\xC72\xFBu13\xFE7\x9D<,5\x19589U\xD2\x10\xD2P#\xF0\xFF\x1B\x13CI\x89\x7F\x8D\x81\x9A\x04j4\x84\xD2/2\xE4\r\xD6\x81\xD0\x04jb\b%\xF9\xD5\xA7\xC6,2\xDB\x8C\x9FP\x03/1%\x10\x90?\x8F\x1F\xA0F^\xD415\x96y\xF9\x9A\xB5\x9Eo\x9D.\xF7B7^\xA2\xBEgI\xE1\xBF\xB4.>\xF5q|\xAA\xF8\x8E\xF0\xD7\xE8\xE4v\xA9Y\xFF7\xF2m^\xA7}\x04!\xA1\xFF_z\xFE\xDE\xBE\x7F\xD0\x10\xCAO\x8D\xE5\x05\xEBN\xF2\xFF\x93\x10\xE1/woI\xFD\xAF\xB9\xF8G\x97\xC6\x06\x0FD%u\x1F}'\xEB\xD5\xEE\xCF\x1D;\xDD\xAF\xC3\x88[O5G\xAD\xAC\x98P\x9E\x06\xEAB\xF1!\x8E\x7FHA\xE5\xB7\x11\x12\xF8g\x19\xCE\xD27W\xD2\xB2I\x95\x9D >W\xF9\x8B\xA1\x86\x8DY\xFB\x1D5\x94\xD9\xBFX\xCC\x8CY\x93\xF0\x0F\xCD\x07\xDE\xA9\xAB\x9C`\xF8\x87\xE2\x1C\xFF\xA7\x81\xA1\xA4\\7\x85\f\x84\x12\xF4m\x9A\x9C&\xC6~.W\xA1f\x84\x06x\xE3u\xC4\xDE?\x1D2\xF6\xE9\xD2o\xE5\x86s\x85\xE2\r\xD4HNG](\x93m\x16z\xE9\x00\xBB:{\xBD_\x17\x8E\xDD\x17\xB8\xED\x97\x8C\xD7\x85\xE2\xF5\x95\x89:\xFE\x96\xE3\x1F\xDA\xC5\x9DS\xCF\xE9\xC8\xB1\xB7y\x84\x86\xC9\xD8\xC3P^1vi\b-\xAF\v\xE5c\xBA'\xFF\xCF\x862\x7F\xEA\xB3\xFF\xCD6\x15Z\x0E\xD5\v\\\xFC\xAD\xA5\xD6`\"'\xE5\x7Fx\xD1Cn\b:^\xC8\xE7U`dY\\U\xA2VQL(\r\xC0\x8A\xB4e\x98\x88\x99T\xDE\xB7v\xAD[\xCC\xD7?\xFF\xAA\x8AF\xF6\x0F\x83}1;S\xE1'\x18\xD1\x84\xFE`BU2\xFAz!\x81l\xBES\xFA\xA1D:W'V\xA4\xC9} \n\xF52\xFB'\x96\x93\xFB\v\x14\v\xCA\x03\xF4\xADJS\xBF\x11\xE3\xF8+Ia\xFF\x9BX\x91^I&\x87\xC5\x05\"\xC6c\xFB\xC5\xCF\xE3\xC2\xFE\xD7\xB1\"}\xB5\x1E\x17}^*\x8B\x11\xC7t\xE1\xA3_\f1\xFF\xAEH\xC7\xBF\xFE\xE8Z\xAE\xFF\r\x9D\xCF\xBF\x03\rre\xC1\xE6\xDF\xCA\x07\xA0\xD8d\xEC1\xFB\x7F\xA4G\x83\x92X\x91\x96\xF6?\xF5\xAAQ\xF9\xD1\xDB\xDD\x9E\xFC\xB7\xBDV\x8B\xEA}\xA8\xE9q\xED\x1F\xEB\xFB\xE9\x97[\xD6J\xD7\xED\xDA\xEE\x81}.\xFE\xCF\x84\\\xFBs\x95\xBB%\xBF\x01\x18\xE9Y\xC8\xAC\xA0n\xBE\xDA2\xCB\xF1\x17\xF3\xEFU\x95\x13\r\xC3W\xF1\xAD\xE8\xCBt\x81?[6\x9EY\xDBtf\xEDT\xC9i\xB0\x85\x04.g]\xDD\t%\xF2\xC8\xB2\xB5#\xDF#\xF7\x99X\xFF:\x8B\x81\x96\xE8\xB0\x0F\xFF\xB7iu\xB6\x90n\xD92\x9D\xE3_\xB9\x9B\x8Ft\x99\x8E\x91\xEF\x1D\xE1\xF8\xF3UR\xCC\x1F\x9F\xA3\xA4\x04\xFE\x05\x8C\xF4t7\xA4\xFD\xEB/\xF6:\xD6-\x1C+:_a\r\xA7FzR#\xDD&\xAF\x90\xDET\xA4o\xF9\"\x8E\x8CUz\xABp\xBBz\xA4\x1BM\xA5\xFA\xABX\xDF\x12#=;c\xBA\xB7\xFEj)\xCD\xC5\xFF\xCF\x1Ds\xC7\xDC1w\xFCN\x1F\xDA\xFFE\x1D\xF8\xB2)\xA3\x02e\x99\xF9U?U^!X\xFD\n\xC9\xAE\xAB3[(\xCB\xB1\xAF\xCA\xAF\"\xFF\x1F<\x17\x9C\xCC\xD7fkGd\xC5\xA9p\xED\x01\xEFs\x8B\xA7|\xF0\xB3%\x15\xD38|jy\x9E/\xF2N\xFA&L_S<&?2\xADK\xEAt\xB7HY\n\xA3\xA6R\xCA\xB2g\x19R\x94\xCC\x95\x96q/\x88\xE5\v6\xADGZ\xBCL\x95g\x97\x8A\xD4I\x11n-p\xD3\xAE\x81l\x86(m\xD2\xBC?\xBD\xA9A\x89q\xAB@\x8C\x82Zh95\x01\xC5\x11=W\xD8\xEF\x1A\xA3\x16'\xA2\xC5\xCE\\\xE5zw\xB5\xECu\xB5\x88\x96\xE1\xEB\xFD='v\xE8lYI\x06%\"\n\x16+\x11\xE9\x86\x00*\x1D\xCA8d7\x95\"\xC2JL;_\xEA.wg\xE89:\x81\x17&Sju\xDBW\x89\x80\x19\xCC\xB5\x8B\x99Y\x15\x99\xC7\f-\xCF:j*\t\xFC\x97\v\xAB2b\xA4\x1D\xD9\xFF\xF8\x9Fz?_YV\xDA@\x89\xF8\x1B7\xA2f\xC3l\"\xB5\xB8\xC4\xEEu\xD4\xF6\xB2Cr\xAE\xD2\xD7Nt)\x1F\x9DtRp\xD3\xAE\xA5\xC4l\xCE\xC5\xA7\xD8by]\xC9n*\xE5\xB9\xBD'\xA2@\xA9\x85X\x83\x06EF\xCBPv\x8E\xC6\xE8}\x02+%\xC3\xFB\xEF\x1A\x87^W\x19n\x9E\x046D\xE3l\xB5\xC2\x00L\xF9\xF0O\xB96\xAA\xE1\xDD\xCD$\x94U\bN\x18Q\xA7\x91`\xFF\xA2\x14i\xD0]\xDBUk)e\xD8\xD5\xC3\x87\x89>\xBD\xE7\x8B\xA2\x17\xC9C\v\xC6{hY\x91\xEA\x1Bv\xDC\x8E\xB5\x14\xC1\xD0\x0E;_\x14!XM\xC5\x99*\xA5\xC5\xD5+\x9D6\xB7\xDC\xC0\xB0\xE5\x0F\r\x82r\xB5\xBF\xF1O[\xCC\xA9\xD9\xCAQ]$\x1A\xFC\xC2\xC3\x93e\xF2\x1F\xC6\x05\xF7}8:>\xAE\xBB\xD6\xECy\x1D|!q\x9E(\xF7\x8B\rThu\x0F\xCE\x87\xEF\xE2\xBF\x1D\x90qP\x17\x80\x89\x86\b\xC2)\x99c?Eu\x046\x89\x02\xBBa\xE2\x03\xA5\xB3\x00a/\xAD\xE7\xE7&\xCEK\x87\x02\x80\xCF\xC6SPo\xA2\f<\xBE\x078\x1CG\x98\xE4?l}\xE6\xE6\x86\xAA\xA7\\\xAC\xAAv\xB1%\xCD\xB3L4\xECI}\xE9\xC5\x12;\xE7\xF6d\x106\xA0h\xF4\x13\xB3\xC1\xF6\xF6\xAA3}\xB1\xC7\x99\xD0Y\xCB\xF3\xD8\xB5\xC4\xBD\xBE\x00L\x8D\xA7\xA1Z\xBA\r\xC1\xEA\x87#vK\x1Eaz\x8A\xEB\x13\x0F\xC8\x87\xF2+T\xF8\xD8+p\x1C\xDE;\xE1s\x93\x1A\xB9T\xFFlI\xCA\xAE\xA1Jy-\xA3C\xE5\xF2oy%*\x94\xDB\xBF\xC6\xB5\x04%\x13k0\xC5\xD6\x9Eh\x94IH3\xED\xBE\xCF\xA7u\xAE\x7Fb\xB6+\xFFl\x99yM\xB6\b%\xAE\xDB\xDEbP\x8FwI\xB9\x8D\x94\x89\xBD\xE2\xED\xCD_\xAA\xA3\xA5\x94*\x93\x7F\f\xD2\x02y\xB2\\\xFE5.\xD8\x86\xF74]B\xD5\x10\x82NS\xA9\x97?\xBF\xF7\x0EG\xBF&\xE4?\x01e~3\xD3\x1B\x16\x82W\xD1OR\xF7\x16\xCA\xE4\xBFo8\xC2\x1D\x94\x8B\x98\xBA\xF3\xCB\x7F/\xD4\xD1/\x8A\xAE\xFEq\x9E\x8A\xE6\xE5S|]\xBB\x14\nvZ\x99\xFC\xA7\x9A|\xA9b[J\x1Bgu\x1C\xF7P\xA5\xE0\xE6!\x0F\x7F\x83\xE1\x9F6\xBCL\xD1\xF9\x06\x85'\xF7\x10\xED\vj\x9D\xD6\xEF\r\x14\x11\xFAxiSKI\xE0/\xB6\xD1)NS\x11\xB1\x96\xC3^\x15`R\xD7QeP\"\xEF\x94\xA9\xFD\xA0\xE9\x9F)\x97F;}\xF8\xA7H\xF98P|\xD5Z\x95\xB8\xBC\x8F\x89\xA6\xA2\xDB\xDAz\xD4\xAD\x84\x8A\x06E(\xC9\xA1\\\xF4?\n\xFC\x93P\x9C\xE6\\\x86\xDD\xA3P\x9E~b\re\xCB\xF4\xBF\xB1\xB3W\xA7\x96\xFD\xFA\xDF\xB0\xB1\xA4\x07\xA8\xFCv>\xEB\xEA\x9F\xCC<\xD6\x19>\x8B\xBD\xFD\x80[\xB1\x85\xEEX\x83\x87[\xDC\xB7\xDD\x1E[\x96l\xEC+\xCC\x82\xFF\x7F\xDA\xC7\xD0\xD8\xF6\xDCd\xD9<\x1E\x90\x05j\xD9\xEB\xE8\xF6\x93\xF4\xA4\x07\x86xqU\x9E\x97\xA6g'\xEBaO[\x88=\xB9;Gn\r,\x03eh_$~\x85n\x1B\xDF\x1F\xCAp\xBE\x9D\xD3\xBF\x00\xB6\x9F\x1C\x14\x05[\x03\n?M\xE2\xEF\t\xFC\xF7\x8A\xD8~\xD2{{\xC7I\xAA\xD5\x120\x10\xF0\xE1\x1FHq\x87\x02\x02\xCE\x96,d.\xFD$\xAA~\x81\xE0dO\xC0\xE1\xFD\x8F\xEDt\xB2\xFC\xF2\xC1\x9D\b\xEC\xED\xDB\x97a\xD7U4\xF2GXS\xC5\xB2\xAC\xF8S\xA7\x16\x10\xC3\x9C\x9A:\xD9\x8B\x80\xE0\x06\xFB\x8A\xE8\x0E\x00\xB5k\xF3Y\b\xAFJ\xC0Y\x14\xC8I\x0FE\xC2\xC5X\xDF\xD9+\x18o\xD9\xC3;|\x80\xDF\xB6\xE4\xC9Y\xE5?\xBF\xCF!\xEA\xDB\xBBUL\x81\x04,_;\xB7\xFF \xC0S\x97\\\xCF\xDB\xE7\xF8\xDF\xBAd#\x80\xFBZ\xC6\x98\x90\x04\xAD[\x83\xDBx\x1A|\x1E\xDD\x8A\x80\xD3mc\xDB\xB3\v\x10\x88K\xFC\xD9\x88z\xD6vq\x8F\x80\xC4_\xE2\x1C\xF2\xB0\xED6\xB1u\x89'\xFF=\x81\x14\xD3\xDE\x81\xA1\xB2\xC2\xC4A]\xDC\xBB@\x84\xF0\xA7\xAF\x82\x97P\x15\x01\xAC\xEDc1\xDE\xFFEG\xA4=\x16\xB8\x1E\x01g\xDB\xBEW\xD8M\xAC8\xF7'4F\x15\xE8\xF1\x89\xA8\xB1\xCBa\b\x07#\xC6N\xCB\xC5\x7F\xAB\x89;N:\bN\xBEX\x90\xF8\x073j \x8F \x8D\"\xE8\xB8\xB1\xCB_\x9CR\xB9|J\xDC\xE2[|8\xEF\xCF\xE7\xEAf\xC3\xFF\xF9<E\x89\xFB\xEC\xCF:\x8AU~\xC9\x8B[\xCE?\xF3\xC3\x94\xA0\x7F\x89\x9B\xE5\xD1\xEF\x7F\xBB\x8EAt\xE8\x03\xDA:1f\xBD<\xB6_0\xF0\xFC\xC6\x85\xF4\x97\x8B\xC8\x1FrP\x13\x7F\x99\x7FR\xC3\xC4uh\xDD*\xD4\xF0D(t\xC5\x1Ai\xBD\x87nr;\xF0\xD76\x0E}\xEC\xC9\xFF\xCB\x1Fk\xC0;.\xD3.\xCF_\x82\x9A\x14o\x81\xB5\xCF}y\xA1$\xAA\xD8<\xBB\xBFY\xF4\xFF\xCEu)\xD9\x9F\x11\x84\xE6\xE7\x93\xBF@M\x17*\"C6P\xE3\x04};\xB9\x98\xA8\x1F[\x90\xA7}F}\xC7\x1C\xD4\xDC-\xAE\x9E\xC5K\xD7D\xF8\xFC{P4\xE5L\x8D\xE5\x11\xA2j5!o\xD7\x8F\xBE+\xE6\xDF\x1A\x86\x9A\xD4\xCB\xBE\xC6\xF77GW\xCCf\xFF\xE7\b\x7F\xD7\x15\xC2\xA9T\x84\x16\x0E\xB9\xF8\xD7\\\xF7l\x92\x84!\xC4\xE4\xFF\xE5\xA2\xD8\xDA\x96\xDD\x95dx.6h\xA3\x80\xF54\x11\xEF\xCF\x17!\xEEr(\x95\xB5\xF1|\xF6\x1D\x84R\xA2)\x02|h\x97\x81\x109\xA4\xC8/\x80\x90\xE4\xBA}\xBA\xFD\xB9\"\x0E4{\xE9\xEE\xF3\xCD\x0E*\x13\bm*\xC7\x7FB\xFA\b\x1Cf\xF8\x866J\xFC\xAF\x05\xDE\xD9\xDF\x1C{\x8E\xEF\x10\xD9\x15\x97\xFDI t]>\x99a\x0FZE\xE6yv\xCB\xA0\x160\xE4\x93\xFF:\xA5\x97\x89V(\xF3h3D\xE6\"rv<7\xD6\x05u\xF4\x07\x05\xB9\x97'tm]\xE8\x12BT\xF4*\x14s+\xC8\xFE\xE0\xD8^6@o\xCFHdH\xF7\xCF\xBF\xF1\x91\xD9\x12\xA1\xEBQ\x86\x7FL\xBAB8\x95\n\xC5\xF0\xCD\xBF\xD1oD\x13\xEE\x02J\x97N\xEA\xC5\x94v\xCF\xF8\xEA\xBF\x02\xB9\x03\x1A\xC8c\x1E\xE3\xB7\x8Ff\x1F\xDD\xA6f\x15Q,FP\xF4i\v\xCA\x9D\xF4V)\xB7\xFF\x07\xFD\x06\xD8\xD2\xA8\x97*'\x1A\xD5\xC8\xC5\xD0-&Y\xD9+\xE9#\x8843c\x9E6M(\x8FB\xEDBe\"\x16M\xF2\x8BV*q\xD9\x9F\x95P:u6\xFF\x0EB\xE9\x8C\x91\x8D\xA7\xCAP\x07!x\xE9\x95l\x86U~\xF4u\xD6\xC9\xA4g\xFFD3\xE5\xF3o\xD7\x8AtZtX\xB9\xEE\xEBR\xAA\xF39\xA6\x8A\x9A\xBC\nG\x8E\xE1\xC3_\x8F\xAF\x9FU\xFF\xEB\xC3d\x7F\x9EY[6\xFF*\xC3~\xFB\xB3A\xA1{\xAD\xB0\x19V/\xC0\xA0ieY\xF4^v\xB9\x0F\x98\xC2\x1B\xE9Y\xDFrb7\xEF\xAD\xB8\xCBJmK\x11\xB1\xBB\xD6rC\xC8\xC5\x7F\xD9\xF7\xFAQ\xB9\xD3g\xFF\xB8\xF6\xE7+\x9E\xC1cci\xCFN\xDF\nQc\xCB\xFC\xCA']\xDE@\x86\xEA\t;\x96\xE2@\x8E\xD0\xEB'P\x95A\xED\xDA\x96\xD2N\x83\xBA\xD1\xAB\xA4d\x7F\x8E@\xF9\xF1\xE2\xA8\x03\xE5G\xA8\xBDZg?I\xAB4\x1CO\xF0z~A\xF8GFz\xD2l\xB9\xED\xAD\x7F\xAFE\xEDZ\xC3\x96\xF8WfFzv\xA2\xF2:z\xFD\xB6+\xD5z\xFA\x01\x00+\xBB\xBD\xF5o\xD3\\\xFD\xDF\xB9c\xEE\x98;\xE6\x8E\xDF\xED\xA3B\xE4\xCF\x91\xC5e\xA0U\xC8x\xD0\xF2I9\xE1{\x1D\x03l\x9E\xD5\xE72\x8E\x03kVg\xC1\xCCC\x95!\xF4\xBA\xCD\xC3\xFE\xA7\x97\xF7%\x9E<+\xD9r\xAB\x82\xD3\xFB\xA2\x98\xAF\xE9\xED\x1Dp\xA9\xFF\xF2\xEA\xBA\xAA\xF7m\xE4\n9\x88\xE6]\xB6\xABT\xCC\xB7\xC2s1D\x90\x80\r\xD5,\xF7\x0E\x98\x91Y.Q\x01\xE9\v\xD0.\xE3CI\x00F\x03\xA7\xEE\xE9/\x8FYmP\xB4h\x9CY \x86g\xE7\xF4./%\x84\xF9\xA4\\h)\xC5\xA0\xECn\x8CGD\x9C9\x1D\xAB8\xF3\\ K\x80\x93BJ\xCA_\xB7W\xD8l~\xA2Cq\fE\x87z\x14\xCAi\xDDFc)\xD2RD\x832\x11\xF5\x85\x1F4\xC6{\xA1\f5\xF0\xC0\x15\xC5jP\x1C(\x03\x8B\xD3\x13\x00\x1Au\xBB\x01\xE5\xFE\bY\x11\x80\xB82\xB6\bmt\x03\f$\xE5.\x19\xEF^\xBF\xC9z\xA3.\x9C\x05_\xF5\r\x99\x99p\xC3\x19\xF2&p\x8E\x91\xD9\x81\x7FXJ4(\xD7\x1B6m\x04p\x89\xA0\xB4\xA8\x1FQF\xE3W\\m\x14\xD1^\x8A@\x11aO\xCB=\xBB]\x87\xB2\x89x?\xA3\xA5\xC4\x03!\x1C\xB9E\xC2i)9\xD18\xB3\x99\x9B\xBC\xF3\xAD\xE6g\x9C\x98\xC8!\xD3\x1Cc\xA6\xDA\xA5\xA5\xD1\xBBZ\x8A\x9E\x17\x89\x1B`K\xF9\xEEZa@Zef9\xC7\xC7\xFF\xBC(iv]u\x13\x94\xD8\x17E4F\x9D\xE6,ZJVKI0\f\rE\xF6\x16\xCA\xFE\x96\xD2\x04\xBF_\xAD%\x13\xCA\xD9\xEB\xD3\xECall\xBF@1\xCC\xCER_\x9B\xBC\xFA\x9B\x1B\xB7\xDF\xB2Xv\xA0\xD2\xE1\xC8\xC7<\xCE\xDF[V\xFC\xB9\xC9\xCEo4\x11\xCBzC&\"\x91\xF6P\x04yz\xF6\xFB\x01\\\x8A:KKq\x19a\x12\x91\v(>\xDE^\xBF$ |\xAE5\x8B\xEF\xAEv\\\x10\xAE\xF3\x1Aw\xA0t\x92K\xC8\x99h!\xAA\xBF#&\x82\xDB\xC3\xB8tH\xFBl<\xE6\xC6\xBASS\xBD\xCE\xD9\x84XM\x87\x93S\xE3y\x84\x93\xE3\xE3\xE9\xCFu/\xDD\xC4Yj|\xCA$&\x9C\x92\x96\xA0~R\xF0\xF9\xBEc\xCA/\xFFa\xE7\xE2!\x1D\xF5I\xD4\x1Fn\xB01\xD5\x12\xB9\x94\xC5\xF9\xFA\xF4\x05\x99\xBA\xE1s\xE0\xD3\x0E\va\xE7|\xCB\x00\xE7\xF3G\xF7\xDC\x8D\xF0\xC0\xE8!\xCA\xE4\xF0\xE1\x82I\x1D\xA8W\xA6|\xF8;\xD4\rwO\xC1\xE7\xCB\xE5\x8E\xE9z\xFD\x82)\xBF\xA2\x11\xF1\x94\xD4Bxl6\xF0\xDF\x14$\x8D\xCFO\x00>=NcQG \xD3w,\x1EO|\xDA\xE2\x9C\x07>\xD7\xE1\xA6c:\xB7\x87\xBB-F.\xF8\xA5\xABjS1\x8BO7dx\x06'\xD67\xD7\xFE\x0F\xA7\xA9\xC4p\x12ac9\xD1\xE9<Q<\xA9\x8ETsz\x95\x91>[V\nV\xB1\x9As\x1B\xC5\xC3\xA5\xECZ\x1A\xCDCIF\xE3+\x97\xEA\x88\xCE\x90\x7F\x12\fb\xEC\x95\x81\xDF&\xFF\xB9\xE5\xB9\x14\xD4'\xA1$\xEE-\xA0\xB1\xC4D\xB4\xE5\xC4$w\x9F\x81615\x0E;\xA8\x884\xC4\x85\x80\x19\xE9(\x94]F\x8E\xA1\xDA\xD8v\x8E?\xB0~\xF9\x8FR7\f\xF9\f\xB6\xC4\xFB]\x91\x8B\xBAa\xE7B\xFE\x7F\xE3MW&5n\xE2\x1A\xBDL\xFE\x1B\x99\xFC\xF7\"p\x18\xB2\x84G>\xEA4\x94\xE22\xE0\xCA\xE7\x06\xA5\xEEE\xFD\xA3\v\xBE\xD7\x92\xC5wY\v\x7F' \xD2g\xCA\x7F\xAA9\x17\xA7'(-\xF1\x8FGs9\xFE\xB65\xEB\xD7\xFF\x9DRs^Z\xCA\xF4O\xB2\xE5\x14\x9A\x8B>\xFCI\xB0\x97v\xD3'\\\xFF\xB3\xF6\x8D\xE9\xFA\xDF\xFF\x84*\x97\x1A\xA3\x03Pw\xA1rb(\x8B\xC6\xE8/\x1A\x80\xE6\x1C\x9A\x9F\xFB\x0E\xFF\xFE>\x13\x86b\xA1\"\xD2R\xE2\xC9\xBA\xAD\xD6\xD2\x18\x94\xB3\xAD\xB9\x17\xD9\xB5\x1A\x17\x10\xCE\xB1\xA53\xCA\x97\xD3}\xC9\xB0s\x1E\xBCN^+\xD1\xE2m\xFB\"\x87\x85O\xFFL\x11\xE7\xCF\xF4\x7Fw\x99\xFEo)\xF1j\xD4\\\xFF\f\x91\xD72\xD1@\xC1r<\xE0_.o\xE3\xA2{\xFE\xD1Uu\xC5\n\xB81\x9E\x81\"\xF2\x96\xB7z\xF8\xA7\t\x9C$\x94\xE4\xB6}\xC4\xD5\x13IKQ\xEB\xF1\xBBN\x1E\xDE\xB23\xCD+\xCCJ\xBE\x14w.\x19\x14\x05j\x03\xC9\xEF\xEF\xCB#xi\xCB\xBA\xB3w\xEB\x92w\x05\xEE\xA6\x17w\x03wu\x83\x97jE`\xA3W\xC0]\x1Ew\xFA\xDF\x04\xF2w\xDF\x9EB\xFD&\x90\x83`\xFB\x92\xCC\xF6\"\xB6\xED\x1B\xDB\xB6O\x14M\xDE^\xC0\x1D'{\x11\x9C\xECYK\x12\x18\xE8\xBDuI\x1E\x81\xC8\x96\x87\xD7\xB3\xDEV_\xA0=\x05\xD6v\x9F\xD4\xF1\xFEl\xD1\x05\xED\xBCu\xAD4\xDB\x02\x0E\xEF\xBFp^\x043\bx\xF8\xF7\xD3\xF9\xDDn\x1Aq\xE9}\xB8sI\x8A\xB5\x13\xA6\xEC\xD6\x81\x9F\xB2\xE7k\x89\xF3\x1FO\xC6\xB7\x8B\x80\x7F\xF1\x9C\n\x97D \xB5\xB5\xAC*\xE5\xE8\xF6,~}r\xD2\xAD\xA2\xBB\xCD\xC3\xD3A\xA0\x93\x81\x13Hn\xDB\xA7R\v\x8A(\x8F\x1BHu\x07r[v\x9E-\xC7\xDF\xB9s\xC9\x13\xA2\xF1`r\xEB\xEDy\x04\x92[\xAF\xC9o\xCB\xE2\xF6B\xD9\xC0\xB7\x16\xF0\xBD\x82\xA4\xDC\x03\xDFt{\xE8\x11\xB9\xC52\xFCo\v\xC4Q\x9B@\xE0\xAE\xA9\"\xB6\x9EtzXO\xF2w\x8D\xFD\x92\x7F\xFF\x82\x89\x1F\xB0[i\xDEq2\xC7\xF9\xFC\xED'\x87\x10p\xB6\x1C\xE1M\x99\xDD6\xF5\xCD\x87?\xDF\xDD@\xF7%C\xF7T\xEA\x9F\xE0\x02N\xFB\v\xE7E\xA8\v\x01O\xFF\xBC\x9A\xA5\xFB\xE8\xF7\xB9\x90\xE4\xDCq$\x8E@Z\xC8?\xF9\x98\xAC@\xE6\xB6%\xA9\x1E\x89\x95\xF0J\xEC\xA4a\x06\xCC\xB2\xAA\xC4\x15VO\x16\xE7\xD6\xCEG@\xC8\xFF6\xCFo\x15a\xF8\x07\xFA\x11H\xFD\xED\xC7\xC4\xBD'\xEF\x05\xF0\x8C\x0E\xD4h/\x1F\xCB\xBD<\x16\x13\x19T\x04_\x9A\xDE\x7F\xCD^\x91\xD9&t\xE9\xC05\x0EB\xC9\x97\xC7\xF2\xF9n\xBC\xE8R|4\xF0C&\x03\r!\x9AqBo\xB9q\xBC\xEE1\xE4\xAF\xFC\x1B\xBA\xF4\xEA\xC7)\xD4\xFE\n\xA1\xBC\xAA\xE3\xEF\x9B\xAF\xFDoE\x1Ch\xBE\xB8\xBFY\x10\xCE\xCF\x15p\xE8\xE3^\x84\x9D\x17\x9A\x0Fs>\xF9@\xF3\x19\x84\xD2\x7F\x95$\xBE\xBA\xC3\xF9\xDB,P\x13y\xDE\x87?\xAF\xA0D\xD1\xEFL\xAE\xFE\xFE\x1A\xD9\x81\x90C\x157\xF17\xF2-B\x83e\xBCbMo>\x8B\xBF\xF7\xB96(\xCE?\x85\xD0+\xC2\x83Oc\x99\x1As\x9Em6\x9F+\xE2'b\x83\x03\xF9;\xF2\xDCa\x91:P^\x95u(\x8B_\x1Es\xDC\x1D\x10\x87\xBD\x12W\xBF@\xE80B\x93\xA8\xD1r\x94\xB3\xE8\x85$3\xF9\xF6e\x81P\xF2\xE9\xD0\xE1!\xF2\x17\xFC\xC4\x97\xE3h\x7F\xF3^\x91y)\x14?4\xC6\xBA\xF7tt,\xAF{9\f\x0F\x12\xB0\x7FoR\x9C|\x88\xF2~\x84\xBE\xE9\xF6\xD0=\xCAzX\x13\xCD\xED\x8ACM\xA0\xA6\xB9\xC9\xC6\x81\xE6\xAE\x9C\x8ECc/\x1D*\t\xFDo\x98x&\xB4\x16x\xE7\xE5\x8F\xA3\x9C]?\xD0|\x1DB\xCEO\x92\f\x9C\x17\xECwr\x05 \xD4\xFB\x82\xCF\xA6z\x81\xFA\x937\x05\\\xCF7K\xF9\x0F]\xFB\f\xDD\x9AC\xAE\xC7\xD9\xE72\xF8\xFF\xB1>7\xE7\xB3\xBE\x94\x805\x7F\xCC\x04\xE0\x98A7\x82< d\xC5\xD7\x852\xCF\x8E\x1D\xDEo\xF3\xB4\x87B\xFEs\xC7\xF8%\xA2\x87\xCAX\xCDw^\xCDb\xE31\x15\xA1\xFB\xF8\xFBg\xFC\xF9\xD6j\x16 \xD4\x8FP\xCA\xC8q\xEE\xFD^1A+\xBB\x1A\x14\xDBH\xC7\xCA\xED\x9Ft,\x9AY\"\xD9\xFBX\xD4B\xE5\xD5\xD1\xE8\v\xD7\xF9\xEC\x9Fo\xF2\xF9\xD7\x06\xC5)\xD1\xA7\x95\xC7<\x0E_\x1E\xD7\xF9\xF1W\x9A\x8Dx\nj\x16J\xECzf\xABg\f\x1DK\xA3c\xB1\xE8\xA0g\xFF\xC4'Q\x990\xA2Q\xCE\xAE/\xED1\xA1\xA4\x97D\x19\xFE\x8B\x1FL\x18\xC4\t7\x98\xD3\xD7_\r\xD2\x06\xF8\xEA\xB0k\xFFtq\xCBG\x98(l\xEE\xF3\x96\xCA\xA3\xDD\x802\xD2\x9C\x15\xA9\x81xh\x01\x99\x85\x06\x94W\xC46I\xB2%V<\xE84+9\xDD\xE6\xF3\xAF!\x03H,\x11\x8D\xE0\x1Fje\xC2(\xE0\xBBq\xCB\x9D\x7F\xA3e\xF6\x8FAa\x1B\xDA\xCA\xD2J\x00\xCBz\x02\x9C\xC0\x87\xB2\xB0\xA5\xE44\xD1\x82\xE2\xAB\xBE\xF3c=O\n\xFAZ\xF9\r\xB3\x8E\x14m\xD9\xB0\x16\xED\xF6\xEC\x19~#\x96w\xE3\xFAnw\xFDumYX\x14\xEFj\xD9\xFA\xF7\xD2\xCAh\x1CUWC\xB9\xF3\xF5\"\xA2=\x11\xA3\x80\xA5=\xF9\x96\xD2\x8F\xF9\xF7\xCB\xBA\xF1\x8D\xA8\x8A\xDA\xB5M\xA5U\x9C]\xA7\xF5\xAFc\xD0\xAAj\xD9]k\x97R<\xD8\x92\xEE\xE9\xF8/\xEF\x16.\x89\xA5n\\JeF\xF8&\x84\xFD\xB9\xD3o\x1B\x93_\xE3\xDEV\x7F\xCCU\xE5\xEFS\x9C\xBF\xC3\xCE\xE4\xDB$\x95ar\x04\xA4\xBFVZ\xD5RD\xAC(>aW\xC9\xA5\xF9p\x1A\xFC\xF2_\xBBv\x99\x8D\xCE\xE82(\xC2\x06[\xA2\xFB#\xF4\x8E@\x99\x9Ci\x9F\xCF\x1Ds\xC7\xDC1w\xCC\x1D\xBF;\x87\xEAc\xEC}\xA1\xEC\xA8@\xA4j:\xBD\xAF\x01F\x85G\xEF\x9B\xEA\xF4\xC0\x15\xE2\xB0m]1\xCBk\n\xDB\xC0?\xAB\n@\xE4\n'W\xCC\xEE\xBF\x80?\xFD\xFElN\x87\xB2\xB7J\xF9'\x15\xF4\xDB\x8A\xF23\x85\x97\xE1\x9F\xE7\xC2(?\xAD\xEC\xE4\xCA\xC2?\xEB\x97\tS26@s\xBAW\xC6$\xFC\xB4A\xA1\xEA\x90<\x8F\r\xA7\xB3J\x1A\x14\xC3M\x8E\x01\xC54\xD2Nyd\xA9\xD1R@s.\xCA\xCC<\xC5s\xD9,g\xEDL\xBA\xB4\xB0\xA4m\xAF\x12v\xE6\xB0\f\xA9V:\xA1\xF4.\xB7\xE1E\xCB+^\xCAM\xD7\xBA\xF3\x82We0|L\xD8\xC6\xE7 \xC3\xFE\xBDs$\x07\xCB?I\xB2\xCBy(E)\x8C\xB3\xC15K\xDC\v)\x13\xAE\xAD\"\xE8\xE5i\x87\xD2\xEB\xEDP\x00\x96\x97\xF6\x92\xBBa\xC8\x7FJt\x1A\xDF\xE5\x1BEK\xE9l\xD9\xEA[\xE2\xFFiI3d(Kk\xC9i4\xB9\xB1\x14\xE3Fl\x8CnD\xD3\xB0\x9B6'\xD5R\xCA\xB9\xC6'\xFF$f\xA2\xA5t\xA1\xA5X\x06\xB5\xC1\xDE\x9A~\xCE\x9C\x9C>\xA3\x92\xBF\x92y2\x95A(\x03\x9C\xC3\xF7\x1C%\xE5\xDC\x1A|N\x1F(\x9D\x9C\xF2Z\xEE?Yq\x96\xEA\xF2\x8E\xC8\xB4\xC3.\xF3?UD,\xEAu\xEC\xDFf\xE1\x99\x9D\xB2\xC3\xAD<{\x89t\x1C4\xE7\x06f\xC3\xBF\xCB/`\xCD\x14+\xBEt\xF1\x03\xD3\xC8\xC6\xE6\x19\xFEA~\xAD\x06\xB9(\x10e\xD1\xEA\xC5\xDB\xE6=\xAB$\xCF\xFF\xA3\xD2\xF2\xCCTQ\x84\xC7#\xCC\xD6\x83_\xBCm l\\\xEC\x90\xCFfx\xEF\xE8\x9EK\xFE\xA2\x03\b\x1F\x9D*\xE0B\xC7\xF2\v&\x10\xF6Dw*\v\x84'?@YJ\xD8\xA9\xF1\xFD\xF2\x85\xECL\xF8\x16\x84\x9DK\x04\x9D\xE0\xD2\xC3+\xDD\xF3\xDD\x80\xFC\xCF<\xD9N\xF1$\xDE2\xFC\x9EV\x9Aac\xAA\xE8\xEF\x92X%q\xE6?i\xE2\xB3q/\xA0\xEEL\x01\xA3n\xA8\x7FXDv}\xA8\xFB\xFAY\x1F\xFDl\xFB\xE1Y\xF0\x0F\xF7\xFA\xC7\xE2P\x9B\xFF\xE7\xED\xB7\xFC\xA7|\xAEc\xE6\xC6\x8A\xCFE~lO\xFE\x9F\xD2\x81J\x91X\xE0\x8F\x86\xF3R\xFE\x17,]\xED\xD0*\x8F\x18T\xBA_\xCDq\x07J\xAA\xC9\x97\xF5\xAB\xB54\xE8\x92\xFF\xAE\xFCG\xE3\xD3\xE5\x9F3\xDB$W\x9E\xCC\\\x93\x13\xED4zid\x06\xA1d\xB8\x13P.T\x9D\x99\xDC\xB5_\xFE\xAF\xA1K\xB7\xE8\xD3\xE5\xDFs\nh\xA2\x05~\xCA\x9F\x99\xD0}\x01\x8DM\xB6\xDC.\xED\xF3'\xAE`O\xFD^\xB7K\xCD\xB9\xFCe\xE4?\xE3\x93\x7F\x86\xE7\xB2\xD5e\xF2\x7FMa\x16\xF9\xE7jpi\xD4k\xF3\xBC\x0F\x96|n\x95x\xCC\x03C+r\x19\x82\xF1o\x19\b\x95Q\xD6\xE0p\x1CJ\xDC\x88K\xF9WbK\xA3\x17\xCB\xF1O\xB0\xC7\xB9\xA4\x103\xE0]b9\xCF\x89\xC4\xC6\xE5I\xC8mk\x85\xBC-\x8D\xFB\xD3\xB8ex\x9F\x05&\x01O_\xB91{>\xFD\x9F\xE2ZE\xB86\x02\xBC\xA4r\xBA9KK\xE0r\xFD\xCF\x1B\xFC\xB9\x8D\xE5%/\xA0nY\x81r\v\xE8\xF2\xEE\xF3\xF6\xB3r*a\xFA'\x19\x8D^N\xFF\xFB\xE726\xD8\xA6\x13o\xFBOY\xEA*F\xDF\xC1s\xA4|5\xE7\xC9\xFF\"\xD6s\xA1\xE2\xBE\xFEp^0\xE4\xA1\xA3\xB7q\xCE<\x10A@\xA4\xEE\xB9\x93\n\xED\xDDqR^7\x90\xDA~2/\x88k\xF9\xC96\xE0\xD6\xC0%J\xA7\xF3v\x19-\x1F\xC0\xDDE \xE8I\xC8=\x81\x11\xC9\x9F\xDB>b\xD6\xF9>\xB5v\x9B.\x1D%\xF2p\xE3\xDE\xFD,=\xBFtJ\x84\x7F/\xE3l\xF9\xF6\"\xEE\x9C\xA1\xFF9C\xFE\xC7\xDD\xD8\xB6\xCF\xBB\xA7\x7F\x92\xC5\xF6\x02\xFB\x07_\xC4;k?pP^b\xE3\x96\x9D\xB9Y\xF0g\x98x\x02\xB6m\xDF\x18\xC3g\xE7\xFD\xFES\xB6\x17\xF1\xFD\x19\xF2\xCF\x19\xF8\xEF\xDF^\xCE\xBE\x06\xC5\xE5\xD4\xC0a\xC9\x90G\xBE\x7F$C,\xB7C\xFF\x18Vw\x9F\x8C#\x18\xDF\xE2\xCAd\xE0\xE8\xD6%\x97\xDC{J\b$\xB6\x17q\xC7\xC9\x1FQ\xE0\xBD\x17({7{{\x96r\"y=y\xEE\x1F$2\xFBR>\xC7D\x8C\xF3\xE4\xA2\x1B5\x9E\xAE\xB8W\x8E\xE5n\xEFv;<-\x8F(\xA6\x10\xA2jA\x81\xF4\xAD~\x91\xA8\x8E\xB8h\xF0\xC1n\xDB\xE7\xF8\xA5\xB1\xC7\x96\xFDw\xE5\x81\x8DZ>l\x81\xC9;N\xCE\xA6\xFF\x03\x8E\x7Fc\xC8\xF7\xF7\xB1{\x91:Yf\x7F\xFE\x91\xE9\x13\x03\x94\x11\xF5\xDD\xC1h\x99\xF7-$\xA7\xC2\xB1\xFCK2&\xFC\xE9\x90\xF3\f(\x01K\b\b\xFD+\xF6\xDB\xE7S\b9/\x8F\xFDoI\xD2\xA6\x0E\x8DExy\x02\xC9\xAC\xA6\xF2Y\xFCM\xE8\xC2\xA1\"\xFC\xD9\xF2\x89\x10\xB6\xA8T\x8A\xF7a\xB6R\xF8\xB9^\xF8X\xD2\xA4\xA1\x04B\xFF\x9Bs\xF8?\x11\xDD\xF0\xE4\xDFew_\xF1\x88\xDC\xCE\x97It\x85\xABB\x84\xFA;\x87\x8A\xD8\xEF\xE3\xE1\xF9\xFF/I\xFB\xE7\xE0\x98'\xB7\xAF\x16\xF1WY\x19\x99_\xD3\xEBA\xE4\xF634\xF8\xC2\xAE\xD9\xE4?\x94\x17Q\xEE\x9CWof\xF2\xFF\xEC\xBA2M\xF5\xAC\xE9\xABqP>\x8ACc\xD3vU\x88\xFE\x86B\xF9\xE7\xC4d\xB4\xF2@\xB3\xC5\x8B\xFB\xD0?\xF6P\x1E\x1C\xD3\x10\x8Ad\x9B\xD7\xBBpe\x89\x03?\xE0y\nX\xE7\x0F\x8Du\xBAY}\x84w\xC0\x14E\"\xB8_C\xEAL!\xDB\xCF\xE7\xDD\xAD.\xDB\x10Zv\x90\x80\x92\xDD\xF0\xE4\xDF\x8D\x99?\xE8\x15nH\xF1\xA0\xFA\x17M\xB8.\x12\x846\xE6u\xF868\x88\xFD\v\xBC\xC1:`(\xE9\xE9\xFFg\x80\\\x81\xD2%\xC1+\xB6Br\"\xFB\x19\x9A|yl6\xF9g\x98x\xF2\xFF|~\x17\xE1s\xED4\xA8_\x9C!\xFF\xBC\x1Ap>\xEFy\xC6W\xB0\xC5\x91\xF0\xD1\x7F-]\x90\x86G\xD7\xD2\xE8\xFD\xDF\xD0\xC9Y\xCC\xE6\xFAZi\xFF\x1B\xCD\xB9]\xEElk\xF0\xA4\x82\x9E\xFD\x9F_^@4N\xCEz\xC5[\xFF~\x93\x96\x184){c\x8F*\x87\xA5\xF1 ;\xA3\xF4C9\xE6\xC5\xF0\x94\xDB\xFF\xEE\xFC\xEB\x9B\xEE;\xB9-\x14\xCD\xFA\x16P\x95\xD65Y\xEFd7\xC9!\xFFd\x85\x8D\xE6\x9C\xA7\x18\x1BM,\xF3\xA2\xF7{}\xEB/\x89\xBF2\xDFH\x0F\xCE6\xFF\xE6\xFD\xDE\x8D\xE6\x1CS\xE0_\x8Fw\xF9Oi\xCE\xFA\x90q\xD1\xE6y\x14s\x9E]M\xBB*\xC4\\Y\xF8\xDE*\xC9\x90gZN\xEC\xA4\x9E\\\x05\xE5En\x0F\xD0\xFAw\xB8\xF9\xC4B\xCF\xFC \xDB`\x99\x176\x90\xFFw:\x96E\x7FC;U\x97\xB9\x97X\xCC\xEE\xE3\x1F\xAF,\x12\xF1\xEEZb\xAF\xAB\xD2\x10u\x17t\x7F\t\xE5Zn\xCCH\x9B\xF0\xC8\xCC\xF5\x97gT(\"\xAA\xEA\xABe\xF6\xE77c\xDD\xDE\xC9n\x92C\xFE\xC9H7\xBE\xE6\xB3g\xBE\xA1c1\xA4\xB1T)\xFA\xD6\xC4\x837\xE4\xFA\xABi\xF6\xF5\xAF\xE3\xF7n\\\x93;\xCDn\xF1\xEB\x19\xFF)\xAD\xC5Y\xD6\xBF\xFF\x86\x1B\xCC\xA5#s\xC4\xD7\xDC1w\xCC\x1Ds\xC7\xDC\xE1\x12\xD7\xFE\xD8\xFB\xE9Yk\x14\r\xC8\xEA^\xDE\xFB\xE99#d8\xA4\x1EUtz\xAD\xBB\x9F\x88\xBFjVV\x12\xA0\x93U=\xEA\x9D@\xE7(:(\x9B\xB4\"\xAE\xEB\xF6\xC6\xF4\xFD\xF5_Xw;\xAF\xF0\x13\xEC\x19\xE4\xBF=KZ~e\xBAO!\x02$Bv\xD9\x19e\x83,/\x1B \xD2\x15\xA9\x11ez\xC33\xB7C\x98\x15\xFF\f'\xC2\xF2\xD2/\x84Mhz&\x93E\x8D\xB5z]\xDA\x0F\xE5 \xC3\xBF\x82\xD7p\xCCNkDD\x8D\xAB\xC5\xB8\xA2'\x99\xE5 \xE1\xA53\xA3\xE1,\xAAu^\x85\xB7\x93\x8A\xCCB\xD5\xBF)V\xCD:\xFB\x07\xA0\xBE\xC8\xF0\x0F;Q\x98\x7F\xCA\xAE.\x13\xB3\x90a\xA3*\xBD\x94\xAD\xD7\xB9\xE1\rG\xAC\xAA\xC2\xFA\xB9\x02\x10\x8E\xFC\x1F\x9B\xB2\xB2\x84\xCD\x8B{\xE6\xBB\xF9I8\xF9s\xCE\xF6\x02\xB9?\x93\xD6\x88\x9B\xC2\xE5<\x95\x14\xFC<\x1CA}r\xEC\xE9s_\xBC~?\xC2?eK\xB1\xE1\xEB\x17\xB3\x96\x7F\xBAz\x98\x9C\x14\xCA\xF5_p\x8E\xA2r\x12\x95\x13\\\xB0T5\x12\x07\xE2\x88Q\xF6\x86\x95\x97\xC3\xFFk&P\xC9\xB1\xB9l\xB4Cs\xEE/g\x9AL<\xA4\xAA\xD1#r7\xA1\xF2R\xEB\xD1\x14\x02\x14\r\xA2\xAD\x9A\xD6\xC8\x0FE\x91\xA9U?\x1C?\xFCE\x11P\x0F\v\xF4*\xD8\x99\x97\xB4\xC3\x1C\xB4\xE7\x89\x1C~\x90\x90\xE4\xE9\xF4\xA1\x1Df\xFF\xD8\xB0W!\xEC\xA80\xA3\xB8\xBF\x82\x99\xAC\xBD\x8A\xEF\xB1lJ\x9B\t\x1BP\xDF:g\xDA<\xE3\n\xD4U\x1D\xECo\xCA2a\xE9\xF4\xA2\xDF)\xAB<\xAD:\x1DEt\xC8!X\xF2F\xDC ?\xE9\x18ev~[\xBF\x83\xAAK7>\x1DI\xAFO@c\x8B\x91\xCE\x8E\xA1K&\xA0\r\xFD\xE5\x1F\x90\xF1\x1F\x1EJ\x8Be\x91\x05Ek=1II!\x9C8\xF0\xC0\xF6\xFDLPy\x8DguF\x81\xC2\xB0\xF3\x9A\x0E\xD4\xF2F\xEC\xCB\xE1\xEF\x9C\x15\xF2?\x96\xC5\x05y\x96(F\xEC1\x1E/\xA0\xFE\xA0auBm&^\xA5y\xFAC-2{\x8F]\xCA5'\xB3\x80\xD6,\x96Ea\xB66\xFF\xC3\xF1<\xAA\x9A\xF9\xEA\xBE3K\x1CB\xA8\xD9qO\b\xD3z\xA7~\x1BBy\x86\xBFB\x8F\xADb\xD6\xFA8\x04#\xEC0\xF9\xAFz\xE2\xF1\xA2\x8B\x7F\xB4\x8D\xFD\xEDL\xE8\x1C\xFF\xF8\r\xA3\x11\xA8\xBE\xE5\x92j\x986\xDC*\r.\xEC\xEB\xE5'm*\xBBn\xDCJCM$v\xCC\xCF$\x12\b\x0F\xF14\xF5Q\xC2\x7FW\x82Z\xAB2^\xF1\xF0\x1F0I\xA3\xA9\x9A\x11\xEF\xC6\xEA]\xFBI\xFE\x1F%A\x1A\x9E\xE1\x1F\x8Dl.\x00*w\x85L^^\xFE\xF3\xEE\xD2\xA6\xE9r\xF2\x1FJB\xC9[fF\xE0_7\x1D\x7F\xB1\xBFCi\x8E?\xDB\xFC@\x16\b\xCBZ\x03\x15\xEC\xCC\xAEX\x9E\xDF\x88\xB1,.eyy\xCA\xB1\x1C?A\xCB\x03\xD4ZM\x1E\xF5c*\xCC\\\x0Fi\x1E\xC5\x14[\xC8\x89\x1E\x9F*j\xED6{j&\xCCIT\xD2/\x83\xF1\x1F\xB0\xBF\x9D\xF7\x14\xF0'\xEC\x81J\xDF\xF7p\nA\xDF\"(h\xFC\xA7\"~ 5\xA5[\xCC\xFBO$\x83\xDDw\x8A\xE9\x9F?9\x95B\xD0\xE9+\xCD\x7F\xB7#\tm\xC8\x93\xFF\xF0\xD0\xFF\xFE\x83}\x1C\xFF\xBC\x87\x7Fb\xF3?L\xB0\xDF\x1E\xB7\xFE\xB3\x8D{\x9B_!E\xCD\xF9\xEA\x853\xF1\xDF\xAA\x03U\x96\xDF\xBF3\x8B\xFE?\xE1\xB8\xFA\xFF\xBEr\xF9_\x95\xF5\x11Y\x95\x87-{\x10\xC11\xBA\x1D\xD3\xF1OHa\xEE\xDD\x9Fg\xF2\xAF4\x8B'\xA2\xEE\x18\xD3\xB1-yT\xB1i!D\xE03\xF9\xAFj\x9E\x14?\xC9#|\x8C?;P\x927\x14\xCC\xFF\xBE\xC7\x89PN{\xB1\x85\xBC\x9A\xE9O\xE5\x06\xE7\x96\x02P\xF5\xCB=\x1F\xA8P\t\x96\xEA\xB5\x8F\xD1\xB7\x8F\x03{\xD9\x8B{\xF7>\x12A\xB5\xAFO\xD5NF\xC7\x93ry\xFE\xB8\x94\xA5A)\xFF{\xA9d\xC2\xB7\x97\x0E\"4\x94__?t\xE7n\x84\xD9\xCA\xB4\xBF{\xED\xA3\xDD@\xF5\x92G9\x83\x19>\xF2\xD3n\tB\xD8\x99\x1F\x1F`\xF2_w)\x0E\xBC6\xF6\x02\x93\xFF G\xAD8S\xFF\xFC\x0F\x13\"\xAF\xCB\xE5\xF5\xFF\xD6%].\xC7\xBE]\x02~\x96\x1A\xDB\xEA\x11\xB9\xF3\x11H\xAA\x88@%gAh\xFA\xB6\xBE~QQZ\xDB\xB8\xE7\xE8\xFD\f\xBD\x81\t\xFEIu\x82\xC2\xB15\x84\x8F\xB2\x87\xD0\xC6\x84\r\x9BI\xF2\xD1\xAC-\xC3*B\xBC\xCD\xFD\b\x9E\xB6\x94\xDE\x1CL\x86\xBF\x92\x10\xA6\x8B\x16g\xF26\x1A\xBA+\v\x04\xF2\x13K\xFA\xA1\x12aU\x8D\xA7\x8A\f\xFF\xBD\x02\xFF\xCE\xC7?rP\xED\x9B\x98\xAA\xF1_\x8B\x18\x94\x125\xA8O\xBF\x11\x8F\xBF\xC90\xB9\xF9\xCD\x14j^\xFA\xEF&\xB2a\xB1\x85R\x0F\xDBTS\xD2\x9E\xA0\xE9\x18![\xA6n\x1F\x80\xAA\xCD\x8F\xD3\xF3\xF8\x91\x12\x07\xB4\xF0~\xA2\x81\x88\xBB\b\xD7OGVK\x7F\x8B\xC9U\xD7\x95\xED\x9F\xED'\xC53{\x97-\xD4\x0Ew\x95\xB2\xAFL\x9F\xFC\x07.\x85\\\xFC\xEBfl\xAB\xE4]\f\x1E\xDDk\x0F$xZo\x1F\xFE?\b\x1FEU\x82o\x11\xD5\xE9\x16\xA0N\xFB\xA9\xC8\xFFv\xD4\xC3\xBFv\xC0R\xCC\x9C\x92\xF8\x0E\x9BjEAv\xD40s\xA9-8\x96d\x1F\x0E\xB4\x14\x13\xEC)b\xF7:\xC5FW\xE5l,\xE0f65\xDC\xBB\xF1\xA1\xF9\xA8\xF2\xD9\x9BU\xB8E\xC7f\x89\xF6\xCD\xC5rS\r\xE8Z\xC3\x06\xFEGkF\x10\xD8\xB7\xED\x8E\x89\xFFyz\x92\xCF5\x9F\x9Dv\x82\xEC\xCE\xF66\x15\x17\xF0\v}Qt\xF1\x1F\xE0\xC5.\x8D=\xEF\xC5\x81\xAA\xD0~Jc\xC4\xE3%\xCE\xCD\x80v\xF26SV\xB8\b\x1F\xBE\x1C\xFE\xF9\xE7\x05\xF5\xF7r\x11\xCF\x99>\xBF\x00\xB0\xDFs\xA4v\xA2\xE6`H\x8D\x89\tN\x9B\xCE\n~\xCE\xCF\xAC\xEB\xFAr\xC3\xE0\x97&\x10\xA2\xBF\xEC\x93\xF7\x00|kW\x17/\xF6\xFD\x91\x89/M\xA2\xAC\x83\xEF\x1D\x90\\\xAB\xD8\r\x17\xBE\x88\xE0{\f\xFF\xAA\xA3T\x9F\xB7 \xE5\x9F\xCDk\x7Ff\xF5S\x05k\xBDQ\x8F\xA1\x82\xAF\x17\xA2|\vj\x93\xD8\xF3\xD5\xD9\x90^P\x9E\x8B#\xD5\xAC\v\xCA\xD1\xCF\xA0\xBA6\x1E\x8F\xE5x|\xB8\x17\x95/\xFD\xBB6-\x13\xB3\xA01\xAB9\xDA\x14\xBDWg\xFA\xFFR\vu\xAC&*8ju\x00Z\xC2\xB0\x06H\xFE\xBB\xE2@gr\xFF\x7FvK\v\x05g\x14\xE8\f\xDAo\xEA@\x80\xE6_\xF5\xB2\xAB\x00\x9Ej\x89W-o1}~\x01^_X\xC8\xFF1\x84.\xCESc\x02ym\xC1\xB4F\x1E\xE1?\xAC\xEA\x9A\x97\x1C\xAC \xFCEdx5\xBB\xFB\xF7>\xD2\xC5\xEB\xB1\x1E0\xD1`\xD2\xCD\xAAZ\xF0\x89)\x9D\\\xA2T\xEB\x02\xA8\x83\f\x7F=B\xF8\xD7\x8AM\xC7\xA4\xFF\xDF\xD95\xF4_\x99\xFE\xBF\xFE'z\x04\x15<\"\xDD\xA0\xEDf1]\xE7\xF8\xDF\x1B\x1D^X\x9E\x8B2~\x8Do\x93\x9A\x17\xC1\"\x9F\xF1h:C\x7F-(C\xCDm\x91t\x87\xB0\x7F\xEE]ct2\xFB\xC7\x88rgw\x15M\xC7\x02\x7F\xCD\xB0\xD8\x83l\xFD\x97\xAE\xB8\x8E\xC1f\xAE\x7F\xD2\x97\x93\xFF\xD5l\x1C\x16\xCAc?\xA6\x1D_\xED\x11_\x196\x96\x17|~\x01\xFF.\x00-\reH\x1F\xB0\xA0\xF1\x8A`\xD1i\x8D\xEC\xE2\x12RUj^\x9E\xEBdhH\x99\xA9\xEEa\x8F\xFC\x86\x1E\xD4\xB1\x1F\x8E\xE9\xE8\xD4\x91fVAT\xFA\xCDK\b\xF1*W9\xA89K1_\xD1\xBB7\xB1\xAF\xEE1\\\xD3\vx)\x9Fg`U\xEB\xCFvwC\xA1\xAB\xAB\v\x99\xED\xA1Zf\x81\xDB\x9F\xEA\xFA\xA1;\xA1\xFA\xE4_e\x9Az\xB5\x14{\xD7\x10mw?y\x88\r\xBC\xD1\xEA\x85\x9AOf\x8B\xE7\x07VB{\x82\t\xC9#\v\xFF\xC2\x06\xAAV6<H\xC2V\xBDp\x87\xED\xCD\xBF}Tl\xBD\xEF\xA3\xAE[t,<\xF4J\\\x97\xF8\xCF\xB4p\xC2i\x93u,}e\xF9_\x1A\x8D\xB8\x12\xD2\xA8\xFB\xFC\x02\xC0Jo\xFDu;\x94\xDF\x14\xB6\xA6y!]\xF9\xD7w\xA7Ei\xE0\xE8H\xC3\xF0\xA3TNK\xD4\xDA\b\xB33\xEF\xD3\x87Q\xC5$\xE5*\x1D\x8F\xEAtrpX\xFC\xA4&\xCEKE\xB0y68<5\xEE\xBC~\xCA.\xB2\x13\xEC)_\xB5\xB2\xBF\xD8\x9Ai%\xB7\xE6\xE7A\x1B\xB5|\rx\xF2\t\x1D\xA8N\xEF\x01\x1E.\x02\xDAB\xFB\x91\x9D\xD0|F\xA0\x96\xDAS\xC4\x8F\xE5\x10\x1E\x95CKK\x19{\xEA4\x1Bx\xFB\xD2\x9D\xA8\xB9\xF0j\xCB\xD5\xF5[\x8F\xA0\xF2v\x00K\xB6\x9E\xDC\xD9\rhG\x9C\xBB\xE9F\x07n\x97\xBBw)#\x81}-\x1Bh\xF8G'\x8A\x18\xB77\xD0\xD4\xC0\x1F\xBA\xD4\fhS\xADE\xE9M\xF0U\xEF\x9A;\xE6\x8E\xB9c\xEE\x98;\xE6\x8E\xE9>\x80iD\xB72\x83\x00W\xA0_\xA6\x05^\x88\xA7\x9C\x04\xD1fM\xEE\xA7\xCCrMq\xB5+\xC4\xF9\x97\xBF\xB5g=G\x91\xAFU/\xDB\x7F\xA4\xE2\xB2\f|\xA4\x9C\xD4\xE7\x8B\xB6\b\xBD\x8D\xCCp\x13\x98\x15\xBF\x1D3\xB3b6\xA7\x81*\xDA\xBC\"\xFE^`\xDFU\bNBM\xFD\xBF\xC3\xDF\x8Dq\v\x17\xB0\xA8\xA8\xA93H\xF1\xB0\xED\xC7\x9F\xD9\x06\x8B\x98\t\xA1\xF7\xBD\xE6\xF8\xF1\x0F\x16\x11.\x02\xEA9\x8E\xC0\xA2\x02\xB3.\xDA|\xF8\x13\xE9\xDB\x8DB-\xD4\xDE65\"\xF1w\\\xFCo\x18\xD5g\xE0\x7F\x7F\xB08\x1D@\xFADwc\x1E\xAA\x10\t\x17\xF5p1\xA2\xE0z\xC0\xE9(\xA2\xDA\xE4_\xD9\x15\xFE\xB4T\x15GE\xFF+\x1C\xA0\x1E\xA8\xF5\xE1/\xFA\x10\x1E\x8DP\x9F\x1D\x95\x1BNW<\xA6l\xDF\xC8U\x15j\xDC\xB3\x9D*}k\x87J\xA7\xF52\xE9\x13\x19\xD4>\xB8\x07L\xD8\x03\x9A:\xE3n\r\xD8\xC4\xFF\xB3\x87#\xC2\xFEq\xEBY\xD3U-\xB2\xAB\x80\x1D.\xA1\xA4\xD3k\x8A\xEA\xD9\x01\xF4'\xBC\x12\xDB{\x98\xB59i\xB3%\xD2\xC2=\xDA9(hP\"{\xA8\xCD\x07O\x8B\xF3\x1F\x1E\xEFiP\xF4\x1Dt\x95\x1D2\n\x1AZ\xA2,\xD9{\xB5#\xF2?T;\xEE\x93\xFA\xD4\xD1\xC8#\xB1x:\x16Ik*\xB4tL\xC7#\t\xE2g*'\xD2@\xDA#\x04\x12\xD0\x1Chy\x1A\xC59\xF6\x8F[\xBC\xA7u\xB6V\xA2\xE7s\x80\f\xFB\xC6Dz\xEA\xB43K\x1E\xACi,\x84\x8B\xBF\xAAs\xFCM\xD7\r\xA9\x96I\xF9\xE5\xCA\x95\\\xA4\x8D\xCF\xD7\xCB\xAF\x13&\xCC~mj\xC66\x9C\x84\x8D\xB8X\xCEG\xF8\xAA$N4\x8E\xAAF\xD6\x99B\xC2\xB9\xBB\xA4M\xE2\xBF\xB9\b\xAB\xDFt\xA9\x836\xB6|\xA3\x9D;*\x12j\x04\n\x16\x95\f\xBE\xAA\xDAD\xF7\x9B\x9D\xDF\xD0U\xA1\xA4:\xD8\x134\xD8\xE6\xAE}\xD4\x84\xE5\xC7\x9F>g\x9FT)l\xC8t\xAC\xB1\x9Cv#\x1D7\x9C\xD5\xA3\x16T\x86\x7F\xBB\xC5\x93\xD8k\x1DEA\v\xF3\xA6\xA8\xFFy1\n\xBE\tJM\xB77:|\xC1\xD5QD\x82b\x8D\x96\x1AiM\xCD\xF0\x07\xF9\n\xC7+E\x1F\xFE\xC1I\x84S\x9B\xD9\x1A\x90\x98\xA5\xAA\t\x1F\xA95\xB1\xF92\x9E\x9C\xAF\x10\xBA\xEEn,\xCD\x04lg\xA6\xFE\xD7l\xC8\x87\"\xC3\x9FJ\xD2?\xD6T1Ro\x92\xCE\x91\xBD\xA8\x90\x01\xFC\x15\f\xEF^&\xAB4\xFC\n\x1D\xA8\xB8_\xA3\x1A\xA6\x1A\"\xD0\x1C[\xB3\xAA9'd\xAE\xE2\xE7k\xD1\xC4C\xA7\xF3\xF4a\xC6\xA7\x7F\x92\xE5\xCF\xA3\xD4?\x15\n \xF6\xE3,*d\xAAuG\xD5#\n\x93\x8B\xF4\x0F\xB3XT\x14\xF2\xAF\xE9\xBE\xBDfB\xFF\xE4\x81.z\xC1\xBF\xB8T-\xA9f\xA6\x7FN\xEB\xF40:\xADv\x06\x98\x7Fe\xFC\x1F,\x93\x7F\x9D=_\xFF\x97\xC7\xEF1\xE5\xBE\xF1\xD3r\xFDc\xCDxZ\x1E\xB5e-\f-\xC3\xF5O?{m\xA9Z\xE4/\xCD\x19\xFA\x87\x8A\x0E\xEF\x00\x1E:j\xB9^\xE9\x1D:\xA0a/\xFBk\xED9\x1D\x81\x1A\xBB\xA1\xDFy\x84\xDA\xCC$\xE2\xFC\xFC\x81\xB7\x8E\xAC1\x9A\xD9\x87\xD5\x91GN\xBB\xFAg\xF7\xC3~\xE5\xA9I\xFD\xA3\x99\xDC\xF3\x02\xE0\xCF\xB5\xCC#1\f\x1C\x8D\xA4\xB544'\x99\x95\xFAG\xD1\x06tI\xB33\xDD\xA5\x91\xE6\xC9\xD3(\x1C\xB1\xD1C\xDB\xB5\xE7\xA8\xC5Il\xD6\x07#\x06\xE0\x86\xA3\x03\xF3\xB4\f\xAA\xDF\xBB2z\x8E\xA7\xFF\x1D\x8E?y\x16\xC8k\x16\xF4\xF9\xCE\x82\x93}\x97\xD9\xD9\xD7\xC8\xEEz\xF7\xEF\xC9\xB7\xED\x05\xA6\x7F\x96\xCCxX\x92\xAEO\x90=\x95\x8E\xD8*\xA9Z\xF7Y\x91\xA4O\xFF\xDC\xC0]\xB7\x84\x7F\xDCF\xC2\xF2\xF0g\x9FWMnf\x7F\xAD\xC4C\x0E\xD4\x98j\xA3\x8D.\xD4I\xA7\xAD&_\xF8W\x8Cf\xA6\x94\xD4H\xBB[9ZEY\xB1!W\xFF\xA8\xEBE\x9E\x19\xE0F5\xD31\nS\x8D\xC4U\x1Bj,\x99\x95\xFA\xA7r\"\xA1S\xB2>\xA1\x074\xD6y\xA1\x7F\x14A\xCB\xAB!\xD6O\x8A\xF4h\x03\x12F\x82\xBC\x9C\x03S\xA3\x19\xA8\xDF\xBE2\xFEV\xD1\xD7\xAB\xA0\x03-\x05w\x02\xF0g\xB2R\x86\xDA/3\x01P\x81\x8C\x8D_q\x85\x8BMBZ\xD5l\xFA\xA7\xC2,\xD3?d\x81\xF4\xFF\x9E\x1D\t\x15<\xFBG\xE8\x1F\xF6\x80C\xB1\x112\x07!s{T\xF0\x00\x04\x13\xA8\x88kv\x04\x88\x19v\x8C\x7F\xB5\xA8\xC0\x1E\xA6*\x1B\xE17&\x1B\xF5$i\xB3k\xAB\xE1:%'gnV\xA5\xAB\xDF#j\xA22e\xE8T\xEBN\xB0\xE8\x84\x8B) V\x93E\xB5\xC9\xFD\xB3V\xB8\x88\xAF\xB8\xF8W\xBCC&\xE5\xDB\xD4\x88\nP\x9A&<\x102-`\x1F\xD3\x04\xCC~{\x87z\xEB\xE8;\x1C`\xE3\x95\xF1\xEF\xB3}\xF8\xAB\x11h\x16\xC3\xBF\x92\x90\xAF\xBC\xE8\xF7t\xF5]\x06\x7FJ\xA4\x960\xEC2\xFCk\xEDY\xE6_\xD3.\xC3\x9Fir\xF5h#\"I\xCC\xC0\x9FB\x91-\x13\xDF\"\xFC\x1B<\xFBSe\x97\xAB\x8A'\xFA#PbFZ\xE0?\x9F\\!\xED&TKm*e\xE8L\xA5\xFD\xFFa\xEF\xED\xC3\xE3(\xAF|\xC1_\x97\xAA\xA5\xEA\x96\xACn\xEB\x9A\x8Bw\x92\xE0R\xD3F-\xC1X\x84e\xF6zs\x19\xBB\xD4\x94p\xAB1\xC8Vd \\\xB0\x14\x96L\x80\xC9&\xDCLv7\xE3\xABH\xE5\xA6m\xB7\x84\xC7\x92;\"8\x19\xC6n+\xED 7\f&L&\xC9\xF2d\xE4\xC61`|\x19\xCC\xF0d\xE6f\xB3\x19(\v\x19d%\xB1\x89\xAF\x13\x14\xD3\x94\xF6y\xBF\xEA\xA3\xBBe\x92\xE7\xFE\xB5\xCF\xA8\x1E?rwu}\xBC\xEF\xAFN\x9D\xF7\xBC\xBFs\xDEsl\xFCe\xDDc\x0F\xCBk\xD9\x8D\xE8\xEB\xC2\xF5\x7F\xA7\x9A\r\xA8)YM)j\x1Cr\xAC-\x87@\x91\x86\xCB\x86\x1EPT\xDCa\xE3/\xF7\xD0\x177\x05\xBFE\xFD2\xBB\x19\x06\x9B\xB5\x04s\xCF\xF9\x80D\xE4Fj3\xA4\xB7ha\xC8\xFB>B\xFE\x1D\xFC\x15\x07\x7F\x1Cg\x0Eh\x97\xFE\xB9\xB8\x98\xFC\x13E*\xEB\xB6\xC2\x8F\xA9PS\xCA\x8D\x15\x07'rB\xC9HYf\xDE\xC4\xC8\x89k\xF5T8\xA1:\xEB|\xA3\xEC\xB3\xFC\x12\xC3\x7FSJ\xB1\xED\x7FJ\xFB\xCB\xD4\xFE\xD16\xA5c\xC4\xAA\xC9\xC7X\xB8\x85\x14!\x87mV\x11\xDDU\xD2\xA3M\xD4A#w\xD9k\xE5\xE4D\xD4\x83\x7F\xAF\xC8\xD7\xA7\xB1z\xB8\x04\xFFH\xB65\x92\x8AFR\xB1H\x1Cr[BE\x8C\x96\xAA\x87oSLu\xAD*\x97{\xA8;>E\xC5u\f\xFE \x1B\xFE7\xA5\x12L\xFF4\x13\xFDCp\xEB\x90\xD2\xBB#1O`FU\xFCm\xAA_>\x01\xF9$\xEA\xE2\xE4\xF5b\x9E\x0E\x9F\x8B\xED\x97&\xB6\xA8\x8B\xCF\xBF\x94\xB8m`'T\xA2\xFF\x8FW\x1C<\x96\x03\x0F\xF5&\xFA?\xCC}\xFD\xCA\xF1\xF4\xFD\xE1\x8CZa\x7FR[zD\xC5#:\x91\xA5\x94!^4Y\xCA\x90\xB3\xF4\xB1\x8C\x0E%\x99\x98L\xB2\xF6\xC7\xA3\xDC\xFE\xBF9-k1\x16\xA0\xB2rX\xFE\x86x'\xD7&<\xF6\x7FV\xE8\xFF\xB8m\x7F\x0EG\xB3]\xD1\x94\x1EM%\xA2q(\xC9\x8C\x8A\x04#\xF0\xA5DB\xC5n\xB7CP\xFE\x16\x19\x02\x940\x02\xFDd8\xA6\x1E\x87Gt\x05\x81\b\x13\x95L\xECS\xA41r\xEA\nYG\xE0#\xEC\x1F\xCB\xA1\xFAk\xC9?|\x99\xE0\xCF|\xF7\xD2}.\x94\xB3C\x8B\xE0\xFFq\xF2\xA4\x8A\x1F\x17_GM<\x92Q\x1A*\x0E\x1B3\xB9\xAE\xA4f\x03\x85\xCB\x00\xEA\xA5\x8F\x07\xACQ\x13\xA3\xA2\x19\xBB\xD8g\x85<\xAB\xBD*v\xC7\x8E\x11\xDB\x89N\xD2\xF7\x11\x8BE\"g)7\x19\xC3)(;\xC7\x1E\xDC\xB3\x8F\xCD\xBF\xCEZ\f\xFF'>_\xF2\x9D\xD8H\xE7_&\xE3\xF9)\xE0/e\xDC\x8D\xA7w\xA7wY\x07\x857\xFC\xBB'\xAC\xD1Yk\xD7\xAC5:;\x88\xC0\x9EL?F\x99\xF9\xD4\xF0\xD2\xA8\x89\xAF\xDB\xB6G`?\x94i\"\x1E\x04\xFF\xAB\xA0(l\xFE\xB5\xBB\x95\xC7\x00\x90\xBE\xCCN\x93\xC6(\x17\xEE\x7F%\x85\xC0\xF5K\x1C\xD7\xD2\xB6\xB4-mK\xDB\xD2\xB6\xC8\x96\xAE\xC6\x90\x87Ed\xB5\xEA\xE5\xBD\xC3\xB2\xE1&\xF5\fb\xEE\x97s\xF5\xE12v}q\xE2\xDA9E\xB0\xD0\x8AT\xE5Xc1\"\xB7\x8A\xE3\xC0\xE7\xA4\xF1\xF9\xC8\xECC\xD5\\\f\xEE\x9D\xCC\xF0L\x88=\x86\x9DJH\xA9h\x8F\xE2\xBD\x8E\\\xEEb\b\xCB\x8B\x1B\xA1<M\xB12\xB6\x8A\xDB!,\xB8O\xA3\x13C\x17\xFEd\xD2\x12\x96]\xEB\x1D\x02\xAA\xC0_f|\xF8M\xBE\xA2\x98`\x1A\x91\xCBv}'\x99\x13\x15\xBD\xF8\x93[%$>\x8Bt\xF1\xDB0BE\x9B\xCC\xB4Y\x11\v~\xCBG\xE7Q\xA1\xE3\xD1O\x98lNe\x01\x94\x13\xF0Y\x1F\x85?\xA7\xCB\xE8\x91\xFCv\x0E\xFErvX\xDD\xD9`\xBA\xF0'\xF7\xDD\xEF\xC6\x9F\x85\xB8\x07\x8AlF\t\xA5\x88:\x83\\\xA7f\xFB%\x96\xE2\x89^Y\xA5sy\xAB\x03a\xB9y\x91XhE\xC9\xB0Y\x80<\xCE,m(c\xF4\xDF\x00y\x12v:Y\x85V+\x0EXi\x9717\x1C\xDB\x03\x85\x18\x90\xC3\x11P><\xBE_\x10\xEC\x99\xE1\xCB&ZT\xF6e4\x8C\xBA8\xF9\x03&\r\xECT\x12\xA3E\f\xAB0\xC4M\xC8\xDD\x14\xCB\xE8\xB2\xD7\xAB\x8A\xB7UIA\xC20\xCD\xB0i\xA4Ji\x8D:,\x98e\xC8\xC4\x91^s\xF1\x06d\xF8\xB2kz<\xE3\xF1\xD8\xF1\xE4\xAF\xDC\xDB\x93\xD8\xF7H\x80\xD1k\x89\x1D\x1A\xBD\xAF2M[Hv\x8E\x9E\xB5b\x82od\xC1i\xC3*\xF9<\xA2!\x9D\x88\x1C0)e\x17h\xA3.\x86\x02\x94T\xFBY\xEB\xC0\xEC\"\n\xC1o\xF10f\x7FS\x9C\xE1/[\xF4\x1F\xE9\xE9\xA6\xA8\x98\x05\xCBM\x90,\xF8\x9B\xFAf\x1C`\xBBV\xCF\xC1/mV\xD1\x19\x1F`|\xF8\xA6~@&\xA7l\x96/\xAB\x7F\xFC\xAF\xF7\x99\xAE\x02'~\xA9\x87\xCD\xBC\xE4\xC1\x84\x86n\x13\xF6t[\xA3\xDE\xA9\xEE\xE3vU\v!E\xE4\x8D\xCBv\xC6\x7F\x04\xA0{:F3z\xA9d\xA7\xBF$\xBA\x10\xEE\xB8\x9C\xFA\x9B\"\xED\x17L\x04\xF3#\xB0{n\xA2\xA9\xEC\xBBV\xBFw\xCFq\x9D\xE1C~\x95J\x90Sq\x8D\xD3w\x9BVK\xCC+q/\xD9C\x8C\xFC\xAD\xF4\xC4\xCD*\x12\xD1q]cla\x8C\xA8!\xB9\x00\xD9j\x96u=\xBD\x18 \xE1F\x1E\xB4o\xF1\xB7\xDE\x17\xA6\xFF\b<W\x1E\x14\xFD\xF5YP4\xF8,\xD9(\xB8\xF4O\x01>\xA9M\x85O\xD1\xD9\x8By\xA5\xC1\xD5f\xC8,]V\xFF\x8CI\x86\xA3d\x00\xABIe_3\xA1\"\x02*\xEC4t>\xF2\"\x97\xA0\x89pb\xC5\x1E\xADR\bD}\niz\xA0\xD5\nk@\x80\xDD1\xCA\x7F\x85\x15\xBA\\\xC9\xB3\f\xD7\x1E\xBE/\xDB\xFA\xC7)\xFB\xAC\xC4\x02\xEA\x98O\x1Dp\xF4\x0F\xB9\xEF\b\xD1\xCFT_\xADRKL\rP_C\x82\xBDp!\x93@\x102uYc\x11\xF1\t\xBA\xFE\xE2\x1C\x90\xDAU\xCC\xD64/\xA2\x10\x94p\x96\xE1_\x1F\x1Ea\x1F\x02a\xF2O\xB9\x9EF\xCB\x8B\xA7\xA64\x11\x1D\x18hJg\x1C\xFC\xFFf\xB2\x00\xE5B:\x87\xED\xB2N'\xB6\x83\x8F\x91#/\x91\t`\xEC\xB2\xF2\xAF\xECO\xE7\x901\x9C\xD1\x8B(1\xA2j2\x19\x8D\xEA\x1F\x1Be\xFA\x82\x1F\x98\xED-\xD7\xFFJ\n\xFE\xE8\xE8\x19\xAA\rf\xD4\xBF\xE9\xA7\x84\x95b\xF1\xA7@g\xD9\x06>B\xFFd\xC9S\xFB\xF7\xB6\xFE\xC9h\xC2\xD1)[\x86\xB2\xFF\xC0\xAC\xCE\xF4\x0F\xDDSB\xFD\x1Cm\fQ<\xE9\x18_\xE24\xA2\x02\x81\x9D\xCC\xC1\xBA\x9D\x9Ek(\x18\xC9\xB1 \xF9\x9D\xE4\xA9Q\x87BG\xC0\xDA=\xBB\x88oE\xB6z\xB8\xFE\t'\xF9\x07\xA6\x7F\x12\xF4E\xB3\x9C\xF7\xDD\xAF\xC3o\xE9i\x07\xFF[\xEF/@\xCE&s\xE8\x9Ba\xFA\x87R\xE52\x19\xA6\xFA\xCE\\V\xFF\xCB\xD9\xBB\xFA\x91p\xD8?\xE8\x06c\xFE\xB9\xFE\xD9Pt\x18!\xC8\xE3\x9B\xA2\"\x89\x84\x9Cv\xEB\x9F\x04\x8Do\xEE\x8A\x0Etj \x9AGN\xC1\xCF\x96)\x8D\xC1o\xF5]F\xFE\xA9\x0F\xA2\x87\x9Cu7\xE9H\x8E;O\x05\xDD\xA7w\xCF\xBC\x11\x97\xA9\xFC\xCB?M\xA8\xD4\xA0\x91G\xBA\x8B`K\x81\xFA\xA2\\y\x12\xC4\xA8F\xBA\x9D6\xBBCE\xF7\x8C\xB5Ye\x9A-L\x9E\x1AA2\xD3=\x93\xD5\xD3\xE9\xC5\xF4O\x90\xEB\x9F\x95\xFC\x03\xB9v\x98\xAD/\xB8\xF2`\xC4eU\x0E\x00M\xABL\x97\xFEin\x03.,\xCFA2\xB8\xFE\xB9\x82t\xA1\x97\xBA\v/O=\xBDQSt\x95\x8E\"j\x8D\xBD\xCBD\t\xF8\\\x91&\nS\x8C/4UX\xCBa\xAA7\xF2\xA4\x19Wg\xC8}}Q\x11\x99\xC0\xCC\x9BhX\xFD\b\xFD\xF3'\xE4\xAC\x1B\xD8\n\x1D[\xFFP\x02|\xA0\xAB\xF9\xB9:f\xFF\xF8\xBEP\x9Fc+\xB9\xD2\xD4\xFEy\x8D@\xDBl\x05\xE8\xC3Zip\xFB'H\x99\xF3U&\x829bw\x05\xB8e\xA5PM\x98\xF1k\xD6\xAA\xD3\x8B\x18\x84r\x98\xB3\xA0\xFEX\x83i{\x99\xD7\xB2\x81\xAC7\x1Fu\x04F\xD2\x81\x15\x9A\\p\x8D\xBF'!g\xB5\x1C\xA4\xD4\x00\xED\xF2`\xAF\xC1\xF1\xEF\x9EYq\xD9\xF17\xBBQsVI@\x8E\xF9\xB9\x12\x1E\f\xD0\x81\xC0\x1D\x91\x02\x7FT\xD6+\xC6_b\x7F\x96\x94\xD5\xA4y\xA1\xD3V\x17\x1B\x7F\x91\x82|\x1F{\x97\xE1\xB7\xE2\xC6G\x8C\xBF[\x84\xFC3\xFC\xD9x\xDDE^\xC3\x91\xF6\xE9\xECF\xFE\xEE'\xC9\xAF\x92\n\x7F\x9E6\x98\xB4dK\x94\xD7\xC0j0\xC0H\xE6\x1E:\x88w\xA8\b\x1E\"\xEF\x1D\x8D\xA2\xB9\x9E\xBE\x02\xE7\x80s\xAB\xB5\xAC\xAE/j\xFF\xF0_\xFCQ\xAE\xB3\t\xFE\xBD\xECM\xBF3\xBF\xC9\xE5\xA0\x19\x80\xB4\xD2\xAD\x7F\xBA\xA2\x0FA\xBE\xD0\x97C$MYq)N\xF0\xA7\t|:\xE4\x95\x97\xD5?\x13\xBA\xE1\x8A\xA9\x90c\xAD*K\xF0\x1Eo\xD5\xD0\xEC\xCE\xBC\xA7\x92\x86E\xD31'\x02\x81?\b2\x1Fi\x9Fy\x80\x06\x1B\x84)h\x0F\x13\vM\xA6a\xED\xFE\x95\x90\xD3\x97\xC3\xDFO^\xACM\x06\xE0\xFF\x06\x00\x96\xD3\x8F\x19]Tu\xDC\xD5\xA5N\xDC\xC9\x9C3R\xA2-G\xF5\xBF\x9C\xA7\xCE&\x8B\xEA\x9F\xF1.\xFA#i3\xB5\x7Fz\ftR\x15\xD4>C\xEC\xAEV\xE6h\xF0Sg\xA5\x94\xD9p\xCC\x8A\xA7\v\x8B\x8D\xBF\xDC\xA2\x0F\xE8\x9C'W2\bd\x99\xA51\x16\xCB8a3\x8A\x0E\xF9\xA1L\xC2\xB9\xCE\xDE\xD8\xB7\xA0\xC8\x86\n}\x92F\xBC\xCB\xF1\xBC\xC6\xE5a\xBB\xF2\xC0e\xC7\xDF\x89G\f>\xDE\xD1\xAF\xC9\xA4J\x8D@9\x9E0\x88\x1C\xBA=\x02\bX7g\x84\x0FD\xD1\x1DyP\xD4D\x8C\x06\x93G\xC3\xE4\x96\xCA$iC\x80\xE6\xC0Q\xA2\b\xE8\xE9\xDC\xE2\r\xA0\xD4\xFD^\x03\x8C\xA2g\x1D\xDFK\xFF\x8ER\x8F\xC6\xE8\xCCD:\xA6\xB3'NF\x07%\x01ed\x97\xC1\xB5\xBD\xD1\xD5\x94\xA5\x0F\x97\xB4\x99\x06-\xA4h\x14\xC1v 9\x19\xDE\xCE\x1Eb\x80F\x1A\x04\xDA \x8F\xA4\xF5\xF0#\xADm\x8B\xE1\xFF,_r\x98\xE2<|}#\xF5\xF2\x937}\xEC\xCFk\x1D\xDA\\\xD9\x88\xC0\xCE\xB1Vg`\x1Dkm\x84\xB2\xD2(b\xDF\xAC\xC5\xEC\x9F<i\x0F\x91\xA8]\x81\x9D\x97\xC3?\x90z\xA2\x9F\x063\xF0\xAF{\x1E51\xDC\x0F(\x83{\xFA\xA9\x13\x01\x8EG\x00\x8A\xF2\xC4\x83\xA9r\xFBS\xB1Poe\xE8Z\xC1\xE1\x07\xAE\xFF\xBA\t\xD4_\x03e'\xF5k\xD2\xE5K\xCAu\xFB.7\xFF\x1A\x04\xF0\x8D~>[\xE4q\\\xF4\x97g\xA9k \x13K\xA5\xD9M\x95D\xA6\x9F\x1A3\x81\xE7\xF6\x89\xE3\xB7g\xAE\x7F\x9A\x82\xF6\xA8\xC9\xED\x9F\xDD*\xB1yv\x01#\x87\xAD\xED\xDC\xBF\x10\x86\xF20\xC1_9\x97>q\xD5\x13\xB3\xFDKT\xD7\xD2\xB6\xB4-mK\xDB\xD2&R\xE8\xA8\xE5\xD4\xBA\xCFN\x89\xAF\b\x06;\f\xA8\xAE2\xBB*\x8D\xA7\xF2\xCC\xA6\x03Ub\xF3\xDD\xA4z\xB8\x8C*\x0F;\xECz%\xB1\xAF\\\x86\xA5\x97(\xB5\xAB,\xD2\x1Dn\x199\xE9\xFDy#\xC3F\xE5\x8D\xB4\xB2\xE5\x03\xF0\xDE\xC5\xD5\x8C\xB4T\xEE\x19q\xA0X\x9C\xE2\xEEu-mp\x0E\xF3y\xE6\x8F%\t\xB9\x80:\xE6\xEA*\x99\xD4S\x1B{\xC0\x87 |\xF3\x80\xBA\xC1d\xF8[tzX\x02\xF2W5[\f\xFF\x0E`C\x11q\x83\xE0\xFFq\x03\xBA\xAEp\x0F\x82\xCF\xB23\xC0\xD0[gW\xB9L\x91\x80\x89\x7FG\x83o\xBB\x8B\xE8(\xBAg%ln\xB5\x96\xFA\x1DJ\x10\xB1\xF4\xAC\xFB,\xD7\x8DD\x83\xD9\x14\xEFT\xE6*\n\xAF\xCD\xB6\xE9\x02\xFFO\x98\t6\x1D\xA6\xC2\xC3g\xD0\xA1\x19z\x17i+\xE40\x8B\xD3\x93\xE81\x9F\x10\xDC\x1A\xBBcM1(\xE6\xD1z\x90\xD7k.\x91\xBB\x9Cs'\x16P\x03\xD5&U\xB4\xB3\xBD\xCCyA[r\xD3'*\xF1'\xF6|\xFA\xC0\xEC\x8F\x86c\xFB=\xA2\xA7D \xCDC\xC9\x8C\x9E\xA5\x06\x7F\xC0\x8A\x06,\x04\xAC\xA9L\x8Ar\xDDi\x04\xAC\xEC\xE1\xA6\x03gy\x15\x86(\xAD\x7F:LS.\xB4O'\xF6\x8A\x19\x84\xCD\xDBQ\xCE<\xEB^%;\xAC\"K\xAD\xFA\x98\x86f\xA5\xE4\xF6D\xD0\x86\x9D \xE6t\x86\xB4s\x84VA\x1Dee\x14\x18E?\x9B>`b\xCAk\xD8\xA7r\xE4j6\x9B\xD7.\x02Z\xC6\x0E[\bH,4\x85\xD9\x8D\xF4\x9A4\xE60\x98\x85d}\x93\x9A\x84\x07\xCEJbE\x80\xD3\xE643\xB3\x95\x14\x14\xE5Q\x93\xF2\xCC\xB4\xEF\x99\xA0+\xD7\xCA\".\x06C\xDCN85\xD4\xED\xE20\x86\x9B\x98\xCF\x96\x12z\xEE\xB6\xFB]\xF2\xEF\x8F\xC0\x7F\t\x92\f\xBF\xD5\xB1Z\xA1S\xAA\xF4\xAE\x17\xA3\x90'\xBBf\xAC[\x8B|\x1A\xB8\xF5\x90\x95H'X\f[K\x11\x11\x03[\x81\xDE\"\x9A\xA5\xB9>\x913\xC1\x9E\xC0\xD2\x04\x02\x96\xBB*\xDB\xBD*\x06i\xD4\\{\x11-\xC7\xD3e\x9C\x18\xE4$\xA5/J4\xA4-l\xD3bM\x14\xFF-zI7D\xDE\x15\xB1\xF5\xE4\x00\x7F\xD3\xAD\xE2\x8E\xDF\x14\xD3\xB7\x9E|\x82\xF1\xA5C\xA6\xB3\x14zs\x84\xD6\x9A\xAC\xBB\x00\fl\xA6\xD7\xEC=d\x89\x15\x01\x96\xFD\x06u\x9FQ\x04\xEBh\xF5j\xD8B\xA6\xC0?\x82\xBF\xA9'\xE9\xE2\x15\xE5DW5\xF9\xA7Db/\xBB\x8EN\xA6\xD8\xD6\xBDb\xA6\xE9b\xE1, -o\xB7\xEAs.\xFC1\x0E$\xE9\xEB]\xF0u\xCC\xC37\b\x94\xF4\x0E\v\xBE\xE8\xBA\x9C\x11\xD4\x18\xFD\xF5\xA3\xA6\x83M\xECU\xDDUD\x9A\xCE\xFB\x02&\xAE\xCAat6\xC1\xDFG\xDF\x94\xED%cj\xA1\x9A\xFE\x19\xC8hHkn7\x01\x13-\x96\xB2\x86\xB43D\x83\xA0\x18-\xF6w\xF4\n~5\xBD\xCAte\xC8\xA1[\x83FTGP\xDC\xB1\xBB\xC8owE\xB3\xC5\xE3\xDC\r'\x15\x8C\x9Ca\b\xEC\x87\x12\xFB\x04\x95\x7F\xA5#\"\xF4O\xAF=\x82\xACl\x9E\x17~\x04}\xB9\xC6\x16\xAA\xE4\x81\xF0\xF25\xEE\x02\xBB\x89\xAA.\x06\x82\x9F\xEF\xFB\xCC;@\x1D\x91M\"\xF6\x18\x8A\xDD_:\xC3\xDD\x95Q\x87]\xF3Y\xBA3I\xC4@)\x1C8\x1B\xA4\xEA\bW\xBE\x12\x85bML\xD2wM)A1\xF6\x1F\xB6\x187\xAEQ\xFD\xBF\xA1\x88\x8CJ\xF4O\x87\xDF\xE23h%s\xAB \x90\xD3\x06\x99\xAB\x8E\xE7*\xF4\x8FB\xF4\xFF\x86\x13.\xF9g\xE1\xF4\x81KDKL\x92\xCF)\xCA\xF51\x9Ab\x93\xC1\xF4Oi\xBB\xC8(no\xBB\x8A@\xA0\xE9Q\xD31\x06\x98\xBA\xFB\xE6\x03\t6\x8B'\xAAI\xE1zc8Z\xE2\xFAG\xB6\x98\xB6\xFCz\xEB\x1D\x00\xF6\x8A\xB4-Lo\x8C\x9EM\n?B\xE6\xEF\r\xFA\x06Q=l\xB8r\x8C\x93\xAF\xD5\x86^:\xF9\x15\xD7!'\xDE\xF2\x84\xC0\xDF\x89\xCA\xF3[\x90\xB5\xBB\xEE\xCFw\xCFxYq\xFF%\xCA\xBF\xBD\x16\xF7o\x83\x7F\x0E~+\xEA\xBF\tr\xFA\x9E|~\x13\xA7\xC1\xAD\x9E|Z\xD3I3\xC8\xE0\vtj\xB8]C\xAF\x81\xBE\x19\xA5K\xE4\fI\x8A;\xF6Q\xCF\xF8\x9D9\x8F\xFE\xE9Qy,\xB3\xAE\xBB\xF5O\xD6f\xD8\xBAg\xC8\xF9}3Y&\xCF\x00\xAE\xA4\xF0jQr\xC1\x87\xBC\xF8'\x89\xFE\x19L\n\xF9o\x15K\x064\xBF\xF0\xA2jB\xB9\x91k\xD2\xFFj\xB3\x80~/\x95\x7F}\xC7\xB7H\xABL\xC0\xFF\x0EWh*\x12\xAB\x7F\xC6\x9B\xE4o\xBA\xA3\xDF^\xAF\xA4\xC7\x83\xAE\x84o\xFEhU\x17\x03\xE9;Ueq\x83\x12D\xFE6{\x05S\xA2\xD3r\xFCw\xB0B/D\x02j\xDAk\xC5%\xE1\xDB\td\xEBN\xF7\xC2\xD7\x06\x9F\xB4p\x9A\x86\xD0\xE7\xA6\xAE\xCC\xB1\xB78\xDC\x94+5v\xC8l|\xAF3\xE1\xD7\x10\xD4\xF0\tbu\xCC\t\xFDs\xA2^\xC8?\xE5\xC9\xAD\x15.\xC4\xAE0\xF11jl\xAC2Q\xF7\x82U\xA1\x7F^e\xF1\xF3\xCE\xC2F\xD5\xB6!\x1127-W\xCB\xF5O\x13y\xC7\xC3\x8E\xFE\x11\xE1\x13!3\xCBl*\xAA\x8E\xB8\xFC\xFB|T\xFEk,H\xCF33I\xE9\xB8\x81\xF4%\x07\xF8d[g\x86N'\xB9\x19\xE9{s\x85\x01\x9A\xB6\xA8\x04\xE8\r\xE7\\\xE3\xAF\xAF\xB4\xBC\x9A\xFE'w\xF7\x11sK\xEEg\x9F\xB35\xE21\xB9\x1C\x19\x16\xFC\xA9\x84\xDE\xDF\x95O\xB8\xB9h2\xFC\xC9\x9B\xE0\xB76\xAE\xFE\n|\x17![\xCB\xFC\x03\x90\xD3]\xD1Lo\x8E\xAE\x8C\xF0[[s\xE9 \xD5c-E\xDC\xA6\x12{\xE3\xD3&V\x00\xDD\xD3ynv\xCASv\x19\x14\x9A\x01\xA9\xE0\x96\xFF-,\xA2^\x9El\x06V\xE8a\xCF\xDD\xC9\xB9?!\xED<\xD3F\xDE\xAFcY\xEE\xE3\x066\xD3\x07\x9A\xF0\xF7lQ\xCB\xC7_\xEA\xEC\x1E\xFC\xB4\xE9xhx\x16\x9C\xA8\xC5\x86\xDD-D\xFE9\xB6}gz\xF9\xB3\x96\xC2Lz\xFB\xCE\xDC\r\xE0\xB6~\xD7\xF8Kn\x94\x17\x80\xE8w\x9A,3O\x1A~K\xB9\xB6\xD7-\xFF\xDD\xD5\xE4\x7Fc\x8E_\xEA3\xCC\xA9\xE4o\xBBG\xA0\xD1\xB9ZTR\x90R\x90\xB3\xDD\xC7\xE5[\xEFw\xEB\x9F\x18\xE4\t\xF8\xF3\x90cw\x9E\x91\xE1\xBB\x11r\xF8\xC6\xB4\x0E\xB94\xB4z]/\xAB\xF0\"_\xAFEJk(\xB7\xAEk\xB8\x83\x06\xF6\xF7h\xB8QE\x87<\xD3!\x069[\xFF\xD3\xF5\x8C\x85^/\xFET\xFF\xBC\xD6I\xEC\x1F\xD7\xF8+S\x0F\x11\xCD\x1C\xD5L\xAD\xA0\xBB\xA9\x96\xEB4\x1C\xFC\xFBf~r\xA7\x89\xBB\xBDRG\xDAR\x1B\xDF$t\xF1\x82\xC8?\xD9>\x93e8l\xD1\x1Cl\xE3;(\x80R\x16\xF2\x00SS\x89\xCEo\x10A'\xA0\xF1g\xB4\xC1\xC4\x9Dg\xAE\x13\x80d\xB6\x18t\x99\x9BT\x82\x1C^3\xE7ZR\xE4/U\xB5\x7F\xEE\x14K\xA8nQ\xA9g\xC1\x7FK\xAF\xC0\xFF3\x9Dw8\xAA^\xB90\x96X\xF9X\xCC=\x02\xD2\x90u\xE5\x04\x14=\xDD\xF6GD\xFF+\xE1\xE3\x0F\xAC\x85\x82L\xAB\xF2x\x8EFS(\xBD\xD9hZ\xD3Sl\xF9^:\x87\x94\x81\x94\x86{\x8AHeF\xB8=\x1CP\xB2\xE2\x8E;\rr\x96{\xFC\xDD\xCF\xC7_c\x07\x10\xCF\xB8\xE4\x9F\xE6|c\xB9\x83:\xE8p\xB9=\x93\xB5\xB3<\xB1 \x81\xB1\xD8\xA61\xD5[\xD3\x19\xA4\r\b\xC6m\xB6_\x06X AW\xAB\xC5\xFC\x05\x8Fi\x8E\xE3 \xDD\xD5\xCB-my-[~\x98\xE9\"\xCF}\x87\xEA\x1CC\xCC\x89\xB6&\xE6\x98@\xA0)[\xA4\xCB\xDCdb\xFF'\xDA\\K*\x94\xC8p5R\x99:#\xC835\x8Atl\n4\xD9\xD9\xFF2\xC3\xCF9\xF1\x03J\xC3X\xC2\xDC\xDB*\xB9iy\x04k\xA1\\\x8F@j\xD7\xDC}\x94\xBB~X\x0E\xBC\x84\x80\xB5\xEF\xC4\xE0\x18c\xBF\x03\xD9\x83\x0F\xEC6Np\xDA\xFC\x91~<\xD1\x8F\xDDE<\x02\xEC~\xE0\x86\xED\xC2\xBBa\xC7\xCC\xEF\xEB\x07\x94\x9D\xEEyJ\xAA\x1F_\xA7\x81L\x7Fmb\xE3\x83nsb\xB7\xFD\x14\x0E\xCC\x12\xF1\xDB\xF3\x00\xE9\xC5\xD7)\xDA\xEC\tn\x7F\xC5\x1A\xEBG\xC6\xDB\xEB}\xE4j\x83\xC3.\xFC\xD9\xEDFgS\xA4G<\xCE\x8A\xD7&\xD8\xC7\"\xCA\x02\xD7@\xF9\x97'\xE8uFiF\xBE\xDD\xFD\xCE1\x99\"H\xF7\xA9c\x02\x817\x9F\xC8\xE1Ur\x85\xDDP\xC2\xA3\xBF\xB8\xC1\x85\xFF\xBA\xED\xD5\xEC\x9F]\"\xACk\x14x\x94\xCE\rm\xFBg\xCF\x83\xFF~\x89\xF9Z\xDA\x96\xB6\xA5mi\xFB7\xBE\xF9P\x16\xA5o\xD0\x98\xEDX\xD9a\xB2\x06o\xCC\xBF\xCD\xAE\x8FUR\xF6\xAE\x95\xB6\xD5\x17\xAC\xBA.\xC4\xB2F\xA8Uy~gM\x81\x01\xBB\xDA\xAF\x9D\xBA_\xAE\xA8\x17,\x7FD_\x8D\xCB8A\xCA\xFBK&\x92\xB1\xCB\x17/\xF69\xCE\x05U\xAA\xE6\xA4\x90x\xD7\x12e\xBD\xAB!\xFB\x07V\x99\x95\xF8[4i\xFC\"\xF8\x0F\xBB\xF1/\xD9\xF8\xFFGa\xD5(v\xB8\xFE\xF0U\"M}\x05\xFE\xCA/\x19\xF9\x06y\xD3*\x13)\x8A\xFF~\xE3Uf\xC0_\xE5\x8A\xB9\x82\xCF\n\x98%w\x9De\xD9 sX\x9F\xACw\xAAXo\x86W\x18\xB8\xCA\xE0\x95\x94\x99Q)\xAB8@\xA7\xD2\t\r\xF0\x9D\xF3\xDEx\x00x\x82\xCCCi\xE8&\xEB{\x87\xF2Ez\x98\xEA:\x86v\xC9\x80\xB2\xDDr\xE3\xBF\xC3(\xE3\xF6\xF9\xC2\x81\x8C!\xF0\xF7Y\x0E\xFE\xF2&\xF8.\xD6\x14\xD1\x94\xA3\x17\xA71\xCCW\xD1;~B\x15\x9E\x1D%\xC3\xE2\xFC\x0F\x98\x0E+N\xCC\xD1\xC0\f\x02\xD6\x81_\x94\xC7m\x1E0q`\xC6\xCD\xD1\xA5\xB91Y\xFF\xA6\xA8\n\x86\xA3\xA2\x91\x07\xCE?\x84\x00\r\x19R*\x123\xD2\xC8\xC9\xFDd\x1270\xAC\xA1\xEF\x15\xEB\x80\x89\x9E\xD94\x9BGg\xED\x9At4\xE4\xE3hLfwyL\xC4\xE4\x8F\xA980m]\xADa|\xF2\x89q\x13\xA9\x1C\xB1~\x0F\xB0\xFB\xD6\xCF\x1C\xD5\x10\xA7\xF0\xB6j\x15y\xF2\x15\x1D\xF5\xD3dF \xF3e\xAA\x00\xAE9\x9E\xA4\xD6\xB5\xDD}\x1E\xE6t\xAB\x89\xFDg{\x0E\xCCZ\xF6r\x80No'\x86\x13)\xF6\xD3C\x87\xE9\xB9\xF5\x16\xA3\xD4F\xED\x82\xC2\x01r\xC4\x81\xD9\b\xE3\xEB\xEC\x99\xCB\xE3\xF6\xE2\x02?wN\xD1\x98\xD5\x98\x8By\x8BB\x8EmZ]\x1E&\xA4k\xD0\r\xD7N\xB9$&\xB9\x05{\x92kG\xD2v`\x05\x1A\xA9\xFC\xCBc\xE5\xF8\xD3\x94\xEC\t\x82\xFF\xEB\x9D\x06\xA4\xCE\x84n\xE0\xDFE\x7F\x0E`\xC2\xC0V\x13\xCE\x1C\xD9ou\xAD\xB6\x189\xCF\xAE\xAC\x1B4\xBDO\xBC\xD0n\xE2\x8E\xFCX\x1F-(\xD0\x01$9\xDD\xB1_7\xB0\xFE\f\x11\xFB?%\x1D\xF4\xCA\xBFlA6\x92\xA2<+\xE3\x1C\xAE\xCDm\x83\xBF\r\xF2\xBFx\xA8\x0F\xAA\xA8z\x0EY\xBD4V\x8Dus\x957\xF1\xC8\xE6\xA8\xC5\xA6\xF0W\xD0\x8C\xB8\xF0\xF7\xEAi\xCB>\x18\xD2&\x16\xF7\xDB\xA3\x9F\xA3|\x1D9f\xAB\xC9YG\xC6\xEC\x01Y\x16\xEE\x18P\x1D\x8F\x1B\xB9\xB1o\x06\xC8\x86N[\x95lR\xC8tW\xBEHs\xD2\xBBf\xEESb\xD7:\x9B_:?\xC8\x93\xE5VI\xBD\x9E\xE2\xAF\xA1B\x14\xE0\xD1\xD3\xD6*\x13\xFB)\xCF\xDFm\xA2)\xE7\n\xBF\xF7\xB5}\xC2\x94\x99\xA2\xA0\x01\xFEX\x96C\xD8\x80\x9C\xF8\xC2#\x1AV\xABcP\xD1\xA0\x11M\xF2\tN\xF7\x1D_\x05<s\xBA\x8DOu}e\"T@\r]\v@\xA5\x9D1fF`\x1C\xBE9\xE0y\xF7\x9C\x95\xCC\xF5L\xACR\r\xA6d\xD8\x1A\x04#W\xA6\x7FR\xCC\xE30\xC1\xE2\xF9}_a\x99\x82\xB8\x83C\xB1\xE0\v/Wq\x83\x16\xB1\x83\x81\x9B\xE8\x15V\x14\xC5\xD3T8K\x9F5\\\xAF\xAABWp+\x85\xED\x15E.2*\x86[\vn\xD2\x9BO\xFA\x82\x85o\v\xC4lB~\xBB_G\x1DM\xFA\xADD\xCB\xE1\x0F\xBC\t`\xA4\x9F(\xC9\x1D\x1A\xE2\x89\xF1a\rz\xA2\xC4\x84g\xBFIg\xCA\xFC\xC8\xB6\xC7Z\xF9]\xD8k\xFB\r\x93\xAB\xC1N\x15\x87Z\xAD\x03*w\xFDpp\x94\x15\x86\x8A\x87\x0E\x13\xB1\xEF%\xFA\xC7+\xFFJ\x01\xC1(M+Dz\xF18\xBDK\xF7\xCCC\b\xDC\rE\xC8\xBF\xC2\x99\xE7.\r\xD9\x98\x95\x9D,\xD8\xFA\xA7\x8Ca\xDE\x1B\xA3\xE9\xBBs\xE8{\x85\x0E\xBC\xC1\x9F\x8D\xC5\xBEO\x1E\x13\x8F\xA1\x1DC\xE0\xBDG5\x1C\x98=\x87@\x94-M\xE2\xCB\x9A\xE8\x01D<d\xCE\xCD\xE8.V\x8A\x06\xCC\xCF@\xB6\xBA+\xE2\xF6\xBBMt\xCF\xB8\xF2\xA8\xFB\xDBx\x93j'\xED\f\x05\x83\x02\xFF\xBE\xB3Q\x91\xA8\xB9B\xFF\xD7\xF6\x92\xD7\x90\xFC4\xD0\xA5b\xD5\x99kzT\xF8i5\xCD\xBA\"6\xA9\x9C\xE7g\xDA\xE0\xDEh\x96\xDDE\x17\xFAg3\xD0\x15\xC5\x06\rw\x1DOh9$T\xDCn\xE2v\x1E\xB9\xFDj\x9F\x868-\xF9Ai|oD\x83|\x0Eu3\x94#\xB5\xEClB\xC9\xDC\xEB\xF0\x9B\x90\xEDe\x05\\\xFF\xD7\x98\xD8z(\xC2\xD6X\xB1#\xAF\xF4\x8E\xBF\xFF\xE9~\xEEx\xEA\xE9d\v\x9D\xD2\xDD4H\x807\x9E\xA8\xF1\xDB{s\xD8,S\xD7\xA7\xFF\x1A\x96\x18\x84s\x80\xC0\x9Dt\xBD\x1ES T\xFF$\\\xF6\x8FL\x1D\xFA\xE9Jo\x9A\x0F\x19w\x8C\x0472kf\xED\xA4|v}L\x1F6\xA2\x91!\x7F\xA2B\xFF\xBF#\xEA\xEA\x10\xFB\xE7n\xB3\x14*\xE2\x16\xAA\xA6\xAE\xD0pe\x8E\xE6.\x13*\xEE\x8A\xD3o\xB2\xAF\xCB8\x93\x8F+\x89\x1A\x1C \x98\x19\x89U9\\Y$\x86Y\x90\x9D\xE2\xDB\xB8\xDC\xC0*j\xFF\xAC _\xB7\x95\x1B\x99\xD2:\xDA\xE6\x01g\xA9\xD1\x99^\xF8\xB6\x02\xFF\xE2\xF2\xC6\x92\xED.\x03\xCA\xC1KM\xB4J\x04;\xF2n/\xFEW\xE4\n\xEC'\x89\xDB\x96%\xBF\xDB\xFE\xC1\x18|Z\xA8\x88+M\v\xBE4\xF3>P\xBF\t\xF7\x1F]A=A\xAC\xD5t\xFC\xFD\xA2\xE3{\xF2\xBFJ\x87\xE6\xF2u[}&\xDCk\xEE \xA7\xF9\xE2\x14y<i\x94\xCB\xFF\xBDG\xA6!1\xFD_!\xFF\xBE\x9B\xF8\xEB,Y]*z\xA2\xE9\x84\x86-g$f\xFFlV]\xFA_.\xDD\x1B\x95\x99D\xDD\xA9r\x19\xD8\xAC\xA2+\xA2_\xAB\xE1\x8E3_$&\x01]>\xB0\x86'\xC0?\xDE\x07h\xFE&\x00\x7FB\xE4<\xE9}\xEE\x16\xEAf\xFADyV\x16O\x1F\xD5\xD7\xC2\x7F\xC1\xC9O.\f\xD9[M\xDC\xAE\x17\xEE\xA4\xFDeA\xD1w\xE4\xCA\xE4\xFF\x1C\xF3\xB8\xADz\xF1[\f\x8D\xCF\xE4TGMI\x16\xFC\xD6]\xFD\xD8\xEC\xCF\xD0X\x85\xB4-\xFFl\xFC%\xF2/\xF3\x83;\f\xB0\xFA\x14\xF4:\xDF\x87\x7F\x05\xFCm]\x91r\xF9\x8F\x1B\x88\xA7]\xF2og\xFB\xF1\x8F'E\xDBl\x87\x88\xFEB/\xEA\xE8`-U,w\xF2\xFFD\x84C\xAC\xED&\xCF\xB4\xD4]\xC4\x96h\x81I\xC2\x9D9'\v\x10\xE4t\xD7j\x8B\x85=t\x9A<\xA4\xE4KD\r\x0E\xDCl\xA2wGb\xAB\xC6\xE3\x8E\x92\xEC\x91\x05\xF4\xA4\x8A!\xAA9I7\xFD^\xF9\x97\xAF\x87\x9C\xEE\x10k\xC7\x98\xED\xB7\xE1\xB8\x05\xB9\xC9Q\xBF~.-\x19\x03=\xFA\xA5\xFB\xA8\x8F\x80\x1D\xB9\xD9;\x8F\xD9\x92\xE72\xB9Af\x0E\x82R\x9C\x16t\xE0\xDEOY\x87\\\xE8.R\x89\x95\xD3\xEC\x8E\xCC\xF7\xD4\xA1\tkV)0F\x9D\xFC\r\xDE-\x86\xBC\xBB\xC9x\x11\xD86:S\x8E\x7FZC\xDA\x9D}IY\xBB\x8B\xF5:81\"v\x1F\xB5\x97\xEBN$\x10\x1C\x87{\xA1\x84s\xE2]|\xC9\x9B\xD2;\xAC\xA20\x99\xCEhx|v\x829\xD0\xF7\xAA\xCE\x9AS\x04\xAC\xA9\x98\xCE\xC2~v0+T\xC5\x84\x86\xED\x8A\x9E\xD60>\x9CH\xE7\x90\xA6\xAE\x87=|\xFC\x9D\x19\xD1\x90\x19n\xE2\xF3\x85\x80W\xFE\x95^\xD4\xCF\x8C\x8A\xF9W\x8A^0\x9D\xE8E`\xA3\xB3\x9A \x10\xB7\xF1OM\xB6}\xE7\x95\x84\x9Dw\xF1\x1B^\xFC\xFF\xFA\x81\x02\x9BD$\x87i\xFD\xA0\x80\xFCD\x9E\xEC\xE1K\x17\x95\xB5P\n\x19\r\xD9D\x86\xC6*\xA4m\xE6|\x9Cvg\x9CNO\x18\xA3N\xFE\x06\xDF\x11\rhB\xE0%\x04j\x9F\x8D\x95\xEB\x9F}*\xF6\xB5\xB9\v\xDC\xBC\xC4\r\x15\xE5\xD8\xDF\xA9NH\x037\x0Fv\xBF\x84\xDA\xFB\xAA\xCF\xBF\x02\xDF!\xA6>\xB1?\xB3\xA3&&b\xA5\xD1\"\xFE&\xD6\xC0\xB8\xF7\xC7s\x9C\xE7ga\x18#\x0F\\\xC7V%|\x93\na\xA6\x1F;\x8B80;\x90\xD1p\xF4\x17\xC4\xFE9`b\x9F\x89Gy5\x81\x86\xA3\x06\x0E\xD05\xDA\xDBU \xE0\x95\x7F\xBA\x96d\xBB\x88\xAFH\xD1\xCB\xEE:\x91E\xF0\x06\xE6\x1Dp\xB7\xF6q\x13\x7F\xD5\xFA\xDB\x91\xC9?\xE3\x19\x87\x80\x83^\xFD\xB3\x97.\xA3\xD8\x05d\x13\xD73\xFC\x1FQ\b\xFE{\xF8\x1A\x8A\x97\x10\xB0F\x8Bx\"f\xA1\xBE\x96E_0\x13\xEE\xDB\xF4j\xDF\xCE-\xF1^K\xDB\xD2\xB6\xB4-m\xFFf7w\xC9N\xB5\"Q\x0F\xB1\x84k\x8A<\xC5\x8D\xE2b\xB0!b\xFE\x95\x8F\xA4\xD5+\x18\xF5j\xFC9\xBC\xCD\xF8\b\xC7\xC1b$\xBF;Y\xB8\xEF\xF7E@\x95\xCB/\xA2-\x9E.'\\\xADU\xEA\x1F\x88\xB9\xFBt\x06c\xA6\xC3\x8D\xBF\xEFy>\x07\x94\xA6\x18M]_\f\x1F\xE8\xB0\x02Ez\xB0\xB2\x1F\xC0MF\"@\x87\xF2zb\xCBe\xD6\x9B,\xF0\xDE\t\xED\xB3\xB9\xEE\xAA\xF8+\xDB\x1DZ\xE6\n\xCDa\x84\x18\x8BU\xDETip\xC8u\xA9U\xAC0\x96\xCF\x9D\x92\x94\x85\xF1\x0FF]\xF8\xDB3\b\xB5h\xF9\xDC\xEE\x10W!0H\xE1\x96\x99HT\xB2\xF8t\x89\xEE\x89B\xAB\xBA\\\xBF\xA4\xF2d\xECe\xA2\x16eVl]\x89_\xA1\xEA\xE6\xF9\x89uj\x1D\xECHx\xA9\xD0.bJ\x19\xE5\xC5\xB2n\"x\x82QF?\xBA\xD6Jv}a\x8A%\xDE\x91\x89\xAD\xFB\xE8/\xCE\xB1\xC0\xFB\x1F\x19@ma\x87\x86\x83|\xD2w\xB7}\x9Bl5\xFB\x8A\x11Pm\x93\xCE\x9E\xA3|\x06\x97p\xBC\x0F\xE5M\xF5\xE4\xAC\xFD,\xFD\xDB2\xEDz\x19Y<\x9B\xC4\x81e\x19Vm\xFC[\xEA\xA2\xA7\x1D\x1C\x88m\xD9\xAC:\xF8G\xEB\xAC\x96i\x96\xDE\x93b+)-\xE6@\xD5\x97\xABY\x150\xD6\xCC{\xF1_\xC75\x81\x94]\x1C\x7F\x17i\xC9\n\xB1I\xB4\xE4\x16\x9Bt\x07\x9F&\xD3(\x7F\x84\xB3U\xFE\x87\xB8\x18\xD7\xEEgS\xE6[\xCF\xA0\xF1L4\x91\xA6r\xE1\x9B#3\xF7\xF4$\v\xEF\xEC\xA2\xA1\xDA]*\xB6\xF2\xFA\xB3\xDF\xB7\xEF\xB3\xB5j<*=\xAC\xF0\xA2#\xFF[\xF82\x19!\xFF~\x97\xFCS\x96\x00\xC1\xB4;{\x0F[\x84\x9C\x8F\x8E\x95\xCB\x7F\xD0`\xC5\xCB\x18MwH<\xB3<\xF6\x1D\xB2\x01\xA7eC]\xF8[O\x03\x93mL\xD8\x18\xFE\xEB\x0EA\x1B\xAA\xA6K\xFFT\x15pI\x1E\x0Fl\xFB\xC98WM\xC1\xC5\xF1\x0F\xBA\xF0g\xA7\x07\xA3\x10\x19\xB7\xE0\xEF%\xF3k\xDFk\xFC\xABo\x04\xCC\xF3Xs\x01\xC0\x95E\xFCi\xB3e\x1C\xB4>\xC1\xDC\x01\x01\x9DR\xF1\xCF\xACc\x05\xCA\xC9\xC4-\xB2\xDE\x04\xF8\xA4\xCF\x91\xFF\xA6j\xF2\xDFh2\x02\xD0i\xCFz\xAE\x7FDULi\xA4\x12\x7Fwh\xDF\xFFD\xC1\x99\x8CT\xC8\x7F\xFD \x8B\x85c\x8B\x85\xEC\xB8\xB8\xEF\xA1\xDF\x85\x7F\xC6\xFD\x13\x82\xEA\x0F\xDE\xB5\x8E\x14(\xF3\x19\xB4\xD8\x01\x87\xA1)\xD5\xF0\xFF\x9C\n4\x84+\xE5??Bi\x88\xD0}\xFC\n\x1F\x89?;=x\x13\xEC%\xFC5V0G\xD7\xD4\xF0\xDA\x8Es\"\x9B\xFD~\x16\f\xFF\xE4\x03\xE9\xBE\xC3\xD1\xCC$\x95\xFFZ\x82\xCF\xE3\xBF\xB8\xF0\x14E\xF20\xE5r\x0F\xAA\x9C\xD3\x86<`\xDFg\x7F5\xF9g\xF9\xF3\xD7\xCF:\xCE\xEE\xC3\xEC0\xBF\x90\xFF\x80K\xFE\x19q\xE1\xC5\xDF\xA4\xB3\xCB\xC9\xE6\n\xFD\x1F\x8C\xB3\x82\x9E\x9F\xA4\xB78(~\xFC\xC1y\xC3~\x17POd\xEF9\xDB\xB9P\x1F\xCBG\x91/Pp\x98\xF4\xD6+\x87\xDF\x9E_U-\xC1\xFEc*\xCF\xD7]\xB6H/?B\xB3[\xF8z/+\xFF\xAFU\xEC9\xE9\f\x97A\x9AAK\xFE9\xCFQ\xEF\xFF#^2\xDB\xFF\x1C\x8B \xFD\xDA!k\xCB\xA1/\x0E1\xE6\xD3O\x04\xB5\xD3\xBF\xE6Z\x8A\xC9\x90\n\xF8\x93\xFF{\xBFH\x8C/;!\xC1\x9B\x17[\x8F\x03\x1C\x8A:\xA22d\xD7\x02\xE0\xFA\xE7\x8Er\xFC%\xD9\x8D?S\xCE\x11U\xAB\xD0\xFFq\x869\xAB\x9C\xE8\xE4\xF1\xD6\xB4\xB3\xF6\xB1\xC15\x00\x9Ev@HDWG\xA2\xAC\xFC7\xD3\xDEA\xA5YR\xD4jf\x17\xD1\xB7\xACw5\x1E9\xCF\xA7\xA2\x9Cc\xBC\x9C\xFEOUX\vt\xD4\xF0\xB1\xB4\x12\xF3Q\xB6\x9E\x88\xC5\xC3Ks\xC2\x17\xB9\x9F\xD9'\xAB\x9B\x93\x1F;\xFD\xBD\x159z}\xDF\xCF\x01,;\xCD\t\x7Fj\x05}\xF5?\xE6pE\xCE\x13<P\xB6\xCE\xC8\xD1\x1E\xEC)\xB8\x13\x97q\x0F\x82\xE8\x94\xCFM:\xB1\x9C\xE6\xB2[\xFF\xF3\xE15\xA2\x97\xAB)i\x90a\xCE\x12\xE0_m\x1F\x1F\xD7'l}\"\x11\xB9\xBA\xDA\xB1\x7F^o9\x13mq\xE3/\xADk\x96\x94\xA1j-\x0F\x13I\xCBV\xCA\xFF\xFAi:\x926\xDCrY\xFC\x9F/\xB7W\xF9 \xC2\xE0R7\x14Y|;\xCB\x13\x9E\xE4\xF3\x02z\xBB-\x1A\xBE\xF6\xB9K\x9B;\xC3\xF72\xF9\x977\x91\x9D\xAB\xD70\x99\xBC\x8D\xFCUo\xEBG\x1F/\xE6\xFB/\xCE\xC0\xBA\xB8\xFC\xDFp\xBFK\xFE\xB9\xFE\xE9\xF1\b\xB3\x1B\x7F\xBF\xEC\xCE\x1E\xC3\x86\xD7MQ\xB7\xFEg\xAF\xAD\xD6c8\xF8o\x12w\x8F\xEA\x892\xFCo\xB0\x1BVsc\xAF\xAC\xF6~\x8E\x82\xE3\xA7O\xA1F\xD9\xFC\xF6\xBCQ\xAD\xE5\xFD\xFDb\xFC\xF5\xCA\xBF\xCA\xF8\xEA\x9Ay~\x85\xAA\x9B\xE7'\xCDa\xB9%\xFA\xB2\xFBK,\xA3;O\x18(M\xF3G)oe\x88\xDDz\xE8\xF6\x03\x9F\xBB\xA77Mw\xFA\x89\xFCw\x9E\x99\xBD\x97\xE2\xF6\x9FL@*\xDD\x9A\xE3\xF5\xB2E\xAD\x7F\xB8\xEBM\xBB7\x96*\xA7\xEFE\x07=N5\xDB\xFA\xDF\xEF\xEA\x1D[\x00.\xA7S.\xFC\xD9\xF0\x9APs\x15\x8F\x89\xE3\xCF\x0E\xD8\xE4\x94a\xCA\xCD\xD8\xA7\xD3\x18\x8F\x1E\xA7\x86Ht\xA3\xB2i#\xAF\x0FK\x8B,\xF8\x95\xAEE$\xC7-\xCD\xEE/\xBD;\xC4\x82Nv\x85\xEA\xD3\xC5\xE7+\xF0W\x1C\x05\xAB\xC4\xE8\xB2\xB5\x1EN\xD7\xFB{\xB8\xA2\xA3\xC3\xF1H\x0E\xFF\xD0z\xE9\xB1\xD9MOd\xA8\xD1\xA8\x10\xF9\xDF\xD1\xCAMx2\xE4\xC9\xE9\xBF\xEA\xE7\xCC\xB6\x13D\xC4\x06\xAC\x8Am\x98\xFE\x1D\x19vh\xE1\xC7\x18P\"\xDF\x19[\xA5\xEB1\xD5\x149\xEDR\xC8lx5nv\xE5t\xAA\xA1\x9F\x15#\xED\x1A\x7F\xB7\v\xCC\x137\xAF\xCCk\x1E\xFC\xED\xD5\xA9\xF0\x7F*\xADd\xD2\xB1\x943\xEF\xF0+\xC3\xFEhU\xFCi\x82\xB8\xA8\xE7Ue\xF8\xD3\x8A?4\xE3_jQ\xFC\xDD?\xB1\x8B\x04\x06\x1D_\x7F\xBD\x95\xE9\x07\x82w0\x8E\x1A\x81\xDF\xF2\x15\x82\xF5\x116cz\xF4\xCF{\xBE\xDEj=6\\`\x07\x03\xF8\xE6\xD9/2\x9E\x7F\x8F\n(\xA5\xEF\xAAx\x8A\xAF\xB6v\xD4\xF27\xAB\xADG`\xE1\x16Gg\x1D{\xE0\xDB|\x99\x86X\xCB\xA0|\xDC9\xBA\xA1\x96\xEDY\xE9\x02\xA4H/\xBB}wm\xC5a\x06c\xE9\xD9\x01v-\xF0\xB1\x8D\xB5\xCE\x1Ayj\xD7\x8D8_\xA7w\xBD]\xFB\xC8,MO\xA4\xB0\xBFS\xDB\x95,\xAA\xD9?4%#\x85%p\x87'&$\xC1\x90\xCC:\x11\\U\xF0we@b\x17Q\x94%\xF2ki[\xDA\x96\xB6\xA5mi\xBB\xEC\x16V\x8Dr\xCBk\xF9\"\x87\xFA\x16e\xF5\x05yn\xE0\xB2\xB9\x80\xC9\x95e\xCDC\xEF\x7F\xF4@%.\x18\xB9\x8C\x99h3\x9C^30\xE26t\xBD\xFC\xBC\\~\xFF\x84\xDD5\x1F\xCFW_\x9E.\xC9W\xAD\xCD\x0Ez\x8Bte}\xD1\xE1E\xDD]\xB8\xBA\xC8\x9B\xAD\x1Ah7\xE9\x8C~\x11\xFC\xED\xB3\xFERXz\xCD\x95\x04\xB8\x14n\xA6\xFB\x97\xB3\x02^\xE4\x8ES\xED&'u[\x8A\xFC\x94-*\xA2\xF1\x81\x8B\xA1A\xB6\xBF\xBD\xE8\x8E\x85\xAB\xCE\xA8\xB3\x13\xFFa\xFA\xA6x\xBF3\xC1'wa\xC7\x84\xA6\xDC\xF8\xC7\x84mSZ\x1C\x7F>\x8F\xCEQ\xFB\\\x9A\xE3<\xA7`\xFC\x9A\x81\xD5\xB46Y\xFB\xE90$W|\xA9\xBF\x87\xF7Z\x1AX3}\x13\xFB\xF8\xC7\xD3\xD6\x1A\xC3kN\x87\xA6 Y\xED&d\xD1\x05A\xAFk\xF6\xEC\xDE=\xD3\x87d}`\"F\xD7\xB6\xA3\xCE\xF2<2\xFBI\t\x8B\xDA&j\xDA\xCB&_R\x165\xE4\xA6-&\x16L\xF1k \xB2Z\xE5s\xD2\xA8F\xC3\xC5\xE9t\xA0}:\xF3\xF8\xD9&\x0E\x97\x86\xAAl\xB0[\xB8\x19\xED\x7F8\x12}\xD4p:r\xAF\x86\xF5\xD3av\x17A\xBC\x93\xE7\xB2Zt\x90\x15\xE2\xFC\xC0t~\xB2\xF9y\xD6\xBC\xF5l\xE9\xBA\xA0\xEE\x9Bo\x16}7\xC9E\xDAM\xB4v[\x1Eb?\xD0\xCB\xFB%\xE9\xB1\xAB\xF9\xDB\xD3\x1A)|\xD7\x9E)\xD6\xAC\xE3\x9C\xBF\x14nV1t\xAC\xCD\xC3\x00H_\x05p\xC45\xAD\x9Cd\xDD\tF\x9B\r\x1C1\x89\x88\"8Y\xF5M\x9Fp\xE5{\xA9.\xFF\xC1\x01\x04\xC3\x93*\x9EV\xC9L\xF99\xBEVb\x82\xA0Ai\xDB#E\xDCJ\x91i3\x90\xBF\xD5\xDA\xD7\x1AAp\x90\xED\x0FTg\x14\x1D\xC4\x9E\xA6w\xFF\x87\xB6\xC1K\xAA\xF3\"o\xC9!Z\x18dw\x11\x93\xD0q\xD8\xAF\x9E-\xFF<j\xD4\x9D!Yc<^\xC1\xA0\xF2\x1F\xE4\xAFO\xA1\x10\xE4\x1F4\x82\xC6A\xE0\x90\x91C\xD0%\xFF\xD2\xE4\xDF\xF6s\x89}\xA6p\x8C\xED\xFB\xDB6\xEB\x99\x9C\x87\xFDF\xB0\x80z\xEB\xA8\t9\xC8}%\xFC\x05\xA7\xE1\xB0\xCF\xB9\x84\x8D\xCF\x8C\x82\xD1/\x171\xA9\xE2{\x1A\xB9\x05\x7Fd^\xF9\xCF\v\xFC\x0F\xDB^\xAD2\xF9\xAF\x0F#h\xFD\xA0\x88\x1F\x98\xD8\xA6\xE1\xBB\xBC=SGL\xCE\x8D\x7FO\xC3?\xD0f\xE8\x1A\x8E\x9C,\xBC\xDF\xBE\x11\xF5d^9\xA9\x91\xF7\xA5\x1A\xFENl\xDE\x0F\x18\xA7\xFA\x8B8O;C\xB3\x16\x14\fL&\x8F\xB1\xBB\b\xE2\xF1'\xA4\x85\xA2\xE5c\x9A\xF3\x14\x10\xFA\x89\x9B\x9Fd\x8D/\x98@\x83\x85z\xCE\xA8\xE4\x93\x17\xD8\x87'M\x1C\xD2H\x07\x8FN\xCFy\x88}Y\x7F*\xC7\xD9\xFE\xE7\v<\x88\xEBp\x9B\xE1\xE8\x7F*Q\xA8\xFB8\x82?;\xA8ba\xEE\xA1J\xFD\xFF\xB4k\xD2Z`\xA8\x06\xAD|\x8E<\xF1\x1F\x14\x85\xEF\f\x98\xF0\x821):\xB5\xD7~\"Z\xA5\xFCg\x9F\xA5O*\xA9\xE1I\x1E\xB5\x98\x9B\x10\xBE\x89'\x8B\xDC5\xBC`\xE2{\xC9\xC2c\xAD\xBC\xB5G\xCCE\xC6k\x97\xFC\xB3\xA7\x7F\xA8~\xF0\x92\xC0\x81\xBD\xD4\x7Fw\xED\xA0\x87\xD9\xA0.\xE3\xEF\x8Bo,\x0F\x03WG\xEE\x02\x97\xBE0S\xBCG\r\xA0\xA1\xD7~\xE5\x9F\x9C\x9B\xB0_\xB7\xC3*\xE9\xE0\xA1\xDB\x1B<\xF2\x1F\xB2\xB8\xFC\x07\v\x87n\xE5\x03\xCA\x916\xAB\xCF\xF1>4q\xF9\x0Ff\x8F\x98X\xD5\xF6\x9C\xCB.\xE1\x1A\xD5\xAD7\xDATg\x7F\xCC\xA0$\x97\x90\xFF2\xFDo\xBFaM\xC6\"\xF8K\xBD\x90\xAC'\x8B\x88\xAAD\xFE\xB9C\xA4~\xE2\x88\x18\x7F\x0F\x02\x83\x8C\xD8Q\xD1r\xEC\xB5\xC7Z\x07\x11\x8C\xB3\n\x16\xEB\xAB\xE3\xEF\xEC\x8Dr\xFD#\xE4\x9F\x8E\xBF\xBA\x8A|\x8A23\xF5\xA2u\xA1<\xB9\x91h\xF9s\xF4\xC3W\xB9&\xCC\xBBal\xA1?\xA9\\\xFF\xF3a7&\x06\xE2\xFF`\xA2E\xC3\x1A\x13\xAD\x91Y\x04]\xC4Z\xA0\xE9Z.\xFF\xE7\x0EG\xF8{\x11\x95\n\x0E\xDDA\xE3\x19P\xBB\x12\x92\xD5\xA6A\x16W\xE6`\xD6\x94\x1C\x9B\x87n\xD7\xF2q\x81\f\x8E1\x83\xEA\x7F\xA9\xBA\xFE\xBF\xBA\xDF;dW\x19\x7F\x07 e\xA3\x1A\x19+\x13\x9A\x90\xBA@$\"\xCC\x92v\x93\xAF\xF1\x19\xCA\xA1Y\xCA>\xDE\x1Eg\xBE\xF2v\x13\xAFW\x1F\x7F\xCFU\x8C\xBFB\xFE\xE9\xF8\xFB\x13\x03\xB1\xF8\xA0g\xFC\x95z\x00\\\xE7\xBD\xDA\xB0\xE6\xFCd[)l\x8CX\x93\xA3\x0E\x17\x89\x13S-\xD3m\xF6\xE3^M\x93\r\xAE\x7F\xA7\xE0\x1D\x7F/\xFC1\xD7\xFF\xE1\xD5\xF1{\xD8\xBE\xD5\xD3\x97\x82et\"4H\xE1O\xAAX\x15\xE7:\xEAu\xCD\x91\xF3;\\\xCD\xE3\xA9]\xFC\x83:]\x13G\xF4X\xA8\xBA\xFD\xD3+\x1E\xF1\t\xF1\xA1\xC7\xA8\x90\x7F?\x91\xABM\x06\xEE*\x8A\xA7\x13\x9A\xBA\xB3\xC8\x99\xF0\xA8\x86u,\xBC\xDF@\xDF\x19\xEB\xBD\xE2 \xFCq\x96OoUU\xFC\xFD\x8E\bl\xE6\xF6\xA7\x90\x7F\xDA\xC8\x15\xE4:q\x8F\xFDY\x9B$\x80\x14=\xA2\xF2\xBF\xF0!;\xE9\xF6\xCF\xB2\x98\xFC\xBBY\xA6,q\xA3\xDE\xA8n\xF3\xEA[\xE8\x8A\x83\xAE\xB6s\xF0{\x88\xE5\xCD\x82B\xEF;\xC3\x9F\xCB\xD6C\x11g\xFC\xF2Oqo\x11]\x97\xB7p\x86\xCB?wwR\xB7\xC2g\\\x97\x13q\xEC\xC7d\xBA\xF6\xF0\xCE\xC5S\x88\xDFYAu\x96\xE3\xEF_\v\xF9\xFA^\x8D_d\xB3}\v\x8D\xD6G`\xEC.\xDD\x16r\xB8\x99{?\x07=Uq\xCB\x19uG\xF0xF\x1D\xBF'\xCA\xBA\x0EHt\x0EV\x9E\xB7\xA5\xE8\xF1\xE3T\xDD\xD8\x05o\xD7\x80\xDA\xB0=\r\xBB\xF3\f/B\xDDA\x19\xEC8/\x92R\xA8|p\x90\xAF\xFF\xB4\xA8\xB6\xAC\x1Fjs\xC6_^\xA3<\x01\x19\xC9\x1C\x92:\x17\xE66\xC3\x91(7n\\q)\xF1\x8F\x01\x99\x1C\x05M\x8CS=^\xF5\xBEQE\xD9\xFE\xF2|\xFB~\vJo\xAF\x06\xC3 \xC7\xF0\xBB\xF8\xA3\xB4\x86l\x98\xDD\x97\x9D\xAB\xE4\xB0#\xA1\xF7tF\x19\x95=\xAC\x96\xDFK\xBC\xECN\xEE\x97q\xB6\x9C\xB33\xDA\xE3\x1AL\x83@&\x11\xF5\x8C\xAD\xF4C\xAF\xE8\xE0\xC7\xDC\rv\x8F\xBF\xFE(]\x99E\xC3\xF8\x83\x96]\x97?\x95H\xDA*+\xA5\x91\x0E\x0E\xAF\x8EBy\xDE\xAD\xB8\xB8\x9FB\xE9\xDD\x91\xE0\x8F9}\xE2\xD2*g\xFA\xCB\x8A\x9A<\v\xA50\x92\xC3\xF5'\xB8\xFCw\xF2\xB3\xBEa\x17\xD8e\x1B\x7F\x9D\x95A\xD3\xC4\x1E\x13\x8F\xC2\x959\xD0\xEB\xA1\xD8e\xA2l\x7Fy\xBE}e\f\x81,+\xEF;\xAC\x8A\xBB(\xD9=\xFD\xA2\x8A\x99\xC9\xCFU\xFA\xF1\xCD\xD6\xD4p,\xCB\x02\xF2S\xC5\xF2{\x89\xF1\xF7\xCF\xEC\x8F,u\xD2p\xEC\x18?\x926\xF2?\x171z\xE2\x18\\mf\x1F\xEC\xD4\x88\xA6\xE9j\xB0\x92u\xF3\xF3\f\xC6Q\x95\x95\x7F\xE2\xD1p\xA3\xB3o\xB0\x0F_\xA7U\x98\xF7\x99\x18\x9D\xCDB\x99s\xCB\xFF>^\xBD\"\xFB\xCDk\xF9*\x89\x03\xB1Z\xD3\x86\xA2\x9E\xEEllD\xA0\xED\x80\x89\xAE\xD8\xE0\x12\xB7\xB5\xB4-mK\xDB\xD2\xB6\xB4\xB9Y\xFA\x9A\xE2\xFF\xF8u4@\xB1\x99y\x1F\x0F\x92W}\xD5=\x05\x1A\x8DJ\"\xC6\x90\xABZ\xAEQ\x95\xE4/\v\xC2\x97\xBC\xA4}\x99'\xA2\x8C'\x17I\xE0\x9D\x85\x0F\xB2\x97\xF5\xAF\xACP`\x13\xFE\xE5\xF3?\xC3}_\xFB\x94\xB0\xB7@\x00|U\xD2\n\x85\xED\xE6E\x8D\x8A\xE9*]1\x1DY|\xB2io_,b\xC8\xC4\xC2\xBB%F\xC7\rQv\x88\xF5\xF7c\xB5\xF2\xA3\xA6\xB60\xAD\x8C\x89\xEB\x1F\x94\xD4'M \x18\xB1\x89#;&\xF3`]\x89._W\x811\x04\x05\xFEA\xD5\xCD0\x00\xC8\x1B\xC8qv\x85\xE3\xFF\xA4\x89\xA1\xF3o\\\xF2r\xE8\xF6vPx\x13\xCA.\xC2\xE3B\x83\xDC\xF6\x93\r:7\x07X\xCCa\xB3\x06HMngP\xFBt\xA9\xD9K\xCB\xB4S\xFE\x9C\xF3\xA8\x92F\xE6\xE9\xC2\xB3\xD3~,\x1C\xF1\xBA{\x9A\xCB\x9C>\xD2`\xFB4\xDB?\xC8\xBC\x1B\x9C\xDCP]DA\x15\xF6\xA0JdWR#\x93\xB2B>\xC32\xC3$HG\x12\f\x7F\xF3\xF4\xBE\x9Ev+\x9Ar\xF0?2\xAD\xE6)\x95wD\\\xD9\xF90\x1D\xE6\xF8\xFB\x14\x04\x15>[\f\xAE+\v'\xCE\x1Bx\x92\xF3\xE1\xCC\xABb\x1D\x04\xB4\xE6\xA6\x7F\xE7\xE2|\xDC\xDB\x11\xE1M(\xDB\xC9\xEF\x1Bt\xF9>h\x1A\xE7\x1C\xC3_\x05\x82\x0E\xFE\x9B5\x1C\fF\x0F\xBA\xA2yY\xF8t\xC1\xB0\xAFCy*\x91\xEFx2i}\xDB\x86\x8E\xDE\xE2`YPt0~\xB8\x8D\xF2\xED4j=o\x94\xA3\xC1\xD8\xC8\xB2\xA4\xA6\x1E\x96\xCF%\xFF\x04\xFFI\x9D\xAF\xCB\xD6\b&l\xAE\xF71\xF4GTM\x8F+v\xAA\xCFCq\x86\x7F\xD4\xBE\xB2#\xFFR\x98\xA0\x17\x9A@\xA8\x84P\x86\x97\xC6\r\xE5\xD1\xE8y\xE8\xEF\x9B\xB8\xC8\xBDfL\xA2\xC6\xDE\xA7\xF2\xFF\xA1Z]\xFE/j\xAE\xA9\xA5\xD8~M\xFF\xB9.B\xF5\x0F\xE5KY`\xE4A\xEF\x12\x9E\xCD@\x87\x1C\xEDT\xE1\xCE-\xDC\xA5\"i \xCE\vU\xA7 \xC7\xEDS\xBA\x8F\xC3)-H\xC3\xEAXF\x0E\x97\x06\x1Cd{\x12:\x91\xFF\xEF\x19\x8Et9D1\xF0T\x99\xFE\x0F.*\xFFO\xBDKn}4G\xFE!\xD0\xC4\x92{7\xFA\xF6}\xFAL\xEF\xC2\xDB\xF3\xEF\x89\xCB\x9E\xB9\xD9z\x9F(\xA8?\xB2\xC9\x90\xDF\x88[,L\x87\xA1ht=B\x1C\xC1A\xEEJ\b\xEA\xA8o+\x93\x7F\xDEH\xA6\x7F|\xEA\x84\x8AxM\xD3']>\x17\xF7\xC6(n\xDD\xFBX\x9E\xAC\x90\x7F\xD2\x1E\x8A?k\xF9\x97\\\xD5\x19\x18\x89\xCD\xF0w\x07`w\x9B\x04\x7F\x91\xDD:\x05y\x90AMQ\xD5\xEDd\xEFlgW\xD4\x1B\x94+\xA3+J\x13\x1A\x1C\x8F\xBB\xBD$G\xCB\xE4\x1F\x1F-\xFF\v&\x95\x7F:\x90\xC9\xE0\xEC\x1C\x8B\\\xFD\xE0\\\xEDH$\x91V\x9D\xB2\xBB\xD7N\xD0\x17Dy\xC7\x9E\xCC\xDA\xEE\x93\x91#\xB4\x9As0FtiP\xE1\xCC^PG\xD0\x93: g\x10\xF4\xDC\xFAgB\xC5\xB63Y\x91\xFF\xB9\\\xFEs6\xBC\xDEA\x81\xA7'\xB2\xF5?\x84\xFE)\n\xFA=\xB8\xD2\xAD\xFF\x0F\x06\xA3\x875\x8FB`\xFA\xA7\xC0\x85\xE1\xCBT\xFF\xA4\x84\xFEI\x1Dt$Y\xA6\xFE\x97^/\x92\x83l\xCFdr\xD0\xB3H\xC7\xF0\xF8\xB5+\xF4\xFFH%\xFE\x85\x1C\xC5\xBF\xDDb\xDD$\xB8)i\xA6\xFF\x93\xCDaiu\xEFk\xFD\xCArq\xD9f\x89\xE1\x9F\xB0\xF1\xB7)\x8BQ\xF3zJ\xC9^\x8F\x9A\x12$\x11\xBF(\xAD\xF0p\xC2\xF4\xF9\n\x7F4\x1D\xA2\x83M-&\xE2\x81[\xC6y\x90@y\x8A\t\xD6\x85\xBCZ\xBE\x93wM\xC40\x93kI\xF7\xF0\x91\x97\xE1/\xC5\xDC\xFA\xAA}\xDAj\xD5\xD0\xEA\xBAN\xAB\x8A6Mh6\xA9\x07R\xDC\x0E\xEFo?&\x1C\x9A\x02\xC9\xD6H\xD9\xF8\x1Bo\x9F~\x9E\f\xB8q\"\xFF\x7F,\xD8\x9E\xF5\xA6g\xD4\xFE\x13m\xD1`\x03{\xD35$4\x1C\xA6\x85q\x15f?\x84,\xC6uo\xEB\b?:\x9D\xF8\xFB'\xE7/\b%s\xFE\xED\xF9\xB3\x1A\xD0h\x9D\x177\xB2\xD7\xC4\xCDh\x9B\x88\xF6\xA8\xC9\x11\x1D^\xC3+\x82\xA0f\x1C5\x9E7\xF7?\x98\xB8\xD1\xBDR\xA0\xA6t=\xB0mF\xE3\xCF+X\x9E\xAAq-E\xEC\xA8\x97\x06\xFC\x13\x88\x8B\b\x8B\x824\xB8\x96\xEC\xBA\xCF\xC6\xBF\xD6\xB9\xD4f\x03\x9F\xAD\xD5?\xCB\xF4\x92\xD8\x1ET\xF1\x90&\xF6\xD4\xF6\xA0v\x10\xB5\x1C\x9F\x07\xAF\xD1\xEF\xB7\x9FT-y\xB6_z\xC7\v]\xED\xE0gkI\xBF\xBE\xF4\x12\xC1\xFFO\xFA\xBD\x14\xAE\b\xFF\xDER\x86\x7F\xB5\xC8\xF6\x05\xEAI\xC9S\xC3c\x95A\x9F\xA0\x92\x979q\x9D\xEB\x89\xEA\xAF}V\xB1\xD3\xE8\x15&\x94\xC3\xD4\xD2\x98\xA8\x18\xF1\x9F,\x8E\x11\xF9oT\x89\x16j\x14\xF6O\xA3\x82F\x8F\x93\xD340\xC3\xBA\xD6(\xB3\x01\xF7]\x13\xDD\xBBJ\xDC\x13\x1D\x9A*k\xDE/\xE8\xAD\xCB\x12\x9F\x9D7\xF1.?~\xC4\xC1\x9Ffnb\x0E\xBB\xFB\fG51V\xF6 m\xF3A\xAF\x11U\xD00\x91\xAB\xA2\x7F\x0E'c.KF\xA7\xF6O\xB8\xCC\xFE92\x17\xA6zi\xD0\x8D\xB33\xBE\xD0\n\xB6\xE5\xA5\x04\xE4\xA9J\xFC\xF39d4\xE4\xA9\xE2\x9D5\xA0\xA9@h\x9C\xCB\xBF\xAAE\xD4\xDC\xDF\x1FT\xEE\x12h?5\xA1\xE4H\xD7b\xB6\xA2\xFB\xB6}\x9D\x9B\xC3T\xFFD\xC8[ \t\xFB_Rx\xEE2\x97\xFEi\xE1\xFEP\x9D\xE9\xFF\xA8\x8A\xAC\xA2\xA5=\xAE%\x97\xF34\x87\xB2\xE5\xE5,\xA4G(\xB1\x19[\xC3\x13\x05B\x03]X\xF6EHI\xB7#\xA0Y\xD2#\x86\xC7\xFEo\xA6\x17\x8F\xF0\xF5\x9E\x92[\xFF\xC4R+\xA3\x8E%\x1F\xA5\xEBtbe\xF6\x7F3\xD5o\xAD\xD45d\xE3\xBF\xC3)\xBF\xDB\xEBd\xB0q(\xD9*\xF2\xFF1\x9A\x8E\xEF\xDB\x14\xFF:\x16\xED\x1F\x90Y\xEC\xFD\xC9\x17\x9E\xED\xB9z\xE5k\xF79\xF6\xFFdT\xF96\x91\xFF\x1Bl\xF1\xB0\x87\x9E'_\x15\xF8\x93\xBF6\xFE7r=\xEF\xC2_u\xF5\v\xD0\xA2*\x8E\x9E\xB7\x16\xCC\xEA\xF2\xCF\\\xB1e\xE3\xEF\x1A\r-|\xBCh\xB3/\xCB\xF0g\xF3/\xF2t\\\x83\xDD8\xC5?\xAA\x95\xE3\xFF\x1Fr\x88\x16\xC5`\xE4\xC6?\x1Eu\xE1/\x97\xAF\x93\xA2\xCF\xBA\x99\xCAO\x8C\xAE\x1A\xFB+\x01\xC2\xA3N\xF9\xDD\xAC\xBDJ\xDA\x85\xFF\xC9J\xFCM\x93\xE0\x9F;M\xDA\xF1U\x13\xAB\xFB\x81\xC6WY\xEC}\xB0\xB1q\xF4\x97\xB5\xE9\xEB\\\xF3\xAF\x19\xE5i\x15\xA8\x7F-g8V\x04\xDB~\xD8\xFF0E~\x1D\xFD;(\xF0?\x06ie\xF5\xA1Sj`\xF8\xB7\x98\x90\xA0\xC9\x8B\xC8\x7F\xAC\x1F\x95i\nV\xE7\xB0\x96\xBBh9\x99O\x1A\xDC@T\xC1\vE1j4\xD8K\x07\xB0O\xC5\xA9_Y?U\xF1\x82\xEB\"/\x00\xAF\xAB\xF8)\xEBH\xC3J4X\xE4\x1F\xDD^\xBB\xEE\xD8\xCB6t\r\xA4\x9D\xA7~\xE5]\x94\xD1p\v\xDB\xF3\xDA\x17\x8E-Q]K\xDB\xD2\xB6\xB4-mK[\x19'_FV\v\x1E[\xAD8>JM\bW\xBD]=Sy.\x8C\xB2\xE9D\xF4r\x8D\b&\xAA6\x8CF\xA7f\x99#@\xA9\xC9x9\x95E3\x05\xC9\x7F@\xEF\x95j\xBD\xAE\xF2\xF3b\xD7\x94*\x92 \xF9\xFE@\xFC\xAF\xA9\b\xE3i9\xC62~\f4Kag}7O\x953\xD8LMAu\x82\xEFo)\"\xBA#X~.\xB0f\xC2c\x1C\xEE\x9D\x8E.\xB7=#5\x153\xEB\xE0\x88m\xF0\xB4\xB8\xA2\xA9\xC9\xBC\x9E\x06p\x96r\xB8v:X\x06\xF2rhd\xFA\xE0e\xE1$\x152\x06>0+\xE4\x81\x7Ff\x07\xF3<*5N^\xF7\xB0\x1B\x7F{\x15\xBF\x02+d\xA2\x16ke\x97\xAD\xEB*\xBEpN\xE2\xD9\x8D4\xC9\xC72\x0E\xDDC\xFE\x86\xD6\xD1\xF0*{.\xAF\xD4\x99,\xD6\xFA\x9D\xBA\x8Ax\xAA|E\xA4G\x9E\x95X\r\xCAG\xE6,\xD8\xE5\x0EY\xA2\t2\x95#\xBF\x96\n\xFC\xE2y\rG\xCE\x9F,?\x17\xC8\x15f\xDD\xD7\xFCm\xC1:`\xE2k\x9CL\xDBT\xF9\x02\xD8\xFC\xD2\xA4\xEA\xD0\x834R:\xCB\xE6}?:r\xB2l&\xBE\x9C \xAF\xB1\xB7\xE0}\xD1\xAFK9\xBC\x7F*\xAC\xDA\x9D\n\xB9\xF0\x0F\x85\x11b\xB3i\x8E\xFFLw\x9B\xF3S#o\xF9\x05\xC0\x14/\xD6\xEC\xB9\xD4\\\x0E\xA7\x1B\xF5\xF7\xA7\x9D7\xE5\xAC\n42\xFC#\xFF\x9D1\xE4\x8D\x83\xD3\x8D\xE9ire\x83\xB4D\xCE\xBF\xA7\x01\x8D\x02\xFF\xC6\xB9_7R\xFFB\xE3u\x17+\xD0\xD6+\xF6l8N\xA7o\xB2\xD2!\xEB,\x83+\x9C\xE2\xBC\x83\x1DQ*\xFFi\xDE\xDA\x84\x86\xF8\x0E\xA7m\x9D\xC7y\x7F\xB7\xA6'\xDD\xD7\\\xAEG\xEF3\xD0\xC4\x03\x9F\xB6\x96\xDF2\x94\xB1i^;\xE2\xAESE\\\xD4\xCD,\x19\xE8z(Q&\xFF\v3\xBA\x8D\xBF\x1Do\x16\xC9A\xD7]\xF8\xBBY,)\xCA=\x97\xA26A\xC2Nh#[v2\x90\x16\x13v\xB9\xCC\xAD\xF9T\x92\\0\x15M9}\xEC\xB2\xF3\x967\xFEYT\xA5\x91\xA8rj\xC3\xF1\x12M\xF1\xAD\xD2D\xBBy\x9AgX\xACn\x96\x95\x16\x9E\xC6Ao\xA9\x90\xFF[*\xF6\xE8:K\xD0\x11\xEE\x9E\xD1]\x17a\xD9\t\xE2\x1D\xF4\xC7\x85\x19\x87\x18\xEF>\xEF\xF4\xB1S\xD4\xF7\xEC\x98\xF1\xE8\x9F\xF7g\x06\xBFdb\x81\xE3?W!\xFES\xB6\x83Vs\xF1\x00\x1BD\xB0\xDFS&\x06\xBDzF1\x10NM\xFE\x1E\xF8\xBBSv\xDC\"\xF0\xFF-o\xFC1\x11\r%\xAB\xF6C\x89\xAA4\n\x91\x91Zy\x8B\xE2\xDF\x10s\xE1\xDF\xA9\x89\x1C\x02r\xA1M\xA3\xFE\\\xFF\xB6.9\x9DP\x01y+\xC3\x7F\xB3\xAB\xE2$\xFCV$\xCA\xA2\x10g\xA2\xEAG\xEB\x9F'O\xB2\xDCP\xD6\xC1`\xC1\t\xB9\xE7\xA9\x8A\x06\x99\xFE\x19\x1F\xE1h<\x0F\x14\n\x8Ed\x1E\x99\xE3\xFD}f\xC4\x03ro2\x9E\xD7\xD0lx\xB4}\xA5\xFC;\xBEB\xE0\xC9\x1C\x9E6\xB8\xFE\x997\xF0\xD4\x9Cg\xB6\xBB\x9C\f\x10ZU\xFCgu\xCB\x95\xED\xC4\x8D\xFF%>X\x88@MM\x12I\xDA\xE5\x98\xFD\xA6GU$\x1D\xFC\xC7\xE6r\xD0\xD3\x0F\xC7F\x1Dq\xEA\xB0s8\xC8\x91f\x83\xDEZNv\xC8\xE9[s\x80\x9C\xA1\x01\xA2L\xFEU[\xFE#k\x18\xFE\xEB*\xE5\xBF\xF2\x89\xA8\"+]\xFBt\xD6\x8E\xC4\xE6\x92#%\"tD\xCE\xA7\xF8i\xD7\x9Ahs\xE1\x1F\x13\xD4\x87\x9A\xF2\x80\x9C=6\xD8R\xC4M\xC6\"\x9E\xE5 \xC7\xFF\x06\xD5Ie\xAF\xB2 s\xDA\x98I\x03\xEB\xDA=\t\xED#\xC0K\xF28\xEAJ\xCC\vl;\xDD.\xE5\x90\xD8\x13\xBE\xE4\xE8\x7F\x17\xFE\xA1\x18w\x19\b\xFDo\x86D\xCB\x1B\x13h\xE4\xAC\xDEE\x15s\x02\xFF\xB9g\xAC>\x133\xAF\xE1\xC21\xC5M\xA8r\xFD\xDF\x18\xB9\xA0\xD1\xA1\xA7q\xDB\xF9s\xA5\xB9\x1C\x11\xA4\xD3d\xFF\xD4o(\xF1..\x1E{\x7F\x86Jcc\xB4R\xFF\x7F\xBE\xE2\x89|\xE9\x1D\x8Aum\xF8\xC1k\xC2\xA8\x15\xF83\xBA\xBBv\xF0\xF3\xEF\x10\xFCK;\xF9\xC5\x1F0\xF0\x85_9\xC8|\xFE%\x9E\v\xA8\x7F\xA7G\xFE\xE5k\xE2\xF7k\"\xE8\xB4nv1\xF9\xFFR\xCEa\xDD\xBFd\xE2~\x03\xAC\x01%\x03\x7F>\xE7\xB1?W\x18\xE8\x19\xBEPU\xFE\xB5\xB4; \xC1EEJ\x02\x7F\xA1j\xBA\xA7\xC5\xD3\x91_\x87\x9C\xB7\xF5\xBF-\xFF=\xF9\xB1d\x0E[\xA2\r\xD1\t\x07\xFF\xB8a\x97\xCA%\xFA\xDF\x96\xFF$\x95\x7F\xA6\x7Fh\xC5[ar\xCB\x93*\v\x99\x96\xF3\x95\xD2>Q\x11\x92=\xD9\xF6e\xA6p\x0E\xB7Y.\xFD\xD3\xC3\x04\xF5i\xEA\xCA?\x94,\xD8\x1Ac2\xD6\xEB\xB2\x7F\xB8Eq$\xE9\x11\xF2\x859\xEB\xC9\"\xBE\xC5\xFD\xBC\xE3\x15\xF6\xCF\n\xDB\xFE\xB1\x17\xD1\x14r\xCC\xFE\xF991\xF94<\xD3\xFE\x932\xFDO\xF5\x8F^\x89\x7F\x87\\\x1E\x10\xE2\xE0_\xE3\xC1?n\x13\x95\xF2\x8D\xF6H\xE7\xD6\xFF\x02\xFF\x87c\x13\r\x1E\xFCy\xD6\xD1B\xBBI\x95\xAA\xBC\xADS\xDF\xC9\xF4\x0F\x1D\xB3\xA2\x14\x7F\xFB\xE2?ly\x87>\\\xF9\xB5J\xFD\x13\xA9\xC0\xBF}\xBA\x87i\x89\xF6\xE9\xB0K\xFF\xB0\xB2\xB9\x83-\xD3D\xFE?\x8Csxc\x06\xDA\xCF;\xC8\xB4\xFC\x98[\x89\xADq\x0F\xFEA\xBA\x10\x98\xFBM\xA4\n\xFCC|O{\xCE\xB1\xFF\xD7\x9B\x8C\x19&?\xFDN\xC3\x7F\x9C\xF38U\xC3\x06\x9A\x892\x8F3\xFC\xD7\x8A^|*\x87\xE9].\xFCk\\\xF8\xD7$\xD1\xC0\xF0\x7F\x96#y\xB5\x80\xA8.\xCA\x93\xF3\x007\xAA\x8E\xFD\x13\xFF\xCEH2\x87?\x93%5\xE5\xCC>\xBEb\b\xFD_\x1B\xB9Q\xC5\rE\xA06\xD9\xA9\x97\x1E\xCA\x01\xB5L\xFEi6\x1B;\x03\xBF\\\xB8\xF1:\x8A\x7F\xADvC\x05\xDA\xD1\x8A\xC5\x0E\xB1\xC8\x97\x19\xFE\xB1\x88{\xFE\xC5\xD2\xB2)\xD1\b\xD9\xF3\x1D\xB1\xD6\xA9UC,v\x9Fs\xB58\xEFQk\xE4\x19\xF75?\x99\x8A\xB6\x9Bh\xE48T\xE4\x9A\xE5%\x93\x88\xF4F]\xAB\xB9\xAF6\x00\xE9glUB\xEBm\xD3\xEE3\x9A5$5g\xFC5E\xBF\x8E\xABh\xD8\x18\x8E\xD8\xAFy\x83K\xFF4&\x01:*5r\"z\xFAU\x91F\xA9\xE1Sh\xBC\xD1\xBE\x82m\xFFO?\xFD\xCE\\\x0E\xC7oox\xEF\x11G\xFB\x1D'8\xD3n6D\x8E\xABx5\x074\xC8\x9F?\x95>\xA1\x02\r\x99_S;\xF3\f\x99#\xAC\x15\xAA\xFB\xFB\xC7\x9B\xA9\x7F\xA7!w\xBC\x02\xED\x9FV\xBC\x11\xA7~IS\xEB,\xB3N|!\x8C\x06\x81\x7F\x03\xCD\x1A\xD4`\xBD\xFCKZ-\xF7:\x9E\xDC\xE65\x15\xA7\xCE;\xB4\xF6\xF1W\xF9\x82\xCDS\xD7y\x94|\xF1\v\xC7^\xA0\xF1\xF9\xF4\xCA\x15\xF8\x87\xF8\x15N\xF5\xE3e!\xFF?\x06^\xED\x07\x96=\xC7\xF2\xD0\x9El\x8D\xBB\xCF\x18$\x03\x9F3\xFF\xF5\t\xFC\x15\x15\xD7\xAB\x0F\xFF\xCE\xE9\x94;?\xD5N\xD4P\x11\xF0\xED\x116\x85}\xCDi\x80\xB7\xA1\xCE\x84O\xB4\xA1\xE1tJ\xE9\xC7\xC7\x8A\xEF\xD5\xECq* (\xFD@\x03\x1B\xAC\xFF\x8C\xCCg\xC9\xADW\x1E\xD7dZ\x04p_\xC8\x04B[i\xBAQq\xEBe\xD3u\xD3t\xE5\x88\xEF\xAA\x95\xE6\x12\xE3\xB5\xB4-mK\xDB\xD2\xF6oy\xB3\xE9\xD6\xDF?\x8F}\xB5#\rwu\x80?\xAC\x052\x8D\x13\xF1\x95\xB1\xC4NN\x18\xCD\x87\xCAX\x12\xBB\x94@\xB8\x8A\xC7\xA1\xDA\xE6_\x94\xED\xFFC\xB7\xCC\xE5p\xE1T\x8FR\xD5\xB7\x92\xA9R;`\x05\x10\x0E\x99\x1F\xAF@\xD5\xDD\x17>\xC3\x95\f\x8D\xF2\xE17\x9D\x06BE\xCC\x18a\x1Fp\x1A\xE4\xAFd$>8?\xF5\x01+\xDD\xCB\x90\xF1Y(Z\xB4\x8E\xF0\"\x0F\xCEg\x01\r@\xD6o\xEA\xAB\f\x04\xDA\xA7\x96\x99\xF85\xC2>Z\xF7m\xD5\x99\x1E^\xDC\x13[%A\xB3\x87\xCCr\xFCg\xB40\xEF\x99O\xA9\x8A\xBF\x9F\xA5\x9B5p\x85V\x82\x0F!\xB3\x17\x8D\x93\b)\xB5&\xEA\x84\x9C\x84LHE\xBB \x1B\xBD\b1\xA5\x9C\x00\x8COP+\xA8\xAE\xE8\xC1\x9F\xE5\x12\x974\xD4\x16y\x0E\x99\x16\x13\vt\x99\xF0\xC2\xF9\x13\bq\x9B'\x04\xFC\xEE\xD4\xCE\x0F\xD9,{F\xFB\xC0m\xF6\x84T46!4xv\xCD\xC3\x0EG\xE1\xC5\x9C\xDE\x89[\xF8\xE7\xCFm\xA5\x9C\x86\xDAmbVC\xDF\xF9\x81\xF7Mt\x9F\xB3\xCEh8w.\xA1\xA6\x14\xD5\xC0\xEFL\xFC\x82\xC7\xE44\xBD\xDF\x98Bh\xC0\x8E9Dh\xC0kjF\xD0x\x11\xCB\xA2g\xD6X3\x1A\xCEF\x94\xD9\x1C\xBA\xCF\xF5\xFEv\r\x99\xA1\\\x1C\xEE=\xCB\x0F\xBB@i\x16\xD2\x1ES\xF5\xD0\xFE\xA4G\x8Cqm\xDC\x83\xC6\xA9\x8A.\x90\xEDm*q\xEF\x17\xB1p.\x8D\xC6\xC9\xE9=\xCF\xC3?\x8F\xC0\xE0L\x0E3.\xA6hN\x03\x1Ai\xFA\xDFF\xCE\x0F\xA3\xD1y\x9A,j}\x96\x07\xC0\xF3h\xE4\xB9\x1C\xA7\x80\xCE\x9B\xBC6\xEE\x87\x1AZ\xBB\xB7\xD2e0\n$n\xF3\xAB\x06\xD4\xF8\xDAf\xEA\xDBj\x92\x06U\xB7r\x90\x06\xE1/A\x8Aw\xCFX\x0EG\xC1{\xED\n\\\x11Ym\x93\xF9/\xDFL\x19\xF2\x0E\x9A\xEAGO\x87u\x15\x89h\xAAKC|\x87\xF5_N\x11\xF9o\xB6\x97\x96\xFB\xAD\x0E\xF9y\xC8\xE1\x847$\xCC%\x9A\x11\xC8Y\xD4&\xFA\xA2\xBD\t\x15\xDD\xE7\xA7\x929$\xA2Y5\xFFs\xA2nR\x93\xA2\x90e\xB6K\xE4\xDE\xEFt\xBD\xBE\xBC\x1C\xA7\xCE\x16\xCB\xBF\x07Y)\xEF\x82`\xC5\x19Q\xA0\xA7K\x90\xD7\xDD>\xD3\v\xF9\x19\x84\xA2\x1Br\xD8\xE0Z\xFE\xA3\x93[\xB02\x82\x03\\\xFE]\x99x\xFB\xDC\xF5OE\xA9\x88\xDBY\xE9\xE4\x1C\xB9\x05\xC3\x7F\x8B\x86\x0F\xBBz\x04\xFE\\\x05\x9D\xE8G$\x12n\xA1\x07\\B\xF6j\xB7\xFCK\x06M\xC74\xD8\x15]\xEBp\x14\x1Cs\x97\xAC\xCA\xB7\b\xFC\x93\x1Bs\x80<qK\x11\t\r\x1B\xD2\x03I`\xC3\xF1\x01Z\x97\x90\xCB\x7FK\x11\x1A\xAFE\x92\xDDp<\x05y`C\xB1\x9A\x07\x04\xB48\xB2\xBF\x04\x7F\xB4s&|\xA7\tMRnU\xA1\xEB\xE1\xC8q2\xA3\xB9U\xD7\xBB\xF8\xDD/R\"w\xB0\f\x7FQ=\x909#\xF6\xC3\xBF\xCE\xBDt\xC2\xDEn\xD6\xF8\xC1z:\r\xFF\x03\xC9\xFC\xF3\x04g%\xFA\x19\x8D\x03\xC8\xD4\xE2\xCDE\xF0\x12\xCC\xEC\"\xF5w\xBBk\xA7n\xE1\x95R\xB9\\q4\xE8\xD7\r&n)r\xFC\xFFJ\xC3\xE1N\x82\xFF\xAA\xBA)\xD4elzd\xA0e\xEA/\xA9\x10~\xFA\xD8\xE46\xB7\x0E\x96\x06\x88\x04J\xF1\xAEh/\xE4K\x8B\xBA\xAEm\x92\xF0\\\xB2\x83\xB4\xB3dR\xF9\x9FI\xC7n6a\xCA\xFA\xC6~\xDC>\x93X8?\xB5@\x89\x9AM\xA2\x16L\xA7\xFE<\xE4\x98\x83\x99\xA4\x97\x8F\x88\xB2\n9\xDB\xB9\xC6\xD2\x80\xBE\xF3S\xB7\xF5\xE3l\xD4j\xA7\xF4\xFB\xBDG,!\xFF\xFB\x88\xFCSm\xB0\xC1\xBB\x0E\x85\xE8\x7F\x9D\xD1\x89s\x90\v\xF6:\b\xF7\xD6\xA9r\xA2\xBEo\xA6\x04y\xEA\xF6\x19\v\x8Ds\b\r\xDE\x92\x83]\xB3\xB2\xDD\xA4\x89\xA9\x99\xFC\xD3\xDA\x9Dd\x8E/;k\x9A\xD8:\x8E\x8D<\xC7\xB5\xE4\x96\xFF\xB8\x81[\xFB9\xFE\xBF\xD1\xF0aw/\x80\xE5r\xC6\x0E\x9A]0q\xEB\xCC\x18km\x8F\xAE\xDF\xEA\xD1\xFF+\xD0\xD8\x8B\xD0\xE0\xF9sY4z\xF3\x05\xBAu\xA9\xD0\x84s\x87.\xBDc\x00\x8D\xB9n\x13&\xB0a\x8F\xF5\x1B\xA2\xB1\x07N\x03\xD3{~\xBA\\Vu\x8DhZ\xAE\xFF\x1B\xB3\xEF\xBEF\xAE\xF3nq1\xFD\x7F\x15\x91\xA5F\xEB|4k\xE50\r\xC3\x04\xE2{R\xBF\xA6\xFA\xD5T$\xAE\xFF\x1B\xC7\xCF\xAA\\,O\xBB\xCE>K{\xB4\xE15\xA6\xFF\x9FF\xE3\xBA\xAA\xFA\xFF]\n\xDA\xBBE\x9Cn\f\xA316\xBDg\x05\xFCm\b(\xBF\x02\xCE\t(.j\x98\xCE\x01\x8D4+r\xE3\x00\x97\xFFF\xC7\xA2;O\xBB\xF0\xAE\xE9\xD1\xFFl\xF8x\x97\xC6T3\xFC\xFD\x1A\xFC\x9DD\xFF/\xAF\xCD\xA06c\xDB1\x0F^\xB3\x9Fq\xE9\x1Ft[\x0Fy\xE4?L\xF5\xCF\xA6\x0E\xF9\xAB\xEE\xD2\t\xF0f2\xB7\xDF\xEBd>y\x97\x01\xC8S\x9AF\x04FO\xF7v\xE5\xD0!k\x9DD\xFF\x7FaM\xFA\x1A]#\xF2/\x8A\xC2g;d\v\xF2\x80\xB3\b\xA8,J\xD3?\x8DF\rr\xA1k&\xDBC\xB4h\xA2\xDB\xC4\x86\xE3Vt\x07\x11\xBC\xBE_\\\x12k|.P\xFD\xA3\x96\x05f\xB3\xCF\xDD,*]\x9E\x84\x7F\x11\xF9\x17\x05\xEE\xBB\xCFX\xF0O\xD1\x91n\x06!k\x8B\xDDN\x1A\xB9q[Q$3a\xEA\xA5\xE1\x1D\xD49\xB5lX\x01V\xEE\x1F\x17\x85\xF2\xBBD\xB9\x19\xB6\x14\x82\x8D\xBF\x1Fv\x12\x18[\xFD\x19\xF89\xFE\xAB\f|f\xF5{,\xB1L\xEF\v\"\xAB\x0F\x07\xE4\x1E\xC8wA\xEA\xE9\x9E\x89]\x16\x7F>\x94'\x0F\xDDO\xF5Of\x83\x86\xDB4\xF4\xCD<\x7F\x8B\x89\xCF\xE9\x03\x9D\x1AnO'\xB5\xCF\xFFp\xA8H\xFA\"\xF4\xB6\xD5=\x93\x82\xFC\x92K\xFF{\xE5\xDF\x1F$\xA3\x8C\x9C\xEDZm\xF5iH\x1EZ\xD1\xA5b\xE3\xFD\xA9\x963\xBD\xB4\xCB\x9A\xC6\xD7\xD6e\xA9\x9Bu\xD0)mo\xFB\xFEl/\xB3\x7F\r\xE4'\xAA\xEA\x7F\x96\xD6oC\x11\x1Dr\x1A\xF2dW4I\xDD+\xDA\xCD\x86\xF34\x9B\xFB\x89\x0E\xE7\xF8s\x03^s\x97me\x9A\x90k?Q\xD3\x9F\r\xC7\xDDErq\x96E\xBFS\x83\xBF\x9B\xE8\xD8\xD5D\xFF8\xFA?\x19\xCD\xB2\x87\xD5\xDB1\xEF\xD1?\xD2&\xC8\xE3\xA8Iv\xD4\xAE)\xC7\xBF\xCE\x85\x7F\x1D\xFF\xA9\xEF\xDD\xDE[rD\x00>\xA7\xE1A\x03\xF7\xA7\xC3_6\xF0\xCA5\xFA\x83@|&q4\xADj\xC0\xFFj\xAF&\x90\xC3\x7F\x19\xB5P\xE7\x92\xFF\x1Aol\x95\x7F\x8E\xC8\xAD\\\xE8\x8A\xC6>\xAD!y8\xD2m\xE2+\xBA\xA5\xEE\"\xB7\x1B\xFA\xF1\xBC\xA8i\xF2\x1C\xC5?\xE3Y\xA7 \xE4\xFF\xCF\x0FQ\xDE\xB2n-j\xA7\xDCK\xE7\xEC\xED/\xE8a\xFF\x87\x86\xBEwJ\xA8\x9D\xEA~\xE7\v\xA8\x9DC\xCD\xFC\x97L\xFC\x85\xB0\x7F\xFEg\x03\xF7\xE7l\xBF\x1E\x85\xB7\xAE\xE4\xB6\x7F\x1E\xA0]\xB8[\xF3\xC8?\xEB\xD7\xE7\x8B\xF8\x8A\xC6\xF3h}\xD8\x8F\x0F_$\xFA\xA796\x02\x85{]\xAF30rbO\x866\xA3\xF7X\xC63y\xAB\xD9\x84P\x13\x1A\xF4\xD3\rq4z]!\r\xAE\xE5o\x82y\x9E\xB9-9O\xF4d\xDB\xCB\x1A\xFEQ\xC5\x89\r\x03\xE9\x1C\x96_7p\xCC\xC0\xCC\x9E\x04\xD2\x11M%\xFA\xF0\x82X\x93\xF8_\x9FI\xA1A\xFF\xDF\x8Cjc\n9\xA0\x01\xB5ch<v~\x8Dn\xE50\x97;~V\xC5\xCB\xAFEo<L\xF0?\xA1Q\xE6\x9C\x1C\xF6s\x1Af\xA3\xD8:\x9Fml,\xF8\xA7vZJ`\xD9Z4d\xAA\xEA\xFF\xE3\x14\x99\x97\x8B\x98\xD98\x8E\x06\xE3\xECu\xE3hh\x03\xF4\x175\xBC(\x04\xE3\x1F5\xBCh;\b\x1A\xBE\xC7T\x8E[\xFF\x9F\xA2\xF2\x7F\x9A\xDB\xFF\xDC\x9D\xFA.\xFDz\xDC \x17gU\x8F\x1F\xCD\xE1\xCE62\xFFZ\xDF\x9A\xB2\v\xDA^\x9D\xC3\xBE\x80\xC1\xDC\xFC\x8FG\xB6\xEDs\xEB\x9F\xC6)\xE0z\xE0\xCB!s7\xF0\r\xEF\xE4tg\xE5\\x\xA5\xFAF\re\xFA\xE5\"V\x9A\bo\f+\xFD\xA8\x83\xDE\xD0\x8F\x95F\xC2\x17\x9AZO\xE7\xBF|M4\xC2J\xBF\x05\f\x9C2\x17\x99\xF5\xFBn\xC0\xB2/\x02\x96\xF4\xD9TS\x0E\xCA\xE7o\n\x99\x90\xB5c/\xBFM`\f\x9D\xB2D\x1E\xFE1Ze\xC6*\x9B\xFF\xB2\xC8\xB4\x9A\xED\xD4C!\xDD\x01\xDF`\xD5\xF9/\xCB\xAEIZ\xD8|\x03|\x83!s\x04x\x03!+\xA0\" \xA0\xF0\xA9\xB4\x90\x1Fg\xE9\x7F)\xE6\xBF_\xB5/\xB2\x92\xCE\x9E\x1AY|\xA0o\x8D{g\x9D\x89\x8F\xF7\x83-\xFC\xBC^\xC5\xF7\xDAV\x00x\xE1\xDC\xA0\xA8}\x8F\x92\x89w\xCF\r\xB2\xB1{_\xFB\x9Ew\x97h\xFF\xA5mi[\xDA\x96\xB6\xA5\xADr\xF3\x85U\x16R\x83\xB0\x1DN\xC3\xD2\b\xC8\x9C\xBB\xD6\\\f\xBFmYj\xF6\xE7J\xDF\x80\xC2w*\x92\xE6\xFD\xD1p\x0E\x90%\xD5\x0E\xAC\xF3A\xA5?\x85\xCB\xA3\xFA\rJ\x8A8\xFC\xA1V\x95-\xF7y\x12\xFA\xDAT\x8A\xEA\xE2\xC0\xD5\n>\\\x95\xC4~I\xFC\xE5Q~|\xBF\xDD<\xD5\xBE\xB8\xE4\x1C\xEF4^\xAArq~\xB0\xEC\xF9J\x8F\x94\xA6\x10\xEAY8\xEF\x044.\x9C\x0E\xD3 ^\x8BFk\v\xFC\xD3\xBB\xFFHE4-\xF0\x97\xACy\x831\xDEq\x16\xC6\xB3`jC,P\xA3\xAE\xA4\x02\xA5\x90\xE5N\xD0\xAD\xABl\x8D\x06\xC1\x7F\xA8\xB8\x92\x96\xCA\x1D\x04\xF4yn\xCE\r\x06\xB0\x96\xE1/\xD3\xB8 \x82\xFF\xAE\x12\x10\x1E*j\xC0M\b\xE5\xC8\xD5j\xE6ahQc\x10\x86XU\xEA#\xF6\xE1z\x9E5:\x8C\x9A\xF9\xF5\xA3\xC4F\xFAu(\x8C\xC0\xD4\xFF?\xF0\xF7\x87!\xF5\xB6J\xCE\x91\xDBC\xD6\x87\xCC\xF7\x14\x18d\xE1\x1C\xAA\x81\xA1\x99\x1FN\xABX\x98a\b[\bf#\x06\x9D\x8C\x87,&\x8DiU\xD3[8m\xBE\xDE\xC4\x93\xA6\xE6N<\x12\xD1P\x1A\x1DC(s\xA9{J\xEF\xCEC\xD6!\xF5 \xA4?\xCDK\xA66\x85G\x8F/L\xAFciuu\r\v\xE7\xA7>\x98\xD1\x11\xB2\xA2\xBBJ\b\x1DC\xF08\xB9\x9A\x94Xx{~\xE1|v\xC1\x14\x19\xA1\xA5\x9F\xD8)\xA4\x82G,H\x89\xA8A\xE6b\xABN[l\x8D\xBC]Fp\xC8U\xB9\x80|p\x7F\x16\x1F\x86\xDE\xE5\xFB\x87\xDE\xE5\x7F\xD9\xE9|?\xFB\xC9u\x9D!\xD39\xD2\xF9U\x9C\xEE\xB9\xB88\xD8\xDD\x1E~z\xE8u\x84\xC6>\x94\x9C\x80\x96\xFF\xDB\x17>Ldr\f\xA1(\xCB@\xB2`\"<z\xA2\xC5\xC4\xDE\x16\xC6\x07\x8E!d}\xC0\bs\xEE\x19D\xBA\xC5\xD2\xA3l\x1EZ\xD2T\xE4o\x9Ew\xCB?Q_#\xFB\x11\xB4\x8E\xCC\xE5\x87N\x1E#\xF2\x1F|\x03\xBE\x07x*\x92@\xD3\xD0\xC9\xD4\xF2\xD04[\x04=T\xC4\xE1\xE0\xB1\xC9]%\x04\xC7\xAE\x80\x8E\xA0\x81\xE0%&\xFF\x93Fbo\xDB\xCF&\r\x91\xB6\xCB\xFF\x80-\xFF\x1F\xCC\x8D\x11\xF97\xC8\xDC\x7F\xB9/\n%\xE3VO\xBA\x9B\xCE\x95U\xD7g\xC7\x97F\xD9\t\xF2Bi\xB4\xC0bB\xE6\xCBZ\x12\xECx{\x8D\x93\x88d\xD65\xC4\xD9N\xD9\xB3\x02J\xB3C\x9D\xFDMnE\xB9Y\xCE\xD8KMz4\xAA\xAF\xE50\xE4'P;\xF9\xD4\xCBN|\xE0S/\x97>(\x02\xC1\x1FA\xB1\x18\x01\xAB\x1AX\x95\xCEDT\xEC\xE5\xE1hc\bf\x9Ff\xFA\xA7\xAE\xC4\x9Ei:\x1A\x1F\x9A\x893\xF9\x1FRQ\x8A'\xDC\xF2?d\xA242\x81`\xA6\x90\xCC\xEBI\x83\xC8\x7F}\x0F\xA4M\xBC\xBE\x832!\x07wGh\xCE3&\xFF\x87\x83\xF9\xC9\xB4\x8E\xE0\xD8\xC2y\vA\v\xC1I&\xFFO\x9D\xB7\xF6\xB6\xE5\x0Fk\xB6\xFC\xF7\xD8iTS\x05&\xFF\x1A\x8D\x99\xD4\xD9rx[\x04^6D\xE9^\x1A\xA8\x86\x86\x87\xC5gQ\xC9\xB7\xA1\xF4\xD6/\xD3,\"\xF1\xD4\xAB\x19\xFA\xB7\xC4\xE6\xBC'~ea\x19\xFD\x07\xBCe\x80}`\xD3\xDE\xB7~E\xF0y\xEBW\x16\x1AJ\xB6?\xEE\xCD?\x16b\xBF\xCC\x91\xFFWT\xFCSC\xE6M!\xFFo\x15\xF1\x96IO\x94\xF3\b\xEA\x05\xDD\xD1\xFF\xCF\xEB\xF9\x82F\xD3O\x85\xC2\xE4-\xE0\xFA\x7F\xEA\x92\x8AU\x8A\xD0?T\xFFS\x87\x91\xCE(\xC1t4\xCE\xF5O]\xE9\xB0\x8A|2\xE9\xC6_W\x91\x1F9F\xF1?\xAE'\xF3T\xFE{ \x9F\x10\xA9\x036.\xCC=\xBBb\xF4\x98-\xFFG\xE6\xF6\x1D\x99\xD1\x11,\xAC0t\x043\b\xBD\xC4\x92\xCBM>2\xBF*\xF8\xB3\x82*\xE4\x9F\xAAG\x96F\xF8\x83\xB9\x14B\x16\xD3\x90\xADm\xDB \x07\x1Dw\x15\xF3\x94\xD9\xD4\x90\xDF\xB2\x991\xC8\"0^Non\xB1\xE0'\xEF{\xA2\xF3F\x9AI)\xCDX\xC4\xADy\x95\x9CK\xA5\x9AV\xC9\x8C\xD8\xE4[\xDC/S\x81\xCFB&\xF3\xFA$mU\"_E\xFE7kD\xDB\xD8\xD9Hz4\xF4\xA8\xE8\x8D^\x8F\xDA\xEF\x91f\xDF\xE2\xC8\xFF#\xDD\xD6\x07\x1A\x10\xCC\x13\xFD/\x95\xD8\v\x1E\xDEE\xE4_\xCDh\xDC\x9F\x1D\n?\xC5\xF4\x8F\x90\xFF\x85\x998\xD7?\xD0\x8E\xAA\xC8\xDFz\xA9l\xFC\xCD\x8F~\v!\xEBR\xF7\xF8\xD0\xA9<\xF7{*\xB5\x93\xC2\x92\t\x8F\x1AJ\x92\x17M\x88\x1A\x98\xEF\xCE\xCF\x13\xCD_\x88v[\be\x10\x1C[NT|p\xE1\xDD\x12B\xC6\x82igup\xA2\x9D\x13\xA1\x12\x82\xC9|\xFE\xABD\x85^\x9BB\xDD\xA4\x9B,M\x18.4d\x15~{5\x8AH5\xE0\xBF\xB8YN\xC3?\x00\xA0\xFB%\"\t\xBD\xE9\xD2fN\xB9\xEB\xF4\x91\xA9\xB4\xE8\xA7\xE3\xFC\xEA\x00\xFA\xCE\x10|\xBA_\x8C\xB2\x9D,\x95\xF4\xE0!\xCBy\xD0b\xBB\xC5 \xFAGw\xE1\xDFgb\xCBL/\x96\xFD\x12>D^t\xE4\xFF\xD2+R\x1B\x11\xB6\xEF!\x10fn/\xD5\xC0\xC2L\xE6j\x13\voS\xFD\xEF/9\xF6\x8F-\xFF\xB6\xFE\x0FY\xADT\xFE\xDDf\xE3\x90\x89\x0F\x83)\x043G\xE6\xC6\x97\x07\xF34\xCFI\x0F\xD5\xE7l\x9C*\xAD?\xB9{\x81.\x96\xD1U\x82\xED\x91\xB9c\x93)\x05\xC1\xB9\x85\x89\x04\xD5??\"\x80\xD7_:\xDC\xBCi\xE8\xA45\xA9\n\xFD\x13\xB2\xEC\xB7\xFE\xFC\xDC\x98-\xFFG\xE6z\x11\x88\xB1D\rl{\x9D\xE8\r\x81\x7F\x83J\x83o\xD9g\x9B\x07\x1B\x7F\xEB\xD54\x96\x11\xFDsb\xE3J\x00?nH\xBFE\xAF|\xF2\xE9\f9w\xD9M\x00\xFE\x9B\t,\xE3\xE2}\xCAD\xF16\x99\x1E\x9Fe\x17\x9F\xA6\xBF\x9CxZ\xC8\x7F\x83c\x12\xFF\xB4\x1F\xFF\xBCq\xDFB\xCE\xD1?o\xA8\xF8\x7F\xAE\xCB\x12\xFD\xE3\x9B\xBF\xA4;\x8B&\n\x1D\xF3\x96\x06\x046\xDA\xE1\xAC\xAA\x81.\x99\xE8\x1F\xD5\x10\xF2/Er\x86G\xFE\x89\xFE\xE7\xE3~\xBCUE)\x99t'\x1E\xD1U\x1Cj\x1BAp\xBC\x90\xCC|r$O\x13\xE0\xF7@J\xF0\xE5E\xB2>SxV\xEF>a\xCB\xFFdr\xEA\xA9_\xBE\x87`>\xFA\xC8<\xD1?\xC1Y\x9A%F9r\xE6\xA2\x9E\xCC>\x95\xB3\xC7_\xA2\xFFs\xB4S\xC9\x82\x85@0G\x17\f\x1C\f\xF62\x17U\x87\xDBS\xE0\xC8\xFF&\x87\xD8\xF7\xDB+\n/\xF6\xEA%\xE6XO\xE8\xFD\x006\xA6K\xEC\xF4\x9E\xFC&\xF8\xDBX\x14K\x07\xAA\xC9\xFFq\xBE\xB3\x8F\xBE\xF2\x1B\xF3+*\xE5\xBF\x03\xD8\xD2\xF9\xB4-\xFF\x9D\xC0\x9D9li\xA1\xFA_\xCAD\x13\x8E\xFC\x97\xE2\x19Y\xA3Ku\xA4\x04\x8B3W\r\xFC\xE7\x99\x89\x11\"u\x14\xFF@\tR\xE4\xF3f\xB9\xFE\x17\xB3\xB3\xD4z\x15\xB8\xF5\x92\xDB\x97I\xF1\x7F\x8E\xE1\xFFO\xC9<\xA4(\xE47<\xF2?\x92\x1A:\xD9\xCB\x8E\x8C\x1Ax:91\xF9H#\x82\xF9\xF5\xA9\x04\x82\x05\x84\xC6\xC8\xD3\xAC\x99?\xBC\xBAw\xE8\xE4\xCF\n9!\xFF\xB4\x9E\x0E\xFB\xFC\x8B\xB9\t\xD4\xBC\xBE~'i\xC3\xB7Gz\xE1\x8B\xB9\xF1\x8F{\xF4O\x8F+\x1A_d\xA1\x93w\xF7\xEAi\x86\x7F\xF7\x8B;\x01\xFC\xC5\xFDiV\xF4\xB9'\x1F\x81\xFF%\x86\x7Fw\x91\x9E.\xF4\xBF\xD6y\ris\xDAb\x17g\x15\x87\xEF\x8E\xDA\xE5\x80\x1Dgw\x97\x86-\xB7\x9C\xB4\xF1\xEF\x02zs\xD82C\x97\x94J\xDBV\xBF\xE2L)w\x1C\xDB\xD6Y\xA4\xD5i\xE5O\x91\x7F\x14\x7F\xADnj\xC4\x96\x7FEE(~=\xB1\xF9\xAB\xE1_C\xFFOH\xE5\xF8\xB7\xA7\x10\x9A(u\x8F/o?\x0Ei%\x14\"\xFF|\xFE%\xEB\xD1\xD1\xDDz\xF2>v\xE4P\x11\x97\xBA'\xE6\xF7(\bMDS\t\x84NB\x89\xD1,=\xCA\xA5C\x17\xF5\xEE\xFC\x07\x8E\xFC'l\xFD\x1F<R\x00Tu\x98\x88\xE0\xDF&\xC7Y\x9D\x94\xED\xA2\x01\xBB\xC9\x1B-\xF0W\xB2\xCC:\xA5\x9F\x05\xC3\xAC\xA4\xBE\x9DI#\xB0\x8DL\xAF\x15\xA2\x7Fv+\xE9\xDD\xB4C\xA9\xC98\x02\x12\xA3\xAA\xC9\x05\xC5\xB9\xDB\x81L\x1792\x9D\t\xB3\xAA\xC7\xAC\xA0\xD2\xE1Vay(km\x04v\x1Ax\xEC\x81\x8C\x9DU\xE9\xA8\x89\xF1\x1C\xF6\xC5\xBE\ne'B{\xAC/:\x89\xE8\xAD/\xEDY\xD3O\x83\x7FB\xAF\x91\x7FT\xC0\x86f&>0\xC1f\x97t\xC5\xFA\xC6S&\xD2D\xFFo\xA4/+\x16\xDE\xB58\xFE\rk}\x06|\xA7\xAC\xAB\xBC\xFA\x7F\xC1l\x00\x8E\xC9\xDA}\x9F\x85\x8E\xD0N(\x83t>+\xE4\xDFxx\xE8\xD41v$Q\xA9\xC5uuo\xCF\x03\xDB\xE8\x1DW\x02/i4\xB9\x9C\xF4\xF9\xD2P\xF1n\xF4\x8B\xF1\xB7\xEE_l\xFD\xFF\x7F\x99\xEF\x10\xFD?K&2\xBFn\xAFe)}v\x89\x06<\xAB\xBA\nC\xD77\xA2^\xB8!\xEA\x85\x8FC\xB1\x9E~\xA0\x84z2\x1C\x1F=K\xAE\xF8\xC8\xA3\xD6\xB3T\xB4v\x9F\xB5\x10\xA8eU\x8F\x0F\x90a\xA8\xD6\xC6?\xFD\xCAKd'9\x80<\xDC\x03T\xFFd\x1E\xE2\x95\xEF\x10p\x96\x1B\xFC\xB0\x1F{\x95\xCCw\x85N\xDEN/5\xF6\xE0\xCE%\xBAki[\xDA\x96\xB6\xA5\xED\xDF\xEA\xA6z?\xAB\x97]\x05\xA02VV\xAA\xA0\xF9%/\xDF^F\xBDz\xE9\\\x0F\xF5%\x95\x9F\xABJU\xEE\xE5\x1CV\xD6r\xC6{\xD1_\x1D\xDF\x84\x8F\xEFWx\xD4\xBD\xEF#\xF2\xF0Hv\xBE}je!\x05u\x91\xF5\v\xCD\xE5N\x07\x84yj#U\xE6\x1E\b\rP\xC3.o\b\\\xFD\x95\xAA\xDC\xFA\xF7\xC1_\xAD\xC4_\xFA\x1F\xC0_\xFA(\xFC\xA5\xCB\xE2\xBFM\xC3\xB6\r\xF9K\x9A\xB6`\xB2p\n#\x0E\xC4a\xD0\xE0(\x83\x99\xFD\x8AH\xCB@\xA6\x00\xBEu]\xEA\xEF\x85?M\xA1\xAF\x94R\"D\x9Cf3\x18:E\xCB\x13\x1BX0X\xCE\"\x0E,\xAB*\xB5\x9C\xE7]\x8F\xEA\xC0\xF2\xD0 \xF95\x94\xBB\xFA\xB5\xDB\x81\x01;j\x8Be\xB4\xB6\xF1\xA7\xCB\xAEo\xAA1\xE0+\xBA\xC8j\x9B\x18\xAF\xAB\b\xA1\xA9\xF1\x90\xE4\x0Ew\xED\xB50\xDD|{\x19\xF5\xED\xA1\xD3M\xCF\xC1e_\xC9-LN\xB3\xDB\xF7r\x1F\xB6M\xA3\x84\xB41\x194\f\xE6\xACA]\xE9f\x13\xFF\xE5\xEDy] \xD6m\xD2\xFD\x14\xFF>\x13\b\xE5\xBA/\x1B\xF2\xB1\xDE\xE4U\x80\x1F%\x07[O\x9E?\xC9\x1BC\xB3\x10\xC8T\x96T\x9A\x82Ur\x15\x1A`\xCFha\x9A\x954\xB5ZL\x84\xCE\xC6Q7\x8F\xE0\xBAm\x89\x1E\xF6\x98X\xE41\xCB,j\xD3VQ\x15\b\xC9\xEF\x19\x18\x04\x12\xE9\xB0\xE7\r\x91]SB{\xB3S\x04\xC8\x88\xCB\x89\x04\xBDt\\\xF6\x88\x14\xA3\x9E\x9C\xE0@W936\x1BL\xEChc\xEC_B\xE3\xB1\xDC,F\xBA\xD7\xE0a\xFC\\\xAA\xFC\xE4xZ\xE8-\x11\x97\x93\xBA\x81\xCD*?\x8C\x1D\x1F\xD40\xACb8\x96\xDD\xDCRRX\xD2xY\xBE\xA8\".)\x17E\xE8\xE0{l?\x91F\xBC\xA7\x025\xEB\xDE\xBB\xAC\xFE\x89\xA8\xBC\xD2\xAB\x95\x03\xA4\xB6K\x85)\x9E[\x98\xE3\xAF\xB1\xEC\xF4\x7F\xCA\x01\xE4-eUMe\x96\xD8J\x0E\x0F\xAB\x98\x1F%\x88\"T\xDC\xF8\xA5sL\x02G\x8B\x0E\xFE\x9A\x90\xFF\x8Bd2\xA2\x8Fk\xA4\xA7'\xFE\xCA%\xC6\xCBJ\b\x95\x18\x95\xED\xD9\xEA\x126I~\xE9\x97\xF9\x7F-\xE2_M\x9C\xFCG\x8F\xFC\xBFEo\xF4\x96\xB3\xCE\xC5\xF9\x95=\xF4\x93\x7F{\xEE\x04m\xC6\xA9\"\xFE\x95\xB9,\xE9\xD7\xFFf\xF2\xB387\xBE\xEC\xCD\xB7Lr},\xB3\x16~5\xF7\xFF\x9A\xF8\x90\x1EvV\x1C\x964\xB0Y\xC3\xE6\xCE\x15\xCD\xBA\xCC\x8B\x9E\xD4\x95\xC6U\xC4\xAF\x9E\x7F\xBC\xC8\x85s\x9C\x92\xD8\b\x90f?n\x12ax\xFC\xB2\xF2\x1F\xA1\xF9mx\xED\xBF\xD0da\xA4\xED\x92\xE1\xE0\xBF`\x9E`y\xBC;U\xAA\x7FD\xD7X\xC0\xD5\xFA\x14\x8D\xCC\xAF\x1B\xEF\x02B\x818\xF9U1\xFE\xFCD\x1Cr\xDC\x8E\xDAe\xFAG\xA3+\xB6\xB8\xFE\t\r\xEES\xC9\x1B\xFD5\xDD\x15\x90/\xA7 \xEBU\xE4_\x12\x93ty<\xEE\xB7\xB6h\xD8\x94COg\xA4R\xFE\x9D\x8A\x8A.\xF9O\xD0\xAEm\xE9l\xBB\xD7\xE4\xCD\xE0k\x19\xE8\xC4\xF9^\x8D\x9F\xD5\xC3\x976Hq\xE0!\x8D\xC8\x7FO\xBE\xC7.:y\xA7\xC6+\xB9\xB4R\xF2s\xFD#\xF3\x1F\x1C\x975\x8D\xCB\xFF\x98\x8A\x0F\xA6\x95q\x91\xE6h\x1FK\xDA\x10\xC8\xF0\xE4n\x81\xFB\xC7.+\xFF\xEB\x8B\xB8D\xEF\xFEir\xAFu\x1F\x9C\x9F\xBA\xDA\xAD\x7Fjt\x16\x8Fp\x17Ko\"\xC6r\xC6;\xC9,JY\xCED\f|\xF50\x93\xFF\x1F%o?\xC7\x98=\x16\xA1\xA7\x8A\xA7\xC0\x1E\x07\xD1?\x81\x89\xF7\x8BD\xFE{\xA2.\xFC\xFD%\xF8/V\t!\xAE\x15\xB5q\xE5\xA7\xBBw\xA6\xFB\xFA\t\x14w\xBF\xE8\x89df\xD4_\x9F\x89r^Q\xFCt\xDFj\xEBs\xF4\xEE[M\xBEg\x9B\xC6\x1D\x13l\x90\xEA\xE3\xF8\xCF\f\x99\xE4\x18\xF8\x7F\x9E\xEC$\xFA\x7F\x80v\xF3k&\xD8\xE3[\xAEA\xEFG\xCF\xFD\xB5\xC1\xFB\t\xFET\xCF\xCB\x17T\xC8\x92rQ\xE3\xC2\xF9\x1E\x1B\x17\x98\xFE\xA1\xA2\xFA\xFEe\xE5_\xD5x\xBE\xEB=D3O\x14b\x05\x1EgN\xF1\xFFxC\x9C\xB9Pw\x17\xE9c\x15!\xF4\\\xFF\xCFR\x00\x03\xE3\xBA\x86\xD0y*\xFFA\xFCn\xB8\x87\xD5C\x91s\x0E\xFE\xF6p|?\xC1_\xDD\xAB\x11\x1C~\xBE\xDB\x95\x99$\xD4\x86e\xBDh\xA8H\xE4X/\xD6\xC54\xA4\xDF\xFBB\xE9'T\xCF\xBCq\x9BG\xFF\x1F\xA7\x8D9a\x9F\xDA\xE0\xFC:K\xDB\xF0\xD6\xAF\x92\xFFJ\x7F}#\x87\x7F\xA6\x1FNj\\e\xB1\x0F<mJ\xE3\xFE\x13\x06}\x17\x96=\xF4\xD6\xAFzN\xAA\x94r\x079\xE5\x9FU\xDE\xEB4\x90\xAD\x9F\x9F\xAF+\r\x15Y\xEE\xEF\xD2^\x15\xEB_.=\xA6\xF1%\xAB\xE3\x1A5\xAEh\xD9\xF8\x03&WP\x97\xD9\xA2\x1AX\xDD\xF0m9@)\x14\n\x85A\x97\xFEg\n\xBF\x99\xBEJ\v\xA63\xFE\x8A\xAA\xD04\xC8V\x89dT\xCC\x1B;\xC9\x8B\x1FD\xF2\xA1$\x93@fw1\xFD3$\xE4\xFF\xF3D\xFF\xAC\xFB\xB5\x86M\x1Az;\x9B\\\xF2?G\xE4\xDF_!\xFF\xA2\xE62\xFCV\xDF\xF1\xF4\x90I\xC6\xC4\xBE\x17=\xB5#\xD9\x8D\xEC\xE2\xFBn\xFB\xA7\x9B\xA9\x97\xD5\xDB\xE8\xDBMd\xFBN\xDA\x8C{\xE8\xC1_1\xCA\x96\xB6\xCD\xF4\x15\xF1f\x0E\xF0\x87\xFF\xB3\xDF\xEA\x16\xF2\xBF\xC5\xC4\x10\xBD\x05\x93\xF9\xA1c\xCA\xAE\x19\"\xFF7\x13\x85\xA0\x8E\xA9P5\xED\x9B\x1AO\xCC\x925\xF0\x1B\x93R\xB8\xF43d\xF9\xF2\xFA_7P\xA0\xCA\xF0d\x0E\b\x9D,\x1B\x7F\x87^v\nl\xD1\\L\x1E+\x9E\xFD\n*\f\xFE\x96\x12\x94,B%\xB2\x93j\xE0\xAC\xCB\xFE\xD1\xC4\x1A\x8D\xEF\x11\xF9\x8F3\xF9\xBF\xDF\x8D\xB6\xFFFZ\xCA'Y\x81\xBFpR\xFB\x93\x9Btk\x8BJ\xB0J\xEC(V\xDA\x9F\t\xA7\xF4L\xBA\xCC\xFE\xE9;\x93\xBCW\xAC\xC3b\xFA\x9Fu\xE3N\x13=t\xBF\b\xF5\xFF\xC6\x83*\xEE!\xF8\xDF\xD37\xD3s\xB7\x8A\x9B\xE9\x95\xBF\xA6\xA1\xC3\xE4\xA3^\x10h\xAA\x99\xBF\xA4\x13\xFC\x07T\xC0\x17\x19S\xB1\xFE\xC7\xF3c\x06\x17\xCE\xBD,L+\x10\xE7\xF8\xD7\x95\xB2\xDA\xE5\xF0\xBFYd\xE7\xA4\xC5\x88\xF5h\x97rIs\xF0O\xEAy\xF6\x13\xFBg\xCB?s\xB0\xB2_!\xE7\x93\x1A\x86f\xA8k[\xCE\x93\x9D\x94/\x1Dr\xD9?CE.\x9Fy\x8A\x7FV\xC3\x98\x86|\xC2e\x7F\x06\xE6\xA0$=\x95X9\x98b0\r$\x0F\xBC\x12\x1F/b\xAF\x8A\xD1\xA0\xA7K\xAC\x83N\x11\x1Fe\xBE\xEC\xA7t\xEB\xB64\xBD\xFB^\x15\x8F3\xFB\x93\xFE\x1D7\x90\xA5\xC26\xC5\x9Eg\xA07c`S\x11\bn\xDA\xAB\xBC\xF9\x94\xC9\xCB\xDC\x1C\xD4\x9CJ^\x9F4\x10i\x0E\x07\xD8\xF8\xAB\x02R\xE4=\x8D\xC8\xFF\x7F\xD7\x00\x85`~A\xA3\x8A\"D>_\xCC\xD1\x01\xE2\xB2\xF87\x18\xBC\xD2\xFD\xF5\xE4\xB9\x07K\x13V$\xB78\xFE\"5\x19\xCBK\xE6\xC6\x9F|\x96\xF3\x1C\x7F\x9A\",\xE9\x95\x7F>U\xA3\xF6\xFF\x05\x8A\xFF\xE1\x8C\x1B\xFF6\xA2\xEA\x03\xD7\x95\xB7/ \xF4\x7F\xBD5\xD65\xF8\xB8J\x94\xEA\x0F\xE7<\xFAgB\x85\xDB\xDFa\x93\xE4\x00\xBEC\x7F\xDA\xF7J\xF2\xAFU\xAE\x90Y\xC5\x9C\x03\xF4\xEB\x13\x06\x1E\xA7\x9D\xFD6OG\xB6n\x7F?\xF6\x1B@\xD0:p\xB6g\xB7\xCA\xF1\xFF\x07\x93\xDF\x82e\xEC\xFF\xF1y\xEB\xFFl!\xAF\xFCz\x13h\xB8\xCAg`\xFD)\x8B\x8E9\x1A\x1B|\xE8\xE4\x9A\xB4p%\xD5\xD8\xA1\xCB\xEA\x9F\x87\xFB\xF1_\xE9\x01\xA7\b2\xCF]}]\xE66WM\xAB\x85\xF3\x96={\xA2\x8F\xD5r\xDB\xD5\xECW\x84,\xF2\xEBy\x8B9m\xC9\x87:\xC77m\xEB\x7F{\x8D<\xB0\xF21C\x94\x1D_\xDA\x96\xB6\xA5mi[\xDA\xFE-n\xB6e\x10\xBE,I\x1E\xA6\x87\xDA\x07\xABU\xEB\xE4B\xB0\xF1v\x88~\xD8!\xD2\xF5\xCB6C\xF1r\xD9\x8AHb\x13^\xAC1\x94\xFB2\xAAvg\xB1\x8E8\xC5\x7F%\xB5\xFCj\x86\xA7,/\xAA\x14\xF4I\xFC\x1E\x0E\x14\xF6\xDD\xF8C\xAA\x0Ehl\x05\x1F\xC1\x9F\x92\xCF\xAB\x8CE\xF1\xEF(j,e}\xDD\xB4\x1AX\f\x7F)!\x01\xD3\x06\xBB\xA6\xBB\xFC\xB10b\xCBR\x10\xB0}\xA6\xDDY\v5S@\xF8\xF4\"\xA5\x90\xDD\xF8+\x98\xAF\xF8\xE9\x16\x81\xA1U\x15\x7F?\x93\xA0`\xCEu\xEB0[\xA2\xEE\xE0\xEF\xB3\x80\x81\xBAc\n\xEA\xF6W\xC1\xDF\xB3\x93\xE3\xBF\xFE\xED\xF9\xDF\x15\xED\xEFc\x04\x7F\xE5\xCBP\xA8\x89\xA8\f\x8E\xCEZ\xA8\xA8\x10\xCA\x93\xFF\xD3\x84\x18\xBF\xA6I\xEF\xDF\x9F\x89\x00\xDAXU\xFC\xE9\xB9\x83!\x8B\xA5,\xBEx\xED\xD4\xD9j%G\xE9\x1C\xED\xE2E\x15\xCF\xE5\xC0\x8Et\xA2\xE0\x1A\x05\xC2\x81*/\xC2\xEC\xA8\xB0f\x1B\xC3\x90$\x84\x06\x8F\x98\xF8m?\xAA\xAE\xE7e\xC4\x0E\xB5\xE8*\xDA\xDA\xF8U~\xD3P\x95D\x04N\xE0\xA8\xAB\x80\xC2\x19Z\xBFrF\x18\x964\xD1P\x0F\x1A3\xB3\xEDSv\x16z\x0Fzr\xB6\x12\x19SUD\x05`\xAC\x7FAA\xDD\x9B\be9\xDD\x192~\x1D\n\xA3\xC2q\xC6c\x9Fh\xE9\xB1\xBDt\xE2\xF3X\x8B\x85\x9A\xD2\x81\xAA\xF8\x07\xA8\xFE\xD14F\xA4\x8C\xB7\xA9\x87\xC9$\xAEZ\n/e\xE2q\x13\x85\"\xD8\x94\xDFy\x11\xED2\xC4\xD5\xE4\xFF\xA9\xB3\x8AsX\xE8\r\x04\x92\x07\x81qo)dWc\xF8\xCEdwe\xED\x8C8\x9B\xE21\xF2\xA1l\xCBk\x18\xE3\xB3\x8C\x19{\xE7\xA1d\x9E\x97\x89\xA4\xD5%H\xBF\x82\xBD\xA8\xB7~0\xED\x95\x7F\xBB*J\x19\xFET\xFE\x8F\x9E\x0E\xDB\xB9\x03\xA2\xA1\x12ia\xB0\x89\x955D\x10,K|\x19\xFE\xDC\xC5&\xBF\x0EP\xB6$\x94\xFD\r\xD1\x10\x8B\xC9?\xC1\x7F\xFD\x8F\xE7\x19\x91\xF8\xFE/\xA6\xCFk\xDEr\x12\xF6\xE6\v\xBFg\x10\xFD\xC3\xE4\xDF\x89\x82nl\xFA\xFD\xE4\xBF\x07\xD2\n\x84\x06\x17L\xFC\xD6\\\xE4\x15\v\xF1\x00\xCB\xA1\x13\x15\x0E\xD5\xC6u\xBC\xFEE(^y\xDE\xBBEQ\x1A#\xB4\xCFy)\xCE\r\xF2LV\x8D:\x97\xFF\x90\x85\xC6q3dy\xA0n\xAC\xB2\xAA\xC5fz\xCFj9;\xAB\x92\xEE\x93\b\xFE\xD2\x97\xE9\x1A+@\x1A\xBC\x9A\xD7f\xAD\x86?}|\xB4t`x\xEFj2w[D\xFEi|]J\x19\xA7\xBF\x8E7^u\xD8\x00\x02\x91\xAA\x9Aj\xDC\xC0\x84\x01\xF6\xA6\xFC\x9E\xF2?9l\x07\xA4Y\b\xEEF \xC9\xAFP]\xFE\xF9\xC3\x92\xFD\x17+\xE4\x7FB\xBC\xCEU\xE4\xFF \xA5F\xE9a\xBFun\xDDF\x9E\xD43*\x18cs\x90e\x17\x0F\xBE\xF3\xCCl\xD6+\xFFB\xA1I\xDE\x01\x97\x86\xB2\x1F=o\xD9CQ\xDA7\x0F_\x13B\xC7x\"\xDF\xD0\xB1\xDF\xDC\xFE\xAA\xF0\xEEW\xE2_r\xF0\xDF!\x01\xC6\xD8\xE2\xFA\xE7\xC0#\xF3\f\xFF\xC7T\xED\xF0\"\x92\fIy\xDC\xC4w\x84\xFEq\xF4\x7Fp\xEC2\xF2\x7F\xE4\xACx:\xA4\xEF=\x04\xFF\x1C\xC3\xBF\x9A\xFC\x07\xB8\xFC/\xCCNT\xE0O\x14\xFB\xE3EN\xBE\x95\xDF\xC5\x14\xF8\xCB\x8E\\\x1C\xA1Ej\n9^\xDC\xE1\xA8\t\xD4\x0F \x98)\x1CZ\x01\x9F\vj;\xF7{Y\xA1y\x8A\x7F>\xE7T\xD9\\\x98\xD6\x10\xBA@\x8BB\xC6\x99\x86o\xBD\x9Af\xA8\xF0yN\xFC*\xC3\xB9\x86\x9C\xFE\x1B\x15\b]\x7Fa\x87\x05_\xE92\xFAg,\xA5\xB0\xF7\xF777\x97\xCE\xB2\x12\x06\x95[]\xE9\xA2A^\xE7\xDF\x94\xD9\x9F\x8D\x97\x93\xFF\xD9\xD1\xA4\xA3\x7F\xEAJ\b\r\xFE\xD2d\xB5\f\xAA\xA9\xB8\x10_\xAD\xB6\xBC\xA6\xC2\xFE\xA1%k\x7F\xED\x1A\xA3\xDD\xDBY\x15\xEF\x17\xCB1<{\x9E\xA0t.\xC7[8\xA3\x01\x8D\x1A\x1A\xAD\xB9#\x97<\xB5\x99\x1AEg\x83j\xE5\xF8\xBB`\xDE\x7F\xAD\x904\x99\x98\xB9\x1E\xFD\xD3>\xED@mo'\f\xE1\xF3eN\xD2\x80\x94\xDD!\xA1F^\xA8JU\x05\xD62\xAE\x89\xC9\xCFc)\xF9\xB0x)*$08f\xE09\x83\xBES\x8E\x93\x02\b\xDE .\xF5\x85j\xE3o\xD2QS\xB2\x8C@\xEC \xA3\x8E\x83\xFB\xAB5\xE6>\xA1\xBA\x1B+\xEE.\xA2d\xAB\xB5\xEDosT5\x95\xCB?A\xA9\xA0q\xF9\x7F\xB2HE=h<3\xAD\xA0\xD6-\xFF?+\x8F\x06\xE1\xEF{\x0F9\xFD\xE0\xE4\xC3\xE2\xD8\xDA\x90E\xF0\xF77qc\xD7\x1F\xEDe\x19\x8A\x96y\xF0O\xF0\x14\x9Dd\xE7\x18-\x1D\x9B\x1D\xB6\xB0\xACT}\xEA\x10\xE0\xC3;\xC7\xBF\xA6D\xED\x9Fj\xFA\xBFf\xFE\x80I\xF5?5\xB1_w\xF0\xB7\x8B\x89Wyk\x9E\x1D\x16\xE2\x1A\f\x13\xE1\f$\x8E\x98\f\xFFj\x9E\xDB\x00\xB7\x1E\xE5J\xF9\x0F\x8AF\x06\xAA(\xAE\xA7\xFA\xB9Vt\xCB\xFFw\x93a\x81\xBF\xC5\xAB0\xD7\xEB\xA8\x1F\xCC\xDF<\x8Fz\x97\xC6\b\nZ\xD8\xE7\xB5\xFA\xEA\xDF$\x0F\xF1\x195'\xF0\x0F \x07)K\xF0\x97\x8B\x1C\xFF\x1DI\x1B\xEA\xAA\xF8\xBFG\x8C\x99\x95\x17\x0FK\xF0\xC9zU\xAA<\xF4\xFF\xB1\xF7>\xD0qTg\x9E\xE8\xAFK%u\xA9$w\xB5\xF4\x98\x8D\x93e\xC9U\xBB\x8D\xDA2\xB1 \xC3\x9Buf\xFC\xACr\xD3\xD8\xED\x86X\xC6+B^vNP\x1C\x86$\x84\x1D\bC&\x044\xADB(F\x16\f\x96;b Y\x0E4\xA2\xC1r\x9B\xE0\tCB\xD6\xC31\x1D\xC7c\b\x99\x05\xC22\x93\xDD9{&e!\xB0-\x12\xC9vL,DS\xFD\xCE\xFDW\x7F\xBA[$\xD9\xF7x\x87\xB3Q\x1D\x1F\xB9\xBB\xBA\xEA\xD6\xBD\xBF\xFA\xEA\xAB{\xBF?\xBF\x8F\xCA\xC6Ew,\xE7\xB3\x9A\xB7c\xEA\x1C\xA9?\xC7\x80\xA2\x9D\xB40\x9D\xC7\x19\xB3J\xFF< ?ejO\xB2w%\xBD\xF9\xBF\xAA\xC2p\x8Er\xD3}\xA4^\xE4\x88!\xEE\xFB\xE0\xA1\x9A\tp$\xCE\xC9\xDC`\xC4\xEB\xEA\x9FS5\xF2\xFF\xDA\xEC\xB8\x88<a\xBA\xEEX\x89q\xF5G\x923\x13Z\xE0U\x1Bq+\x8E\x05\xBB\xC4\xE4\xEAP\x9E\xB8N\xDE\v\xEFX\x0E\xF5\xB3t\n\xC4\xD3\x15\x9B\xB5;v\xDE\xBA8\xFEeI\x98o/?J\xF5\xFF0Yt\xFD[\xBA\xBE)\xCCy\x04^+\xAF\xB5\xEB\xAF1yT\xFF\xDA~\xF0#}\xABi\x97UxG\xBD\xF5\xEFFo\xFDK\x85S\xFB\xA8\xCDL\xF7\r\x91z\x9DY\xBF\xA8\xFC3\xDE~\xC6R[\xA7\xBAns\xBF\xA4\x0F\xF2\xC9\x7F\xEB\x06\xAA\x18\x1B\b_\xF62J\x9F\xD0\x11 \xDB\xB6b>\xA8j.\x94}\x8D\xD4\xEA\xFF\xAB\xFB\xED\xCF\xC9\x91\x96\xAEo\x82F\xA0mw\xD7\xBFw\x7F\xA9\xA9\xF6\xFD;\xB8\xC4\x02\xB4\xB4-mK\xDB\xD2\xF6\xFB\xBD-j\xF6\xB7\xDE\xAB\"\x80Rc\x19V\xEB\xD0\xFEGk>\xFC\x06\x17\xC3{[\xD7U\xAB\x8E\xB9I\x8E\"\x1A\x1C\x11\xE7\x1C\x8AV[\xF5\x83\x1E\x07\xD5\xAC\xDF\x07\xDF\xF1\xC3\xC1\xBE\xA5\xE4q\xDAo\xC20\xAAxg\xBE\x97\x15\xBD\xEA\xDCF\xDB\x1B\xECY\xBB\x1A\xFF\x06\xF1k6f\x8C\xF9nS5\xFE\xB2\xB2\xEDb\xF8\xCF\xFE\xF6\xF8\xB3\x19K\x96\xD3\xEC\xFB\xF1\x8F\xD8\x01\xFC7\xC8\xD3\xC3vV:\x0E\xE2\x8B\xE0_\x96+zG\xE2\x9F\xAB\xC6\xC4\x183l>\n\x0Ex4,h\x8E\xD2t\xF9_\xC2\x8A\x12\x9DE\x87\xCD\xDF\x8C\xFF\xFFAO\x14\xAB\xA70q\x07\xBE\xCE\xBD\xD6\xA9\xE0ig\xA4k\xE2\x8C\x85Xo\xB5\xAD@\xD4R4\xD2\x7F?\x15\r\xD81\x98\xD5\xD1\r\xB3<\x134\xD4W[\x03\x8Cz\x86#c[]k\x1E3&$y\xD8\xB6\x7Fm\xCE#f\xDD\x99d\xB7\xAC\xBBz\xA67\xC9\xEC\xFFYF!\xE2\xF89\nd\x9B\xC3\xDC,\x00#*\xDD\x01\xAEo\xE8Ai\xC3\xC9\xBE\xCD\n]\xC1\xD0x7\xCA<\xF5\x99\xB5\xB6\x11\xB8\xB57+\xEC\xC6@u\xFB\xB2\xE7|\x86\xE9\xD0\xC5\xC8\xB7\x05\xD4\xA6\x8C\xF64F\\\xD3\xEE\xCA\xE03\xE8\x96`\x8B\xE7\x11KV\xAFbD-3%=\xA1\x88\x04_\xB7\x88^\x82\xF8\xCE\x15JJ6\xAD\x04e[\xADk\xB8\xEB\xAB\xB73\xCE\xCAnf\xB9&\x8A\xFB\xE4_\x94\xE6\x94\xF2\xBF3&\xEC\x93\xDD\x87\xB2\xACR\xDE6z\x96\x92\x802\xC4\t\xA0|mr\xF9OB\xC9\nB\x1D%]\xD5\xCF\xAEX\xBC\xBB\xE4U\xFC\x84\x12_Y\xE22\x1D\xE5\xC1\x96\x973\x13\xC8\xC7d\xB3\xABj\xF5\xB4\x12\xE5+\xAC\xF6~oh]OH\xF9W\xBA\xDCk\xAD\f\x9E\xBBFb\xD8Y\xAA\x83\xBF\xB0r+\xE9\x83\xB1h\x95\x82\xEE\xCE{\xF8t\xDA\xF5\xC7\xF5\x9E\xF8\xD7\xF5f\xA6h\xF7\x98!\xB1\xC3\n\xBC\f\xD6\b\xFD#V\xA3\xBDr\xBD\x95\x18J2\xFC\xB3\x8C?!\x05e\xB6\x06\x7F)\xFFJR\xD47t\xABB(\xE29\x8D\r\xAD[\xC5%\x93\x13\xE6+q.\xA5=\xACF\xF0M\x16\xBE\xCC>\xAC\x96\xCDv\xD7\xCA\xBF\xE2\xF0\x02\xDF\x95\x92W\xE35\x9E*z\x17\x92\xA5\x10Va\x11\xF9\xB708\xB5q\x11\xF9\xCF\x1E\x95\xFA\xE7V\xD9\x87D\xDE{\x16V\xA2\n\xFF\xE0J9|M=\xA8\xB3\xF5v\xDE\xEA\xCA\x7F\xCC\f\x94\xA7\xAC\x92\xFF\xAE\xA4\xB8D\xF7T\x96\xFED\xE5\xDF\xA1\xC2\xCF\xC6\x1E\xC0\x87\xCB\xBF\xE2\x97\x7F\xE9eP\x84\x19\xA4\xF3\x18\xA4\xFC\x8F\xF0\xFE\xF3\x16^N\xD2\xCB}\xCAD\x86\x1D\x18\xB3\xDFK\xFE?\xC3nn\x9F\xE9\r\xBF{Z\xCA\x7F\xF8\x01\xB7\x14\xC2W\x82\xE7\xDD,\xF1\xBF\xD9\xC2+\x9B\xAA\x8B\xB3\x8B\xDA\r\xE1\x14\xC2b\xE0\xD7I\xFCo\xCC\xE3f\xD9\x8D\xAF\x8A\xAB\xB8>\xEB\xA0l/\xFB\xD7z\x86\xEBz\xD6\xA4\xB0\xF2U\"~\xBA\x99x}\x13\xB1\xE2>\xB7\xEC\xE6;\xC5%n\xBCS\xFD\n=e\x1B\xBDz\xD8A\x98\xE2\x7Fc\xA0MS\xBC\x92\xC2\xC9\x9BE\r\\y\xEB\xE5\x87\x81\xBF\xCE~\x9DQv#\xCCnMx\xE8\x166\xB4\xE8&z\xB9\x9FZx\xFBNz\xE4\x80\xB9\xB81!\xEC|\x91\xF5\xF0\xAF,o\xF87\x1A\x07\xA4\x06(\",\xEE\xC5\x7F\v\x9E\xF7O\x12\xC3W-l\xFBd\xB5N\xF8\x89\xC8\x12JU~)\xBAZ\x94}\xF8Y\xDE;\xF7\xA7\xE20y\xFB\x96\x05\xDBi\xAC\xA7\x7F\x96\xD5\x93\xFFe}\x8Cr\x87\xE2\xFF2\xF0?}\x01\x93/p\xFC\x15\xC1\x86\x91\x93]\xFD\xE7\xEF8?\xE5\xAD-Kc\x99\x82e\xD7\xF1s}m\xBA\xFC`Y\x910\xB5L\x9A\x04\x97\t\x19x\xF5\x1B\xC9\x9F\xDB,O\x81\x1F\xBC,\xFB3>\xFF\xF9%\x1D\xE1U\xFD\xC8|\x92\x1E\xF9S\xD9\xE4Ok\xE5\x7FY\x8AG\xD4\x0F\x99\xDE\xD0~\xF6\xBA\xD4?\xAD\x0E\x96\t\x10\xB6\x06\xCF\xBDR~\xED\xB3\xB0\xED\xD2j\v[F\x14 HF\x1BEW]\xB6\x8F>\x99X\x07\x88\x90r4J\xFC\x1B\xB3\xBF\x19\xFF\xC6z\xF2\xDF\xD8w\x85<\xFD*\x9Bv\xC9\xDDD\xE9\x96eb\xFESy]\xD4\xF1\xDF\xFA\x0F*\x1Dxc\x82\x9E\xD5x\x13\x1A\xD7\xF0s}m\xC6\xC4\x83\xD3\x98\xDC\xE6\xE3\x11\xF2\xF7\xE1\xAA\xD7o\xDDJ\xD8Y<\x91\xAA\x91\xF4\xB1\xA1u\xB0\x9E|\x85^.\xEB\xCF\xF7\xB9\xBAV\xFE\x1B\x07F\xDC\xA9\x91\xAC\xD7\xD3\xB7\xD2'\xFF2\xF2\x7F\xAB\xB9\b\xFEyl\xBB4\xBA\b\xFE7\xF5\xFC\x83\xE8\xEA'\\\xFC\x81O\x97\xAA\xF0\x97\xF3\xEA\xC6`;\xE1\xBA\xF8g\xEB\xE2\x7F\xA5\xE4\xDB\xEF#\x01\xFCE\xE9\x96\x06Q\x8A7z\xA9\xB8\xD7\xDB\x1EM\xF1\xF4I\xF6o\x9B{\xAE\xAF\xCDm\xC2\x1A\xDC\x98\xFDS\x91\xF4q]U\x1F\xFA\xEE\xBC\xEEJ\x82\xCF\xE4%t\x8D\xEB\xAFbC\xBB\xED\xF5\x11\x8Ev\xF4Rz_\xFE\x83lrk\xAD\xD1\xBE1\xF5\x10k<jz\xED_\xE5\xCA\xBFz\xD0-\"pEpQ\xF9)\xD9\xD5\xAB\xF2\xE8[\x14\x7F\xD8\x97\n\xFC\xDD\xE2:}D\xE4\x8Az\xE3m\x8C\xD5\xC7\xBF6\xC5oQ\xF9\x1F\xA7\"\xCAh\xF1(\xFE\xF9\x1A\xFCe\xA1\xE4\v/\x15:\xBE\xEF\xD1\xF8\x15\x9C{\x8A\xE2\x7F\x93{\xAE\xAF\xCD\xD3\xC2\x1B\xD8\x18\xDFZui\x996\xD87|\xEB\x95\x84%\x15r\x11jLr\xF9\xFF\xAF+5^3\xEAB\x86\xFF\x95\xBEg\xBFV\xFE/\xE49\x05\xB4\x91\xBB\x85ll\x92\xF2\x1F.\xF2\x8E\x01\xF8\xCB\xE0y7I\x19\x1E\xB0q\xCB\xA6j\xFCe\x96t\xB6\xE7\xB9lp\xA9\x8B\xAF\xD9\xF8K9\xCC\x9B\x85\x9Bu\xBD\xFB2\n\x1A\r\xEA9\xD9\xC2\x1B\xEB\xED\xFC7\x03\xFD@\xF8\x1E\xDE\xFE\xCDv\xCD\xFB7$\\\x00?\x7FN0\xE9}\xFD\xCEV:\xA3\bk\xF4e\x1Anr\xCF\xF5\xB5\xD9*\x14W\xF8\x90;\x1C\xF9\xD3!9\x96\x8D7\x96\xF05\"+b\x84/\xE7#\xFA\xFA\xB1,/%\xF0s6\xFC\xAF\x93j\xD0|W\xD9\xC1\x95\xD2\xCFK@\xF8\xE3\x12\xBD\xC7<\xF9\x0F\xDF\xB3d\xFBZ\xDA\x96\xB6\xA5mi\xFB=\xDE\xE2\xB5\xE6_f\x95\x8D\xAA\xE6o\xE35\x88\x92\xC5K\xFD2\xD2\xC2E,\xCCA\xE7\x82x\x1F[nzm\xEA\xBD\xDD\x04n\xDFT\x11\xA5\x1F\xF5\xB7\x13\xFA\xAD\x9C\r\x9E\x01_\xB1\xFEW\x9C\x14\x8B\x84\xC7\x13\xD1C\xFA\xD7w\x89E\xDB\x89\xD7z:\xD8\xE8\xFA\xB8\xB1\x9D]\xE5\xC1\xC5\xF07\xEC\xBE\xAEz\xF8\x0F\x96\x10c\xF8\xBF3%\xA7@j\x139\x14\r\xDC\x1A#\x06\x83\xAC\x98k\xE2\x16\xF9\x0E%K\x86SgmF\xC5\xC3\fb\x92\xE4\xF0`p\xEE\x1A\x15\x11&\xCC\x86\xC0\xF1\xDFtH\xCC\xE5\xDE\xB2\x01u\xA0Cu\x10\x1E\xA85\b\xFB\xBF]=GO\xE4\xF5\x07O[\xB8\xDA\x8Ez\xE1\xC4\xBCxA\xE8dCi\xDD\xE0\x0F}\x01H\xE1r\xC3\xED\xF2kh\xF8\xC3\xF4/\xFD\xFA\x11\x0F\x94\x83\bM 4\xF6Q\x1Bjh\f\xA1\xE7]\n\x88\x8FT\xC37Vm\x99\xAFb,a\t\x95\xBC\xA0\x18\x8C\xA9Z\x84\xF9\xAFo\xF7\x1Exk\x918\n\x8E\xBF\x12\x93K\x00\xF5\x96N\x9F\x85\xB3S\x84\xAF\xB4\xC7\xC8-td\xC7\xB4\x0E%\xD9y\xAC\f\xC2L\xAC\fU\xB1\xB2\xAA*)\xA8\xFA\xABP\xA5x\xE5\bS\xDAi\xCF\xCB\x03j\xAAc\xDAsy\xF8\xB6@\xDC\xF8x\xDEq\xF30\f\x1B\x97\xF6\x0E\xF8\xC2iLN\xB7>\x10.\xA9\x81\x00Hs\x9D\xFB5\x12gu\x90)\x8CG]\xC9\x8D\xC4\x10q\x10q\x8E\x02\x95Y\x87\x97\x0F\xE3\x91\xEE\xAFU\xA1\x14\x91b\xE9\x99(\xFF\xD9SI\xCCd\xCA\xB8\xB6pi^\x1Al\x83[\x97\xC9\x8D\x8D\xD7_\xB7H\x12\xEB\x02K1P\xBAe\x88\xAC\x91>\xE3\x8BW\x9F\x17\xFAGY i\xB6\x9E;\xB72\x97<\x937Ap\xC6\x12R!b\xD7\xF5`U8\xC3\xAF\x7F\xCA]C\xCB\x01\x9C}IFD\xE7\x01\xE3OO\x19\x030jXt\x82\xD1J=y\xCD\xC5_\xCF\xE3\x04\x89\x02rq\xDA0\xCFimT\x98\x95\xA9\xA8\xFF\tR\x15i\xA9P\xCEa\xD6izO\x89W\xDD8\x06\x85@\x89\xAE\"\xD0\x94\x1C7\xDB\xC6\xA519h\x1D=Tm\x19V\x0E\xB8?~\xAC\x9F\xE2\xCF\x8D\xC9\x9B\xFA\xEB[\x86\xB9=\xB6k\xE2@!_\x1F\x7F\x1Dh\xB1\xB1@$wJ(}N\xC8\xB3\xA6jB\xFF\xC4[\xE6\xE8C\xFA\xB61\xD2\x16J\x9E3\x99<\x9B\xC79\x96\x88\xF1\xE3\xC9\xE3\xD5\xF1~\xA1,/f\xCD\xBDHk\xEE\xBC\x80*\xD3\rB\xFF8y \xD4\xF7\xA1\xA3)\x84j\xE4\xDF\b\xC8\x7Fj\xBF\xE7\x17\xAB\xD8\xE8\x99\xCB\xBAUM\xA1\xB0\xE2\x05\xDA\x84j8\xCB\x02^\x89Te\xCA\xC5_]E\xC5\xE7L\xC0\xB9\xA0\xACg\xB7 \xBA\xD2D\xCFP\x8E\xCB6w1\xD4\xE0\x1F\x7F/\xF9\xA7wv-\x97\xFF\xAF\xBE\xA7\xFC\xAF\x9E\xBA\xBE\xAE\xFE\xAF\xD8hg\xC1\x87+\x8E&\\\xFC?t\xF4\xB3\xEE\x01m<rU\x89\xB7\xC7(\x9E\x1DS\xEB;B\xD9\x0F\xCD9\x84\xB0\x90E\x86\xB9\x90\x7F%\xB8Xf\x06\x7Fi\xB7w\xC8h\x86\x15\x1C\xC9z\xBE$\xC59'6P]\xE8\xB3\xC6\x07\xF1\xEAT\xD2\xB5\xDBw\xE5\xB1*\xD6\x0E%\x11\x90\x7F%]\xB1_\xBExW\xDE/\xFF\x11\xB7D\xA3\x91:*\xF38<r\x03c\x02\xC66\x18\xD9S@[$\xC7}\x97\xDCqy\xB2\n%cy\x95\xC5\x1B\xE1\x03\x01#C\xD8\xE2k\xF3W\xE9\xE73u\xDE\xB0\x9C\x8Dm\xCF\x81\xBA\xF1\xD2\xAA\xD4\xFF1\x9Fk)\x9E\xDC\x1A\xF0\xA3)}P&c1:\xD5\xE9P\xB4\xCEC\x89x\x9E>\xCB\xB1R\xF0\x89[\xB6P\v\xA3\xF4[\xB5\xF7\xDC1OO\x8F\t\xF9\xEF\xEE\xA7\xEF\x8B\xCE\xE9z\xDE4%\x10\xF7{\xF5P\xD6}\x8A\xBBm|\xB2x\v\xF7\x94q=\xAF2\xD6\x97\xA6\x86\xF4\xE1\xED~\xCBQ\xEA\xAD\xA9qW\x80\xA9|*T\xFF{\x12H\x85\xBF\x0FJ\xB4\x03\xA8L\xE5xW\xB9\xA8\xC4\xAA\xB4\xB4\xD2/G'\xE5\x7F\x99'\xFF?%@\xAB\xF3O\xDC\x1C\x97\x87k\xA9\x0E\xC8\x0F\x93\x8BW\xBE\x13\x8DZ\xF5\xF1\xDF\x0E\xDCh\xA1\x18v\xDF\xBF\xA9k6z\xF8_\xCB\xD3\xAC\xF4\xE2_0\xDA\xFF\xBD\xFA\xD8\xCD\x1B\x13\xD7\xEC)\xEF\xE1N\x96&-\x90\xBB\x14h:.\xA2\x94\xA9\x8E\x13\xA4A\x9F\xDC(\xF0\x7F\x14@\xEB\x81k.p\x84\xDD&\xA0\x10\x8F\x04\xBF\xC6E\xB6\x17k\xED'\xD79\xD0\x13\xAE\x9CW\x98\xE7kY\xEB\xC6\xC1\xA6\xB8\x7F\xFE\x13\xDE!okS\xD3\xE7\xE9_\x8A\xFFu\xEE#\xD2\xB4\x1EM}h\x8A\xDE`#~\xA7\xC3G\xF1\x05\xCE\xB9T\xA5\xA5\x9B\xD6W[}}&\xCA+K\x80\x9A\xE3\xE6#\x8AF\xE3\xAFka\x10\xB4`\xAF;=\xF5P\x8A[x\x92`\xD2BQ\x97\xEF\xDFH\xEA\xA9\xCB<\xFC\x0FP\xFCG\xA0?Y\\M\xF5\xC0\xDE\x99\xF1\xC7/K<m\xE3{\x04\x93yx\xFC\xD8\xB5\xF9&\xCC!\"\x88V\xF4\xE5\x9C\xFE\xE2\xF5\xBB\xC4(\xE8\xFE\xA6\xE2\xD3o\xE4\xD0R\xC3\xE2\xA2\xAF\vhH\x96\x13\xC7\v\x10\xEC)\xE1?\x15\xFB\xBC\\\x1B-9\xCCJ;\x9Ds;i~\xCE/{/\xAFsk\xF2\x86\xCF\xBD\x91\b\xFC\xBF\xEC>\"\xE1\x18\x9AF\xD0\xB4\xF6s\xC0\xE0\x91(\x9A\xCE\xA1\x00\xB2_\xBEX\x8D\xBF|\xFF6\xBA\xF6RO`\xAEd\xD3<n\xECe>\x88:\x91\t\xFC\xD7+W^\xF8r\xBD\xF7o\xCAD\x17cK+\xBA\xF3\xCF\xC6T\xC2\xA7\x7Fb\x02\x7F\x12\xEB\xBA\x89\xC9\xFFx<\xD9Ev9\x8Fr\x8E5\xA6\x7F\xFCEF|=\xA7\x80\x88k\xEA}\x9C\x9CpsR\xDC\xAF\t\vP\x8BDu\xA0|\xBB\x06\xFF\xC3\x81\xC7\x88eJ>,\xCF\xBA\xEC\xBA?\x87\xDE%\xF1\xCF\f\xE7\x01-\x17\xDF@xU\x14\xF9^H\xAB\xEE3\xA2O\xE7M\x91\x9E\xE0%A\xE9\x13lP}\x0F\x03\x7F\xDD\x95@\v\xC5\xFFq\xF6K\xBEJK\xE8\xF2\xB1j,V\x99\xBE)\xE6,\xCB\xF2\xB3\x9C%\xC9\x04\x1A\x9FZL\xFE\xAF|\xB4\xEF\xC2z\xFAg\x98P\x84\x19\xFE2mA\xFDL\r\xFE\x17C\xDF\x1Ec\x83\xDE\xAB|\xA4\xF3P\x86\f\xA7\xF6\b\xFC5o\xCEP\x15,\xC1\xE8w\xA4\xFE\xC9\xA5\x18\x7F\xE0\x151!<t\xBFz \x96\xCAAy\xB2\x06\xFF\xB5\x01\ta\x1Et\xFE\x1CMX\xF8\xE4\x84\x8A\x16y\x83Z\x16\x9E\xCD\x03\xCD\xA7\x0F\xC7b\xD1\xCC\xA8wN\xEB\xC6\xC1\x17dgt\xF5a\v\xD0O\xBB\x04;lg\x8C\x0E\xAA%\xF70p\xCEh\x8A~\x05\n\xF5\xF1w\xDF\xBF]U\xA6o\x00\xB70\xFA\xD3\xAF2!S\t\x10>\xAF\x16a\xEE\x8F\xBE\xF9\v\xB9\xAB\xEB\xE1\xDF\nt\xD8t\x91\xB5bJvN\x9D\"I'\xF8\xFE=\x04\xE5\xC1\xCE)\x87\xBD\x7F\xB7\xC7/\xB9\x87\x8C\x1C\"\xFDX!\xF1\xBF\x9C\x83\xAC\x05#\xF9\xD5V\x1Ek\xC4\x04\xF2\xC2\xBB\x13\xF4\xD7M\x92+`-\x01\xD4\x1D\x17\xC4\x1D(5Y\x06\r\x01\xFD\x7F7\x9Fw\xC9\xB9\xF4\xE6X+\x94\x9B\xA4\xFC7Y\xFD\xF4\xAF\xDAz\xDE\xE7\x87N\xFB\xD7_j\x83\x9B\x05\xA9\xAE\xA1m\xDEC'Q\xEE\fD\xC9\xB2A\xD1\xF7\xEF5\x97\f\xF1I>\x9F\xC6\xAF\xA8\x9E\x7F.E\xFF/mK\xDB\xD2\xB6\xB4-mU\x9B\x16\xB4\xFCGUSS\x84\xC1\xD9\xFC\xED[\t!\xAA\"Jdd~\xA8\xAE\x17\xA0\xDE\xD7P`O\xDCo\xEEv\v]\xCAr\x97\xE2\x9F\xEAw\"xk@\xFE\x93\xE9\xDB_\xD5\x7F\xF7D\xB3\xAA \xA7\x1A8\xDE\x94M\xF165T_.\x1A\x12\x06\x7FS\x15\xCC\xFCfh\x911\x12\vm24\x1D \x1F\xE1\xEB\xE0\x86\xE5\xC2R\x1Dr\x10\x1A\xF9\x88\xEC\xE6\xBF\xB5\x80P\xFE\xDC\rt\xCF\x87YO>Z\xEF\xBD\xCDO\xFC(\x9B/]x;\x9B\xE4\x84\x9C\x0F\x87\xC6\xD5\xD0\xD8\x8A\x12>\xEC\x1A\xC9C\xFC\xA7\xB1]G\x9D\x7F[\xAA\xB1\x84\xCB\xAF\xFF\xEE\xA8kcw\x10\x12\xE6\xBB\x0F\x7Fp\xF0W4\xB0r\xB1\xAAz.\xD4uP\xA2P\xA2\x1B\xE8W\x86\xBF\xEA$Sq\xC0\xE4T\xF0\xEF\xD8\x80Z\x86\x9As\t\xF0)\xFEjT\xC4\xBB\xA8\xE4\xA8%\x16\xA7\x00\xA6\t\x10I\"r\x81-'K,\x19\xDF96\xEBL\x99\x82\x18\xE4D\xBD\x84\x18f\t\xEF\xE33M\xFB\t\xB6\xF0\x8C\xF4\xCD\xCD:\x95Yg\xC1\xC4\xDC\xAC\xCB\xAB\xC3&o\x11\xE7Td\xDBt-/\x81\xFC\xFA\xBA\xBB'\xD2\xE7\xFE:'\r\x95\x9Eo\xC2p\xDC\x7F\x95*\xAE\t\xBE\xC2\x9D\x13T\x90\x15\xBB\xBE\v\xC6;\xD1wL\xA0)CrK\xCE\x89\xABTl\x8E?3\x8F\x1C\xB6\xA1\xAA\x1C\xFF^\x1B\x95\xE9(\xC2\xE5\xC1\xC3\x1A]\x92\x84\xCB\x1C\xF0<a\xC1Nj\xCE%\xCFz\x87\x1Dy\x9Bt-\x9D/\f\x89Cb\xA6\xAA$\xA1d\xFC!\xFDPr\xF1\xA4\xD6i\xB3\xA9\xB22\xB9\xBA\xDEj\xB7\x9B\x9E\xB8m\x95\xF0\b\xF0\x80\xF9m\x89X\x82\f\xA5b&:X\x042k\x8A\xFF\x14\xBDs\xAA\xCF\vHV\x82\x86\x02\xA5\xAF{*\xE5\xFD$\xCDw<\xDA\xD9\"\x18%\x806\xC1\xFF\xBA\xFFF\xD9\xAD\x1F\r\xCA\xC6\xE8\xAA\x18\xB4\x89\xDC\xAA\x98\xB7_\v\xF2u\xB8'&&r\xF2\x98\x9C\xBF)~\xBC6\xC1\x9B\x1A%\x18\xEDv`<O\xFF\x01m\x06\x81\x91b\x85\x92\x1F\x9C'h3\x1C\x84\xA2mF\x94\xDE\xACP\x94g\xB5\xBCM\x00\xA3\xCC\xCB%\xF3\xED\n\x13\x99M\x07\v\\\xFC\xF4t\x87\xC8g\x19\x10\xBC\xACt\x05\xA1\xC5eg:K\x14\xB4\xCEC\xEB\xE3\x16c:U\x8E\xAF\xAA'\xFF\xCC\x12>\xC6\r}'\x87r\xDC\xA5\xDAy\xE8\xC5\xCA\xD4\xC0\x82\t\x8Eg\xB7/\x96\xFBL\xCC\xF1\x92\x0E\xAAB\xD3\x95>2\xE4x?IC\xE8\x1AI>\xDCN\xF5\x12\xA1\xF8\x84\x88\xFB\xAF]z\x1C\xFC[\xBB\x1EC\x88|\xE1\xC8:\x8F\xC2&\x14\xEC\xBD<\xF1\xB6c\xEB\xBE \xF5\xE1\r\xEC\xC3\xD7\x84\x7Fa\x1D?\xEC/\x9E{\x06a\xDA\xCE_\xD0\xFD#\xEC\x1F\xDA\x94\xF5,^\xBD\x0F\xA1h\x82\xA0\x8D\xBE#\xA3\x95\xA9l\\I \x14\xE5\x02\xB6\xD3d\xD6{EF\xCB\xF3G\xF8\xF58\xF1%\rA\xB2\x90\x9D\xA17\v0\xB2e\xD9\xCD\x93\xCCmq\xA6w\xA2bc\x8A-K\xDF\xC9\xD7\xB7\xF6\xC3px\"\xC4\x9A\x97\xF83;v\xAA\xFB\x96\xDD\xDD\xB8\xBB\x1Fow\x7F[r\x920\x03o$\x1A\x9ES<Bx\xA3\x8A\xCE\xEB@eNZB\"\xED\\\xD2\xB8\x8B\x96S\xE6~\xAE\x0441H\x9B\xD6!\\F\xD3\xB9h:w;\xBB\xF5\x7F\x11\xB4\x04V\xA6\x1F@\xD3\xBA\x14\xAC\xC1z\xAC\xE0\xDC\xB2\xD7\xC1~J\x93\xB1\xB5\x96g9\xF4\xFC\v\xDCd\x14.\x9B\xA91\xC0\xAC\xD8x8\xA4A=\xC8\xCB\x07Wfl\xE8C\xD0rh\x8C\xE6\xE9\xD7\x14\f\x87\x8C&\xF7\xCCt\xC1p\xB8e\xF5m\x8B\xB3y8\xFB|\xBA1\xB39\xE5v@X\xC7X@\xAC\xC8tP\x92\xAE\xFEa\xF2\x9F\xEB<t0n\xE1\x82~\xA0a~q\xF9\xCFq\x02\x96/\x0F1\v\x95r\xED\x8Ad\xF2\xD9\tzS\xBA\xA7\xE2\"\xCB\x89\xCB\x7F\xC3{\xCB\x7F{bB\xEEi\xA8\x96\xFF\x90\x98|h\x9F/1GLH\xE3\xAF\xC8\x1E\xF6kGU \x02cC\x1E|\xC9\xD1\xDCw\x8D\x1A\fCP4N\x87r\xDBk\xF3\x7F\x10\xF4kWJ>+\x8D\x92\x1E|\xEE \f'c\xE2\xE9\x1Fj\x14|\x95\x85\x04d\bt\x07Z\x14\x8D\xD1\xFD6\xE2\xA3)(Z\xCFh\xB20z\x04J\x9A\xE3?a\x82\x95\xAB\x89\x16\xF3\x9E\xFE\xBF\xED\xC7\xAEE\xCB\xFC\x02\x87\xBA\x89\xEA\x1F:\x15j\xD2\xD0\x94\xDD.;\xDCo\x02M\xCE5\x1B'\xAE\xB1@\x87\f\xF3\x8B\xF5\xF0\xBF\xC1\xA6\x87]\xC7~z\xE21ffiJ^\xBF#\xAB6\ru\xDA\xF8\xD2\xF9Ia\xA4m\x9A\xE4\x06\xCC\xCE7\x94\x1B\\yh\n2\\597<&\xE5\xBFIA\x93xqm\x97\xC1\x18\x83TZ\xE6\x85]:\xA4\xD1W\xA4\xEA\xF0\x83\xAA\x8A\xEC\f\xFEh\x1EjaX\xCBU\xECE\xE4_\xB9\x85\x9F\x92a\xB2]G\xFE[\xAF\xE5\x17J1b\xEDwl\xC47p\xFC\xA9 \xAD\xCF\xAC\x87\x1EG\xF3\xC5h\xCC\xE6-\xF4\x8C\xA6\xD00OF\xB3\x93\xA3\xEB\xD00\xCF-\xDB\x05N!\xE5\x93\xFFQ\x82\xCC\x06U\xD2\xF2\x98\xFFI\xF0\xD1%D\x90j8\x8B\xA6\xE4M\x12\x7F:\xEA\xA6\xC4\xE0\x1B\x13_\xB0q=\xAB.\xF1\xE5z\xFA\xE7s\x14\xAB\xDC\x97\xF9\x1B\xFF\b\xD3\x99M\x7F\xF9\xB9\xE7Py\xE3\xC0\x02\xC1\ro\xD0Q\xDFH\xF5\xC6A~\xAF\xCB\xE7;_\"\x8B`\xD2T\xBCn\xA3\xE3\xDE\v\xD7\x8Dr\x83d\xB3lf\xB3C\xDA\xFFP\x94\xCDOL\x181^\xE6\xE6mR3\xFFT&+o\xC6\xB4zUQ\xB8`\x87\xE4L)^W\xFE[\x9E\xE7\x06\xD8\xAF\xF5\xBE\x8Apy\x94\xA0r4\x8AF\x8D\x07]\xC726\xC5\xBFQEc2o!>\x9A\xE6\xF2\xBF\x7F\xE60\x94\xF4#\x90\xED\xE8I\xE8E\xB7\xD27\x95\xFF\x1F\xAA\xEE\x04\xEC{\xC4\xF3\xCD\xE5\xA9\xB2\xD2\xD0\x92\x9D\x90\x07\xEFe\xEF\xE8\xBC~\xF0)\v\xEC\x95\xFDr\xB1\x1E\xFE\xF4^\xB78\xBC\x84\xD0\xC7\xAEc:\xB3%\xF9X1\xBBL/\xC6L<\xDCB\xE5\x7F\x0F\x01Z\x98\x9C\xEA\xA9\xCE\x99\xAD\xFB=^\xB2`\x8A\x93~`_\xA6\xCB\xFBI\x17\x8F*/\x88\x10\xB5X\x19\xD80#)\xA2\xE0\x8F\x00y\xA81\xBE\"\xEA\b\xE2\xDFs{\x1Cj!\x95\x9E\xF2<D\xCD\xE5\xAA\xF9g7\xFB\xA9\xCB\x97\xD9\xCA\xDDy\"\xD1L\xCFJ\xF9\x1F\xA7\xEF>\x1B\xD7u0\xA5\xC7\xDC\xD3\xB1$a\x85\xA45\x84\x92\xC4B\xCFD\x1A\r\xF3\xAA\x92$C\xF4\x03\xCF\xD7k\x13\xB3\xB8\xE2j\xDF\xFCg\xDB\xED\xEEj\xC3|\x94\xAF\xBF\x94\f\x85\xC8f\xF8\xEBI7\xA4a\x92\xB1\x12\x152V\xC1\xC2#\x16\xD0\x90\xDEW\x0F\x7F\xC6Y7\xC4\xF1'/03\xBB\x9E\xFCA1y\xF1\xE8\x81/Yx\x8AY\xDA\xF3%9\x1C}\xE0\xA6\xCBR{\xDD\x93[\x82\xE6}}\xE8\xC9\xE2a\xEF'i\xB4\x7F\xC6\x14\x8B\x97\x8B\xE8\x8C\x9A\xD1\xF7\x84\xA2h\xD0\xE8\xCAQM\xF2p\xA0L\x95\xFC7*h\x8E\x99\x9B\xDBm\xD3g\x9F\xF7o\xCD\xED|\x95\x94^\x19wY\x8FxU5Q\f\xA8\x95\xDDX5\xF9\xB5\xC9\xFB\xD10?\n\xEC\xCBG\xDD\xF9\xE7\xFA\xDE\x18\x9D\x7F\xD2\xC7\xF0\xD0I\vj\xB7\x86P\xAC2\x97\xFCU\xEFZ\xC0\xE4\x0F#\xAB\x97t\x1AF\xD1\xF5\xBF\xE7L\x8C?\xEC\xE1/\xDEY\xCCZ.\x1CO\xCA\xC6\xB5\xEE\xFB\x97\xBEX\xB5D\xCC\xE9\xB4\xD9\xFB\xB7uc\xA2\x7F\xB1\xF9\xFF\x0E~\x8B;?\x7F\x04\x82t1{x\xFB\x8E\xC7\xFA\xD19\xC1<\xDD.\xA3o\xC3\x8E\xC7c\xB7\x12o\xFE\xFF\xC7U\xEE\xF5\x8F\xC5n\xF2~R\x8Ex=a\xCC\xFF%z\xE2Z*\xAEMQ\xB4\xAEEk\x13\x1A.\xE7\xF2\xBFP5\xFF9>\x8F\xA6\xF3\x06_\xF2yH\xAB\xA8\xC3\x9A\x7F\xCDST\xBE\xF5|\xCE\x9D#\xD9l\xCF\xDD\xBC{\x1A?>\xFB\x8F+\xAEEk\x93a#q\x83\xC3\xA6\x00\xEC\x82\xA5\xF5\xC0r\x18y \xDB`!l;\x88\xACW\x91m%G`8!O\x9B\xB5\x02;\xDC,\x89\x07\xFA\xF1\xC0\xD1s\xEB\xBB\xF6\x96\xB6\xA5mi[\xDA\x96\xB6\xDF\xA7M\t\xFC\xE3s\b\x12, +\xBE*u\xAA\xC4V\xD5\x9C%\xB5\xA5\x81}\xC7\xF3\x03H\xB0\x8E\xAD\xFF\xF4@S\xC1\xEE\x11\x7F\xB5\xDC\xC5\v\xE9z%t\xFDWT\xBCQ\x04\xFA\x96\x14\x11\x06pO\xA9j<\xC9\xF6'}\xA7/2\xC0\xAA\x16\xFC\x87\x91\xE0\x01\xD5\xE7&\xFD\xFFxgT\x02_y\xD3\xA4\xFC\x9A\x94\xC5\xBC\xA0\x12\xF7s\xD2\x8D\xF4c\x87\xF9F\xE4\x9F\v\x92\xA4l\xC7\xFD\x9B\xF47(\xCF\xDA\xE0k*\xD0=\xDE\x01\xDFN\x9E\b\x10\xE8\xA4{\xA2\xDB[\xFF\xB5|?\xD5\xC1_\x9E\x02\x7F\x97\xDC\xEB\xFANwO\xF9D\xA9z\x8C^\v~\x1C\xDC+\x06\x87\xE0n\xB7\xD9\xBE\x7F\xC7\x0Er\xBB\xB4?\xEB\x81\xEEd_\xF91\xFC\x00\xF7\xF3m\xAFI2\x07v\x16\xDDY\x951\xE1\x1E\xCF\xDAq\xFF\xBA\x17\xF5N\x07\xBEn\xA3\xAA\x03\xFE\x8E\x89\xEE\xB1\x9DUu\x10\x02=w{\xEB\xBF\xD6\xB1\x83U\xE3\x92\xED\x1Ct\xAF.FdW7\xEB?\xDD=\xE5SV\xF5\x18\xBD\x16\x8E\x1D\xACj\xD9;\xE0X58\x05\xCB\xF7o\x94/Q\xD3\x1E\xDD=\xD8N\xF6\xB5 V\xC1\xF4\x00\xF7saXF\x987\xD3\xC3\xC6\xADz\f\xDB\xCD\xE9\x82\xC9\xDB\xD9\xCA[+\x8C\xA6\xDD\x8B\xCA\xC5QZ\x04\xB0\x05;\xE0\xEF\x98\xE8\x1E\xDB\x89\xE6\x801!\xD0s\xB7\xB7\xA3)\xEFZ\xA3\xE9\xAAq\x89v\xF4\xB4{u1\"\xAB\xBA\xD9q~:\x1B\xA0{\xCA\x7F\xAE\x1A\xA3\xBF\x05vE^\x00\xD7\xBB\xA2\x1E\x18\x82\xDF#Y\xFDY\xD1\xFC\xFE\xDA\xB8\"\xAA\x99k\xBE8v\"\x8B\x9C\f\x96L\xF8\x942\xF1\xC7\xB4{\xDA\xD9d\x16'\x13\xE11(\xAA?8\xD9s\x0E\xB2L\xEAh\xCD\x8AD\xD8\xEC\x87X\xB5\xF7P\x93\xEFy\x0F\x90\xAF\xCA\x05\x94\xE3\xAE\xB3zJ\b\x8544\xCCS\xC1\xB3\xAA\\\x8A\xBE\xB3|u^\xF8\xB5\xFC\xF9\x06o3_\xE0\xBB6>\xBA\xCB\x81\xF1\f\x80\x15%A\xA1\xBC\xA6J\xFEY`<7\x1D\xF7<Wf-\x07\xAF\xC8\xAB\x99\x1FZW\xEDn\x97\xC5%+\xB2~1\x03\xDF;,|G\x99\xEF\x8F\xBA\xA30\x1Cb\n\x9B\x89jJ\x93\x84r\x1E\x94\x81\x9ER=\xFC\x1B\xCA\xAA\x85\xC1\x1F\x95\xA1:\x83a\x07J{en\xA0b\xD3\xC5\xBEg\x9Cd7E\xAC\xC7\x1B\xE6!\xB9m\x07Y1\xF1\xB8\xBA\x9E\x19\xCAn\xF1\xACd\xEA\x88\xFF\n)^\v#<\x02\xD5\x11!\x8B&:\x8F9P\xB4\xCA\xF4\xC4\x00Ae*\xC9\x98\xD5\x03K\xE0\x94,Y\xCB]\xBA\xA2\xD6\xB9O\xB1\xEF\\A\xBB\xF1(A\x87\xAAB\x89\xC3pXeaz\x9F~^e\n`\x10}\x86G\x9B\xB3r\x84\xA2\xCA\x89W\xB8\x84\xF6J\xADQ\x0E\x83\xCCL\x912\xE9\xD8\x07\xED\x94\x90\x9F\xB0\xD7\tU5\xF9\xB9\x95\x92\xDB7\xE5j\x1B\xCB\x84\x99\xF7\xD3\xD2\x9C\xF5\n\x9AY8fm\xD1\n\xD5\xAC\xD8\xCC \x19\xCEE\x87\x15\xA8\xCE\x90\x92\xB2\x88\xF7\x10\xB9\xFD\xEF\xB0\xE5\x03(\xC5r\x03{\xE8:\x7FI\xB5M|H\xEC\x1C\xAA\x89\x8B\xCE\xA4\x93\xC2ed\x8C\xF0\x82\xB9\x15\x1B\xE3\x1DT\xFE\x87;\xF3\xB7\x13\xE4\xBA9\xB3z{\xB5\xFCkL\x7F\x1A\x13\xEE\xDB\xBF\xD9/\xFF\xCC\xB6\xF7.A\xE5X\x19\xC6\xA7\xA0\x99?\xB3\x05\xB0m\xA8#\xFF\x9CL\xA3\xE7\xB9\xF2\x15&\xA0\x8D\xC0\xC7\x10\xC5;\xDCyxy\xB5n\x96\xF8\xAF(I)Rs\xFE\xE7T\xD5\x04\xFE \xF2\xA2\xE1\xA9\x92\xC9\x12\x85\x80T\xAB\xD4\t\xCA6\xA8\xA9\xE1\xBA\xFAG3U\x8B9\xC4\xD5\\\xCFO\xA6\xD0\x1A}\xE8\xD05\x0F\x11\\m\xFA\x85-\xE5\xF1\xFB\xF9\xE4\xFF\xEB\x84\xE2\x9Fa\x945\xF1\xE1-|\xE7C\xA5\xEA\x1C\xD5+.ci\x1A\x86\xCE\x9C#i.\xFF\xA9\x8Ey(\xDA\xB3\x85\x83\xEF\x12<2\xC1\xE4\xBF\xF9t\x8D\xFC\x17\\\xF9\xFF+R\xED\xC7w\xE5\xFF\x9Ca\xD6\xA2\xE1\xF4Q\xC5\x9Eq-u~k*\x80\x9F\xB1\x87\"\x06\x93\x15\x80\x0E\xCA?\x83%\x8E7\xAA\xBDW\xEC\x8A\xBC:p\xCAd\x83\xD2r~\x19\x1E\xFC\xD1<\xBFw=\x96{\xD3\x95\x94)\x9C\x14\x83\xAF\xCD{\xF8\xE3r\x96\xB9P\x83\xBF\xE1\xF4PQ\xD7\x10\xCE\x1D\xEE\x8AA=gH\xE9\xB3\b,\x02\x8Fn\x9D]q\xA5Pf\x96+\xFF\x9B\x19\xAD\xD0O^\xEF\x03pe\xAFhy\x88T?e\xC9/&\x85\xFEW\x8B.\xE7a\xF8(\x95\xFF\xBB;'B\x04\xA9\x86,\x9D\x01\x06\xE3r<\xF9o\x88Q\xF9\xAF\xE2lw\xE5\xBF\x1F\x7F\x16f\xB1\x16z\xFA**\xFF\x99:\xF2\xCFD\xF4\nn\xFA\x9Esho\xB4.\xF8\xE3\xB7y\xAFf\xAB9\xDB\xDB\x98T\x9B\xAC\fqj\x13\xD7\xFF\xEDn\x88=/{\xC4\x1B!\x16\xDA\xA5\xFC'M\xFC\x9C\x1Dr\x0E\x91zX\xDD\x06\xC5\xD4\xFD\xF5\xE2}/6\x15\x18|\xCE\x81:\xF1\xD1\x86)\xA8\xDA\xB3\xAF\xA5\x1Eb\x95\xDC?i\x06\xE4\x7F-\x91\x8F\xAA\x94\xFF\xB4\x85{\b\x92\x8D\xE7\x00\x18\xED\x10\x98\xB3\xB8\xF1\xC0\x9B\xF4\xB6\x9D\xA7\x85\xFE\x8F\x14\xB9\xFC\x17\xF2\x88wW\x10\x8A\xDE\x1B/\xBEK\xD0sO\x12\xE1g\\\xBE\x14\xEF\xED\xCF\xE5\x9F\xF9\x86x\xAD\xE7\x1E\x1F\xFE\xBB;\xCB\xFC\xAD\xF4\x91\xD1m\xC0\xCBX\xD6\xF7iK\x14~\xFA\xA8YG\xFE\x05\x11\x13y\xF96*\xFFE\xF8\xF5$\x17\xCBX\xB6\xD6{\xDB\x01\x98\x04wX\x18\xE6,\xF6J\x8CGd\xD5\xE2/^\xE9j\xCC4\x85\xEA\x8E\x93\xBF\x95Jf\x1B\xD4\xE4EV\xDD\xD5i\xACb\xC3\xDC\xA0A\x9BP\x95\x18\xD4\x8B\xAD\xD6\xE1\xDDL\xFF_l\x05\xF4\xFFk\xA2\xF0\xAE\x8A\x90\xB0\xD5\x7F\x8B]\xE8\x92\xD7\x97\xB3\x02\x04\x90\x8F\x07\xFC\x12B\xE5\x7F\x15\x17\x8D\x9B\xE8{\x99\xDD\xBBB\x1E\xA9\x0E\r\x86S\x98\xBC{\x98@U\x92PcU\xD9\x94\xF4i\xD5\x86]\xD7\xC0\xA3l\xF4/\xFB\xF0\xDF\xD9or\xFD?\xF5e\x07\rih\x13T\xB1\xB3\x024\xEDU\xF3\x1F\xE6\x94\xB8\x94\xB5p\xE5\x8At\x92\x00Z\x91\xBB\x0F\xFC7\xE8\xCA\x15\xD5\xF2\x7F\xD8\xC6\x0F\x99\v\xFB\x81~\fw\xF0\xA2\xFE\x97\xA3\xD5\x9B\xE9\r\xBE\xE4\xB8\xFAG\xE6\xA4\xBFa\x96\x04\xFE\x87\xDD\"h\r\x0FB\xCB\x96\xFAk\xCC\xEC\x00Z\xD7S\xF9/\xDD\x8F\xE6\xBB+\xAF\xFD\x02\xEA\xA1\x8A\xBD\xE3\xA1~\xDA\xE0\xE1\xFE`pZ\xBF\xBC\x172Cy\x07sN%\xD5k\x19\xB5\xBE\xAF\xF6\xAE\x11\xC8JxG\xD4\xE1\xBD\x07\xAD\x0Eoj\xA5\x85;\xDFh\x82\x12\xAD\x9Cx\xB2\xDC\x8F\xCA\x1BY\xAA\x90k\xE5\xBF\xF9nW\xFF\x1F\xAC\xAEY\x80\xB7\x18h\x1D6Z\x95mh\xDD\b\xC3\xD9HU\xDFvo\xA9\xE8\xB5\xD5\n\xE0\xFFf-\xDC{\xFD\xC6\xB7mF\xB2\nA\xDE\xEB\x0E\xF0\xDE\x7Ft\x96L^K\xDB\xD2\xB6\xB4-mK[=\xF3;\x91\x16\xFBZ[7\xB7\xDF\x92\xF7\xB0fK\v\xF9b-\xB86\xF9\x80\xEB\xA1\xEA\\%\xE0}\xF0\xBF\xA0\xEBU\xFC\f\xEC\xF4Nt\xF9y\xAA2\x17d\x10{\x15\x93\x8F\xBF\x97Q\xF1\xD7b\xA4\xF7&\xEAX\xAB\\rqK\x9C\xAE\xD0_\xD3\xFC\x94\xDF~\xAB2\xBF\xC3g\xB5N\xD6\x18\xF3\x03&\xF4E\xAC\xD9\xC2B\xBEH\vn#\xC9\xA0\xEB\xA1\xEA\\\x7F\xB3I?\xFE\xC1\x9A\xC8,\xEE\xA2\xF5\xA3C.\x85\xC5:F?r.\xCF\xAF\xEC\xE06%e}\x87\x8B\xBF\xE1@qR\x80\x16\xD9\x02\x85\x85\xC8*\x0E\x94u\xEC\xC8\x81?\x99r\xFC\x96((Qb!\xC6\x97\x99\x92Mb\xA5\xE4+pi7\x88%lV\n\x10\x1FJ\xF3S\xD8w\x1F\x01\x05\x8B\xB1\xEC\xB61gc\xBFM\xC5%\xC6\xE6\x93\xC4\xAC6\xBF{\x1F\xA4\xD9<\xE0\bx\xCEgB_\xC4\x9A-,\xE4\x8B\xB4\xE0z\x13\\K{\x95\v\xC0\xB5\x9F\x07L\xF4\xEE\x02S\x0F\xD8\xDC&\b\xA0\x9F\xFC\\\x8B\xC4\xBFEe\xC1\xAE\xF4\x84I\x1E\x95\xD4B\xA0O\xEC\xF5\x16Ay\xB4\fu\xDA\x18\xFC\xD16\xB4d\xBFK\x0F\x88\xA2%\xF9\xB4M\xA7\xF4d\xB5|\"x\"\xBC\xEE<\xCD\xE0b\xD1e\xE2\xBE?\xCA\xE4\x82\x85Q\x8A\xDCyq\x00\xB3\xDD\xFDA\x8B\xE3~\r\xC45\xE9\xB4\xE5\xBD&\xBA\xF2X\xC8\xD3\xD5n\x92\xAD`\x92\xA6\xCF\xD6\xDD\x1C0S\xBBfs\xBF\xC1|\xDCoB_\xC4\x9A-,\xE4,C\xBC\xB6\x05qJ\xB38\xE6^nZ\xF7\xB9\x00\xC6-T5\xEB\xFD\xAA\xA4\xEB\xE1\x1Fm\xD2\xDD\xDA\x85)\xE8q\xE8\xE7s\x88(\x0Ez\x96\xE2\xEF\x96\xB1\b\x97\xA1\x1Fh&\xB829\x05\xDD\x9C\xE0\xC5\x1Cu\x16\xA5\xA9~\xEA\x8F3R\xFE9t\xFAP\xDE\xC2\x84\xC9r\xBAuqk\x9Ee\xF8\xF3`\xCE'\x99\x9CO\xE61I\xC4:\xBD2\x93\x99\xCC\x8B\xFD\xD0}\xF2\xAF\v\xAE\x83\x7F\xDF\x8F\xCE~\xC4\x80Qf\x94\xCB\xF9\xCD_j\x90\b+\\\xEE\xB1\x14f\xC4\xF6\xCC\x8C\xB7\xBD\xE4\xD0%LC\xD9]\xAE\xBEst\xBE\xD6\xD4|\x99\xAC\f2x\xD4\xF9wv\xB5\xFE\xAFL\xC5\xA1f\x9BY'\xFF\xCA\xC6_\x01\xCD\x9E\t\xE8 \xAF/\xB0*\xE4\xD5\x98s\xCCE\xF5O\x17\xA1Z\xE2\xC3\xEE\x93\xAE$\xA1\xC4\xA1\xAC\xE5\xFA\x87\x88=L\xFF\xF0A\xA9\x05(C\xAB\x80\xC1\x17\xB7@I\x8B\xF2\n\n\x0F\xFC\x1E\xFF\xF1P\xCE5nq\x05\xD2\xC9\x1A\xE1I\x10~\xFD\xC3\x83\xF9;\xA5.\xE2A\x8C\x836\xE2w8\xDD\xB6[\xFB\xC0'\xFF,\xC7\xA4+\x8F\x17\xF2(\xE6q\x0Ep\x9AU\xD6;m\xFA^(F>`\xA6P4\xB2\xEB\x17m\b\xB8\x992\xA9\x02\xB4\tq\x00\xBF\x83[j\xEA\xD3\xA9\x9A#\x98\x99\xE7/]\x19\xDF\x9A\x0F\x14\xFBf=\xCE\xC2(\xF0u\xF4\x95&\xDA\xFCUE\x94v\xCE5se\xCC\xC3y\x9F?{(X\xC7\xE4\xD7t)\x1A\x9D\x9E{^\x1E0\x04c#/\f\xB3@x\x15\xC2$\x8C\x89\xB7\xA5q\x89\xE2o\f%-\\\xBEy\x1EF\x9A\x95\x17)\x8A|\x075\xFEG7\xB8yO\xCCn`\xE0\xA4\x85\xD3\x16oG\x10\xD8\xBE\xC5D\x89'\xB3pR\x9E\xF9\xBC\x88\xFB\xCD\xE41\xF8b\xE6\xB8,\xBC\x1E0\x0F\x1A\xDF\xE7g\xFD!\xC1;\x04\x9A\x85X(\xCD\xDF \xDE\xD8\xD5\xF5~;\f\f\xA7g'an\x8E\xC7<C\xC4se\n\xA6\xE1U\x93\xAF#\xFF\x86\x93\xE1\x1A\xA3\xB5i\xF0\xB52\xED\xB0\x1Et9\r\xC5\xA1\xAE\xCBYB\xB6+\xBC\xCE\xA6\x94\xFFo\xF2\xF0\xE3c\xDEC\xB7\xB0\xB8\xFC\xC7XNS|\xC8W\xE5A\xD9\n\xE5|\xFE\x13{o&\xA1\xC4:\xDCA\x85\xCBP\x0E\x14\xFAqe:\r%\xCB\xF2}\x8AB\xFE\xF5\xCB\xA7]\xF9oh\xE7/\xD4n\x1Bq\x8B\xB7#\x88n\xBAI\xB5\xFC\xAF\xB6\xB1\x82\xF5\xF0\xBA<\n\x8F8\xAB=\xF9\xCFU\xCD2\xBB\xF2x\xDC\xA2\rFMdXY\xA5\x8C\xE9s>\xBA\xB5\x12\xB8\xBDT\xD1\xC8]\x13T\xFE5O\x15\xC7\x874hS\x02\x04\xF6\x14\\\x91\xAA!\xCDVG\xE4\xFB\xF7\x99KW\xC5\xAF\xB6\xAB\xE5_\xEDu\x10\xF6\xE4?a\xF9k4O\xF0\xD4\x9B\xC4h\xD1=\xBE\xD33\xB3\xBC\xCC\x19u\xDC\xED\xCF\b\xD0\x14m\x949\x02h\x8A\xA3)\x8A&\xAA\x7F>o\xE3\x1A\x13h\xCA\xA2i\xFD\x17l\xC1\xE0M\xFB\xDCT<\xC7Bev\v\x9A\xD2_`d5h\xC2\x9F\xD1\xC7y\xEB\x1F\xB8\x94AML\xDB79\xD7\x10\\o\xF3\xEC\x06\xA1\xFF\xBF\xC4sL\xD8_N\xE9\xF3E\xE0zK\xE8\xFF\x9E\x1D\xC3_\xB4p\r\x97\x7F?\x01\x11\xFB\xFCevk\xF6\xB3\x14\xC2\x05&\xBD\v\xFD>[ksP\xFF7,TN\\0\x18\xAC\xC0\xDEs\xC7<\x8C\xF3\x84e\x98\xFD\xCD}\xA1\xC6\x9A\x14>_\xC4!\xAB\x85\xAB_w6\x13\xCE\xF5\xE6\xD7\xFFI\xA8\xCE\xBDLf*&f\xF3\xF8v\xDE\x93\xFF\xBB\xD8\xD0f\xF7\xD4\x93\xFFP\x1A\xE1\x00\xFE7\xE7\x81p\xB4r\xCC\x87\x7F\xD8\xE1\x84\xE07\xB1\xFA\x1D\b'\x11\x8E\xDDL\x98m\x9C\x0F\xAD\xA9X\xB1A\x94)4\x8D\xD0\xFDME\x84\xB3_e\xDE\x84\xCA\x1B[\xFDp!\x1C\xFD\x82M\x1B\xB9\xCE\xF2\xC0\xE4i\v_d\x03\xBAA\xDE\x8B\xCF1\xFD\xBF\xCDD[S\xF9\xABy\xB1\x1FM>\xF9g\xB7\xEF\x8B\x16\xCAL\xFEU\xFAx\x9A\xDC\x95\xEC\xC9\x7F\xB3\x1C\x1A\xB7\xD0\x86\xE2}\x97\xE5\xDB\xCD@\xED\b*\xFF\xCD\xA7\xFD\xF2?x\xB8F\xFE\x1B\xCB\xEF\x8A\xA2\x1E\xCF|\x03*\xCBZ\r8\n\xB7n\xCAB\xB3\xDEf\x98\xA7,$L\xBC\xE5\xF1\xD7\xC5\xB8\xFEO\xA4\nu\xF4\xBFR=\xFF\x9Cd\xF3\x9Fe\xEE\xFC\xA7%E'*\xAC>\xF5\x84\x88mHB\x9F\xA0\xD3\x1B\x91\xE5\xF12\xF4\x03\xCB\xC0\xE6\x9F\xFA\bKN)\xCAx\xFB\x97\x97\xE9\x17\xFA\xA7\x8B\xD0\xFB\x9E\"\xB4\x91\xC7\xA9v\x12?\xF1\xAC\xA2\xBFc]z\x8A\r\xE1I\x82\xC7\xF2\xC2%Q\x99\x19\x9E(\tN\xA1@\xE5t\xF6\xF9i\x1B\xFF\x9E\t\x7F\xDCB1F\xD1{\xDC\xF4\xC9\x7F\xE8\x1C\xF9\x81\xCD=\"\xCB'\x8B\x13GY\xCC\xBF'\xBAs\x0E\x9A\xDB\xFD\xF2o\xF6~\xB6&\xD4DM\vr\xB6\xC4\xBD\xA9a*\xFFj\xC1\xFF{_\xE6\x10\xB4\x02\x97\xFFO\x98H\xE4\xF1\x90\x97\x8B\xF4\x00O\xFCL\xF8\xE4\xFF\x80{wZ\x93\xD0\x03\xF2\xCF\xD2\x13\xA2\x17\x8F\xDE\xEA\x9B\x7FF]\xD6\x9D\xBC\xC0?Fqnf\xF2\xDF\x90\x86>t\xB1\x053I\x9B\xF2\xF07\xE9O\x17\xBB\x93^\x81\x7Fn\x8F\x8DB\x9E\xCD\xF6u\xC1@\xB5\x9Fu\x8F\x93\xF9\xEC\xB1\xC5\x1C\xF8\x07\f\xFFQ\vm\xFA\xF0\xE3y\x96\xF3\x05o\xCA\xCA>\x17\xB9?\xE2z\v\xD7XH\x99(\xC6\x19\x8B\x94\x89\x92k~o\xDA.\xDF\xFElJ\xD3p\xE4\xEA\xBB\x1E_\xC7b\xFE}\xABo\x13\xCD\xBF\x16\xAE\x01\xF6w\xF0\xC75E\xD3\x9A\xCBwr\xFD\xD3zde\xE2\xF2\x97\xECjG\xE1M\x87\xB2hH\xFE=;\xE6\bA\x85\xE0{^~\xC4\xF6o\xF1\xF7o\xDC\xBBew\xD9\x8B\xBE\x7F;,:\xFF<\xBC\xFDE\xF9\x80,g\v\xDE\xF38mA\xB7H'\xCC\xB2\xD7+{FZ7B\xD9q\xB8\x1F\rw_.\xF6+;\xE8\x07B\x7F:\xFC\xF9\x1D\xC1\xF5\xEF\x85q\x82\xB8\xCD\xDAi\x10\xCA$\xD6\xEF\xBD\x92x\xA1\xA8\x156V\xB0\x9F>\xDE\x8F\xFEC\xE5\x0E\v\x17\x10o\xCD+\x1B,\xF2\xB9\xEB\x1E\xA6\xFF\x87\tV\x1CO\xF2\xF5\xEF\xD2\xB6\xB4-mK\xDB\xD2\xF6\xFB\xBB\xF9\xAC\x10\xAA,\xD8*\r\xE3QNn\xE3{\x05G\x834/$\xE4\xAB\x05\xE0\x9E\xAB\xF8\xAC\xF1J\x80\xFF\xC73\xAD\xFBm\xEF\xFCH\xF6\x99\xA8\x90t\xC7\x96\xDF\xA6\x1F\xFD\x7F3\xC4\xD0\xA2\x04D\xDC\x19QE\xD7\xE3\x0E\\{\x0F_\x83\xC7\xFFo\xD1\x7F\xC47\x1C\xA5\xEEY\x96\xBF\x0F\x9A\xBB\xBA$&\xE2J\xB6s\x8A\xC4\x00\x95\xB1\xA9\xB8\xAF\xF8\x0Ee\fJ\xB4Ci\xEA>\xB4\x8ES\xFE\xAAJ\x10\x7F\x85t\x00\x1D\xE1r\xA7\x8D\x95\xC9\xA8\x9C9de\x99H\xFA_L\x89\xAE\x98rd\xA2e\x94\x1E9\xE5Um\x90\xFB\x89\xF8\xAC\x908\xB3\\u\x94@\xF2\xC2\xD2\xDEA'*\xD1\x0Ee=\x94u+\\vb:\xB79'\xE8L\x92d\x05\x82h%\xEBZ\xB4:\x14\xD6\x01\xC5YQB\xF7\x94\x8F\xCET\x89uO\xC4\x17\x14\xB3\x83Ux\\\xC3\\\x00+,t0\x1C:\xFC$\xC6J\x17\x80w\xA68\xBB\xC2\x9FB\x19\xE0\xFE\x85\x0E\xD0~v\x00\x9B\xA6\xB2\xDD%t(\x0E\x14\xD2\xE5\xA3\x82\xE9\x96t\xFAk,\x1FC\x82\x8Cn2\tL\x13\x9B\xA65s\x98$\xC1HlX^\xC3\x06\x06\xE0\xA6\xE91\xA8\xD1\xDE\xE9[R)\xE1\x05\xAAL;\x01Z\xE0\x96\x83\x1B\x80w\xD5\xD4\xA5\x04\x97\xA6\x1CaDU\xDB\x93b\tLgY\x97Lg\x93\xF1!\x1E\x18\x035k\x12\xA4Ug\x93\x9CUn\x16wj\xBD \x10P\xD7o\x9A\xA6\xBDM\x12\xFA\x95\xFF\xFA.]D8I\xF5\x10\xD4d\xCA\x94\x115j\x12j\x90\xBB@fd$\xAF\xB1\x02\xCE*5\xD3;\xDD\xCE\x1A\xA7s\xEF\xCDq\xDF\xCATu\x92\xF1x\xC3t\xB6wz4M\x90d\xE1\xDD)\x13\xBD\xD3\x0E\xD4\xF3z\xA7}\xE6>\x95\xE2\x9F_9+L4\xAAJ\x87\xD0\xE8l\xCA\xD3~n\xB2\xF1\xB6\x9A\xDCLO\x1C\x82\xBA\x8EGa\x99l\xD1\xBDA\xD6,\xC8X>\x86\x04U\x04R\x8E\x11\xDCic81b\x8D\xAC\xFF\x99\x85\xB6f\x87'\xBD\xEEf\x03\xDF\xAD\xE5\xA0\xF5\r5\xA7\xC7GR\x82\f\xB59(\xFF:\xD9e\xE3\xA2\xCE\xF2\xBD\x04\xDFH\xE7\xA01d\x9A\xDB\xEF\x13\xF9\xB3\xF4\xEB\xF0*-\x97\x18\xDA)\x18u\xCC\x9C\x891-7&\xE5\xFF\x1B\xFC\xBE\xB0\xF0N\x8B\x9D2\x92\xA0\x1D\x18\x07,\v\xFF\x83\xC8{\xD4L\x86\x13q4\x83\x9E\xC8M%Z\xB2\xBAd\xA4H\xD7\xC5+?f6[M\xE6\xD17_\x7F\xBB\xB6m\x84\x00Z\xF6\xBE\x12\xEE\x9A\xF4\xCD\xCC\xB5\xF8\xCEt6\x9B\x1E\x1AI\xBC0\x9A\xC7\xE8^z\xE2\b\xC1\xD0\xC8\x10\xB4\xE8\xED\xCD\xBE\xD5\xBDF\x9F\x9A\xB7\xD3L\xFE\xB5a4\x0FP\x88\xB4\xD4n\x13#\x16\xC6\tF\x13\xD9]&\x86\xD2\x0E\x96\xA5G\xD9\xA0v\x1D\xEF\x13\xA1\xC2\x1A\x95\x93\xD1\x12n\xF7Z\x13k\xF6\x93\x04'M\x1C\xEF\xD6N~\xC3\x8CY\x88DR\x88P\xF18\xC5\x06~\xAA\xFB\f\"\xDBN\x1B\xE9\xB7\"In\x91\xEF\xD9\x15\r\xD0L\xB5L\x9D \xF8R<\xF5\x16\xC1\xDCl\x8E\x17\xAA\x86\x11;-l\xB0\x14\x9F\x99\xDE\xE8\xAF\xE6\x0E\x88*\xDBF\xFA\x94\x85\xA9\x88\xE3\xE6\x83\x8B\xFD\x8D\x05I\xB7U8\xDE\x1D\xE7\xD47g,\xA1\x7F(\xFEF\xFC\xEC\xDCZ\x18\xD9\xB36#\xC9\xE1\x8DW\x91\x9C\x1B\xC2J\x10\xEFe\xCF\x85!\xF5\x8C\x91>6\x17;V\x02\x8Cd\xBF\x85\x13\xDD\xBE\xC4\r\xE3#\xD3\xBD\xE9\xCC\x96\x85\xB3/\xE6f\xF2\x98f'\xCE\xD98\xB3\x85\xB6?7\xE7\xBB\xBF\xAC\xB5\x9D\xF70\xFC#\x130\xD4S&`\xAC\xFD\x9C\x89\x8A\x85\xB36\xDE\xEE\xC5\t\x13S[F\xA08o2\x15q|\x8DK\xFCE?\xCC\xE6\x05\x8B\x17|\xAC;\\\xFF'bZ\xF7\xD4\xBA\xA4\x85\xFFs(\xC5\r\xA7\x9CKae\xEC~(c\xB1\xA1\xF4\xCACC\x1C\nU9o\xA7\xDF\x9D\x12Y\xBF\x8A\xA0p\xAC\xBC\x92`e\xD2\x91\xE9g\x97K\xFD\xCF\xB4\xF7P,\x16+v\xCB\x8A\xCC\xE7\xF7c\xE5T\xCE\xB5j\n\x95\xB8l\xAD\xE4\xC8Z\xDE9\x11\xE7\xEB\xCAx^\xE8\x9FOP\x15\x9A\xEAP\x8E@a\xABN\xA1\xFF\xA3P\x83\xA51d\x99\xE9-\\\xFD)]\xEE{\x81(\xAC\"\xA5\x92\xDDdc\xF5\x84\x7Fe\xFAF\xF7\x94\xF3\xF5\xA1X<I\xF5\x7F\xD7\x84x%'b\x0E\x94dl(Y\xA5\xFF\x9D\xED\xB3\xD2\xD1\xE3\xB0\xE5s\xAA\xDBF\"\x8F8\xC1\xC8\x90\xB3\xAA\x9F\xE9|5\xC1I\xA2\xBBY\xED\fV\x8C8\xC9i\xEA=\xF6\x1EE\x84a\xA7\x98\x15:\x19\x1F1w\x8D\xFC\xDA\xC2\x8F\xAFI\xB1\xE0sp\xFD|i\x9C\xEA\xFF\xD4p6\x9Dr\x92B\xFF\xC7r~\xFCCd3A{\x88l\xB2qi*'\xF5\xBF\xA4b`\xAAj\xE35\xA9L\xBC(\x13\xEB\xD2\x1B\x80\xCBS\x9ESK\xA8\xC4\xC6#\xC2G\xAE\xC6S\x05\x8A\x7F\x1A\xE8\x95\xAE\x8D\xFFJ\xF7\xDF\x9A\x8CkT\x81\xE7]\xFDO\x10\t\x12\x83\xABB\xA8~5\xCD#\x04\xDCb\x97\xE9\xDE\xE9\xBBY\xE3\xE9S\xC0\xE6\xB8\xCF3\xA5\xA6\xD3\xF1\xF4\x8Ek\x166\x1D\x9E\xD8L`\xB27H\xAF\x8D^\xFA\x1E\xCC^~M\xB5\xFE\xDF\xA92h\xD5[\xA0\xB6o\xA6\x1F\x8El \xD8\x92g\xFA?\x9E\xDCB\x1B\x1FF\xE4y>\xA84S\xFB\x97\xE5\x85o1\xA8\xFF\x85\xFE)\x03o\x9B8\xD5=2?\x14\x8DYh7\x12<j\x97+\x90\xB3sc0.<\xB3+5\xD3\x1B\xE77\xAC\xDD\x88\xC5\x03\xB5\xBCS\x15\x1B\xF1X\xEA]\x82\xB7zs\"\xE2\xD1\xC8\n\xBA3\xA6\x7FN\x19\x89w\xE6\x8AR\xFFl=\x05\x9C\xE9mw\xDD6\xA7E\x05\xD8\x84\xA8jd$\xCF\xB2\xCA \xF3\xC0\x99\xBC\xF0t\xB4\xD3\xFD\xC5\xCA\\V\xEA\x9F\xAC\xD4?k\x83\xFAG\xC4]\xC7x\x16\x83!u\x9C\xF1\x8F\xF3\xDD\x9C?0\xBB\x92`~\x8D\xDF3\xE5\x9C})\xBD\xDB\x88\x9D1&*6fY\x10\xE9B\x1E'\xBB\xA30\x92\xBFz\xC9_\xFC\x85^\xB4}K\x82\xBB\xC6\x10y\x95\x8E\xD1\x18\xF8\x95\x8D\x99<NZ\xE8\x9C\xCB\xBE]\xC2\xD99\x07J\xD7)a\xAE$\xBC5^\b\xA3b\xF9\x18r\f\x81\x7F\x9CY\x81HL#w\x91\xEFY\xA8L%8\xE5\x05W l\xFE\xA9\xACTR\x17%\xE3\x1C\xF6x2\x19\x98\xFF\x18\xCE*\x82\xCA\x9CC\xF5\xCF!G\x9A\xA6\x93R\xFF0+\xD3\xA1h,v@\xEA\x9F\xAD\x9D6\xE2\xC9sVHI\x88\xF9*\xF0\xD2\xCF\x8A\x13w\xF5\x8F\tNw\xC3r\n\x12\x1DJ\x1AJ4\xEEV\tW\x92h\xF9tP\xFF\xAC\xE1\xFF\x17\x93\xA9\xE0\xFC\xF33\xB1!\xC2\xA6\x8B#\xFBJX\xFD\x88\xDF3\x9B\x8A'\xB3\xB1d\xB1s\xAA\xD8E\x10\x8B]\xC85Fg\xEC\xB3P\xB2\x17$\xFD\x9A\x8A\"Vy\xED\xB8\x98-+\x9F>\x9Fj\xCB\xD4\xF9\x04kL\x9C\x9F\xC7\xBBJ\xB2\xDB\xC4\xCAX\x12\xFA\xAB\xB28\xCE\x00\x80\xD5Rav\x11_\x19t\x85\x97E\xC2S\x04\x93&&\xBBF&G\xCDB\x1E\xAA\x1E\x85>\xC4\xCD\xDA\x8C\x96?\x87\x16u\xEF\xEAT\xFE\xAE\x14\xA7|\xAF\xBC\x99\f\xAE\xBF\xCC\xBD\x04*\xCC\xEF\x11<E\xCFe\xF2\xDF\x92\xE4\\4`\xCC?\x8F\xB7\xC4\x8A]C\x82pF\xCF}\x17x*\xB3\xBC(%A$<\xB2\xEA\x03\x8C\xD1=\xF9\xF4>\x8Aq\x91u\xEC\xF1~\xA9\xC6\xF4\xC4\xA3\x994ZbO\xD1f\xB3\xA2\xF1\xAA\xD2H-\"d\xBD0\xC3<\xC2\xAE\xB3\xA0\xE5\x8B\x13\xA3\xE3\x8F\x9At\xCFwL\x14\x8B\x7F\xEA\x9B\xBF%\x9E\xBA+]\x99Yx\xAAk\xA1HP,\xF6\xF1@\x85\xEFumEKt\"\xE3\x9B\xA9\xB2\x8B\xAA:\xBB\xC5\xFA8\xF4\xF1}6\xA0\x0F\xEC\xB3i?'Jx4\x93\xDDk\xE2{\xAB\xB3\xD0/\xE6\xE4K\xFBg\xE8\xA4\x82\x8A\x10\x8B\x90)\x12<\xE2]W\xC8@\x81\xE3\x9F\x19\x99\x1CMN\xE6\x11\x1F\xFD\"\xC7\x7F\x82\xE3\xDFu\x1A\xFA\xF2b\xD7g\x1E\xC9\xA4&\x99(\xC6G\xD5\x94_\xFF\xA8\xA9\xBD\x04\xF1\xA1\xF4\xA3\x04\x05\x17\x7F]\xE2\xCFj\x1C<\xA2'}\xF8O<\f\x142\xD7\xB9\xF8\v\xAE!\xB5O\xB2\xA5%\xF3])\x81\xBF\f\xED\xA0\xB3r=\xB3\xB7\xCB\x81\x9EdF\xFB\xA4h\\\x0F\xCE\xFFu\xF1\xBA,r\xD6 \x17\x7F=](\x0E\xED\xA5'\x9E\xF30\xC1\xBE\xA2\xEF\xAD\xAA\x7F\xFC\x91\xD1t|T)t\r\xED\xCB\xA3pY\x8E#\xB6\xA7\xEBF\xE8\xCE#\xA3\x7F\xE3;2\xC3\x86\xCFco\x86\xD0\xD2N\x87\xA0\x0FO\x10|7OG\xF1\x9D\xAEC{-<\xDA\x95\x84\xFE\n\xCF#(\x16\x97\v\xFC\x99\xFF\xE5\tS\xE4\x17\xB8\xAD\x89\xF9O\t\x1DC\xD9\x8E\xA1\xF5\x17\xF6\xE3\xF0\xE7wp. \xB1\xF0|\xED\x1E(\xF6\x8A\xA9\xA9\vb\xCB\xB9\xEB\xF9\xF0\xF6\xE5\xC3\xFE\xF7\xAF\x96\xEC\xB6q\xF8\xFA\x8D\x9D6:\xA7\xA2B!+Y\xA1^\xD8sG\xA6\xB2\x9DS;\xE4:\xF7`\xB7\x8D\xF8\x8Fv\xB8\xFAGp\r\xB12\xC7\x170\x02Lr(%\xEC\xEA\xF2\x81=\xDC\x0F4\xDC\xD3\xA1h\xD2h\xBFQ\xAE\x7F/\f\xEA\x9F\xCB\xF9\xFF\x17\xBDv$\xA8\x7F\xB2k\xA7nYA?l_\x01$\xB6\xFB\xDE\xAA\r/^\xB0={x{k\xE7\xD4\x8ED?\xBA&\xC4\x8C\x85|\xFE\x1E(\xD1\v\xB6G\xAB\x16\xD7\x87?\xCF)4o\x81r#+a0\xBC\xC2\xC6\xF9\x04\xAB\xF2\xE8P\x945\xFDX\xB9=\v\x85|\x82\xBB\xE9'\xDE\xF0\xAF\x7F;,|\xC2\x85\xAE\xE1\xF4\x92\xDDki[\xDA\x96\xB6\xA5mi\xF3\x99\xC4\xBD\xD9eU\x15\x00\xD7\xE2\x1D\xAA\xF95\x04\x7F647\x89\x13q\xA4J\x02\x95\x85o\x0F\x16\x1A\xB6R\xBAW\xE5v\x91\xBA\xBD\xA1\xC5,\xFF\x84[\xD1\xDDd\x01\x95\xF5!D\x9B\xF5\x8C\x84\xBAd:\r}0\x81g\xC1\xAB\x9D\x87x\xC4\x9D\xD3y\xC8\v\xB0\xA1\xB3>/\xB4\xB5\x9D[\xD1\xA1D_\xBF\xC4\xF1\x8AN2\xBB1\xB3\x96\xA7\xD8\x8B~\x80E 8\t\x8Bp\xD7\x00\xC5\x9F\x19\x94z\x8E6\xD16\x1F^\xE7\x1A\xCD.-!>\x91\xEEbk.\xB68\x9A\xED\x80W7\xF0\xFF\x9Arh\x7F~x\xAE\xE0\xB5\xF0/\xFAh7\x9C\xAE$\x812\xCF\b\x88\x04\xFE+\x19\xD1w\x07\x10\x9F\x88\xAE\xB4\xD1=5\xDBY\xA2\x93\x99\xF3\x19so\xCF\x07\x13\x7F\x9E\xB5\x9A\xE2\xE1\xC113\xE5\xC5\xF30\x83\xB94\xB04:Po\xEA\x9D\xB6\xD0\xE8\xEC\xED\xDA\xCA\xC3\xED\xD8)\x87\x00\\=\xED@M\xB1P\x9F\x14\xA3\xBFHl:\xE6@uzY\x1D+a\xFD~\xE4\xBF\x03\xF8\xEC\xFEi\xFE\x95\x9By\xAF.8\x9F\xA5W\x19\xBF\x9A\xFE-\xF6\xDA\xDE\x1D\xBF4\x1E\x85ZLw\x9F\xE1\xE1+\xC1EG\x11j\xF4\xF2G\x1D\xA8\x93\x00n{]4\xF8\xD9\xE1Y\x9E\x01M\x9B\xB5\x90)\x14\xD3\x16\xAEd\xF6y\x18\xCE\x95\x1F\xCC\x8AO\x1A\x1D\xEF}\xCF3\xB1\xD7R\xE3ioEs;\xB3\x9C\xCB\xC3\xA2X\xB6~8\xED\xA0\xB9}\xFF\x9BS\xF4\x14>\x1C\x16\x1D=\xF6\xB1!h\xC5]6kM\xCBAs\xC6\x86G\xA0\xE5h\v\xCBR\xDC\xD5\xF6\xCD?\xA7+\x97\xE1ol\xE4\xC6p\x1E06:\x12\x1D\xCD\x03\xDA\xA7GM@\x9B\xA5\xC7\xAB\xC2\xA5\xF5\x8D\xE3\x0E\xB4\xD9\xFB^Or\xF9\xDF\xE5GO+BsF7+\xDC\xE0_\xD8\xD9'OI\xF1n\x0F\x8F\x14o\xB7q\xD7\xF1\xD9\x87l\x8CXx\x89\x19*\x1F\xFA`\xCA\x7F\x84\xCA\xFF[[\x98=,R<\xFB\x84G*u\xD6\x16\xC5\xFE\xC0\xABT(\x85c/\x16\x11q\xA62t\xBC\xA2F\x06c\xC8?;5\x00\xA3\xFD\x04\x01\x8C\x14+\x00]|\xF3\x98\x83\xC8\xCC\x1C\x95\xFFW\x11\xA1b\xF9F\x81j\xA1\xD7\x8F\x95\xDD\x92\x16\x9B\tff\x9DJ\x9E\x95\xD8\xB0\xE9\xD5\xE9\xF12\f\xF5\x17\xF7\xE4\x10I\xD8\xE1\xFF\xC9\xE5\x7F\xC6\x9F\xECN/\x91;\xB1\xC6\xE1\xE5\xA7{v\xF1\x12\x8Bx}\xCD,\xB7\xB7Wf\x0F\xBEI0\xF3D\xF18\v\xEE\xA5\xFA\xC7p\xDE\xFA`\xCA?OM\x9A*\xF2\xCF\x89\x98\xC7\xC6\xCC\xB4\xB7\xAB\xFFsP\x9F!J\x01Jj\xFF\x9B\xCF{\xC5\x01\x99U*>\x1C\x85\x92\x96\xE9T9(N\xACP\x84\x92\xA3-4~\x9AG\x7Fu\xADh\x05\xB0\xFE\x1B)\xFA*a\xDB_\xF7\xA3g(J\xE8\x9A\xB7\x8F\x85\x82\xCF\xC6M\xF0\x9A\x95\xAC\xB2\xF0\xF7\xA1\xCCv\xBF\xDE\x07}\x9B\x1B\xF2-;\x13\x85\xF2\xFD\xEE\xD7\xE2PN\xD2\xD7\xF0\xD0\xBF\xF0\xDD=L\xFFw\xE5\xD15T\xBC\xC8\xC6\xEA\xA9\xD956\xBA,\\\xD6O\x15\xE3\xFA\xFC\x07S\xFF\xD3\xA7{s|\x81O .;|^@\xFF\x1B\x9E\x9F\x14F\xA1w\xFA4\xD4\xD4\xA3\x99m\x9E\xFEo<\b\xE0\xB2\xB9\x01\xA8#I\x93kf\x07*\xFE\xE3\x1BE\xA1\xCF\x8D7\xA0R\xB1\xBC\xE4nz\xA1\xCC\xFE\xFF\xEE&\xDA\xF4\xDA0\v\xCE\x96<Dy\x1A\xF5\xC0\x16[T\xE2\xA0G\x16hk\x99\xFD\xC7\xB9\x93q\x8B_z\xD9%\xD2j\x19\xEA\x13\xCC%!\x1E\xD2\rq\x877{Y\xC1\xD9@\xF0\xC9T:e\xE2\xB2<+\x96\x1D.o\xFE`\xCA\xBFq\x1D#E\xE1\x19\x1F\xD9\x93\xBD\xAF\xB8\xBF\x9C\xF6\x07RDrP\x9E9\xBEf\x18\x863\xC3\xEC\xF3\v|8\x11\xFA\xE2X\x88\xF5\xC1x\x82\xD5mw`\xE4\x10qf\nc0\x9C3&\xA3\xF4b\x0E\x853\x97\xD0;\xB5\xF0\xF0\xF9\xAE[\xF0l\t\xB3O\xF41\xF3\xB8\xC3Jo\x14\xCF\x98^\xDA\x82\xB3?\vc\xB6r\xB4\x0F\xFA+\x9E\x9BRt&\x05\xC3Y\xE8\x1D\x86Ag>]\xBB\xC4-;5\x97\xE2N\x84\x85'\xC6O\xD9\x98\xD9\x9F\xAB\xD8X\xC8\xF3\x04\x8A\xF1\xCA\x073\xD8\x92ek\xAE\x8Aq\x0E\xA2d<\xE6\xC5\xD3\xB2\xB0U_)\x8A\x96\xC2\xEA\t:\xFF\xFC\xEE\x06\xCD+\xFA\xACPTW\xBF9\x00e\x92\xE9\x9F\x14\xCF\xA8Z\xFDz\x1C\na\x99S)\xAE\x7FV=\xCA\xCEJ\xA6\xDDB\xF3q\x13]\x978k\x18\xE6\xCC\xAA\xC6|\x04\xF2\x8A\x9DS\x80R\x8C\xC7'\xB9\xE3\xA3\xDB/\xBD\r\x0E\x14r\xC1D\x99+\xCF\x7F\xDA.\xE4\xBF;6\xC0g\xAA\xAB\x93\xC5\xD5\x04\xAB\x14g\x15\xC1j\x13{J\x80^L|0\xF1\xD7\xA9\xFC\xEF\x7F\xF3)n\xE2\xDE?\xE3\xCD?'-\x118\xCD\x0ES\xA1;\xC5}\xF4\xEF\xFE\xD7\xBB\x00\x14E\x92#\x95\xFF\xE2\xEA>\xE8\x93,\xDF3\x0E=\x85\x16g\xF2N\x07\xFAx\x81\xB3\xAB\xE9T\xFF<f\xCC\x00\xD8\xD7\xEB@\x17\x85\xB6\xF7\x94\xF0D&Ud\x14\xF7\x8C\xC1\xBE8A\xAF(\xE4\xBF0JO|\xFA\x98\xC3\xF5\xFF#\x81>Gig2\xC3\xBC{\x83/\b\xF9\xDF\xCBJi\x17L\x14/\xCB>j\xE3\xE9\x99\xF8~\x1BE\x9E\xC0h8\xFBK\x1FH\xFC[F\x01<\xCC\xCD\xD1z\xB2X\xF4z\x99\x0F\xE0\x9F\x82\x1E\xDFWLA\x8F>\xBA\x99\x1E\xBCO\xE0O\x8F/v\xAD\x85\xFE\x03\xE6\xE0X\v\xFD\x16\xE8}\x8Fk\x05\xE8C{8\x17\x1Fk$\xFF\x0F\x9F\x01\xF0\xCCD\x1A\xBA\x90\x7F\nT1\xF5D\x9Eb\xBE\x97\x9E{\xA0@?\x8B\xBBS\xA0\xD7J\x14:\xB6\xC2\xF8g\x97\x99Gv\xC6\x81^\xDC\xDBU\xE6-\xC7GE\xBC\xDC\xDE\xCC\x00\xBF\xAD\xC5\xA2V4\xF1\xB0\xBEv\xC2b\xC6\xFC\x12\xD0\x98(|0\xDF\xBF\xCCbO\xA6\x9E\xE4&\xEE\x9E\xD7\xD6\xBB\xBF\xB0\xB8w7%\xFC\x02(\xC9\xC4\xF6\v\xA0D\xFFK\x07\xD5$\x17\x88\xC2y\xEB\xD9\\\xE5\b\x94#\xAC\n\xCF\x114\xEC\x80\xF2\xE4\x1F\xBE\x19\x83r\xCBZ\x9E>\xC0\xF4Og\x98\xCE\x9AV\\\xB0\x11\x8A@\xB8\xB3D5\xC6j\x96C\xF7\x87\xF4\xEF\xCCZ\xDB\xD3\xFF\x7F2\xB5\x00e}\xE7\xEC\x16\xE8\xB7\x8A\x12?\x81\xF9O\xB1\xFB\xB5&\xDE\xBD\xC3\xDB\x05\xFE\xDD+v\x00X\xDB\x8F\x9E\x98s\x11A\xF7\xD4\x91\vl\xF4\x10\xD6\xD5\xE6\xCC\xDA\xA5\x8A\xBBK\xDB\xD2\xB6\xB4-mK\xDB\xFF\xBE\x1B\xA9o\xC9?\xB7z\xD9m\xBD?W\xB7\x10\xB5<\x02O\xEF\x03\x8F\xE9\x97_9EO\xF4v\x11\x84\x1F\xBD\xDD;\xB8\rPC\xDA\xEF\xEA5\xF1m\xF9\xAAK\xD7\x9B\xF3\xBC\xBF\xF8\xDFi\xFB\x02}]\xF3\xA9\xDCn\xFB\xE1\xC9;K\x18\xDE\xE5\x88\x84V?\xDFr\xB8\xEC\xAF\x15[\x99s\xC4\x01,mvP\xD6\x9C\xAD\x1C\v$T\xFA\xEB\xCCF\x19C\xAC\xCB\x8C\xEA~\xD8]\x02\x9A\x9B$yo\x99\xE7t\xB7I\xCFN[\xF3\x80{\xF0n\xB0\"kp\xD3\xF6Y\xDC\xB1:\xCB#\xFA\xB6\xD8xG2\f\xBCc\xE3A;8\xA9\n;\xEF\xD8y\xEF\xD2\xB4\xB7\x82\x9C\xBF\xA3\x04N\xDF\xCD\xF0\xFFK\x7FE\xD4\xFFo\xB7\x9E\x12\xE6\xAD\xEAR\xBC\xFE\x14\xD4\xCC\x86\xADgLTN\xB4\x03\xB0\x12\x13\x9C\x06A>\x15\x85\xDD\xEE<\xB3\xB9}\xF7*\xFA\x8F[Jw\x13\x1E\x85\xDEN\xF7\xC7\x03%;\xE91\xCD\xED\xBB\x13\xB9\xDD\x8C\xDDV\xD4\b\xE6\xB7F~`L5\xB7\xC8\xAF\xC3\t\v\xEE\xDD\x07/\x9D)\x0F\xDEo\xC3\x12\xBDe\xD5\x8AyD\x9F\x1A\xE3\x91\xC0I\xD6\x8D\x0E\x19\x15?\xB1\"H\xE6\xAC\xFC\xF3\xE6\xEE\x83\xBEK\xB7\xBBdX\v\x84-N\x05\x1A9\xE8\xB9\xCD\xE4}\xC1?\xC5\x16n\x0FW5\xAE{f\x8D\xDB^r\xE8\xB2t/\x05v7\x1B\x89\x1F\xFF\x80\xFC\x9Fh\xFF]\xE5\x9F\xB1|\xA3\xAA\x985\x0Fs\x85\xF1\xBC\xFC:,\x98\xDB%)\x99\xCA2\xF4\xF9\xAF\vy\x97Q\x9F\xE1\xDF\xCA\x92\x82\x8Dk\x13L\xAEO\x13$\xF2\xB8\x82'\x89\xE7\xF1\xAB\x8F\xFD:0\xCC\xC6\xEB\x12y!\xFF\x8C\xFF<\x87\x16q\t\n\xBD\x9B\xAD\xA0\xFC\x11\x94\xF6D\xFE\xFD\xC2\x9FX\xD5\xA5\x00\xFDd\\\x99Lq\x15\xC1\x9A\x13\xF4\x8E\xE4\xCE_W\xA5\x7F|\xA7h\x9A\xE1\xE8!\xEE\xE1e\xBE^\xC2\xBC\xCEj\x1E\xC9@\xE5\x85XR\x83B\x92\x8D\xDA6F\xAD\xD0cyI\xFD\xEE\x07f_J\x8B\xAF\x86\xC3\xE5\x7F\xF09q\xB9\n3\\\xF3n\\\x96\x07a\xBAQ\x14_\xE6\xEF\x02\xB5\xC8\xC5\xF5\xFC~*\xF6w\xF5\v\xF9\xCFTa\xA8l\xDB\xDC)\x94\xCCu&\xA0}\x1FM%\xEFqh\x91\xD5\x9F\x8D\x7F\x81\xF1/\xEF\x93\xFC\xAB\xA0\xFA\xA7\xAA\x14&\x8C\x97}\xF2\x7F\xF0\x9D~\x9C\xFE\xEB\x8F\xD7V\f\x07\xA7\r\x97\xF8Wl\xF3\x9Dc\xCF\xF3\xC3\xDE%\f\x9Fp\x19\xC6\xC1\x93\xC9@\xDA\xCBU\xAF\xCD\xA31~\xD7\x1C\xD5\xA8*\xEA\xCB?+d\x9C\x15_CJ\xC2\n\xC8\xFF\xE6\xDE\x01\xCE\x83\r\xE08A\xE5uv\x7Fy4;\xAF\xB5\x1A\x11E\xB4\x8By\x8C\x12|\x95\xC1\xFE\xED~\xBC\xF1\xF9 \xFDN\x88\x8C\x12qK>c2\x9C[DWwR\xE5)'!\x8D\xEDh\xFA\xA3g\xDF\x1F\xFD_\xB1\xA9\xFCwV5\xAEx\x88]\x91)\x12\xA0\xF3\xCD\x8FPE\xC0\xD8\xDD\xFD:\xC7\xF4qa\xC5\xAD\x01.\xFF\x9A\x85\x10\xA3-\xA2\xF2\xAF\xE5\xC33\xCF\xFB\xDB.\xC44\xE8\xD9\x05}\xBCh\xD1{\xA4\xFA\x1AT\xFD\xB32\x16*\xCF\xCD\xA7\xEF\xD8\x01\xFD\xFF,\xA3l\xE0\xBF\xF6\xDA(N2\xE4C;|\xFD\xBFv\xD0\x12\xEF\x91\xE5\xFD\xA2L\x86\n$c\xC1\x99R\x833\xF8\x920\xE0\xA4M\x96v$SB\xDE\xCD\x03\xBA\x94\xFFe\xDF\x87\x9E\x8B[\xEF\x97\xFC\x13\xAB\xBA\x142w\x93\x89\xC1\xEEw\xBAm\\\xB0\xF3oX=k\xB3\x8Aa\xD2/\xFF\x83%\xF3\xB6\x97~A1a\x0F\x14\xC5\x87\xCB\xFFeA\xF9\x9Fs\xA0\x16\xEE\x9A\x99(Z\x02|\x15\xD5\xEF_\x9E\xAB\xC2\v\x16`\x99\xC8\xBE\xBC4&\x99\x1A\x99\x1D\xBB\x8F\x97301\xC3\xD9?\x94Qo\x16\xA4\x17\xA3L\xAE\x1F\xEB\xA7\x8D\xBF\xD3/f\x1A\x1Bo\xA8*\x9EK\xC8\xED\xE2\xC9g\xD9\x01\xDF\x871\xEE\xC9\xBF;\ti\xFC\f\x8C\xDC`\xE9\xFD\xC2\x7F\xD2\x92\x1C,\xDE\xFBw\xD2\xFD\x18W\xCC<\xB0\x87\xE9\xFF1\x86\x7F\xA3'?\xF3^hr\xC3\xF2\xC2\x9E\xB2\x1E\xD2\xB9\xAF-DXi\x18&\xFFj&@\xE8W\x8E\xA5a\x1C\\0\x84\xFEi\xAF\xA3\xD6x\x1D\xFCC=B\xFE\xCB\xB70\xA8\xF7\xF6\xCA\xF9\xCF\x1C\x95\xCC\\^x\x85\x9E\xCD\x9B\x9E\xFE\xE1\x7F\xF5\xD85\xB6\xD0?\x83%|\x92\x1DIL\xCC\x14\x82\xC5\xD3[\xCAW\xF6\x8A\xF9\x0FU\xEF\xFA\xBF@\x13\xF8\xD3[&\xD3s\xD8\xFC\xE7\xFBm\xEF\xCF\xFC?eR\xFC'\xAA\x1E.\xFD\xA0\x7F\xBA\xB2\xDFFa4F\xF1\xEF\xA6\b\x9Ck\xF9d\xDE\xE3\xA2y\xBCgX\xE5\xFA\x9F\xCB\x7FO\x89E\xB3\x18\x07Og\x02\xF2\xDFy\xAC\f%\xBEs\xAA\x8B\xB0g\xA4\xBD\xA6\x10\xBFHgSnz^\xC6b\xBD\xC4\xAE\xB2A\x11\xEFq\x9D\x19]\xCB\xA6\xE8\xFF\xF4~\xDF\xFB\x97?\x05\xEA\xB5\xFC\x99Z\xC1j%\xF0WgO\t\xFF\xA1\xAB\x18\xD4?eUZ\xEC\x8By\x86\xB3\x94\xFF\x95y\x9F1\xBF\xF1\x8F`\xFCK\xC5~\x1F\xF1/T9\x9B|\xBCI\xA9T\x8A\xD5\xA2\x8A\xB9\xFAg\xBA\xDF\xC3\x7F\x83wJ&\xDE\xED\xB43\xFDo\xB2`\xA1\x97MV\xC0]\xCB\x8F%\x03\xF2\xFFTW\x06za[\xEF\x81\x85<\xA7\x96\xC2E\xF2\x86n\x93\xDD\xD8@\xC5O\x12q\x19\x0Ew^\xC7v\xDD\xCF\x7F\xBDh\xF8\xB4\xCB'3l\xE2\xD9\x8E\xA87\xFF\xE4B\xDB\"\x9E\xA9\xD3\f\xFF\xAF\x10!\xFFC\xC1\x95\b\x14R\x99\xCE\xF9\xE4?'\x8Ak\xF0\x07\xD0\x95\xFFf\xFA\x13y\x7F\xF4\xFF`\x89vu\xBEz\xFE\xF3\x03\xEF\x80\xE7\xCA\x95<\xCE\x1Eo\xA2\xEB/V\xDD@\xF5\xE9\x9Fy/CG\v\xDB\xE6v\xE38\x9F\xFF\xCF\xF7\xE3\xA3t\r\xFB)4?x\xF2P@\xFE\v\xDB?\r\xFD\xE0\xCEXS\x17\xD3??\xB4=R#7U\x93'A\xCB\x87\xCB\xE4\xFA\xE7\x1F\xB7_\xCB\xBF\x97\xAEi\x05\xF0\x1F\xD9\xC1\x0F\xD9xtM\xC4{\xFF63\xFAA\xCD\xE1\x9Dl\xEA\xA7\xA3\xBBD\xEA\xFF\x1D_z\xAC\xEA\xFD\xAB6\x8B=\xDF\xEE\x07\xF4\xEF\xC3\x10_W\xF4\xCB\xA6h\x9B\x0E\x8C\xEF\x97\xFA\x97\x8CUK\xDB\xD2\xB6\xB4-m\xBF\xCF\x9B\t\x98\x1A\xFD\xC77\xCB\xDDM\xDF8\x8A\x8A\xAA\x92\xB7>\x06\xBC\xF74`h\bR\t\xBD\xC7\x16B\xC0^P/P?\x16\xA2m\x8D\xB0\x9F\xD2.\x89P\x87\xCB\xEAo\x99,\xE3\xC0\f^Q\xBE\xDCMoXU\xED3^\xA0\x1B\xF9\x89*\xEA\x1FSE\xFB\xDF^\xD3\x82[\\@\x95\x8BI\xB5\x8E\xA3 \xEA\x87Fr\x93\xA0\xB3?E\xF1\xB7L67K\x02#|\xA25o\xB2\n\x84J\x1C\xCA\xB9\x7F\xF2#:\x1F\xFE\x13\xB1x9\xEE\x99\x9AE\x92c\x9F\xDF\xC8,\xA6\xB5\xC6\b\x8C1\xFA\x8F~\xA6\x7F\xDFf\xCB\xBD_\xF9&\xBD\xF3\xFDb\x89zJ\x9E\xF5\xCE1\x07\xC6\x9F\xBA\xA1n\xA7=[D\xEA4P9<B\x8F\x9C\xCB \xC2\xED\xF3\x1E\xFE\xF7[\xE6\xFC\xAE<\xABO\x17\xFDU\xA9\x1A\xFF\x93&N\xEE\xCA\xCA\xAC\xF9uG\xE1f\xD0;\xA7\x80Sk\xA2P\x06`P\xFC\xD7\xCAs\x8F\x06\xAD\xFA\x83\xB6\xD7\xF3\xF6\xFE@0\x1Ek\xCD\xAC\xCC:0\xB2gdBD\xBA7\xB8.\x8EDy\x9F9\xFF\x06G\xF0L\xEA|\xBA\x06\xECt\x10.\x0F>\xC7X}\x1A\xCE \\\xE6\xF7\x8E\x98\x18\xE0\xB5\xC9\x14\xDB\x8E\xD0\xB5\xEA\x14\x17\xF7\x88\xB7\x92\x15w\xA2\xE1\x00|\x8F\x86`~h\xD6\xD0\x9CE3\x03\xAA\x91\xB6\xC4Y#\x1E\xF0\x19\f\xEFc2\x99!\xD8o#\xCD~\x1D]\x15\x83\x9Er\xE9@}\xBC\xF4\xC5\xFD6\xDA7\xF7\xED\xB7AF\x17\xD0\xE2\xF0Y\xDC\xBB\x92&\xFA\xD8\xB1\xF2\x9D\xF6z*\x00\xCD\xD1\\\xB0\xA0^\xCA\xC4\x98\x89\xB1\x9D\x9A \x98m\x8E?kK:P6\xDB\xDC\xDD\x15\x85b\xA2\xD9\xA9\xD8\b\xCBS\xF7\x07\xC2M\x93)\x02\x97\xF5\xE2W\x16\xFC\f\x18\x8F\x9A@svl4\x87\xE6\xF4}6+\x9D\x06\\a\x06iiu\x87\xC7\x95\xF1tf\xDE\xF8\xD8\b\x9D\x93?\xDD\x9F\x06\xD2:R\xBAx\xB4\xF3\xFC\xE9\xD8\xC4\xAD(J\x16\xC6\xF9D\xD9\xE62\x12\xF8i-EL\xA0K\x82\xC18\x9Dn\xE5\xC374\x18\xDB\xE8?\x8A\x7F\x9F\xCB\x16~\xD2\x87?\xA7\xA0\xB9\x95\xE0\x04\xA1\x7FY\r\xAF)D\x86O\xCA\xD1\x9Dp\x87\x19I\x9D (o\xFF\xF8Q\xA0\xE7\x9EID8\xBDLt\xB3Lz\x1A\xC9\xA7N\xEE\x99\xA6\x8Fts\xD6\xC3\x9F\x8D$n\xE1>;\x80\xFF\xC3\x90\xF8\x87\xCB\xBB\x81\x87f\x1C\x86?i\x06\x96K\xD8\x1F\xAE\x91\x7F\x17\xF3v`\xDC\x87\xFF^\x024o\xE5\xF8\xDFOD\x1D\xCF\xAB\x93\xC1\n\x80z\x8A3\xB8r\xFC\xBF\xCB\x17\x1As\x14\x8B\x87\xC9V`k\xC5NW\\\xEF\x86\xD4?=\x16\x97\xFF\xB5\xF3\fFI\xA9\xE1\xAD\xB8\x178\x98JP\xFE\xB9\xD06\xA7\xE9\x18\xC50\xFB\xDC|\x8D\x9C\x0F\xFF1\x9F\xFCs\x17\xCCh\xEC \xF4\x89\xB1Z!\xD4\x8BO\xE4q\xD5\xDD\x0F0\xF9\x7FB$\xEF7;\xAE\x01\xF3\x9D9\xE7\xCE\xE9\xFB\xA1M\xC0h?\x1D\xC4_\xEA\x1F\x8D\x93`\xC0\x883\x8D\xC1:\xA6\xAAT\xFFDX\xB1K\x83D-\x1CG=\xFD\xC3\xE4\xDF\xD3?\x84eF\x04\xF4\xCF\xD8\xA9\x88\x03#}6/\xF4O\xEA\x92\xA0q-2\xC4\xF5\xCF\x9Bl\xF83\x84kW\xFA\xA4t\xDE@1O\xEC\xE2.\t\x02e\x84\xDF\xE8I\xF1\xFE\x8D\xC3\xB0;\xA7\x98\xFC\v\x90=\xFC\xBB\xCC\xA0o1\x80\xFF\x16\xE6+\xECs\xF5\x0FG\xD5\x8F\xFF}\xB2\x04\xC9^\x82\xAFs\x87\xE0\xB4\t=YO\xFF8{\t\xFA\xAE9Y\xCC\xA3\xF2\xE6<Z\x18\xE1\xB0\x91I\x13!\xFFf>u\xB2\xF0\x18\xF7Nz\xF2\xCF\xEB\x1D\x97\xA8\xFEy\xE8\x84+\xFF\x1B\xF7\x97|\xF2oc\xB7\x9E\xA3=oNTJ\xF8\xA8]O\xFF\x04\xE5\xBFbc\xCC\xF7#=\xB2\xF9\xBCo\xEA9\xAA\x85\xF2B\xFFl\xDE\x92\xAD\xD1?QW\xFEy$d\x8EY\xEAN\x9B\x16`\xFD\x98X?&\xCCM\xA7\xE6\xF8\x85\x8A.\xFE\xCA\xF9\x1D\xCCz/\xF1\x9F\xF1\f_B#\x9DSO\xFF\xA4a,\x17\xA1\xE6L\xFE9}\xD6\xE9\x1A\xFD\xF3<\x1B\xD1\v\xEC\xAC\xDD\xDD\x0E\"\xB7\xB8o7\x9F\xFEI\xCC\xE4Q\xD9\xF5\xE0L\x1E\x99-:\"b\x15\x7F\xDBkB\xFF\xDF\xF6Z\xF9\x8Ec\xF3\xD03\x01\xFC\x99<\x98&\xC6\x85\xFE\xCFr\xDBK\xDE\x94Y6\x8Dj\x8E`\xF7h\x8E\xF6\xBC9M\xF2^\xF5\xED\xBD\x81pG\x95\x98\x1E\xFE\xC4\f\xE0\xCF\xB4Y\xF4\xDEL\x0E\xCD)\x17\xFF\xAB\xABHJt\xF0w\xD6\xA4t\xE2P\xFC\x99\x11\xEA\xAA\xD7\x1E@C\xD98Z\xA6\x93\x99\x90\x05\xC3\xE1\x17\xDA\xCBK3\xD0\x07s\xED\xDBF\xA9\xAE\xFE9YW\xFE\x89\xAB\x7F\x12\xF2\xFD\xFB^\xFA\xA7\xA7\x84\t\xE0\\\xAE\x12c\x1At\xEC\xAE\xA7\x7F\xF6\xDB\xC8\x0Fi\xFBm\xDC\xF6\xC2\x8C\x88QoDF\xCE\x7F\xC6vn\x9B\x1FIS\xFDo\xC4<\xFD\xC3\xE4a\xB0D\xE7Q>\xFD\x93\x9D6\xE9\x8C\x85\xB5P>Mp\xFA\x9E\"\xED\xB9\x91\xEE\xB1\x98\x89\xB5\xEA\xD63\xABfOI\x10\"\xF1\x0E\xD7\xE8\x9F\xE8\xDBkr0Rge\xB1\x8F+.)\x07\xF5\x8F\x83H\xC2\xD5?\xA78\xA9\xCE\xDCc\x00\xFA\xEE\xB6\xB1\f\xB74\xD0[L\x0F\vE]\xFD\xB3L\xC8\xBF\x1DK\x9A\xBE\xF7o\xB1\xFA\xFD\xDB$}+J\xA4\x06\x7F\xC6V\xD4\xE8\x11\xFA=X\xA3\x7FT\xE0\x11\x1B\xAFs\xF9_1\x0F\x9D\xDC\xEB\x06-xl!\xC5\tV}`\x02\xC8d\n\xC2\x90k8n\x99\x8C\xCA\xDCg\xEF|\xD3\xA1\xFA\xBF9V+\xFF\xC1\xF9O\xAC`\xCA\x923\x8D\xEA8An\xF4\b\x93\xFF1b1\x13\xEB\"\xF2\xFFM\xDB\x93\x7F\xFF\xFB\x97\xCD\xA6\xCE\xDB\xAD;hN\x8E\x9B\xC2j]#\xFF&\xF4\x84+\xF9y!\xFFt\xFEs\x95m!T6~Yf\xB7^A\xC3\xBC\x8B\xFF\xC5\x16\x10\x8E#Ln\xDAD\xBBu\x93(\xEB0\xE1\xB6z\xA3\xE0\xF9\xBF>\xA0\x7F\x88\xAB\x7F\xBA`p\xB6\xA8\x94K\xE8w\xDA'9\xBCNJ\x8F\x85i\x82V\x8B\xCB\x7F\x04\x91\xF1\xB7j\xBCW\x88\xCC\x9E0A\xA6\"'L\xDC\xF6\xE2\xB4x\xE2\x1A\xB7\x12K\xE0\x15\x1DI\xE6\xAD4\xD3\xFF\xC9\\\x8D\xFCW\xCD?',\x80\x13\x1B6\x97\x19\xFECL\xFF\xB7\xF7X\xCC\xC4Z\x8B?\x93\xFF1_\x80\x8D\x1F\x7F\xAE\x7Fv\xEBQ4\xDF4.\xBD\x06W\xAC(\xD7\xE8\x7F\n\xC5>^)@\xE8\x7F\xFA\xDF\x03\xD6\x10\xA0\xCE\x87\x98\xFC7L\x01\xA6\x8B\xFF\xE1~>q\x8A\x15\x18a\x8E\xA4\xF4\xF1\x88S\x84\x91_r\xE3#B\x07\xF8B\xC9\x95\xFF\fx\xAD\xF9\x10\xFD\xBB\x9B\xAD\xB6\xC6}\xEB\xD0q\xE9E-\x10\\\xCC\x9A\xFAn\xF7<\xF4\xA1\xFBP+\xFF\x89IB\xE5\x7F\x92\xE0\xC5LQP\xEB\x1B\xA9\x1E9\xFFY=\xF7\xD9\xFB\xE6\x1Ch\n\x9AS\xE3\xBFA\xFE\x97?\xE2\xE1\xAF\x8E\x99\x18/r\xFCc\xC4\xF2\xE9\xFF\xFEj\xF9w\xF1\xAF\x92\x7F\x8E\xFF\x18\xC5\x9F\xED\xD7\x0E1A\xAA\x92\xFF!N\xF8\xC3\xF5\x7F\x9E\xFD\x1DO\xD3;u\xA7\xED\x00k\xA9\xFE\xA7\xEB\xAF7`8\x16\xBB\xF4\b/\xEF\xAB\xA4\xA0\xAC\xEFd%\x9B\x05cO\xC3\xDD\x9EQ\x80C\xAD\x8F\xFA'|\xC2\xF7\x14r\x10\xBA\x07!\xE6\xC2\b]\xEEF\x97-\xF7\xE1\xFF![\xFA\xEBK8\xCC\xBAt{\xBF\x06\xE5\x16w\x12~\x81\x87\xE4\xF3\x9D\x16Jwk\x9D\x16\xB4\xE4i(7\xB2f\xFF\xB8$\xE5\xFF\xF0\xCEm\xC7-\x13Z\x04-\xCB\x9F\xF2\xBC9\xCB)\xFE%|\xB7\x84\xBF\xBD++j\xA8\xB5\\\xFBL\xBFd\xD0\n\xB5~\xD7\xC2\x0Ffv\xD0#[\xD6wX\x88\x96\xEA\xCD\xFF\x95VR\xC2\xD3\xAE\xFE\xF1}\x16G\xB6D\x9F\x9D\x89\xA2%K\xF7\x1B\xF7Pa\x8B\xB5\x06\xF1oE\v\xDD?\xC9\xFA\x96gWyj\xF3\xC1%\xE3\xD7\xD2\xB6\xB4-mK\xDB\x92\x17\x803\xE1\xAB\x8B\xFC\xAC.z\x96k\xDFN\xBD\x97a\x1FP,\xF7HH\xD2\x1E-T\xED \x88\xBE\xA7C\xC1W,\xC0W> V\xE7\x8Af\xB0{\b[P\xCCh\xD5U\xD4jz\xFF\x14$\x83\x90\f\tK\xF8\xB9\x89d\xCE\x82;\xFB\x11a\x18\xCDd\xACA\xBC\xB8\xD3\xAA\xD7[M\x15\xEDx\xDDP<<\xA3.\xAAg\xFA\xE9T\xF9W/\x12{6Z\x17\xE7\xAF\x00\xD3~&\xEA\xB0\xBB\xE05\x11f\x84\x87\x91v\x18qD$\x12\xB2J\xE3\x94\xAF\x91)KZ\xC2\xD9RZ\x89\x10D\x12\xA7\"\xD1j;\xB9lA\xAC@#\x82\xC2zn\x96b\xF5:\xDBw\xF6E\"l\x14\x91\xF5\xA7\x80XD\x04\xF7\xCE\xD98J|\xF8GL\x97\xEBC\x05No\x89\x8A5E$\xCA\xED\xF0\xD3k\xBC@!\xC6\x92\x9DF$\xC5s\xED)P\x91\x81c/&\xDE)\tk\xFFQ`\xFA\x1Ev\xA1\b\x91KZ\x81\xFF\xE9-cb\xA4\x91\xF4\xD5&\x0FRz\x9E\xA5Ls\x84]\x1A^g\xC1\xC5\xDF\x886\x01\x17{v\xF8\x91\xF1Ly\xBF\x8E\xBA$!W\xDB(\xEC\xAD\xF70(Y\xCE\x1BO\xD7\x17\xCD\x9A\x9B:\xED\x164\xF5[\xB1dU\\\x87O\x80\x07\xDFt\xD02\xFB\xD0\x9BA?E\x8B\xFC\xDA\x9C|\xD2WEk/\xC1\xC4]\xF4'VI\x16\xE3\x19G\xB0\xDF\xB4\xC4\x1E\xB2\xF1\xCE\x8CX\x80\xE4\xF9j\xD45\x89\xD0U\x8F\x98\x1B\x0F\xDA\xE0\xD7bl\xA8\x0E\x9F^>{\x99wu\x96\x80\xEC\xF0\x0E\xEC\xE7\xB1\xEE\xFA\xC8d\x973j\x8Au\xFA~\x1B\xCF\xCE\fy\x9D\xD4\xA3no\xF7\xAEv\xDC\xD1\xD1\xB5\xADJ(\x1A-\xCEY\x9B\xC7\x8C\xB9k1\xCBe\xDD\xACL9\xCB\x81\x7F\xE0\xC3aQ\xD6\xF7\x8F\xC6'\xAF;\xA9\xD7\x93\xFFO\x13<\xBB\xB7\xAB\x8E\xFC\xAB\xC3h\x1C\x12\x9Di\xCE\xBA\x9C\xAEh\x1E\xA8]E\xF2\xA57\xF4\xAD`\x8C\xD3\xE9L\nz\"W\x1C\n\xCE\x93\xE5\x03\xDA\x9C\x95E\x84\x05 \xFBg2n\x83\xF7\xFDdX\xAC\x80\xF4\x839\x13\x1BG\xC5\x02|\x8F[{\x8E'\xB6\xB4\f\xBBl\x06)\x82\x1C\xA3\xCD\xD9C\x17\x95]\x1C\xAE\xC2\xA8\xA7\x7F\x1E\xB5xZ}\x8A\xD7\xCE\xCB\x98\x14\xCC\xA7g\x8A\xE5~\xE1\x86+X\x98\xE4q\xA7|\xBDIo\xAE\x18\xEF\xFE\x9911R=\xB3\xC5\x94\xF8\xEB\xDA$\xAF\xF0\xA5Jy\rE\x93R\x15\xA9*\xF9\x1C+\x04&\xEC\x00\xC6\xC1\xB3\xB3\xF17\xEFi?UO\xFE\xBFV\xC2\xF4~\x1F\xD3x\xA3\f\xBFW\v\b\x0F\x88\x87\xD1Hr*!&~\xA6\xF7P\xCBM\x10\xF8D\x1E\xA0\x0F\x9B\x85\xABgS\x88$N\xDF3[m\xA7\x12-$\x85\x19\x8D\x15#8A0\xF3\x04\x1D\xFB/\xD9\xFA\xE5\xCC\x96\xB2\xB0\x80Eb\xA7M\xDC\xFA\x84\xC0a\xDA\x94W\xE4\xF2\x1F)#\"\xE4\xFF\xEA\x12\xCE\xCE\xE6D7\"i\xAE\xDC*\x11/z\xBC\xC2Y\xFA\x99\x02<k\xE3*\xFAu\xDC\x8E8\xFB,Q\x9E\x8F\xEA@^\xE7\xCD\xB8YtL\x1A\x1Eg\x9E8\xC3\t\xFF\x11qN\x89 \xE1\x11D\xE6\xF7\x95\x18\xFE\xAE\xFC+\xDA\xB0\xC4\x7F\xF0\xC7\x8EI\x84\xB6a^\xB3\xDC\xB8\x9E*\xDE\xF5\xEAG\xEB\xC9\xFFV\xA0\xE0\x97\xFFf\x99t\xD3\xBAV\xEA\x9F\x1C]\xD1\xBBuf\xEB\xC9\xBF|B\vt\xB0%\xDC\x949\b}6W\f\xC6O\xEA\tW\xFE\xA5D9\xBC\x9Dbq\xD4\x93\xFF\x19W\xFE\xD7?dc43\xE0\xCA\xBF8\xAB\x999\xC8\xF4a\xE83\xEE\x9Bu|uB\xF0Z\xB78\xFB\xF8:\xB4K\v\xB8\x11\xA5J\x99\xB40@\x1F\x877\xF63\xF9\xE7\xF6\xD8I\x82\xC9\f\x93\x16\x9D\xD1\r\xE9\xDFw\x83\x8A\xF7v5\t\xF5\xDC2\xB9\x85\v\xBC6\x02\xA5x\xDAd\xFA\xC7\x95\xFFp\xB9,\x11\"\xBB\xD2&\x11\xF2?F%\xF9\xB1{\xDFt\x8A\xC5O\xD7\rJ\xBC\xDA\x0E\xEA\x9F\x96#\xF2A8\xE2\xD3\xFFY/\xBET\xEA\xFFz\xFA\xA7\xC0\r\x80W\\6\f=\xF1\xC0L\xB1\xDAO'ZH\x8B\xFB\xC5\xDE)L\xFF\xFC\xAB\xDB\xE0\xB8^\x96\xFA\x7Fr7AEz$\xF2\xDE]^\x90*\xE2\tw\b\xF7\xB1$\xAFG(\xB0\xC3\xBC/\xFB/+\x07\xDC\x88R\xA5\xEC\xE1\xF2\xAF\x8F\x14\x8B\xCE\xBE\x92\x97\x17\xB6\xFF\x85\xA2\xB8\xAD\xDC\xCE\xA2/H\xFDsF\xF6v!#\xF0\x1FGd\xE1\x9BU\xF2\x8Fd\x87\xC4\xBF2\xED\xB8\xF8\xD3g\xB9\xA5\xFC\xD6\x9A\xE2\xCC\x13[\xEB\x06\xE5\xDEdaz\x7F\xC0\x1E%\xF1\x1F\x90\xFA'\x07#\xC1u\x85\xDF#PO\xFF\xBC\xCAm\x9E\x83\xB3\x05D\x12'#\xC5E\xF4OV\x1E\xEF\xF0y\xD4\x14\x9Bl\xF0\x06+\xB3\xA6(_\x12)\x9E\xB5an\xF1.'fM<H\x86\xCE\x7F\xC4\xBD\xB9\x82\xE0\xCC\x1A\xDA\xBD_03;o\xE7\xC4=\xE3A\xFD\xD3\xC7+_/\x10\x96\v\x10q\xE6f-\xD3\x04O\t9N0\xCD{\x1B)\xCB\xF9\x8FPn'\xB6\x8C\x8B\x12\xAE\x91Q\x99\xA40\x0E}\xFC\xA4\xA8\xF0\xE8\xCE?M\x17\xFF\x9D+\xCF\xF9\xBA-\xF4\x0F}\x96\x15\xF5\xDE\xEB\x8A\xC5\xCC\xFDu\xE5\x7F\x9B\x85\xC9\xBD~\xCEjyC\x1BS\xBCn\x02\x93\xFF\x84O\xFE\x05\x89\x99?\n]\xCCL\x18c<\xB1P,\x8E\xA3\xE5\xF8}?\xF9\xF3\xA0\xFC\xCB\xF9g\xF3\x88\xD4?t\xCF\xC3&\xF6\xBF\x99u\xCDb\xB9\xA2\xF37\xF2i\xCA\x01\x83/x!\xDF<r_Twj\xF1\xE6?W\xDBx\x88M\x93\x1E\xCE\xD36\xB9\x05r\xBF~& \xFF-\xC2K\xB8\xCF\xA6\xC7C\xB7\n]\xCE`I\xE4\x85\xB1gp\xD6'\xFF\x04\xBA\xC0\xE1;/\xFCZ\xD0\xB3\xE8\xE5\xDD\x84\xBF\x7F\xE3\xD0\xCF<\xC1\xE7?\xAE\x7F\xAAa~\xDE\xCDG\xDEE\xE5_u\xFD \r\xE5o\xE9\xC5'3\xE3=\x8B\xE0_<\xA1\xD5\x97\xFF\xC6.\xA9\xFF\x13\xD0\xA5^j\xCET;p\xDD\xB4d\x16\x88\xDEc\xE1{\xD7\rC_\xB3\xDBU\xF8\xF0\xB4=\xD7\xFFR_9\x9C$\xBF\x90\x19qo\xE8\xF8\xBETN\x98^\x9F\xFC\xA6\r3#\xF0\x7F\xBC_\xDEe.\xFFz\x06\xBA\xC8O\x1C1\xB1[\xA7\xAF\xAD\xC7X\x9B\\]\x14\xBBr\x81\xD7\x13c.\xE2\x96\xF61\xA6\x8E\xF6\xBC\xD9\xE7\xCA\xFF\xA3\xC0\x81.\xAEl\xCBR\xB9\x15\xA4\xFE\xF7\xDEn\x051\xFF\x8CA)\x14\xF3\\\xFE]\x9F\x93\xE9\x8A\xF7\xE0\xE1\vM\"l\xC5\\\xFEw\xAF\xFE\xF8\xC4\xEA\xF6\xBA\xF2?\x9E\xC7\x13;\xB5\xFA\xF2\xDF\xEC\xE2\x9F\xE1\x85\x03\x18z\xA9\x80\xCC\x07\x9C\x05\xF7s\xF9O\x14\x87\xA1\xA7w\xEB\x99E\xE4_{\xDC'\xFFO\x01{FKn#\xDF\xEAZ;\xCE\xC7\xD4b\x8E\x13O\xFE\xF7\xE5\xE5U\xB8\xFC\xEB9wI\xB2\xAB\x84\\f\\\xD8~\xA5\xFC\x173\xA7\x83\xFA?\xC5/\xF78\x8B\vBK\xB2\xD0\x95v\xE5\xFF)\x13{\xBB\xFC\xFA\xBF\xE8\xEA\xFF\xEF\xEC\xEB\x93\xD2\xB20\xCA\xE5\xDF8\x04ua\x81\xE3\xDF\xE0\xE6\b\x9B+\xBC\xF9\xE7\xAB\xA6\xCCSx\x9A\xCE\x7FZ\xBF;s\xEDD\xD7\x85\x1D\xF5\xF0\xFFA?\xF2we\xEB\xC8\xBFz9Z\x18\x15\xBF\xFE7h\xB9\xC7\x93\xDE\x96\x9B\x84\xCC\xFBZ\x9B\x14x\xBE\xC1\x99\xF0\xC9uw\xA3e\xE4\xD97\xEF\xA9\xBF\xFEj\xC9\xCA7\x1A\xDD\xF3H\t?\xF8\xF2z\xDA\x13\xD6\xC8\x93?9\xF2_\xC4x\xD7?U\x82)\x97Qt\x99V\xF2\xC9\x7F\xCB\x05n\x974\x13O\xAD\xFE8\x95sv\x15\xDE\xF8\xB3w}$(\xFF\x03\x1C\xFF\xBF\xB3\x11\xA5\xB7#\xBBg\xE6ZW\xFE\xF7\xE4\xB1\xFF\xCBlZ\xD5\xA2J\xFC\x05\x91\xE3\xDFwm\x93\xDA5\xB7\xBB\x9F\xAF\x8F\x92P\xDB#\\\xFF\xF0r\xC9\xEC\xB5Xv\x83(\xE6\xDA\x07}y\nK\xDB\xD2\xB6\xB4-mK\xDB\xEF\xDD\x16r\xCD\x99\x16`\xB5\xD5\xF9\x9D\xD3\xF8\xF38\xFA`Z\xA3\x82\x0E\x85\xBE\xA9dj@\x14\xA1(\xDD\xE3\xB3\xFB\x93Z\xDBw\xCDF\x868\xD7\xBD \x9F\xEF`\xD4\xA0\xC4\xA2;\x89\xB2\xAE\xCA\x92\x1F\xF7Q\xEB\xD4I\xA1\rE\xDDz\x01m\xFE\x9D\xC1\x9F\x10\x8A\xB6\xB9\x1F\xF8~\xFF\x89\xA1(\x05\xC5_w\xA0\xB6\x06\x01;\xB1\xCDm\x96}\xF67\xD5\xE6^\xD4\xD7\xB1\xC0E\xF9\xD6\xB4\x8E\"\x1B~\x10\x91\xD9\x9F\xFF\xF9l\x1B\xD0P\xB2#\xC0\xF2~\xFC!{\xA7\x7F\xA5\xB3\xFD\"\x86?\x9D\x89\xD9V\x00Fu\xDD\x065zII\x14+\x84\x1A\x85\x12\xDD\xA0F{\xA7<\xB6\xA5M\xEE\x84\\\x9D]\f\xFF\r\xC3\xEBR\x16g\x15\x8E\xF2\\\xC5\x94\x85^\x8B\xFE\xBD\x84\x05F\xF4\x94L4\xAE\xE7\xB6\xA9\x95/<\xF3\x1B\xF1o\xAB\xC1\xBF\xAD.\xFE\x12\xA86?\xFE\xFC\xAB*\xC1|o\xFC\xFD\x80\xFF\xAE\xF8\xF3\xAF\xAAJ\x97\xCC\xAA\x02mhwb\xA8bc\xA0a\xF9E\x16\x8EY\"&\x7F\xD7qV\xAB7<\x1C7Q\xBC\xA3\x8C\xB0/j\xC2P\xCF\xCE9\xA7M\x11\xDB\t#\x8A\xB0s\xDA\xC8\x9E\xEC\x1Cv\x0F\x11+\xCC\xF0\xDD0\xE2\x8B\xE1\xFF\xEB\xB9$\x8Bu\x8C\xBA\x19\x1C\x15\x1B3\x8CD\xE8\f\xA3\"!\x97\xCC\xC3\x98\xE2\x9C\x06N\xEF\xB4\x8B\x7F\x1Dk\x89/\x84;@e#\xA3\xBBk\xF7\b\x96'\xF7W\xB6\x07a\xB93hQ\xF1_(p\"k0\xF0u\xCE\t\x9C\xE8\xEB\x98\xF8\x95\x7F\r\xAF\xD3\x84\xFC\xDFS\x99\x9D\x8D\x01jk\xD3\xE1~\xFA\xEC\xDF\xCE\x1E\xFA\x90\x12\x1Df\xE5\x8F\xE3\x16*S*\x1A}\xB9\xCF\xCD\xA91\x96\xEF0&\x17\xADP\x87\xEE;\xA1\x8D\xC5\v\xEE!\xDF\x12e\x97\xC7y\xA5\x80\xBA\xDB\xF8^'\x97gY\xB1\xEC\x98{M\xECf\x13\xF2q\v\x0F\x9D\x88Q\xF9?\xA4\xA1q=Oi(\x8CN\x8E\xE7\xDF'\xF9\xDF\xEA\t\xA76\xF4\xDB\xC8\xBF\xF6;\xC8\xFFV\x84\xB4\xBA\xF2O\xD7wT\xFE\xA7v'b\x83%\xA8\r\xF3=L\xF7rc\xC5\xD99VL\x931#u\r\xA5\x02\xF8/K\xBE\xBC,\xFA\x8A\x89\xFF\xC6o\xEB\xB2mh\x9Ax\xF5c\xD1\x9F\x9D\xEF\xC5(\xFETD-\xE6\xB0,\xB5\x18\xFE\xFF\xFC\xCB\xE4\xCFm`Y;\x96Q\xFC\xFF\xC9\xC4\xCFl\x9C\x00~n\xE3\xD5\xEF\fH\xF9\x9F\xA8\x94\xF8\xCA\xC5\x19\xCF\xFF\x867\x1A_\xB1\xFA|\xA9\xA6\xCA_\"\xA1\x93\xEE.v\x8C\xC9\xCD\xC2\xEB\x84\x97\xD7\xF5\x1A\xAF\x83\x9Ek\xB8\xB3\xEC)\xDB\x90R\xEB\x11Wa\xB7\x85\xCB\fa\x937(J\xE3\xD0\xF5\x97\xA5V\xFB\xA0M(^\xDCt\xCF\xED\xAA(\xBD\xA0\xAAm\xFC\x94\xC8\x9A\xB3s\xCE\x04}lio\xCB\x92Cfel[\xCC\x04\xF4\x82EP\x99\x8AC\xF5\xCB\xFF\xB6o\xFE\xF8\xBC\xF1~\x19\x9B\xDD\xBC\rj~|U\xEC\xDE\xF8!\xF7\x10q\xC9\xC6\xC7\xD1\xFC\xD9\xC5\xE5?\xCB\xE4\xFF/\xE9#\x00\xFC\xE7<\x93\x7FV\x9B\xFB>f\xD0$I\r\xFA\x04/AR(\x16]\xFC\xEBXK\xC2e48|\xD0\xAAog\xD8\xE6\xF8\xBB\xD5=\xD8\xD8B\x7F\x8B\x86\xF9\x0F\xA9)\x8AU\x88H]a\x0E>WB\xC3\xE9u\xA1(\x14\xD7\xD2\xD2^s\xA1g\x06\x7F\xB4\x9CX\xC3\xCC\xBClr\xE6\x9C\x9E\xD7\x1C()zaW\xFF`\xC05\xBE\xA1\xB5_\x98\xD7\xC2\xE5\xC4\x90\x8A\x86\x93\n\xFB\xFC\x0E\xE7-\xD7&\xEE\x8D\xA5\xA8\xFEaz\xA9\xD3\xC6|^\xCA\x7F\x89\xE2\x7F\x8B\x052\xA4\xC28\xEE\xD3\x81\xB9\x85\xDE\x89\x93\x9C\xDC\x8C~}\x05\xC6c\xE5\xEE\xD4\xBB\xDD\x1E.2j\xFDy\x18\xD3\x8B\xE1_\x11\xFA_\xA4\xA5\x9Cb4\x1A\v6\xCE\x96\xB0\xB0?+\xF4\x8Fq\x90\xE3_\xDE?\xF3^\xFA\x07&T\x85\xCB\xBF\xEF\xED`\x96\xF9\xAD\x89D$\x1A\xCB{J\xE0_\xC9p\xAAb\x13(\xE7\xCB\xE0\t\x96\xF9\xD0\xA8\xA8\xF4-,\x85\xAD\xA1\x06\x7F\xB5\x90\xFA\xE4\xAF\x07\x7F\xB8\x1Cj\x8A\xDD\x02\xAAF\xB6\xC7\x15(q\xF6\xD5R5% \xFFJ\x1A\x90\xE6e%\x1D\xFF\x86\x03%\xADYT\x17\xD1\x9D\re\x8A\xFF\xC7\x16n\xB3\x05+\x14\x9D\x01\xB2a\xAE$\xDB\xA8\nV\n\x97\x95\xF0'sNP\xFFGs\x9Bc\x0F\xD926\x9B\xEA\xFF\x1F\xDCw\"qo\xDC{G\x8F\t\xFD\xFF\xC0{\xE8\xFF\xB1\x9D\xD9q\x9E\x13\xC1\xD2\"\x1E\xB21\xCE\x9C\xB0\xF7\x02\xF7\x9D\xE8\x03\x10k\x98\x87\x92\xE0\xA8n\x9A^\xEF\x02\xAB\xD7\xC5_\x13\x9Cw\xC4\xF7\xAEd\xD5\xB24a\x97\xA3\xAA\xF2\xDF\x10\x13T\x1D\x19\x8E\xB9\xA9<\xDC\xA1\xA2i-B\x9C\xF6g\xA0r\x8C\xBE\x7F\x07w9n\x95|\xDF\x83#\xB7\xA6\x02\xED\xCF\xF9\xAC\xE4P(\x8A\x86\xC3\xA6\x89\x89\xD5\x87\xD8LO\xF5\xCD\xEA}\xF87l\x14\xF2\xAF\xA6*\xBFP\xA1\xA47\xB3\xBE\xDD\xC6Y\xFA\xA9\xD8\x9B\xF4!\xBA\x83\xEA\xFF3&\xE6K>\xFD\x1Frn\xB5\xF0B\xB5\xFE'\xAF|2\xF9\n\x81\xA8\xD9@\xF5\x7F\xBEJ\xFF\xBF\xCC\xAF\xD84\x82e\x85\xC5\xF0\xFF\xD9/\xCD\x9F\x95\x80e\nm\x01x5O5\xFF\x9C\x8D\xFF\x91\xC7\xAB\x1Fc\xF8\xC7b0f\xF8H\x06\xC2\xB6\x1BD]'Z\xC6p\x10\x12\xF2\xEFs\xBE\x99\xF4\xD9Q\xA3p\x89=CQ\x91j\x11\"\xCF\x160\xBAR\x81N\x10RyPMt\x98\xBE\x7FUlE\xAB\x9B\xDA\x90\xAB\xBEP\xF3\xE3\xA9M\xE5\x9E;\xE6\xC1_\x01Jj\xB0\x84\xF5\x87\x92\x14\x7F\xAA\x03\xCB\x82\\\xCEu~\x19\x0EZ\x89T\x98fzx\x18J:Ce \x9A\xCF\xCB\x90\x06v/\xC8\x90F,\x8C\xB3\xB2\xFEt6\xB2j\xDB(\x01B\xEA\xA8U\xF3\xFEm\x8E\xE56's&r\b\xE8\xFF\xB1\xB8\x87\xBFp\x146\x16\xDFC\xFF\xE76\x1F\xF4\xCB\xFF}y\x8C\xE7Q\xCC#W\xC2}'h\xC7:\x92\xE7@\xE92y-Z%\xEF\xCE?\xEB\xCB?\x86\xB8\xC5\xD2\x87\x7F\x9E\xCD1\xFA\xFD\xF3\x19\xC2ur\x88h\xC3\xF8\xEE^^RY\xE2?\x12\x85\x9E\xAB\xFCpL\x14:g\xC4z5\x17\xCAW\xECa2\xA41\xF9'PR\xA6\t\xA2$\xD10N\xC5b\x99j\xF2N\xB8\xCE_\xE6\x05p\t\x00S\xC3)(#w\x13\xBA\xE4d7e\b*=\x856\xC2\xF0\xBF7\x1F\xC4_Q?d\xE3C\xD3\xA9\xE0\xFB79\xBEY\xDDma\xDC\xC5_\x9B\x18_\x95\x1CKx\xF8\x8F\x89'\xAE\x88\xE6E\x8D\xAD\xBBw\xC6\x18\xFE\n\xCFW\x1A#x\x90U\xBE~ \x8F\xF1U]\x00.\x18z\x1E\x8Dq\x81\x7Fl\xC2}\xED^d\xD5\xC5_\xE5\x11O\x1E\xFE\r\xCBS\x04h\xB1d\x16\x1A\x1D5g\xC0\x85\x12\x8B\x0E+V\x87\n%&\x8Bw\x9B+\xD2Q4\x9CV\xD7D\xA1J\x8F\x86Z3\xFFi\x88\x99\xE60\xB9c\x9E\xE2\x0F\xC2\xF5\x0FYq\x18\xAD1\xB6v\xAE\xC1\xBFa9\xB0\xD6\x95\xFF\xC1i\x15ja\xB9\t\xB4F\xE9M\t\x9F\vM\xB1\x889X\x12\xFA\xC7!x\x9B\x1D\xFC\xD6\r\x9F\xA2\xFA\xA7U\xED\xB7`\x0F\xB7B\xF39\x02Z\xB2O}y\xF9\xF7\xFB\xF1\x94\xFC\x8A\xE6\x83O\xBF\x99\xFD\xDB\x13\x9E\xFE\xFF.\xBF\xA2v?Z\x1E\\\f\xFF\x83_^\xFFt\x89\x9D\xCE\xEC\xFF\xCF\xDA\xF8^\x9E\xFE\xFD;\xE0i\x164u\xF2\x86&hO\xF6H\xD2\xBC\x92\x84\xBD\x8E\xFD<T\x02\xD66\xB0\x8Fn2\vZ\x9B\xE8\xFCG\xCB\xC2\x88\x04\xF1'h]\xFF\xF9\x06\xC7\xB2\xCB,o\xF4B.\x9C\xEB\xCC(B\xAD\r\xF6\x8Dh\x94a\xFCjS\xF5\x85Z\xCF3K\xF7\xF7\f1mC'N\xE7R\xE8\xEC\xE5\xC0!\xAALB\xE5\xC1\x1F\x96\x02\xFA\xA7\xB5\t\xA1\x92|s\x99!\xB5\x15\xCD\xAF|\xA1\xB4d\xFFZ\xDA\x96\xB6\xA5mi\xFB\xFD\xDD\xDA\xFC\xA6\xEC\x9Aue[=s\x96w\x98\xCF\xB4\xDE&\x0Fn\xF3Y\xAB\xDA\x82\x16\xF86\x9F\xF9\xAB\x96%\xFE7\xB9*\x82V\xE2z?\xB5\xD5\\\xD4\xBF\xA7\xAD\xE6\xBAmU\x16\xB6Z\x9B\x7Fp\x7F\x1B|\xFC\xF6\xB2\xFD6\x1F\x1Amu\x9D\x11\x12\xE1\xB6Zg\x844\x00\xBE\xEF\xF8\xD7\x18\xC0\xFF\x7F\xC3\xBFm1\xFC\xFD~\x90\xDF\x06\x7Fy\xBA\xBF\xFD\x8A\xFD\xBB\xE3\xEF\x1F\x88\xB4c\v{x\x8D]]\xFC\x144\xA7{\x87I\x9B\xB9k\x00\x17fp\x04M\xF4>#\xB9wQ{q3~\xDD\xCD\bZ\xE9\xED:?\x05\xBA\xEA\xF3&Tlo,\xDEu\xE7<\x06\x15o @\x9D=\xBE\x8Bz-\xB0\x9Dm\xF2r\x1C\x8D:\xBD\xF2\x8D\xD7sC\xB8?\x85\xA2\x7F\xF0\x9E\xF2\x1F\xBD\xFDw\x97\x7F\xE5w\x93\xFF\xD0\xFF\x8A\xFC\xA3\xAE\xFC\xBB5D Ki\x07\xE4\x1F\xF9*\xF9\x8F\xDE\xFE\x9B\xE4\x9F\x1Bp\\\xD7\x00;]\x90\x84\xB3\x03z\xAC\xC5\xE5\x1F\xA6O\xFE\xB7\xB6\v\x83\x89\x16tw\x9Aj\n\xA4a\xBE\xD5g,\xF2SC\xAFB\xB9\xDA\x9C\xD8X\xF6\xCC/jT\x98\xA7\x14\x93X\xB2\x9E\xC8!\xDF\xEDs\xED\xBD\xCA:\xCF\xFC\xA5\xA0rl\xDE]\x99w\xFC\xF6\xEF\xAA\xB0\xB4\xC97F#U\xF8\xD3\xF5\xEE!\xBE\xDC\x16$\xBAa!\xFF\xAA\x1B\xB8\xFB\xDArN\x90.\x8C\xF0Vy\xFE\x91y\xF8\re\xFE\x02\x04|\x15-\xFA\xCC\xEF\xC2|\x0F\xAF\x04Q\x82\xFB\x13\xB1Xm\x11\x0EZ\xC3|\xAF\x1D\xECmXX\x81\xE6\x8E\x95uWc\xA8\xCC!\xAB\b\xBB\xDC\xE0T\xB9\xC3\x8E~\xC5\xA7\x7F\xFC\xB5c6\x86T\x8D]\xDC\xB3\x006\xAA\x9Eo\x97\xD3a)\xEDh(o\x00\xACD2\x02\x90]\xFF\xEA9\x1Al\x89O\xAB\x05E{W\x92hE\x91\x1E\xAC\x9Bl\xFE\xDE\xE0#%LUJ4`|hp`\x10\x84\xDBy\\\xF4J\x11\xEB8\xC2\xF9\xC7\x06K\xE2\x16[\x1F\xFB\xB5\x9F\x9D\x9E\xDCi\xAE\x98\xD2|\x8D3cf\x95\xFE\xE1\xC8\xF3\xCF\x8A\xB6\x99\x05\x8D\v\xF9W\xD2\\\xFE\xE3\xECk\x9A\x99\xF8\x02u\xFABQ~\f\x94t\x97i\xBEc\xE3\x0F\xB8\xFC+\x03\x14\xFF\x86\x83\xFC\xA7\xA46\xFCn\xB7s)\xF1\xE4\xDF\x9F\x85\xF1\xE1\x1D#|\xAD^[\xA5\x82^\x8BS*7:P\xCDQ\x82\x87V/\\d\xA1g\xC8\xB3Vq\xA3\r\xB3te\xD10/\xBA\xA7F;\x9F\x9Bw\x1F\xF5\x1B~K\xFDOe&\x85Vv\xF7\x9B\xB6\xFD\xDCo|PShv\x10j\xE7\x9C\x06\x82v\x98\x8D}\xC4\xA2\"\xBA\xA1\xC4\x05>Z\xB1\xE1\x12\xEF\xF7\f\xC7\xCBw\xCC\xFB\xEC\xF3A\xFC\xB99\x88#\xCF\x13:\x1AN\x16\t\x9E\xCDW\xCB\xFF\x19\x86\x0Fm\xD6(\xEFD=\xFC\r\xA7\xAB\xD7\xD1\xF91\r\xF3\xD0R0\x0EBQx#\xC9\xD4\xF0J\xB2\x9D\xE2/\x81\x9D\xF6\x01b\xF7o\xE5V#\xAFJ\x8BL5m3eNfk\xF4\xFFa\xEF\r\xA0\xDB\xB8\xCE3\xD1\x0F\xC3\x810\x00)\f\xC4U_\xD44/\x1EB\x90E\xD1\x8E\xE8\xF8\xA5[\xB7O+\x8E`\xC8\x86\x90<Qf\xE9\xD6\xC9\xCB\xB3\x18\xC5M\xBCY\x9F:\xCDi\xDF\xE6\xD5*8\xA6i\x87\xA2\x1DS\xC2\xD2\xB1\x9A\xCD\xB3 \x9A\x8A)\xC8k6\xDD$M\xDD\x1C\x1A\xABh\x1D\xC7\xBBk\xA7^o\xDA\x93\xB3\xAF\x19R\x94E\xD1\x0E!1\xB2EQ\xF4\xF0\x9D\xFB\xDF;3w\x00\xD0Q\xCE\xDA\x9B\x9C\x13\xCE\xD1\x81\xC0\xC1\xCC\x9D;\xFF|\xF3\xDF\xFF~\xFF\x7F\xFF\x1F\x9Ay\x9B\x89C\xAD\xE9S=0$\xF9\x7FW\b\\E\\\x83\xA2\t\xF97%z\xFA\xCDk\xAC_P\xFF(\x1AB\xFDP\xC9\x8F\x13\xED\x0E\x90\xCFM\x19\xE8I\xE8\xAF\x9C\x97\xF5\x8F\x9B\x7Fo\x1Dp\xCE\x85|\xCA\xF4\xE5o<\xBCh\x8Ch\xBE\x7F\xB6J\xFF\xA8\xC3\xFEs\x89\xF2H\xDD\x84F\xF8OK\x8F\xAC\xB7,jSR\x94N\xA6\xB3\x1C\x1C\x7F\xB9\xFAR\xB2\xB9\x1D\x89\xFB\xDCP^\xA8\x84\x7F\x9Dh\xFBXn\x87\xF5\xB5M\xC6(\xE1\xFF\x87\xB5\xBCz\xC7\xFD\xA2ZD\x97Ym\xFF\x84<%\xA9&\xA0;\x86\x85C\xAD#\x1D\x16:\xFA}\xF9\xA7\xB8\xC0\x1B\x17\xE9\x8D[\x10\xFA'\xEC\x1C\xD5\xFD;\xBDZ\xF97,`M\x16*\xF9\x11\x1A\x12\x81\xFA\x05\f\xFFI44\xEF\xE1:[\xEC\x1C\xE0i\x8B\x96ml\xE1\xE3\xDA\xF7\x97\xF6\x1A\xB8\xDD\xBD\x91\x8Eb\xE2\xFA\xCE\xAA\b\x07?\xBB#\xB4\x82/\xFF\x908\xA6\xB7\x88/\x1B\xB8O\xB2\x7FLS\xC8\x9F\xAF\xBC\xD0\xCCZ>\x96\xED\x9F\xBD\x99\xE1\x7F\xB4\xC8\xCF\xCA\xA0a\x83\xC8\x1B\xA6\xA5w(\xD6\xCE\x8D\x06\x93LC\xD6\x1D\x98\xA4\xE0\xA8\x07\x14^\xA9\xE7SReZ\xFE_\xD2r\x97U\xAB\xAD\xC0\x0Fw1\xFD\xF3~\x150^\xF3\xBD\x15\xDB\xBC\x05)\xECu6=\xFD\xD3>\x93\xF1p\xF8\xA9_\xC0\xFEI\t\xF9\x877\x04\xF0\xAFf\x19\xFE\xC3\x05.\x7F\xC3pwBT$\xE1\xC3bLU\x0F\x94}\xAFA\xB2\xD39oz\xBE\xFC\x1FV\xCB\x9F\xBF\v\x1C\xC0!\xFE\x99z\xBF\x81o\x16]\xFC\xD3)\xBDe\xEC\xE3\xDE':\xBD\xD9\f\x02F\xBCPf\xEE\xDF%\xAE\xD8$\xD8X\x0E\xA1\xFDX\xF34_\x8A\x02\xDDy\xA8\xBF\xEF\xC0\xF5F\x94\xD7\x8A\xAD\xC1\xBF\xF1e\x85\x97\x1B\xF0+\xB3\xB8\x01\xED\x19O\xFF\xA8\x194d\x07\rX\xADJ\xCA\xC2\xF2\xFD\xBE\xFCS\xA6$\x7F\xDD\xC9\xBA\xF2o\xC1\x98'\xFF\xA3W/\xFF\xB0\xE2\xEA\x9FTF\xBESUC4\x8Dh\x9A\xDB?f\xD9\xB7\x7FT\x12\xD1_\xD1\x8E\x1BSj\xC2\xF4\xBD\x06-\x96\xD9\xF2\xA4\x1B\x9C\xCF\xB1\x17JV\xDB\x9F|\x14\x10\x8E\xB3\xEFl\xE1\xFA\xC7\xF0O1M\x8C\xD2\x9F\x1Fa\xBA=y\x9B\x15T\x98\xEE\xF0\xFD\x87E\xBB\x99k\x83X\x8E\x8Db\xB1\x1C_\n\x01M9|\xB7\xF3a\xDB\xFE\xB0d\x7F\xCA\x93\x88\x8E\xFB\x9D\xAF\xF6\x04\xC7_7\xA0\xFD\xB0\x01\xE1\x0E\b\xF7\xA1\xE9\x96+4\xF3bby\xD4wu\xFD\v\xCBE\x82r\x13`f\xF9\xA0\xA9:\x1B\xF5\x0F\x9Er\xAF\xD2~\xF5\xF3/m\x01*Y\xCAkN>\"[\x1Aa\x07\xFA#\b\xAD\xE1\xEE\xB6!\xC9\xF8\xE5\xF6\xE7\x10\xED\xFF\xDE\xD9\xA5OY\xBE\xD7`\xA1\xA7\xFC\x99\xEB]b\x9Fc/\xBE]\xF2\xF0r\xF9o\xF0\xF1\x1F\xF9L\x96\x96\xE3\x89\xA0\x02:\xA5\xB7,\x02EN1\x00\x7F\xF0\xA1\x9E \xFE]#\xEA\x87\x9B?\xB0\x0F\x880\x8B\xF1\x0E\xACu\xD8\xA3Y\xF3\x99U\xEEku[\xDDV\xB7\xD5\xED\xD7z\x93\xC97\x99\x19\v\xD5\xC9\xC6\xB3\xAE&\xAEu]\r\x7F\xE5\x91\xBDU'\xD6\xE5\xF7P\x13\xA7\xBD\xCEk\xA4*>\xB6\x96\xC7\xAB\xD7%\xF9\x12\xD5\x8E\x009\xA4v\x85S\xE0\x86\xD1\xCA\xC7{\xD4\xB1\xD7\x93uA\x12\xF2\x1D(\xF4\x95<\x1D\xEB\xAA\xDC\"n\xB3\xAB\xF2\x97\xE5\xBFN\xE6\xFC\xDF#\xF9\xEB>\xF9\xEF\xFB\x02\xEA\x06\xBD\x07\xAB\xEBz|x\x15O\xBE\x1C\xAC\xAEX\xED,\xA8\"\xFC\xF5\xEA8y~b\x9D\xF8\xFCZ?B\xBD.\xC9\x97\xA8r\x04\x04\x96\x00\xA0\xFE)~A[;\xC0\xDB{\x7Fz\x82\x92\xEF\xEB\x1D\\\x18u\xEB\x11\x07\x04\x12J\xB4\xF8 \xC9\xAE\xF3b\x17\xFF\xC7\xF0\x9F\xDBQ\x83\x7F%[\x0F\xFF{ \x975\t'\xD6yuC\xC2\t(\x84@eO\x00\xFFaS\x8E|V\xAF\x1E\xFFJ\x020kh%\xF7\x14\xC3\xEB\xEAA\x1F\xFF\xB4&K\xA5\x1A\x88\x80I\xB0?H\x11<\xE2,b3\x8C\xE4\xCA\xF8\xD7L\xBF{r\xCDMI!\x98\xBD\xB6X\xD5\xAEF\x9C+\xD3\xDE\xD34\xEB6\xE8\x07\xC0\x85\x06\xDEozd\x85\xE9\xCD\xD6\xCF\xD0\xE9\xB9\xCC~\xF9\xACv\xDBg\xB7\x02$9\x9F\xCD{\xAE\x81\x88\xA3\xD2a\xACY5\x0Fe\xFBre\xE2\xD2)S,\xBA\xD7_!\xFE</3$\xBDe\tWny\b>[\xBCT\xF5\"+\x89 \xC3\xEFO\x93\xE5^]\x132\xA0O\xD0%\xCC\x85O/p\xC2\x9FW\x7FNY\xA6Hk\xEF\xA6\x9E\xCEQ\xC2\xB1\x8D+\xE3\x7F\xD8\xF2[\x96\xBB}\xC5\xF6\xC9\xED\xA2!\xD6\xC7\xF5\x96\xB3\x83\xC9\xC4o`E\xFDs\xC5\x96\xA6\xABqm\xD2\xA3\x13]\x86\x1C\x10iUzO\xF6\x07\x9E\x9A\xE1\xE3\xFF~\x03\xD54\x8B\x87\x7Fmdy*\xCBk\xCEB\xCFA\x1F\xC9\r\xF4\xF5w\xE6\x05\x1B\xA9\x8ER\x92\xF3\x1FV\xBDY\x96\xD7`,\xE9s#pS\xA9S(8\x15$\x9D\xA8\xF3R\xBB\xB5\xB9=\x1Ap\x8A\xE9\x96\xBE\x1EJ\x9D\xF1\xCF\xEEO\x14\x8Bh\xE6\xF8\x8F\xC5~p\xAF\xC3\x97Qt\xA55\x1F\xFF\xEA\xC0'\xCD\x15\xE5\x7F\xAB\x05\xCF) \xE3\xBFT\xF4\x85\xD6a\b\xFC\xA7\x1EX\xB82\xD3}W\xD9\xEFv\xD56\xC8sS\b8\xB5\xA5<\xFC\xF3\x83\x95/\x02n\x129-P\xA5\xF1e[\xFCZC8d\x03\xF8\xD7\x17\xD75\xB8E\x81\xA39(\xDBol\x9F\xB8\x98N\x8BR\x0E\r\x1B\xD8\xF3R\xEF\xACR\xA4~B\xF85\xC32\xFEE)\x07\x0F\xF3\xA1t\x1D\xF97\x88,\x10Cn#\xA9\xFB[\xA1O<W$\xCD\xAC;\xDC\xC3\xD2\xC9\xDE\xC7\xE9\x8E\xFB54\x8D\xB0';$\xBDh\xEA\xC0\x7F]\xB9\x98\xE3o\xF6@w[\xEE\x95\x0E\xA3\x02\x91\x84\x96pw\xD6\xC5\xFF\xED\xA65\x98*\x88G\x1B\x9D\xAFm\xED\xF5\":=\xF9\xEBO/z\xF8\xE7)\x8F\b\xE1\x1C\xFF\xCB\xD3\x81\x1A(;\xA4%\xA8;\x8C\x9A\xE1\xCF\xF3\x01\xAB\x85T_V\xA8G&\xFF\xE4\xF7f0pW\x1Fx\xAD\xD2\xB5o\xB1KD\xBE \xEB\xFF~C\xD2\x94JF\xC6\xBF\xA8P@\xAC\x1A{d\xE1\xDF\xAB\xF3R+\xFD\xBE@\xF8\xB9\x9D\x0E4\x8A\x15\x0F\x9D\xFF\xBDt\xD6\xA0\x95\x80i\xEE\x85\xE1\xEBk\x80\xEF\xEE\xD3|\xED\x19\xEE\xEEZ9\x93\xC3\xD9\xB2_M@\x95^\x93\xAF\xF6@\xAC\xAF\xD1\xD2\xCB\xEE\xBB\xA0\xEA\xCE\xC3vb\xD9^q\xFC\x1D4\x10\x92\xCA\x95\x1A=\b\x1CL\x8Dp\xF7M\x02\x0F\xC9'\xEE\x95\xEC\x9F\x97e\xFC\xF3\xA8\xFB\x06W,\x91y\xAE\x7F(sN\x1E\xFA\xC4:}\xE2K/\x8F\xB8\xC3\x8EI\xB9\xFA\x7F$+\xD2\xE7\x8AX4\xEB\xEB\x7F\x81\xFF5w\t\xA7j\xB8\rZ\xDFJ\xFA\xDFC\xE9sG[]\xFD\x8F\xB3g\x97:,\xF64\xF7\x92{\xF7\x8A\xAD\bU\xF9\x80H~r\x9F\r\xACI~re\xFC\xB7H\xEF\xBB\xFC\xDAn\xB2(\x81!\tM3\xC0\x01\x16\x0Fi\x8B-\x8E\xF0\xFFJ\xAB\xD5d\xFC\xB7\xFB=\xD7\xFE\xA4\f\x91\xCC\x8B\x1FL~:N\xB0w\xFC\x87\xC0Hw\xB3\xCF\xB1cG\xE0\xF5\xE7\xE9\xA4\x14\x0F\xFF\xB9[\x97\xF8:kDM6\x1C\xCC$/\xA6\x9B\x11J\xB9\xFE\xF7,\xA2{d\xFC\xA7,\xDC\xE6\xC9\x7F\x8D\xB0\xDDb<S\x90\xC0\xFFw\x98\xC6.\x13\xFE\xB1\xB4\x92\xFE\xF7]\xB7\r\v\x88\x95\xF6\xB0\x01\xC81\x06^\xE1\fv\xC1\x04\xD64\x95\x9EZ\xE2\xAAry2\xE5\xE3?\xBA\xF4\xFB+\xD7\xA2k\xB7%\x07\x93\xD4\xED\x7F\xEC\x01\x9A\x84w\x80\xBDzD\xB4\xFE\xF6\xFD\xE7\xD5T\xE2\x1A\xBC\x13\xFE\xB3\xFE`7\xFCuST\x13\x10\x07\x93\xCA\xE2\x04\xBB\x91\t\x8C\xBF;M\xDF\xBF\x13\xB0\x7F\xD6\xF2U\x0FI\x0F\xFF9\xD3\xAD\xC6\x1EMC\x1BY\xA7\x7F\xED\x81\xC1>\x84\x15q\x15\xDDA(\xDDa\x07\xE4\xEF\x0FIn\x06\xB9\x1BE\x8D!n'\\\xCB\xB3\x18!\xA4\x88\xD7\xAD\x9E\xFE\xF7z\xD5\xB53\x05\x95\\9\xD1\xE6\xE4\xD1\xEC\xB2\xCD\xF0\xCF\xE4\x1F\x8B\xEDJ\x8Dr\xFC'\x1E\x15\x8E\x83\xDD\x06\xA0\x19{V\x8E$\xBF\x8D\x12\x18\ng\x8A$\xFF\x06\xB8\xF8\xE7U\xD7\xF5\xE7\x01\x9C\xFAL\xD3\x86\x99DOyE\xFB\xE7\xAB=\xFE8\x05e\x9Fa\x82\xD7\v\x10\x07kk\xBC\xB0\xFC\xD0@\x00i\x1F7|\xFFN\x00\xFF|\xD5U\xC3\x1B.\xFE\xBF\xC6\xA76*\xCF\xA3\xAB?\xFF)m\xDF\xD7>\xF7\b4\x1A\xA0\xE3q\xA6\x82\xD6\xE4\xCBV\xE0E>\xE2w\xE9z\xFE\xFF\xF7\xF8\x1E!\x96\xB2@\x85\xFE\b\xD6l\xA8\xB9'Q\xD1\xC0+\x16|`K\x12\x8D\xD7_\xC3\xE4\xFF\xD6\xBE\xAFg\f*\xEB\xDFL\xFA\xE7\xAB\xF7\n\x97n\xF4\x01\x91\xEC\xEBg\xCCtwn]\xD9\xFE\x1F\xB2}\x89\xFD3\xA9\xDB\xDB\xD8M.\xAD\xB2_\xAB\xDB\xEA\xB6\xBA\xADn\xBF\x9E\xDB\x8AA\xE0^\x12\x89*\x92\xAD.[[C\x7FA\"\xB4\xE5\xBC:\xEB$\x82\x0Er\xE0n]B8\x18\x15\\{\x89\xDA\xD8\xFB\xAA^\xAD{G\xCA\xDA#\xDB\xD7\xD5\\b\xDD\xCAwT\x15H\x8CzrXW7H\xBEJ\xB0+S\xD3+\xC9\xBF*\xDD\x8D\xCC\x96\xD7\xEFm(\xB1\x8E\x99\x8B+\xC8_\xD1|\x86\xFF\xDD\x95\x7F\x8D\x13\xE1\xE7\xCA\x7F\xDD/\"\xFFu\xA1\xE6wG\xFE\xA1\xC4\x8AA\xF8^\x12\x1B\x89\xE4\xAFJw#\xB3\xE5\xA8\xA5\xEC\xF8a\x93\t\x9F`\xAFH\xDC\xBEL\xE6W\x9C:\x1E\x01o\xE9A\x95\x19\xAC;\xB5\xD4\xBAG\xC2\x07\x12\xEC \x10o_\xEB2\xF0\x9C\x1D\xB5\x1D\xA8u(\xC8\xAE\x8A\xBA.\x92\xC0\xAA\x87J\xBDE\nU\x82\xA5\xC3\xDE\t\xFF\x8Av\x9B2\x06\x181\x0Ffa\x13\xDA(\x7F\x82^>\xD6P\x00\xFF\xCD\xC1\x07\xBDm]\xC3\x82\x8Cg\xD5\xE3\xF6\xBDx\xDA\x90\xA1\x86\xF6\xAC\x84\xFF\xDB\x82\x84\xB7L\xD7\xCB\xCC?}\xB2I\xF1.\xD7\xA7\xB0\x8E\x98(\xD5\xC3\xBF\xAA%\xACj\xFC\xE7v$\xD6Qj\x9Au\xEAhU\xDC\xBE\xB4\xB2^\xA2l8\x07\x153:\xFA\xB4\xDBj:\xD3\"\xAFzh\xCB\xF1\x1B\xE9\xB2\xEA\xE1\x1F\xFD\xEB\xA8&]K(\xF1\xB6\xFB\x80:\xAB\x9ET\x84M\xB4{)\x13\xD4:*\x07L\x01\xC3y\x84\xD7#\xFC\x01D\x96<\x06\xE6Re\x9B\x9F7;\"\xA1%VD\xC3\vWl\xCD\xA3\x1F\x97O/5\xA7\xF7\xFB\xF8\x8F,!\xE6@\x9FX>\xBB\xD4[\xAE\x83\xF0\xDE\x99\xA5\xDE:\xF8\xCF\xCB0\xE6\xDD\xDEk\x03\xE1;{\xCBXr\xC3\xAD+\xA7\x17x\xD9\v\x8A\xDAJA\xCF\xCBE3\xE7iJ\xD5\xFB\xB2\xB3\xF4\xD9\xA5#\x06J\xD2\xED\xF0\x8E\xBDY\x17\xFF\r\xBCj\xF9\x84\xFA\x9Ff\xFEO[\xDA\xC3\x99\xF9\xCAw\xBD\xEFo\xEE\xA4\xBC_\xAA\xE3\xD4\xC1\x7F\x1E\xF1\xA5+\xD3\x0E/[\xEC\x91~\xD5A\xB0*\x9Bh\x8F$\xC7\xA0\x0E\xEC5\xC5\fn\xBARd\xA0\rOC\x1D\xF5\xA6\xD2\xCD\xBB\xD2\x88\xB9\xAE\x169;Dl\x02J\xCA\x18r<\xDA?w\x8B\xB1'i\xFA\xEF\x9A\xEE \xDC\nm\xC4\xE8\xCB\xE6\x02\xC1\x84\x82C\xC8\xA9\xFD%\xAB\x16\xFFR\xD2~C\x9067\x9A@\xF4\xE2\x7F\xEBa{h+\xB6\xD0ES\x16\xD5\xB9\xD7'\x10M\x15\xA4K\xEC\xE6\x15\x9Fc\xA9\x8F\xF6eo3q\xC2\xEE\v(\nE\xF3bt\x19\xDE\xBC-N\xF8\xD7\xCA\x1D\x8F\x0E\x8Aj\x98q)\xD2\xF8\x98\x7F\xE4\xE3\xAFSf]\xA5\xBB\x1E/\xD4\f\xF4\x0F&KL\xE6\xD7}b\x97{\xA1#\xB5\xF8\xD7\x9D\x91\xEB\xE7\x10q\x06\r\x0F\xFF\x13X\xFB\x16\"w \xF2\xA7\x1E\x03\x93\xCAmC\x93[\x1D#<\x1Bx[#\v\f\xFF\x1E\x9E\xFF\xD3\xD2\x10\xD1\xE6\x1D\xFC\xA2\x8D\x9F \xFC\xBFz\xDF\xF7\x16\x02\xF2\xF7\x8E\xB7\x97\x98X\x1A\x17\x83\xC0\xF0!\xB7\xDE\xC2 \xB1OG\xCA\x80\xA2fL\x88\xF8\xEA\xC8\x12W\xB0L\x8C\x8D\x8B\x88\xDD\x05=5/]\xE2\v\x16{5\x96\xDFp\x9C\x86\x85#\x06\xBEp\xEB\xD2\xED\xC1\x0E<\xE6\xC9-|Q\xBA#\x8E\xFF'\xD4\x86Y\x91\xF2K\xF1;\xF3'm\xFE\x91\xF3\x0F\xD2\xF7\xA8\x93\xAFM\xD5\xA5\xAFg\xF8\x9F\x99c\xF8\x9F\xBA\xE1m\xF7\xBA\x19\xAB\xC6\xCD\x18m\xEE5\x00u\xE0\x8A\x8D>\xBE\xC4\xE0KYAu\xAA\xFD^\x077\x974\t\xFFR\x99\x06\xFD\x14\x14\xAD\xF4\xD4\x04B\x02\xC0F\x9F\xC1\xD1[\xE6'\x87\xB2PJP>`\xF4},\x00\xBF\x98\xD0\xBE]c\xFDm\x96_+\xDFm6-{\x1E;\xBD\xD8\xF8\xF0\xC5\xDE\xB2\x8B\x7FEK\xF5g\\\x12\xAF\x19\xCAvh\xCE\x90t\x89.\v{\x80\\\xDB\xD8\xC6\xA9\xEC:\xA0d\x0E\xEC\x96\xE5\xAF\x15:\xCA\xF5\xF4?\xD5vG\f\xCBsm\xBF'RN\xF9}{\xE6\xB3[\xBD\xEFG\xCE\xD18\xA8vw\xD5I\x95\x96\x07\xCC#)6X\x946.\x85\\9\xFE\x96]\xC3\x8A\xEB\xCE\xAEv\x07\xDA\xC2\xB5\x16.S/\x96\xCF\xE5i\xF8V\x99\xFEw\x8F\xFF\xAB-y\xBF\x04jXJr\x15\x1BF\xC3\xD27F\x92^\xBE\xF4\x8E\x07\x96\xB6|\xF4\x19?\x947\xB2\x845%4\x8C,\x9F\xBD\x1801\x1B\x84\"\xED>\xC6\xED\x9F`\xE2\x9A\xB0\x0F9/\x04\xFA\x1A\x1Bhb*\xF1mW\xFF\xFF\xEF\xE4\x9F\xBD\xCD$JV\x1F\x85\xAE\x9D\x97\x006A\x19\xFEO\xBC8\xB1\xD8\xC9.\xF1v\xA7\x13\x18\x80B\x9Aa\xD6\xD3\xFFT\xDB\x1D\xFAR\xEE\xE1\xE9\xFFd\x07\xDC\r\x00~\xBB\xCF\x7FRo\x8Ae\x05\x85\xE5Z\xBF\xA4\x9ED\xDC\xF9\xA6A\xFA\xFF5\xF3\xEDz\xAE\x19\xFA;\x05E\xEBm\xCBA\xC3?\xF6\xF0<\xF6\xF8p\x94\x02\xAA\xC3y\x84R^z\x97c\xBB\f\t\xFF\xF2\xFA\xA9a(\xEA\xE7^v\x10\xCFy\xEC\xEB\xB1\xB6V!\x16~k\xB1\x97\x10\xCB\xC7`t\xC8\xB7\xDF$\x82\xF0\xF7[]\xDC=\x14\xE8\xD8\x9A\x00\xFE\x85k\xC3\x04\xD4\xB1\x0E\v!W\xFEweXO\xF6\x9A\x94\xA8\\\xD9\x8Eh\xFEq\t`\xCD\x16,\x03mMc7R\x99\xE9]7\xABjP\xF7J\xFD\x91|\xCD\x91$\x1F\x19{_\xEC\xFF]\x91W\xCA\xCF\xB43-\xD9\x9F\xFF\xA6\xF8C\xFEt2\xB5\xF2\x8F:h\x1C9\x92\xBC\x81\r[\xD7-<X\xF6\xDD\xC4A\xAF\xC4\x06\x84\xCE\xEFJf\xA1\x8C6P9`\x00\x1F\f\xADg\x83c8\x85p\xECvO\xFE\xBB\xD3h\xBA\xC9m\\\xD2\xFF\xB1\xC3\b;\xA3#\x9A7\xFE.\x9FI\x1D\xA5\x82\v{\x85[D\x83\xD2\x87X\xF2\xC6M1#\xB0lA \xFCh\xA6\xC0\x14K\x15\xFE\xD5\xFD2\xFEs\xF4\x82g\x99\xFE\xD9`Xn\x96\xFBh\xEA)\xD2?\xA6I\xCBX\xC2)D\xB5\x83\xD2\r&-<f\xA0y\x8B\xF6\xB9\x9D\xA9\x8FX\xF8\x93/\xABAC\xDD\x94\x16;\xC8\x16\xC5\b\x97\x7F\xEE\xD6\xD9\x17E\x02\xFCg}\xFC\xDF\xEF\x1B\x06\xFF\xEF\xCD|5Y\xE1\xA6Z\xFD\x13M\"V\x18N1\x8D\xF1\xAF\xA6\xCC\xB7\xDD\xDD\x87\xAB<\x98\xD1\xCF \x1E\xEF=y\x07\xD4\xC26`\x94\x1E\xD3\xA7\x9E\xDF\x07\xED$\xA2M\xD0\x16\x1Fs\x8F\xBF|w\x1E\xDA\x8F\\\xCD)\xD9\xFF\xB1\xD7\x10+\x19\xF7o\xF0|\xEB\xAAV\xF8@eBZ\x1Fq\x11M\xCC\xFE\xFC\xDE\xCCBH~\xFAM\xE2F\xBE\xBE\xE5\xFA\x03F\x8D\xFE_\xDB'\xE3\x9F\x9B\r\xFDe \xFC\x99\x0E\v\xA3\xBCW\xD1\xC5\x9B\xEEu\x84\xA2c\xF6\xE7D\x95\xFEy\xD9\xC6\xA6\x1E\x9C>\x97\x1F\xCD\x16N\xF5\xE0\xD1O-U\x19\x00\xBE\xFC]\x9F\x85\xA4\x7F\x9C\xE5\xE9\x1B?\"\xF4\x8F\xEFc=\xF5Y\x7F\xFC\xFD\xF7\xD7\xD3Y\x9A\xF3\xFDZ\xFBG\xDF\x8E\xF8[G\xEE.\xB0\x1B\xDC\xB8\xCA\xFF\xAFn\xAB\xDB\xEA\xB6\xBA\xFD\xBA\xBB\x00\xD6\x05\xC3\xAA\x03\x04~m\xE0t-\xA1Z\xB7\xE9P\xDDz\xBE\xA6[\x98\x15*\x16<&-b!bI\xC7+5\xD3\x9F\xC0O+T\n\xB6n\x80u\xF5\xB7n\xFAY\x12\xDF\xF9,K\xBEb\x7F\xCD\xCF\x1AD)\xE1\xFA\x11\xCB*\x8C\x9A\xD6\xFC/\xFF\xD3\xE5\xBF?RF\x84g\x07t\xE3\x18\"\xE5\xFD\xEC\xA1\xE8\x1F\x94\xAC\xD0\x89\x80\xFC\xA5\xF5\xDAl\xD6\xAF\xD4\x97\xBF\xD1\x97\xF0c<\x94?\xAF\x1B\xC2\x01e\x9B\xB06\xB5\xB4\xC1\x97\x92*M\xDEY\xC9z\x91<\x86\x85\x8DS\t(\x1F\xA0\xE8\xDF\xEC\xE6\xAA\x95\x9B\x8A\xB0\xB1\x8D}\xA2W-\"\x80\x84\x99\xCA\xEB\x94\xBC\xAA\x18\xC1N\xEEgM\x01[\x8B\xA8\n\xD7\x0F\x04\xEDK\x81\xEE\xD5\x81\xEB\xB5\x84v\xDD\x00\xE0\xBA\xB7/\xE3?\xE2\xD5G6{m\xF4\x9EK\xD4\xF0l\xA6D6K?\xAD,\xFF\xCD~,Jl\x85\xD7GM\xB9\x13\xC0d\x9ALJ\xE5\x86\x9F+\xFFd\xD2\xA1 \xA54\x94\x84\x97I\xB9\xD5p\xEDR\x92\xFF\xC6>'\xD0\b\x05C\xF6\x9E\xD4\x96\xA7\xF2rk)6'b\xB7\x93\"\xF9\xB7\xF1%\xD4\x14\x98$\x93\xD8<\xE4lWf8\x90| X\xEF\xDB\xF5\x14dRu\x03\x80\xD5z9\x87#N//p\f\xF4N\vc\xBE\xF7\xAC\x931\x90\xD9\"\xF5S\x7F\x01\x81\xFC\xBD\x12\x0F\xA6\x0F\xAC\xF0d\x19Z\xBC\x1A\x7F\xD0\x07\xEBD\x9B\xB3\xFD\xA3\xEE*i\xEBr'M\xA9\xF4\xE2\x95wL\x06\xB5lc\xB1\xBD\x0Fz\x19\xCA\x17\xA1;^\xA3\vF\xA0?\vC\xA2]q\x80r\x17\xC3\xBF~0\xAA\x07\xE4\xB0\xF8\xF2AN%]\xB4\xDC\xC9#\xD0[\xF9\x0E\x80\xCE\xD7\xA5\xF2\x16q&\x8D\xFB\xCEN\xF0\x8A\xC9>\xD1]\x8D\xFF\tD\xF7\xDFZ7\x00\xAC\xEE\xED\xAB\n\x135\xF5<\xBBY\xE8\xFFl*\xBD\xB7\x8C\xBD/KS\xADX\x1E\x81\x84$\x92\xD6\x8D\r V\xBF\x06\xC0h\xAE0\xE6\xC9\x9FMN\x0F\xD69(6\"r\x07\x850\x96\xE3\x95R\x8B%\xB7\xBDR=\xFC\x8FY81;\x82\xD8\x04\x1A\xCA\xD0\xD2O\xB9\x128Q\xF4\xFA3\xC0\x0E\x1B\x14r\x16\x04\x8A\xC2&\xB9\xCB\xB3#\xBBrc\x81\xD6\x06\x1D\xAF\xAE\xB4\x97m&\xD3\xC6Z8\xD7&\xD7yd\xD20\xFB\xB5\xAAJ\xE2\x07\xABz\xA8\x8D@\xCD\\\xAC\x8B\xFFp\xBD\x9C\xE7\xAA\xB9\xD7\xC2^\x92R\xE7)\x81\xFF\xBD\xA7\xBE\xD8e\"cIK6\x1A\x0F\x06\xE4\x1F\xB9x\x95\xF2?aKtA([O\xFE'/\xB8\xDE\xC3\xA7y\xED\xC8\xD8\xC4\xCF\x95\x7F\xA9\xAD\x88\x98\x85\xA6\xEDh\\<\xE6\xEE\xF7\x8BT\x92\xFC\xC7gE\xE6)\xD1\x87\x06\xD6\xF9\xF5\x83\x13\x87\xDA\x02o\xEB\x89\xD9\x02\xA72x}\xCC\x11\xBA\xE2\xDE\x97\xD91m\xE3\x13U\xDA\xFB>b\f\x16\xACw\xC4\x7F\xC8\xA9\x9FC \x96\xAF'\xFF[<\xFC\xA7U\xD1\xB1l\xF8\xD4\xDE2\xBA\x87$\xB2\x8B\xD7\x82\xF4\xE4\xAF\x0E_\x8D\xFC\x8F\x05\xF0?\xE2\x97\xAA\f\xF4\xAA\xE0%\x87/\t\xF9\x8F^\x85\xFC\xBFNA\xBD&\x94l\x8D\xFC\x078\x9E\xC7\x06\xAD\x00\xFE\x89\xBBH\xE5\x06:\x06\x03\xAFa\xA9\xCD\x11\xF2\xA7\xD3\xFF\x8E>\xBB\x06\xD9\x13\xEC\x9CJV\xE1?\xDB?\xE0?P\xDA\x06Q\x8B\xFF\\\xAE\xAE<\xD4\x17\xEA\xED\xFC\xE2\xAD\xBC\xC0+\xD0{\xC6\xF5~\x9E\xDA\xDFeb\xEF\xB4D\xB5\xE9\xFF\x14\xD0`\xB2\xFC\x99\xBE\xAD/\xFF\xB7;K\x92\xFE\x7F\xD6\xA3^\x83\x809\xE8%PZ\xB8\xF7Y>\"x\xA0\xBAR\x0FHWl\\\xA9|\x87!\xADa\x01J\xD6s\xDA.\x16\xBD\xFE\f\x90\xFE?%\xC6\x05a\xC2Q\xA4\xF4\xF8@j\xE8\xEB\x81\xD6*\x05\xD6\x14\xE0\x14}\xC3\xA2k\xE80\x80\xF3\xB1\x89*\x1E\x92\xDB?\xEF\x88\x7F\x07Za\x05\xFB\xA7\x1E\xFE#\xE5]nHp\xF6\xC1\xFF\xCE\xF7\xFD\xD1\xA6\xEE^\x1Bf\xBBD_\x8B\x95Df\x1D\xFD\xC3\xEC\x9F\xFA\x01\xDF-\xE9\xE7\x03\xF6\x8FRO\xFF(\x89\x8C\x9B@\xAC\xE5\xE4\xB5\xDCU\x97,\xBE\x93\xFD\x934\x90L\x1AP\x9A\xA9\x8C\xC2\x82w\xCCuE\xCF\xFE\xD9\xC0\xEC\x9F)QNW,\x07\xE3>\xD0\xBE\xED\xA9\xBE\x9B\x02\xAD%\x1Dn\xDDq\xA3\x85\x8B\xEE9\xFBzf\xD0\xBE&\xE1\x9FR\x83\xAC%\x02<\xF2\x0E\xF8\x8Fv!\xB2T\xDF\xFE\xA9{\xFB\xAAy\xC0uw\x0E<\xFC\x07|\xDFc;\xFF{\xBF\x81\xE7\xCE\xAD\xAFv6\xF9\xCE_i\xDD\x842\x00\xA5>\xFE[\xFB\xFAZ}\xFB\x7F\x10\r\x8B\xF5z5\xE2\xE1\x7Fk\x9A\xDAQF\xDB\xDC\xF6\xDA\xEA\xC9\xBF\xCD@[r\x04J\x81 \x9D\xF6\xE4\xEF\xDA\x9F\x03P\x9Ef\x87%\x0F\x07\x1A!\xFCw\xF4\rt\x8C\x04z{\xDDT\x01\xCAaO\xFE|\xB5\x1D/p_:*\xE1\x9F\xEAY\x7F\xE4\x81,W\x80\xBE\xF9T\xD5\xC3\xE8<\xD4\xD1'\xEB\xCE\x1F\x1B\xEB\xC9_K\x1F0\x84]\xF2%M\x98M\x0Fj{\x06\f\f\xDC/\xC9?\xC6'\xC0\xDE\x1BQ\xB8\x1A\xF9o\xA9\x92?\xD2u\xE5\xAF\x8A[H\xB7\xA6G~\x11\xF9\x7F\x85\x1AL\xA7\xEA\xC8\xFFE\x92\xFFh\xB0\x11vu59\xA0&G\x02\xAD%\vP\x98l7\xD1E\xF9r\xA1\xDEY\xA6\xC1\x9E\x9B\xDB'\xE9\x9F6\x00\xA7\xEE\xB9\xA5\xAA\x92\xF5\xC3U\xAA&\xB6\x9B\x19\x12=W=\xFEj\xF9\x1Bl\xF2\x18\x027\x9D\x16\xF9v:^wn(\xE3\x86\xCFH)q\xF4\xFF\x1C\x98\xC1\xE9\xF3\xC1\x19_\xFDj\x02\xCE\xBD\x0FI\xFA\x7F\xBE\xFE4A\x9F\xF0\xA2\xA7\x16:'\xF8\x97\x9F\xAB\xFF\x97+\x13\xD0\x0F\xF2\xC9\xE6R98Y`;\x07H\xB1\x9F\f4\xE2/i\x9F\b\xD8\xFF\xF7~\x05\xFAK\xAC\xB7\xC6*\xFB\xB5\xBA\xADn\xAB\xDB\xEA\xB6\xBA\xAD\xB8\xA9\xC4\xB8\xABW{x\xC2\xA5\xC4k\xF9\xF0d\r{\xE71\xE7\xF2v\xB0\x0E\xDF/\xF5\xA4\xB6{5m\xFE|\x7F\x87\xDB\xB4\xE1\x7F\x06z\x9Bp)\"\xF0\xE0L%\x98N$\x04(\xE6\xD5\x8B0!\xF5\x93\xB7\x93\xF2F\xF0\x8Dg\x1D>e\xD88\x95o)\x82S\xD3\x88;[\xBD\bCZ\xD2\x1B\xB8M\x85b\xBD\x94j\xEBbsY\x90Nn-\xA7\xA0\xFC\x95a(\x85\x96\"\x1D\xC6\xFE\\@\x84\x98d\xAF\x1D\xC5a\xB3'J\xB0\xD0nc\xB9,\x8E\xF4\x9E\xD9&\x1Bm\xA6{:\xD5\xAA\xE3;\x83\xE6\xCD\v+\x8A\x81.t\xBB\xB1\x82\xFC\x95now\xFBT\x82\xE7<lq\xE5\x9F\xE4\xF2w\x03\x0E7\x99H\xD6\x93\x7F-\x0F\xC3\xC4\xA8\xF8\xF2o\x9F\xEAFd\x02J+\x17\xD7!\x03\xD7\xA7\xC4\x14\xAF-i^k\xB8Kq\x95\x84\xD7\xFEf\xCA\xB8\x18\x8CP\xA5\x89^MU86\xA1\xE0;y?\xAB\x1E\x90\x92\x85\x92\xB9\xD6\xF0\x92\x82f\xA0\r\xD0\xE4\xD1;\x80*y*O\xF0\xD5\xD0\xAA)\x8E\xF4\xA6\xB4\x9B\fv\x83\xFE\\\x8F$\xD6^e\xC5Q\xDA\xDB\x15\xE4\xDF\xC7\xEB\xDB\x06\xC8+\xEFS\xEA\xED\x96\xA4\xC3\xF3O\xF2K_)\xA3\x9D{F\xDCBl\xEDv\xFD\xB4\x99[j\x1E\n\x9BY(\x8E\x17\xF5\xD76\xE2PH$\xDB\xD3J\x99\r\x16ou\xB8\xC9\xBA\xD8>\xBCX\x04t^\xBD\xF5NoQ\xFFb\x91\xE1\xBF?\x90\xB4aA\x10,U<y\xD9[\xA4@B\xD0\xFBj<5K\x8BE,\v\xF7P\x1F{L\xFA\x88\xBC|\xE3\nk\xE1<\x80\xCB\x06\x96Mq\xE4\x92{\xE9e\x03\x8B&\xDE\xF6\xF0ON\xB1\xCBU\xF2\x8FL\xAC(\x7F\xBAP[ Ej\xC6\xFF\x94z\xBB\\)\xF0\x1A\xA9\xBC\xF1\xDBL\xCC\xF3\x84'\xFA\xB0\xC7\xFC/\xD6\xC3\xFF\x9BV\x1D\xDF\x01\xF4\x84\x17-\xE9\x8C\x97\xD8\xE3&\xF9,\xDB0\x81\x13\xFF1\xC5y\xBF\x13\xB3\x85R\x91\xE2\xC6\x99\xFE\xD9\xF3\xB4\xE9\xB3|\xF7\x95\xA55\xFElb5\xC6\x89\xC4j\xFA\xD7\x84H\xAB\xCB\x1B\x89\x05k\x8E\xC7r\x88\r\x97z\xE80N\xDB\xEA/\xB2#c}\x1E3Yb-<\x03`\xBC\x07\x9A!\x8E\xF4\xF8\xF6c6N\x94q\xCC\xEB\t\xC5\x9D\x8EW\xCB\xA1mE\xF9\xC7\xD2r\xD4(\xC9\xF3U\xFF3\xE6\xE3\xFFx\x9B\xC3\xD3\xFC\x968Ecb\x9C\x16\x14x\xC7\x8C\xDB8^\xEF\n\xE35/\xC5\xBF3\xC5Y\x1C\xFF\xA5R\x89I\x8F\xE4s\xDCD\xAF\x8D\xA7\x8Fo\xE0\f\xE7X\xCC\x1A/\x8A\xB4\xF9P\x9C\xE3\xB6/\xFF\x18\xDC\"\xBF\xE2F\x9EA0\xFA\x8EoO\x95\xDD\x1E\xF2F\x88\xC1\bL\x87cK\xE3\x06\x1D\xC6s4h9\xC4F\xFC\x1B\x8F9'X\v}\x9C\xC2M\x14\x85\xE4G\xBDXG\x83\xED\xF7\xEF\x91N<^\x059}ve\xF9\xE7\xAB=\\a\xCD\x1F\xADb>\xFB7>[@\xD3k\xACqn7\x941\x96\xE4\xC7\x1C\xF4\x906^O\xFF\x1C\xABy)\xC6\xCB\xA2eNz<3\xFB\x1D\n|e\xF2y\xA6\x07\x03\x06N\x9C\xBB\x85\xE3\x7F|\x96\xDC\x10\\ta<\xE365^d}\x0E\x84\xC8\xC6f\xEB\xE3\x9F\xB8t\x1F'\xD5\xF2'\xFC\x171\xEA5\xC2\xF0?\"\x92e\x90\x04\xD8{\x15\x9Bb7N\x83\x0E?\xD2\xC3\xFF\xB8\xC1\xEEz\xCC\xCF\xF6P\xE0(\n^\xA5\xF4\xCE\xF8\x0F(\xD2\xB5\xDD>\xCB-\xC9\xFFxNP\x94\x02\xFFE\x8Cs\xFD\x1F\xFB\xA6\x87\xB4R=\xFDs\xBC\x86Rx\xDB\x14z\x80?\xF7\x12C\x9D\xEB/\xB0\xF0\x9C\x81\x05\xAAAp\xC5\xC6\xC2x\xFF\xA2\x97\x94\xA9\xD1\x91\xF5\x7F\xCA\xC2]2\xCC\xB8\xE6\xAF\xD5\xFF~E\x9E\x92\xFF\xE9\x9F\xF5\"\xF4\xE1E\xC3\xA3MJT\x93Q^\xBEG\v.\xC8[\xEA\x18\xEC\xBD\xE3GzN\x94\xCB6.\x00W\x8A\x01}\xBE\\u\xCB1\xE7\x9D\xF5\x7Fp\xA9\xD1\xA2\x00F0\xC4bq\xBC \x1A\xA7k\xA5\x8AXh\xB9\x03<\x01\x1A\xEF\x894*UK\xA0\xD6&\xD43\x9E\xB3f\xB9B\x19$\xF4,?x\x8B\x81\x8D\x94o\xC7\xB0\xB0yJ\xBB\xB6\xE8\x99\x8EY\xCF\xFEI\x92\xFCS\x81a\x8Bt\xACR\x8D\xB4d\xD1]\xA4&\x0E\xF8\xE3\xA0\xF9\x91\x87\xB2tm\x8F[\x14@\xB9\xC8lEE\xF3\xDBQ2[\x98\x01\xC6tck\x91A\x82\xD3\xF2\x9E\xFD\xB3\x85\xEC\x1F\x8F\xAB\xE4\xB6\xD6\x96*94\xB5\xAEl\xFF$\xAA\x92\x80y\xF5A\xAA\xAC\xE5\xCDS\x0E\x7F\x8F\xB8\xFD\x99\xB2\xD0~Z\xB2\xAB\xC9\xFE\xA9k\x7Fn\xA9y(-\xAEe\xC5\xE5\xDF\xA2\x14\xC8\x0E$\xFB\x07\xE80\xD0J\xF8\xDFb\xA1\xB5\xCF\xB9\xAE\xE8J\xB5a\xE1:\xF7\xAE7\x16\x19f:d\xC6\x97\x1FS#\xFF\x14;\xFDi\xFA\x89[tc\xC1\xDB\x1F\x802|]\xD1\xED\xA4\xF2MDc\xECH\xDF\xFE\xDF\xCF\x8C:e\x94\xC7\xC6\x18\x96\x1B\xA1a\xFAw\xB7\x11\xB2\xFC\xD9\x89\xD7U\xDDrc\xE9\x9D\xED\xFF\x00\xFEyl\xB6\xA8R\xB1_\xF2#d\xA0o\xF3\xEC\xF9\x0E\v-k\x89\x80uyo\x8E\x84\xAB\xB1\xFF\xE9\x8E\x18$~F\n|\xF3I\xC2\xBF\x92\xE3\xB8\x8A\xB2v\xD2\xDCL\xDD\x92\x1Ehc\xF0{\x91s\xD7[%\xA9\xAA\x06\xD4\xC0\xB4\xE5\xAF\xE9\xF3\xD9:O_\xE1\x8C\xFAH\x9D\x07\xA48P\nm\x86k\xB1+\xB3\xD0\x06\xE9\xA1T\xE1\x9F\xBDA\xADe\xF6\n\xF0'\xB5\xC5\x95X\xBB\xC1&>\xD7\xF9\xF2g\xA3\xE1\x87\xAAB/\xA2+\xDB?\xD4r\xE0F\x84\x83 ]\x85\xFF\xB6\x91/\x92\xFB@\x14\xCEP\r$Mn\xA9\x8Ezwz\x95\xF8\xBF\xEC\xBE_\xAD\x1E\xFE\x91\x862\xCD\x8B\x83\xE4\xCBX\xA05qK6\x9C\xF6\xC3\x8B=\x80~\x98\xAB\xCA\xCB\xEE\xA3\\\xB0\x839N\xD9\xAFS\xF4\xF9P\xD5\xB5\x16\xCB\xDE\x8C\x86<\x9E\xC4r\x07\xFD\xB6\x85ECT6g\xFA_\xE7\xFA\xBF\xE4q\xFE\xA4\xFF\xFF3\x1B\x8F\f\x9A\x92\xD0\x91\x8E\xEB\\X\xECa\x06\xF9\x82\xE7k /\xC0\xE5j\x7F\\~e\xFD\x7F\xF2\x9D\xB2\xBFJ\xCE\x82\xC5\xF1\x87\xF8\x8D\\v\xB5\xFAR\xBB#\x0Fy\x97{\xB0d^\x95\xFE\x8F\xB2\xB3\x1E\xF5\x9C\x02\xEE\x1A\xF6O\xFC\x02\x85\xE7V\xB7\xD5mu[\xDDV\xB7_\x8B-A\xCC\xB6`\x11Uk%\xBE\xBDj\xF81\x83\xDF\xCDZ\xEA\xBE\xA6\x1DS:\xD1\xACmY\r^4\xB2\xC2u\xBD\xD4\xAD\x86\xF80\xAB\x88z\x8F\xCCW\xDD=j\x1Df^\xABW\t\x94\xA7\x16I\xD482\x02=t\x9B\xD5\xAA\x0F\xAB\x16\x9D\xA9\xC8\xA7\x87\xAA\rc\xF7\xFB\xF9d\xDAq-|\xA7z\xDA\x15Z\xE8=\x99Gml\xAD\xFB\xE7\x15\x9Eg\xDB]\xB6\xAF\x92\x95\xBB\xD9\xF6\x9D\"\x9BO\x8A \xFF\xD4\x14\x05\xFF(\xBB\xA1\xBCE\x9Fs)f*\xCFu\xF4Hw\xA7\xAC\xF1\xBE\xEF\x10\xC9\x07\\\xF1\xAA\xF1\xB8\xB2\r0\xBDl\x8A-6\x91\xE7\xEEJ\xE6[\xC9\xBA\xD8\xA1\xDE$\x8A\x84\xBA\x82\xDA!\xCB\x9F~\xCA\x00\x1D\xA7rt\xF0-`mJ\xBF\x86\xD6\xBF\x9DJ\xEC<\xB7\x82\xFC\xB9A\x9Ba\xD2\xDB\xD1:\x00\xB5\x1B\xAA/\xC9\x1D\xC1s\xF6NecT:\xAD\xD3f\xA7\xDF\xFA\x83\xE6[\xED\xE0|J|\x7F\xA2\xFDt\x9B+\xFFD`B\xA1tCI\xACS\xB2up\xE8\x06j\xDEf\x92\xB9\xEB\xE6\x10\xD0(\xDB\xF0\x0E\xC3/_e\xBAo\xD4^\x95\x82\xE0\xC2\xE7\x99\xC4\xE8s/\xFB\xD3\xB8]N\xC8\xAF\xDC\xE4}'\xF9\xA7}+Q=\xFF\xE1\xBE4\"K^\xE6\x96\xB7\r^\x89R\xD8\x9F<\xC4t\x87\x9A\xF1,~n\xEF\xED4%\xC3\x8F\xC4u\xAB\x8DT\x86\xC9\xBFs\xFA\x8BP\xA4\x90!5\x8F\xC8+-\xA9\x0Fd\xC3\xF9Z\x1E\x8358\x95\xA6L\xCB\xCD\xEC\xDC\n\x9B\xDD@\xF59\xB1[\x83\xE6\xE5\x0E\xDD\xB9B\x81(\xBB\xC8\x94\xCDt\xBE\x92\xF139KD\xB1>\x7F9\x9E\x83\xDE\xCD/\xB4\x18\xA0}J^\xEE\xA0\xEA\xD0\x1A\x19\xFF\xBA#\xAA\xA4\x11\xE9\xFA\xB6\xC1\x8Cvo\x81\xAD\xE5\x96\xE8\xEB\x8BR\xCA\\\xCDD\xF4<\xB4=\x88\x9E?@\x7F\x1E\x91\xDFn\xDD\xBF|\xC5\xE6\xC9\x1F\xBC\x151\x89\x9F\xDCk\x01\xE6\x05\xC3\xF7\xCE\xA0\xC9\xF0h\xFC\x8B\xB4\xBFR\xE9\xF3\xC2 \xB9\xE7\xF1\x9C!\xB9 \xE3\x05\x1E\x87\xBF<\xC7\xF4\xED\xFC\xEE\x01\xF9\x8A\xD0\x99\xFE\xF9\x17\xED\x89\xF3U\vy\xDC\xB8\xBE\xE6N\x88|\xD1\xC0\x05\f@\xBB\xC1O\xC5\x03\xBC\x19\x9C\x8BUf\x14\x8E\xFF\n\x11>\x97~\xD0\xEC\xA7\xC4\x89I\x9CI\xAC0\xFE\xFA[\"\xFC2Vx*\x90\x19c\x02J\xF7\x87s\xF4h\xA2U\x9E\xD8\xB4\x8F\xFF\xA8\xE2\xE1?g\xE2\x84\x81\xE3\x06rf\xAD\xFE\xDFM\xFF\xEF\x06\x0E\"\xE4 tg\x07\xD3\x8A\xCEo\xB8z\x93^\x19\xF1\xBD\x83gq\x0F\xA5\xA5d\xE6\t\x84\xD8\xF4\xCD\xAB\x9B\xB0\xD3\xE0\x1A\xE3\xCF\xF9\x9F\xBC\x16\xEA\x96\x96&v\x96\xDB\b'd\xFC\xF4J4\x83\xDE`!\x93fr[\x9F\x1C\b\xA8eJ\xB7\xFBG-\t#\x1C\x94\xBF\xBB\xA2|r\xC7\x06\xCA\x97\xCE\xF0\x7FMe\x00\xEA\xA3\xB2O\xF0}A\xFCo\xB9n\xF1\xBE\xEF\x7F\x97}\xD9\xC8N_\xDF\xF9\xCAz?T[\xC2\x7F\xECb)7\xEA\x12\xC8\xDF~\xDA\nR\xBBMc?i\xDB_G\xFF\xBB\xAF\xC3s\\\xFF\xC7\xE7<\xF9\x1F'\xF9{\xAF|\xFB\x94\b]k\x9D\xE2\x95\x17\xE6\xA1<A\xA1\x95\xF3Q\x1Bh\xE8\xEA\x98L\xFA\xF8\x0F\t\xFDox\xF2\xF7\"\xD2C\x89\xDE\xFF\x00(\x9A'\xFF\xBF\xB4\x01u7B\"\xE6y=\xE7.Z>\xEF\xC9\x9F\xE7\xF5m\x97\xE7\xF2\x94\x81<a\xA1\xF74\xC3\x7F\xFB\xE9\x01\xF6L}\xF9;\bi\xC3-\xCE\xA6s\xF9\xBA\xF87\xEEg\xFA\xBF\x89\xB2~mIN \xF4yY\xFE\xBF\x11\xC4\xFF\x96\xA4\xC6\xF1\xDFN\xF8\x7F\xDF\x0Fn\xF1\x1F\x90\xCC\x99\xC7\xFA\xC7_w\x04\xB7\x1F\xB3\x82\xF8\xFF6B\xA9u<\xDB\x89\xA2\xD6e\xDD\r\x8B~rW\x1E1\xF9\x171n\xFB\xAF\xBC\xD9/\x04\xB8'EbQ\xD3\b\xCFC\x9DG\xB8k/S\xE0\xF3\xB9d\xAA\xAE\xFE\xA7$\xD5y_\xFE\x8A\xC3\xDE9E\xF3F(\x95\x8FJ\x8A\x90?gYw%\xE1\xA9\xF4bQ\f\x8BM\xFE\xAA\xB2~vd\x19*\x85\xD9\x9B\xAA\x13\b\xB0P\x12\xD0g\xB5}b\x89P\xAD\xB2\xE5\xFA\xFF\xB7i\xD9W\xE7\xB4\x05\xC5\x90\xC7\xDFMA\xF9\xFF\x1FO.4\x13\xA7\xB1\x83\xB0\x9A\nILl@\xFF_\xBC\x1C\x1F\xF5(\x91\x8BV\xD0[\xCD\xF4\xFF\xABu\xF4\xBF\xBE-\xE0\x02\x88\xF8\xE59\x8E\xF7\xA0d\xF8q\xDD\xE5G\xC4\x83{\xF1C\xE4\xCBnJ\xA3IAS\x12k\xE7O\x19\xC0\xDA\xAE\x9F\\+R43-\xB1\xC6\xF2\x1E\xEB\x8BEzX\xFE\x8A\x80\x84\xFAP\x1E\r\v;\xAA\xBC\x0F\xEA\x9F\xCB\xE3\xEFO\xA6\x9B\xBC\x11\x99\xEB\x9F\xFF\x00\xFC\xB6wSk\x18N2E,\xBF\xC1\xE4\xFF\xF2\x1B\x03X\x83\xA0\xFD\x13kV\x9D\x7F\xECt\xEA\xDA?\x87(z\xFD\xD4]\xECJ?h'b\xA7)\xB1\xD2\xF8\xFB_\x8A\xE6\xF2$;\xF2'\x93{\xF8x\xED\xBBT\x02\xF6Ow2=*\xC8@\xC5\b\xDA?m\x88\x95J#\xF9:n&e\xD0sV\xB2\x9F\xBC\x1Cb&\x13~\xC9\xC0\x7F1=\xFC\v\xF9g6\x91\xFC\x05\xF8\x17\xA1\xA6\t\xFF\x8B_h\x13\xB7p\xA3\x014\x8A\xB3:\x8A\xB8\xA7\x07X\x9B\xF6\x94\t\xD6&\x96_W\x10JO\xBA]Xo\x02\xA1\f\xD6\x8A\x8C\x19\xFF@=\xFF\x97\x1F\xFA<;K\xD2H\xF7\xDA8\xE5!s\xEDz\x00/\x14\xB1\xFE\x96a\x00\xFB\xD6\f\xA0QR5k\xF3PF\x97\x7F\x9A\xB8{G\xA6\xBE\xB2}};\x1B\xA7^b\xA7\xDC;\x99aW_\xE3?\xA9\xA9\xA0\xFD\xFF\xAF\xEEu\xD6\x9B\xA7\x00|:\xCE\x06\xBEW\x8Ef\xFE\xC1W\x83\x12\xFE\x95\x1F\xB7\x9Fv\xA0|D\xD8\xFF\x81\xCC0\x13\xD0\xB7\xFD\xECdA\x06|U\x97~V\xA6\x9F$\xFC?k\xB0\x7F\xDE<\xCE\xEC\x17\xEAe\x17\x97\xBF\x9Af6[8\x89\xF0\xFC\xEDl\x00M\xEFM\x8A\xB9\xC2\xDF\x9Bn}a\xA0\xD9\xC4\x1D\x06%\xFF\x89\xBBk\xCA\xD6$\x9A\xD3}\x88\xA7\xBC\x1C\x83S&\xA5h[#z\xCCY\xD2]\xD7*^\xCA\xA0)\xFA\xE56\xE0\xFDf\xC0\xFF{\xB7\x85\xA9\x9DL\xFE\x7Fxf `\x7F\xAEI >\xDA|\xCB\x86\xEC\xEE\xE0B\xB6\x90\xF8\xF3\xEF)\xB0\xBC9s\x92]hk\x8A]]\xF5\xF1\xDF\x1D\x94\xFF\xC7[RS\x9D\xCC\xCE\xD9\xB9\x83\xBDtw=\x93\xCA\xF9\x95\\$G\x89RH\xA6S\"\xD0E)m\fd\x86y\x06\xCA`\xEB\xC8\xB32\xE0\xDDWU(\xFC\xD6b \xF0>gb\xDA\xC0\x94\x81\x8F\x98\xD5\xFA\xFF6O\xFF\xAB\x05D\x18\xFEI\xFE#]\xC9\xBB\xC4\xE4\xD3\xF2\xE7_\x93\x16\xD5\x1D\b\xA7EAX\xAAN5\xD9\xA7B\xD9\xE0\xC53\xB4XT\xC5 ,.\xBDG<\xE5&oO\x8B[\x9D|\xD2\xBB)\x95\xC1\xCC\xB4\xD0\xD2\xCF$\x99I\x05\xE5\x1FN@\xC9M>\xB8>\x9B\x0Ef\xAD\x8F\x8B?\x0F%\x99\xA90\xF9`\x9A\x06\x9A\r\xEC\xEA\x92\xFC\xABRJ\xEE\xDA\xBA\xA1\xA5\x8F\x9D\xF8\xF1\xAD\x1B\xF8\xF1\xBE\xFCuy\xD9\xDD_/u\xDE\x05\xFD 7\xF8\x97\x02\x81\xFD\x9F\x80>q\xA5\xF2P\xF5)\x12\xFEE\x99!i\x0E\xA5\x96\xA1K\xAF\xFC\xCD\xFD\"\xDF\xFE\xDE\xBBHQ\x84\xDF\x82\xFA\x16\xD4k\x11~\xEB\xF6\x1E \xFC\xBF\xEC\xFD\xAC0\xE0\xF7\xF7\xF8\xE3\xEF\xB6\x1Ed{\xF8\x84\xE8yo\xEA\xB4m\xDF\x06D\x9E\xBF\xC3m\x99\x1D\x1Fy\xDE\xD3\xF6\xFC\xF6;\xA7?\xEF\xED\xD9\xDF#\xE4\xBF\xCD\xBB)\x95A\xF7f\v\xFB\xEFb_\xCCS\x13rJ=6\x98Fn\xDCvWb\xD7\xF7\x9F\x0F\xDA\x9F\xE2\xCF#\xFB\x98\xFE\xD9v\x17;e\xD7g\x9F\xA7\xAB\xFB\xFA\xC7\f\xE2\x7F\xD7\xA7\x9F\xDF\xFFY&\xBA\x1Dtz\xFA\xFB\xCF\xDF\xBC\xCA\xFF\xAFn\xAB\xDB\xEA\xB6\xBA\xFD\x1Ao\xAA\xA0\xA2\xCD\x15x\xFE\x00U~5[\xB05\x8D'<Y\xC1S\x10\xA4\xDC\xADL(\xC8\x9C\x93\xF9i\xF1\x02:\xCD\xFF#\xF7Xgy\xA6\x01\x05\x06\xF7\x1A\x84\xC9^\x92z\x19\x13Si\xB4^\xF5%\xAA\x17&X\x99\xBA\xA2\xAE\xDD2&\xA7vMn3\b\xB3\xA1\fU\x15\x16NR\xE5\xC1T9?\xC9\x86;\xCA\xEF\x9A\xAE\x0E6\xBB\x93\x13\xC5\x9E\x90\xC3?\xAC\x92\xFF\xEE\xE9l\x1D\xDA\x8E\xB6\xF3\xFD\x99\x9Dt^\xA7[\xB32m\x01\xEA\x04\xD4\x0Fr\xF9\xDFi\x03\xE1o{\xC7\xFB\xF9\xF0\xDDd\xF5\xCB<J\x96\xDB0\x94\xDCfseb\xB3\x8DM\xB5vZ\xA5\be\xFBF\x9B\x96\xF6\x87\x99\x19\xF3\xFB\xD3\xDB\xBD\xA3\xEE\xE2\xD5\xDF\x94\xED\xD7\xADl\xA2\\#=\xD3\x7Fm#\x19qg\xCE\x11v\xF5\xCF\x7F\xA9N\xEE\x8B?\xE5\xBCb\xB0\xCD\xBD&\xDD,\x89\xD4t\xCB\xF0eM,O\x8BU\xAB\x9BOQq(%\xB5\xD3\xAC\xC6\xD3\xCETu\xB0}\xAEH\xAD\xF9,\xFD\xBE\xAA\xEC@\xB9\xD1\xC0#\x93\x8D\xE4\xC7\xCF8</A\xCE\x12\xCE\vJl\xFE\x02\x9B#\x93e\xDBU\x04\x9B\xA9\xB9\xDB\xBA\x90\x01\x14y\x96\xA7\x18\x8A\xEB\x80u\"x\x8F\xCF,\x06\x88\x05\x1AI\x192\xE1&\x1E\xF8\xB5m\xDB\xA1\x8F,\x1A\xB4\x9C\x99\xD6z;\x9B\xA7\xFCN\x9A@\xCC\x84>\xF5\x0EKD\xE5\x8C\xE5\x8F\x99\xF8\xBBsn\xBDE*Bw\xF0@\x9De8<\x07\xEC`p\xED\xF2\xB4\x89\v\xAC\x0F\xFD\x9Cc\xE7]\xAD\x94\xD1\xBA[\xC8\x7F\xBE\x93\xF0\xAF\xE7\xDF\xF2\xF0\xEF\xB2\xDC\x93s\xD5\xF8\x7F\xAD\x87\xCA\x1Dz\xB1Lz\x1EjZ&\x9Fg\xC7\x03\xCB\x8B~*\xCD/\xE6w\x7F\xECb\x11r7\xE6- >\xC1S\xB0\xE6\x00\x87=\xD9o\x07\xE4Oy\xC2\x19\xA8\xBE\xBF\xE4\xE3\x9F\x13\xFEZ\x86J\xD0Nt\xD8\x82y\x83\xB4\x80\xE5\xE6J\x19J\xFE\xA36\x1A<\xFC\xCF\xFA\xF8\xFF3\x1E\xC8\xA4l?\xB12\xFE\xE5\x94\xC5\x9BL\x8Cx\x8B\xFDi\x01\xCB\xE6\xA9:aH\xAD&jc\xE4R&\xAD\x86&&\xB6\xD5\x10\xACi\xAB\x89\xCE\xEF\t\xFDs\xCD$\xB1\x13\xA1\xDCz\xB3\x9A/\xDA\x92\x1C\xAB\xBAD[\x11\x1DLJn2\xFC\xD0\v\x88\xE4\xEF\x93\xBA\xDA>\x15xd\xD7I`\x18\x9A\xFA\xD1z\xFAs\x8B[\r\x99:6\x82P\x17\x9F\xCA5\x17\xC1\xBF\v\xF9\xEB\x0E\x9Bw\x13\xDEr\x99\xD1C\x06\x0E%%\xFCS\xE2\xF4\xF5[\x19\xFE\x9F\xF3\xAE\x12\x13\xF8\x9Fh}\x02\xCAHN\xE0\x9F!\x7F\xB1=\x88\xFFh\x1B\xF4\xA9\xB9\x95\xF1\x7FJ\x02\xD5\xDB&F\xDA\xDDuO\x14?\xB64^g\x19\x0E_NRU\xD6\xB1\xC3\xA4\x9B\xA52\xA0\xED\xB6\xF0\x1A\xB4\x97QVD\v\xA94\x8DB\xA1\xFC\xFB\xFC\x85W\x82m\xD84U\xBD\xD8\xE4\x7F\xEB!\xA2\xDEK\x9B\x1F\xDA\x0EU[\x17\xA0\xC1\x03\xF8\xFF\x90\x84\xFF\xF3}\x99\xF7\x91bk\x07\xDEG\xFB\x99\xC0\x1B\x1C^\x9D3k`\xBB-U\xEA\x04\x96\xCF%}\xF9w:\xBD\b\xEA\x7F\xD2E\xEF\xB3\x99\xFE\xF7\x93\xC2\xB9\xD1\xD1\r\x95\x19\xAE\x18\x19\xFE)\xB1\xED\x893>\xFE\x05\x95\x1A\x9B\xF8\xFD\xAB\xC3\xFF1\x13\xCB\xB3.\xFEiq\xCAh\xA9\x8E\xFCy\x1A\xE7\xAA\x85\x03\x99\x1Ez#\xA8\x16^\xD6e\xAD3\xC0^wl\xFD\x9D\xE7y\x89d\x9F\xAE\x80*\xB2\x01\xEC\xC8T\xE3?\xCDU\xBA\x1B'\x8F\x866\xA8yY\xFFw\x06\x87\xEC\x8FJ\xF8\x7F|Z\xC4t\xE7l\x911\x90\xBDJj\x92;U\xEF\xB3q\x9B\x11HDshK\x92\xD7\xE9\x10i\xA6l\x94\xFA\xF8*\xA1\x93\x9E\x97*E\xF8\xF7cn\xDD\xF4\xF5\xB3m\x1A\xD4\x91\xA4\xA4\xFFK\x92\xFE?d\x001\r\xFAT~e\xFCg\x82\xF8\xCFx\x1C513K\xE3u\x96Aq9T%\xD08\xB5\x87\x06;\xF2I\xBCl\x93\x17\x8F4\xF0\xAE\x8F\x89'x\xF7\xC3dJ\xAD\xC9\xF9ce\x93\xC8\x06\xF6_>\xF6L\xD5%^\xB6\xF1\x03vGn\xF4nx\x16\x911\x19\xFF?\xB8>`\xC7\xFE\x7F\x12\xFE\x0F>$\x86\xE3\x1F\xBB\xE32\xBB\xC7\xF8v\xAE\xE1s\xC0Ol`\xED\x9F\xFBRj\xFB \xB3N\t\xE7\xAD\xB9\x89E\x13'\xA6\xB4*\xFC\x7Fvvd9\x80\x7F\xA1\x96OT\x16\xA0O\\\xB1)\x9D\x05\xAD\x06\xBA\xF2S\x1F\xFFG\fZ\xE3\xA6N\xFCW\xFB\xAA\xE4\x7F\xCCD\xEF\x8B\x19\x19\xFFO\xCD\xD6\xC1?\xD7\x1A\xE3\xC5j\xFB\x87\xDD\x17\x11\xD7\x9F+\xE2,]\xF1\x0E\x03\xB7_+\xB2\xA9<u\x92/\x0Fqf\xBD\x13]\x96\xFB\x8F\xAE\xAD\xCECr\xB7\x81{m\xDF\xCC@S\x1E\xA1\x9C\x8C\xFF{_\v\xE0\xFFS2<~\xEA\xFC\xC0\xA5\xE8\xFF\x9E\xF6\xB0\x8E\x85\xA7\xA0\x9E\xE2\xE0\xF93\x03|Y\xA2\x90\xD2\xF5\n{4\x84\xF3\xCE\xCA\xC8&\x13\x8B\x14K\x8Fp\xAB\x87\xFF\xBF\x1E\x9C\x18\x90\x83\xE7\x15a\xD1_\xEC\xD3\xA0\r|\xD8\xA4\xD4F\xB4\x1A\xCE\xF8\x92\xFFf\xAD\xE3\x8F/2\xF0\x17\xE6\xD5\xEA\x9FL\xCE\x93?\x1B\bF\x07\xEB\xC8\x9Fk\x9ERPfw\x99\xEC\x1FO\xDD\xBF\xD7\x06\xAF\xEC\xB3\xCB@r\xE7\xD3B\xFF\xF7Q\xCB\r\xDA'\xBC\x13\xC3\xC2\xA2\xBF\xFD\xD8'\xAB.\xB1\xD7F\xB7\t4\xB8\x19\xFF\xD6d\x11O5Kw\xB1C\xBD\xA1\xEAxok\xCE$\xEE\xA5??Q\xC4\xBD~a\x8B\xED\b?\xCD]\x00\x7FX\xA4\b\x13o\x8A\xD3\xAAP\x12{\x86\xF3W\xD3\xDB\xFF\x1F\x13\x1B\xB9\xEF\x98\xCB\x1FL\xAB$\x1F\x1D>`\xA1\xD9\xA8\x96\xFF\xB7\x1EX\x80~\xF8_\x9A\xB8\xCD\xA2T\xF9\xC0\xE5\x07\xFD\xEC7\xD7\xF0\xC7\xA7\x1E\xBEme\xF9\x9B\xB2\xFE1\xD0\xFB\xF2\xA9\xA0\xFE\xA9\xB3\f\x87\xE7\xCBZ.V\xBFG\xB7\xB2i\xCEM\xBE\xF5\x0Et\x1A\x98\xEC\x7F\xD1\xB5X\xF6s_\x8C\x9Fd\xCCuo\xDD\"\x97\xA7\xA1-kPk.C\x0E5\x07e\xC3\xA44U\xD9;\xDD\xBD\xD2[<\xD9?\xFCqCL\"\xF8\xB3\xFE\xB8EI\xFC\xA8\xAA\xFB\xA4EK\xA7%\x82\x9D\xE4\x7F\x9Ek\xA7\x9B\x87N\x1E\xB0\xB0@\x84<4r\x017$i\xF1\xC2\xE8`Q\xCAj\xA5\x8B\x9B\x9A=\x9A\x84V\x1A1iNA\x01\xF0\xC9c\xFE\x8C\x89=\xAFP\x12\x91R\xD7\xCA\xF2\xB7\xA4\x9F\xBET\x84\x95\xFD\x84;\xE3g\xC8\xEF\x1F\xAB\x83\xFF/S7\xFAj\xF4\xCF\x1D=@\xF8y~\xE3|\xE2c\x96\xB1\xED.\xD1\x82\xC1\xF1\xAFh>VUQf\xF7\xE3g>Su\x89N\x9BZs\x19r\x84'\x10y~\x9B\xA4\xE4w\x84\x03\xAB\xF6\xEE\x90\x06\xA3m\x7Ft\xA3WO\x8A?\xEB\xCF\xF4p\xFD\xF3u\xEE\x02\xF8x\x0F \xBD>V\xBB\x835M|\xAE\xFD\xC9}\xB7\xFC\xF3\x1El\xBA\x87tx\xF4QR}\xEC\xFBM\x93\xCF/\xD9n9`\xB6=*\xFC\xA4s\xDB\xA1\xBFt}\x0F\x96l@{\x89!\xF6\xACO\xF2\x9F\xB6i\xDCizi\xFF\xCA\x85\xDD\xEF\x97\xF4\xCF#\x06\xAC\x17\xDC\xE1;\xCA\xE46t\xAE\x8E\xFC\xBFJ\xA7\f\xF5\xAC\x92^\xAB\xDB\xEA\xB6\xBA\xADn\xAB\x9B<\xA2\xD7a\xE8\x95:\xE4\x7F\x02\xF8|\r{oT\xB3\xEB>\xFF_\xD7\xE9\x90\b\xAD\xC0\xA2k~\xCBR\xE0\xBD\x85P0\xF1\xBE\"y\x10B\xE2H3\xD0%\xA5\x9E\x97\xC1\xD2\xBC^\x89\xE8}3Q\xC3\xDEW\xAF\x05\x90\xBEk\xA1z\x9E\x8B\x90{;\xD2\xAF~\x06\xA4\x90h3!u\x98:h\xB2\x89\xF9\xA5\x8A d\xCE[\xA8\x94q\xC9\xC6y\x93}Bg\xF6\xDB|<\xCE\xBE\xC7\xF7P\xE1H\x8A\xF9\x89'\xD8?\xDA.\xB0?\x89w\xD5\r\xE8\xDB\xCF\x97)J\x198\xFDh\xA2\"\x16\xB9\v\xF9\x9F\xEF\t,\xF7\x9B\x8E'.\x00g=\xFAT\xDF\xCE'\xDD\x93\xC0\x8C~\v\xB36\rq\xA1\xB3s\xDBN\x97q~h\xCDd<\xC3\xBA\xC1\fK\xD6\x90G\x16\x9C\x01&\xE7\x0E\xB2\x83\x89\x81\x9C\xE4\xDCl<\xCFf\xC1\xF1\xB8\xD7,q\xA1\xB0\x9F\x89!\xEE\x9C~)[)c\x9Al\xDA\xF9\xDD\t\x1E\x1AT\xF1\xBA\x17gs\x84I\xE0\nu\xEF4?\x9D\"\xA5\x11\xD7&\xE3yn\xF1\xF26O\x13h'\xE3{\xCEP\v\x93\xF1OVl\xCC\xB1/\xCC\xFE\xF9\x13v\v\xFB\xCF\xD1\x89\\h\xA7\x1Eu.\xB8\xE7N\x89\xA5'>\xC6\x14\x93\xDE\x02\xFEI\x89D\x1A\xEC\xF3\x84\xE5=\x84\x17\x0E\x19\xC7{\x94\xBA\xED\xA5H\xDD\x0E$#\xEE\xBB\xA3\x9A\x1E\x12\x84\xFC#\x16\x91*\xEE\x16\xB1\x1D\xC5@\xC8\xF0^\xAB\xA4\xF7\xD2\xE86{\xA0TI-\x0F8*2\xAA\x81\x88\xFDE\xDD\xD6DP\x0F\xAD\xCF\xB9\xC6\x15\xD7o\x18\xD0q\x90\xF5\x8A\xC4\xA2\xDB\xE4(\ve\xA1\x9B\b}\x87\xE3-\xEC\xAE8\xD1m\xD6\xF9\x98\x99\x87\x89\x88MN'\xCB\xE1MF\xBD\xEE\x85\xE6\xF8\xAD]\xB1\v|\xF1/\xDD&\x9F\x1D\xE7u\xBB\x1B\x14F\xCB;\xC0W{\xE8\xF6\x13t\ft;\x135\x10+B\xB7y#\x0E\xD0\x17\xB6\xB9\xD0\xA8{\xE5\xBE\x88\r\xF7`\x86\xC9\xF3\x9D>\xFE\xA7L\xF6\xC9^\x016+g\xF2\xBF\x187\xCE\x1B\xF4\xF4\xF5\x14\xE24\x11\x887{\xFC?\xE1\x9F\xE4\xAFg\xA1'/\x02\xB4\xB6\x033[\x9DI\x8F\xFF\xE7\xF3}+\x80\xFF3\xF1\xBE\x8B\x06&\xB7zn\x02&\x7F\xDB@\x05\x98i7E\xB4?\x03O\xDFt|`\x068?\xA41`\xEB\xFB=\xC7\x96W\xE9\xF0\xA7&a>\x9E\xE2\x8E\x98I^\x934>@\xF8\x1F\xE0M\x9D3\x04\xFEg\x1Ee8\x9C\xDD=`[\x98\x01f\f\\\x9Acg\x9D\xB5\xAB\xF1?c`p+\x93\xFF\x8CI\x99\x80\xF8+\xCF\xF0_\xE0\xB7\xCF\x0F\x9F1\xF8\xFD\x168\xFEg\xB6\xF6q\xFCO\xEDf\x97\xBE\xB8;\x01=?U\xE4Bc\xF3\xBB\xE9G\x9D\v\x86@~\x15\xFE#v\x1D\xFC\xAB0\x18,C\xC3\x94\x87\x8C\xB3:\xCD^6Z\x029\x8F7\xCE\x02I\x15\x88\xF36\xCB\x89*\xFCWy`\xA3`0P\fo.\xB6\x9D\xEB\xB0\x90\x81\x84\x91\x86_r\xE5\x03\x11;\xCF\xD0bi\n{Y\b*M\xA3r\x83a\xD6\xF3\x83\xB4\xA8<K]\xE2\x0E\xB2\x01*]7\xC6^aO\xDF\x1A\xD0\xAC1\xA0\xBB\xB1<\xA0\xDB\xD0\xA9\f\x8Aj\xE4yk>\xFE\xC9\xEB\x1B)\xE3\x8A\xFD,\xBFGJ\xBF\xDC\xEA\xE2\xDF\xE2\xCC\x06\xCFS\xA5\x8B\xA7\xF6\xA3p\x19\x9A\x81Hy1\xCC\x93\x99\x99\x03\xD4\x88\xE3\xDE\x8B\xC3s\xBEE\xAC\x91\x90)r\xC7\x85($\xF8|\xE7a\x0F\xFFL\xD3ZL\xFF{\xF8\xBF4g\x90\xFE?L\xFA\xBF\xCF\xC5\xBF\x90\xDB\x05\xF6\xD3\xA3B\xCF\xEB\xDB/\xD9\x98\xA5\x96\xCF\xC6\x13\"\xB5\xB9\xAB\xFF/\xD9\x81\xC4\v\xE7\xE6\xCC\xF3\xC0\xF4K\xDDU\xF8\x9F4Qig\x02aw\xC9PmO\xC7\xCDI\xE0R%?\xCD\xB0DP\x89|\x00\xC0kEI\xFF\xB37E\x04]W\xE6\xBA\xC4\xFB\x18\xCF\"\xFE\f\x7FA8\xA98o`\xEE\x99\x12\xE2\xDD3\xF1\xFC9\x03gLL\x9B\xB8\xB8\x15\xF2;B78\xC7\xDD\x82\xFD\x84\xFF\xD7z0\xCD4\xC0\xF3\x1C\xFF\xE7\xB6\xE6\x11/\xF1\xF7\xC2{\v*s\x85ijdz\xB7\xC1_\xA5\xCA\x1Ck\xE4\xF3\xECe\x99=g\x02\xF14\x7Fk\xA6\x1F]\xBC\xE4\xBEk\xE2\x8D3\xD7{\xFA?N\xC8WM\xFE\xC4\xC9\xEDh:\xA4\xF4\x0F\x92\xF2\x1Fq\xF5\xBF\x90\xBF\x94\x86\\\x03ZU\v1a;%\xC2v\x10\xFFfU\x8C\xC4\xC7\x82fU\x92\xE3\xFF\x7FuqH\xCB\x80T\xC0Pq'\xB7\x1F\x14+\xCFU(\xD4\xCF\xF3\xF2\xDA|[k!\x14r\xF8!\x9C\f\xE0\x81\x00P\x06\x10j\xE5C\t_\x01\x16\xB1\x11;\xBA\bt\xEB\xB6\xA6\xDBlP\xA0;u8\xFEu\xBB\x1A\xFFG\x8Cg\xB9\xFE'i\xF0\xAE:\xBA\x1D\x03f\xF9\xC2)\x0F\xFF!\x14\"\xB4\xC60R\xDE\xCF\xF1\x1F\xA5\xA1M\xB7\x7F\x04\x94\x9A\xC5X\xC6\xC7\xC1R\b\xD0,\xC9X2\x9B\xAB\xC6_E\xD2?\xB0\fW\xFEM\xAEU\x99\x00J\x92\xFCy\xA8s\x1Eh\r{\xF2/;a\xD1h\xDE\x93\xBF\xAC\xFFC\xF8|\xC4F\xC4N\xC8\xFA'j0e\xA2s\x85`\xF2\x07\xBD\xBD\xD1\xEE\xA2\xDB\xD7\xD8`\xAD\x93\x12\b\xB3+\xC6\\\xFA\xE57L\xE8\xAC\x1DAD\xBB\x96\xE4\vl8\x0E\x8DqE\xE1\xE5o\x8F\x15K\xC0\xB30\xB4\xA8\xC1\x06\xD0\xB3e(V\x1F\x97\xBFdO\xB6\xF2\x0E<j\xF4\x89|\x1D\xA6\x97\x00<\x1D5\x1C~\xFB\\\xFFp\x18\x84\xE0\x84hDV\xCDL\x98\xC6\xEB\x88\xCD\xEE\xE2\x8BL\xC1\xCE\xBA8d{\xA6\xAD\xC5\x06\x1B\x8D\x860\x90I\xFFT\x8F\xBF\xB2\xFE\xB9\x107.\xB2\xF7\xEE \xF4\x8F\xB8\xE3oB\xBC\x8C|\x8D\x1B\xDF\xC9\xF4O\xEAb\x19s\xD5\xFA'\xED\x1F)m\x93s\xE6E\x03\xD3[\x1DY\xFF0\x9D`\xE1\\{\x9A\xBF\xFE\x88\xAB\x88\xDB\xB3[\xFF`\x12\xF8Y%\xFF\x1A3\x14[=\xFC\xCF\xB8\xDA\xEC\x8C\x81\xD3\xF1\x9B\x10\x17\x17\x98\xDCm\b\xFD\xC3\xBA:\xC6\x87\xB9iw\xFC\x9D\xDD=\x8Ax\xA12\x97\xAF\x90\xAAT,\xCC?\xDAZ=\xFE\xEA3lO\x19\x8Fne\xF8?\xDB\xC3\x95\xE107k+s1\xC4G=\xFB\x93\xFBD\xCE\xCD1{{\xB6\x88\xE9\xDD\xDAY\x9B\xD9\xC6g\xB6\xB2\xBB\x88\xBC\xE4 ^b\xDA/\x9Eg*\b\xB8\xA6\x92|\xCB\xC0\f=\xBB\xB3\xE4\x18:\x98\x15\xF2?ha\xC4d\x9F\x07\xE9\x93'r)\xB4%\x87\r\xCA\xF4\x15=%2t\xC5Z\xBD\x8Cy\xF4\x13\xDDiTC4u\xB8\x88\"\xC9\xBF\xD8\x96\x10E:\xA2B\xFE\x8F\x1B\x01\xFD\x7F4f\x0E\x1B\x18u\x97Z \x9A\xE4\xE9\xC5\x8E\x9B\x18\xA7*H\x94\xCA/\x83\x98Qj;x\x14(lI\x17\x07\x1D\x0E\t\xA8\f\xE7G\xDD\xD6\x8E\x01\xC7r\xDD\x88\xE59\xFE\xC7\xDAx\x02\xC0,\x1B\x0E\xC8\xB15\xD2#2\x98\r\x1B\xF8vn\x14\xB1D1\x96>n\xA0db\xCABa\xB0\x95'x\x7F\xD2\x8F\xBE\xDA\xCA;p\xA4\xAD\xC4\xB3\xCF\x8D\xDB@\xEC\x06\xEE\xBE\x7F2\x96Gl\xDA\xCB{\xC6]*\xC7c\xADO\xD2\xF7\xA7^t\x8ER\xC2\xB4cm\xEC.\xFE$v\x03b\xB3\xA3\\J\xE4z\x9B\x1Dl\xFB\xB76\xFE=\xE7`\x8Dj\xF9\x8F\x1A\xB2\xFC\x99\xE8\x86}\xF9\xAB\x88Q\xCC?\x13\x8B\x90\xFFA&\xA5\x9B\\\xF9\xA7\x0FZ\xAE\xFC_\xAC\x96\xFFAHN@&\xFFt\xAD\xFC\x8B\x06\xBEa\xA0\xB8+\xCD\x9F\x05b)\xC4\x92#m\x05.\xFF's\tDs\x1E\xC1>\xE2\x0E(\xC7\r\xFC\xEDu\x05\xC4\xD2\xDC\x113\xC6\xFB\x16\xCB\xB2?II\x8D\x1A\"\x83\xDF\xB0\x81b)\x86Xb4\xC7\xE4?nc\xB4\x88\xE1R\x8E\xCB_J\xAB\x98\xE5\xF2?\xD4\xF6,?\xBDh\xB90\x8B\xE5\x8F\xE54\x9E\xE2\xE9\x1B\x86\xEF\xCC\x1A\x8Fe\x8E\x99\xEC{1Vz\xCEf\xA7\x1Ckcwq[\xAC\x1B\xB1\x11v\xF5F\x87\x87^<\xFD\xE2b\xC1@\x91(\xE8\x11\xC2\xE4\x85\x97}\xFD\xB3`\xB0\x97\xF4B\x99\xEB\x9F4\xD9?\xDB\xC9\xFEy\x02\xFA\x07\x10'\xB7\xBB\xDE\x87\xB8\xC8\xFCs\xC1r\r\x03\xA6\x7F\xD2\xE7-L\xF27+\xEE\xB8\xF3\xDF|]\xFBg2\x9E\xBFd\xE3\xEC\x9C\x14&\x04\xD8=8\vL\x0E\xE5\xB9-\x84x\x13\xE2\xDBO\xCF}\xB0b3\xFD\xF3\xC6\xD6\x84\xC88\xA41\x9C\xBF\xE1*\xB4\v6\xB7\x7F\x9A8\xFE\xCF\xBE\xF4E\xE1\x84jX\xE0\xD3\xEA\x852\xA6{D\x1FNo\xBD\x11qgfk\xFE\x1Ci\x95\x99\x1E,T\x1E\xE5\xAA\xC0\xCF#\xAA\x8BY\xC3\x91?~\x88\xFF\xC4&\xB9\xFC\xD2\xF1\xF4\xE5\xAD7!~#\x9B\xF9J\xFA\xE7|\xA5\xEF\xB2\xC1\xBEW*l\xE2c\x97q\xE6\x8F\xD9]\xFCk\xBD\x80\xF8\xD7I\xFFh\xBC\x9EWeN\xF9\x99\x8D\xB3\x96\xEBeX\xDDV\xB7\xD5mu[\xDD~-7\xD5OEc\xD6:\x02\\\x12>\xC5\xE9\x1D\x04}\x00Db\xD4]\x14\x90Z\xE1\xBB|6<^\x88\x98\x9Cl\xD5\x04Y\tvF\xDDA\xC4\xBB%W\xA4\xF2z\x98\x91\xDC\n\x88\xF2\xF5\x8C\xEEU(\xB7n\xF6\x17\xC9\xD5\xFF?u\x9B\xDE\xBDT\xB1\xF1\xA6\xE9G\x8CWlf\x18\x9C\xA5\x0EO\x96Q\x99K \xDEz\xE6\xA5,\x9F>\\p\x19\xFB\xE52_o\x9B\x98\xF3iCw2\xE5.\xD1=[\xF6\xBF\xD3\xFEy\xDE~\xE5%?\x04e\xDA\xC2t\x11\x95\xB9\xEC43\xA5\xFC\f\x9C\"\xCA6\xBE\xFF<\x11A\xD3C\xCC\xAE\xA0\xEFY\x99\xA5!f\xDE\x97\x7F\xC6\xC49`O\x11[LT^J\b\xFB$\x9E\x9D\xFDU\x95\xBFn\xF7G\r\xAA\x86\x16\x15,D\xD8\xA4\xA8W\xF7\xBD`\xD3\xED\x90\xA3\x9A\x0E\xC0\xA4\xB7\xC6\x10\xC0l69\xF5\xE1H\x14\x90g_:\xFE\xCB\x15\x92\xC3\x90\xD6\x83\xC2\xEAa}\xD5\xDBu\x8D\x8Dk\x8AP\xEEw\xA85_\x92.Y1@1\xF3\xA5klS\xB7\xD1h\xFB\x8DC\xEBs\xE9\x17\x7F\xF1\xF83E\xD6\xE0\x9DE\xF4\xDAH\xDC\xCF\x8E\xFC\x8D\"\xEB\x83n\xFFJ\xE3\xBF`\xF99%\xCE\x98\x98-c\xD6\x12\xEFBe.\x85x\xEB\xCC\xD6,\x9B\x02\x00\xE7\x9F\x11\x81mK=b\xBD\xB9\x1F\x94\x18\xFF\xEE\xCF\xC3?\x9B\xB6\\0\xB0<\xE7\xE3\xFF\xA2\xC5\xAEU\x99\xCBNY\x90\x93\xE7\xDC\xEE\x96H\x9EgW)MF\x96\xA6L\x10\x91\xDE\xFA\x0E\xF87\t\xFF\x17l\xBC\xC2\xDA,\t\x9A\"^\x9A\xFAU\xC5\x7F\xA4\xCC\xF0\xCF\xC0\xE6\xA6\x18\x8A\x10\xF9\xD6\\\xE4$\x1E\xA2F\np\x1A\x8B\x02\xFFJY\xC8\xFFv\x8B\x93Z\xA95~4\xD1h\x1D\xFCC\xC6\x7F\x86\x13\x9Ba\xA3$\xE3?f#v\xD4!\"\xCB\xDF\xFFg\xE2e\x1A\x1E\xB29\xEBhFx\xFC\xBFK\xE8AK\xD6\xC5\xBFnb\x9C\xF2\xEAk\xD6\x9C\xEB\xA5\x9A\xFB\x15\xC7\xFF\xB0\xA4\xFFm\x93\xCD\xCBN\xF3(h\xA6\xFF\x1D\xC4\xDB\xECx\x96s\xFE\x97\\\x88\xE6\x05+\xEE\xCC\x1A\xB5\xF8/xC\t\xE2RIe\x9A\x00\xCEX8\xB7\xDB\x7F(\xE7L,[\x98}f\xF8\xB5\xB2xA\x04\x07\xC0\x11\x1B\x7F\x8Dt~bRwf\xB9\x8B6\xEE-sp\\\xF5\x1E\xC0\xBF\xDD\xC3\xF0\xDFean\x8E\xBD)\xB34d\x9C\xF9\xD5\xC5\xBF\xA9\x9A\xF8K\xC3\xCF)\xA4\xDB\xD8`\x89,,Q\x03\x8AU@\xC8\t\x97\x1D`\x91\x8D\b.c\xDC/\xBCB\x85\x90U\xAB\xFF\v.\xD9[\xA5\xFF-N\xDB\xEA>\xED\x8C\xE6\x1E\xA0\b}2IK\x1D\xE7V\xD0\xFF\xCE5\xD3\x19\xE1\x9E\xF3\xF0O1\xA8\xBA\x1Dx\xC5\xE6l\x81\xFFe\x1B\x1A\xE9\xFF\xDF*\xF2\xD7\xE7WT\xFE!8\x912.\x95\xE1e,\x84\x89h\x19\xBFI\x1Dn\xB4\xD1\xD4\x93\x07\xDAT\xB3\x00|\x85\xCCE)\xB1\x03C\xBE\x13\xF7\xA15W\xA5\x7F\xE8\xAE%\xFC\x93\xE84\x13\xB1\xA2/1\xBD\x8Cx\x11\xAA\xB9\xA4\xDBu\xAD\xD9\t\x86\x7Fd\xA2\xFA\x9D\x8A\x89\xDF\xB2%\xFB\x93\x96\x17\x91\x8A\xF3\xF1\x9F3\x115q\xD4d\x86\xE85v\xAB\x8B\x81\x83\xEA\xAF*\xFE+\x95\xBEi\x93\xBC\xAA\xC2y\xC4,\xCF\xD9\xA2p\xAB\xCD\x02\xA7_2\x88\xB0rx\x05\xCCKs\xBE\x88H\x1B\x14&\x8B\x81\xE1\x15\x9E\xABZp\xF8\x12\xFE\xC9\x82\xAD\xD8xc\xCE\x8FM\x9D11k\xE2\xECK\xFD\\\x9By\xFBEt}\xDC\xA2,|\xCE\xB2mVl\xCC\x06\x8Fq\x87x\xDFj\xED\xB0Q\xA1@\x97\xDE2\xCE\x91s\xE1\n\xF5\xE1l\xF9WT\xFEO\xC6\nO\x95\xC9\xFEts\xCA\x1D31f\tZ{\xDC\xC6\xD3\xB9\xED\x88\xB5\x8E\xCF\x16\x10cH>8X\xF0\xE4s\x94J\xC0\xF8\xA5\x9D\xBD$r\xEE\x1A+\xE2\xF0%H\x13\x01>f\xE0D\xC9/\xD12^\xC63&FsKOy\x1C;m\x82\xAC\x8EQ\xAD\xD2X\xE2x\xFB\x9D#EZ\xAB\xEBU\t!\xFD/\xDC\x04\xEE\xF6C\vEb\xE6\r\v\xE3\xB3m\xA2\x80H\xEC\xE0\xE8\xAF*\xFE\x8F\xE5\xE6GM\x1A\x7F\xDD\xCA\x0EO\x99x\xDA\xA5\xB5\xFF\x1Axr0\x8D\xD8=\xA5\x13\"#\xDCp\xA9\xE0\xC9g\x84\xDDZ\xA9\xE8A\xCB/\xE3\"d\xFE\xA4E\xBC\xB7/\x7Ff\x8B~\xCB@\xA9\xF4\x88\xB7o\x8Ch\xF3\xE7f\xFB\xC9I\xD1]-\xFF\xC6$\xFB\x12s\xBE\xFB\x83\xAE\xA7\xA9c\xC2\xDD\xE0./\xA2\x8A?>\xFEu\xE0[\xA6\x90\xFF\xC8\xC3\xA7\xDC|\\\x07\x9F\xFAU\xC5\xFF\xE5\xADM\xD3e\xFCM\xD9\xC7\xBF]\xC6\xCF\xDC\xE5\xB7\xA7m,\xFD\xF1\xC7\x10/-\xCF\xF5A\xFF\xE7\xA4\x7F\x84<;,b\xE0\xE3\xCFVP;\xFF\x15_\xDE\xE8\xF1u\x91\xB7\xFFL\x0F^\x1F\xBF\xD1WbeT\fL\xC6\x97\xCE\xDA\x80\xEE/\r\x10\xCE\x82\xF8\xF6\x0E\xB2\x7F^o\xBF\xF3\xAC\xC1:\xE6\xB9>y\x87\x17z\x02e\b\xCE\xDB8C\xE64\xEB\xDE\xDC\x17Du\x98\xB8\xB3\xB0\x1Ar\xBF\xBA\xADn\xAB\xDB\xEA\xB6\xBA\xFDZmR`\xBDJyux\x98\xD3\xBA\x95\xCF\xA8J\xFB_o\x99\x00\x85\xA4\x06\x02J5\xB1_\xAC\x14\b\xCC\xC8=\xF2_\r6\xAFx;\xADD\x94\xFD\xA9\xA9\xDE\xFE\x90Ak\n`\xF0\xA4\xFD\x96\xEB\x1F\xA1\xA8\xD4\x907S\xF5\xFA\xA9hr&%%\x90\xFC\xBF\x8E\x8BD1\x13\xAA\xF5\xDE\xD8\xC4\xC4\xE3\x89\xB4\t\xFA\xABP\xD6{\xF3\xE5\x8C\xC9\xE4\x7F\x812\xC9x\xF4\xA6?\x95\x13V\xCDy\xB9\xE2\x80\xAAo\xBB\\s\x85\xDE\x07\xEC\x9B\fl\xB3\xFC9\x17\x1A(\rBC\xB1\xC3\xC6\xEF68\xDB]k\xE7w\xE9\xF3F~\xAD\x86%6)\x1E\xEA\x173\xBB\xD0\xE7\x9B\xEF\xCD\xC7#Kj\xC4\xC9\x8F'v\x01I\xC4T\xE0\xFCY\xA7\xD9\x00\"K\x17\xF4\x04\xF4\xFCF\xDB\x9C\x0F\xE5\xD9\x1C\\5\x97m\x9C/\x02z\x82\xD2\xC58U\xF2\xBFTF\xCA\xE2wg\xCE\x1B\x98#\x03\xFE\xBE\xB2(~\xCA\xB7\x8D\xEEm\xBE6\xD4<\xFD\x1E\xC9\x9F\x90p@T8\x1D\xE1\xA9\x15\xBC)[o\x19\xD7\xD8(\xFA\xE5\x00D\x1F\x8E\xFAwb\xC8+\x82\x97'\xB3\x9Bk\xA8\x9B\xD4\xDA\xED?4\xF0\xAA+\xFF\xBF7\x80\xB5DJ\xAF\xDD\xFEC\v\xFF\xF0\xD3\xDC\xAB.%\xC8\x13\xCC\xFE\x84\xB7\xA0\xA8\x912Z47\xFD\xAE\xA2m<`~\xB8?\xB3<\x9D\xC0\xF1\xFC\xB2\x8D\xBF\xAB8\xBDe\x1CQ\v\xED6\x10J\x1D\x8A&\xA15/n^\xFA7S\t6?U\xF21pGI\x9E>\x03\x19\x98\x97+\x13\xC3D:=n\xA3\xD8\xEE\x1Cq3\xDE\xA4\x83\xF5\xB0\xBC\x10\x97\xBF;\xE7\x88\x82\x92\xEF\xFA\xA6R\xDAr.\xC3\xB0)\"M]{>g\xE2<\x95\x03\x10\xF8\x87x\f~\xEC\x19/\x01\xE9n\xEBb\xCE\xA7j2`4\x9F\x19\xF9C\x1B\xDD.\xEF\xF1q\x03\b\x13)\x14N\x7F\x1C\xF8\xE4\xA6|\xB7{\n?\xA6K\xC2\x7F\xEF\xCB\x8E\x90\x7Fdi\xAA\xDD\xFC\xC9\xBD\x8E\x1Aq\x96+\xE9]\xC0\b\xB4\x8C\x89\v\x11Z\xB9\xA0/]\xA8$\xA1\x15\xDAZ\x12\x17\xB7:\x17\x88T\xEC\x15aQ&\xFBS\xDF\xEF16\x94\"\x80\xE1\xFF\x90\x81y\x13\x97Ms\xDE\xA4\x90E\x9E\xEAJ\xF7\x13\xA7y%\xDB\xA6\x86\x12\xD3\x07\x9A\xDF\x1B\x8D\xCF\xC4\xF7a\x81\x7F_\xFF\x1B\x96\xA0e\x9E\xB0\xD9\xDB!\xF0\x1F\x11>\xE57\xA4\x95\xF5\xF2\xD0\xB0<]XW\xF3\x9A\xEA\r\xC9\x9B\f\xBF\x1E\xEB\x8D\x06\xD0@\x18k\x18\xFD\x1D\x1B\xBFs\xFA\xC5\x0EW\xFF\xFC\v\x03~\xBE/E\xED\xB0P\xCC\xF6\x8B\xE7\xAB\rv\x9C\xDB\x1FR3\x1D\xFD\t\x1CH\xF7\x96\xF1\xDC\xD9\x99\xDE2\x0E\xF1\xA9w\xD48\x14\xDD\x0E}\xE4\xA3\x15\xE7\xAB\xE9\xC4!\x06\xA9\xD6\x9CI\x8E\xAAh\xF6q\x8E\xFF\x86\x19\xAFK\x7F\xFC2\xC3\xFF\x11\x03\x05\x13\x07\xBE\xB4t\xA8Hy\xF8\xC1\xFED\xD4O\x11p\xC5+\xE4z.?~v\xE9\xBD\xD3\xFF\x1F\xE5\x17R\xBF\x06\xFDk2\x9F\xC0n\xA1\x88\xCB\x96\x87\x7F\x91j\xF8\xA8\x9FY.#\xE3\xDFj/t\xD4\xE8\x9F\vk\x15Y\xFF\xBCZ\x06\xD6\x92S`\xED\x86W\r\xBC\xFA!_\xFF\xFC\x88\x1E\xAB\xF8\xB3a\xC9\xB0\xD0\xF1r\xBF`6B\tc(\xA3D\x96\xD4\xB0\x93\x1F\"\xDCXl\xFC\xBDtz\x89\xF2G9\x17t@\xF9\xD8\xC0\xFD\x89\v\x0F8l\xDE\xADfr&\xE6\x99\xFE\xCF^\xE0L\x87\xEA\xF3N\x8F\xA5\xD4Ke1\xCC\x8DdF\x9D\x1E\x91|\x9B\xC9_\xF7\xF5O\xC9\xED\xD8\xD4x\xD7\xF4\xFD\x89\xF7N\xFF\xF7\x8B\xE1uDT\x93'\xF9w\xD0+P(b\xC4\x8BE\x0F\x89\xF4A_\xF7\xC6\xDC\xC8\x92\xAC\xFF;\xFA\x9DWj\xF0\x1Fi\x18\xB9\xA9\x07\x1FqO\xB9\x81\xC9\x96\xF4OC\xEA#\x06\xD6o\xCC\x7F\xC4\xBDM\xFE\xE5w$\xFC\x1B\xD9G\x04\xB3\xD1\xB0\xD0q \xD3\xD1\xA7-\x9FQ\xD2\x07\xF2\x1D\x16:\x86\x16\x96m\x1CL\xAA\x86\t(\xB1CQ:\xE6\x81\x85BZ\xFD\x8A\x014.\xB2\xD1\xA1\xE8\xE9\x7F\xC7clX?\x1F^\x1C&\x1D{\x10X~ji\xD8\xC2\x88\xE5j]i]\x8D\x87\xFF\xE7\xCE\xE5\xDFS\xFD/\xF4\xBAb\x8A(y\xEA\x89A\xFF\x16\xA9\xAA\xAF\x00a\\\x10\x9E\v\x9E\xFCC\xD9\xAFJ\xE9)\xD6\xA7\xB2\xEF\xAB\xC1\xFF\x17\x1F)\xBCP\xF4\xF1\xCF\x06\xD9\xB5T\x9Cwm\xFA\x1Fl\xFC\xCEO5/\xAF;\xFF\"\xF0\xAF\xA8\f\x03/\f\x8BK+\x9Aq\xA0\xDBx`\xC1x\xD0\xC9\xEF\xD2X\xDF\xFAS\x86\x85\x837/1\xCD\xD6\xB0\xF4\xF8\xB9\xED\xEC\x98>mx\xE3\xD2\xBF\xB5\xE9x\x8B\x81\x07\xD1\xEC!\x83}\"\xEE/\xAD\xB5\xA7\xB4\xC7y09`\xF4iG\xA8N\xBAx\xEB\xA5\xF1\xD7K\x032r\xBC\xEBxR{O\xE4On\x91\xCB\x02\xFF\x13<\xB5\x177\xF8;\xE8\x15\xB8\xC5\x16\xEF\x02mwW\xEB\x9F5{>+5\xF6\x99\x9D_\xFD\xBD\x9A\xF1\xB7\xE1\x81\xBE\xDF5|\xFC3\x907\xDCC?8\x1F1\xF0\xCA\x03\xF9\x1B\xBD\x9F,\xD7@%\xFD\xC30\xD09\xEA\xE3\x7F\xA8\xBB\xA3O\xEBxPIwj\xACo_\x9A\xEE\xB0p\xB1\x8F\xE3_\xBB\xD8\x9E\xE4\xF8\xBF2\xA5\xCE\x1Bt\xBC\xC5\x86W\xA6\x7F\xD8g.\x80\xFF\x07\x16\xE6\xA9J\xEF%\x9B}\xBFh\x8AuX\xECZ\x92\x05\xF8i\xDBs\xBB\xA8\x95\xF7H\xFF\x93\xFEy\x94\xCB_IzW_\xE7\xFE\xEB\"\xE1\x8BA6$\\\xF6_\xF70\x1F\x1A{\xBFd\xFF\xFFV\xFF=\xB5\x19\xA8\x9A\x1E\xE9{\xC9\xC0\xAB\xEE)\f\xDEks\x1C\xFF\xAF\x1Ah\xFE\xB2\xF6\x8A\xDB\xC2\x8F\xE8\xDC\xBF\x978\xED\x8Er\xC6\xC7\xBF\xA51\xFC\x1Fp\xF2\xA6\x8F\xFFp\x03\xC7\xFF\x82j$9\xFE\x95\x8DK\r.\xFEi*\xA7\x91\xCB5\xE71\xF6\x94\"FS\xA9`\xB1j\xB0\xEF\x8A\xBB\x0E\x88\xAE\xE5\xA7\xD5\xFA\x82\x8B%\xC5r\xA2m\xB1\xF7N\xFE\x03\xC2\xFELB\x13\xF2ov\xE5\xDF]\x14_H\xFF\x88\xD1\xE1;\xBE\x13\xED\xDA)\x89+\x9E\xFA\xA3\xC1\xE6\x1A\xFC\x9F\xB7\xFA5\x03\xEFsOYo\xD0j_\xF6\xEC\xD2\xEB\r\xAC?\xAA\xAD\xF7~\"Q\x8B\xECO!\x06\xF2\xC4\x83\xAA\x8F\xFF\x07?\xC2\xF0?\xD0\x9F\xDA\xC4\xF1?\xD5a!\x17\xD2\x12\x84\xFF\xEEM\x02\xFF]-j\x97\x8B\xFF=E \xACuY\x94\xAE*\x88\xFF\xDB(\x98\x7F\xD4`\xDF\x7F\xDF\xC0\x89\xA2\x8B\x7F)a\xA9\x97\xCD\xF2\x0F\xFE\xA3\xFA\xDC\xE9\x85\xF7D\xFE\x9C\x96\xE7\xFAD\x9B\xF0\xCA\x04,\xBBE\x84\x83\xD5\x84k\xEC\x7F\x94\x9Bd\xA87\xDD\xF0\xE9\x1A\xFC74l\xB8\xC1\xC6=\xEE\xFE\xCF\xDA\x94e\x8B\xE9\xAE\xFCgm\xDC\xF5Z\xFE.\xF7\xA7{\xE9Q\xDE\xC3\x9F\xE0\x9A5\xE5\x1E\xF4\xDC\xFD\xB52\x7F\xBEMk\xCAw\x9F,\xDF\xB3\xA6\xFCi\xE5{\xAD\xDF)\xF7\xA0|\xCF\x8D\xE5\x1E\x1CzmM\x8F\xC1~}|f\x82\x1Ds\xCF\x9A\x87_S\x06{\xE8\xF8\x1E<l\x00\x9A\xF3H\x0F\xA0\xCD\xA3\xC9/\x15S\xBEg\xCD`\x19\xE5\x1E6\xFF*\xDF\xB3\xE6\x11\x1B_\xA3\x8B\xB2ki~\"\xBE\xA3.\x96\x06\xC7\xBE6v\xFD\x9AUvju[\xDDV\xB7\xD5\xED\xD7|kQ\f(\x9AjzK\x14M7eM]\xFA\xFD=\xDFT \xA9\xB8l\x86\x92\x10\xC5\x82\x15\x8A\xEAW\xEA\xF9\x17$\x96\xA9\xDE\xA6\xD5uI$\xDF\x81D\x91\xDC\x07A\t$h\xA7\xB1\xF2%\x12\xDE\xF7\x9A\xE4H5\x05\x82\xDD?I\xFE\xB9\x8B\x16F\xBE\xE4P8\x93Iq\xC5\xB1\xDE2&\x7Fi\xF2\xDF^#\x7F\x95\xE4\xBF=(\xCC\x0F@\xDAi\x14W4\x89\xA5?\x9D\xFA\xF2o\xF0'D\x17\xA4Y9\xFF.\x12.\xEB\x85\x8B\x96\x94\xDD\xD7\x8D\x93\xBCR\xD1\xA8\xEAS\x1EzB,\xFD\xA6\x13\x7F\xF62\xC5\xC4\xEA|Ix\xAB\xCC\x85R\x86%\xB1\xF2t\xF9\xE5\t\xE8\xCE\x11\x1BW\xA6G\x11\x1B\x80\xEE\xD0\x8Ac\xC74\xAB\x93E\xFF\xCF\xD9z\xCB\xB8R\x19\x11\x0E\x1A\xE2\xAFz\xBF\xBF\x04}\xF42_\xFD\x1A C\xF9a\x83U\x04K\xF0\x98\xA7\x83\x7F\xEE\xA9\x7F\xB0T\xD1\xF2\x10}\x0E\x90\xFC\x8Fp&\x93\xBFY\x9A3\xEC\xAEL\x87t\xCC\xE0\xF1<\xB4\"\xA2iD\x13\x88\n\xF9\x1F\xB11\x9C\xA6\xF0\xFB(\xCF\x8AYB\xD4\xE7|\x86\xC9\x94\xE5\xDFw\xA53\x88\xAE\xBF`\xC0x\x90\x92-\xAB<\xFDT\xFF/\x13\xFFi\x0F\xFF\xCD.\xFES\x84\x7F\xA5\xCA\x93G\x9F\x02W\xC9\xBA\xFA\xC7\xAD\xC8\xE9\xFEy'\xFF\xBF\xAA>\xA6,\x7F.s.[\xFE,\n|\x12\xA7\x1D$\xF2y\xB1F\xFE9\x92\x7F\x9EI\xD8%|\n&\x0E?@y\xC8\xF9\"\xF4\xE8=\xEC\xE9\xB8\x1BkG\x13\xF8\xBF\xD2\xF9*\xC2\x9F<bc\xF9\xEC\xDD\x88\r\xA3a\xE99\x1Bh\\\xFAe\xE1_\x05Ri\xC3\x95\xFFz_\xFEV\xAD\xFE\xA1\xE9\x9Ar\xAD\x90\xFFU\xE9\x9F/\xF0\xFF7\x17\x7F\x8E\xFEY\x94\xF4\xCFES\xD6?>\xFE\xB9\x8EZ\x1C\xCF\x92\xFEI\x93\x92\x11\xF8\xBFh\xE0\xD2\x1BTcN\x1Fu\xF5\x8F\xCF\xC5]\x84\xAF\x7F\x92\xA3\x03P\xBA.\x18\xB8mg+\xE2\xAFAI\x10\xFEG{\xCB\x98-\xFE\x12\xE4\xBFlc\xA9\xD3\xAD\xB2\xED\x96w\x81>\xFD\xB6\t\xE8\xC1\x0E\xE9\x7F\x05\xA9L\xB6S\xB7\xB7\xD5\xA5\xFA^\xE1\xFF_\xAEf\xB6\xFD\xBFym\x91$ao3\xAF\x1A\xCC[V\xDA\xA8\xC0n[\xF5\x91#y(I(i(\xAD\xDE\xE3n\xB7\x91\xE2\x1C\x05\xAF\x99\xC8~\xF2\xF1\xBF\xD9\xF6\x8Bq,\x9Fp\x10a\xFA\xFF\xB9c\x0E\xD3\xFF\x91%\xD2\xFFo\x19\xD6/\x07\xFFQ\xE0\xB6\x9D4<*c\xBC\x94\x83\x1Ab o1\x02)\x87\xE0\xA9#\xF7\xA5H\xD6\xF5i+\xC1\x91V\xE9\xF6%\xB0\x82\xFCy\x89\x10\xAE\xCD\f\xCE\xA4\t\x12\xBB\x8D\xE4\xE6+4\xEER\xDF<\x95&\xF9\xE7\xA1\x94<\xA9\x1A\xC0&\x91\x0F\x9FF\x01\xE5z\xB9\xB8aJ\xAA\xD2b\xF4i\x88i\xC3&\x8C\x07U\xC4\x1C\xA8\xC3%\x13h\x1C~\xB1\x07\xBF\x94\xC8\xE1(\xF0\xDFv\x12\xC6b%^\x9C%\x85\x014|\xF7w\x99\x96\x18\t*\r\n\xE5uw\xFE^\xDD\xDE6\x04\xF1\xDF\xC0\xCB\x10\t\xEF\xA4\xF4\\\xFC8\xDEo\xD0\xE7\xB3$\xFF\xEFR\x9B\x7F\xC3\x99\xAA\xC6\xD2w,\xA0\xD1\x97\xFF\xD7\xA9\x91gOt\xA1q\x02\x8D{X\x87\x1B\x85S\xA9\xC3\xC6\xB7\xA8\xD48\x1AI\xFF\xC7>\x87F?\xC0\xF5o\x8A@\xE3\x0F=\xFA\x0E\r\v\x97\xCA\xE88\xB0\x84\xB8\x85\xC8\xC5\vL\xFF\\\xBC\xAF\x8C_J\xE4\xFC.\x13\xDD_.\t\xF9\xAF\xDD\xC7\x00v2\x81\xD8]\x14\xF1\x1E\xD4\xFF\"-\x8C@\xF8H]\xFD\x13\v\xE2?\xF6c\xFE\xFFSU\x07K\x8B\x84y<\x06\xF7aq\x04\n\x1C\xC62\x94\v\xC5\xAF\xFD\xFA,\xC9\x7F\xA44\x8C\x98\x81X\x17\x1A\xDB\xBCb\xFA#\xC0\xB1\x1E:\x8D\xF7\xB9q\f1\xDF\x17<Z\x04bw\xFA\xF8\xE7\xF3\xAF\x03*\xE0@\xFD\x1A\xADF)\xE5L\xFCRV\x8E\x1C0\xD0\xFD\xE0].\xFE\x19zSJ\x0Fb\xEAQ\xC8\xB5\xF3\xB9@\x00\xE9\xA1<U\xB7\\H\xEC\xDA\xE0\x9F\xCDUld\xAD\xFC\xB9\xE4\xE5OO\xFEG\xCD\x80\xFCG\x84\xFC\x1F!\xF9\xE7(9\x92\x90\xFFS6\x8E\xF1w\x8A\x03\x80\xFD\xE4\xD7\xB1eO?\xB6G\xC6\x7F\xB7\x89\x8E\xFB\x97\x10N#r1W\x04\xC2\x8B\xF7\x95\xF1\x87\xBF\f\xFC\xAF\x03\x0E\xED\"\xC3F\x1D\xE0\xA9\x81\xB6\x85-\xE8T9H\xAF\x1A[\xA5\xCF\x9A\xD2B\x81cj\xFE\x9C\xAF\x82V\x83\x7F\xAB\\\xDA\\\xF2OZ\x92\xFE\x89\xC5\x98\xC0c\xEF\xAF\x91\x7F3\xC9?Cy\x96\x84v\x1A5p|cY\x92\x7F\x0E\xB1\xBB\xFDK\xB0v>\xEF\xD1\xD7hZ\xF3x\x19\xE5\xCF\xACa\xE6k\xD3W\xF8\x8A\xEC~\x03\x03\xBF\x8C\xC8\xF9O\x03\xDF\xBE\x8E\xD6\b\x84\x0F\xA3\x91a\xFB{3yh\xCE\x90\xED\xCFY\xDCy\xBF\xE3\x7F\x02Cu\xAD\x85\xBA\xA7\xD4\x1E\xDC\xE4k\xB6\x05\xC3\x9F\xDB\xF2\n\xC8\xD3\xC2\xFE\xFC\xEB%\x03\xD0\xFF\xD8;\x92O\xE2\x16\xC7\xF7\x91\xFD9\x0F\xFD0tQb\xE0|\x19\x97\xDF\xD8\xEE\x1B`\xFAC\xF2R\x85\x852\xBC#W\xB7\xD5mu[\xDDV\xB7_\xEB\xCD\xF2f\xC7\x9AR\xFF\b\xB3>O\xFE\xF367\xBFPf\x85\xDF\x13Av=\xB3\x92\xD1+'\x91Vd\xAA\xCD\x12\x89\x86BU\xCC\xBC\xF5s:\xA6\x98\xA6A\x1E\x81\x96z7\x9C\xF2\xEB]\xB2\xB9p\vM\xC3CAN?\xB8\x19u\xA5T#g\xF73\xD8\xBD\xF3C\t\x1E\xC4\b]\x9B\xAFm]\xCF_\xAAT\xB7|\xC1c\xB3\xA9\xA9K/\xD7)\xFAy\xA9\xCC\x0F3/U\xB2\x97l\xFC\x8C.\xF1VQ\xB4I\xFF\xB9\xAC\xB8\x9E\xA0\x00\xE3\xCC\xC5zw\xF0f\x19\x17\x8B~\x12\xDDy\xD1\xC2~\xEA\xB9\x03\x9D\xC9\xFF\x82n@\xFF\xBFi\xFF3\xD0\xE7DX\x9D>'\xDDE\xC0\x16Z4\xAD\x9Bm@\xDD\xBEC\xDD_{\xC5\x8C\xE5r\x14a'M%q\xD5\x90\xD6\xE2\xB6\x10\xA0/D\xC5=\x83\x18\t\xB9|\xC5Mu\x1E\x92\xC5\x8EO\xF6\xE5\xAB\xBC\x15G\xCE\xE5\x0F\xF2\x0EGg\x8F\xD4\x1Ar\xD1\xAE\xE1-\xD5\xE2\xF5\x0E\xE3\xF4\xEC\xC1\x03ubJ\x0FZt\x98\xEE<\xB6\xCBy\xCC$\xDE\x9BvR\x9Bd*G\\\x99D\x1Dbw\x9D\xE1z\xF2?l\xE0\x89\xA2\xE0{\xFDKG\xD9;\xF5\xF8\xB96N\xAD?~\xCE\x11\x89\x8C\xA2\xEF\x876 ,L\xAD$\xDDE\xE0\x1D\x1C:\xBD\xC0LM\xBDxA\x1F\xAEK\x03\n\xAABo\x15\xF13\x95\x99\xCBZZf>\xDD\xC7Z\xF6\xEC\xCC%\xF9\x11\xEB\xA7j\x9B\xA5\x8A{}\x8BC}\xCBA!\x1F<\x90>$:y}\xA1V\x02\xD1\xFC\xE3\xE7J\xD5\xB25$o\x02\xBF\xFD\x9A\xED\x90\b\xC3n\xFE\xCB-\x89\xBF4\x84\xDC\xBER\x14m\x92ZqY\x91h\xE21vd\xE6\xAB\xF5h\x84\xC7m\x1C\xB2\xF1\xE5\xE0\x13\xE7b\x9F\xDF%\xC4~(\xDA\x8D(\xE1?\xBA\bmNT:\xD6$\xFCG\x038\x1F\x1C\xD1\x06\f\xF6\x80\x8E\xCC|\xA5.rn\xE7\n!\xDAV(\xE21\x93\xE1\x7F\xF3\xCB\x8E\x0F\xE3j7D\x1B\xDB\xAFd\xAB\xE9\xC1\xE0\xB6\xD1f\xFB7N\xA5\xAA\xBC\xA5\x97*n\xA1R=w\xA1V\x02z\xD7\xC5\xA1\xB6Z\xDD\"OC\xDEl\xEF\xAA\x8B\"6\xD3\x8C,\x9D\xD7\xF3\xF3\x96H\x04}ALg8\xFE_\xF5\x94\x03eB\xDB\x7F\xA1\x9En\x9D\xB7\xE0X\xA2\x84\x9F?{\xA5\xD2uC\x15\x83\xAB\xB2\xE5\xCA\x9F\n\x1F\x9F\x9E\x83^\x12\x1E.]\x82\x8D\x1E\xC0\xBFsz\x81\x1D\xA3\x97.\xE8#u4\xA7\x8D?\x13W\xB9s\xD9\xC6\x9B6z_\x9E\xB9\x9C\xCE\xD6\xC3\xFF?y\x17Z\x92\xE2\xE2\xA0?R\xDB,\xBB\x05\xFD\xD9\xC5\xA1\xC3\vA\xF9\xA7F\xD2[\x04\xCB\xFA\xD5\xAD\xB5\xD3^\xA5k\xF3T[\xDD\xF1\xC6\xFBR\xB7\xE8\xF3F\x83\xE8\xDCP\xA2EIl2\x84\xDA\x14\x91\xC0\xDC\x15\xAB\xBAEl\x95\x04\xB1\xBB\x89T\xBDq\xB3\xDDF\x9B\x85v#@\x11\xF3J\xD0\xE7\xFB\x1C\xEE\xA61\x92?\x86B\xF8W\xBE\v\xA5\xD4&H{\t\xFFJ\xE0\rm\x1B!*G\x1B\xFD7\x03\xCF\xBF#\xFE\xFF\xB4P\xC4\x11\x13\x99]\xAD\xC7o\x16\xE2\x1D\x93;I\xC91\x10c\x9DyjJ\xC2\x7F\xEC\xAFj\x9B\xA5\x94\b\xA5\xB1\xC1\xD7\xC6\xAB\xE5\x9Fwo\nu$\xA0\xE4S}\x8B+\xC9\x7F+\xDD\xE9\xA6d\x1D\xFC\x7F\xC8\xA4\x8A\xCC\xBAs\xED>\xA7\xDD&\xDE\xDB\x97\x1E=\xD0\xC8\xA2'\x9CM&\xFBl\xAD'\xFF\xB6\"\xDA\xCAh3\x03\x8E\x0F.\xDB#SI>\x02n>\xD9\xEF\x92\xED1(\xFB\xDD\xABH\x15\x0F\x95\x80\n\xDDzzi\x91\xFCSov\x0E\xBC\xA3\xFE\xFF\xA7e\xCAR(\xE3?\xA0\xBD\xB9O\x87\x12\x17/\r\xC9\xFA\xDFZ\x01\xFF\xA5\xE5\xCA\xC0b\xF0\xC7\xBFy}\xCF\xDFr\x816\xE6\x9F\xAB\x1D\x7F\x1B\x13\xDF\x1C\xAC\xC6\xBFw\xD8\xB3$\xFFo4\xD6\xC1?\xCF\x07\x8E\xF0\xFAo^g|\x03\xF8\x1B\xDBe\x9F\xE0f\xE7\x88\xC6]\xB4d\xBEe\x02\x8D\x85g\xEB\xD18O\xDB\x187)\x9F\t\xEF\xAD-z\xC5\xF0?\xB8\x88\xC6$\xEB@l\t\xBC\x0F\x8D\x8Bh\xCC\xFC-?\xB8Q\xE2\xFFcsr\x9B\x7F\x9B\xD4\x1E\xB6\x01m\xF6/[\x9D\xBA\xF8\x17%/\xA3\xDD\xC3\x06\x1E\xB3\t\xFF\xAE\xFC\x83\xF8\xFF\x03\xFAd\xF2\x1F\xED\x97T\\\xAC\x8E\xFE\xA1,.\xA5\xB1\xC1\x81Rp\x90=:\xD8%\xBC]\xB1t\x1D\xB7K\xCC9\xF1z\xA9V\xB6|\x1B\xE7\xC9\xD8g\xEB\xD8?\xCF\xD9\xF8\x96\x01D\xE7\x9F\xFA\\~\xDC\xC6\x98,\xBD\x18=\xD0\xA8\xAB0\x1B\xF7\x1F/\x03\xB1\x1F\x97\xEA\xE1\x7F\xCC\xC0\xB7L\xFC\x8D\x19\xBC4\xE5\xBA\xB9\xE6\xE1\x12On3\xFEz?/\xBFKd\xE3\xFEg\xB8\xFE\x89\xCDJ(\n\xDC\xC2\x89\xCA\x02\xF1i\xA5\v\xFA\xE1\xBA\xFA\xDF\xB5\x93\xEF\xBCd\xE3<\x18\xFE\x17]\xFD\x13\xD4\xFF\xE4I!#\xEAmy\xFC\xD5\xFFj%\xFD\xBF04\xB1\x18\x14\xF2\xC8\x8B\xB9\xE3\x1C\x96\xB1\xFCH\xAD\x04b7\x94\xDA\xAA\xF1\xEF\xE5l?A_\x8E\xB6\xD5\xC1\xFF\x93\xC01\x03P>9\xDA60b\x89\x18l\x81\x7F.\x7F\xE5c\x1E\xFE\xD9\xD3\x89}\xBB\xAE\xFC\x9F\xB3\xD9\xE5<\x0F\x8B\v\x95\x1B\x98\xE6|q\x111\xAA!\xDE\xB6$*\\7.\"\x96\x11\xF1\xDE\xB1\x15\xF1\xFFLq\xA0\x95\xF5\xED\xAF\x7Fg\xEA\xE9\xDA+\xDE`\xB9k\x97\x1A\xBAo4\xF1\xDB\xCC\xFE\x89%\xDD\xBA\xBFA\xFB\x87\x17\xC6bcP\x8Bl<\xD4\xB3\x7F\x92E\xB6\xBF%\xADUyKGK\x19W\xFE\xE9'k-\x90X\xF7H\xDB\x9DU\xFB\x8E\x1B\xDE\x8D\xD0\x13l\xAB\x83\xFFc&\xC9\xBF\xA1<\xDA\xA6\x8D\x9A\x820\x7F\xCA\xF6\xD1\xEB\x13\xEF\xB1\xFDL\xBC\xB1\x1F\x9F\xA8'\xFFQ\x9355\xEA\xCA_\xE4\xFF\xA7\x94A\xDBbm\x9Cc/\x95\xFA\xDDD\xFDO#\xB6_\xA8\x88\x98\x84\xF9\xD8\xB3\x81\xA1\xF0I-k\x00j\xF16\xF5\xC5\xDA+\xDEfB\xB8\x8A\xC3\xDD]&\xBA\r,Wf\x97\xDC:\xEFA\xFC\xD3\x10CF\x94\xB3q\xC3U\xD8?}\x8B\xED\x03U\x85\x98\x17\x86\xE6/\xF7\x88i\xE9R\xAD\x06\xD6\vW*\x03+\xCD\x7F\xB9Y\xB8\xF4r\x1D-z\xD9\xC0\x9B=@\xD3\xF6K\x95\xFC\x82!,UQ\x8E\x84WG\xF2\x88w\xFD\xA1\x8B\xACo_Y\xAA\xE7t\x98/\xC3\xE9\xC1\x9B\xEE\x13\x17\xA5\xFA\xE9\xC6\xBFWy\x8B\xCF}\x9C{U1\xA7\xD67@\x7F\xE8\x92\xB0?%\xFC\xEB\x01_\xE4\x957n\xFA\xCB2\x10\x9D\xF8F\xB4\xCE\xF8\xFBm\xC3\x1Be\xEE|\xCE\xC6\xBF\xB7\xA0\x86\xE2\xA9\x9E\xBA\xF8\x7F\x82>\xD9\xD4l\xE3\x1BR`\xBF\xF2\xF9\x15\xEC\xFFx*\x997\x8CU\xCEku[\xDDV\xB7\xD5\xED\xD7ys\xCB\xEC\x86\x12WO\xEF\x1Br\x18\xBC0\xB2\xB4\x1A>\xDF5\xB0,-\xE4\xEF\xCF\x06[\xD2\x82\xFE\x053\x14\x88Dx\xB76S\xF5\x1D\x1C<&Ms\x07P\xCD\xE8\xD3j\x02[\x12\xF2\x8D\xA8W\xE5\xE0\xA8\xBD+3$\x96\x03h\xD2\x01\t\xD5\f4\x0EE\xC4\xD8#\xB4~\xB3\xED2\x03@\xFB\xD4\xB6\x96d^p&\x8A\x93\x1Cq\xDA\xA7|\xE3\xD9\xE8k\x06\x8A\x1B\xC5Z\xDA\xED\x90\xC2\\7\x9FL\b6\x80\xA2O7\x96a\xF4i-\x10\xE1v\xEDS\xD9\xF6\x00s.\xEE\xBB\xFD\xB5G\x98\xFC\xD5\xCC\xA6\xB4\x93\xC4{\"\xFF\rC\t\xAF\x9F\xA9\x9BgD\xB0\xB4\xFEB\xAAo\xA6\xF7\xAC\x13\x93d\xAD\xDB\t\xDD\x15\x91nCE`\xADt\x03\x19m\x80_Vo\x87\xF4k\xA7\r\xA8\x0E\x97\xFF\x0E\x06\xD1,\xD4\x81\x90\xC9\x8E\xE9\xA4\x1C\xBF\xE9L\x82\xBE\x18\xBEKB'\xF3)\xF2\xCA\x82\x05\x8F\xE2Y\x1C:\xB5\\!\xCBY/B?\xB88RXh\xF7\x05s\xA52\n}\xE2\xA2\x97\xE7Arm,\xB4Op\xDEc\xE9\xBAE\xF2q`\xB9BiT\xE9\x80\v\xBA\x13H\xA9\xE4\x9EuA\x9Df\xDF\x1B\x17\xAF\x8C\x8F.\xBF\xEBA\xA7\xBA\xB3l\xE3\xEC9\xC7\xBB\xE2\xC5\xB9\x89+\xEE\xEC\xECr\xE5\x83\xA6\xEA\xA6d\xA1wyG*\xC1D\xAA2\xF9\x9B\x16n\x9D\x0ET\xF1\xF8\x98-j\xF0e\x10$\x0391\xC5&t}\x036\xA0\xE5\xDB\xA7\xF3P\xB3Pfv\x18h\x01\xD8\\O-\x18}\x0E{\xF4\x9E\xC7Gq#TC\x89\x16iUH[\xDF@\v\xE7\xC7\x94\t(\x89M9\xA7m\xA4$\xE1?\x0F\x14[\r\x19\xFF\xE2\x85\xDA<\xB5\x0F\xCA6\xF6\xE5\xA7\x7F\xC0cbS#Z\x9B%x\xB0\xF6\xA9\\\xD0s\x94\xF5\xF1\xAFd\x11\xEE\xBE\xF6\xA4\xB3\xE5]7\x8CC\t\xC3Br\x17\x891\xCC\xB0\xA9\xAB\xA39\xE1A\xE8\xBAm\xE7\xC5\xBD\xDFw\xC4\x9F\x94\xBC\xBA%\x99hq\x89;\xC3BJ\t\xC8\x9Fu\x8F\b\xFF\xCD\xAE\x9E\x94rlp'X\xDF\x9DE@=\x18M\xA6I\x15\x8C\xB5\x97\xF1\xA52\x1A\xD9\xCC\xB7[\xB7[\x15&\r/\x91\xEF(\xF4W90\x16\r\x9F\xD6s\x86\x9C\xE5\n\xDF?\xC5~*u-W\xA4\xFA\x14\x95QD\xBE\xEB\xFA\v\xAC\x00\xFE\xF5\t\x1E\xF1\xFE\xF6\xAEy\xD6\x8E\x89+\x15\xC7\xC3\xFF\xE5\xF6\xC1\x00\xEF\xA7\x8B\x17\xEErj\x9A*\xA69W\xC6G\xAF\x94\xDF}\xF9wXHvr\xF93\xDDx\xFB\xA8+\xFFHa\xEF\xCE\xF5f8%\xF0O\x8A#d8\xA4\xB1\v\xDCQ\xDBX\x0E\xC8\x9F\xA4m\xCAE]\x0FH\xF2\xEF/\x03\xDA\xB3\x94\xF7;q\xC0H\x03\x03\xD0\x9E\x0E\x91\x8E\"\x7FP\xA2/\xDBJ\x8E9\x17\xFF\xB1\x93\x9C\xB8CH\x1B\xB7\xFD\x1C5\xA5\xC1\xC2\xF167\b6V(\x8D\xE4\xC5\x9F|n\x9E\xFB&B\xC6\x98D\x82!&\x929<S\x1AA\xEC\xBB\x00\x9E\"\xFC\xA7z068B\xA47\xBB\x9D\x13\x9F[|\xA6\x1C\xA05\x04\x83\xF4\x99\xEB9\xFE\x9Fy\xF1\x8D\xE3\xEF\xBA\xFA\x0F\x19*\xB0<\xC3\xCB\xA7\xE6\x00\xBC\xE9\xE9\x9F\xD0\xFA7\xCF\\4\xA3\x1B\xC4\xE3P9\x86\x13\xE4\xDF/p\xFD\xAFYK5\xF2\xCF\xC3-k\x0E`\x97\x11\xB0!\xA0\x96\xA8\x9CD\xA2\xD3\xCE3\xF9\x87?G\xA5\xCF\x91\xA3d\xF8\xE9\xCC\xD3\xF4\xC5\xF49j\xEE\xFD\xD4g\x17$\x07\xD3\xE2P\xC1\xD5\xFF%\xE8?^\xD0_Y\xAEH\xDCxe\x8E+\xD5Z\xFD\xBF8.\xF4\xFF\xDB\x1Fe\xD8^`\x83\xC5\x88\x87\xFF\x05\xBDpE\xE6=t\x91\xF7~A\x1D\xE5\xAB-\xAE\x8C\x7F\xFB=\xD2\xFF\xC6\x00\xD7\xFF/\x02\xD8\x94\x1Ek\x13\xE3\xAF\xD3:\xF4\xC1\xDE\xD7\x9F\xEF\x95.:\xB55A\xF5P\n\xBC\x12\xF4d<\x80\xFFs\x86(\x03t\xCE\x13\xA1t.\r\xCA%*\f\xD1\x1D\xDD\x9A\xA6\xAA\x13\xADgLL\x82\xF4O\xFC\x06}\xB2\x8D=\x1D/m{l\x94\x93\x87\b\xB7\x8DY\"\xF36\x83\xF1\xA0s\x9Cw16\x8B\xD8\x8F\xC7\xCFt\x95\xDA|\xFB'58\n%+\x0E\xE6\x04c,\xEB\xE2\xBF\xC8\xDF\x88c\xD94'*\xC7\x06'F- \xC6\x9E\xF2\x89\xD9\xC5\xB1\x00\xAD'b\x89\xC7+\x0E\xD4Q\xA8\x99\xE3\xB1\xD1c\xEF~\xD0\xB5\xB9\x0E0\x84\xFD\x93\xE7\xF2\x17\xF6O,\xBB<\xA5u\x89r\xCA\x00\xF9\"R\xC9D\xCA\xF4\xF5\x7F2\x19\xB0\xC8\xAEc\xFA\x9Fi\f\xCFO$\xAF\x92\xA3D\xFA\xCF\xB61U_8\x97\xA4\xAA\xA0\xF1\xD6-\x06\x1B\x07g\xD8\x89\xDDS\xBB[\xDF\xB0e\xFD?,\xA0\x1B\x99\xBEb\xCB\xF8\x1F[\xAEL\xB8\x03\xC4\xB7/o\xCA/J\xF6O\xC7\xD0(\x1A\x16\xC4\xC1\x02\xFF\x13.\xFE\x1DN\x8B-S\x8A'6\xA6T\x86\xDF\xF2\xF0\xDF>\x1C\xF4\x1C\x895P\xF3\rw \xF2]4,,W\x06\xDE|\x0F\xE4\xBFlc\xF9\x1C\xC9\xBF\xE10\xD3?\x95\xEDB\xFF4fS}3]\xED\x8E\x9B&\x8E\xE4\x7F2A\xBC\xB4;\xFE\x06\xE5\xFF\xA1\x1E!\xFF\x96*g\x1CG&;\xF1\xA1\x1B\x99\xFC\x13\xEDSy(\xEB\xA1d[\x80T\x91\xCC$\xA5\x90Jg\xA9qW\xFE\x8A&\xEC\x9Fp\xCA\xB0\xDC\x85N@\xDBH\xEB\x16\x9E\xA3I\x19\x85Rh?\x93\xB8N\xB2\x7FR})(\xAE%\x1F\xB4\xFF\xB7\x8E$\xB9\x9B\x95\xAF\x86K\x9AH&\xEFJYb\x81\xE1\xE6\xA9\x8Bm\xB2\xFEq\xBB\xD1\xFE\xD3\xB7\x18\xFE\x15m\xA3\xF2L\xFB\xBB\xAE\x7F\"K*0p\x80`\x16\xBF\x9E\xD90;[\x05\xFE\x9B\x9C7+\x13\x87LM\x04T\x90\xFC\r%a\xB8\xCE\xE2\x16\v\x9BO\x06\f\xB2\x16\xF7f\xAF5\xEA\xC8\x9F\\\xD8\xB8\x96}\xDE`0\xDBr\x1F\x94\x81\x8D@;e\x8D\x85\x92H\xA5\xEF\xA0\x07\xB1_\xC2\xFF\x88\xA7\xFF\x17\xDC6\x9D\xF1\x17/\xB7\x0F\xF0\xFD\xD0\v\x97\xB78\v\xEDA\xFBGw\\\xFCOy\xDE\x1F\x06\xF8\xF6\xAFq\xFC/f\x98\xC0/[Xl\x1Fy\xB3(b\x0F\x16\xDA\xBF\x1A\xD4\xFF'\xC5YO2\xE3\x07\x8A\xF6f\xE7\xD8\xE2\xBB\xBF\xE8\xCF\xEC-c\x80\x87'\x11\xD5\xBF+\xD3\x9A\x11%\x06\xB2\xDD\xFDc\x07\xEF\xD7\x0E\xF1?\xA9n\xFA\x9E0\xF6x\xDF\xE9Oy\x93\x7F\xF2\xF7\x04\x7F\x15\x9Fa:\x92\xFE\xDC\x03\x7F\xA7\xD7\x02=\xF1}\x02\xC0\xA1\x1B7\xDBhu\xB9\xF7\xE4\xD4\xEE-\xFB\xF8\xFC\xF7F(_i\x9FI\xB4\xEE\xF3\xF1\xAF2\xDC\x9An\x80\x81\"\xDA\xE1/\xCE\xBE}\x1C9\x9B[\xD9\xFEk{\xB0q\xEA\xF7\xB6\xF6\xD0\x024`\xE3T\xA1U\xA6\xF7\xDD\b\xB1\xB6\xA2\xC9@\xD5\xB0\xB0%\x99\x7F\xF7\xF1O\xF3\xDF\x05\xAE\xFFU\x06\xDD\xAFd^\xC8\n\xFC\xBF\x90\xE9\x9F\xD9\xD6sx\x1B\xEF\x15\xAD\x0E\x18\x9A\xF1\xD7\x1A\f\xD9\xECO\xB9-\xF9'\x7FO\xF0W\xF19\xE3\xB0#\xE9O\xFE\x8F\xEF\xAC\xB3\x90au[\xDDV\xB7\xD5mu\xFB\xF5\xDA\xFA9\xE5\xE1R\x19\x89*\xEA\x1B\x81\xF2v\t\n\xB0\xAF\xEF&\xA0\xE0\xFC\xE0\xB9|\xBFo\xCC'\xA2\x01\x82<\x13\xA2\\\xFArq\xDE\x10\x9B\x95\xBB\xAC\xBB\xA0\xEB[%\xF2<\x13r\xAF\x18\xC2\x07\x00M\xB5RR\x14^\"\xF4\x8B\xF8<$\x9B\xD2\xBAJf\x9Fw\xE8*\xD9A\xE3\x9D\x9D(d\xB3D\xCA\x19\xB3\xDC\n\xB5I!\x82\x1Aj3\xD4D\xA7\xED\xE8\xD3\xCD\x80\xD3\xD0\xEF\xE4,\x07\xD8O\xE1\xD5O\xDCZND\xD5T\xA4\xCC\xAD\x88L\xB0\x8F\x0E\x93?;\x17\x91S\t^\xF8\xB2\xD3r\xF7\xC3\xA1e\xC5\x1F\x88\x86\x1C\x84\x9C\xC8\xA9\xFD\xBB\xA7\x13;\xCB\xD9\x10\x12;\x80t\x86Y_\xD7L;{m\x84Bw\xD2]:\x14~\xEF\xCA\x9F\x82\x9C)\x14-\xBB\x03\xCE\x07m\x92\xBF\x9A@\xE8\x85l\x7Fj\xC86t\xA2\xDC\x07\xFA\r\x11\x1A\x1EuD2\rN\xAE\x86>(\xDF\xF7_T\xFE\t\xC0:\x1B-6\xDE\x16\x01\xEAO\xB4\xD8<\x80\x96}\xAE\x95\xAD\xAF\xE0\xB9\xEB\xE8\xA7\x8D\xB5\xE6YD\xB4\t\xFD\x9F.\xDB\xD8E\x07\xB4\xD85-\xE8\xFF\xE4\x07\xA3*l\x7F&\xA3mVKP\xCE[\x16\x9F\x9D9P\xBA\x93\x03\x89\x1D\x8A\x03\xF5`&\xDD\x96\xEA\xA7\xE4#\x16\x10\xFDa*\xE3\f\x9D\xCC\x1C\xCE\x90\xE1\xA4\xF4\x05,.\xB5\xF0%:\xBD\x05\x18\xE8sx\nh6\x85W\x07\x8E\xB0_\xFB\xA0\x16\xA0$\x8E\x9Ck\x86\xDA\x97Ig\xDA\x92\xF9\xD6-N\xE7\xB4\xD3n\xA3}\x8AM\x01\xFA\xFBJ\x1F\x06\x86\xCE\xCD3\xC3Le\xE0\xD8\xCE\xE9\xFA\xA8s\xE4\f\xB3\x97o0\xD8\xF7\xF6\xE9\xD6\xB4\xC1\xAExd\xCAA4\xBF}\xCA\xE9:\xE6\xE4\x88\xD7\xFD\xFD\xA9\xA5v\xCE\xEC\x85s\"\x99\x8CJ\x93\xEBP \xD3\xFB\x16\nR]6\xF0!\xC3\xE5\xCD\xB4\xC2\x96v:F\xE9\xE2\x15r%\x89\xCD\xCB\xE7.\xD3O\x8B\xB5/\x80\xCAN\xFF\v6\xAB\xED:`\xE0A:\xE0m\xA3\xA6\x85P3T\xD7\x86\xA7\x90\xD1\xCD'\x9D\xFB\x95{\x00\xAB\xD3&\xEF\x00\xC3^A?\xE3l4\x12P\x0E\xB6\x1A\xDD\xEAH\x1E\n\x93\x12\xD4\x83j:\xB1\vN\xA6\x8F\xC3\xD2_\xD9\xB1\x83]\xF7\xD9\x8F\x91\xFE\xD1m\xEC\xA5\xF2\x9A\xB7\x96\xA1\xB1\xFD\xCEN\xD7\x83\x06\xE4w\xA9\xEC\xCB\xA6\xF2\xFE\x98\x9D\xD6\xA7\x13-J3\xE9\x9F\xF5\x00vf\x9D\xF7\xD9\xD8\xA1\xDEIOj\x94\xA6\xE3\x84^\xB5\xD4\xB5#'*\xC9\xAA\xADj\xDA\xD9j3\xB9e\xCC\x02\xC2\xDD\xFF\xCC\xE8\xDE>\xD2E\xF3\x85B\x9B\xD1/H\x9CP\x10\xFF\xFA\xAB\xB5\xF2_g09\xEF\x12\xFE\xA3\xF9M\xAD\xBE\xFC\x0F\x05\x02\xD8\x9A\x834*\xFB\x1C\xAC\x95\x7F\x94\x9D\xB8\xD3\x00\xF4\x8B\x07\fq\x98K\x8AJ-\xE8\xAFBs\x83!\xE9Z\xAA\x99\xE8\xB4[\xA19!\xE0\xE1\"M\n\xB4\xFD\x83\xC5\xEE\xA6\x17\n\x80\x13y\xA1m\xB0\x98v\x19\xD7'\x86l'\xA4\xB5Fz\xF8\x92g_\xFFP\x8D\xDD\xC2\xFBhN\xF1\xA0\x89\xA8\x1B\xCBJK-\x06~\xD3\xE0Dn\x01ZZ\xB7\v\x80\x15\xCEf\x1E\xD5\xF2}\xD6~\xDDf3\x91#3w\xB0\xF6\xFA\x13\x8F\x19\xB8f\xB2\x8B\x0Ef-<Q\xE4\x84\x9Es\xCD\xB9\xFF\xEE\xE6Ar\x9E\xB0K\x9A\xC5\xAE\xF8\xBE\x17\x96\x10z\xF5\x89\xB1\xFD\x8F\xED\xFA\x1A\x7FM\x1E\x9FY\x1A\x12\x1C\xBE\xBB\x98%B\xB1\x9A\xEA\x86\x80\xFC;\xD9\xE3x\xDBD\x8B\x89]\"\xAB\xD5\xF0\xCE,efP\xBB\xD9\x85d\xF6IY/\x9F\xCB\x9F\xD7b\x9D\xC5)\xEC\xC4\xBF0\x01\xE5\x8E\xCB\xA6(\x7F \x1EnDz\xFA\xE1;\xFC*\x99\xCA0\xE9\xFF\xC4\x0E\\\x0F\xD5\x8A\x1A\xC4N\xAB\x05\xA8\x99\x8F\xD9\x85P\x7F7p0\xA4\xA2\xCBJ3\xFD\xCF$\xF9\xEA\x0E\x14\xAE\x99~\xFE7\xB9WB\xED\v\xA2\x82\xEB\xFF\xD6]\x06\xA2\xA9\x14|\xBA{b\r\x93\xC90\xE9\xFF|\x8C\xAA\x99\xEB\xD3\xF9]\xD3\xE9N;\xA3\x98\x99\\\x11\xBB6\xB1\xD6\xD7\x1A\xDD\xB7\x97\xA1\xEE\x98\xA7\x92\xB5\xEC\r\xCA\x882\xA9\xA5\xE6\x9Dw\x03\xF8\xBF\xD8\xFC\xB4\x941\x1D\xDDfcz\xD3]\x07\x11\xDA\x9E\x1D\xED\xDE\x9Bi\xA5W\xE3\xDB\xBBS\xFDY\x91\xF7\xF8N\xB1\xA6\x89\xA6\xBAP\x032\\\xEEc\x8F{\x9D\x85c\x16{\n$\xFF\xC3W\x86\xFE\x91\xC4x\x98=\x1Ay4\x8E\xFC\xA3|\xEE\x83<\xDBU\x9D\xE1\x9A=\xE2\x9D\x16S\x83!K<V\xD1\x8EzG\x80lW\xDC@S\x9D\xB5|f\xAB\x13y\xE9s\xC0\xD29\x83\xD8i\x06\xBC\xFD\xDA\xD6\x85\xA9r\x02z\xBEb\xE7\xD7\xBC\x94G\x9C\x18\xEF\xB5\xC3\x91\x97\x1C\x1B\xDB\xCE\xBE\xC4\xC5\xE2/\xE4\xA1B\xA8}g\x99\x14\xDBt\xFB\xFFg\xEF}\xC0\xDB\xA8\xCE|\xE1\xD7c\xC9\x1A\x8D\x1D\x8F\xF0\x86]v\xBF>e\xAC(\xD8V\x00\x93\xB4]X.\x9F3\b\x05\x1C5\x1B\x07\xD7@\xCBv\x8B\x97\xD2\xD2\xE6vK\xA1\xB4li\xAA\f\xC6!\x8A\xA1\xD8q\xCD\x92\xDB\xCBG&B!\xB6L\xE3\x96\xA5\xA5\x9BRG\xCD\xA6\x90\xA6]\xC2\xE6r\xEF\xB6\xB4\x0F\x9D\x98@\x12\xC3\xC6!\x04b\xCB\xCA\xE8{\xCE\xBF\x993\xA3\x91\x13\xB8\xB0\x85\xAE\xCE\x93G\x19\xCF\x9C93\xF3\xCEo\xDE\xF3\x9E\xDFy\xCF\xFB\xC2\x94a\x12\x92\xBC^\x07\xA8O\xCF\x90\xC4\xE2\xF5!\x80\xD8\xE4\xCAA\xA8\xCF\x1EnL\xD7\xEB\xA6\xB4}\xCD\xC4\xCA\xA4l\x80l\xA0\xFE\xF7\xB7G\x07\xE7kp\xE8\xD9\xCF@}\x9Cd*<w%~\xD1\xF5\xE6\x1B?[AS&\xD5?+\x1FMLhp(\x07'\x7F\xD6\x06\xF3\xF6\x9C\xAB\x9Ag\x1F0qp\x80\x17\xFE\xEC\x80y.\xED\x19\x9F\x00\x1Ff\x14\xAB\x8FY\xCA\xD9\xC6\x7F\fa\xF5,\xECMJ\xE7\r\xC5\xA1\xEAv\xF2\xC9\xCC\xB7\x93\xD7\x90R\xD7\xE5\xD0?\xF8P_)\xFE1\xC8\x11\xFE\xE5\xFD\xA7TX\xA7\xDA\x95\x9D\xF8\xEF\x04\xDF$\xFFeE\xD2\xA1\x83\xB1a\xA8\x8F\xB7\x1A$\x97\xF4 \xD4\xC7\xA7&.<\x7F{\x17\b\x9D\x8D\xF5\xE2\xAB\xB1\b]\xC8\xE0\xCB\x1C\x10.jzvw#Y\xCE\xC0e\x9D^\x88\xF5\x7F\x04\xC9\xF9\xC5\x83*\x84\xEF\x0F\x91)\xE9W\xD1\xF78~^\x0E\xA0ZD\xFA\xBF>\xF9\x91\t\xA4\xFF\x17m\x1F<\xBC]|m\"\xDE:\xD1~D\x81#\x17\xA2^\xB2\xBD'4\xA9Acx\x10G1B-L\xC6HG\x1FW\xE6\xBD@S\xCD\n=\x13=?n5P\xCF\xDEX\xBF\x17\xFC\xC9\xC9\x95\x83/\xAE\xECl\xCA\x01\xD4\xFF\xE8_W&&\x88<\xE7}\x86\xCA_\x9E\xF6\x90\x7F\xEB~\xD2\x93\x9ER\xE0\xCF\x99\x13\xE9\xB7\x9A\x07\xAD>\x91\x9FL\x84\xC0~\xFE\xDC\xCB\xCB\xF5\xBFX'\xE0~\xB0\xA1\x91\xE9\xFF*\xC5>d\xCB_\xEC\xE3[\x8E\xC4\"M\xBB\xA2 \xC4\xE9\xEC<\xEA(\xD74\x87\xC3Jz\x10\x84\xCE\x0511\x1C\x8E\x80\x10oQ\x90\xFC\x1B\x85\xAEH\xEC\x9C\xD6\t\x93\xE7\x8D\x91=\x86\xE4\x9C\xC5\fsh\x81\x06\x11l\xFF\xB4(xQ\x8C\x90\xBED\xC7S\x1E\xC2 \b\x91p,\x04B6\x9A>~a,\xD9\x1C\x8E7\n\xC4\xFEA\xF5\x13\xE9\xAE\xB0\x0E\vci\x1C\xC5\xAB\x13\x13\xE0Yr\xA1\xE8\xD6\xD5\xE8-\xE3~<\xFCH8\xACAS\x0EZb\xE7\x83\xBF=\x9A\xDE\xF1\x89\x97\x1EZ\x80\xEE\xFC\x85kb\xBD\x94\xB8\xF3?O\xF5\x8F\x98\xF2\x90\x7F\x84\xF6\xBF\x8D\n\xB40\xFBg\x19\x91\xBF\x88\x0E\xAD\xE3\xC5\xEB\xEBt\xCF\xBC\x03\xF4\x94\xCA\x1F\x9BX\xD7(H\xAA3\n\xB5|\xA8\xFD\xC3[_\xF2~[\xFF\xD7\xA1\x96\x9B\xC2\xBB\"\xB1\x95 \xACA\xF2\xEF\xC63\x0EB\xBCub\xC5\x02\xE1\"\x10\xAE]\x18N\x9E\x1FN\x82\xB0\xA6\xA5\x1B\xC0\xDF\xDB:1\xD8\xB4\xEB\x95F\xE2\xE7\xC0E\x8B\xBA\x00=\xFE\xA5\x98\xF76\xCF\xEF\x86\xE6\t\x8A\x7F<\x07\xD4\xB6\x80N1\xEC\x00a\xD7\xF9\xBBL\x10\xB2\x8B\xD2u-i\xB1ubM\xEB\x84\xD8\xA2@s\x18\xD5\xBF>=x\xBE\x01-\xE1\xF3\xF0\xCBJ\x02\xC0\xC5\xE1\x1D\xE4B\xD1\xAD\x9F\xA4>\x1EB\xFC\xFC\x896t\t\x05>\x12~\x01\xFC{.\x0E\xDFsml\xF5\x05\b\x00?\xBA\xFE\xB3wR\x8Fz\xDF\xC3\xD4e\x8A\xE2\xFFC\x8E>t\x8F-\xFF\xE59\x0F\xF9\xBF\\\x1E\xFFg\xE1C\x83\x1E\x8B\xA3\x8FS\x83\xA7\xEE\xD3\x8D\xCC\xFE\\\xE7a\x7F~\xC8\xD6\xFF\xB8\xE5U\x8C\xA3\xB6\xD8iJP\xBB6\xB0\x7F\xD8*k\x0FO_\xBB\x18o\xC6\x96\xAFr\xEEg-\x87X\xB3\xE2*?\\M\xEB#\x84\xE8\xFE\x10=\xD7o\x93\xF0\xE4B\xAB\xB0k\xD4\xD5\xD8$]eq\xE9~zK\xBA\x7F\xE0j\x05U\x8B\xFB\xDB\xBB\xE8\x94\"\x90\x11\x04]\xC7_\xFD\x9CC\xFE\"\xB2\x97\x1AspA\x0E6\xD0\xB1\xF8C\xDF\xFA\xC5\xEF\xF0\xC6\xA7\x91\x90x\xF7\x00\xDF\xA7\x1D\xF8\xC7\x87\xFAJ\xDD3\xAA\xD0+\xFEF\x0E\xC0\xB7\xEA\x82\x1C\xAC\xC3\x15\xD6\xE5\xECC\x96\x1B\x06\xF8\x0E\xF3-\xF7\x1F\xA6\x1C\xB5\xC5NS\x82\xFA\xB0s\x03/\x8B&\x7FR2\x9C\xA3\xAF\x1D\x8C7c\xCBm\xBA\x9B5k\xF1\xE1V;\x84\t'\xF57[\xDB\xA42\x80u\xA1\xFE#\xA6}\x95\xC3\x8CK?l\x92[\xDA\xCC\xE8\xF4\x9Dd\x83\x8E\x7FM\xCE%\xC0\xC1\x87l\xA8F\x7F\xFE\f\xE0V\x96 \x0F\xE4\x81e$O1^Ft\xCA1\xB0r\xBC\xBB\x9F\xE3\xDF\xB7J\xD5?n\x13\x1D\r<\xF7:k\x81\xB6\x13\xE0\xAE.?\x07\xBEf\x86\xFF\xE7*\xE4W\xA5TJ\xA5TJ\xA5\x94\x963\xF5\xC1\xC1\xFC\xFE\x99\xE6\xD2\xAB\xC2\x16\x89j\x13\xD7\xA5\xEC8\xE7l\x1Fr\xAE\xDE$\xF1\xF3\xDD\xB1\x89\xD8\xF4\x81\x88\xFFEJ\x1Aq\x13\xF9U\xDE\xB3\x01\xB8)\xCCxW\x95\xA5\xFFE'y\xEFj\xC1\xE7\"\xFE\xCF`>\x01w\xD3e\x9C\r.G\xF6\xF6J\x8B\x15/\xB1x\xD9ZT\xDF\xC3h\xE8ap9|\xCB\x95\x80y\xEA@(/\x8FOc\x89\xC9\x06\xCC\x00\xFA\xE7\xF2\xB6-\xC8i\x1A'P\x1E8\x0E\xB6?\xD8\xEC\xD4s \x0F\x80<\xEC\xA2\xBF\xE8\x9Fr\n\xFF\xCB\x107\xB07\r\x16^^\xA6!\x1F-\xBF\xFA\x19\x12{\x9CpA\xC5\xA7\xAE6 \xDF\x1F\x02\xF9v\xECr\xF6\x10Y\xD4y\x92Ux\xBD\x9E\xD2\xF5\xD5\xCF\x14\xFE\x9F\x03)\xA82\xD7>S\x98}i:\x0F\xB4\xC6\xC5\x07\x1A>b \xFBg\xF1\xDD\xBDP}\x19T\x9F\x03\xD5H\xFE\x1Fy)\xCC;H33)\xB9\x98m^\x8C\xCE\xAA\x01\xB28\xDA\xAB|\v\x8Dy'\xADQI\xC9\xF4\xCD\xE3<\x8F\xFD)\xC5^\v\\\xBE\xE8J\x87\xB9`B \x11\x95{\xF00\xB6\xC9p\x07mn\x9A\b\x83\xF0\x0Fd\x86\xE2\n\xC3\x0Ei\x1E\x0E\x93\x00\xCB\xCD\x11g}z:\x19\xB5\tI\xE2K\xB6La!>|t\xCD\xB8\xE5\xD3\xD2d\xE0\x81*aN>\x15\xF9\xBA\x0E\x9F8h\x12Z\xBE\x15\x8F\x1C;\f\xDB\x9F\xEA\x86\xC34.\xCA\x1A\xD0&.\x14\xA1>\x1BW\xD5\xE1\xB0\xB8\xE0\x00\xFDd\x967\x0E\xB6\xAB\x00\xBE\x81\xBD7\xC5\xC1\xD7\vu5\xE0C\x00HDP\x83\x8B\xDD\xDFv\xCF2\xE6{\x83\x06k\xBE\x1F\xDB\xC3\xE4\x92\xB2Ua\x91\x8B\xE4\xFD\x1E\x87\xEB\xD8K\xC1\xA3\xA7\xE2\x19\xCA\xFF\xF2P8,\x10\xFF\xFF\x98\x06\x8D*,T\xDC\xF2_\x88dH\xFC\xEE\xC2q\x85\x97\xFF|\x10\x1A@hs\xC5\xCDn\xB2\xFC\x06\x85\b\xFE\xD7\x86d\xA8\xB0Y*6\xDF\xD1\xC2\xF9\xAA\x85\xD8\x15\x17\xEC\x1C\xFF\x93\x1C\\\xDB\x1B\"\xBEa\xD14\x1A/\xC4T\xFBe%\xB6S\xFC\xC7\xE3\xF1h\xD8\x04\xC1\\\xBB\xCF\x9C\xB9b\xBA\x10\xA3\xBA\xE8\xAEp\xA7\xA6\x02\x88\xC9z\xD1\x87\x13\x98\x1B\x80\x034\xF54\xA3\xF7\xBE\xDC%\x001\xBC\x8E=\xCE]H\xBC\x8AM\xD3\x95\xEA%\x15\xC0\x8F\xF1_5\xDFK\x99<o\xCF)\x00\\\xA3BQ=\xBD\xFE)\\U(\xB4\xF6\xD8\xFAGEo\xDF\xA5Of\x90\xFE!~w\xE9\xBC\xCA\xEB\x9F\x14v\xD5\xDB3\xE3\xAD\x7F\xF0\xA2\x03\xF4/M\xF4\x0Fe\xC9X\xC0\x1F\xCB\xE9t\xD6\x80\xEB\xD8\xF6\xA9O\xDDtB\x85\xD9\xA9\b\xCC\xEB\xC1N}\x83$\xEC\xC3)vQ\x93\xE1?\xD2#>\xBE(\x01\xB5\xA1x\xAC}\xB8G\f\xAF\xA3n\xDB3\v\xF7\xA3\xC7\x91\x07\x17\xF7\xE3\x1B\xA8>\x07\xE4\x18v\x02\xCCZq\xBC9\xA5=x\x92\xC1`V\xA1\xB1\xF4O\x95\x99|^\xA8\x01%+d\xAFLy\"\x9B\xFF\x92>\t\x00\xDF\xD1\xE0\x01\xED\xB4=u:\x13\xCF\fG\xC7\x87\t\x8B\xABC\xB6\x1B}5\x8F9W\xBB\x8FL\xA6\xD9\x82\x82\xE77r\x01\xF0\x87\xA5A\xB4_J\x8D8\xE5\x9F\xB5r\x9DK\xFBq\x05\xF4\xF9?\xA0\xB0d\x7F,\xE0\x95\x1D*A\x01+\xBE\xD9\xC8_l\xBA\xCE\x80\x176\x980\xEFK8|A\x01\x00^P\xED\xCA\x83,\x98\x8C\x0FB\v&\x12 $\xE3WL\x8FM\x99k\x0F\xD3\xA9\xE6\xC6\xC6\x06\x9C\xAF\xB3!w\xA3\x0F}}u5\xC4\x1B0\x1C\x8E\xBA\xD6%\xE1\x8FT\xB8\xC0\xFA\f\x15\xEA7[\x0E\xFF\xCBU\xA6\xFFaN\xFC\xCFC\x1B_S\xD9\\\xC6\x1C\xC5\x1F\xCE,\x8Bd\xA3:\x91XB\x87\xAC\x06#\x1A\f;k\x8D Ib\xFCK\xA9\xFD\xAA\xED\x0F?6i\x824\x00\x92\xB9\xDD\xF9\xBE\xE8j\x0Ei\x1C\xD0\v\xD2\xD0?\x80\xDF+@\x83x\xCC\xCB\xBA\xE4?j\xB0\x8C\x90\x00#{#\x1BU\xF8\xED\x7FtA\xED_\xE2K\f\x90\xD8,\xD6K\xFF=\xC3\x7F\xD1P\xF3\xFD{A\xCE\xAC\xDD\xD5>\x9Dn\xDF\xCF\xA2p\xE4\x9B\b\xFE\xD3K\xFBwc\xFCO\x93\x0F\x90\xE0\x7F\xC6\x8D\xFF\x8C\x15?\x01G\x81\xC8\xCC\xA1\xFFQ\xFF[/\x95\xD5\xFF\x161\x8B{\xE7\x1B\x14\x04\xB9\xD3\x94\x9A\x0F\xFF\xEE\xCA\x0F\xFD\xE6\x02\xFD7\xF8\xDE\xEB\f\xF8\xB5\x06/h,?>+\xBF\x997\x0E\xF3p4\x98y\xE3O(\xF0\x02\x93\xFF\xAF\xBF\x9D\x06tH\xFB\x8D\xD3\xA8\xF8-y\x1D\xF3za^\nW@\x88\xFD\x81\x01\xBF\xA5\xEE\xE5\x94o\xB1\xAE\xF2kN\x17\xBD\xD8j\x16\rx\xE1\xDEk!\x88Zy\xE1\x82\x87Id\xB9\xDF\xB0\xC6\x1F_\x7F\x19\xBDw\xD9\f\xF7$A\x88\xF8\xAA\xA7\x95G\xA6ox\x86\xAE\x88\tS\xFC\x87}\x02\xC6?\xA8d\xCA\x98\xE0\xBF\xD1m\xB4\xCC_h\xB9\xD7v\xD3\xBC\f\x97\xCF\xD1\xFF\nx\xB2@\xF2\xB2\x7F,b\x16\xF3\xAB\xFF[)\xFB\x1E\xB9W&\xF4\xC6}\xA9f\x9DdG\x15\xB1\x1BC\x9F\xE6\x9E\xCE\xDEp8\r\"\xD6{\xE2\xC4f\x03\xFA\x98\xFC\xEF=<\x0E\xE2n\x10\xC7\xEFw~ht6JLa\xE2.M8\xFF\x8D\n\xDC\xA71.\x8E4\xCB\xCE\xBA\xD7\x00\xB6\xD4\x0ER\xCFg\xA2*\xDC{D\x03y%\xBE\xC4$\x99\xB6\xB6\xFCi7\x1F\xA4V\xFD<xn\xC9\x15\t\xD4\xFF\xE6\xD4\xE9]\xED\x9D\f\xFFO,\xECD\xEA\xB46\xB6vo/\xD4F P\x00\tu%\xD9EH\xFE\xEE\x85T\xB5\xE2\x0F\xD9\xE6\x13\n]\xB1UNn\xA7,\xFB\xB3\xD6\v\xFF\xD6\xB4\x0E~\xDDK\x15\xCA\x8D\x9F\xB6\xFF\x9DnM\x93\xFE\xB7\xD5\x80i\r&u\x9A\xAA\xD8\xD1\xFF\xD6\xEF%\xFD\xEF\t\xC5\xEE\x7F\x0F\xDF\x9F\xC6\x9Dl\xBA\x8C\xFDob\xFB\x7F\x1C\xE4\xED\xC4\x87\x84\xD9\xFF\x14\xFF\xB3\xEC\xACI\x1D\xBE\xCA\xBE\xA0W\x03\x97-\xCD\xC1\xB4\x9C\x84\xE0j\x008\xD2\xF1\x10\x89,je\xD6?>F_\xDFG\xEFn_}\xE5^\b\x84|\xD5\x05e}a\xF3n\xDA\xADg\x16\f\"\xF9K\xB1H_/H1\x10\xDA\xA9\xFCq\xAC\xA4/\xBA$ \x9D\x93aR\xCA0\xF9\xAF+\xB3\xD8pY\x0E\xC0w\x9F\xC5\x8A\x97\xD8\xFF\xBFcZ\xFDC\xA8\xB3\xCEA1wf\xF8oO\x13\xFC\xB7+\x90\xD2\xE0>\x1D68;\xEE\r\f\xC3 \xA6\x87\x14T\x81b55\x8EA\x9Ev\xD5\xE7\xF0\x9F\xC2\xF8GF\xF5f\x85E\n\r\xD2h\xFC\xDF\xB6r\xBF\xEA\xA0Z\xF8\xBF\xC9\xA7\xA8\xD07\x12%\xE1[7\xB4#\xBC=\xA4\xDA\x1F\xDDC\xEDt\xBAp\xF7\x97\xAE\xCCD\x13 \x99>P\x15M\xEDa\xCBf\x95\xCBwa\xFD\xE3;\x1B\xE9\x9F\x18T\xAD\"\xAEG\xE10\xEA\xA0\xFF\xCA-\xB4\x9B\"\xEC6\xF0Yq\x8F:\xAC\xFC\x0F\xF4P\x87-V\xBCd\xFC\xCB(\x07\xF19B}\x9F\x05g\x80\xFFg\n3\xFD\xE339:k0\xAD\xC1\xB4\x01f\xB7\v\xFF\xE3\xCC\xFE\x1C?i\xD8\xEBA\x8ASi\x1C]\x7F\xDCU\x9F\xE1\x7F\x13\xC3\xFF\xD3\b\xB7\xDD\x16\xFEW\x92j\xD3\xD6\x98\xD7`K\xAD\x01f\xD7\x17\x96\xE6\xE0T\xABI^Sq\n\xF5;'\xB9\x8F\xEE\xE4\x82K\x98\xFD\xA3F\xC2I\x10B\xC5)s\xA6\xDF\\\xCA\xB2\xE7\xCF\xAC\xAFA\x8F#o*N\xED\x06\xB9\x07\x7F\x86\x9B\xB0\xB5\x8C\xE4\x7F\xC8-\xB4\x1Ekd=\xA3\x01\xC8\xBD\x15\x9A\xABR*\xA5R*\xA5R,*\xDBW\x86\xAC\x16\xCE\xE8t\xD1c\x1FM\xA4\x1B\xF2\xE2\xC6K\xDC\xF05\xCF\v\x85\xCAs\xE9\xA1\xF2\xB7\x11\x02\rW\x9B\x8B\x1B\t\x9D\xF6Bgr3\xA5\xCF\v\x10\xC1w\x18/=k\xAEu\n\xD5\xA1\x8F\x024V\xB75\xE5`qu\x92OY\xB8\xC4]\xB3\r\x00>\xC2\x8D^\x17\x13W7K\xA6\xD5IBB.\xB9\x1B\xD5\\\\\x1D\"\xDC8e\xBFi\x9D0f\xCB\x91\x11{\x11\xB6:.\xD2`\x89\x10\xBA\xD8p\xDFU\xE9\x9D.!WG\xCD\x96\xAC%\xACn\x87\xEA\x7F@\xCF\xA2\xC1bt\x035\xE7\x95\x9B\x9E\xA8f\xFEQx%f\xE3\x15!\xA8N\xCE!\x9E\v\xBB\xE9\xCD|\xA4\xFC|\xC7\x85D\xFE\xD5\x91\xC5\n\xFA%;/\xFA\x97\x90\xF5\xEC\x8BK\xA9!\xDBJ\xFF\xF0U\x06,\xF6\xE9\x8BU\xB8\xDC\xD7\xC0?\xF8\xC7]\xA7\xE0\x95\x15\t\x0E\xBF1\x05g\xEC\xB2\xC4\xEB\xEB\xEC\xC4\"M\xF4\xA2\xFF:\x0E\x9A\x84\x1BG\xC6\xBFf\x93r\x00\xB0\"\x83,\xB1\xAB\fz\xE8\xE3/\xCDow!\xD6\xE7!\x93\xB8\x82\xAF\xEE3yg`V\xBF\x1D|\xF3\xC1g\xC65Xn@,\xF3\xE3\xE5eG%\xEC\xDDU#\xA0.\x8Et\x91\xB0?\xE5\xCA\x92\x1C=eE\xF9\xF1f\x82z\xDE\x9A8\x16\x13\x8Dl\xF9qv\xA1\x15\nt\x18h\xF8SF\x7F\x1CK)\xD0\x99R\x96\xAB\xB0\xAE\xBD\x01|\x19\xEBH\xAF\xE2\xF1\x89\xF3\xCExH\x88b\xD2\xE6\xBD\xC5N2\x90\xB9\xFB0\xAA\x94j\x16\x81%/\xD0,\xF1\xE2\xFA\xA9a\x04\x92^\xBCs\xBD\x01\xBD\x91\x06\xCD%\x7F\xD1\x83\xDD[o\xC0\xDD\x06&2\xC4\x12\xF9\x8BI\x10\xC3 \x86\xD6\x1B\xE8\x0E\xFB\xF6\xB0T\xBB\x1E\xCF\x1B\xB2&G\x10H\x0E\x0F\xCE\xBD27\xA1\xD2Sz\xCA\xF3\x8D\xF7\xD2e5\x91\xBB\xD8\x03\xA2\xFA\xECB\xEB\rH)\xF6\x10\xAFd`\xD5\x90W \xD31\xFE\x83n\x98i\x1D\xA4\xB9#q9\xE1\x92?\x9E\xE9\xE3\x9DQqN\xED\x94\xCD{\xCB\x9D_%\xD1V\xFBq\xCD\xD6\x10\xC84\xFC\xAC\x1D<\x96\xB0\x85cH\v\x9D\xD0\xE8\xA1\x13\x8B\x92\xAE\xD8\xF8VR]\xBE\x1C\xD3\xF1\xD5\xE5\x88\xD5\xAC\xA3\xBE\xAC\x82\x8C\xDA\xC9+\xF0V\x7F\xEA\xDCr\xC2\xB2r\xF2\xD6\xAE\x01\x80o\xC8!\x90/\x9AC\xFEO\xA8\x00r\x17\x00M\xA4\xE2Y\x8E\xD2\xB0\x00\x03X 16\x7FA/tB\x03\xD3(\x9F\xD8W\xE8\f+\xB0(\x1DnT\xA0Qh\x00\xC1\x0E}\xB3\xC0\x9D\xB02\xECZ\f\xA5\xB0\xC0\b\x8DVS:\x99\xBC@5\xC3B\xD8\xCA\x9C\xDB\xE8l$\x9AF7\x19\xC1\x95\x1B5X\x90\x0E\xB93Y\v\x1E\xF2\x8Fhx\x92Q\x88\xF3\x8B\xA1X}\x11\xCFE6(\x1A,T!\xDC\x93\x8C\x94\xD3\xB7V\x07\x87\xD9\x80\xADh\x90\xFB\xFC\x1C\xF2\xC7n\xA8H\xFE\xE7\x97\x0F\x92\xC0\xC2\x02\x84\xB0g8\x95\x7F8\x16\xB2&\xEC\xA2zy\xFD/w\xE6\x158&g\xF3\n\xCC\xA0\xD1t\xB3ud\xDA\x8D\xFF\xB4\x95$\x9AV`1\xF0Y\x1E\x9F$\x19\xC8\x93d\xEE\xF9[\xE2V*\n;\xF7:\xC5?\xFA\x98\v\xB8r>\x07\xF9\xB1\xAE\xBCqz\xFC\x9F$\x93\xECr\xDE\x9D\x14\xDE\xA6\xE3\xCC\"f9\x8E\xEFK\xDDPN\xDFZ\xE9Z\xF0L\xD9\x1B\x1D1>K~i\xC9#\xFC\xEF\x00n\x8E\xDE\xA3\x0E\xC5\xBF\x89\xF1Oa\x9Fg\x81\xA3\v8\xC8R\xBE\xDC\xFD\b\xC9\x88\x0EM\xBB\xA2a\x15\x16 \xC4\xDA\xF2w\xC7+\xC6\xD37<P\xAD\x9C\xCE\x16\xFE\xC9\xD7\xA1\xF4\xA0\x9A\vz\x9AA\xB8\x94\x1C\xB1\"\x87\x90F\xA2\xE96+\xDFSD\x87p\xBA\xAB\x04\xFF\xAB\xBC\xF1O\xB2Q\v%\xFAG\x98\x8F?\x81U\x8A\x86\xBE\xD0\xF3\xD2\xE2\xEE\xB2\xCFk\xD9?H\xFF4\xF6$\xE9\xEC\x7F\x99\x12V\xE9)Jy\x9B\xF6B\x8A\x7F\x05\xE3\xBF\x99\xE1?b\xDDvT\x87h\xB9\xFB\xA9]\xF5\x84\x0E\xDFOd~\xA8\xC2p4\r\x92==\xF5\x03\xD7\x17\x87cl\xF1I\x04~\xA0\xD0\\\xC3#4\xB4H'\x99\xBD\x1A\xC6\x9DMV\x1A\x00\xE9Q:ih]\x1D\x87~\xDA\x9EE\xBF?\xC4M\rk0\x9A\xEDr\x87\xA0\x97<\xFAO\x1A-\xAA\xB6\xD9\x11\xE1\x9C\xD6\x1F\x02i\x1Cj\x93#\x1AlW \xDB7~M\xB9\xE7\x95\xD8b1\xFC\xA4\xA3\xF7\xC6\xA0\xF6\xC29\xE4\x8F\x9E\x17\xDF\xCChy\xFC\xB3\xB0T\xFA\x93\x86=\x01\xF4\xE4\xA4iM\xC0\xFD\xC8\xB0\xE7\xF5J\xEE'\xB4M\x87\xEE\xBE\xCCM\x1A\f'\xD2Pc\x7F\xF8\x8F*\xA7\x91\xFF\x16\x05@B\xF2\xFF;:'\xDB\xA9c1\x8E\xE0\x95`Y\xF46uO\xF9\xA7'\xD1\xEF\xA3\xF8\xACm\x06\f\x9FW*\xFF\xC1\xD2;\x1D#O!5\xBB\xA2\xCA3\xF9\xA7@j\xC8\xE6 \xAD\xC0\xE3}\xE9\xF2\xF2g\x99\x17j\x90\xA0>\x97H\xBA\xF35;\xCB\xED\x06}S\xC3\xE5\xF1?J\xC3\xF8\xEB[\x15\xB0\xD2\x01\xEBR\xDCz\xF6\xB4\x06ce\xFB\xDF\x06E\x81\x8Bz\xA4\xC5*4\xF6\x84\xA1\xDA\xCE\xB5\xAD\xB8,.\x1Ci1\xC2=Wc7\xEDn\x16S\x9F\x9C\xCE\x8B\xF0M\x86\xB1/N8\x1C\xB3R\xB1\x87\x15G\xFFK:h\xD2\xFF*\x1A(\vJ\xF5\x8F\x87L\x14\x8Dh\x83\x84W\xFF\x1B\xC1\xFA\xA7\x19i3\x05\"\xE9p\xBC\xAC\xFEa9y\xF1\x93\xFE\x15\xBA\xC9\xD8\x1C\xF2\xBF\x94\xF5\xD4M\xE5\xF1Ou\v\xD5?\t\xA6\x7F2\xD6\xB3Gth.\xDB\x1F=<\x9D\x83\x03\xF2\xE3\xAF(`\xCA&\xD4\xDB)kg\xDC6a\xCE\xD5)\xCF0sn\x1F\xE5\xDE\xCDn|J\xA1u\x9C\x1A`,F\x19\xD7\xFF\x8E[\x06\xEA\x8CB\xED\xCF\xE9g\xFF\xD1\x1D\x82O\x1E/\xBD\xD3i\x8Dxq\xDC\xCF\xE7\xD5e\xF5\x9F\xC6]\xF0\xD3\xA8\x8E\x01\xD3\xB7\x8C\xDFP.\x91\xB1u.~\xD2\x97\xD0\x89\xF7\xCD!\xFF\x03\xA8K\xEDq\xE7_p\x16\x93\x9A\x1F\x0F\xBF\xD9m'\xF9-\xB4\xD6Y\xCF>m\xC0tw\x85\xE9\xAA\x94J\xA9\x94J\xA9\x147C^\x8E\xEA\xAF\xB2\x0Ei\xD4\xF1\x1ES\xD9VxX\xBA!\xA8\xA2\x17Q\xEFA\x9E\v\xEA\\\xB7Q\xB2G\x9C\xABfI\x83\xF6\xFA\x02\xAD,\x87_\x853\x0E\x9C\x11\xDB\xAFy\xEC\xF4yV\xC6\xEB\bBg,{\x05\xB3\xEE\x1C%\x9E\\\xC2=\xC5\xC5/E\t\x9F\xDC(t.\x16BK\xC2G\xC3*&\xD5U\x80\xEA5\x8B\x01\x96\xBE\x84\xC4~q\xCE\xE6\xBA\x97\\\xE1\xC8f@\xDC\xB0\xC3\x1A4V\xAF\xE1\t\xED6\x03\xE8\x85\xAA\vK\r\xF0p\xD8\x06\xF8\x88\x06\xAD\xD6\xBDU\xDB\xF2\xBFH\x87\x8B\xBD,\xC0%\x9A\xE3\xBA\x1F[p\x99\xBBY\x92f\xA2\x9A:\x95-\xAE\xBE\x12U\xE3\xC9\xB4\xEA\xF3\x9D\x13\x04t\xE8\xCD\x8B\xA8\xF5%&\xFFjs\t\xCD\x11\xB6\xA6\x91\xCDS\\tw\xC8\n\x16\xE4*\v\xBD\xE4\xFF\x91\x1C\xE5\xDE\x19\x13;\x9C\xE0\xE4\x7F\xB9/\xBBL%/\xA2\xB3\xE3\xA55\x1D\x07\xC3\x17\x1B\xA8>&\xB7\xE3\x1D\x06,\x8F \x9BSUm.\xBD\xE3\xE0$\xDF>N7\x80\xC4\xB5\xF4`\xDC\xE6\xDB\xB1\vh\x07\x9D)\x18\"\xF3\bW\x95\xDC\xF3\n\rb\xD6\xCD\xF8\xEC\x95 W\x19\x8E\xAC\x07\xAEkY\xDB\xCB\xE2\xC8\x98_\xCE7\xEB\x7F\x9E\x9FP\xE88\xF8\x0F\x1D\x06\xC4\xF9\xCF\x90\xA3\xDC\xF1\x9F\x9F)m9\x91\xA1OQ<\x98\xFE8]h\x10\xBF\xD8\xA0\x12\xE88\x88~\x8B^\xB7w\xB1\x17k\xBAB\x05\x07\xDF.6\xAF\xE7\x03Z\x1E\xEE\"!\x11\x12\xCB\xE6\xA7\"\x03=\xED\xD9\x84\n\xBD\n&\xC0\xC55w\x01lhF\xB0_\x9F\x03\x10)\xFE{\xDA\xC5R\x15\x92\xD0`\xB9\xF8i\x10\xED\xA7\xBB\xDF`,\xBAx\x82x!\xF6\x96\x8CJzun\xA7h\x0F\x06{5X\xEF\x05\xB0\x1E\xEEA\xFAt\xB8\v\x93\xF9\x8E\x90\x02\xFE\xEByM\xD6\xDB\x1E\xBB\v \xC5W\x10\x9D\xE3\xAF\xE01\xDA27b]\xFF\x05\xFA\xA4[\xC4<\xCB2\xBC\xE6\xAFU*\x81\xDE\xE1\x1E\xB2&\xA8\xB4\xFC\xB5\xD7KyR\xE3\x06Dh\xE0\xF0\xE5\x13\xDCS\xBC\xD9\xDAE\x1C\xD0\xFFi\xCF\xF9\xC7j\x9B_\x1F\x8B\xFFS\x0EN\x92\xAC\xBEr\x1Cg\x85F\"=\x86\xFE\xA4\xA7\xBC\xEEL\xF3M\xE8\xD0\x1F\x00<\xB9\xAF\x8B\xCF\x00~\xCCb\xD1\xE5!\xD3\x00OR\xF1\x84\xCE\x0F\xD6\xECY\xB0\x93\x9A\x9D\x8B\xCDE\x8A\xDA\xE7\xAAp\x12\xFBA\xBD\xCE7K\x18-\xD6\xD4\xC9}m'\rp\x86\xE4u\xCE\xB5\xB1\x95V\xBC\x88&\xC7\xA8\xFC\x7F:5\xC4\x1C\xC0\xE2O\x1A@\xFC\xE8H\xE0\xEBoy\xDD\xDE\x93^\xF8GC~G6\xB7\x18?\xB8n\x9D\x88\x92?\x95@\xACi\"y\xDE\x8D\xD9\xB0\n\x11\x85\xB2\x9D-\n\xB4\xE041\x98\x18of\xA78\x02\xB6\x13b\xB3)\x07\vc]$\xB6\x95\xC5\x97\xB2\xD5C\xFFH\xCE\x8C\x94\xDCs\xAB\xCE\xCD\xD0\v}v\x9B\xBA7\x03\x10\xE6$\xD9\xA2C$\x9Ct\xFB!\x93\xD0\x1C\xCC\xC2P\x84pDq\xBA\x05\bN\x17\x02\xA1\xAB\xB4\xE5p\x98\xA2h\x8Bp\x82F\xCC\xA6\xC9s\x938\xAAL;\r\xC7qf\xFA\x9F$7\xE7\xDE\xF8\xAE\x82\x03\xFF\xD9c\xF8\x12oL\x84fd_\xA1\x1Ff1\xFEO\xA1\xB1\xBFZ4`\x16'\x12~]\xB13M\x1F\x97\x1D*\xB4\x80\x85\xFC\xA6\n'\xF7\x99 ?\xC5\xE3\x9F\x81\xC7\x981\xC0\x9DT\xD7\x9A-\xB2\x1E\x9C[\tX\xD4\xBD=\x87\xF9\x16\x8E3\xFC;\xD6\x18\x8A\x8El\x05\xC5\xA9\xF1\x93\x06\xBC\x99\x9B\x03\xFF7\x95\xE2\xFF\x8D\xFEAvz\xF68]h\x93\xC5l\xFFn\xF4M\x1D\x1D\xB7\x82\xC5\xB9?O/\xFC\xB7\xF0\x84\x18z\x95_\xE6\xF3//d\x01\x99\x95\xAB:\x1B\x85\xDB\x9B&\x90\xFD\xD3H\xC3\xFE \xFCG\xD3I\x92g\x19\x84/\xD1\x99\xB2\x89\xCB\xF8\xF6\xC92\xC0V\x03\x16\xC6z@\xD0\xF8\xB9$\xB6z\xEB\xA1\v\x15\xF0p\x98\x07\x88\xE4\xC0\x8E\x97\xCE\xCD\x82-TO\x8F\xFF\x88B\xF1\xBF\x90\x7F:\x92\x1F\x9C\x91l\xCD\xE14\xAA\xA6\xCE\x81\x7FJ=\xF1Y\xA1\xCF\x8F\xD1\xD7\x97\xE9\xC9\xB3 \xF0&\x8E\xF7\xB2\x06]\xF7\x91\xB4E'\x9E\t\xFE\xB7*N6\xBB\xB6\xF9I\xEE\xCF\xB1W\x13\xDF\xD7\t\x83\xDD\xF9\xC3\xC9\xAE'\x12\xE11\x03\x9E\xC4\xFF\xA06:f@v\x14=\xCBV\r\xAC\xC9\x82'\xA2\x0E\xFC\x93\xE9\xE0-\x00O\xEE\xDDAR\x93\x90\x92f\x9C?H'\x86\xC9%JD\xFA=\x95&\x17\xC67f#\xF3I\xB5du\x15\xB8[@\xF79\x89\xA4\xF6C^\xFEuW\xF2M\x8Df\xCD1\x03\x86\xF9\n\xB5CN\x82:c\xB5f3\xEDY\x8A\xFF\xB5\xBF\x14\x19\xDB\x8C\xD3\xDD\xD6\xC6\xF1:\x1A\xF4\xCA\xD6zA}\xCC\v3\x9F\xCBq\x84<j\xAA9\xC3\xBD\xEB-R\x92\xA4\x8B\xED\xBEg\xFE\xD6\x9A\xAEt_v5N)\x8B\xC9\xED\xC4#\xE8\x11\xD0\xB3\x8C\xA86\xD7\x9Dq\xCA\x9F\xE4\xB3\xB8Q\x83\xCF\xF6e\xAD\xC7!T\xFF\xA3\xDD\x94\xAE'\x19l\xB7\x94\xDC\xDB\x0FU\x9A\\\x18\xB8\x14\x1B$\x1D\xED6\xAFg\xE13\x17?\xA1\x80\x8E\x97\x83m5J\xF0/\xD1\x1E*\x9B\x05\xDD%\x16)\xED)\x7F\x9E\xF0\xFF\x11\x9Bq\xC8d\x93t&\xA56\xB2Z\x07\x90\x10\xFE3\t\xD4B\xC6\v\xFF\x9F\xF5\x1A6\xFE\x95\xE2\x8C)*4\xF3\xFA\xA7QH\x90\xDE\xF9\x92\xBB\xCFo\xAA\xBE}A8~\xA9\x82\xBEh\xAC\x7F\x1A\x16\xAA\xD0\x8C}\xDD\x17+`M\xAF+1\xC7\x84\bY\xFBy\xA9\x06\x1F\x8B\xED\x00\xE1\x1C\x87~\xA0W\xDC\xD4\x9C\xF3\xD6?\xE7)l:\x0FU\xB3!\xD5\xAC{TF\xF5s\x0E\xFD\x13\x8E\xE1\xF9}\xC7\xF8k\x15\x9D \xC0eQ:\x12Q\xC1\x99\x12\xC2\t\\\xF6P\x1F\xE5-\x96]\xB4\xA7;[\x10\x19\xDB\x7F\xC9\x7Fc\x16\xC8\x82\x1E$\xFF\xB3\xBDn\xEFc^^+/\xB9b\x9AY\x89uh\x17c\xCEb\xF9\x1F\xB8?6}tEa*{P\x81S\xDD\xB8\xA7\x93\x1F\x9BQ\xA8\xB9u\b\x9D\xB8\x9DN\x04\xF4\xEF\xE2\xDB\x7F\x03\xFF\x1E\xEC\x86#\xAD\xF7\x80\xFC\x8A\xB5\xFF\xF5\x1C3\x17\xE5Wf\x952\xFD/\xE7\x8D\x0Fr\x9B\xB5\x7FV\x01\xCF4=|\xEE\x86\x93\x06\x9C\xC0S\x0F\x0E\xFBS\xE6C\x03\xC1\xF4-\xBB\xA6]MqW\x01n\xF9\xDBK\\\x9D\x93\xCC\xE3\xA58e\xE6i\xD2\xE4\xA7'u\x00\xF9Ydo\xDC2\xEE\xF9,4wO\xA5TJ\xA5TJ\xA5T\n\xCC\xE1Z\xDF\xEE\xC5\xDE\xBB\xFC\xD0\"\xE0u\xB4\xCA\xD9\xB8\x17\xC1.\n|8\x1D<_\x10TP\xCDj\xCE\xF4\xAAv[k\xFC\xD5#\xBE?\x0E\xF1WcgK\xA7\xD3\xFBb<\xD8$#\xBB\xC5\xD5\xB7\xD9\xCE\x8A\xC4\x1D\xC5r\x8A\xABv\xCA\xBF:\xD1j\xC0R\x83\xB3\xB2\x84\xFF\xE3\xC9\xEAC\xF5t\x9E#\xF3\x97\\\x81\xB6\x97\xA8\xF8\x1FO\xE6s\xB3\x00@\xBC\xFA\x05\x931\xF0\x91\x95\xCB>m\x87\xD3\xFF\xE0\x16\x9Fyq\x8Ef\xC5r\xB0\xE8~3\xA6\x11\x86|~\xCCv\xD7\xCF\x03KL\x06\xA5n\xF9\xBE\xC9\x84\xCE\xB1\xFA,\xFCKG\xA9%\xE6\x1B~\xE4\xA0\xEDRB\b\xF3\xE5\nt\xE8n\x02\x9F\x14\xCA\xCF\xFBL+\xEFC\"c\xEAc'\xECp\xFA\x1F\xDC\"\x86>\xAE\x01\x88\x8EI\x9F>\x15@\x94\xC82\xFC\x9E\xF6\xEC\xFD\x96LD\xAC\x01\xFC\xCC\x1BP\xDC\xE3l\xAA\x9D\x04\xE7\xB4\x9D\xDBE\x84\xFF\xBB<.j\x16D{T\xD4\x83\xC3_\xF7\x1B0\x94s\x84_\xB6\xB6)?/fA\\\xC3f%2+cC4B\xD1\x07\xBA\xC8\xE6N\xC3M\xFA\xA1aQ\xFDq2\x969\xDE\x11\xB7\x9D\xAC\xC8\xB0\xA5vM\x19\xAA\xD0<\x06pL\xE3GLY\x1A \xDD}\xD1\x81{\xA7l\xD1M\xE1\x11\xDC\xA4\x0ES\xBA#\x1C\x99\xB5\xCD\x12\xAD\x1E\xB5\xE2\xF9\xBC\xB9\xD2\xCC\x8E\xBDB\"\xA5\x7F\xB0\v\x0E\xBE\xCD\xFB9\xB3$\x92\x83dT\xDE4\x91\xBC\xD0\x12 I\xD7n\xFB\xCC;\xBBca\x98P\x9A\v,}\x855\x95R:\xE8\x13\x8E\x1DO\xDB\xC3\xCC\x85\xB1!BSDr\xD0\xE2$fIa\x1E\xF5\xB6\xFE_\x14[\x91X\xF6I\xA8\x1E\xF8\xE0\xE3\xFF\xE8\xC9\x1C\xCD\x8A\xEB`\xD1\xE5<A\xDD\xA9V\xED\xB8\xBD\\%\x0F\x0E\x9Fy'\xFC\xEA\xB3'T\xC8\xABp\xCCn\xBC\xD9\x9B\xF4\x96\xB7o\x9E\xB2\x979L\xE30\x17E\x03N\xEA\x8E\x8F\xA5h87\xEAMk\x8A\xE1\xCD\xA9\xA1\xDF\xDF\xFC\xD6\x1F\x07\xFE\xAD\x89\x1B'\xFE\xA3t\xDEj\x82K\xC8\x88\xB3fXSBn?\x95\xEA|S\x0E\xC2\\\xFC4\x10\x9E\xF6d\xD5@P\"=\x9F\xB1\xFEj\x9A@fU\v\x9EV\xE0\x19\xAA\x85l\x9B-\xA8\x1C\xB0\f\x9E\x96X2\xD2\xD3\x0E\xC2\x07\x1F\xFF\x92\xB9-\x07P\x9B\xE0\xF7=i\x00Hq2Y\xF9\xC3E1\x9B\x16\x96N\x80\x95p\x1Cm8\xCD?)\xFE\x83nt\xAE\x1D\x8BO\xBA\xCC\x9B\xF4\x96\xCC\xB5\xBF\xB4\xC3\n=\xB1\b\xBD\xFD\xEF\xE5P\xCDm\xDC\xC7b%b\xA6-H\xA6\xE5\xEA?\xF6jl\xED3\x05\xA8\xFD\xE0\xE3_j\xFE\x9C\n 9\xF0\x8F\x04^{\"C\x1C\xF2'\x93O\xD8\f<6\xF8k\xAC\xDC\xD9N\xF3C:\xF8\x88\x06:\x17\xB4\r\xA4\xDD\x0Eo\x7F\xBBf6\x93\xB5\xF1\xBFm2AB\x84=\xE2\x8CYg\xB5\xC3V4\fXo|k\"\x99\xC9&@\x8A\x7F\xF0\xF5O\x14\xD9\xFF\x82\x03\xFF-\xD8\xAF\xBE\x95\xBA]E\xECiq\x01\v\xBC\xDA\xCA\xDD\xEC\\\xF8 $.\xC0\xD3\x82-v\xFDK\xEC\xDE\xD3Q3{6G\xB3\x93Y\xC2\vt\xA4p\xF8\xA9@\xEBD6\xC77`]\xB15\x16;\xBBj\x95\x95\xBE\xF6\x83\xDC\xFF>\xFBZ\xB7\xDB\x92|C\x01\xA8\xDF\xFF:\xE9\xFB\xA6\xCC7\xEC\xFE\x17gs\xB0r\xC7\xBB\x1C\xEF\xE5\xE3\xAF+0\xADq\xD47\x8E\xC6cv{\x18\xBD\xC5)\xDB\xFE99\xD5C(\xFD\x19\x05u\xC1\xA5\xFD\xAF\xB5\xA2\r\xE40\xEB\x7F\x93\xC5)\x93\xB4_)\x95R)\x95R)\x95R)\x95\xF2\xC7\\\xAA\v\xFC_\xB3\x06\xCCNa\x1E[\x1E\x07y\xDC\xB5=kp\x15\xB8\xFAh\x8F<\xCE\x02$\xD2S\x1CK2ez._\xC1q9\xD2\xDA\x94]\xCD\xAA\x8CC\"\x8C\xFF\xD1\xCA\xDF\xC9x\xF4)\xD0\xD7\x8C\xDD\xA5\xC44\x88i\xD76:jU\xE0\xEA\xA3=b\x9A\xC6\xDD\x15\xE9)v\x18^\x91\x1EuUp\\\x8E\xB4\xD6lW\xB3*\xA3\r1]\xC1\x7F\x05\xFF\x15\xFC\xFFW\xC6\x7F\x91\x81\xB3\xE8\xC6\xBFI\xF0\xCF\xE6t\xCC\x12\xFC\x9B \x9B\xB3\x96O>\xE7/\x87\x17\x9B\xD8\x8C_q\n5\xE2\xC4?v\x1D\x94\xCD\xFF\"\xF8\xD7\x14\xD0\x9AY\xAAG1\xCCm\xC766\v\xBD\n\xF4*\x90\x19\x8E\xF1\xF5\xFBZ\x1A66\xC7@L\xD3eMA\x1C\x7FF\xBC\xD1\xC6\xBF\x94\x80`\xC3\xA0\xCEB\xAB\xD1\n8N\x88\x02\xBD\xCDv$\x90\xDE\x96pFAm\xDAY\xCB\xA5\x04\x0E\t\x12\xFE\xA3\x95\xBF\x13ZX\xFEX\xBC\xB5y\xA8\xCD\xF7.\xCA[\xDB\x9B[\x8E\xEF\xD4\xE1\xA7:\xEC\x1C\xB5r\x1F\xC1N\x1Dvf'\xB6\x8F$ \x88\x8Eb\xF1bF\xAB\xF6/6\xF3s\xAC\xB5;\n\xDD\xB0\xC3Q\x015\xB2\xCF\xD5\xDA\xD8\x8E\x9D:<\x85\xAB1/\xE8<:K\xCC\xFF\xF1\xE2?\xEE\x92\xFFN\x02o1\x06\xE2\x8D\x99\xE14\xDB\x8Emli\xE8S\xE0\x1E'\xFE\xD1\x17\xD1\xD2\xA0E\xF36\xFEI\xEC\xBE\xE0\xF1\x8D<\xFE\xEB\xA5\x8D\n\x13)Y\xF4\x87\xBF\x82\xB4\x02\x99\x11{i\xED\x86hgF\x81m\xB8\x1AM?\x11\xECD\x7F\xD6w\xFE\xF1\xCA?R\x82\x7F\"\xF3\x1BALg\b8\x83\xC7A\x9C\xD8\xDCr\xBCO\x81o+\xB0s\xC4\xCE\xC0\xBBYA\x00\xDE|a\x18} \nX\xC0\x86\xE0q\x1B\xFF\xE8\xF3\xD9\xF1\x94\x0E\xFF\xEC\xAC\x00\x00\xFD.\xFCg\x07\xDD\xF8\x0Fv\xA2\xB3\xA4?b\xFC\x9F\xE3\x96\x7F\v\xD1\xCF\x9DP\x1B\xDEi\xE1\xBF\xF6\xFA\x8D-\r\xBD\n<\xA1Co\x8B\x8D\xC6^\x1D\xEB\xFF\xE8\x12\x1B\xFF\x12\xC6\xB3\x98\xE5|fb IO+p\x8F\xCE\xD9?\x18\xFF\xC3:<p\x81\x8D\xFF\x07Z\xB3\x9A\x0E\x83\xB8\xDAO\x98\xFE\x19\xD3\x01j\xFFx\xF5\x7F\xC0A\xF8k\xDD\xA0}\xA1\x06K\xE9J\x10?\xAF}\xF1<\x8AX\xF1\xCAG\xBE\xF8\xD6\xFF\xEC\x86\xFB\xBA\xA1\xF7\x8B\xD7\xF2\xFA\x7F\xE3\x17\xDF\xDA\xBC\xFAY\b\xFE\xE9N\x9D\x83w\xED\xA5\xFFd\xCB\xFFR\xA8\xCD\xFF\x0F\x1D~L\xA6-j\xFF\x02\xCB\xFF-\x12\xD7(3\xC2\xE3\xFF\xCA,\xEEb\x00`\x90T\x16\xAF\xFC\xE7n\x80:\xB3BTTJ\xA5TJ\xA5T\xCA\xBBR\xE6t\xB6/\xE7\xE4\xCF\"\xF0\xA8\x1E\xF5\x9DE\xC4\xD9\x01B,M\x00\x1D\xE6\x96\x04\x0E\n\xF9\xE6\f\x9E\xEFSq#Z\xC8uV\xE9\x92\x84\xD2\x1B\xAE\xC2\x01\xDD}\x10jD7\x1D:\x8B{j\x01\x14lc)P\x15\n\x82*\x80\xE5\x11&V\x11oL_\xC8j\xED\xAC\xB7\x11\xF8\xE7m\x14\xEA\xAC/\xD7[{\xA6\f8\x84I\x8F\xA9\xA3\xE8\x8A\x07\x1C\xA3T\xECMQo\x1E\xC0\xFB\x0FZ\xF2\xAFO\x9E\x9Cj\x83\xFA\x90;\xCEF}\xEA@}hj\xE5*\xD4N}\xE8\xD0\xFD\x97M\xE0\xDD\x07\x98\v\xC4K\x1A\xBEJ}\xE8\xA0\xDCv\x00\xE0\x90\x06P\xCF\x11A\xF5\xE6\xA1\x1C\xBA\x9F\x89\x95!\xA8W\x0E\xDFO%0u\xD4\x84z\xE5\xE5g\xBB\xA0\xFE\xE8\x01v\xCFtp$\x9F\xFF:\xC0!\xE6\x023u\xD4|Y\x85\x83\x1A\xF8\x84PcU\xC8\x96?\x0E\x16\x11\xEE\xC84\xC8&\x88\x11\xA8\n\xB5\xA8\xAA\xA0\x02\xF8\xF00\x84$\x03\x15\x86\xC07\xBF\x91=\xE3Y\xCBh\xBA\xC6\xE2\xA1\xC2Z\x92&O6\xD7\xE6\xE8rl\xB4'\x80\xFF\xBD\xCD\xB2\x94\xA6\xD3\xB2];\x87\x01\xC8\xCAd]B\xCF\xBB\x93\x17i\x10\x0F9%\xDF\x18\xCE\xA5\x98\xB1\xDD\xB7\xC4\x81\r\xBB@2\x87\xDC\xA1\\\x8F\xEE|\xD5L'>M\xF2<\x0E'\xE2\xA4\xB51\x03\x88\x83WF\x85-\x92\t\x92\xB9\xEDHl\xCC\x00\x9C\xF2\x8CK\xDE$\r\xFE\x18'\xCD\xD4\xFBP\x9D\xED\xAFR_\x1A]\xEA\x01\xC9\xCC$\x06\xA16L\\\xB9\xF0\x9Aq\xEC<)e\xF8e\xEF\xC3\xD1\xCC\x88\x02\xE3\x06\xAC\xDDg\x16\x0F\x84\xACxP\x91\xDE!$\xFFe\x91\xA59\x1C\xDB\xA4\xBA\xD0\xD2a\xE2\xC0/X\xFER\xFB\x06\x15\x07\xF4\b\fY\xE9/Ou<\xCF4\x86\xEA\xA3_\xBE\xEAc\x9F\x12\xDE\xA3\x9Eyvq\xAB\xD0\x00)R\xA8\x9C\xFC\x1D\x94\xABD\xE5?\x8C\xF3\x02\xDB\xC1\r$q\x8B\x14\x01Iq/]\x97R[\xA4\xD0\xD8\xE4*,\x8A\xD0\xF7\xA3)\xD2ZZ\xA5.p\xC3\n\x8CM\x86@\n\rG{\xB7\x90w-q\x10\x92\xCC\fv\xBA\x1B\x9BT@\xEA\x19\xEE\xA3N\xA1\xDB\xF6\x9A \r\x0EGC =\x91\xC6O\xBCUe\xCE\x93R,\xCD\x05+\x18{\xB5\xE1\x11\x15\xB2\x1A\xF8b\r\x7F\xB7\xC0\x04A\xB9\x11\xEF_\x11G\xF2/\xBE\x9C\xBC)P\x00)\t5\xCA\xA2\x89\xC8\x83\x06\x80\x1F\xBFb\xE93\xB3\x06@]\x06\xA4\xF1O\xB0\xA6\x16\xBDL\xFD\x9A|\xB2I\xC9RL\x8A\x92\x0F\x19\xFB,\x99\xEF\x80 \xA5\xF8\xAF\xB3\xE5\xFFK\x03\x9E\xC1\xDFT\xAE\x0E=\xAFc\xC5u\x1D\xBE\xBD\xBA\x83{\x14\xF8\x05\xC0\xAF\xAD\xB7]7\xFE\xCCk\x97@\x9D\xE2\x8E\x86]\xD7\xF7\xF3\x15\xBF\xDB\xF5\xD7\xE8\xAE\x9Ey\xCD\xDC\xF7Z\x1B\x89\xE0\xBAK\x85\xBD\xB8\xE6\xBF\xE7\xE0\xE7\xE7\x9B0\xCF\xDC\xF7Xh\x9F\x01?C\xA7p\xF8\xAF\x1B\xFC\x17\r~\xA1\xC0\xCF\xEA\x92Pg\xEE\xB9\x8FJ`\xF7\n4\x14\xFA\xE5c&\xD4\r\x93\x06\xD1o\x1D\xC6\xFF\xBC\xE4\xBF\x1B`y\xE0\xED\xB9\xC0\xCCi\xB0\xD7\x80\xE2TrlB\x81@a'>v\xF7B\x1C\x18|]\xFB\xCE^\x1FH\xEDP[\xC8\xC6\x93'4\x00?v\xBC\x97\xBB\xC2\x04\xFFr\xE6Z\xF6\x8C\x83\x1D4^Aq\xB2sk\x14\xEB\xBA\xDA\xEBi\xB8\x06\x00\xB4G\xEA\x84\xE0\xDB&\x88\xA8\xC08\xFCg\x15\xAAXvN>\f\x00\x8F\x18\xA5\xF8\xCFd\x00\xC6r0l\xEB\x9Fl&\xFA4H\xC9L\x89\xFE\xD9\x9A\xE8\xCA$B\xF8k\x1A\xDC\"\xA5\t\xFE\xC7X\x9Cj\x1D]e\x10\xA4\xE6t\xF4\xF3i\xE2_*\x99<\xFE\x9F\xEAF;\x1F\x89\xA6@\xEA\xD9\xFE\xEA\x04\x8F\x7F\xAC\x85\xE2D\xD5\xE8\n\v%-\r\fk\xB0\xDD\xC2\xFF\xA40f\xC0N\x05|jCcS\x01$\x850\b\x1F\n =\xD3\xFA\xB2\x19\t\x14@@\xDF\xC5\xCE\xC3{6\x1B,\xAD\xA7\x94D\xA8\xF6e@0\xADo|\x94\xC5\xD9\xEEmI\f\x8D$\b\xA11\xA4\xC3\x10~\x90\x87G\x12\x10L\xBC\x13\xFDO\xB0\x124K\xE5\x9F\xC1\xDF\xBBC\xA4A&\x7F,\xFC,'\xFF\xA1\x16\x11\xA4\xD8\x83n\xFD\x13\x1A\xCDv\x8D$Va\xF9\x9B[\xA44\xD1\xFF:\x00\x89\xCB\xB1-\x07[\xA3&HO\x8F\x8D\xC4\xD2:\xF6\xAF\x964\xFE\xF4\x11\\\xF9\xB1_&\x01\x9D>\xCE\xE9\xFF\xC1\xAD\xE8-\xEC\x18c\x1D\nH\x07\xF1)\xAB\xB7qA\xC8\xB7&\xCC\x11\x80\xAC\x01k\xA7\x92''\x15\xA4\xFF\xF1\xF3N`=\x13\xEFo_\xDA;\x00r;T\x17\xB2+\x93C\x1A[x\"w\xA1G\x93M\xF0e\xAC,\xEA&\xC3\xFF\xD6\x05\xD3\xD4h\xAC>Gf\xFA\x7F\xB1\xA6\x82\xA0Z\xAB\xD8\xDE\x06\xFEI\xFBA\x0E\xFF\x06\x8C\x94\x95?Q\x8F\x99m8@\xBA\x9D\xB1Z\xFA\xD1\x83G\x90\x88\x1E\x00\xB7\xFCG\xA2;\xB6`d\x8EM\x0E\xEE\x9C\x1C'oVg\xBC\xA2\xAE\xC1\xD6\xE8 H\x97\xA5[b\x8F\x11\xFF\xF6Z\x07\xFE\x11z\r\xD8\xD2\x17\x03\xD4\x8F\xA4\x19\xAAM\xDC\xFF\xF6\x80\x04\x1C\xFE\xF1\xDB\xA9}h\x87b\xCB?\x9BE\xF8\xDF\xAEA\\m\xA8\n+ P\xFC/}\x19\t\xB3\xEB\xAEv\x9F\xDF$2\xCF\xC6\xDB\x91\xFE!\xF9 \xA4.\n\xAD@\xC4\xCA\xCA\xDA\xC0\xE2\xFC\x0F\x8D\x99k\xF7\x91\x9BT\x15\x8D\xDA?\xBF\xBF\xB9\x00\xD5\x85\xFF\v\xFCs\xF2\x07&\xFF\xFB\x06H\x17Y\x82\xFF\x83\x19\x80\x7FSy\xFD\x93\x1Eji\x87\xDA\x98;Y\xB3dn\x99\xD706\xB9\x04\xF5\xB9}\b\xFF$]2\x82\xA8Jq\x8B\x85\xB9;;\xF2\xF5-\x14\xC6\x9C\xC3\xB6\x94\xFE7\xEC\xBE\x9E\xDE\x8B^\xEEpt\x9CI\xB5\x07\xEA\xBA\x86\xD1\x87c\xDA\xF8\xAF\xC5\xF8\x94&G\r^\xFFP\xFC\x9F\xD7\xFF\xC4\xEC\x15H>D\xFEa?\xD2\xFF\xD7\xBD\x94,\x1E\n\xA1>W\x1E\x1F=\x92|\x90\xA5\x99\x00\x19\xF7\xBF\xA8k\x1E\xB7\x02\xC8X\xD3\x9D\xBD\x8D@3\xADb\xFB\x93\rQ\xE2P\x13y\x07\xF8\xA7\x9FR\xBD-\xFF\xBD\n\xE4\xB0\x0E\xD8=\x8C\xE4\xBF\x87\x17i=\x96\x7F\x9Do7\xC0\x80\x06{\xEC\xFE\xF7\xD1\x83\x17\xB6C]\xF2\xA0\xCB#\xBD.\xB4+\xD5\xFC\xB3:t\x91]\xF7\x85~\xB1\x82\xE6\xA8\xDD\xAD\xC0\xB3d\x03\xE0gu\x17A]\xFB\xBE\xED1\xD6\xFFr\x19\x01\xEA\xB2\x0F\xE6\xE0\x17*\xFC\xEE\xB1\x18\xD4\x85\xF6\xBDF\xF1\xFF\xAB/\x99 v\xED{-\x04u\xA1\x9F\xE1=?\xB7m\x83\xEF\xEEU`7\xBB\xB1\\\xDD\xAA}\x06<\xAB\xC1\xD9\xC2'\x17\xF6(P%\x12se\xE9/\x10\x98\x87\xD6\xB5\xCF\xF3\x17P\x9F+\xA6\xB3\x1D\xEDH\xFF\x040\xFE\x83\xB8\xFF\xAD\x12A\xCE\xDC\xC6\x9AJ3\xFCo]0\xBD6\xF7\x15<\xB4\x13S:\xB5\x7F\xF0\x9A\x91\xD7\xDE\x01\xFE\xE9d\xB4h\xCB\x7FP\x81\xBB\xF1ESX\xFE\x1Ao\xD2\x92\x10\x8E\xA2\xAF\x17\xD7IY\x87D\xAD\xB7\xC5\x041\xD6\xEB\xB2\x7F\xC5Po{\xFC.\xF1\x1C\x04\x9B\x11scs\x9A\xA4\xC8\xEFU\xE0\xBB\xF8M\xA5\x14\xB8K\xEC\x02\xF1\x12\xAD9v\x17\xC0=\x1A@\x90\xE3\xD8\xC5\xFC]\x00)\r\xB4\xE1$\x88\xA1T\vm\xFD\xDE\xE18\x88\x83}\xC3C \x0E\x91\xB5\xB4\xA8Y\x11c/\xA8\x0E\x81\xBDN\xF6\x81\xE5q\r\xE7\x84\x8A\xF4\r\x8D\xC4\x14\x80cd\x00\x1E\x0E\"af6\xB4\x7FtC\b\xC4= N\xEC\x88\xB5?\xA5\x01H{\x88\xFE\x8F\xAA8\x8E\x9D/c\xF5q;\x961\xFD\x93\x16A]\x817\x8F\x85X\x84C1\x1E\xC7\t\xFAc\xEF\x10\xFF\x9C\xFC\xBFc\xC0}\x18\xF3\xDF\x7F\x15i\xB9\xBB\x1C\x11D\xB1\xDE\x13?\xB4\x1E\xD7I\xE5\xEC\xFD\xEB\x0F\x8B ^\xB9\xDE\x9DJ\xCC\xDC\xD4\xD2\xD3\x7F\x18\xC9h\xD3\xE1\xD0\xDD\xE2x\x0F>e\xBD\x01w\xE3\x9A\xFD\x06\xF4\x1F\x19\x84\xE0\xD3\xDA\x9E\xE4f\x036u\x03\x88+\xB8\xD3\xEF\xD9l\xC0\xC3\xDDp\xB7\x18\x03\xD1\xEC\x9F\xA4\xF6\xE7\x86\x96\x1E\xA8\xFD\xF0\xE6#K \xB8\x84\xACA~D\x07\bb\xC3Uj{\xC4\x00k\xCE1\x9D\xBD\xF4\x81n\xE83\xE0W\xFF}\xC9?-0A\xAE'\xF2_z\x005\xB5\xF4\xA5\xE4\xEE/\x9A8\xA7X\xCD\xBE\xD7\x92\xCFX\xFAG|\x11{\xFB\xD4C\xD0\xD6?\xEB\x0F3\xFD\xD3\xFD\x95\xB59\xFCV\x02\xF5\x9F\x05X\x8B7\x83\xEB\v8[_\xB2\xC2hUJ\xA5TJ\xA5T\xCA\x7FF\xD1\xBC;\xF4*\xC6\xF5+\x84\x81'9\f)#\x1F*\xD3\xC8EUN^\x9C\v%$zLFh\xF6\xAF\xCF\xDD\x14o\x07D\x04u.\xD3\x03\x1F\xE5j8\xC3\xB4\x96\x8F\xAB\xA7\x9Fe1\x9F\x02\x8B\xC4\xC0\xBC\xF8()\x9DCv)\xE5\xA8\x03\x05\x9E\xA3&{h\x9D\x1Cw\x16\xD9i\xD8{\xEC\xA3\x84\xF4\x0E\x14\xEC\xC6s0\xAD\x01\x1B\f\x82E\xC9\x02\xE0\x18\xF2\xC2e$\x16t\x10 \x02J\xD1\x80<v\xA7,\x1E\xC0C\x1E\xC24\xE2\xDFN\r\xC0\x7F)\xF8CW\x03P\xBE\xD1\x8F\x84\xD0\xE9K]g\xFD\xE9\x0F\x81\xFC\xD4\xD5\xDC\x95H*\xDBU\xF8\xB7\v\xD5Y\x03\x00\x9F\xD0\xE0\xBA\x1C\x80_\xA1\xED\xA3\xFD\x91NO\xF9\xFB\x91\xBD\xFA\t\x03:\xE7\x94\x7F\xF9tT\x0E\xF9\xB3x\xBF\xF8\xA2\xBE\xA3\x8C\x94&d5y\xD3*\xCFQ\x93=\xAC\x0E\x0F\b\x15\x9C{\xB8m\x95\x9709\xB4\xC0\x00\x9F\xC0\x85\xE1\f\x14\xC8\x80\xA2\x83\xC5L>\xA5\xC2\x8C\x01K\x9F1}\x00W\x18\x10S\xD0\xF8\x1D\xE4\x1E\x90\xF18\v\xFF\xE6\xD1\xC0\xBF\x0F\xE4\x01\xF4\x8Eh\xD4e\x13\xFB\x81\x9B3t\xDEg\x1C\xED\x11\"3\xDC\"z\xB2v\x95\x04\x91.\xB2\f\xAD\x05\rG\xA5F\xF5Y\b\x1Dg\xD4Mn.i\x9C\xD4/\x1A\xE0\x1879W\xEC\xBEY\x8E\xD1g\x8E\xBE\xC5C\x05\x90\xC7g\xE8m\x13~ [dQ\xAF\x8BS\x8C\xA3&\xAC5\xE3\xA8-o^>F7\xBF\xD3\xDAcos\xA4\xB7u\xA8\xA0Cqj\xA8\x14\xFF\xAF3 -T\x10\xFE\xE3\xFE\x90\x88\x13+_a\xC0O\x11\xFE\x1B\xD0?\x04\xC2\x06\x86\x7F\t\xFC\xC9\xAB\x01:\xC9\x83\xF8\x13\b\xD5\x91,\x05<\xC2\x7F\f\xAA\x9F\xE0\xF1\x9F\xC0\xEF\xA2\x13\xFFv)\x80>\x10\x80.\x9D\xE0?v\x06\xF8\xF7q\xF8\xE7Ho\xC1\x91\xA6\xB3l~=\x86\x7F\xA9*\x04\xFE\xD8\xD5\xF4\xB6\t\xFE_\xA3\xA4\xB4\x02[\xA3\x9DC:\x99\x1E\xEA\xDC\x1AM\x80\x84ij:aD7\xB6\xB2KX;\x87\xD8\xF81\xA3sG\t\xE9-u\x92\xA3\x19\x9C@a\xD4\xC0\x04\xA6U\xAA\xA7\xC9\x84B\x13[\xAD0\rH\xFE\xC5C\x18\x068=h\xE6\xAEc\x10\x90 \x80[\xC3\xBF_\xD7\x01\x02\x97B\xA0\xF3V\x00\x92Y\x98\xF0\x00wl\xCB\xDEA\xFF\x14Q\xCD\xBA+o\xE5\x9E\xFF\x1F\xF0\x85n\xC77s\xA7N\xE3\xCF\xDF\xAE\xC3\xED*@\xE0N\b\xB0\x10\n\x81s\xEE\xF0\xC4\x7F\xE03\xE4\xD2w\xB8\x1C\xCB\x9Ds(\xD3\xE5\xF5?q\x98{\x13\xC1)\xC6`C\xD9\xE0\xF9\xF8\xDE\x86t\xF0\x05\x13\x97\x13y\x06\x13\xF35\x1DDLS\xB3=dc>\xEBC\xD1\x06\xDEi\xB1H\x9D\xDC\xBB\x98\xDF\x8F\xB9\x91\xAA\xF6\xE7X\xD7p\xD2\x80\xC7t\x98\xDF\x97-\xC5\xFF\x16\x16Sh\x81\x01\xDF0@Y\xD7E\x1C_G\r\xF8\xA9\xAA\xA2\xA1\xBA\x80\x83\xC0\xE1\xDFp\x0E'\"\x14:\x9B\f\x16\xB0\x9D\xC6\xDB\x8F.\xB4\xFE\x14BP\x15\xE2\xB51\x19\x99\xB6\xE0\xDB\v\xEB\x00B'I+\xD0\x84Z\x13\xAC\xF0\xE6 D\"\x9E\xF2\xC3js\x81A\xCE\xE5t\xBEs\x91\xC5\xC6r\xE2\x0F<\xF5M\xFC\xE9]\xD3a\x82\xBC\xA3\x90\xE3\xDE]\xFD\x8B\x94e\xD2`\xEA\x90\xB9\xD4\xC0}\xA8\xA0\xAC\xDD7\x8Es;jt\xDA\x11\xDB!\x11.\x00>&\xFD\xC6q\xD8~{\xCF\x1B\x96\xFE9B\xB8A\xB3\x89\xE5s\xF7\xA9P\x8D\x1AWx\xF0\x14-B\x12\xDF\xCC\xB4\x8E\xF1\xFF\xF2\x9FnV`R\x87I\x05\x166\x15\xB0\xFE\xFF\xAES\xFF\xA7A\xDE?c\x05L\x96w\xE1\xF0AY\x9A\v\x00\xE7\xFC\x05\xD9\xE4\xD1Hj\x16\xACmy\x88\xA4\x158\x018\x93/\v(\x04\xF2.\xEF\x94\xBE\xF2\xC3\x000\xA3b\x05[=\xED\xEA\x17\xAC\xF2V\xF7i\xF0\xFF\x80\xC2\xAF^\xC0\xFA_\xA0iZ\xBAs\xD0\xE8cQ\xDA\x02\x85\xB3@\x87\xE0e\x10\xB8\x8C\x8A\x9A\xF4q\x86\x9D$\xE5.d,\xDED\xC3\xC4\xE1\xD2\xA5\xC2\xC3l\xBB\xB3\x15\xE3\xC8\xDF\xF5<\x86\xDC\xDF\xE6\xE0d\x0E\xE9\xFFD\xC7\xC3\x1C\xA8\xDA\t\x1F\x95Q\x00\xC4>\xC2\xF0\x04\x01$\xDF\xAA\x8D\n\x8Cb\xFC\x17\x0F\xC6A\xCA\xB0\xE9*\xF4\x16\xB2\x1A\x80\xB4\x03\xA4\xD5#VL\x15\xAC\x06G\xB3\xE6\xA34@J\n\x9DR\x15\xE2#\xDE\x8C2*\x9B\xCD\xBF\xE0\xD9\x8A\x1C\xD9\xEE\x016Y\x03\xD2S\xDF\xF3\xD4\xE1x\xBEf;\x9D\xEC\xE0z\b1\xC5\xD7\x8A(\xA7\x91\xFF7\xFFe\x1A\xE4\x1E\xB6L&\xC9\x9B\x88;u\xE88d\xDE@\xFA\xD0:\xB5x\xE8)\xF0)\xE0\xF3\x91l\xE0d\xDE!\xCC\x05\xA9\xDE\xDB\r o\x02\x80\xAB\xD9EO\xA9\xF0:\xD3N\xB3\x87I\x8C\xB8\xEB?\x8Ae\xB2ZG\xF8\xAF\xC9A\xD1\xB8\x89\x97?\xD1\xFF\xDB,\xFD\xAF\xC3\f\xC07\x9Fy\x11\xE1\xBF\x1B\x8E\xA8\x90\xB8\xAA\x80\xB0*\x93t\x15\x8F2\xFCgA~z\xD6JX#?\x8F3k\xA7\n\xDD\x96\xFD\x93\x81\xEA\xE9\x99R\xFC\xE3_\x9C\xAF\xD3$7\x8C\xBF\x85\x1D \xB3\x04\xC7\xB2v\xB2\xBC\xFD\x93\xF7\xB0\x7F\x9C9n\xBAO\xA3\x7F$A\x04\xF1\xBBt\x95\r\x99\x1F\xA9\n\x91<S\x8A\x06\x07\xFC\x91\xB3\x14\x9C\xDC?P\bi:T\x99\xE4Z\xB7\xE5\xE8\x85\xBEj\xD8\x19\xFF\xD1[\xAB\xFE:\xAF\x7F6\xA8p!\xBB\x81l+\xFE\xAA|\xBE\x7F\xC7G?A\x92\x95\xE8\x10\xE9\x1F\xE2\xFB_\x82\x7F\x04\x1B\f\xA4{\r\b\x1A \x89\b\xFFdfg%\xD2\xFF\"\xCD<\x8B\x7F\xB1\x06\x96@\x88-T\xD9xG\xA8\xC3\x99\xE5E\n?\x9Cs\x16\x84\xF6F\xCD\xAD\xFF\x892<\x0F\xB5p\x11\x89\xAC\xD5B\x02\xE6\v,\xFF\xAF\x90\\\xE8\x89a\xBC\xE2 L\x82\xEA\xF8x\xFB\xDF\x11\xFB.sF\xF8\x9F`j\x93\xAAh\"\xFF\xA5\x1A4\x06\xCF\xB9Z\x81\xA8\x86.q\xAE\xDC\x06~\x01\xAA\xC24\x89\x00\xD6\xFFY\xC5\xCE?\x1BW\x01\xE6E\xE8\xE8\t\x97\x19\r\xD2\xAAS\xFF\xA3\xF7\x88\xA7\t\x00\x1ER\xE0J\x80k\xE2\x9B\xF8\xC1\v\xC1\xFFIf\x90Okp\x16\xC0\x1B\xAF>\x8C\xE4\xAF@V\x85\x04\xEA\xB0\x86@\xC6&\x1F\xFEE\x96<\xB2\xFFw\xCD(\xCC\xDE \xFDB\xEBP\xC1\xD6\xFF\x9B@6g89\x99\x1C\xFE1\xE6\xBB\xC8\xCE\"\xC5\xFF\x90\xA5\xFF\xCB\xD8\xFF\xDFG\x1F\x0E@!7\x97\xFDS8\x9D\xFC1\xFE{\x19\xFE#D\b\xC46V4\xF8\xFD\xABOo$!\xFD\x03f\xF7\xCF\x14\b\x9AP\xDFF\xFB\xDF\xFAz\x82\xA2{\xBAy\xFC\xAF\x00\x80\xCD\xEC\x86\xEF\xEF\xB6cE\x86\t\xFE\xEB|73\xFB\xFFd7\x1A[\x15\xA7>\xCF\xC9\xFF\x1C\x82\x7F\x1F\xC2?z/\x1B4\xF8;\x80\x06@c\xAB\x19\x03\n\xDD\xB06\xA7\x82p#]p\x81\x7F\xC3\x066\x84\x84+\x1B\xAD\xF1\xA6p#N7sc\xA4\xDB\xB2\x7F>\x0F\xA0\xF2\x11\xE7\xC2\xDD6\xFE\x15d`\f\x92\xEF\x0Eo\xD7\x800q:\xFC\xAFD\xF5\rX\xA4\xBC\xA3\xF1\xAF5\x0Ezi\x1A\xE4MLm\xEE\x02p\xF6\xE6\x95R)\x95R)\x95R)B\x99m\xAFe\x00J\x99\x16\xCA\x9A\x03U\\\xEE\xBFrW\xE1+\x93\x9A8\x13\xC0\xAA?\x9CH\x9A\xDF\xC9Id\xFEB\x11\xBC\x1F\x11\xEDo\xEC0e\xC3\x84*\xF3*\x03Z\rd\xCF\xDF\x81'\xF7O\x1A\xE6\xCD\x13\xD8\x8C\x14\xDAn6\xB8\xD4{>\xD3\x95\xD9\xA7i*i\xE5\xBA\xED7\x00j\xCC\xE2Km $\xC9~\xABX\xE1\x11f\x0F\xB4\xCDN$\xD9\xB94\xA8\xC8\x05x\xCF\x93\xCE\b$X\xFEm\xE4\xCF''\xDA@6\xAF3\xDEM\x91\xAE\xCD\xB1\x07\xF1\x99\x16\v}\xCA\xF06`\x9A\x0EM\xCE\xD5V\xE0x\x11\x99\x7F\x06\xC0E_\xB5\xA8\xEF@\b\x02u\x10Pn\v\xA0\xA7\xB8\r\x80g\x05o>\xA4\xDC\x86\x9E]}]\fA}\xE8jl\xCC\x1F\x07d\x84\x83\x10:K\x0E\x9DU\x9D\"\x16\xF5F\x00\xD1\x8E?\x19reI\x9B\xD6\x90\x19fj\x8CL\x0E\x86\xAE\xAE\tAmj\xBA\xC71{E\x93\x97I\xA9T\xFF\x9E\xE1~:r\x9FN\xA1\x8D\x01\r.\xC2{\xEC\x1C\xA0hD\x86\xAD;\"\x161\xB5E\xDE\x03\xBE\xD4\xCC\xBB\niUe_\xB3\xAF\x87\xC6\xD5we\xAA\xA573\xD4\xAC@a\xE1\xDC!e\xE6\x8Ft\xE3\x81\x92\xD8\xDEg;;\x99 \x1E\x03q\xFC\xDE\xC3:\x19`n\xE0N\x18h\x1E\xBF\xD7\x80\xAB\xAF\x98\xEE8\x9C\x04\x1F\x82\xD6z\x03\xAE\xCA\xC1u\x98\xF0\xD9f$\x1F<J|8\xC7\x03\x06|\xC2\xC6\x7F\xD2\xE2RJ\xF1\xBF\xDE\x00\xA8On\x9B\x1A\x07\xA9m\xC1\x94\xE9\x81\x7Fi|vr|\x96y\xC8\x7F\x9C\xE1\x7F\xE1D\x9B\xE3\xB3\xB2\xF0/\xD1x&hL\x17\x18\xDF\xF6n\xE3?`\xB1\x91,\xC9Wy\xFC\xCF\xA9\x81\xAA>\xD9\xA4\xE2\x11\xB1\xFFG\x96#.\xC2*\xFA\xB7*\x9FV\xC8\xE0\x9DO\xB2\xA9\x84c\x11\rf'\xC4\xF6\xD6\x18\xF8z\xBA\x144\x14\x8A\xAB\xB0\x02\xD5\x89\xC5\x95Xo\x98\xCC\xD1\x84O(\xB0\xC4:\xD1\x17#y\xFD\xAC\xF2XK\xCC\x9A}8\x81\xCF\xED\n\x87AN\xE7\xC3\x0E\x17/J\x97\xC9\xE9\xBEhZ\x88R\xE66\xD1L\x83\xEA\xFC\xB45\xED\xA0\xB0p\x04\x1EL\"\xD1\xD8;\x91\xD64\xF8\xD2\x85w5yY\xDC\xC2\xBF\x90\x06\xE93\xF6\xD4\x86\x9B\x7F\xCBf\x15\xB8f\xE1G\xE7j\xAB\xBE\xEBT7f\x87|\x90\xB7\x87h\r\xB8\vX%\x8C\x8D\x93\xC1;\x9F\xE4\xEE\xE4\xD8\x8Ei\rj\xEE\xB6\xF1\xDF\x84\xF1\x8F0\x1CH\x9E\x9CJ\x9E\x9C$\x1C\x05\xC2\xFF>g\x06d\xDE{\xFCI\xCC6\x90\\\xCF\x01\x9C\xC7\xE1\xBACm \xB4\x8D\x1Er\xE8\xFFQ\v\xFF/\xB7Y!\xA4\x8A\f\xFF#\xD8g\xEC\x8ER\xFC\x8BT\xFFO\x1Dy\xF7\xF5\xFF\r*\x9B\xB3\x96\xF2 S\xAD\xED\x91\xD3V6\x8B:\xF4\x1F\x9A\xF3\xDAB\xE7\xE7h(\x835\xB6\xFE\x91;1\xFE\xC7\xF38*B\x9F\x8ET\x10\xA7\x7F\xFA\xEE5\xE0\x9B\xBB\xC4\xF6f\x8A\xFF\xB8\x02\x07U\xCC#\xF9c]\vc]Q\xE2\xC3\x99>\xA1\xF0\x1F\x0E\xDA\xC9\xAF\xDE\x8A`\xFC\xFF\xC4\xC2\x7FU\xCC\x17M\x83\x94\xCEF\x1D\vb\xE8\xAB\x97\xD2B8-\xB4P\xD7\xCD\xC1\x85a\x82\xFF\x7F\xC6\xF8\x7F\xCC\x8E\x1A\x1D\xA6\xEE\x9D2&\x07\xFC\xE1%\x1D\x13 \xBD\xCB\xF8\xBFFeie\xA4\xAC\x85\x7F\x0F\x15'i\x92\x0E\xD7,\xBC}N\xF9\xC7\xC7r\x98O\x10\xE26\xFE\x83\x9D\x104A\x1CL\xF5g\t\xC1\xC5\xD3\r'\xC7\xFA\xF2:t\xDE\xED\xD6\xFFMxq\xD3u/'\xAF#\n\\\x1A\xBF\xCE\xE0\xB3s&]9^\x8BX\xFF\x7F\xC7\xC2\xBF\x90,\x1Am %-#\x87'!A\x1E\x9F=\x98\x9C=J\xF5\xFFK\xB8#\xB0\xF0\xDFT\x8A\x7F\x1F\xED\x05vG\xD1\x9EwW\xFF_\xA3\xA2O\x80\xC9\x9F.\b\xCAx\xF0\xFFf^\x87k\x9A\xE6\\\xB1%O\xBF\xD9M\xD8W\x1E\xFFI\x8C\xFF\xC1\xE9\x14\x92\x7FJ\x03~\xC2`hxG\x9F\x0EwL\x88\xED-\x0E\xFD\x1F\xC7\xF8\xBFial\x88\xEA\xFFt\x97\xC2).<q\xCFs\xAD\x91H\xCC\xCAp\x8A\xF0)\xC7\"\v\xC3P\x13\x0E79\xF4\xBFIO\t7v\xA4c-T\xFF\x7F\xF7\x824\xF1\xA3&\xF8\xB7\xE1\xEDg\xF8\x0F\x10\xF2?\xBD\xB4/\xFD\xAE\xE3\xFF\x06\x15\xBD\x02\xA6\x7F\xF6[\x13\x19%\xB2\xD5d\x1D\x8A/\xCF\xA9\xFF\x85\xAE\xAD*@u\x1E|\x1C\xFE\xC5\x10\xFE\xD7p\x17^\x113\xA3:2h\x9F\x18\xCB\xE4u\xF8\xC4\x15\xD3\x1D\x87\x92PO\xF5\xFF\xCD\xC4\xFE\xF1\x9BW\x1D1\x1F$\x00\x0E\"\xFB\xDF\xC6\x7F\xB0\xC4\xFEy\x19\xEDi\xB18\xF6`\xB2\t\xA1z\xFC\xAB/{\xE1_\x18\xDF\x11\x19w\xE1\xFFo\f\x181\xDA\x1C\xF8\x0F\xB49\xF0\x0Fm\xCD\xEB\xCDw\x1D\xFFq\x05nP\xCE\xA4\xFFM\xE6\x15\xB8\xC6\x9F\x9D[\xFF\xA3\xFEW\x88\x80\xEF\xCEA\x1B\xFF\x03 7\x83\x9C\x9EID\x00`\xA3\x8A\x90f\x95mYeP\x87[{\xC4\xDDj\x04 \xDE\xA3BL\x85]\x1A\xA0\xD3\xC5H\xAC=B\xD7\xD1TGb*\xD86\x15&\xAE\x8Fs \xE9\xC4\xEE\xEEd\">\xAD\xA2\nK\x96\x0FA\xF5\xFC\x91\xE5\x8E\xD9\xEC/R\xA4\xCD7|\x99\r\x97S\xCA\xFD\xCF\x97\xD1\x1B3\x7F\x8E6l\xF7\x0Fi\x882\xE4\xBE!2\x95Y|9\x0E\xD2PZ}7\xE5\xDF\xAB\xA3\x7FXPQ\x10\xA8\xF7@\xD4C\xB6C\x9D:\x8C,\xD2\xE7j\xCB\xD7>\xA2b\x92\\\xEC\xE2\xEC\xFF\x06\x10\xE3 \x86{Z$\x1A;\x91\x93\xFF@K8e\xC0\xB5_\xAA9G\xD9\x05U=\xF7)p\x9F\x02u\xDD\xF0\x9A\x02 \xEE\xFA\x95\xB2\xEBK\x8D\xB8\x03\xAD\xDB\xB5B\xE14\x03&\xAE\xEB\xB8v\xEEk\xDDe\r[P\x07*\xEF\xFAUK\x18\xEAn<\xAF\xC5\xD1\xFF>JcI\xDD\xB8\xF9\xD0\xAE\xBF\xBC\x90,\xAE\x85W\xF0\xB9\x7F\xA9\xC0\xB2f\xB4q\x9F\xD5lM\x982\xE4\xA4\xFF\x95\xD2>y\x02\x84\x89wW\xFF\xEC\xD4\x81\x86\x00\xAA\xBA\x93L\xB2#-\xE1a\xFF?\xFE\xA4\x0E\xA3\x87\xDB\xE6\x94\xFF\x953\xDD8\x1B\x82x\xF4\x845\x11)?\x8C\xFD\x07\xEE+\\\xF881N\xF8\xF9\xCD\xC3_\x1E?\xA1U\xA8\xAEJ\xA9\x94J\xA9\x94\xFF\xCA%\xC4\xEC\x97P\x88\xF5\b\xB8\x0F\x17\x9D\x11r\"\x02\xF5\x81\xA7\xCE\xF3U\xDE\x13\x02.\xF6\xDB\xD1\x02\x17{\x87\x04\xCC\xF9\xD0{\xFDl\x8A\x16\x07\xCD\xFB\xDEBs\xDF\xB0V:\v\xC1\xED\x110\x9F/XGE\xEBt\x9F\xDBH\x13qS\x9EA\x81\x14FSG\xC8\xC6Y\x8C\x84\xF9\xA6\x01w\xBC2y+>\xFEUr'\x81\xC8m\n\xDCv\x15\xA6\xB2\xB1\xD9@\xD8\xEC\xAF\x19p*\xE7I\x89+\x7F\x8F\x9B\xBA#\x07\x10XCZ\x80@\xE8\xCB\x07\x9B\xD1\xB9\x81\xAE[\x01|\x81\x01\xF0\xBD\xB7\t|C\xBD\xED\xFA6\xEC4U\xCD\x9B4\x03h\xE4N\x96'\xEC\x1B?\xD7 \\\xE5\x00s\xCEy\x91\xD0\x05d\xE8\x87\x8C\"\x1C\x1Dz\x9A{\xCC\xE9\x9E\xB6<\x92\xFF\x87\xF1\xD1\b\xF6{\x19 \x1E)y\x97\xFC\xE5\x14jJ\x1E\xB0r\x92\xE2l\x8F\x84\xD7\x8D0\x9A\x1A\x8F\x8CE\xBDhP\x97BU\x81\xDE`\x82\xAC\x99\xA5kuE\xB3\xDF\x80\xDE\x14\x1A\xD5\xF6\xB1\xC5\xA1\xC4\xF2Lx\x9A\x85b2\x85\xAF\xB8\xCEZr\x8B.d\xF6=j\xE2\xEC\xB1\xDF\xED7\xA0x\xD0tgp{\xB7K\x95\xCF\x1C3\xF0\x03\xD4p\xEE\"\x02BQ\x03\xDE\x1D\x97\xB0?\x8A\x14\x02\xE9\xDA4\x8D\xA1\xDA@\"\x1E\x90\x01\v\x00l\x91\xC2i\x80G\xB8fuy\xD7#\xE8\xAD\xA1Qs:\x1A\x01)\x89\xFFe\xED\x13\xB9\xE1\x1B\x1A6J\x1FN3\xF9\xEB*\v\x10M\x92\xC7\xC9\xD6j\xFA\xA4\x0F\xE8P\xEB\x1B*\xCC\xC4\xDAI\xFE/\x9A|V\x8E\x1CWaj\xAA\x17p\x86Y\x8B..*ln\xC5m6wN\xE2+\xBE\x85^\xF7\x1A\xFA\xBA\xE5\xC1\xA3G\xD0\x97\xF8\xBA\xDC\xF5:@\xB8\x7F\x10|\xAF\xBD\xA7\xF2/\x1E\f\x1D\xEB'\xEB\x118\xD7}<\xAC .\x8Bk\xFB{n\xC8\x11\xAE\xE6z\x96el?\x97\xF16\x859\xAEt^\x07>\xA6\xED\xEC\xC1\xA1\x13\nu\xA5\xCE\xB7\xC6AN\x80\x1C#\xAE\xBCn'Fy\xE0\x18\xFE\x8El\xFC[\t\x02\xA8\x07W\x04dB;\xC5\xD6\xE6\xA8\x1B\xD5/4\b\xB6\x9A\x01\x8BU\xC3\x9Fr\x95\x0E\x82\x8AWW\xA9\xF6\x94\x8A\xDF\x80\xB3\xBC\x87E\xC9Z\xC5\xD2\x87q\xC6\xDD\x99b\xFF\x1A\xEC\xB8\x98\x95\r\xB8\xEE\xE0\xF0{\x8D\x7FQN\xAA[\xF0\xBC\xB1\x10r\xE1\xFF\x1A\x8D\xE0?\xDC@\xF1\x7F\x1B\x8F\xFF\xB4\xE2\xC4\xBF\xEE\b0\xA5\xDF}NF\xA1K\t\x1E\x99\xFC\fH\t\x90b\xE4Y\xDC\x83t)\x8C\xF6H]^\xF8o\xA6\x94\x9A\x98!\x1Bg1\x97\xE6\xB6n8\x16l\x7FSa\xB3\x8A\xF8e\xBD\xD5\r\xC7;>o\x91\xC9\xA4\xE6\xCB\nL\xE5\xBC\xF1\x7F\xAA\xDBRw\x04\x81\t\x90C\x04\xFF\xD3\x17\x9A\x07U\x88\xDEkB\xFD\x8B\xEF\xA9\xFC\x97\xAE\x8B\x9DL\xE3\xB9\xC5\x00\x97X\xBE\x06\xC92I\xF1\x9F>7G\xF4\xFF~\x86\xFF\x17m\xC2\x9C\xE9\xFF\xBC\x93=\x9B\xBE\xEF\xD17t\x00\t\x89`Z\xDE\x8D\x1FM!\xF8?\xEE\xD6\xFF\xF8K\x91S\xCE\xD5Ci\xCA{\x00^vB\xF0\x1F\xBCs\xA9F\xBB\x0FE\x83\x8Dr\x82\xCC\xB3\xD0\x95\x05\xE2\xC0\x90\x06\xDFY\x8E\xF4?\xE1Q\xC9\x972\xA6p\xF3\xB6|\tv\x92(`\x03$o8\xE0%\x1BA3\xDD\x81\xDE\xC5\x83{C\xDB\r\xF8_\x13\xA2;\x83\xF3\xBBn\xFF\xACK>\xB0\x02\x7F}\xD2\x13\xBCN\xB6\x96\x12q\xF8\xEF\xF4\xC2?\xE6\xB5\xFA\x9A\xD3\xAA\x03\xD8\xFA\xFA\x02\xAA\x8C\x93A\xE8R\x17V\xFE\xE7\x95\xC1\xBF\xA8\xE3\xEF\xC8\xC2\xFF\xB0\x02 a6Cz\x9A\xAAe\x91\xE2\xD30\xE0^,\xD5b\x0E\x8AGV\x13\xFC3M\xF8p\xD1\x00s*f\xADh\xEB\xC3\xBB\x8F\x18\xF6\xCAG\xE7{O\x9E4\x80_,\x86ul|\xEAH\x17\x00\x9CX\x89\xF0\x7F\xE1;\x8A\x04\xF8\xB6\xF1\x7F\x05\xC9\x19\xFD\x02wo\xBA\xF5\\k\xA7\x86\xB0\xFD3\x00\xF2\xB5\xBC\xFE\xA7\x1E\xBC\x18\xA8\xF9\xFEa\xA4\xFFU^\xFF\xAB\xA826\xC7g\xA7V`\xFB\xE7\xC7 ?\xEBr\x0E\xC1-\f\xA2\x13y\xFD\x8F>7\fY\xF92\f\xEC\xF9\x14\xFF\"\x87\x7F\x1Dz:v\x13\v\x87\xAE\xCB\x10\xC3\xBD*\xF4\xB4\x7F\x1D\x00Hp\f\xF2=nP@\xF7\xA4\x06\xC5\xF9\x84\x94\xEB\xD3-\xFBG\x04qM\x0F\xC6\xFF\xFA=\xA9~\x03^\x9F\x94h\xF8\xF1\xF7\x10\xFF\xB1\x81\x18\xB6|D.^\r\xC6[\x84|\xB6\xCA\x90\xAA\x00\xF86A\xD5*\x89>H'\x8E\x8FB\xE7I\x00\xA0N\xCDH:Q6\xAC\x81\xF5f-\xC2?jGj\\\x81\x83\x11\xEA\x00=\x96Y\xC5\x95\fn\xCAd\x8DC\b\xFDI\xBCkv\xE3\xB7 R\xB2W\x8EEr\x90\xC6Zq\xA9\x06o%\xE2\x04\xFFo2$\x1C\xD7\xE0xG\xCC\xB2\x8D\xC9\x17:\xA3\xB0\xD0|n\xFC\x7F\x94\xE0\x1F;\x8DG8\xFC\xA3\xFE\xF7\xF8\xFD\x93\xC758\xB7z\xFA\xBD\xF6\x01^\xBA.i>\x82/\x81\xDD\xC8\xD9\xBD\xA5\xAD\xB5\xCF\xD7DS\xD7(\x00\xC1a\x98\xA7\xB2,\xC3\xFBy\x87\x19\xB4\x9D\xC8\x8C*\\\x145tT\x18f\xEB\x89\xB2\x8B\xE281\xB1\x0E\x12\x92\xFF~\xB7\xFEI\xA1\xA6\xA4\xB4\x15k\vU\xC0\xCD\xC2\xBCv\x8A\x7F\xD2\xFF\x8A\xB1\x05\x00\x0F\xE2\xBB\n\xABp\xF7\x86\xEB\t\x807\xD0P\xAF\xBE\xBB\x15\xE8mG\xF2\xBF\v_\x82\xCC&\xF4+\xDC\xEC\x80\x03\xFF\x9D\x1C\xFE/\xE1\xF0\x8F\xBE\x85\x9E\xD4}\xBD:4\xA4#\xAE|\n\xEF>\xFE7\xC0\xC60\xC1\xFF~\xEE\xDE\x1EBz\x9B\xE6\xAD\x18z\x00)\xE4\fT\xC5(\xAF\x8E\xE7bx\xFCK\xCA.\t\x9C\xF8_\xD7)\xAA\x00\xFEN\x8C\xFF8\xC6\x7F\x9A\xE0\x7F\xBE[\x1AC\xB8\xA9t\x1D\x93\xFF\x9Fh\x16\xFE\xB1X\xE4\x1BA&\x03\x81+\xA7\r8\xACR\x1A\xBC\xF0\xE5\x897\xF1\xB7\xF0\x06\xC5\xCC\xA6\x82\x01':\x92\x96m\xF0*\x86\xF7\xF1n/\xCE\x1C\xF7\x17\x9C\xFE\x7F\x9A\xE1\xFF\x9E\xD7\x9A\xD7`\x8Bz\xC9\xB4\x01\xDF\x98z\xD8\"\xDE\xDF+\xFC\xA7\xCC\xB7\x16\x10\xFC\xDF\xEF\xB2\xFF\xE9g\xFB/7j9\x80\xAA\x18\xD4\xB4}\x94\x1A\xD2\xFB\xC9\xAC\x04\x1E5#Cq\xF1\x82\xD8G\f\xB8\x98{\xCC\x8F\x1C\xB9v\xB1\x06\x10\xBC\x16m\xBF\xF4i\xA8\xBE\x12\xAA\xDB\xA0\x1A\t\xE7&\x97\xFC\xABoDMU[\x8D\xC3\x97\xBA\x01\xAA1$j*\xC9\x8B+\xA5R*\xA5R\xFE+\x93\xFFnv\xBA\n\xCE\xC8&\xF1s\xEB\xD1\xCA\xC5\xE4?\xCB\xE3\x90\x07\x13\xCE\xFB\xC6W\xE5\xA0\x8A\xBA\xDBG\xFE \x12\xA9\xE2\x9FHs\xCF\x05p\x8F \n\xCE\x98B\xEF\xC4;\x03\xFB\x93\x935\x98\x16q\xF1:\x1E\x8E\xCDN]\xC6\xEAx\xBB^\xBF\xC9\xAD\x07\x7F\x99\x9D;\xC3Ee9i \xF9\x1F\xEF0\x1D-\xC8!~\x8CL\xA8\xD1N.\xC7\xE2\f\xBA\x81(\x19\x98\x9B\x87\xDE\xC3\xD11\xB5\x7Fp \x85orC\xF8op\xBFd\x8E\xE3+.\xF9\x07B\x10HB@\xBC\xCD)\xFF+\xF6!{f\xCD\xCDOC\xE0\xBE5\xD8t\xC4\xDBO\x93_\xF4g7\xCB\xDFdeq\x92\x92\x16\xCB\x97aW\x19\xC3\x9E\xB7z\x949\xB0\x95\x19\xA1\xEA\xDC\x1AXk\xBD\xFF\x96I\xDB\x83f+^2?6\xD9\f\x12\xC7\x90:\xE2f\x87\xC8\x98\xA58\x89\t\")M\x9C\xBB\xC6&_#5u\x9F\xFA^N\x8D\x91\xF9*4\x14Jp\xD7\xE9\xC0\xCF\xB2\x1C\xFF\x12\x8F\xDF\xBFq\x19\xD8\xFE$\xB2\xFC\xFD\xE37\x18\xC0\x13\x0E\xC7\xDB\xCF\x01\x80\xCB{\xCF\x01\xDFE\x97\xE3\xC6\xF1\xF69\xE4\x17\xFD\xA9\x01\xD9\xA0\xBF\xC4G\x97!\xDC\"\xAE\x8F\xF7c\x7F\xB9\x0Esn\xFC\xA3\xFAA\x1A\x03'\xCD\xDE]~\xAC\x8B\xAF\xA0hp\xA2\xDF\x04y{y\xFCc\xF7\xE9\x0E,\xFF\xFAI\x008\xA1C~\x8C\x10\xB3\xD9\xF7\x14\xFFM\xE4\x9E\xFDH\xFE\xD7s\xF2\xFF\x14\xFE\xBD\x1EC\xE6k\xF8\xF7v7\xFE;1\xFEW\x91y\xC0\xB3\xD8\xEE\xB1)To\xCD-\x06\x87\xFF\x1C\xC3?\xFA\xC0\xD0\xA7N\x96\x1C\x04rN\xFC\xDF\xC4\x13w\x99\x04\xD2<[\xFAB\x16\x83\xEDy\xFF\x19\xDD\x8E\x870\xC5\xDE\xDD\xA3\xD9sx\xFC/\xD5`$\x9A\x05)Z\x06\xFF\xCD\xE4\xE3\xFAZ\x1F\xF1\xF5\xCD\x92P\xE7\xDBI\bw\xE9h6\xF3\x1E\xE2?R\x06\xFFd:o\xB9j\xE3\xFFj\x0F\xFC\xAB\xE0o#\xF8?\x97\xED\x9E\x1C&\x98\xBF\x07|K\x18\xFEk\x18\xFEk\x90\xB2\xEE\x06\xB2A\x7F\x9D\xF8\x7F\x83\xDD\xC3t+\xC2\xFF[\xB7$O\x8F\x7F\x16\"\xCF\x8Ap>\xCB-r'\xF8\xC7\xD1\xB4x\xFCs\xA1\xA7\xE5/\x11\xFCK\xB7\x90n\xE85\x12\x19\xE6x?\xB9\xAB\xC8\xEB\xEFe\"]\xC6\xEB\xEE\xB1\xE6\xC2H!.\xB8\x05,\xC0SV\xD4\x0EG\xA7\xB9\x1F/\x99\xC9\x1Cw\x12\x8F\xD2\xD8=\x00`\xDE\xF2I\x90\x7FE\xEE\xDB\xBC\xE5\xD7 \xBFb\xDE\xF2\n\xC8\xBF\xA63\xCEx\x83\xFEZh\x94\x90\xA5\xF1\xA8\x1D\f\x1C\xE1_\xEFc9\x1A$\xA5,\xFEK\xF5?\x97\xA0!\x8Dc\xE6\xA4\xFB\x9C-H\xDC\x84\xBB\xB4\x83\x841_\xBB\x97|\x86\x8F3\xFDO\xFEL\xA2\xBE\xE3=+\x94\xB6\x15\x93\xCE\xB0b\xD0\x8B%\xBF\x0E\xBF\x05Ba}\xDB\x85\x7F1\x89W\xE8\xBC\xD8\xEF\xD4\xFF\xE6a\xF4\xED/\xCF\xA9 |\xBF\x1D\xBF\xD0\xE5\xBD\x1A\xF86-\xEF\xDD\x04>\x8DR\xA3><+b\xF5k2\xBE\x006x,\xFB\xE7X+\xB1\x7F:\xE7\xC6\xFF\t\xDD\x8E\x01r\x84\xED\x9C\xE1\x96=\x9E\xD0\xD07~\xE2\x96\xA4\xD3\xFE\xE1\xF1\xAF\x81\x8C\xE3hQ\x82\xF4C\x04~\f\xFF{\xF2c\xEFa\"u\xEA\xFC\x19H\x11\x7F\x0F\xDB\xFE\xC1\"\xB9\x13\xFF\x12o\x90[\x95R\xFD\x7F'\x04\x1An\xC7\x12\xD3\xD8\xD1T?\xD2\xEA\xAFt\x98\x10(\\E&7e\x13\x02\xAB\xE2q\x95\xCCT\"\xFC\x07lK\x0F\xAC\x05\x9E\x98\x8E\xB3\x88\xEB?S0\xAD\xBD\xC5\x92\xA4\xF7\xD2\xCB?3Xk\x1C\xFE\xA5-vf\x93s\rXk\xC0\x9F\xDFEr\x05X\xE65\xAFRL\xA8BWY{\x00\xEF\xAC\xFA\n!\x1E\xCF=\x80/]\x95\x94\xDFK\xFC;\xEC\x1FN\xC2+U\xDB\n\xEA\xC4u\xFE\xD6\xAD\xFFM\xF0\xAF\x06\xFF\x8B\xD7\xE1^\xD4J\\;\x85Qx\x99\xAA\x81l\xFE\x03\xC6\x7F\xF1\x80\x00U\x1F.\x1E*\x80\xD4@B\xC1\x80o\xD01V\x98G\x13\x85\x00\xC0\x13l\xDF\xFF\x8E\xA2\xAB\x8E\xFE\xAB\xD5\xFFz\x83\xF09\r@\xA4\xC6\xAF\xCE\xEEa\xFB\xF7\xD6X\x15\xFE\r\x07\xA5\xFF?\x17\x98\x8E\x16\xE6q\"\x95\xB2$\x8E\r\\\x80\xAF5\xEF\xBBd\xA5\xD8\xFE\xEFE\b=>\xDC?\xFE\xDE\xDB\xFFH\xFEwr\xFD/\x89\xD7w'g\xF9|\xCD\x8D\xFF8\xC6\x7F'\xB1\xFF\xAD \xEA#)\xF4\xF7\xC1\\\x01|>2\xC1\xD5\xBC\xDE\x04\xFFs\xCD\xF18\xD4\xBEE5\x15A\xAC5\xEBWE\x8C\xFC\fO\\\xFF\x99\x82\xFE\x14\xB7X\x82\xCA\x96\xC5\xBF@\xD7\xEBX\x93\v\xA3\x07\xEC\xA8\x8Cg\xAB\x10U!\xF4\xB3.2V`W\xE4\xF2V\xC0\x0E\xF2\xE75\x8D\x04\xF0\xC8v\x95t\xF8\xD0\xE5\xE4sh\x17\xF5\x9E\xFF\x1C\xFC/\xE7,Lb\xF9\x90/\x82X8\xD7\xBAG\xFE\x97\x80?\n\xFEn\xF2uX\xF8\x9F\xFC\xC5\x95\xA8\xD9F\x1F\x04\n\xC4i\xE7\x99\x1E\x1F\xF8\x1B\x9E\xE97\xC9\b\xBFAa\xF8\xB7b\xD7\xD4\xD4a\x8E\xBA\x8D'\xAE\xBB?\x8B^\xCA\xC5\xAF\xB01Zu\xD4\xF3\xFE\xBB\xD1h\xE21*\x7F\xF6\x85\xFEy\x8D\xAD^\xBE\xA8@\"\x077\xD7<N\xDAgW\xE4x\xF8j\x01j\xD0\xFD<\xF0y\x8C\x7F\xBC}\xB1\x017\x9F\x87QQ\x93\xFC\xCB\xC9\xF7\xD0;\xA5\x91\xB3\xFFWr\xF6\xCFg\x14{\xCCE\xA2\xE6~\xCA\xAD\x7F\x9E\x06\xFF\xD7\xC1\xFF0y;\x1A;\xF7\xA1\xED\xA8\xFF]\xFA\xCA%\xE0\xAB#\x91\xC1.\xF9l\x01\xE4\x17/\xB9\xC9Gf*o\xB4\xF4\x7F%\xF2O\xA5TJ\xA5TJ\xA5\xBC\vE-\xA1\xC8ixa\xA8\x82*!T\xC5\x87\xAA\x13@\x01\x91xc\n\xEF\x88\x99?\xB3j\n\xB3\xB1\x959\xA6\x1Ep\xAEa\xD1&Y\xE9C\x88\xA7\x99\x14\xE0\x8B{j\xC0g\xEFq\x1C\xFA\x90\x0F\xE6\xCA\x12\xB0\xA6l\xF8\\t\x88\x1E\r0~\xBBv\x07\xD4\xEE\xF8\xC9\xE8\x8E\x9F`\xBB\xF2'\xE9v\x10\x0E;\xFC\xBE\xE6]K\x9FAh\x10|\r1\x1F\xF7D\xBEd\xC7\xD4\x00\xF8l\xF9\x17\r8w\xEE\x95\x80\xD54\xE9\xED\xAD\x9EG\x03\xEE\\B\xB7\xE2\xD5\x07\xB76!\xB1\xDEqH\xE1y\xFB\xAFr<\xFFm\xDDpk \x04\x01\xD1J\xDDEy\xCE\x80}\xB7VH\n4\x04\x0E\xB4-\xA3\xD9\xEE\xFE\x02\x02\x9F\xBF#\x07\xB7\xE9lj\xC0\xB2\xFA\x02\xF3o\r$\xC9Y\xFC\xAC\xC1\xAD\xCF\x84n\xCF\x01]g\xE1U.//\x81\xCB5v\xD4\xC7\xF8\xED`\x03\x04\x1B6\xB64\x90\xA1\xC7\xC6\x96\x06\x90?\xE3D\xC1\xAE\xB5t\xFD\xC2\xDE\xA9)\xB3c\x8A\xE7\x1F\xF6\xCE\bI2\x00'\xE9\x1B\x86th\x9C\x1B\xD0>*\xC3\x07=\x1D]\x82n\xB8n\xC4\xCB\xC67\xB6\xA0\xF72\xB0\x813}\x83\xC9!n\x9C\xF5\x1D\r\x1E<\x92\x84`\xDB\x00{\xF6!\x9A\xE3\xF8|GS\xB8\xE0\x9C\x9B\xD1\x16\x1A\xBDs\x02\x82\xE7\f\xA80\xA8\xB3[\x92\x98s]\xF0\xEB\xFF\xF8\xC5\x18\x89\x8F\xF1\xA0\x9D*\x19\x06[L4L\b\xC6\xDF\t\xFE\xAD\xA3\x98\xB5.\xDC\x9Cs\xE3\x7F8\r5\xAF9\xBC\xE0\x82'\xDA\xA9\xFFX,\x18\x1D8\x12\xE5\"\x1FH\xAB\xC7\xA6\xF6\x824le\xA6\xD8Y\xCE\x83\xD4~et\xB4\xE8\xFD\x9A\x04\xB7\xFC\x1B\xD1\xC00\xB6`b\x15\xFA\xE0{\xB80\bB\x8Cw\x15\x0E\x034\n\xE8tk\xDD}39*$\xF8:\xF6\xA5\x85\xB6\xBBi;Q\x10nR4X\xA8Z\x83\xB8\x1D\xEC\x12\xF3#\xE1$\x8D5\xCAs\xDDB:b\xA5\xBDx\x9B\xF8W\xBB\xE1\nz\x95\x1A\xCC\xE9\xD5\xB8\xF1\x1FM\x80\x94pxA\xD7]\xC9\xF0\xBF_\x9E\xFA\xEE\x18\x1F\x8BI\xDE?\x13N\x92\xB8\xB5\xDF\xC2\xF7\x99\xD1\xEC<\x80e\xF0Oa\xE3\x1D\xFFJ~\xCC\xB5\x03U\x93\xF3\xF9\xD6\x01\x00\x98\xEE\xCF\xF0\x97\xE6\x95d^\x81\xD9\xA9\f]\x1F\xE4`\xA4m\xB4\x14T\xEE\x90\x9CUi\x94\xE9<\xC8\x83E\x03NYN\xE92\xC3\xBF<T\xBCe\x17\x8D5\xCD]kv\xAAP\xD0\xE8\xBA'\xCF2\x07\xCF^\xD4(\x19NX\x8B\xB8\\@\xF2\xE7\xF0\xBFy8\r\xB2\xE9\xC0\xBF\xBF\x93\xE1?1\x13\xCD\x8E8\xF0\x9F\xFC\xDE\xB6\x04\xE1\xBD\xAF\xC7\xB0\xFF\xA9z:\xFC3\xB6d\xC4S\xFFH{];F0\xB3\xB4=\xFA0\xDA\x96\xB8\xA0\xC7\xD2\xC00_\xCD\x80\xED\xD1] \x99\xD6\xFA\x1D\xE6\xF3ik\xCB,;\x843\xDEfi?%eA2Gp\x9E\x02v\n\xC3\xBF\xF4V&\x9A$q*\xB2\xDC\x070,\xE9\xDBT\xE7\xDC\x93\xB3,\xCC\xCD\xC5\x93\xD0%0\xBE\f^\xD1\x93A\xFAG\x8CiQI\xC3\xF2O\xB7\x9An!\xC8\xA6\xA5\x7F\x96G3G\xA2\x0FqB\xE8\x1C]\xBD\x97\x04\x81_\x8DO\xDF\xAA\xB08<\xE5\x8A\x9Fv[3\x9E\xE6\x83\x9C\xF2\xC2\x7F6?6\x80\x81\xF7\n\x7FW\xB3\xFC\x1A:tT\x039e\x01\x95_s\xE7\xFA\xE20\xFE\xC7\xA9\x02\x94\xB3 \x0F\x17\r\xC8\xEB\xD6'\xD3c\xE1\xBF\xD0\xAA\x10\xB8\xF2\xD1\xAEf\xA7\xC6O\xB1\xD4\x03\xDEd\xBE:\xD7<\xD1G\xB9d7\x99m\x05\x10\x05\xA8\xCD\xF7-\xDAA\xB2$\x173\x00\xF3ns\xD8?\x82\xC8\xF4\xCF\x8B\x1DS\x99\xB1\xA9,/\x04\xAC\x7FPS7\xB0\x04I\xA7\x91\x7F-]z\x95\xF5\x8E\xCF\xEF\x96\xFF\xA8\x81\x00\x99]\x8D\xE4\xBF=\xCA}\xF2R\x86\xF7a\x1E5 \x1BMS\xFFd\x02\xF2R\xFC+<\xFESE\x1A/k\x92\xE0\x7F\xCC\xB0\xD2\x10X\xF8\x1F\xDA6i\x12O\x86QN \xC3Qm+s0\xF0,-\xE5C[lT\xE0\x19\xD2T\x15\xEA\xE9\x96\xF6\xC6\x91\xFC\xC5\xD8\xCE\xAC4\x8C\x01\x9C\xCD|\b|\xBF\xDA\xA88\xF0\x7F6yR\x7Fl\xDD\xB2\xC4\xD6e\xED\xBCj\xBA\xA6u\x88x\x0E\x93\x80'\xF1\xD3\xEA\x1F\x9F\xCF\xD2\xD8^\xF8w\x7F\xD48\xC8\xF9\xA3\xF9\xD6\x87\xF1\xE2\xB8\xFB\xB8\x9A\x99|\xCE\xA5\xFF\x87@\x1E\xB7\xF4?=\xCA\xE1\xDF\xB9hh\x9C\xE2\x04g\xCD(\x1A\xE8{d\xFA\xDFJ\xA2q\xE2TG\x94\x9C5\xCD)\xE4\x99\x8E\x1F\xE3\xAF\xF2W\xE5\x1E\xF1\x8B\xE5\xE5?k0\x03\xB0j\x1A\x00\x8C\xF5\xB73\xFC\xE7w`\xF9\xEF\xDCf@\xE0\xA2\x03<\xFE\x83\rg\x93g\xF1\x7Fe\xEB\xB2\xDB\xB6.\xFB\x02'\xFF\xEB\xFF\xF6s\x1F\x05\xFF\xF5\xA8\xE3`\xF8?M\xB1\xD8r\xEF\x9Bt\xDB?\x82\x82\xA3\x9B*!\xB6m\x95f\xDE\x95\xA6\xDA\x00A\x11\x01D\xB6\xC0\x10\x98\x8Bx[\xE9\x88/\x88\xDA\x11\xD9\xADF\x01\xA2A\x05d\xC3j\xDF\xA2\x88\xFF\xB4JM\xE0\xC9F+\xA4\r\x19\x8B\r\x07\xD1\xCE\x8B\xCA=\xE2\x1C\xA1u\xEA\x81\xB9^\xD7G0\xFEcH\xFERb\xE7pz\x80,D\x8A\xF8\xC0w\xE5fG\xFE\xE5\xA34\x98aP8\xD2\x02GZ\xB8\x91n\x10\x06j:!\b\xD6\xECj\x83\x02\x9D\xEA\x19\xE1\x7FX=#\xFD\x83t\x82\x94\xCEb\xCD\x93\x8Dr\xCB.\xA4M\xBC\x06\xCB*\x90\x8D\x0E\xF1\xFA\x87u\xA66\xFE\xB7\xAA\x0E\xFDC\xEFSJ\x83\xB4}DA;Y\\\xC1\x1D\xB6\x8AK\ffH\xE2'N\xF3e\xA3\xD1-\xA8\xFF\xBD\xA7\xDC#\xB6\x96\x0F-\xF5\xBA\x01\xBF\xA2\xCE\xF0\xE8\x8B\xCE}9\x0Fb\rH\xD7o\\t\xE9?\xE3\v\xF5?R\x80\xC0\xAF{\xF9\x11\x84\x18\xFB\x17\xD2`\xD0\f\x1E6\x83G8\x15!\x9A\xFDG\xEE'+\x80\xFE\n\xD7y\xC9`K<Nk\xFFhg\xAE\xFF\xC7\x89\xFE\x1F\x9D\xE4\xA6\x1B\xA4WF\x9Dya\xB2\xAB'\xBC\xEC\x9FGm\x1B\xC9\xD2\xFF\xDD\xA8Mz\x9F\xD2\xA3 \xA5F\xBAy\xFD\x7F\x8F-\xFF\xD5\x8F\x91\xB4\xE6\xFC\xDD\x8Ef\x9F}\x14\xBD\xC1\x1FW\xB8\xAAJ\xA9\x94J\xA9\x94J\xE1Ild\xA0hb\x15g\xCEUy%\xEDe\x14>\xB8Iu\r\xC2s\x13\xF5Z\x89\x95\xA8:N/)\xDE\x9E?>\x15\xAAr\x1F\x88\t\x11\x95<\x9A\xCF9}\xE0\x19.\xE9+:\xDC\x06p\xDB\xB6\xD0\xAD\x00_{\xE6\x12\xC2{\xDF\x1AH~\xE5Q\xE6+\x18`&q\xE0E\x00\xF8\xDA+\x9C=\x13h\xF8\xEA!3\xC9\xCB\xBF\xC6\xBC\xED\xAA\xCB\xF8\xEC\xC0\xE8\x12\xEB\xC5;\x8E8\xF2'\xDCF9\xA5N\x9E*\xE7\x82\xE7{\xCB\xFFv\xAD\xCC,\xC0\xFB\r\xD0\xA0\xA1Q\x93l\x8A\x16b\x03\x05\x01\x88\x1F\xA2\xBB<h\xC0f\x03\x1E<\xD2\xB6\xD9\x80M-{H\xB2\xC2\xEF\x1CI<8\xC9,\xE1 \x93n\x10\x8D`\x1E\xE63i\x06\x93\x83#\xE1\x8D|\x8E\x06)\xBD\xF9\b\x1A)\fr\xD7z\xF0Hr\xA3\xDF\xB1\xD4\x94\xE6\xAE\nv\xF1\xC4\xBE\x1DY:\xE8MU\xA1\xFB4\xDE\xF7\xE2\xAF\x9E\xC6\xB1\xD0\xD7\x80\xA8\x92!\xDB\xA1\x1C\x80/>\x95\x03\xCF\x14c\x11\x8C\xDEp:\xDC\b\xD04\x91 \xA1h\xCF\v'#\xBDL\xFE\x02\xC3\x7F\x15\x1A\xE8E{9\xF9\v\xF3\x17\xDCxT\xD1!b\r\x8E|\xF9H\xCFe\xAE1Ec,\xD1:u\x90\xBFh\x98\x92\xEDI>\xF3\xC2\"\xEB\x14\xC1\xDB\xF3\xA7\x11 \xA2\xBF\xEF\xE5/\x88h\xCC(\xC7\xA1\xB6\xA0b\xB1 \xE1\xF8O\f\xAB\xD0P\x86a.\x1A\x90\x9F\x1AG\xBF\xFD\t\xC6\r\xEE-\xF63\xFDcQ\"86\xC5\xAC\x83\xCF7\xF3\xAD)S\xE7\"'\xCBC3\xD8\x837\xCF\t\xAA8e\xCE,\xFA\xA4\x8B\xD6\x03\xB6\xF4\xC9f \xCB\xB3:\xD6Y\xC5\xDC\x07\x04\xFF\xFE5 \xF9\b\xFE\x9Br\x00\xFE\xF9c9\xEFX\r\x19\x1D2\x1Ad\xA5\xF4\x88\x02c\x93y\xE2O\x9B\x8D&2\x16\xFDm'\t\xFDG\x00\xD8\x9E\xE5I\xC5\xC1\xD1\xC9\xA3[\r\xCE\x85O:1\x86\x17P\xF0IH\xB3\xD1\xC4\xE8\xDF;\x16\xB3\xB0`\v\x9D<\xCDh\x9FR&.SF\xB5\xD7I\xBD\xBF\xF1\x8F\x13\xC7\x97\xE0_\xF1\xD2?E\xCCc\xCFN\xA5OuC~\xAC\x9D\xE0\xB08e\x16\xC7\x98\xC6\x965~cz\x8C\x8B\xA5#?1-/9\xA1\xC3\xC3v\xDC\xDDl\x1EG\xBC?\xC6\x93xS\xE6t\xF5y\xFCE\v\x14\xFF'x\xFC\xDB\x9F\xCC\x1C\xF8\xFF\x00\xE8\x7F\x13\x02&\xF8\x93\b\xFFVdr\xFF\xFC1\xC3\x1B\xFF[U\x18Va\xB8\xCF\x1CQ\xE0\xB1\xC9\x15\x14\xFF\xD2\xAA\xAD\t\x96\x1B\xD1\x9A\xB8\xC1\x1B\xDB\xB3\\,\v\xE9\xC5\xB1\xC9\xECv\x9D\xB3\x7F\xA4\xFCc\xABK\xF1\xDF>\xF6\xB2\x03\xFF\xC3\\\xB0\vk\xF9\f\x87\xFFx9\xFCoU\xDF\xFF\xF8\x07\xF0e\xC1\xAFB\xADI8[dd\xF8O\f\x83w\xAC\xAAS*I\xC1\x9F*\x1A0\xDD\xFA<\x99\xF7)N\xED.v\xF4Y\x90f\x1B8\xDF\xE8\x18\xA7\x7F\xE4t~\xEC\xF3o\xF2s\xE8rj\x06\xCF\xBA:\xF1\xFF\xC2tc\xC4K\xFF?\xCF\xD3\xEC\\\xA2\x815\x9EOv2\xE7\x15\xA2\xFF}\x88\xFF\xE0y\x18\xFFp.V\v8\xAA\xBF\x0F\xE1\xDF\xEB\xE3\xADQAT\xA1Jk\xAB\x06\x90\x8D.\xC6\x8D\x87}\xAA\xB5\xF2\xC2\xD2\xC6xi\x86\xCE'#h\x93\xF4\xACO\xE3\xE7\xB0\xDAj\x94\b\x9F\x1D\x18[\xC4\x8FU\x1Fp:\xFDRQ\xB7\xF1,}\xB5q\x9A\xF1\x97\xBF\x9B\xAF\xF3>\xFE\x00\xAA\x8E\x81_\x80Z\x93\xAC\x8E\\\xA5\x00\xF8\xF3\x86\xE2=\x85\x91\xD5\x91\xFE\xC9\xEEM!E\x84\x93\x13e\x15\x18\xD9\xAB\x0Fg\xEFs\xF7\x86\xD8\xD1e{\xB6\x93\xD3?\xE9\xEC\xE8\x92\x8C\xC6\xE1_J\r\xEF\xDD\xC4\x93\xE7xM\xD9\xDE\xE1\x88c\xF6\x931\xB7\x19\xBE\xFF\xB5\xF9yi\xD8[\xFFh\xF6Z\x83\xF7o\xF1wBU\x03\x88Y\x10\x85\xB3\xEC H\xD2\xD9\nM\x14\xE5*\xC8\xEC\xC9\xC1cY<\xA7\x89\xC7\\\xC39\xD8\x1E}h4\xFA\xB8\xA7\xFE\x1F\xEE\xE3\xED\x9F\xF1\xB1\xC9_e4\x8E\xC3\x97\xCCQ\xE9\x15\x00\x18\xE5\x1D\x00\xFA6\x8D\x1Dq\xACc\x1D!\xFD\xB5\xB4\x9B\x9F*\xB5\xF9\xF92\xAE\x02\xDB\xBB\x1D\xDD\xCA\xFB\xB4\x04\xAF\x85\xFA\x0F\x83\xB8\x1D\xA4\xC7\xC8\xB4`\x9F\x01\x10\xBC\xFE\xECnx\xA0\xBB\xC2vUJ\xA5TJ\xA5T\n\xB1\x95B\x98\xD7\nq\xC1\xF9\xD9\xAF\xE0r\x98\xC7\x7F\xFA\x18\xAD\xADA\xA3\xB5\x00\xD5]B\xD4\xBB^\bY\xBC7?)P\xE5p\xC5G\xDB\xA9\xBB\xC4*\x80F\xECb\xE4\x98\x0E\xD0\xA8\x87\xED\xD5\xBC\xE9\xAAy\r\xF9\xED\xBB\ry\xF0\xC1\x1E\x7F*\xD4w\xB7*dq\xC6d\x83\xBB\xBD\x10\xFE\x13T\xCDy-\xDE\xEFW\xF0\x88h\xC4\xDD-\xBD\xB1\xB3\xDCWgf\x1C\x96gXT\x8ASt\xCFq\xFC{#;\x04,H\x0E],\x8F\x9D\x81\x88<\xC3\x10\x8Ax\xB318\x13g\x8DB,\xFB\xE3\x00\xCD\x86#~\xB8 s\xB6\x11\xDE^.\xAF\x9AQ =o\x95\xCB\xCF\x7F\x86\xDDF\xA7\x93\x05\xF5@\x915\x8A\x90\xDD\x16\xAA\xCBq\xF7\x94U\x8D\x88\x0E;\x83}\x8A5\xFB\x1B\x80\x17\xAC\xDB\v(\xFF/\xBE\xFFO\x95 \x96\xFE\xCA\xCFy\xCA\xDF\xBE[y\x80\xDC\x98\x15\xA5|&`\xBE\x91\x03\xA8Y\xC13-M{\xD6\f\xFA\xE9\x90s=\xB6\xE4\x1F\xCCq$\x8C\x0F\xF3\x9F\x12\xAE\xE0[C\x9C\xA6fs\xD0\xB4\xEF)o6FDu\xAE\xFA\xC5\x1A\xE2:\xDE\x94\x83\x1BXdQ:\x8C\xFD\x057\xBC\r\xA2\xED?\xF9yr\x81\x01\xDB~\xB6\xC6\xCAfH-R\x96\xAD\x80\xA7==.*\x8F[n\xEA$\xD0\v_F\x9D\xF5\xD7Sw>\x96\xE5\r\xCFA|\x9C1\xAB\x1F7\xF0\x9D\xD3\x0Fu\xCD3\x062\xCE?\xCB\xB7@\xA3E\x91\f\xA1\x97q\xD7\xE5\xEE\xD0\x1E\r\xD1\x1B\xB3\xEE\xF9O\x0E\x0E?\xA4RgZ`\x81y\v\x1D\xF1\xCD?\xA7\x94\vY\xA4\xE0S\x01D\xE6V*m\xB79\x19\x1C\xC0!\xAEBV\x85B\"\x93\xF2t\xDD\t\xEC\xC6\xED\xC4I\xE4\xF9\xB8\n\x1B\x9D.\xA6\xF1\x0E>\n\x04\xDA\xCE/\v\x9FR\xE0\xC4\xE5h\xE0\xCC\xE7\xC9\xCD\xAA\xD4!\xAA\x8BO\xFAVzQ!\xCC\xA2\xDC{,sp9.\xD2?\x858>\v@\x18&\x19\xCAz\xD9\xCA\xEB\xDF}\x9C\xB5 \xEE\x8E*\x10Q\x9D9&\xC8Y\"\xFE\xAD\xCD\x800\xDF\x93\xA7\xB2+\xFB\xB1\x10,/\xC7\x85\xC9\xE3\x1A\x8F\x7F$\xFFm{\xD6\f/\xA3/\xFD\xDFs\xC0\xC2D3\xF9W).\xFC\x17\r\x84\xCC\xF5{\x9F\xDA\xE99\x1A\xADZ\x83[X\x03\xF8\x9Bz0\x07\xE7:\xF1\x7F]\xCE\x8D\xFFE\xFB\xCCF\x15\xB6\xED+\xB8=\xE7\x19\xFE\xAF\xE3N\xBF\xC1\x1B\xFF\xACM\xBF\x1B\xFF.\xCAb\xD4\xA2\x9Eh\x96\xC38\x81=\xB9\xC4oy\xFC\xCBk\xFE\t\xEF\xE7\x03tPmL8y\xE9)Ba\x95\xF2T\xF6\xC7\x82o\xEC[L\xFE\x9F8\xD4\xBC\xC8p\xE3?\xB3<>\xB6/\xCE\xBF;\x8C\x7F&\xDC\xEA\xBC\x05Tr\xB7\x11\x1C\xA9\xFB\x89D\xA6L\xF0y\\\xA7#\x0E\xE2n\xE2\\\xBD\xD8\x00~\xEDO\x97\x17\xFE\xFFJ\x83H,\xE3\xF2s\xB6\xF0_\x98\x1B\xFFR\x9A\x83\xFD\x99\xE1\xDF\x7F\x0Eu5$y[\x14\xFA\x85\x0E*\x90\xE9\xD8m5\xB5KA\x02q\xB8^\x13mLr\xF3\xD5f\xC0\xF7\xE8\\\xF8\xAFIC\x10\xB5\xD6\xC0d9\xB8\xB0m\\\xE5t;\xD1\xFFS\xC9\xC3\x97\xD3\xD51d\xF9\x00N\x93\xC1Z\xAE\xAF\x07+X\x16NA\xBE\xA7\x1B\xA1\xE8\xCF\xA6\xC6\xBD\x83o\xFBI\x9A\xCE$\xC9W{\x95\x0178\xB3\xEF]w\x84[\x89\x83sz>\xF2r\xDB\x84\n''\xC6]\xF8'\xCE\x84\\\x1A\x0ET\xFE\x977\xFE\xAD\x80Q\xC93\xC2\x7F\xF0<\x98G0,\x91:\xE4\xC1\x7Fk@\xF10k!\x90\xFC&\x9Eq\xF8I9\xFC\x8Bm \xE7=\xF0o\x13)4\xC6Z\x17\xDB3{PM\xF3\xBA]D\xDDw\x97O\x1D{\x89\xBE3\xF29\xA1>\x89\xC4\xCD\xB6\xE2\x15\x90\b\xD4\xB2J\x82\x87d\x01\xBA$\xDD\x1B\xFF\xD5\xE8\xF3;A\xDD0\x10\x1C\x9FS\x80g\xDF^\x9394\xE3\xF8\xD4\xF9@\xF7R\x1D|\xD5\xBA+\xDEG\x9E\xD93'\xB8\x9D\xABK\xAF(\xE94-\n\xE7\xDA\x02<i\xCBS\x7F\xD6C\x91\xA0\xF0x}\x81\xC9.\x91\x00\x18\xB2n\xAFJM\xE38\x98\x8E\xD98\x9FN\xAFH\x8D(\x8F\xF5\xAA\xF6\xAA'Y'\x0F\xB8\x93\t*\xEB/\xA0\xDE\x99-j \x8B\x92\xAE;\x98\x1C\xF6\xD3\x97\xFE\xA0\x15\xFA\xCF2\xE4\xC8%\x82I\xEBW\xD1\x10J\xAF\x9B\x1C_\xEA\xCD\x86%ij~\xDC\xE6I\x8C\x7F\xDEo\xE1*\x1E\xFF\x18\x1E\x8B^\x1BW489\xE9\x85\x7F\x7F\x9Bk\xF1\xE3\xC7=\xF1o\xADn+\x99;\xBB\xC2Y\x9F\xB6/\x88T\xFF\xE3\xA7\xDB\xC6\xE1\xFF\xA4u{\xA29k\x94L\xBA\x91\xF6k\xD9W\xE05Ug\xD7\x97\xE8\x87i\x01\xF5\x7F\x1E\xF1\xA9\x1A\xBFl\x10\xF5\xFE\x9Fl\x15\xC6\x8EP\xBF*\x12\xD0\xA9[\xE1\xC6\b8|\x07\xCC\xC3\x15\x82\xE8w\xA9\x01\x8A\x02\xAB\xA2=\xDE>\xF9\x02\xAAs\xACE \x1B\xAA\x02\x97+p\x8C\xAB\xA9\xB6\n\xCE\xE9\"\xF8B\xA4g\xA9\x01\x03Q\xF4U\xF26\xD5\xB0B\xAF\xC8\x9F\x1EW\xBC\xAEhY\v\x82{a\xF7\xB4\xB3\xBE\xA2\xB0\x87\"5\xF1\xD3}\x81\xDD\xE1\x17\x14\x18\xB0nO\xEEQ\x14\\_q\xCDo\xB1_tQ\xA1\xCC\x00\x88\xB6@\xAEb\x01\xF5p\x8B\xB9\xD6`\"e\f\xFC\x03\x91\xAC\xDEH\x07\r$\xEDBB\xE7<\xE1}\x82=\xAA\bv\x12\x91Fu\xE8\x1B\xCBz\x12\xDAdD\x13\x1D\xE9$\x1B\xCB0\xEF\xFD\x00W3?\xD2\xE9\xAA\xBCua\xA7\xAA\xC0\x03\x8B\xF6S\xB6\x9C\x9B\x9B N\x17\xFC\xE9\x89R\xA3\xAB&k\xBB\xAC\xF8;]\x07\xBF\xED\xBCI\x9Ad\xDF'\xA0\xB3\xD8\xD3\xFDP\xA1\xC9\x97\x13:\xBC\xD9b\xC5\xBE\xCBfut\xF3\x9D\xFC\x15\xFDQ\xFB*b\xB4\xF4r\x00\x1C\xCF/e\xC9\xEC\x89j\xCDq\xE8\x82\xAAZ\"\x05\x90p\x02\xDF\x9B\xB6\xFF\xF0\xB34\xCE\xD0\xD9\x98\xA3N\x18\xEC\x13\x03\x1A\xE8\x1Ed\xFB\xF7\x81n\x88\x1A\xD0gl\xF7&\xB4q\xFD\xE8\xD4\xB5 \xA2\x8D7\xBB\xE1\x9An\xDA,\xBD\xE6\xAB\xD7\xBA*\xB7|\xF9\xDA\x07\xBA\xE1\xCD/\xA1\xED\xEF\xF2\xF27\x00\xAAh#V\xB9\xADT\xFE\xD2v\xA8\xD9\xEE\xB8[\xAE|\xCCy\x93\v\xBBY52\xAE\xC1\xF5\xFF\xBE\x9B^\xE2\x05\x1D\x1E\xF8\xEF\xAC\x05y2o\xC0\x86n\x07$X:!\"\x8D\xA7K/G\xE4\xC3Z\xC8\x92\xABX{&\xB7^\x9B\xCD\x81\xE7Y\x95R)\x95R)\x95R)\x8E\xB2N\x9C3\xD5\xEF\x7FZ!\xCC\x88\xC8,\xBCR\xA3PaV\x85\x1A\xBE<\xE4\xAC\xA0pD1\x0EO$\x88J\xC9\nU\x1C\xB2CUp;\x02;\xFD,\xBE\x9FG\xFBC\x8E\x05\x0E\x9A\x88\x1A'\xAB'\xB8\bB>~\n\x80\x18\\4\x11\xB0\x0E\xFE\xD0\xAA\xB7\xE3E9\xE3Gw~\xC3\x1F\xDE\xF1\t\rd\xAExFb$\xBF\xC2\x07\x12\xC4\x9E~\n]t \x9BH\xFE\x01.\xF5@\xC0$\xE9Jy\xF97\x19\x0E\xF97\nT\xFE\xAD\x06'\xFF\xAA\x10/\xFF\x9Br\x97\xE5\xE5\x81\xD7\x03\x85\xB59\x98\xC1$[al/\b\xE1\xE9\xFE\xF6\x19;\x82A\xCA\x8E\xEF\xCDEH\x98\xAFAqj\x00|\x19\x987\xF8\xEBmo#\xB4\xFB(vx\xD6\xF5\xF7\x05\xFEo\x8F\x90\x98\xD5mH\xA4>{\xEEc9\x16\xF2rj\x82\x86\x8AS&\r\xB6L\xC17`\x13\x95\xB2I\xD6\xB3\xE3\xCC\xC8v\xB4\x81\x938N\xD1\xEC\x94\xF9z\x00\r\x91\xD6\x1E\xA2\xB1R\xF9\x15\xE2\x89\xABr\v&B\xAD\x07\xE3qF\xCAe\xB2\t\xF0\x9B\xD9l\xFB\x88\xE5?\x89\x9Dg\x8A%\xBE4]\x06\feM\x10\x86\xC1\xDF\xF6\x89\x83\x993\x7F\xEC<v\xCAZ\xF9\x07\xC7?\x0E\x9E\xD91\x85\xE1$\xEF\xC1\"5\x1D\xF8\xF7\rX\xF8O/\xFB\xA8\x1B\xFF\x12c\x15\x84v\x1F\xF6\x13\xCBjt\xF8C\xCA\x17\x9AB$dP\xD8\x97j\xD7`9\x0E\xCD\xEA\xC2\x7F\\U\xF3c/\x1E_\xD7\xB56\x07\xBF#\\V\xBF\tu\xA1\x17\xBE\xF7\xF0o\f\xF85\xC1\xFC<\x8D\x8F\x8B\v\xF3\xA8\xA87\xEB\xB0\xF3?\xF0=\xCB\xCF\x15\xD6?\xF5v\xF0?\xFE\xBE\xC0\xBF\x0Fg?La\x9D#\x8Ec\xFC\xDB\b\xBF\x1A\v\xF9j\x86\xFF\xD9_tB0d{\xEE\x05C6\xFE\xAB?\xB9T\x03\b\x88\xB7\x19\x00\x81;\xAD\x16~\x88\xDD\x86\xA7\xFB\xB3\xC5\x83)\x8C\xFF\x17\xED\x8F\xC5\"v\xA6\xCC\xC8#\xA1\x96\xA6B\\\x85{\xF1\xFE''\xDB!0\xDD7\x9C\xDD\x00\x90\"\xF2\x17\xC7\x1Dq\x15\xC4\x8C\xD5\x05eR&\b\xED \f,2\xDE\x864\xF3\v\xC3\x00p\xF4\x0F\xEEx\x86\x07\xFE\xA3\xFF\xD1G\xC7\x95\xBEA+\x008\x8D\xE6\xE4\x0F\x91\x98NP;\x9E\xBD\xCA\xC4\x99|\xADH\xEF/\x92\xB5\x06\xA8\xD4\xBD\x82\xF1?\x9E\xD5\x1D\v\r\xFE\xAE\tm7M\x84#\xDB^l\xD7\xE0o\x96=fw\x16\xACl\f\xB7\xDFz\xDE\xC0\x9D\xBA\x1AW\x81\xB8Hf\xFA\xF7\x80\xB0rt2;b1\xDB\x98\xB7\xB9Fu\xEB\x9F\xA5:\xFC4\x91\x05_\x1C\xA4\xD5\x8F\xBE\x9D\xD0\xEE\x9F\xC0\xF8O\xFC\xC1\xF5\x0F\x0E\x9E\xFCB\x16\x07[\x90\xFE\x12\xE3\xDF\xCEj\x1A\xC3\xCB\x03i\xDC!A\x9C\xDD=\x88\xBE\x17\xEB\x05\xF9z\xC8Z\x03\x82\x7F\x04iIL#\xF9_j\xB5\xF0\xE4\xE4\x0E\x8C\x7F\xF3d&u\xBD\x0E\x7F\xFF\xF9>BS\xF3s\x1Ckwg\xB6'Bc/M\xAF\xCD\xD1\xD5:\x85\x9E\xF9P==\xDD\x9F\x98\xB1\xD6\xEF\xE0\xE5B\xB6C2[=\xD1\xA5\xC3\xD6V\x13\xEB\x9F\xEC\xEC\xE1\xF4\x99?w\x16'PX\xFA\x07_xR\xF3yt3\xDF#\xC9z\xA2\xE0\x0F\xF1\xF8G\x9A\xDF\x1F\xB9\x85|\xF5\xD5?N_e:^P`\x1C\x82,H`\xDD\x95H\xD1W\xA7\xFE\x9B\x01Pm\xCF^-\xCA \xF9\xAFZ\xB7$\x9E\xD9\xB4Z\x87+\xD6\x15Hg\xC1\xFBx\x9CU}\xCE\xC7\xD6%\xAF\xC6\x1F\xC5\x02\x12\xE7\xAD?\rB\xBB\xD2\x93X`0\x83\x15/\x97\xB3\xF5\x0F[=\xF7{\x1D\xD6\xEE\x8Ac\xFCg\xB3o\x07\xFFE\x8C\x7FE{_\xE0\xFF\xB7\x93OQ\x12\xDE\xFF\"\xF8m\xFB\xA7\x07U\x18\xD6U\x8A\xFF\xE2d\b|\xFB\x9D\xF8g\xFA\xBF\nC\xBAnh\xAFb\x07\x9D\x01\x80\xAF\xDD\x8C\xDE\xEC\xD5\xCBV\xDF\xBE\xF5\xB1v\r>\xFD9_)\xFE\x8B\xAF]\xB9{\xF5\xAE\xB1C\x85\xA2Ai\xEDSj\fd3?\xD6\x99\xB7\xC3\x01\xA5\x1C\xF6?[=\x17W!\xDEQ\x00\x7F\x17\xC8\x99\xB7\x85\xFFUQ\x07\x83\xFD\x87\xD3\xFF\t\x00\x18\xFE6\xCE\x16\xE2\xCB\xA0.5h\xA7\x8F\xDF\x9C\x03\xA85IH.\xA8\x9E\xD6k_\x84@\xC2~Ar\x1A\x82l\x15g\x8D\xF8\x9C\x06 \xA4\x9Bs\x00\x82\xBD*\xF6\xDF.@\x06\xD2\xA3\xD1\xF3~?\xB9w#\xC0U\xF7\x9A\xA5\xF8\x8F\xDC\xB5\xEA\xC2\xF51\x92\x1D\x80\x8E\x0F\xF0\x1B\x17\xF4AAq\x84\x03\xE2zmz\xDD\x1BT(\x1Aq$\x7Fi\xF7\xDB\xC2\xFF\xE7\xA2\x0E\x06\xFB\x0F\x87\x7Fd\x06\x8C\xB4\xF71\xF9\xDF\x86^\x01?\xFE\rF\x82\xF4\xAF\xC1\x91X\b\xE9\xFF\xE0m\xF6\xB7\x13\xB4\x16\xE0\x1C\x93\xD1;\xC2\xE1\x90\xAA\xB9\x91/\x8EUyQ5\\$\xA6\xFATx**\x94\xE2\x7FiO\xFB\xC7\xFAv\x8Dn\x8Dt\xAA4\x1EQva\x04\xFC\x91l6\x9DU\xACE\r\t+\xBA\x17p\x01\x85T\x1D:\x13\x05\xA8\xE9\x02\xA9/\xAB\xBF\rm\xF2\xFF\xDD\xE2`\xB0\xFF\xB0\xF6\xBF\xD9\xFA8\xD5?\xD5\x0FC\xF5\xB3\x0E\xFD/\x84\xBFB5\xC0\x87\xF3M/\xA2\xFA\xB5\f\xDE\xC1{`\x1E\xF3j\x90\xEBQ\xB5:s\x1F\xFE\xB5Z\xF8\xFD\x7F\xA0\xED}\xAF\x99\xFB\x8C\xD4R\x03\xEE~\t\x1F\xAA\xAF\xCFq\x0F\x9E\xFB\xD2\xD3\xBF\xFA|\xF2\v_\x18\xDC\xA0\xD0\b?\xD9\xE6A\x10\x07G'_\x1B5,\xFBg\x93\x9D\xB7\x9A[=z\x8D\x02\x1B\xA2\xF7\x80o\x05H\x8Fgu\xB3BkUJ\xA5TJ\xA5T\n\b\x8A;\xCB\xA3 \x96z\x16\x85|\xBD\xEE\x13\xB5\xB2De\xA9[\xB6\x0F\xEFg\xBFPrEP\xD0?\xC5\xE2\xF1y\x8A\x9FZ|\xC2\xE9\x1F\xE4\x03*\x7F\x8B\x07\xB9A-+\xFF\xCF\xEEjw\xED\xF9\x9D\xB7\xFC\xD1\xDE\x05\xC6\\\xF2o\xCA\xC1\x0E\xD7\xE1\xDA\xF1\x9F\xBC\xFAP\xE3/\xD1\x80\xE8'\x13\xC8\x14\xFF\t\xE7\xF8G6~\xF2\xAAy&\xF2\xA7o\x89\x9B\x1DXZ\xF5\xD4\xFBb\b_\xAE\xC8\xE3\xD6x\xE1j\x1A\xE5u\xBC4\xF3\xA0ZB\x01\xAD\xF7\x1C\x94\xE1\x07_\xA3\x95\x8E\xA3M\xEB7\x02\xE0\x1E\x01J\xE1-\xD1\xF0\x8Eh\x1B\x8E)\x8D\x8C\xFC\xB4\x02\x96\x99L6\xD2\xD9\x9E\xD3>\x88\x1D\xFA\xC9g\x8FAc\xF5\xED\x9E\xF7\xFF\xBE\xC1\x7F\xC4\x8A\x8D<\x07\xFE\xBF\xFA\x8C{\xD6\xE6w\x9E4*>1^\"\x7F\t;\xD4\x91\xDF\xA2\x01\xA6k@!O\x9Cj\xCDe\xE4]\xE8\xE8D'2\xF5\x15g\x04`\xF6\xEE\xE6*8R-\x9D\x85\xA9\xB5=c\x8B\xBBL\xEF\x85\x1B\xEF\x17\xFC?o\xC5U`\xF8O\x95z6\xAAq\xB7kw\xAF\xFE6\xF0\xFF\xE6\xD4g\xAC\xDF\xB3\x00F]\x15\xA4\xF1lt|v\x12!<\xDB\xBA\x868\x7F\x8E\xD8nc\x80\x03\xB9ko\x03\xFF\x1C~\x12\xB1,\x9F\xA7\xEF}W|v\x18^*\x7Fh\xB3\xD7\bXc\xCC\x12\xFC{#\xAA\f\xFE\xAFY\xD6e\xFDfux\xC1ux^\xFA\x85\x7F\xD5V\xCDC\xDD\xC2\vat\x13\xBF\xD6\xE07L\xFE\xBF%\xCE\xB1\xFFq\xDAa\xA3`/\x96\xE1\xF03\xFB\xEC\xD1\xF7\xC5\x14FY\xD8\x98V\xB8<J\x9C\xCA=\x10\xD8\xE4\xAA\x15/\xC1\x7F\xC6\x13Q\x81\x82\xE7\xAB\xC9,B\na\xE7h\x9Ex\xF9\xF6\xB9\x0E\x8B\xE9\x94\xA8\rc\xEF\xBE{\xB1\x9EIit\x8E\t\xD8\xD4RJ\xCC\x9C\x11\xFE\xC9#\xF8\xEC\x9B\x8BV\x0F\xBF\xAF\xED\x1F_\xC6\x9A^\x91\x984@x\xCBU\xEB\x8E\x12\xF9\x9F\xF0\x94?^#3X\x82\xFF\xA5\xBBP\x87\xD8\x82\x17\xB9\x14\x9D+\"\x89\xE8f\xA7\xC6gq\xB2\x80\xFC:\xF4\x8D\xE4\r;\"\xD9,\xD5\xFF\xA7\xA3\r\xF1\x9A\x9Dk\xB8wAO\x7F\xE5}\xAE\xFF\x9F\xB2rC0\x12;\x03\xB2\xBB\xFF\x8D_\xE5\xD6?\xDB\x8C\xB2\xF87K\xE4\xAF\\\x81\xF6\xB7^\xF1\x04\x99\x9Ev\x87\x18\x93\xD2\xD9\xFF\x9F\xBD\xFF\x8F\x91\xE4\xB8\xEE\x04\xF1W\xD5\xC9\xA9\x9C\x16\xBFS\xD5-\n\x1A\xAC\x04\xAA\xBB\xD9\xFC\xB28<\x91\\\xCB\x074!y\xBB\xD8,jJ\x141\xA4Ijwa\xE8\x04\xDA\xD8\x15\x88[\xDD\xAE\xC4\xB5o[\xE4h*\xA7\xBA\xA8.\x8D\x88\xE9\xF1H^\xF8\x0F\x9D\xC0\xA3t\xB8\x16\x05\xC8\x02\xCE84\x0E\x86\xAFE\xCD\x91c\xDF\x824\f\xFF\xE13\x8CEi\xCC]\xB6u\xC0\x90\xA0\x05\xB8E\x96\xAA\x0F\x19\x91\x19\xF9\xE2gFfW\xCD\x8C\xEC\xF7A\"\xA7&+:\xF2\xC5\xAB\xA8\xAC\xCCO\xBC\xF7>'.~\xEFD|\xFDy\x89\x85g\xBC\x14e\xA9\x8B\xFC\xD2\xFD=\xAD\xDA\xB6q\xFE\xFFw|,av\xB3t\xE2\x7F}IZ\x13\xBF\xD1\x10~\xF7\\:\xFFO$\xD2\t\xB7@\xE5\xED\xDC\xEB\xCF\xCF\x8C\xBD\xB1\x8C\xE6\xA6a\xFE\xB7\xC5\xFC\x8F\xAF\xFF\v\xDA\xF5\xFF\xA3\x17\xFF\x9F\x8F\xC6N\xFB\xAB\xEF\xC6m\xFE*\xCA\xDA\xFCUr\xFD\xF7\x9B\xFF\xBB\xEA\xFC?\xF8\xE9\r>\xFF\xBF\xFB\xAE\xEA\xFF\xE3I\xDA\x17\xBE\xFEl\xAF\xA9\x97t\xBB&\x85\xEE\xFF\x16\xFB\xE5}\x84}\x89\xE2\xEB\xFF\x82z\xFD?\xD7\xFC\x8F_{*~\xC4>\xC7Z\x9E\x8B\xB26\xFC\xC5\xB9f\xEE\xFC\x8F\x9F*\xFE\xA7\x85\xEC\xB3H\x06\xF5\xBE\x17n\xE8\xF9\x0FcQ\xAE\xEAO\x93\x9B\x87\xFF\n\xA0N\x97\xFF\xD4T\xFD\xFF\xBF\x99\xEF\x7F\xE2\xF9\x7F\xD9\xE0\xFF\x87\x01\xE0\xD1K\x01\x9F\x8A\xEF\r\xD5O\xED\xBD\xB7.\xFC\xBC\x1E\xFF\xE8\xBFw\xC7Hi\xF3.{X\xD8\x7F=\xEF\xFE\x87\xC5~|3\xC9\xB0\xCB\xE6\xFF[W\xE2\xC7\xBA\xDF\xA5\xF2;\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81\xF0\x0F\x02\xA3\xAD\xCB\xF1>\x02\xA8_\x1Em]\x8E_\xA4\xC7\xC5\xC6\xDF\xFA\xD9\xD66\x00\xBC\xCB\x1A\xBC\x1Be=\xBC\xBB\xB5\r\xF5\xEDw\xD9\xBBj\x9F\xE9>C=\xEEM\xFC\xEFg\xA8\xB7w#o;#\xC0vf\x96\xB3\x17\xEFX\xFA4\xDA\x99tU\xBF\x8C\xED\x14}&\x06\x03\xD8\xFA\x84z\xDC'\xB6\xB3\xBB\xB9\x1F\xEF#\x80\xDA~7\x02\xBE\xC5\xAF7\xF7\xA1\xB6\xCF\x0F\xE2\x11\x05Q\x87\xED\x01\xA0\x13D\x9D }\x97\xBDN6\xFE\xD6-Q|\xA2Y\xD6`\x16\xD90\x1B\x1F\xDFf{\xF1\xB7\xA7\xE2\xFD\x10\xC4\x1E\xE1\x14\xDB\x12\xDC\xC2\xFAy\x1F\xDA\xDB \xDB\t\xD8Ndy\xFCb\x1EY\x98g\xE7z-\x82Z\xDCf\xBD\x86Z\xD6\xA2uvd\x9D\xFD/\xDE\xF3>\x8F\xA1}\x8A=\xB6!D!\xDB\x03@\x18\xEF#\xF1:\x8C\xF7\xFC\xA04\"\xE1\xABS\xE1\xF0|\x98\xBA+\x18\x9EJ\xB7\xF3\x00\xE7\x83\xE1\xF9[\xA2\x1D\xA3\xAF\xDE\x17\x1F\xDFa{\xF1\xB7\xC2W\x10\xAA^\xED\xB0-\xC1\x07-\xBE2\xF9\x7F\x9Dy&v\xC8\xFB\xA2\xCC\x00\xE1+\xF6\xD6N-\xDA\xB1\xF9\xEAX\x14\xFB\x8A\xED\xC5\xDF\x8A\x8F\xB2\x83\xED\x14\x9F)\xFB\xDF\x00\x00n\xB5\xDA\xB9\xCD6\xB3\xFF\xC3\b\xF8\x16wb\xF5\xFF \xF5\xD5\xE0\xDE\x8D\xF0\xDE\xF4\xDD0\x1A$\xDBF\b3a\xB8\x11\xE2\xF9\xFF+9\xF3\xEA\xBC\xF0\xFF\xBD\xEA\xFC?\xCF6\xC3\xFC\xFFX\x8E\xFF\x91\x9D\x11`;\x01\xB8\xA9\xC0\xED\xC4\xF3?\xCF\xCE\x9D\xF7%\xF3\x7F\xE7c\xB6\x195\xB3\xA2\xCC\xFF\x7F\x963\xFF\x07\xE9\xAC\x1B\x1C\x05\xE0\x1B\xC0\x05n'35={\x8F\xCD\xFC\xBF\t\x93\xF63\xE1\xEE\xF3\xE1n\xFAn\xFCY\xF0\xED\xF9\x10n\x8E\xF7\x1F\xDCh\x8A\x11\xBD\x8Cl\xF8\x95\x8D&\xCC4\x7F\x85\xBD\x9B\xF4\xBC\xC1\xFAd\x9E\xDFU\xBC:\x13\x7F\x9A\x8A\xFF\xF5>u\xD46\x90\x9D\x11`;a&Lf\x0E\xB3\xF3VK\x9FF;\xEF\x8D\xB2>\x05D\x9F\xF1\x7Fn\x0E\x85\xFF\rv\xCE\xC4}\xCA\xFE\xBF\x00\xA9\xCF\x0Fv\x81oP\x1F\x1D\x85\v\xC0\xB6\xA3i\xC3\xE5+\xEC\x93z>\xEE\x9F\x1B\x1F\x7FG\xD2\xCE\xE3\xCF\x82o\xEC\x8B\xB3\x1B\x85\xCB\xCF7\xC5\xD9\xAB\xC8\x86\x97\x9Fo\xC2\xCD\xCD\x97\x9F\xCF\xCC\xC8\xFAL\xBE\x89\b7\x87|D\x89\rhDU\xA7\xFFe;\x01\xDB\t7\x8B\x99\x13\xDB\xB9d\xE9S\xB7\xF3}\xEC\xAF\xB2>A\xED\x93\x9F\x19\x00\xEE\xB6\xD9ys\xDC\xA7d\xE7\xD6\b \xF19>~\xF0\xFA(>R\x1F\xC5o\xF1\xB1o\xED\x89\xEB3\xFF\xF4\xBB\x9B;\xCF\x1A\x9C0\x8C\x7F\xB8a\xB8\x8C\xCE\xDEu\xFB\n\xCD|w\xCB;\xFC\xFB\x8C\xA4>\x9F56fv.\x95\xED\xD3\xF2\xC5\x8B\xEFg\x8A\xF6\x99\xDC\v1;\xBF\x1CwrAo\xD9\xE4\xD7gv\xBF\x04\xEC\x1E\t\xA2\x81\xF8q\xE9\xF6\xC3OAkn\xE6\xED\xF8tA\xDCU[\xB4\x94gu\xB7\x1F\x02k\x99}\x7F--\x19Z\x80Z\xB6q\x1B\xE7\xB8d;\x01\xDB\t\xB2\x9Dk\x96>\x8Dvv\xA3\xACOs\xCB \xDE\xD9\xFA\x84 n\x89\xED<\xCA>\xAF\xE4\x83cv\xB2\v\xCE\x88\xF7\t\xDCN\x86\x056\"vya]\x04\xD0\xDD\x1C<\x93\xBE\xDB\xDA\xDC\xFF2\xB4\xE6\x820`w\xAD\xF3\xF5Q_\xB4\x94\xE7@+\xEE'n\x99}\x7F--\x13\xFF\xA3\x96\xFD\b\xEC-%HvF\x80\xED\xE4g\x0F\xD8\x90\xE7\xEB\xA3\x9E\xA5O\xA3\x9Da\x94\xF5in\xC9\xFCi\xEB\x93\xBD+\xF9?\x04\xD5N6\xFF\xB7y\x9F\xC0\xEDd\x18'wJY\xFBV\x10\xAE\x89q\xF5\xC3\x87\xCE\xFE\xF0D?\x9C\x85\x17 \x80\xF9j#@^\xC5\xA7l\xF5C\xA8\xC4-\x95{0\xBDe\x8C\xCA\x0F\xB1\xFF\x034\xAE\x96\xFBA\x11\xDB)&$:\xFB,{k\xBE\xDA\xA8Z\xFA4\xDA)\xFCom\x19dW\x1E\x83\x9DA\xDCR\xBA\xCE\xEF\xAAv\xC6\xA6\x06M\xD6\xE7\v\x10\x84\xFFD\xBDS\x8D\xF7\xAB\xF1=\xC0\xFE\xEA\xC6\xE0\xBEt\\\xAB\x1B\xFB\x9F\xF8\xE4\xCD\xED\x07\xDE\xFE\xD2\xE6q\x98\xD9\xEF\x9E\x1D\x06\xA2e\xBA\x17-\xE1H\xDCR\xF1\x95\xDE2\xC6\x91\x9B\xF1\xF5'@mV\xA3|\xFF'vF\x80\xED\xE4g\xFF\x12{\xAB{vX\xB5\xF4i\xB43\x8C\xB2>\xCD-g\xF6\x85\xFF\rv\xCE\xC4-\x95_\x00\xC5\xCEO\xB4\x00f.\xB0>\x8F\xC3\xCC\xDB\xBF\x19\xC9\xFE'\x10\b\x04\x02\x81p\xED\xF9\xFF\x94\xA5W\x18u\xCC\xD2\xBF\xEB`\xBF9\xAF\x9E\xC7\xFC\xEB}v#u\x9F\xDDQ\x8BG\x18\x9DQ\xDFL\xF9s;\xA3n^wH\xDF\xC5#2C\xE6\xF3sF\x04\x90?\"\rxD\xFC\x0EPg\xD41K<\xEBb_Af\x143\xE69\xD0\x18]\xDC'X\x9F|9Okc\xD4\x05Q\xE3`\xD4\xD5\xB3\xE3w\xF1\x88,\xD8\xB6\xAC;\x18G\x04\x1E#2\xDFK\xF3\x11\xF1>\x97\xA3\x84\ns\xF8\xDF\xB4J\xB2\x93\xB2\xB5\x06k\x97\xBD\xFD\xBF<1\xFF\x8B5\x02\xA8i\x1EH\xD7Sr\xFD\xBFw-\xFD\xBF\xCC\xB8\xB2\xE60\xDER^\xF4\x14T\xD9&[\xFB\x98\xC6\xA8\xC3M\xCD\xF8\xF8s\x88\xD1\xEDu\x84?\x9B\xA8\xE5r\xAF\x03U\xB6\xC9\xD6\xF2\x96\xB7c\xDB\x94fq\xCBF\xDA\xBEQ\x897\x8E\xF85\xB0\xAD\"\xAF\x11\x84\xE6u\x1F\xBER\xE0\xE1\xFFJS_w\xD0\xFBL\xF9|\xB3\xFF+9\xCF\xF2\xD9\x88\xB8\x97\x0E\xA2xKx\xB9\xDE\x00\xAAlK\xF1\xE9(\xE3\xA0\xC6\x12\xFB\x14\x9B\xBA\xD6o\"?\x0F\x84\xE7qK\xBDO\xECyA\xC92\xFF?\x1Ao\x18\x8C\xD1\x8DGT\x1F\x1D\xBC\x9E\xF2\xB7\xEC\xB5\xC2\xE8\x86\xD9\xBC\x92\xED\xD4\x9E7\x9D\xF3_\xE6\x93m}F\xFA\xF74\xF3\xBC4\"\x1DhD\xBA\x9D\xE3\xAD=\xA8\xB3-\xC5C\xB6\x11\xB16\xE3\xAD\xAC%\xE7\xB4}\xFA\xE4\xFE7\xD8\xC9\\*\xCDG\xC6\xA6\xB0\x96\xAD \xDE\x12\x92\x86\xF1+-\xC8\x8E\x00\xA0\xB37\x8C6\xA4\x98\xF7\xFE\xFD\x85\xAD}>?\x95>\x0F\xB6\xF6\xA1\xBE/\xDB\x99\x8Dh1g\xFE\xA3\xB1\xBB\x19u\xC8\xAE<&\xF6\xBB\xC9\x8E7\x11\xA7\x1D\xE2>\xB5\xD9\xA2\xAE\xBC\x80\x07\xF3y\xB0\xDBJi\xB0V\xB6BQ\xBB\xA0\xFB\x7F|6\x14^\xD2\xFBl\x9C\r\xBD\xEE\x7F\xAA\xD2\xFC\xB7\xF5\x19\xF7V\te;\xE3\xFD\x9C\xC7\x88\f\xBF\x0E\x1A\xA3\x8EY\xB2\xB5\xC8\xF2\xB7\x8C\xC9\xC4\x8C:\xE7\xB4\xF5\x96z\x9F\xB7\x83\xA3O\x99bd\xB7\xA3\x01(+\x14\x9CQ\x07\xCC\xA87\xD8\xD9\x1B\x96_@l\xE7\x92\xCB?\xD2\xD9\x93>m#B\xE0s~\x0E\xF2\x7F\x7F+h\x8D@p\xDA\n\xA3\x8EY\xE2\xB1\x8B\xFD\x869\xA9\xA5k\x8D\x00\xF7\xB9\f\xBE\x8Cz\x00\xA6\x15\n\x13\xA3\xFEA\xD7\xBA\x83d\xE7\xDD\xFE\xFEw\x8FH\xF3\xBF\xCFZ\x06\x80\xC4Q\xF3\xD7\n\xA3\x8E}\xE5b\xBF\x01|\x98\x7F\xBDO\xFEm\xB50\xEA/\xD8\xFC\x9F\xADP\x98\x18\xF5\x86c\xDDA\xB6\xD35\xFFe>\xBF\xE1\x1E\x91\xC5\xFF\xEE\xB5\f\xBCF 8m\x85Q\xC7\xD7\n\x17\xFB\r\xE0\xC3\xFC\xEB}&\xC7\xCD\x8C\xFAq\xDD\xFF\xEA\n\x85\x89Q_p\xAC;\xC8v\xAE9\xFC/\xF3\xF9\v\xEE\x11i\xFE\xF7Z\xCB@#\"\x06\x86@ \x10\b\x84k\x8F.zb\x12\x8C\xBA\xB2:\xE0\xB5\x8E\xE0\x8C\xCF\x17\x01\xF6\xF1[[Y\x03c$?\xA4Q\xF7\xBFx\xA4X\xC6AQ\x9BsG\x84\xEDT\x98\x7F|Fl'F|DN\x10\xC0\xBD%}F\xA1\x83%\b\xBC\xC7\xE2\x8E\xCF\xE7\x07y\x83\xE5^G\xD0\xDD\x98\xF7\xE6\x1C\xE92cP9\x05z\xFBZl\xF9\t\xD6\xE0\x04\xB2\xE4Do\x1B\xAA\xDB\xF1>\xE3\xFD2\xB6vy8\x19\xFF+v*\\nb'\x7F\x96GvJO\x1C\x11@56Ua]\xEE@\xFBi\xF8?\rz\xB7\xF9\xFF\xD4\xF20\x1D\xD70s\x17\xE7\xBD\xE3}\xEC\xFFSl\\;\x00p\x17ky\x17\xB2\xE4\xAE\xDE\x0ETw\xE2\xBD\x18\xD7\x95\x8E\x91Y:\x9C\xFF\xD7\xEF\x88d_1\xDC\xD1[\x87\xEAz\xBC\xCF\xFC\xBFg|\xA6\x8E\x8FT\xF7\xE2M\xFC-\xFA4\x97\x13\xBE\xB4\x81\x18\xBC\x84Q/\xE5\x7FW|\xBE\x88{\x0F\xC5\xFCgnoGi\b\xA82\xAF\x026\xFF\xDB\xDB\x82}}\bY\xF2P\x7F\x1B\x82\xEDxo\x9A\xFF\xED)\xCC\xFF\xB6{\xFE#;1\xE2#Al\xAAq\xFE\x9F\xE4,\xE8\xEB\x19\xD9+\x18\xF52\xFEw\xC6\xE7\xC3L\x92\xD9qo\x04\xCBot\x84\xDB\x07Q\xBC%~\xEBw \xE8\xC4\xFB\xB8\xA3\xF8\xD3\xBC\xFDO\x9A\x00p\x915\xB8\x88,\xB9\xF8\xB5&\x1Cm\xC6{1\xAE~\xE6\x8D\xC1\x84\xE6\xFF\x1D}\xC9\xCE\xEC\xF3\xC5v\xF2\x96\x9Fj*\x16&vF\x00GcS\x15\xFF\xEB}\xDAg\xB5\xAF\xB5R|>\x02\x8F\xA5\x87\x9B\x93\x04\x87\xDD\b\x96\x07\x83\xCC\xED(\x92\x7F0\x18@8\x88\xF7\xE9\x13\xFA\xEDkM%\xF6;aozM\xA86\xE3\xBD\x18\xD7`\xE0bw\xCB\xCD\x7F\xC5N0\xDA\t\x8A\x9D\x18\xF1\x91j\x13\x13\xDAw`\xCF\xA71\xFF.\xAF\xFA\xFB\xDF'>\x1F\xB2O\xBF\x91\x1F\xC9\x0F\x0F\xB6\xC03\xEA\x1E_s\xBA\x13\xF2\xBFb\xA7\x03\xD8\xCE\xC2}\xA2UQ\xC1\xA8\x97\x98K\xEE\xF8|\xC1\xD2w#\xE8\x88\xA8{\xD3\xBA\x03\x8E\xBA\xFF\xD4I\xDF\x8C\x83\x8Ee\xDD\xE10P\xECt\x9C]\xB2\x13\x94\x99 \xADzt\xB45\xFA\xEE\xE6\xC0\xC1\xD2\x1Fx\x8F\xC5\x1D\x9F/X\xFA\xF9\xF8\xDB\x97F}\x839\x92_\xCC\xFF\xAF\xB5|3\x0E\x06\xE8.nR\xF3_\xB1\xD3qvl\xA7\xB4\x90\x10\xA9\xF9\x0E\x03m%\xA5\x85\xDE\x15\x8Cz\x99\xB9\xE4\x8C\xCF\x87\x80\xC5\xE73\xFF7\xD0\xB8\x8C\x91\xFCb\xFE\xCF\xB5|3\x0E\x1A\xC8\xFF\xAD\t=\x99*v:\xCE>\xE7\xF0\xBF\xBC\xEA\xD1\xD0VRV7\x062\xA7}\xBC\xDC\xF5\xC7\x1D\x9F\x0F3,>\x9F\x7F\xE8\"\xEA\xDE\xB4\xEE\x80\xA3\xEE+\xADb\x19\x07\x00>\xDC{\x81\x11a;\x1Dg\xC7vb\xC4G\x94U\x0F\xFF|\x07\x02\x81@ \x10\b\xD7\x00\xA2\x06\x0E\xE7\xDE\xBDo\xE3\xF8\x134\x7F\x92\xC5\x0F\xB3\xCFn\xEE@-\xDE\x9EM\x1F\xB1\xAF\x9E\xCF\x98\xC0\xAB\xDA\xAF?~\x17s\xFB&S\xB7\x95~\xF0^\xEA\xED\xD8^\x89\xE7\x82,>\x1F\xFF\x95)\xE3\x00\x9F1'\xE3\xC0R=)Cu=aY\xAB\xEB\x00p{\xCB\x9FyH\"\x841\xED,3\x9F\x83\x8C\xB7\xC1\xDC\x88\xC2\x96\xA0w1\xB7o2u[\xE9\x07\xEF\xA5\xDE\x10\xF7R\x84K1\xC6<\x0F\xF4\x1A&\xF8\x8C:\xEF\x8D9R\xCE\xD6\x9E\xD0\xB8\\4\xA8N\xD2\x03[\xFB\xB8\xA3\x94\xFF\x1BF\xFF\xA7\x81\x97K(RZ\x8F\xC0\xC1q\xD4'\xFA;NZpG\xF1\xFFZ\xA4\xF6\x99\xF4\x16\\;\xFF\xDF\xAE\xF5\x8F\xD7\b\x1E\xEAgk\x04\xA7\xDC\xF3?(8\xFF\xCF>\xCA\x9F\xEC>\x90<\xB6&\xF8@\xE5Q`\xDB\x07\xD2G\xC3\xA5A\xC6\xD274\x96\xBE\xBF\x97\xBD{\xE2kM\xD7)\x8F\xAA\xDF\xA3\xBE\x16\x9F\xDC\x1Fp\x1E\xBBS\xC6\xFFg\x1B\xA2\xFD\\\xF6\x94\xD5\x98\xAB4\x80ms\xA6oqG\xEB\xBF\xD3\xCF\x9Em\x1Fb#zL\xE3\xD2\xD1\xA4\xEA$\xAB\f\x9C{/0\xFF[<\x9E6\x90\xE3\xC9\xB3\xF8\xE4tAa\xED'.f\t\xC7'\x7F\xBA\xE7\xF4\x7FU\xFB\x1Ei\x11\xF2Io(D\xB9(\x97\xCB\x9D\x9C\x8DH\x8E\x8A\xC7|&\x87;\xE3\xE0\xA1\xA8)8R\xF3\xF5?\x1C\fDjO\x91\xEBO\x83e\x13\x04Z0\xBF\x9E\x1F\xD1\xDF\xDAs\xF4\x83\xE3\xF3\xCF9[\xE2<\x02i\xE6GZo\xA8e\xC3\xDB\xFFsx\x05\n\xD19\xFA\x88\xF0\x19\xDD\x19\x07\x17\xD1\xEF\xEF\x92\xDB\x12\xC4\xBD\xFB@dRT\xAC\xF7\x18C\xDDB\xF7\xDD\xC8R\xE4\x9C\xFF(E\xA5\x81f\xBE\x96q\x00x-\xFBW\n\xF0-\"\xE3\x03\xDF\xFF\x982\x0E\x9C#\x922\x0Ez\xD9\x1A\x8De\xEC\xAD9\xF4\x91\x7F\xCA\xDB\xFF\x0F\xA6\xF1*'w\xCD1\xFFJ|\xBE\x8D\xD9\x93\xE2\xF37\x9D\x81\xA9\xA8e\xC3U\xEDGj\xF9\xB8\xB7\xF7\x0F^\xDD\xCFf~\xD6\xE7\xA8\xDB\xEF\xA8#\xB2eFXF\xB4\xE0b5S\xFF'\xDC\xBB\xAF\xB5\">|-2\xC7\xFC\x07\xE9\x074v\xB2\xF4z\x1E\x81\xFD\x94\xF9\xB9\t-\xFE\t\xA2\x96\xF3PlDm\xA5Os\xC6\x01x\x8E\xE8ngn\x02\xFB\xA9\xFAa\x12\xC1\x92p\xEF\xDE\xB3e7\xF3\xBF\xC6\x93\xF3\xF8\xFC\x17\xF4\xDF#w|~\xD5\xDB\xFF\xE0\xA8\xF6#\xB7\xCC\xC9\x893\xCD(\xA9Os\xC6\x01x\x8Eh\xC9\x99\x9B\x00,\xEE\xBD\xCD\xDFH\xB8w\xFF\xABe\xC2~\xDFg\xE0\xC9Y|\xFE\xE6q\xDD\xFF\xEE\xF8\xFC\x1C\xFF{0\xEA\xF1\xD9\x95\x96\x05\xE7\xBF\xDA\xA79\xE3\x00<G\xB4\xE6\xCCM \x10\b\x04\x02\x81p-\x81yi\x8E\xABz\x8C:\x7F\xFC\xD8\xBA\xAC\xFCm\tF=+\x89/3\xEA\xE2\xB9\xC3\x1F\xFE\xB5\x86\xA2A\x18E\x10E\xAC$9{-\x8E'G\xD8\v\b\xC3\xDE\xA0)\xAA}\xF6P\x9F\xF1\xF1\xB0\xC9\xDF\xCD\xFE\x16\x80w\x15\xA1\x96\xC9\xEB\xD0\xB7\xB6!\xE7\xA51#\xBD\xA4\xC5H'<C\xAFc\xE4\xA9\n1\xBA\xF22A\xC6\xE8\xF2\xFF\x16\xF2\xFF2\xAA\xB5\xB2\xEC\xAC\xB52\x1D\xFF\x1F\x8B\xF7\x8CY\x89\x10\x97\x9B\xBC\x0E\x8Fy\x8E\xE2\x14\xE3\xA5O\xFD\x03\xF7\xFF\xB1h\xC8\xFD\x7F,\xDA;&\xDC\x15\xED\x1DK\x8E\xB0\x17\x10\x1E\xEB\rV\x00`\x83\xF5\xB6\x81\xFA\xDC\x18\xAC@\xB8\xB2\xC1\xDEM\xFFv2\xF3\x9FGq_\xD4\xFC\xDFA{\x0E\xCCf\x17\xF6\x7F\xCA\xA8\xCFA\xB2\x81\xCC\xA8\xF3\xFF\x96\xF6\x7F\xDBg\xFE\x0F\xA70\xFF\xA3\xC3\xCE\xFF*\xE2\xA5%N;\xAD\vdd\xB3\x8B\xCF\x7F\xC0\x8C\xBA\xA8\xE1#\xB3\xCA\xA3b\xFEg\x11\xF8\xB6\xF8|\x9E\xC1\x91\x18\xFE\xE6\xDE\x19~\xFD\xA9\xED\x9D\xD9\x8C_s\x9C\xD9\xDCK\x8E\xB0\x17P\xDB\xDB\xD8\xDC\x16\x9E\x7F\x06\xF5\xF9\xCC\xE66\xD4\xB6\x9F\xD9\xCC\xD6=\xA3\xCD=\xE1\xED3\xA8e\xF2\xBA\xB6W\xFA\xF7\x17{^\xADx\xA3\xF0K\xDE\xBE\xE2k\x04`_#(q\xE7\xC0c\xFE\xF5,\x06\x1E\x9F\xCFW\x91\xD2kB\b\x11\xF7\x8C\xA4q\x90\xE4[EY)\xB3\x1E\x9B\x8D\xCFh\x19\x07l\x966q\xA5\x9D\x88\xCD\xC63z\xAD\x15\xB4\x86\xE2\x83\xA5\x9E\x9A;0\xB6\xC4\xBDc6\xBB(\x16P\xC5\xA1,\xE6_\xA9\x8A_\xF0\xFE\xC7?>?\x92\xF3\x1D\x1C\x1A\x07=\xEF:\xFF\xC9u&\x82CF\\s\x9E\x1C\xCF\xE4\x86eE\xA9\xDB\x0F5\xE6\xD3\xF7,\xF7\xA7\xBE\xBD_\x8A\xF9\x1FI,}P\xCC\xF2\x8ES\x8F\x003o\x91T\xE7\x7F`\xD3\x0E\x88\xAF<\xDE\x1A\x07\x91\xADe\x04\x85x?\xCE\x93\xEB\xFE\xB72\xEA\b\x8BP\x8C#m\xB15\x9A,\xE6\x1F1\xEA%\xE6\xFF\xC0\xBB\xD6\xD0\x19\\\xE7_\xD68\x00\xA4q\x00\xF5\xD13\xDE\x1A\x07gl-#\x8D!w\xFB\x9F\xCD\xC0\x13\x91\xD9\xFF\x06F\xBD\x94\xFF\x955\x02\xBD\x86O\x89\xF9\xDF\xF0\xAE5$\xD5\xF9\x975\x0ER\xED\x80\x17\xE2\xB3W\x1B\xD5Ck\x1C\x14\xF5?\xE7\xC9\xDB-\xF5Zme\xD4\x0F1\xFF\xC5\x1A\x81^\xC3\x07\xA0x1\x1C\xFFZC\xB8\xCE\xBF\xACq\x90h\x070\x8D\x03\xA8\f\xAB\x87\xD68X-x\xFD!\x10\b\x04\x02\x81p}\x91\xF0Q)\xA7\xC7)n\xCCS\xA5\xF72\x93\xE0\xC9\xF9q\xF4\xAE\xDE\x9B\xF5\x9E9\x90\xEE\x90[\xF8x\x90\xDD\xC7\xB6\x02\xE9\xBCQdy..\xEA%K\x9F\t\x89g\xB73\x83l\xE7\x94\xFDogt\xC5\x1E\xF5s\xFE\x1F\xB5\xFF\x19\xCB\x9D\xFAJ\xD0\xDD*\xFB\x1D\xAE\xF4\x06{\xC2W\xD8c\xE7\x07{\x10\xEE\x9D\x1F\xEC!?\xFB\xCE\xFF\xF3\xA5\xE6\xFFj\x94\xDD~\xAB\xFE\x9F\xD9\xC7\xE7==\x05\xFF\x9F\xF6\xF6\xBF\x14\xF3\xF3\xCB>\xFF\xD9\x93\x1A\x1F\x11\x1EG\xFC\x944\xB3/\x9E\xE3V\xA3V\xE2%\xC6\x95\xE9\x19\x07\xA7\x87\xE5\xFD\x7FZ\xE3\x87Oo^\x86\xDAe\x9B\x9DR\xF4\xE3\x8Cdg\xE6\x13F\x83\xF3\xFE\xCFD\x8C\x1E\x97y\xF2\x94\xA8\xDC;_\x94'\x8F4\x9E\x9C\x1DO\xF6E\xAF\xFF *\xA2\xA3\xD5\x04\x94q\x90\xFC\xB7>:=T\x19u\xD0\x98\xAE\xA28\xED\xC88\x90+\xA2\xB7*\v\xC2\xF3\x12WYYH6\xF5\x93\r\x01\xC2\x8C\xD3\x16\v.\x82'O\xBF\x00\xFE<\xF9\x86\x95'\x0FAR\xE2Hf\xFE3\x1E>YM3\x0ET\x96I^M8H\xE3\xB1m~\x1E\x97\xE3\x8D\x1D\x19\x07\xF5=\xDDNC\xDCo\xDD\xBC\xEA!\xF1\xE4\x11<\xBBiK\x82+\xC2\x93G\xBE<y\xCFC\x85Y\\>\r\xAB\t&;\xAD\xD9\x01\x87\x803\xE3@\x9A\xFF\xF3\xB2\x9D\xF9\x1F\xEC\xE6>\xD4.\xA0\xCA<\xDB6\xF6{\x02<y?\xD3\x0E\xE8\xE2+\x8F\x8F\xFFkR\x1E\x81M\xB9\xA0\x1B\xE5\xC5\xE7\x1F\xC2\xFF\xD6u\x07\xEC\xFF\x9A%\xDF!PW(\x10\xA7}!\xAB\xCC\x93\xE6\xED\xAA\xEC\xF7Dx\xF2M\xA4\x1D\x80\xAE<>a\xD78>\xDC\xA1\\0\x9F\xAA\xABX\x15\x01J\xF9\xDF\x99q \xFB\x1FB\x97\xC6\x81\xCEQ\xC7\xBE\xDA\xCE*\xF3\xA4\t\xA1*\xFB=\x11\x9E\xBC\x9Fi\x07t\xD1\x95\xA7Ud5\xC1TA(\xAB_4_m\x80S_\xF8\xC4!\xAE\xFF>\x8A\x00\x8A\x9D\xD2\xFCW\xEA,e\xBE\xBA\x94U\xE6I\t\x7F\x95\xFD\x9E\bO\xBE\x81\xB4\x03\x90\xFF\xFDb\xE3\xA5>e>?\xAB_\xD4=;t\xD7\xDBi\xB7\xCA\xFB\xDFG\x11\x00 ti\x1C\xD0\x1A\x01\x81@ \x10\b\xD7\x15\x19S\x17\xC8\xF7T\x1AS\x17\xF9<\xED\x82/\x93\x93\xCF\xE8\x9A\xEC\x04\xFD\xDE/@\x0F\xC6:\xF7\x1B\x188jq[\xE8\xE6\xA8U~\x12\xB5T\xE2x\x05\xF9\x19a\x8D\x03\xA6\x14 D\r\x84v\x00\x969 \xFFO\xDC\xFFj\xC6\x01\x1FH\x18J\x11\xD7(L\x1D\xFB\x1F\xDF\xA9\x16\xF5\xFF\xC6\xA1\xFD\xBF\xEE\xED\x7F\xD5N\xBB\xFFW7\xF6\xF55\x02\xA3\xFFOO\xCC\xFFr\xC6\xC1\x1E\vG\x0F\x8FI\x19\x07(L\x9D?\r\xE9\x8A`\n\xA3\x9Ek!\xF6\xDE3Q1Fw]cT\xD67\xD5\x8C\x03=\x06L:\x8E\xEC\xC4\xDC\xBBqD\xE2\xB1H\xF2\xFCd\xE7\xFF\xD0w\xFE\xCBO\xCD\xF9O\x7F>\xEFV\xA3bO\x94>\x19\x07\xFEv\xB6d^\xDA\xD1\xF8\xB4\xED\xEC\x06~RZ\xCBP\xF2\bD\xCC\xFF\x99H\xCB8\xE0K'\xB5=)\xE3\x00\xA7\t\b.\xBA>\n\xEC\x8Cz\xAE\xFF\xC7\x87\xF0\xBFO\xC6\x01\xB6dQ\xB1S~wu\xCB\x9CS\xA0\xD4\xF0\x11k\x04>\xBC\xAB\x14\xF3\x0F:\xF3,\x96K\xF4\x8C\x83\xB4\x18\x8E\x94q\x80\xD3\x042\x8Dc\xCC\xD4)+J\xB9k\x16\xD8{\xEFF\xC5\x18E\xAF\x8C\x83j\x96\xA3\x84[.\xF2\xE3\xD5\x86\xF1;b\x89\xF97|\xFA\x85\xD62\x1C}\xAA\x19\x07|%\xA5\x86\xCD\x1B\xA2=\xAAx\xC3\xAA\xF7#N\xBB\xA30\xD5\xEE5;\xCC\xE8.E\xC5\x18u\xAF\x8C\x83W\x1D\xFA\xC2r\xD4\xAB\xC4\xBD+1\xFF\x80\xF5\b \xF2\xBD\xBA*k\x19\x8Eu\x07-\xE3\x80\xF9\xBF2\x922\x0E4F\xBD\x9DV\xEFW9m\xC4\x94~\xD0\xDB\xFFw\x17\xF4\xBF_\xC6\x81\xB9\x82\x90^\xED\x070\xF7\xAE\xC5\xFCc=\x82\x03\xE7\x1A\x01\x86\xB2\x96a]w\xD03\x0E\xF8JJ\xAD#e\x1C\xA0\vf\xA0)\x02\x1B\x19\xF5\xDC\xF9\x7F\"*?\xFF\xFD2\x0E\xCC\x15\x84L\xD5~\x10\xF7\xAE\xC6\xFCg5|\xE6\xED|\xBE\xE9\v\xE0Xw\xF8!\xF6\xBF\x9Aq\x90\x14\xC3\xECH\x19\x07\xE8\x82)i\xEC\x9Aj\xF8\x88#\vn\x1D\x164\x805o\xFF\x17\xC980W\x102U\xFBA\xDC\xBB\x1A\xF3\x9F\xD5\xF0\x11\xD7\x1F\xAF\xCA<\x91c\xDD\xE1f|\xFDQ3\x0E6~\x9F\x99w\xAF\x94q\xC0VR\x88{!\x10\b\x04\x02\xE1\xDA\xE3\x9D-o\x8D\xDD)T\xED\x93x\xF2(+1\x94\xD5\xF0\xA9'E~\x8A\xDA\xA9\xD7\x05\xCAz\x16c\x8F|\x9F\xD33E\x00V\xFC_\x940\xCA\xEA\x17\xA5U\x8C\xDCg\xC7\xE0\xE7-\x10\xC9<\x05\xFFK<\xB9\x16q-H\xC5(*l\xA7\x1Eq\x9D0\xE4\xA8\x86L\x99\x8C\x03\x99\x91\xC9\xF8\xF9\x94\xA5\xF7_MH\xC6\xE2_\xF1f8\r\xFF\xAFlD\xEC\xBC,\xEF@\xC98H6fX\x81\x8C\x03w\xCE\x05ZS(\x93q\x10$\x19\x07\xAB\x91\xEC\xFF\x94\xA5\xF7_M\xE8\xD1\xFC/\x91q0\xB3\x8F\x97\xA4\xD0\xFAH\xF2\x9Dpg\x1C\xE8\xFE/P\xF1f\n\xFE\xDF\xD8D<\xB9\x96q H\xF53\x11\x9C/h\xA7\x9Eq\x90\xF5\xAC\xCC\xC0b\x19\x07-\x9Eq\xC0\x99\xD5\xECj\x94\xB2\xF4\xEE\x8C\x03\x8Cg\x93\xB3\xFBW\xBC\x99\xC2\xFC\x97xr-\xE3@\x90\xEA\x11\x14\xC98\x00s\xC6\x01\xE2\x10\xF0\xF5\xA7X\xC6\x81\x1C\xB4o[\x1F\xF1\xC9\xEC\xA8\xA2O\xBF@\xC5\x9B\t\xFB_f\xD4\r\x19\x07C<Wo\x9C\x8C\x83/\xEBv\xB2\xFB\x1F\xFF\x8C\x03\xCEO\x16\x88\xE4\x9F\xC6\xFC\x97xr5\xE3\x003Z\x85\xED\xB4\xCC\x7F)\x8B\xA1D\xC6A\xAAn|T\xB73\x80\\E\x00\xDD\xFFE\"\xF9'\xEF\x7F\x89'\xD72\x0E \b\xF9\xA4\x9A/n\xA75\xE6\x1F\xB5,\x93q\x90\xAA\x1B\x7FY\xB7\x93\x99:\xF6^M\x18'\xDF>\xFFH\xFE)<\xFEa\x9E\\\xCB8`\x8C\xFA\v\xDC\xFFE\xED\xB4\xC6\xFCK*\x03P8\xE3 U7\xE6\xEC:Z\x1Fy!\xB9Hy\xAF&T\x91\xFF\xFD\"\xF9\xA7\xE5\xFFL5X\xCE8\x88\xBF\xD7\xB5\xE3|\"\x15\xB5\xD3\x1A\xF3/\xA9\f@\xE1\x8C\x83T\xDD\xF8\x13-\x90\xD6Gj\xC7\x93\xE8\x17\xEF\xD5\x84*\xA9\x00\x10\b\x04\x02\x81p\x83\xE1]M\xD9\xD6Zi\x1F\xF3\xE4\x87\xD4\xD8\xC5\x8C\xBA|v\x1BF\xFE\x11wu\xF3\x1A\xC1>\xFE\xAB\xBA\xAA\x1D\x80-\xEC\xEAuV\x91\x9D\xFA\x1AA\xB9\x11I\xCF\x86\x00\xC5*\xDEx\x7F\xBE\xB6\xDA8S\xCC8\b\x9B\xB9#\xC2\xA4+\x1E\x91\xC1NLLh\x1C\xB5\xA3*\x91'\x93\xB0a\xF1\xFF\xE9)\xF8\xFF\x1Ae\x1C\x84O\x19G\xB4\xEE\xED\xFF\xD5\xC8\xD7\xFF\x8E\xAAD\x9E\xFE\x7FF\xF3\xBFW\xC5\x1B\x7F\xFF\xE7\xC5\xE7{Z{\xDA?\xE3\xA0\xB6m\x1C\x91\xF4\\Y\xBB\x9Cl\xF2\x88\fv&uVM\x19\x07y9\x14>\xFE\xC7\xD1\x83\x05*\xDEx\xFB\x1F\x8F\xC8\x1D\xC9\x7Fzb\x19\x07M\xE3\x88d\x96^\x8E$/b\xA7\x94q\xB0\v\xF9\x19\x07\x90\xCF\x0E\xE11zU\xBC\xF1\x7F\xA66k\xECN3\xE3\x00\xFD\xFE\xDA2\x0E\xA0\xBE\x9Fl&,\x82\xF6Y\x183\x0E\xFC\xD6\b\x00|\xD9\x89\xA2\x15o<\xAF@\xC6\xDA8S\xCC8@\xAA\xD9\xB6\x8C\x83\xF8\xEB\\Q\xBF\xD4F;\x93\xCF\xC2\x96q\xE0\xCC\x0E\xF0\xF1\xBF^\x91\xDE\xAB\xE2\x8D\xB7\xF7-\x1A\xBB\xD3\xCC8\xD0\xFA\xD4\xBF\xD1ze\x1E\xEE\xCF9\xDDN\xBD\xCE\xB6\xB6F\x80\xBCd\xD0\f\xF5\xF7\x7F\x91\x8A7\xBE0k\xECN5\xE3@\x8B\xA2\xF7\xA9\xCC\xC3\xE7\xF9\xAF\xEBv\x1A\xEA\xCC\xABk\x04\xB6\x11\x1Dx\xF8\xFF\x84v\xFD\xF7\xABxS\xCC\xFF\x96>\xA7\x93q`\xF1\xBFV\x99\xE7\x87\xBA\xFF}\xEA\xFC\xEBk\x04\xB6\x11\xF9\xCC\x7F\xA96N\x81\x8A7\xC5\xFCo\xE9s:\x19\x07Z\x9F\x96\xCA<\x92v\xC0\"\x80w\x9D\x7Fu\x8D\xC06\" \xE6\x9F@ \x10\b\x84\x1B\x18\x99\xC6.\x8B\xCF\x97\x8E\xF3:6\x11\xE2\"\xD2'\x85\xB1\xC6Q\xF0w\xD9\xB3\xF9\xDE\xBB\xDE\x91\xFC\xD3\x80b\xA70\xEC0v\x8E\xBD\x19\x92\xA2\xC8*~\x84\xA1\xCE\xFCc-\xD1\v_\x8B[^`\xFF\xBD\x80Z\xC6\xC7\x8F\x86\xFC\xDD\x18G\xC3\x17\xCF5\x01\xE0E\xD6\xE6E\xD42>>\xDB\xE4\xEFN\x0F\x8A\x9D\xC2\xB0\xC3\xD8y\xC1\xE9\xE1o\\#\xFF\x1F\xCB\xC6\x85\"E/\xFC\xED18z,\xDE'\xE3:\xF6\xE2\xB9\x15\x00\xF8\x0Ek\xF9\x1D\xD4\xE7w\xCE\xAD\xC0\xEC\xCAw\xCE\xADL\xD9\xFF+\xC2'\xDF\x88\xE0\x1B_KN\x17\xBF8\xBA\"\xFE\vGW^<\x17\x7F\x17~\xC0Z\xFE\x00\xD9\xF9\x83s{0\xBB\xF7\x83s{\x9E\x1E\xBEp-\xE7\xFF\x90\xE6\xFFD\xE7\xBF\xA8xS\xDBS\xAB\xF7\xCBZ\xBA\x17\xDE\xDC\x13\x96\x18[\xA6\x04\xCB\xDEwX\x90\xF3\x8B\x1E\x91\xFC\xD3\xC076%;\x1D\x1A\x07?\xF0\xB6\xF3BN\xD5\x88C\xF8?\xABx#S\xB2Y\x1D\x1Ba\x83\xA3\xCE\xBF\xA4\x1D\xF0\xA2w$\xFFT\xE6\xBFb\xA7]\xE3\xC0\xDF\xCEox\xAF\x10\x15\xF7\x7F\xD6C\xD7\xE7*\x97\xDFr\xF8\xA2w$\xFFt\xFC/\xD9\xE9\xD08\xF0\xB7\xF3\xC2\xD4F\x91U\xBCQ\xEB\x02\xA9ul.x\xC7\xE7\xBF\xE8\xDDr*\xFEWk\xF8l\x1F\xDE\xCE\v\xDE\fyQd\x15o\x02s\xD4}\xA0\xB7t\xC7\xE7\xD7Gg\xBC#\xF9\xA7\x01\xB5\x86\x8F]\xE3\xE0\xCC\x842#\xE6\x0E\xF5\x05p\xD4\x05\xE2ul\xB4\x96\xEE\xF8\xFCB\xDA\x01S\xF9J\xCB5|&\xA3q\xE0:\xE1\x89\xE8\xB0\xD6Z\xEA\x02\xB1:6\x91\xD6\xD2\x1D\x9F_H;`j\xFE\x9F\xB4\xC6\x81\xEB\x84%U\x06\b\x04\x02\x81@ \\s\xD8\xE2\xF3Sz\xC4\x1C\xCD\xEES\xF1\xC6\x07>\xF5s&3\"\x16\xAB\xAF\x8C\xC8\x1FEk\xFC\xFA\x8F\xAB\x1D\xB4D|T[\x7F;h\x19\x9F\xFE\xDCO\x82/F\xC5X\x82\xC9>\xD7\x9BG\x14\xB4\xDA\xDA\x88\xFCQnD\x17\n\xFA\xDF\x10Uk\xF1\xFF\xE9_\x12\xFFg#\x9A\xD9\xBF\xF6\xFE\xF7\x89\x7Fn\xCB\x1A\xBB*P4;\xF6\x92\xBB\xE2MQkOO\xD6\xFF\xB6\x8C\x03-\x92\xDF\x1F\xCF\x94\x1B\x91\x8F\xFFe\x8D]\r\xD9l\xC1*\xC6>\x15o|\xE0o\xA7?\xCC\x91\xFC\xF5\xD1a\xFA\xF4\xCFa?\xE3\xAD2\x90Xk\xD1\xD85\x98\x1DM\xDEZ\xFF*:\x05`\xCE8h\xE9\x91\xFC\xD3\xF0\xBF5\xE3\xC0\x02\xA5\xE2\x8D\x03\r=*\xDB\x82\xA2\x15\xB9\xC7\x13\xE6\xD5M\x19\x07\xB5\v\x81\xF6\x8D\x9E\xDE\xFDO\xC3{\xD5#\xB0i\xD7&\xD7\x7FK|\xFED\xFD?\xD9\xEB\x8F%\xE3`d\x88\xE4\xF7\xC6\xE15\x0E\xEC\xF3?t\xD5\xB1A\xEC\xF7\xD8{\xFE\x8F\v\xCE\x96\xC9\x12\x87\xE6\x8C\x83\xDA\xB6)\x92\xDF\x17\x87\xD78\xB0\xCE\x16\x9Bv\xAD\xE6\x7F\x88L\xBF\xCA\x93\xB8ZN\xC3\xFF\xEA\x88\x82\xE6a\xFC\x7Fx\x8D\x03;BW\x1D\x1BK4\xFB\xC4*\xDE\x14\xA8\xCCS\xCC\xFF\xEA\x88f.\xAC\x1E\xE2\xFAsx\x8D\x03\x02\x81@ \x10\b\xD7\x1E\x8A\x10m!(\x15o\xA4\xE32\x9D\xEE\xAA d\xBA\xF3\xB7\xE5\x11\xE0r\x07Yn\x82\xA9*\x91\xC8M\x18m].\xA0\x1D\x80\xFA\xD4\xE8\x8B\xCB\xE5\xBC\xE4\xB63\x89\xF8=Z\xE6\xEE7ct\x05\x8B.\x8E\xCBt\xAE\x8D\xFD\xCE\xE2\x8D}Z\x1E\r\xB1\x9DA\xD4a{\x10{t\xBC\x13D\x9D\xF4\xAD\xCE<\vr\xE3\t\xE9\xB3\xA8%\v~\xDB\x16!p\xAC\xF1\xA9xofqO\xB1\xAD\xF8}\xAF\xD3\xCEI\xF9\x1F\xDF\xD3\xBA\xFD\x7FzR\xFE\xDFzM\x8Ch\x84<6z\xEB5\xA8\xBF6z\xEB5~p\xF4\xD6k\xF3[;\x00\xF0\x1Ek\xF9\x1E\xEA\xF3\xBD\xAD\x1D\xA8\xEF\xBC\xB7\xB5\x93\xF5\xF9\xD6e\xC5K\x87\x9F\xFF\x01\x9B\xFF5\x8D\xF9\xE4\xF3\xFF\xF4&\xEB\xB3V\xA6\xE7\xB6\xBB\xE2\x8D\xE6U\x9DUN\xCE^\xCE\xFF,7\x81;\xD9\x91\x9B\x10\r\xC2yo\xED\x80`p\xCCz\xFD\t\x8F\t\xB9\xE4b\xFEg\x8A\x03#\xAD\xD6V\xA21\xA1\n\xA1\x16\xF1\xBF\xC4W\xB8Z\x9E\xF6V\xF8\xC5\x9E\xD7\xF3\b2\xC1\\\x80\xD1^h\xAC\xF3\xAF\xFA\x7Fs\xEF\xEF\x90\xFF\x9Fq\xFA\x7F\xC4\xF3M\x8C\xD7\x9F04\xCA%\xE739\x03\x97\x9D\x89\xC6n\xBD\xCC\xEAON\xC5\x1B\x8DO\xD0y?]\xE1\xF7\x82E7A\xD5\xD8\x95\xD5\x90\xC1\x9E\x1Br&\n{,\xC8\\\x8F\xE47h7\xE0>\x15\xC8\x9F\xBE?\xDCv&\x1A\xBB\x95\xF2Q\xAF>k\x04\xFE\x1A\xBB\xDEy\x04\xD2\x8Crg\x1C\x14\xD58\x98l\xA5w\xB7\x9D\x86\xEA4\xFE\x90+\xDE\xA8}\xEA\xF3_{\xAD\xB7\xBC\xE0\xAE5\x84\xEB\xFC\xE7\xC5\xE7\x8BP\x93\x02\xDA\x01\xB8\xA5\x8AV9/\xB9\xED4)\xE7\xFA\xC3\x95\x1D }G\xBC\x15~\xCF\xB8k\rIQ\xF79\xF1\xF9\x89\xC2o}TD; \xB4\xF3\xC3\xADr^r\xDB\xA9+\xE7\x16\xB9\xF28U\x83\xB5\xF9\xEF\xA3\xF0\x9BSkHZw\xC8\x89\xCF\xE7\xB9\t\xF3\xC5\"\xF9\xED\xFEW\xCE^\xE0\v\xE0:\xBBI9\xB7\xD8\xFC\xB7\xAA\x06k^\xF5Q\xF8\xCD\xA95$\xAD;\xE4\xC4\xE7\xF3\xDC\x84\xEE\xD9B\x91\xFC\xA1\x95\x9FW\xCE^\xD0\xFF\x93\xAD\x9ED \x10\b\x04\x02\xE10\xC8\x18\xF8z\x0EO.\xD5\xCF\xCF\xE3\xDE\xC5\x11\xAB\xC6\xAE\xDCa\tE\x00k\x14\xBD7KY@\xE3\xC0C\x11\x00\xAB\x00\xFB\x8F\x88\xB3\xD3\f9<9\xDB\f\x9Cv\xCD\xC4\xBD\x8B#\xF3Zo)\xA4\x0E3.\xCEVA\x020\xF3\x0FV\x96\x98\r\xC4\xD3\xFF\xB3\x92\xE5\xE0`\xE9\xA5>\xAD\xFAz\xAA\x9D>#B\xF3\x7F\x7F\x9E\xCD\x7F}\xEDI\x9F\xFF5\xC6\x9B\xD5\xB4\xD9r\xB0\xB5\x0F\xF5}\xCC\xAA\xDDj\x8B\xE4\xAC\xAB\xB5\xBB\xE1\x9A\xCF\xFF\xF7J\xCD\x7F\x98\xE8\xFC\xCF\xF4p\xC3p\x9E\xA9\x18\xEB<9\xD78\x8E\xB7\x8C\xD3\x0E\x85\x9D\x1B&\xEEW\x99\xFF\x06e\x84\xB0\x89\x05)\x18\x1F\x02\x85\x141\xACz\xA0\xDE,}\x01\x8D\x0F\xC4<w\xAD\xB5sU;}4>2_\xD5\xF6\xC6N\x9E\x1C\xBBk\x84T\xB3\xCF8U\xB3\xDF\xB1i\x1C\xCB\x1F\xA8\xA2\xC8\xA0>'*\xFA\x05\xCC\xF3\xD6\xEC\f\xEF\xB5$\x9B\xC6\xC4i]c\xC2\xA2\xC8\xA0\xD6\xCE\x95\xED\xE4O\xF7\xBC\r^\x1F\xC1#Bz\xC49<9\xD6\x8F\xD8\xC8\xE3\xDE\xB3\xEF\x8EMcW\xEEP\xD68\x96\xF2\x0E\xF4\x8A\xF4\xA7\xDDQ\xF4\xDE\\\xBA\xAE1\xD1\xD0zN4&*\xAA\"\xC9<\xDA\xA7\xE7]H6\x13\x82|s\x86E5v\xCFLTc\x97\xAF\xE6\xF0y\x82g\x8B\xAE_\x90\x93\x1DP\xF7]%\x19[4\x0E\x0E\x9Cq\x17x>K\xAB~uMg\xA1>2\xAE\x8F\xE0\x11Iz\xB8N\xA6\xBA\x10\xF7\xAE^c\xCD\x11\xEC-\xEB\fQk\xF2K\x98Fv\x80M\xE3@?\xFB\xBC\xB7\x9D\x07\xBB-\xA3\xC6A\x10t\xC47\x1AW\xBCq\xF3\xE4\x85\xB8w\xE5\x1Ak`tk\xEA\x1A\x01\xCF\xF8\xD0\xFB\xEC\xF2\xB3\xA3\xCF4';\xC0\x9B\xA5\xF4\xD18\xD0\xCF>\x0F\xE0\xD2\x0E@-\xF9\x88\xDA\xCE>\xFD+\xDE\x14\xE2\xDE\xC5\x11\xAB\xC6n\xA0k\x07\xF8*\x02\xE4d\x07x\xB3\xF4\x054\x0E\xA4:\xFF`\xD7\x0E\x90\xEC\xF4\xD18\xF0\xAFxS\x88{W\xFCo\xCA \xD0\xD9o_E\x80\x9C\xEC\x00\xEF\xF9_@\xE3@\xEB\xD3\xA2\x1D \xD9\xE9\xAFq@ \x10\b\x04\x02\xE1:\xAC\x02LJcW[Y\xD05v\xB9\x9A\x80\xC4\xA8{3\x9F\xB9-\xF5d\x84Bv\xBA\x99O\xD1r\xB4%i\x1F\x88\x96bh\xB9\x19\x07\x8A\x1B\x03\xA7\xC1Ad\xE6\xCC\xDD\xC0k\x04\xA1\xCA\xB4+\x8C\xBA/\xF3\x9F\xDF\x92\x97\xAA.\xE2\x7Fw|>\xB6\xB3?\x88_\xF7\xA3\xF8E\xBCE\xE8x\x18o\xF1\x11\xF6\xE2\xE2 \xF6\xFF9\xD6\xE0\x1C\xEA\xF3\xDC`\x1B\xC2\xEDs\x83\xEDs\xD1/\xE5\xFC\x87)\xCC\x7F\x1E\x9F\x1Fx\xCC\xFF\xFE\xE0T\xE2\xFF\xBDS\xF1\x96\x12\xE0\xFD\xBDS\x10\xC6[|\x84\xBD\xB88\xD8\x01\x80\xAF\xB3\xDE\xBE\x8E\xFA\xFC\xFA`\x07\xC2\x9D\xAF\x0Fv\xBE\x1E\x19\xF84\x1B\nh\x1C\x83\xCC\x9C\x1B\x19\xF5H\x8D\xE5\xF6\xD7\xC2\xCE]#\xD0\x83\xF1\xF2\xFD\x8F\xD62\xDC\xCC\x7F2\xFF\x87\x93\x9F\xFF\xA7'\xA5q\f2s\x9E\xFE\xEDXazeF\xDD\x87'\xD7\xD7\b\x8C-\xE3\xB7\xEA\xA3B\t\xE6#g|\xBE\xE4\xFF7/\xF3\xF9\x7Fz\xF3r\xBCE\xEA\x1A\x81\x18\xDA763\xFF\x1B\xB5\x03T7NL\xE3\x18\x8C\xD7j\xADFJh\xCB\xF8Xtv9\x8DR\xBE\xB6\x98\x7F=\xE3\xA3\xCFFt\x9A\xAB\x06 \xED\x03\xF5\xD7\x07\xC2\x8By\xDA\x01\x8A\x1B\xFD\x15|\nT\xBCa\xAB\xC0z\xCC\x7F|D\xD18\xF6\xE0\xC9\x93y\xBE\x95\xD32~\xAB\xB6\xEF/\x03Zh-\xA3\x9F\xFE\xEEW\xE3_\x9C\x1Ds9\xAF\xF8\xD7jx\xB1\xA0\xC6A\xC3\xBB\xC2R\x81\x8A\x1F,\xB3C\xE7\xEA\xE3#\xF2\x8A\xD2\xC1\xCB\r\xA3\xC6\xEE\xE2\x91\xE3Pm\xE8\x1A\xC79\xDC{Pt\xFE\xFB\xAEz\xF4\xD3\x96\x8F\xBC\xBA\x0F\xD1@V\xF8\x8D[\xC6\xAEfg\xBF\xE8\x97\x9B 01\x8D]\xEC\x7Ff\xC3\xA3\xFA\xBDJ\xA4\xE62,\xB2;\x9C_\xF7\xE0\xDE!o\x8D\xA0\xC4\xFD\xCF\x19\xEFU\x8F\xD3i\xCBv\x1F\xBA\x9B\x03]\xE17\xE0\x16\xD6GO\xFB\xE5&x\xCE\xFF\x13\xE5\xE6\xBFm\x8D \x02Mc\xD7\x97\xF9\xCF]#\x98e\xF3\x7F\xBE\xD8\x17\xA0\xF0\xAAG\xBB\x0F\xAD \x94\x15~\x7F(\xCE\xEE\xA3\x1D0+\x9B01\x8D]\xA9\xCF\xD0\xAA\x9C\xABj\xEC\xFA\xF3\xE49-\xBF\xC4\x92\x11\x8A\xC9\xCA\x14_\xF5\xF8\xF8\xCC\xFE\xEA\xC6@V\xF8\xBDY\x9C\xDDG;\xE0KT\x02\x88@ \x10\b\x84\xEB\xC8\xFC\xA3X}\x03\v:\x89\x8A7f\x9E\xDC#\xE3\xC0V\x99G\xB5\x93g\x1C\xA4\xA6\xBE\xE3}k\xC1YS\xC1\xA6\x8A\xBB\xA6\xA2\x11\xD7z\x15#//E\x19\xA7\x9A<\xDF\xE9\x11\xC5a\x99\x8A7\x82'O\xD8Z#O\x18w\x9E\xCF\x13\xA2>\xD7\x01`\x93\xB5\xD9T\xFC\x10\xAEo\x0E\xD6!\\\xE7\xFF\xBB\xE8\xED\xFF\xF8n<\by\xFD\xCFV\x04\xADH:\x8E\xEF\xFC\xC5X\x1C\xE3-\xEC%\xDE\xE7^G\xE57\xA4\xA1\x95\xEAY\xF6\x95pW\xE2\xA5p=9\x12\xAE_d\x11\xEF\xE7\xB5\x18i\x1E\xF1~~\x90q_\x9B\xF2g\xAA\x18\x99|\xB2\f\xDF.\xE5\xFF\xD5(\xBBQ\xBF\xA6\xFE\xFF\xC7<\xFF7\xF6E\xE68^g\xD0y\xEFd,\x96\x8C\x83\xD3o\xBEV\xDE\xFF\xA8\x02\x92a\x15\xA0T]\xA6\xCD\xCD\xCB\xA2\xFF\xD3\x11\x98yr\xD6\xF9\xB7\xF3xr\xC4}I}*F&=\x17\xF5\x7F\xD4J\x17\x7F\xE0`7[P0D\xBC;3\x0E\x92\x1A2\x05q:\xCA8m\x03\xA3\x88\x9E\xF7\x8B\x7F\xB2\xA1Ts\xC9\xCC\x93\x83\x0FO\x9E}\xA6J\x9F\x8A\x91Q\xB6\xA0\xE0\x7F\xFDY\xDD\x1AA}\xA4\xD3\xA5:\xEF\xED\xD6#\xC8T\xFB\x8B\xF1N\xEAwjRj\xBC}Ec\xD7\xDAm\x01\x9E\xBC\x9F_\x17hXt\xFE+\x1A\x07\x0Ey\x8Ei\xE8\x114\x92\xEB\x8Fo\x9D\xFF\x02\xFEW5v\xD3\xCF\x17\xF3\xE4\xDCW\xDEy\x04}KK~!\xC1-\v\xF8?\xBE\xC9\xBC \xC6\xAE\xDB\xE9\xC9\x0F\x97\xD3,n$\xD7\xD2\xD05\xFF\x83rW6Yc\xD7\xC8\x93\xB3e\xAF\xA7\xBD\xF3\bNG\x0E=\x02\xD62\xBD]\x7F\xBA\xC0\xFC\x0F\x01.8\xEC\xCC\xAE0\xCE\x88\xF7r\x9A\xC5\xC9\xB7)R3\x9B\x0E\xEF\x7FUc\xD7\xC8\x93\x17\xD6\xD8\xB5\xEB\x11$-_H\x7F;|\xCDd\xAB\t\xDB\x16;\vd\x1C\x94\xD4,\xD6\xFC\xBF:\xA1\xEB\x8F\xAA\xB1k\xE4\xC9\vk\xEC\xDA\xF5\bx\xCB\xDA\xF1\xA2\xFEg?\xD9\x97,v\x16\xC88(\xA9YLK\x00\x04\x02\x81@ \\'\x18\x98\xEDz\xC1\x8A7\b\xDD\xCD\xFD\x84H\xAF\xED\xF3\xD7\xE2x\xD6\x98\xBD\xB0\xD5\x1B\xD1\xCB\x8C\x97S\rvGt\xDBF\xC4-/\xD7\xB2\x80\xCF\xC5ZF\xFD\xB2\x81Y\r\x13\x96\x12\xF1T\xEA>{:\x90\x1F\x10Z\xFD0!\xD2\x83\x90\xBF\xCE\xEE\xA8Ec\xF6\x02\x9F\xD7pv\x84sQAF\xD1\xC9\x15\xBBG\xC4-/\xD7\xB2\x00? \xF8\xE1\x94\n>\xED\xED\xFFUo\xFF\xAFn\xEC\x9B\x19uF\xED\xF6\x11\x93\xFC\x15\xE9\xEC\x19\x93|\x18\xFF\x9F\xF6\xF6\xFF\xAA\xB7\xFFW\xA7\xE6\x7F\x89\xDF\xA8i\x15W\xD0\xD9\xA5\xD0\xB2\x19\xB5\xCE\x7F\x8B\xF9\xDC\xAA\b\xA01\xEA\x06>S>u\t\xFF\xFBh\xD7\xB6,\xCFS\xBA\xE5\xFE-\xCB\xF9_\x8F\xCFO\x82cq\xC5\x15\xE4y)\xB4X+\xB7\xB2*\xC7$\x9B\xE3\x90\x19\xB5\x8B\xBD46T\xF1\xCA\xF0L)\xD5`\xB7\xC6\xAEY\v\xD8\xFEI\xF9\xB4,\xC2O\xA6k\x19\xB5\xCB\x86Z\"us\xC5\x95y\x8B'\x95#BN7H\x9764F\x9D-m \xCF7\xF4\xB3#LOc\x97c\x11d\x0F\xCB#\xB2q\x0Ez\xCB\x02\xFE\xCF\xD62\xC2\xB1\x81QW\xB3\xDE\xF0\xCC\xCF[#\x88}\xCEZ\xB6p\x84\xBC\xB4\xA2\xC4\"\xE4\xADz\xB8\xF2Wo\xAA\x1A\xBB\xFA\x88\x16\x19+\xE8\xD3\xF2P\xF3_\xAFu\xA3\xC6\xD2\x1B*\xAE\x18X#\xAD\x86\xCF\xC1\xAB\xF1=g\x12\x86-E\xC8w\xB2>\x83\xCCK\r\x8F>\xA7\xA1\xB1\xCB\xFD\xA9g\x1Ct\xBD\xF3\x80\x0E\xF3Ydk\x19\xB5}k\x1D\x9B@\x9D\xFF\xD6\x96\xD8y\x10\x86\x11WD2G\xC8C\x1A!\xFF\xC1\xC8\xB7\xCFih\xEC\xF2k\x8E\x9Eq\xD0\x8A\xCC4s\xCB\xBB\xA5\xDF\xEF\x94Z\xB7_\xABcS\xA4\xE2\x8D\xE6\xFF\xA4g5B>e\xD4Y\x84\xBCU\x0FW\xAB\v4\r\x8D\xDDE\x00{n\xC2\v\xFA7\xC5\xA7e\x01 \xFF[\xEA\xD8\x14\xA9x\xA3\xF9?Q\x04P#\xE4SF\x9DE\xC8[\xF5p\xB5\xBA@\xD3\xD0\xD8]\xB4\x8C\x88\xE5&\x1C\xB7\xDD/\xF9\xB4\xF4\xF7\xFFa\xEE`\t\x04\x02\x81@ \x1C\x06z|>\xAE\xFB\x91\x15\x9A`1\xC6\"\xD0WD\xD2B\x1A#\xED\x15I\x1Bn+\xD1\xB9\x12J\xC5Z\x1B\x19Ek\xC4/\xB63\xDC\xCE\x8B\xF8\xED8\x18\xF2\xC4\x15|\xEC\x91/O\x98\xF1\xC3)\xB3\xA4[\x8B};\x1D\xFF\x9F\x9A`\xAC\xF54\xFDo\x89\xB8\xE6!\xF4\xEC]N\x95_\xB4\xD5\x18\xD7\xFD/\xD6\xA7\xD2\xA7\xB9\x1C\xFFo1!\xDD\b\x12E\xDD\xB7\x92@k\xAE\xB1\x1Bo\x00|\x7F\xD1Gc\xB7\x1E\xEF\xFBo]\x9E`\xAEMb\xB9\xA85Q\xDF?\x882\xF2\x93\xEB\x11\xF0\x83\x89\xFFY\xAC\xEC8n\xB9\xA7\xEBk\xE3H\xDAM[\xC6M\x1Di|0\x9B\xBF\x1D\xF9\xF2T]4\xFFW!\xDF\xFF#>\xFF\x87\xF9\xF3\xFF\x1D\xEF\xF9?J\xAB\x18Mp\xFE\x8F\xBC\xE7\xFF;\xDE\xF3\x7F\xE4=\xFF\xDF\xF1\x9F\xFFb}$\x8D\xFE\xD5\xE3\xF3q\xC5\xFB\xFE^v\xFD\xE1Eo\f\xFEg-\xBF10G\xF2K\xE3\xAAm\xE3*F\x13\xBC\xFEo\xCA+\x1A\xA7\xED\xFE\xFF6\xF2\xFF3\xDE\xD7\xFF\xD3\xB6\xEB?\x1B{\x81\xEB\x7F\xD4\n\xE4\xB8k\xED\xB98\xC4\x11\x89}Qh\xA8v9)z\x83>\xA9t\xA1*d\x91\xCC>\x1A\xBBM\xB1\xFA0\xA9\\\x0FagV\xD9\te\x1C\xA8\x19\x1F\xD8\xCE\xDA\xB6[\vx\x13\xDB\xA9\xAD\xD0\xA5S1\x14\xD7\x9Fg\xFCj\xEC\x1F\xECJ\x05Z,q\xEFC\xBE\xB8/E\xDDo\xEE<\xBB\xB9m\xE8\x94\xB5\xF4\x8A\xE4\xE7}\x0E\xF3\xF9\xE1\xC30\xEA\xEEH\xFE\x89f\x1C\x18\xC6\xEEF\xA0\xAF&hq\xEFs\x88\xA5\xEFo\xEEw7/p\xA6\x9A\xF1\xF9\xDB\xB8%\xE6\xF3\xBD\"\xF9\x03P#\xF9\x15\xE6s\x12\x8C\xBAo\xC6\x81A\xB3\xD8/\xE3 PGt\xD1[\x8F \xC0\xB5q\xD2OVa\xE9\x93Xz\xF6\xC9\x9E\x8E\xC20\xBA\xD0\x12|\xFE\xE6\x8E\x99\xCF\x07\xF0\x8A\xE4O\xFB\xB4+\x02\xC0\xE1\x19uW\xC6\x01\xB63(\x9BqPSG\xF4t\x04\x9E\x8B\x01\x19?\x8Ft|\x94\xF8\xFC$\x96>H~\x11\xC2h;\xE3\xF3\xFBM\xDC2\xE3\xF3\xE3o\x9FG$\x7F \xB3\xDF\x93\x9B\xFF \xAFhX3\x0E\xB0\x9DA\xD9\x8C\x83@\x1DQ\xD5\xDB\xFF\x07\xBB\x99\xFF\x85\x8E\x8F\x12\x9F\x9F\xC4\xD2sj:\xF6\xFF\xA5\x8C\xCF\xDF\xF8}\xDC2\xE3\xF3\xD3q\xE5D\xF2\xA7}Z\x15\x01\x0E\xE7\x7F\xA1Dl\xCD8\xC0v\x1A4\x8B\xFD2\x0Ef\xD4\x11U=V\x1C\xC4\xCDS\x18y\xADP\x10\b\x04\x02\x81@\x986\nW\xFC\xC0\xCC\x89\xF3w\x1C\xBFkc\xD4\xF5\xFA!\x86Xw\x87\xE5\x90\x1F\xF1\xDE\x8A\xE43F\xE5Gd\xE6\xBD\xF3V4\xAC1\xFC\xFCY@\xAB8\xD4wW\x1C\xF2\xB6\x16\xB3\xB2}\x87\xD2\x81\xC9\xFF>1fY\xEDzg\xC6G7\x92\xCF\x18\xB9FT\xAE\xC6\xBE\x9BQ\xB7\xE6\xB0X\xE6\xFF\xC8{\xFE\xBB\xAD\xC5\x85\xEEGh\xB6\xAC;\xE7\x7Fw\xCA\xF3\xFF9\xAD\xE7\xCD\xEB:\xFF\xAD\xF1\xF9\xB6\x8A7C_k1+\x88\x99\xCF\x86\xA2\xF1j\x9A\xFF\xAB~\x8Cz\xF6<5\xF3\xF6\xAAqD3o\xAF\xCA\xFE_\x8Ft\x06\xA3\x94\xFF\xD1\x88\xD6\x9D\x8C.\x1E\xD1\xAA\x81\x970W\xBC\xB1qJ\xD8{\xCF:\xAD\x954^\xCFf\x15\xE9\xC7\x8A\xC6\xAB\xC9\xFF>e\x84}3\x0Ed\x0F\x1B*\x99\x94\xD38@5\xF6\x0F\x9C\xD5{\xDC\x19\x07\x85+\xDEx+\x02H#e\xAB{z|\xB2^?g\xD5\xDB\xFF\x99\xCD\xCE\x8C\x83x\xC8\x91y\xFE\x14\x1D\x91\x04Tc\xDF\xE0\xAB\xBA\x99QY\xF4\xE8\xD8\xBF\xE2\x8D;>\xB6*\x8D:\x14}vU\xF5\x1C\t\xF3\x96yb\xBC\x02\x81G\xC6A \x8FE\xFF\x05l\x94\xD38@5\xF6\rw\v\x15]\x91\xD6\xDC\xB2p\xC5\x1Bo\xFF\xE3\x96\r\xD7\x1A\x81\xC1\xFF>8xu?\xA1!\x9D\x19\x07\xDDH\xD7\xE0(9\"\xD0Fd\xCD8@\xFE\xB4e\x1C$s\xA8h\xC5\x1Bp^K\xAD-\x1Dk\x04\x06\xFF{2\xEA\x89\xC6\xAE3\xE3`^\xD68\xE8:\xFD\x7Fw\xA9\x1A\xFB\xEE\xEAI\xB6\x8C\x83\xECn\xADP\xC5\x1B\xEF\xAB\xE5\t\xED:c^#0}O\xFD\xFD\x9F\x9Bq0/\x7F\xA3[N;\x0F\xAFq`\xF3\xBF\xADe\xE1\x8A7-_\xFF\xCB\x1A\xBB\xF65\x82\xBC{\x1B\xB7\xFFs3\x0E\xBA\x91\xA4q\xA0\xF7<Y\x8D\x03\xFD\xFAc\xCB8 \x10\b\x04\x02\x81p\xED\x91\xD4\xF1@wJ\x19\xA3\xA8T\\\xE9\x87\x13\xA8\xF8a\xAB\xC8\x9DR\xA0/\x9D\xDB\x8E\xF7\xAC\xC1KQ\xF2\"9>\xBB\xCD\xDF\x8D1\xBB\xFD\xBD\x87\xA4\x96\x02j\xCB\xB4O\x1D/\x1D\xE2>$\xB3sv[:;?\x82\xCE\xF8=\xE7mtRG\b1\xFF-\xB7\xC6\xEB/\xA5\xFF\x7F`\xF6\xE1\xF0\xFA\xFB_\x9F\xFF\xDDi\xCC\xFF\\E\x8Ct\t\xE6\xA5\xF3W\x01\xE0*kpu\x18o\x1CW\xAF^\x85cW\xE3=\xC7\xB1\xAB\xDF{\xC4#\xE3\x80\xF7y\xD5\\\x1F\xFB\xEAa\xE6\xFF\xF9x*\xBE\x15\x01\x1C\xDB\x7F\v\xF5\x93\x1C9\xBF\xEF\xE9\xFF$\v\x18k\xBC\"5\xD8U\xE5\x19\xADl\x88\xD4\xC8{\xFE_\xE5\xF3j\x98?\xFF\x7F\xEE=\xFF\xAFNa\xFE_\xF5\x9E\xFF?o\x15\xFFE\x90y\x80\xC3C\x89\xA57\xC4\xE7\xA7K0/\xFD4\xF3\xEA\xE7\xA3x3{\xF5\xC8S\xDF\xFB\xD3\xAC\xE53\xD7\xFC\xFA\xFF}\xE4\xFF\xCF;\xFD\xFF\x07N\xFF'ul4\x8DWC\xCB\xD7G\xE5+\xDEXb\xFE\xF5\xF8\xFC\x97\xBE\xFA\x14\xF7<\xC8\xDA\x01\x9F\xFF\xEASp\xE4\xA9\xCF\xB3w\x19\xC2\xEF\x9D\xF4\xC98\xC8\xFA\xD4\xF1\xF9\xC3\\\x7F\x84\x9DG\x9E\xC2|&?\x82\xEC\xCC\xB9\xFE$\x15o\xB4\xA27\xD3\xABxc\xCD8\xC0s\xD2C;\x80\x8F\xCB'\x92\xFF0\xD7\x19k\x9F>\xD9\x01\x9E\xF7?J\x9D\xED\x9AY\x11\xA0\xDB\x9FD|~\x9E\"\xC0K\xCE\x968>\xFF{'}\xB5\x03^\xDA\xDCw\x8D\xBD\x9C\xFFmy\x04\x91\xAAG\x90\x7F\xFF#3\xFF\x00N=\xDCR\xC8W\x04H?\xF4\xCF;[f\xF1\xF9\xF5\xD1\xCF[\xBE\xDA\x01\x9F\x8F\xC2\xDC_\xBA\xA2\xF8\xBC-\x8F \x02\xE5\xEC?\xCF\xF5\x7F!\x8D\xDDr\xC8W\x04x\xC1\xA7e\x16\x9F_mTZ\xC5\xB4\x03&\xEB\x7F\xB0\xE5\x11D\xA0\x9C\xBD\x92{\xFFYHc\xF7\x10\xD6\xBA\x14\x016\x8F\xFB\xB4\xCC\xE2\xF3+C\xEE\x7F\x7F\xED\x00\xF3\xD8\x0F\xE7\x7FC\x1EA\x04\xCA\xD9+-bY\b\x04\x02\x81@\xB8\xC10\xEB\xC1\x93h\x8C\x8A?\x1Ej\x7F7\xDE\xB3{\x80\x87Z\xEAq\b\xBE;\xD5\xC1\xF93<\x0F\xB9\xEFR\x90\x9D\xD6\x11\xB5X\xB3\xA2#\x92\xFC\xBFc\xE1\x9Av`v\xE7\xFB\x96ws\xC6u\xF2\x8F\x00\xE0Y\xC6f<\x8B\xD8\xBCg_\xFD#\xF6\xAC\xFDG\xBF\x1C\xFEGvr\xCB\r#\xDAe\xCD\x8A\x8E\b\x15\xBB\xFE\xFEy\vO~~\x0F\x8E\xED]=_Fe\xF2\xD9K\xD9l\xF9\xA7\xD1\xB5\x9E\xFF\xFE\f\xFF\xB3\xBB\xD7\x7F\xFE_\x9D\xC6\xFC\x7F\xE0\xAF\x01\xE0>6:\\\xF7\xE3\xD7~\xFC\xD7\x8Cw\xFA\xEB_\x8E\xF9?\xF3-4\xA2o\x89\x11\xE1\x19\x15\x1F\x99\xF9\x16nyC\\\xFF[-0U\xBC\t\xBC\xEA\x04\xDF0\xFEG2\x07\xF7\xA1QL`}\xA4\x96y\xF5\xFB6\x9E\\\xE5\xDE\v\xE0\xBE\xD7G\xCA\xCCO,g\xC7K/(x\xB3d\xDEv\xBA=\x89\xEDD\xAF\xF1\xB8\xF4\x95\x94\xE9\xCD\x16\x7F\x18*\xDE\\C\xF8\xAB0\xCC\x17\xE8\xB5e\x1CQ\x00\xA0\xE4\x10y\xC1\x87'\xD7\x18\xF5\x02\xFEw\xAF&\x94\xD3\xF7\xBC\xF6\xFE\xC7\x91\xFC\"\xE3\xC0\xA0\b\xD0*<\"\x1F\x9E\\c\xD4\x8B\xCC\x7Fg\xCC\xFFaj\xCEx`<)\xFF#;\xB3\x8C\x03\xA3\"@\xD1\x11\x05\x1E<\xB9\xCE\xA8{\xC3\xB5\x9A0}\xFFC\x01-\xE0b\xFE\xB7*\x02\x14\x1D\xD1\x8C\x07O\xAE3\xEA\x05\xE0\x8C\xF9\x9F\xF2\xF5gbU\xE6\x90\x9D\x81mD\x86\x95\x14\x02\x81@ \x10\b\xFF\xB8P\x80Qo\x81k\x8D\xA0\xDC\xB3\xFC9Wt.f\xBD\x1AgC\xA8\x84\xF1\x93Z%l\x9C\r\xC5#[r\x9C\xD7\xA6`\x99\xECs\xF7\xDF\"\xB2Sq\x8Ej|\xBCr\v\x7F7\xFB[E\x0F\x0E\xF5\xA9\xE7\xC5O\x039\x8C.\xE2\xC9\xB9\xCF\xADk\x04\xBF\x94\xFE?\x16\xEFY\xDCc\x03E?6~r\f*l\xBB\x91\xE6?\xF7\xF9\x84\xE7?[\xADH\xF2\b\x90\xAF\xF8ZF\xBC\t\x9F\xF4\xCEC\xF5|\xEC\xF6\xEA\xF9\xE6\x95\xF3\xCD\xD4]\xCD+\xE7\xF9\x91\xF8?\xD5x?\xB7\xF6-\x00\xB8\x8D\xF5v\x1B\xEA\xF3\xCE\x97\xBF\x05\xD5o\xC5{\xD1\xE7\x95\x81\x98\xF9M\xD4\xB2\xD9\x1B@\x95m\xD7\xDD\xFF\x98Qg-\r\x8C\xFA\x8F\xBFU\xFA\xECW\xFD\xE7\x7F\xAF\x03\xD5N\xEC\xF6j\xA7\xDD\xEF\xB4\xD3\xC6\xCB\xECx\xBC\x8FgK\x87\xF9\xFF\t\x00x\x8C5x\f\xF5y\xFB\xDA\x13P}\xE2v\xF6n\xDA\xE7)\xE1\xF96\x9A\xFF\xCBWNA\x95m\xD3\xC7}\xBBe>\xA9Ie\x1C\xE0\xEB\xCF\xE7\x9D\xFEo\xBE\xD1\x84\xA0\xB9\x1C\x01\x04\xCD\xDE\xA0\xD9K\x1B\xAF\xF5\xE3\xE3I\xC9\xE50\xDE\xDFy\xE9W\x85\xE7q\x8D\xA6\x07\xDA\xBF\n\xC1\xAF\xC6{\xD1'\xFB\xABe\xE6\xF9\x1Ej\xC9\xFB\x8C\xB7\xEB\x0E\xC4\x93\xDB>\xA9d\x8D\xA0\x9C\xFFq\x1E\x01\x02_\xCB\x887\xE1\xABA\b!+\x1C\x112\x81\x83\xF4O\"v<\xDE\xA7,\xCA\x9D\x9D[\x84\xE7q\xC6\xC1\xD9\xCE-\x10\xDEr\xB6s\x8B\xD4\xA7\b^E-y\x9F\xF1v\xDD1\xE5\x8C\x03\xFF\xF8|~\xC1\x89\x84\xC6\x81\xB11c\xD1\x1F\xF4\xCE8\xE0\xD7\x9C(\x82\xEB\xB2\xEA\xE1u%\xB1\xF1T\x13\xCA8x\xC9\xA9G\x80\xCF\xDE\xDE\xDC\x87\x1A\xD68\x90Z\xE2:\xFF\x0F>02\xF6\xB9\xFAr\x00\xB0\x10\x9E\xDD\x97\xFA\xF4;\xFB\xF4\x90SeK\xE3i}\xEA\x02\xF9\xE3\xF3N=\x02|\xF6^\xDC\x12i\x1C\x183\x0E\xD8\xFC\xDF`\xE5\xCD\xF4>\x17\xE2\xCFe!\xEC\x05r\x9F^g\xBF\x11\xFCo\xD5\xD8\xEDOB\x11\xC0\x94\x1D\xA0\xADzl[*\bIu\xFE+\xC8\xFF\xB8\xCF\x85\xB5\x00\xE0/?\xB0\x16\x949\xFB\xF5\xF2\xBF\x87\xBE\xB0\xAD.\x90\xBF\xFFm\xD9\x01\xDA\xAA\xC7%K\x05!\xA9\xCE?\xF7\xBF\xDE\xE7G~4\x82\x99#K\x8B\xFBe\xCEN \x10\b\x04\x02\xE1\x9Ac\x8E\xDD\x1E\x198U~\xDBT\x918\xED\x84\x9Eel\xAD(\xDA,\xF1\xB4\x8C\xF4\x9B\x14O\x8E\xEBB\xDB\xECL\x80\xEC\xE4U\x88\x83\xE4u\x16\"(\xD7\xB8n9\xCE\x9E\xF6\x99\x9D\x1D\x9FwI\xA9TYm.i\x95\x8D\xAD\xCC?\xBE\x01g6\xF0q\xE9\x9C\xEA\x1C\x7Fz\xAD|x\xCA\xFE_\x01\x80\xF7\xB36\xEFG-\xDF\x7Fv\x05*+\xEFg\xEFb\xFF\xF3\xCA\xA8\x86\xFA\xA8\x95\xDFF\xE3za\x16\x80\v~}\x88m\x1C,\xC5\x98o\x10\xDF\x84\xCB\xFEoz\xFB\xFF1o\xFF7s\xFC\xFF\x82\xF0\xB3\xEE\xAB;\xF94\xA9~\x13q\xAA;w\xF5vb/Uw\xEE\x8A\xE0\xAE^\x12\x8E\x1E\xBF\xA8\xEEd\xFF\x8D`n\xEDgF_\xDD\xB3\xF63\xA8\xFE\xEC\x1E\xF6n\xE2\xE7\x9E\x8B'o\xF62\x9E\xFC\x83\xEE\xF9\x8F\xEC\f*\x8D\xB9\xB4\x9E\xED\x93\xBB\xF1\x96|\x82\x95\x06\xF0\r \xBE\t\xE7gI\xCF\xFB\x8A\xA1\xCF\x81\xE2\xFF\xC7\xD9\x1E+\x1A\xC4GnZy\x1C[\x8E\xC6\xF2\x8A\xCE\xFCc\xFF3K\xF8\xBCz\x1C\xF5\xCFq;7\xBB\xFAY\xE4\xFF\xCEr\xAF\x13\xF7\\\xED\xB4#h\xF7\x93\x8A=\x12O\x0E\xB0\x1C\x15\xE2\xC9\xD7\xF9G\x06\x00'Q\xCB;z\xEBP]\xBF\x83\xBD\x8B\xE7\xFF\xE7\xA2l/\xFB*\x9B\xFF\xB3G\x1E\xFEW\xA9\xDB\xF1\xF5\xE7_\xBD\xF20\x1Ca[z\xFDi>\xFFo\x01\xE0\x92\xB6J\x95\xE0\xE6\x7F+^b\xCEyIQ\n\x90u\x84\xB9\xE7/i\xD7\x9FW\x9E\x7F\nn\x96\x02\xC8g\xD9\x1C\xE0\xF3\xDC\xC0i\xF3\xF9\x1Fd\x9C\xF6]\xFD\xE6Z?\xE5\xC9#\xE8\r\x9A\x06\x9E\x9C\x91\xAE\xF7\xB4\v\xF2\xE4\x91\x99'\x17}:\xECL'S\xD6\xE7\x1CH\x1A\xBB\x82\x06\x94\xAE\xFF\x8C\xFDn\xFF\xC4Y\xBD\x1F].\x1EG\x9C\xF3\xD8y\xFDi#\xCEm\xEC\xBC\xFE\xCC\xB1\x9C\x02>.\x03\xA7\xCD\xFD\x1FJ\x9Cv4\x10<y\x16\xAC(\xF3\xE4\x10E\x05x\xF2\xBB\x9C<\xB9\xE83\xBEvY\xECL\x80\xEC|\xF2uUc7[M\x90\xE3\xF3{X\x8F@\x07\xCA\xCC:g\xB9\xEE\xE9:\xE6=<\xF35}s\xFC\xB7O\xB2\xD5\x8D\x07wK\xF1\xE4\x11\x98\xB5\x80\x19\n\xF0\xE4\x91/O\xEE\xDF\xA7\x92q\xE0\xE0\xF3\xB1\xC6A\xD7C\xC5Co\xC9\xECiV\xB5\xDF_\x8B\xC6\x814\xFF\xE7\xD1\xB8\f\x9Cvr\xFF#q\xDAH\v\x18\x14-`\x91\x1D\xD0\x8D&\xC6\x93\xE3\x8C\x03\x9B\x9D\xE9\xB5\"\xEBS\xD1\xD8\xD5k\r\x89\x0F\xA9\xB1i\xCEM\xD0\x19\xC2%\xFC\xBD\xD3\xAB\xFD\x80\xEA\x7F+\xF3\x8F\xFD\x9Fp\xDAf\xEE}!\xB9\xFF\x918\xEDL\v8\x02E\vXd\x07\xCCO\x8E'\xC7\x19\x076;\xD3\x89\x18\xA0\xF9/i\xEC\xDA\x14\x01\x1Cz\x04:C\x8E\xD5\x10\f\xD5~\x94+\x92_\xF5\xA4y\xF6u\xA8\xB4\xCC\xDC\xBB\xEE\x7FI\v\x98\xFFD\xEA<9\xF3\xFF\xA4xr\xBD\x8A\x8E5g\x0F\xD9\xA9h\xEC\xDA\x14\x01\x1Cg\xD7\xFD\x8F\x15~\r\xD5~4e\r+\xF3\x8F\x7F\x8Fv3\xFF\x1B8m\xED\xFA#i\x01Gp_J\xCE+\xD9\x01\xDDhb<\xB9^E\xC7Z?\x1F\xDB)k\xEC\xDA\x14\x01\x1Cg\xD7\xAF?X\xE1\xD7P\xED\xA7\xA5\xFA\xDF\xCA\xFC\xCB7\rD\xBF\x10\b\x04\x02\x81p]\x10\xA0\xBD\x89'\xCF\x98j\x9E\xDFmi\xD9\xE2o\xB9\xF3\x9D\xB1\x02\xD1R\xAFie\xD4\xE3\x1B\x8E&\xE2\xE8B\xF1\xB7\xB8\x87\x85^\bU\xB6\xC9v\x82aD`\x1F\x91\xF2W\xAD29\xEC\xCAZF%\vbO\x98y\x14\xF3\xDF\x88`i\x8D1\x96\x11g\xC5\x13\x9E\x1C\x8C<\xB9\xE6\xFF\x0F\x19\xFD_\xF9!T~X\xDA\xFF\x8Fy\xFB\xFFQo\xFF\x7F\xC8\xDB\xFF\x1FB\xB7\xE5\xD7\xDE\xFF\x82'G\xBC\x1C\xE2\xC9\xF9'\xC2,\xFC\x10[\xB6\xC0-?\xC4\xDC\x1EoGn\x86#7\x7F\xC8\xB8\x8A\x01\xA0\xB0\x88\t\xA3\xFB\xDCS\x00\xF0\xCF\xD9\x91\xF3\xE88?\x027\xA1\xF8\xD8\xE7B\xE1\xF9\x01j\xF9\xE8s!\xDC\xC46\xD9N\xD0F\xC4-\xC7\x8F?\x81\x18\x11\xC0\x93\xAF\xDCl\x18Q\t\xFF\x8B\xB5\x8C\xEA \xF3\x03_\xC5@1\xFF\xCD\xD8\xFF\xA7\xA0z\x8A\xFB\x9F\xDB\x89\xB3\xEFc{\x98?\xB3O\x84\xBD\x8E[\xCAO\x10J\xCB'wM\xAB\x18\b\xD8{\x8F\r\xB6\x8D|f\xC2-\x87\x19\xB9\xF7\xCA`\x90\xFD-j9\x18\f d\x9Bl\xA7\x8E\xC4r\xF4\xEE\xAC\x18\x91\xD2R\x1B{\x11\xFFw\x12\xFE\xBF\x9A%\x11@\xD0\xE1\xEB#\xF1\x96\xAE\x8F,}\xF22\x1C\xB9\xFC\x1BC0*\x8D\xCEW\x16\x80o\xA6\xB9d\x15\xD8\xAD\x8F 7\xDF\\\xF2sSx\xFE]\x83\x9AaSyF6\xB0\xF4\t\xA3\x18\x16\xB03[#\x90y\xE9I [\xCB\b\xB2$\x02\b\x9BJ\xCC\xFFZ\x04K_n\xC2\xD1\xE6C\x16\x8D]\x83\x16\xB0\xA4\xB1kl\xD9\xD25vuH\x1A\xBB[\xDB\xC2\xF3K\xBA\xF6k\x1D\x91\xDB\x16\x8D\xDD\x83\xAD}\xA8\xEFK\x1A\xBB\xC8\xE6E\x90?\vyDO\xBE\xEE\xD48(U\xC3'\x8B\xF9\x97\xC3\xFB\x95\x98\xFF(\x82\xCF\xB4\xE2i\xF3\xBB\x11xG\xDD#\x8D\xDD\xC8x\xFF3\xD45v\r\xDFP\xECg\xF4\xFB\xDBu\xFE\xFE\xDA4v\r\xB9\x84(\xA7\x00\xB7\xCC\xD18\xD8\xDC\x99\xC8\xFC7\xAFe\xD4\x1Az\xCB\xCF\xB44\xC6\xDB\x19\xA3.k\xEC\xE2\x96N\x8D]\xE7\xB7~\x89q\xEF\v`d\xD4%\xEE\xCB\xA6\xB1k\xB3\x13<\xFA\x945\x0E\x06r\x9F%\xAB\x82\xB4\x8D\x8A\x00\x95\x91bg7\x82\xCF\x9CL3\x0E\xFCb\xD4%\x8D]cK\xA6`\xA5h\xEC\xBA\xFD\x7F\xB7\x8D\xF9\x8FT\xEE\xB7\xE1\x1DK\xBF\x88~\v\xF2*\xF3\xA0>7\x07\x8E>\xFD\xD13*\x02\xD4:J\x9F\xF3\x00\x83\xDD4\xE3\xC0Q\xE7\xDFX\xF1&\xB0\xB5|A\xD7\xD8\xD5!k\xEC\xDA\xAB\xE8\xD8\xFD\xEF\x8E\xA5\xC7\xFEwW\xE6\x91\xAA\x12)\xDAs%j\xF8(k\x19\xD2\x13]G\xB13\xFE\xC1m\xA5\x19\x07\x8E:\xFF\xC6\x8A7J\xAD{\xD1\xB2v\\\xD7\xD85|C%\x8D]{\x15\x1D\xF9\n\xB0\xE0\x1DK\x8F\xFD\x9FW\x99\x07\xF5\xB91p\x8C\xBD\xA8\xFFU/\xCD\xDC\xAB\xD8\x19\x7F5Zi\xC6\x01\x81@ \x10\b\x84\xEB\x81%tO\xC2chE$-T\x97\xEF|\xB0)b\x14\xEFla\xF6\xB2)\xF6^H\xD9\xA7b\xB6\xADuDt\xE8R+3U\xB5S\xB6\xF0\xCE\x89\x96\x94\xF6\xE9m\x8Eq\xC5\xF1\x8D%\n\xBD\x16\xC71\x93\x9CX\x1E]{\xFF\x9F\xFA%\xF5\xFF=\x05\xFD\xFF1\x80\x8F\x15\xF1\xFFg\xBE\x88\xFC\x7F\xE5\x94\xD83\x12\xFE_\xDC\xF9\xE0J<\"\xC6\x93\xDC\x89\x18\xC5\xC7\x9F[\x11\xFBi\xCE\xFFu\x00\xB8\x83Y\xFB\x99\xDDx\xE3\xE0q\xE98:\x9D\xFB\xFC\x9E\x96\xAF\xC7&<\xFFg\xEE\x05\x80\x8F\xB2\xBB\xFD\x87#x8u\xEF\xC7\xD8q\xE0{\xEE\xE1\xE7\xB6\x01\xE0\v\x91\xC6\x051|\xE1\xAB\x97\xC5\x9E\xF9\xFF\x89;\x99\xC6.o\x83[&\xD5]\xFC+\xD2\x1Fy\xAD\x8C\xFF?\x19[\xF2\x1BQrva\x80jg\xEA%\xDD\xCE\xC3\xE3_x\xF4v\xA2\x1F[\xD2\x89\x00\x82\xCB8\xE3\xE0av\x1C\x82\xCC\xCE/|\xEDn\x00\xB8\x88r\r\x06hV_\xFCZS\xEC\xD93\xE2\xF3w\xFEi\xE6\xFF\xFF\xE50\xFE?Z\xA6\xE2\xCDm\x7F\x12\xFF\x15\xE7\xC9\x07\xBB\x99\xA9\xAA\x9D\xE9\x9C\xD7\xED<<|>\xCD\x13Q\xB6>\xABe\x1CH\\\xC8E\x94q` J\x92\x95\x0E\xF1\x14\x1F|\xA6\x15\x8F\xF1;\xAC\r\xD6\xD1\xAB&\xAB'\xFE^\rK\x8D=\xFE+\xCE\x93K\xAB\xB2\xAA\x9D\x89\x97t;\x0F\x8F\xEFx\xF4\xD6~$\xD58\x90\x17\x0E\f\x1A\x07Z\xC6\xC1\xAAk\x9D\xE8\x8B\x9FA#Z\xDD\xBD\xD6\xF7f\x98'_\xDD\x85_\xDB\xCDi9\r;}>M\xAF\x8C\x83\x84K\x04\xB5*;\xEA\x9F\xB3\xDF8\xEA\xFE\xF7\xB8\xC6n+\xBFe\x0EJ1Z\x9F\xC1\n\xBF-\xB8\xA9e\xB7\xD3F\xE6\x1E\x1E>\xFE\x17\xAB\tIf\x84d\xA7\xBE\x96\x81\x81g\v\xAF\xB7\x93E\xDD\xD7\xC6\xB7\xB1+\xC0Bn\xCB|\x13\xCB\\\x7F\x06\x88%\x8E\xE7\x7F\xCBz\xF6\xDB\xD8[\v0\xF9\xF9\xBF\xE038\x90\x98\x7F9\xE3@\xC9#\b\xD5\x98|\xFCQ\xB3\xCF+\x8B\xBA\xAF\x84\x15\xE4\x7FW\xCB\xE9\xF8\x1F\x90\xC2\xEF\x02\xC0b\xCBz\xF6\n\xF2\xFF\x02\\k\xFFg\xAB\t\x81\x96q`RX\xC0\xFE\xFF\b\x9A-\xBC\xDE\x0E\x8A\xBA\x7F\x9B\xFB\x9F\xB7q\xB6\x9C\xCA\xF5\x07\x90\xC2\xEFGv\xE1\xC3\xBB\xD6\xB3s\xFF\xEBv\x1E\x1E~\xBDI\xCC\xBF\x94q`RX \xE6\x9F@ \x10\b\x84\x1B\x07\x98\x17}\xCC\xF9\x1B\x8D\xDF\xE5\x7F\x85\xF7\xC9\xF1\x9E\xCAy\xCEy[\xC2\x99\xDB9\xED\xAF\f\x8C\xAE\xD3\xCEG\xBDG\xA4\xFB\xE1\xD1\xC3\xDF\xA5 ;\x95\x11\xCDi\r&\xE2\xFF/L\xC1\xFF\x1F\xFB\x07\xE7\xFFl\x8D\x00Q\xD3\x82\xE9\xF5\xB1\xF6\xDFh\xFE\xE7\x9E\xBF\x88\x8E\xFF\xC6s\xDB\xE5\xFD\xCF\f\xE3F>\x8C\xFA40\xEAN;\xBF\x8F\xDE\xFD\xEF\v\xFA\x7F\xFB\xF0\xFEGv*#J\x06\x85\xA8i\x85\x97vkq\xE2w\xB1\xE71\xB3\x87\xF9a\x8E\x13\xDE#\xE2\x8C\xFA\xC3Z{\x03\xA3\xEE\xEC\x13\xFB\xD0_]\xF4\v\x93\xF2?\xB2\xD36\"\x9D\x9D\xD3g\x8E\x0E\x1C1~\xD1Q\xF1\xA6\xAC\xFF\xDB\xDE\x8A\x00\x17\xBD3\x0E\xFC\xFD\x7F\xD1V\xE5\xE3\x10\xC0c\xCF\xD6\bd\xBEzl\xC8\x830c\xAC\xC5N\x9B+\xDE\xD8\xBD\x9A\x03\x9B\xC6\xAE\xCE\xA8\xFBg\x1C\xF8\xFB\xD3V\x91\xA9(\x90\x9D|\x8D\xC0\x1FK\xCE\xB3{W\xBC\x910\t\x8D]\x95b.\x90q\xE0\xED\xCF\xB1\xAD\"bQ\xD85\x0E\x925\x82\xDA\x05\xDB\xEF\xE3\x92w$\xB9\xB3\xE2MI\xFF[5vy\xD19\xCC\xA8\xFBg\x1Cx\xFB\xB31)\xFF[3\x0E\xC4\x1A\xC1\xC8f\xED\xD8{\\\xCE\x8A7%\xFDo\xD5\xD8\xD5\x18\xF5\"\x19\x07\xC5\xFC?\x81e\x1C[\xC6\x81X#\xA8m\xDB~#\xAA\xDE\x91\xFC\xAE\x8A7\xA6o\x9F\xBF\xFF}T\x83\x8Bd\x1C\\O\xFF+:\xC8\xC9\x1A\x81,\xC4\xD3n\xF9\xFA\xDF\xB7\xE2Mi\xC3\xBDU\x83\x8Bd\x1C\xF8\x9E}\xC1V\x11\xE80\xD7\x1FyD\xC9\x1A\xC1\xCC\x05b]\b\x04\x02\x81@\xB8\xF6\x98\xAB\xA8\xCFhV>_\xBB\x1FP\xE2\xC3\xB3\x96r\xC5\t\x00Xg9\xB6\xEB\x9B\x83\xF5(\xD9\xB3\xBB\xDFA|\x9C\xEF\xF9\x7F#\xF8\xAD\xCD\xF8\x96\xECi\xD6\xE0it\xC6\xA77\x9BPk>\xBD\xD9T\xFBdm\xE2}m\x90\x1D\xAF\r\x92\xFF\xB2\x17\xBF\x85z\xC3}BMe\b\x85\x9D\xDC\xAA\xF5(;\x9El\x11\xF0\xCDm'\xEEY\xFC\x15\xB7s}s\x80\xFBt\xFB\xFF\v\x13\xF2\x7F\x7F\xD0\xE1\xFB~\x94\xEC\xD9\x1DY'>\xCE\xF7\xFC\xBF\x11\\DuQp\x9D\xEDs\x83m\b\xB7\xCF\r\xB6Q\x9F\xA7\xE2=\xE3l\xE3}\x98\x84\xCD\xF7\xF7N\xC5\xAF\xF9\x7F\xD9\x8B\x8B\xA8n<\xAE\x1E\x0F\xA1Zy@\xD8\xC9\xAD\xEAG\xD9\xF1d\x8B\x80on;q\xFD\x96\xFE`}3\x82M\xD6&~1H\xC2\xE6\xF9\xE7\xF91y\t\xC0\xC5\xE7;\xFD\xFF\x99\x1C\xFF\x9F\xE2\xFB\xFE0\xF6\x0Fw\x1A\x84\xA7\xB8\xAF\xE2=\xFF\xEF\x10.\x0Ev\x8C\xBE\xFA\xFA`\x07\xC2\x9D\xAF\x0F2\x8F\xF5\xF7\x98\xAFX\x9Bx\x1Fv2\x1F\x86\x9D\xE4\xBF\xEC\xC57\x90\x97\xA4\xDA\xE9\xE1\xB6\xE6\xFFu\xEE\x19\b\xD9\xF4L\x1B\x8B\xE9\xCF=\xB9\x19\xFB\x7FOT.\xC2\xF5\x8B\xCE\x0F\xF6 d\x1B\x88\xBFM>5ng2\xD9\xD2\xCF4a\xD4\x11$\xCFG.\xA6W\x89\xCF\xCFz\xF8\xEAe8\xC26e^\xEDMa\xFEG\xBF\xDC\xF3_\xFFE\xC0\x9E?\xB0\xD4\xE8H\xFC\xFF))>?\xEB\xE1kM8\xDA\xC41\xFF\xFD7\xE3\x8B^\xDF\xE3\xFA\xFF\rv]=\xE7q\xFD\xEF\xB3\xBF\xE2_%\xF7\xF5\xFF\"\xF2\x92\xFB\xFA\xBF\xB9\x99\xD8\x99{\xFD\xFF\xB6\xD3N\xDC3\x1Fu\xDFr\xFD7T\x1F\xB2\xAC>\xE8|\xB8\x14\x9F\x0F\n\xF3,UF\xEA3.z=J\x85\x03\xA2\xF4\x91\x9C\xB7\x8CR\x8D\xDD\b.F\xD9\xEFZU\xE2\xA3\x9A\xAC\xD2{S\xEBSX\x1B\x9A\xCE\x1E\xBF\xB8\x88\xBC$\xF3*\xAA\xFF3;A\xD2\x02f\xAF\xD3#ls\xDB\x89{\xDEd\x7F\x95\xD9\x19\x85R\x9F:\xD0\xCCw\xD7\x05R\xE2\xF3\x1D\xE8\xA7g\xAFb\x8D]\xA56\x0Ech/\xA2\x11\xB9\xCF\x9E\xFC\x88\x88\x965S2N\xDC\xE7\xF0\x1B\xDEZ\xC0}\xDC\xD2\xA6\x05\x8C\xAE\x12\xD5\xA2}j\xBA\t\x06\x8D][] }\xFE\xCB\xF1\xF9r\x9FRe\x9E>\xE7\x8D\xFB\xFB\x8F\xECB\xA6\xB1\x9B\xD6\xC6\x99C\x15\x84.z+\x02\xF4\xD5\x96\xDB\x86\xB3\x07\xDAoYd\xE3\x87%;u-\xE0O\xB1\xB3w#\xE0\xDBEo\x85\xDF\xFE&\xD3#\x88\x04\xF3\xBF\x8D\xFB\xD4Y\xFA\x03W\xAD{\tJ|\xBE\xCC\xD2KUt\xD6y\xDCu\xB0\xD0\x8E\x90\xC6nZ\x1BGh\xEC\xCE\x03\xFC\x96\xB7\"\xC0\xBA\xD2\xB2\xB6c8{m\x1F\xEA\xA3\xDF\xB2\x8CHZ\x13\x91\xED\xD4\xB5\x80\xBF\xCC\xCE\x1E0\x1F\xE6\xDA\xA9\x8C]\xD2#@\xBA\t_\x86V\xCB2\xFF\xAD\x95y0\xE4\xF8|\x89\xA57h\xECB+x\xB4\x1D!\x8D\xDD\xB46\x8E\xD0\xD8\x9D\x8F\xBF\xD1\xBE\x8A\x00j\xF5\xFE\xA0i8{\x00Pm\xD8\xAA\xF7\x1B\xB2\x12R;u-\xE0\x87\xCE\xC6g\x9Fe>\xCC\xB5S\x19\xBB\xA4G\x80t\x13\x1E:\xFBC\x03K\xEF\xA8uo\xF2\xBF\x88\xCF\x97Xz\x83\xC6.\xACn\f>\xCE\xF6)\xFB}\xAF\xA2\xB1\xDB\x8D\x92q\xF9(\x02\xA8\xD5\xFBg~\xDFp\xF6\x99}\xA8\fm\xD5\xFB\x13\x15\x00\xCD\xFF\xAB\x1B\x03]\v\xF8\x13\x9F\x8C\xCF\xFE%v%\xC9\xB5S\x19\xBB\xA4G\x80t\x13>\xF1\xC9\x9B\x89\x81!\x10\b\x04\x02\xE1\xDA#\xE3^6\xAD<y\xC2\xBD\xA0#\xB7\xB2\xDF\xF7U\xFE;>\xF3\xF6*\x7F=\xF3\xF6\xEA\xCC\xDB 6#K\x8F\xCF+\x98\x1Fq\x16\x85\x9F\x81\xD4\x12\x8DQw\xF4)\x88 \xD5N\xD4\xE7\xAAldrD\x1E\x91\xAD\xA5\xEB\xEC\x00\xB6\x11\xA9\xFEL\xD9\xA7\x84\x82ct\xEBE\xC4\xA6\xEA\x9C*>\xB2\xC8\xEEo\xF9\x13A\xAB\x1F\xB6\"\xF6:\b\xE3\xBB\xDF \xDD0\xA3\x18\xA1'q\xC4\x12\v26a\x0EM\xDA\x9A\\cTf\x14]}\n\"Z\xB53\x92\xEF\xD2\x91\x91\"\xB2\b\x8F\xC8\xD6\xD2uv\x00\xDB\x88T\x8E4e\xBF3\xEEw\xD0\xF9\xB6\x85'O\xB8_\xC5\xFE\xD4Z<\xFF3k\xD3\t\x83\xAD]\xCF\xF1\xFF\x8E\xCA\x0FC\xCA\x18\x87;\x98+v\xF7\x89\xFD/\xD9\t\xBE\xFE\xC7\xF3\xDF\xE4\xFFu\xCE$\x03\xC0\x97\xD1\xD97\xC5\xDAA6\xA2l\x8D\xE0\x7FT\xE6s\xEC\xF3\xBD\xD2\xF3\xBF\xB5\x91}[\x91\xDEw\v}[[)\xFBq>\xF6\x92\xA6\xB1\xBB\xFE\xE6y\xA8\x9D\x8F\xF7\xC2Z\xEF\xEBO\x1F]\x01\x1A\xCE\xEB\x0F\xB6s\xDEy\xFD\xC1-\xC1\xD9\x12\x9F\x1D\x9C\xD7\x1F<\xA2\xAA\xE5\xFA\x83\xAF\xFF6\x9E\\\xBF\xFE/\"\xFD\x8E\x03\xA6\xF7\xCAk\xBCg\x15\xD1\xD3\xD0\xEBu\x8B\xC6\xAE\xAE\xF0\xFE\xEF{Mc\xDC\x1D\xD7\xD8\xC5\x15\xD1\xD7\xCFf}\x8E\x9D\x15\xD1\x17\x99\x8A\x81\x8F\xC6\x01\xF6<\x1F\x91\xF5\x1732\x9F]\xAF\x8A\xF3\xB4U\xE3\xA0\x99\xB1\xDF\x19\xF7\x1E~\xDB\xC2\x93\xA7\xDC;\xFA\xFD\xAD\x8F\x94\xC8|a\xB9Z?\xDF\xA2\xB1\xCB\xF5pq\x8E@\x95\xBD\xB6i\xECJ\xE2\xB9\xB8O]c\x17\xB5\xE4v\x16\xD38H\xBF\xD1\xEE\x11\xE91\xEA|,\xF2\x88,\x1A\x07\xEC\xB8\xA4q\xC0xr\x7FN[\xAAx\xC3x\xF2/\xAB\xD1\xEC\xC9\xB5\xA6\x88\xC6n\xD3\x18w\xCD5v\xF1\x8A\x06\xAF\xC8m\xD7\xD8\xCDf \x9E\xF9\xDE\x1A\x07\x12\xF3\xAF+\xF2\xB8\xF4\b\xE4\xAC\x1F\xAB\xC6\x01;\xCE\xBF\xD1\x12\xF7\xEE\xD4\xAE\xC5\xB1\xDC\x81\\?\x7F6\x82\xA3\xF1\xAB\x91\xCE~\xDB4vu>\x9F+\x02\xE8\xD7\x1F\xAE\xB1k\xE8\xD3\x83{\x9F\xAF\xB9\xCEn\xD68\x00\x90\x99\xFF\x8E\xF1\xEC\rs\x9F\xA0\x8Fh\xC1\xD2\x92\xF7\x99q\xEFv\x9E<\xE1\xDE\xA5\xF9/\xD5\xCF\x7F&\x99\xFF\xDB\x92\"@r\xF5\xF0\xE5\xF3\xF5\xDA8\x88\xF7n\xD9\xAA\xE8\xB8\xB9\xF7y\b\vk\x1C\x80\xCA\xFC+-?\xE8:\xBBT\x95\xE8ngK\xDEg\xC6\xBD\xDBy\xF2\x84{\x972\xC8\xA4\xFA\xF9k\x11\x8B\xEE\x0E\x9A\x92\"\x80\x91\xA5\xB7\xF3\xF9U\x87\xFF\x8D\xAB\t\x1E\xDC\xBB\x12u/\xB7\xB4h\x1C\x80\xCA\xFC+-]z\x04rU\xA2\xA5(?\x8B!\xE3\xDE\xCFZy\xF2\x84{\x97\\#\xD5\xCF\xBF/\x82O\xB4\x00f.H\x8A\x00F\x96\xDE\xCE\xE7W-\xB5q\xB8\xC6\xAE\xAD\x8AN\x0E\xF7\xEE\xC8#\xB0i\x1C\xE0\x15\nSK\x97\x1E\x81\\\x95h-\xF2\xCDb \x10\b\x04\x02\x81p\xBDV\x01|\x18\xF5\xD5\\F=\xFDY7r\xEF\xAB\xA8\xE5j\xBA\xE1\xF3JgGQ\x9D\x06;Mq\xA4\xA2\x93q\xCA\x12\x8C\xB7\xF6\xE2}\xA4\xF2\x1E\xE2\xC8\xBB\x88%xWa\t\xEA\xDB\tW\x80\x19\x86\bp\x87\xD93;\xE2=po>y\xF7\xFE\x8C\xBA\xC4\x93\x1B\x19\xF5\xF4V\xD9\xC8\xBD\xB7\xA2\xACe\xAB\x9Fl\xF8\xBC\xD2\xD9QT\xB9\xC1NS\x1C\xB5\xE8D\xA8\xF16\xCE\x86\r$\xCC'x?q\xC4\xAA\x04\xDDkB\xB5\x99p\x05\xC9\xDF\x1E\xE3,.\xDF\xB2\xE3\xFCu\xE5\x98\xC4\x19\x02\xDC\x86\xF6\xFE\xFE?,\xA3\x9E\xCE\x7Fc\xCBU\xD4\xB2\xB5\xF16\xDF\xB0\xE7\xD7'\xE5\xFF\xDEy\xEE\xFF\xE6\x95\xF3\xCD!4Sw5\xAF\x9C\x87\xEAy~0\xF5\xF3\x8A\xF0\x12V(\xBE\xAD\xB7\x02\xD5\x95\xDBz\x99\xC6A\xE3J\xA2\xF0\xDB\x8C$\xA5\xE3\xE4u5\xFB\xAA\xDE\x86>M\x9F\xBAO.N\xDB\xCE\xA8\xC3\xE1\x18u\xBEj\xB3\xAAx\xDEy\xFD)\xE2\x7F\xA6\xC6;\x84\xE5^\xA7\x1D\x81\x10\xE4\xE5\xB9!\xCB\xBD\x8EH\xE7Y\xE2Z\x1E\x9A\xAF\x1E{\xAE\t75\xB1\xC6G\xA3w\x8A{{y\bm4\xFF\x97\xF9k\xA4\xF1\xB1\x84>\xCD\xC7=\xFC\xBF\xEE\xAD\xB1+\xF1\xE46-\xE0d\x8D\xC0\xD0R\xFA\x93zB\xED\xAE\xBB2\x0EB}\x9E\xF4=\xAE\xFF\x8D7\x125\xDE\xB5~\xB3\x17\x81\x10\xE4\xE5j\xBCk\xFD\xA6`\x18nC\xFE?\xE7\xF6?W\xF8\x1D\xC2\x1A\xEA\x10L\xC5\x04\xF0\xCC?\xE7\x93G\x7Fx\x8D]\xC1\x93\xA7EWn\xAD\xE7h\xEC\xF2U\x9BL5\xD8\x98qP\x97B\x04\xA5\x98\x7F\xD0\xE6\x89\x88\xD8\x8F25\xDEh\x90\x06\xED'\xD4f\ba\x18\r\xC2(=bU\xE2\xD62n\xB2>#\xC9\xDA\xA4+$\xFB\x8B=\xEFSw\xA8\xA8\xC6\xAE\xCE\xA8/r\x81\xDD\xF8\xDD!h3_\xB4\x94I\xF8!_w\xF0\xCF80\xC7\xE7\x9B4v\x9B\xA9\x1Ao5\xAF&\xFFc\xDE\xAB\x1E\xFC'C\xF4\xE9\xC0\xE3\xDE\x19\x07\x12\xA7\xED\xAD\xB1;\xE7\xE4\xB4\xD1\x9A\x8E\xCA\xBD\x7F\x00\xB5\xECF\xD0\xEDC7rg\x1C\xB4\xE4\xEB\x0Ff\xFE\ry\x04\xDDt\xC8B\x8D\xF7\x91W\xF5\x9A\xFCYK\xB6J\xEB\x9Bq\x90\xF5\xB9\x9B\xA3/|\xCE\x96q`\xF3\x7FA\x8D\xDD_w\xB4\xCC\xDCn\xE8\xF3wP\xCB\xA0\xB6\x0F\x9B\xFB\xF3\xF5\x913\xE3\xA0\xA5\xFFN\xB5\x14\x96\x1E\xE5\x11\x04\xE9\xB2\x97P\xE3m\xF7\xF5\x9A\xFCYK\xE6+\xDF\x15\x8A\xAC\xCF(G\xB3\xF8\x9C-\xE3\xC0\xC3\xFF>\x1A\xBBNF\xFD\x05\x07\xF7\xFE j\xF9O\xE0\x85n\x1F\xE6\xAB\rW\xC6A\xE5\x87\xDAu^c\xE9Q\x1E\xC1\xACXvD\xFEWk\xF2\xA3\x96P*\xE3\xA0\x1D\xE5h\x16[3\x0E,(\xAA\xB1\xEBb\xD4\x05\xF3oj\xB9\x1Ae-\x7Fs\xF38l\xECw\xCF\x0E]\x19\x07Gn\xD6\xFD\xAF\xB2\xF4(\x8F\xE0K\xE2\x92\x9B\xB6\xFC\xB8^\x93\x1F\xB5T\xD6\x1D<3\x0E>\x9E\xA7Yl\xCD8 \x10\b\x04\x02\x81p\x03`\x8C\xA2\xE9t\x9E\x1C\xEA\xBE<9\x8E\xA6\x1BG\xEA^:\xD7\x96\xCA\x93\xFB\xA0\xFB\xEAH\xDCKw\xD1\xEDw|\xBC\x16o]\xF6`\b\xB5}\xDC\xBF\x14MWW\xA3\x13\xDDg\x97\x98\x7F\xC7\x88\xE4>\xB1\x9D\x06\xD4F\xA8\xE5~\x165\x972?\nO\x0E\x15_\x9E\x1C\xC7\xC7\xF2?y?\xDAs\xBC\xFF\xEC\x8A\xD8c\x9E\xCA\x07\xBC\xF2\xF0\xCD\xE9\xED\xFD\xBCt<\xDE\x02\x1EL[Yh\xF4\x06*3\f)?\xCC7\xBF\xB3K\xCC\x7F\x94\xF5&1\xCF=\xB5Ol\xA7\t-\xA5e\xA3\xB7#\xBCtW\x14o\x1Cw\xF5v\xA0\x1Aowe\xFE\xDF\x13Ud?\x87l\xB8\xBB\xB7\x07U\xB6\t?G\xAA\xCD\x99\xB5\xE9>\xF9\xDB\x02\xFE\x7FA\xC4s\xFEf\x14o\x1C\xB3\xF1\xF1x\x9B=\xC2\x9E;\x8E\x1Co\xF4\xB3%\x83W\xA4j\x03\x9Dd\xF3\xF3?V7\xE6c\xE1$6\xEE\xB3\xDDW\xFB\xC4v\x9A\xF0\x82x\xC5,Oy\xF2\xB4\x7F\x85'\x87\xAA/O\x1Eo\xB2\xB5\xFC\x83;\x89Z\xEA\xBA\xC9\xFE\xF3\x7F\xB6\xF6Y\xEEy\x1E\xA5)\xD8\x83\xDFy\xF5\xB3P\x8B\xB7\xDF\xD9M\x1E7\x9B\x83\xBB\xD5\x95\xA9\xE4q\xF0\xEEd\x93\x997\x1B$\xE63\xE2\xFC\x83\xCA\x0F\xF7\x06M\b\xD9\x96\xD9\xF9aa\xA7\xE9\xFA\xF3a\xF1r\x8E=\xA8\xBE\xBF\xDF\x145\xACt\x9E\x1C\x82\x8C'\xBF\xDB\xC9\x93\xEB\xFE_F6g}\xA2\x04\xFCB\xFE\x9F\xC3\x19\x07\xAA\xC6.\xBB\xFE\xD4\x93\xD2\xF4\xAF\xFC$\x94\x18l\x81\x8A\xCA\xE5~\xDD\xFB\xFA\xF3\x8AC\xE3@\xEEs\x0Ee\x1C\x18\x802\x0E\x9E\xDC\x958\xED\xA4\x7F\x99'\x87\xD0\x97'\xC7\xF9Y|\xE6\xAFi\xEC_\xC4\xCE\xC5\xF7\x1C\x9F\xF3\xF6\xFF\x93\xAF\xE7d\x1Cd+;\x9A\xEE\x80\xED\xF77G\xE3\x00\xF7\xE3\xD08\x90\xFB\xE4vZ\xFD\xAFe\x1C\b\x9E\x1C&\xC8\x93\xCB}:\xF0X\x81\xEB?\xE4i\xEC\xF2k\xCD\xB0\xE1\xAC\x99#\xCD\xF0\x1C\x8D\x03\xF5\x1B]4\xE3 \x0F-\xCCi\x83T\x97>c\xFE=yr\xCC>\xB5\x9D\x8A\x00s:O\xEE\xE3\x7Fs\xFD|\x83\x9D\xB6\x8C\x03\xC6OJv\xE6h\x1C\xE8*\x03E3\x0Eth+)\xBD\xC8T\x97\x1E\xB3\xF4~<9H<9xF\xC8\x17\xF0?\xE4\xD9\xC9\x07^\x1F\x8DQ\x06\x96V\xEDG\xC9#p\xFA_kY4\xE3\xC04\f5\xE2]\x89\xA5Wxr\b|yr9>\x1F<#\xE4\xFD5Y\xCC\xF5\xF3\xE5\xD5\x04\xE0\xCB\xA3\xC8\xFFj\xB5\x1F\xD9\xCE\x1C\x8D\x83\xBE\xDF\x88\xEC\x19\x07\xFE\xFEW\xEB\xD2#\xE6\xDF\x93'\x97\xE3\xF3\xC13B\xBE\x80&\x0E8\xECLW\x13\xE2\x1B\x8C!\xF6\xBFZ\xEDG\xB63G\xE3\xE0\x01\xBF\x11\xD93\x0E\xDC\xD7\x9F\x00B\xA2_\b\x04\x02\x81@\xB8.H\x18u^#\x14\x92\xD7\xF1\xAD2z\x8Ep\xDF'\xEF\x97\xD3\x98\xDB\x1A\x88\xBF\xC5=\xECo\r\xA0.\xC5\xDCvQ\x04]\xD7\xF9l\xCB\x19uCKmD\xFE\xC8\xD6G\xEA{\xD6\xF5\x11\xB6\xFF\x0F\x8F\xC8\xD9\x01))\xA1WZ\xF8\xCA#\xDB\xF1\xBE\x95=\xD7\xCFW\x16tF]}\xFA\xB3`\xA1\x9C\xC6V/\x14\x7F\x8B\x95v\x17z!TC\x9Dy\b\xD0\xD3=>\xAE\xAF\x11\x98Z\xAA#\xF2G\xB6>R\t\xAD\xEB#l\xCF\xAB\xF17#Xf\x9B(\xBF/\"\xAEE\x9Fw>\xD8\x8C\xF7-\xCEB3F\xFD\xAB\xC7uF]\xE1s\xAC<y)\x8D\xE3\xE6s\xA1\xF0\xFC\x00\xFD\xD5\xA3\xCF\x85p\x93\xE4\xFFY\xB4\xC7\xBC\xEE\xACe\x8D\xC0\xD4R\x1DQ\x01\xFF\xF7\x92\x98\x7F\xA8\x0Ep\xD8\xBFXyi\xA6o-\xADe\xD1\xE9\xCB\xC3,\x1C}\xF9\xCA)\xA8\x9E\x8A\xF7\x99\xFFW\xE2=\xFB^\x7FI\xF3\xD8\x976\x8FC\xED8\n\xA3\xCA\x16\x05\x8C\x18\x94\xF2\x7F{0\xC8\xFE\x16\xFD\xD5`0\x80p 3\xCF\x16;\xB5#\xB3\xCCf\x9F\x11\x15\xF1\x7F\xBA>R\xEDX\xD7G\x82x\xCF\xD5\x10\x9E\x18\xC2\x17\"\xA6\xA1\x90\xCA\x1Fp5\x84x/\xCF\x7F\xAC\x98\xE0\xAEx\xD3\xF3\xD6\xD8\xF5\xE7sz9\x19\x07\xA0\xF0\xE4\xE0\xC1+\xCE\x81o\xCB\x02\xFE\x17\xEB#A\xD3\xBA>\x12\xC6\xFB\xA5/\xC7-\x9F`eL.F \xE4\x0F\xB8\x1A\x02V\xA3\xBE\xF3O\xB7\x15\xFF\xE7T\xBC\x99\x86\xC6\xAE;\xE3\xC0\x82E\xA7\x87\x9F|='\xE3\xA0\x84\xFF\xB3\xF5\x91P\x9A\x15\xCA\xFAH\x14%j\b/Fb\x19E\xD6#@\xAC\xC8g\x1E\x8A\xFD\xFF\x9D\x16\xF8V\xBC\x99\x86\xC6\xAE;\xE3\xC0\xC0\xBF\xA9-\x17\xADL\x1DxF\x1D{\xF9\xDFg}\x84\xDDY\t5\x84\xAAC\x8F\x80\xFB\x9F\xB5\xAC\xA0\xFB\x9F\x9C\x8A7\xD3\xD0\xD8ug\x1Ch\xFE4d\x1CDf?\xE8\xDFYCn\x827\xB2\xF5\x91\xDA\xBEu\xDD\x81UO\x12j\biv\x80\xA4G\x80W\x13~\x8F\xB7d\xA3\xF4\xABx\xE3\xEB\xFF\"\x1A\xBB\xCE\xD5\x04\xED\x9Ac\xC88\x88\xCC\x1C\xA9\x0FK\xEF\x8Fl}$\xB0\xAF\x8F0\xE5\x02\xA1\x86\x90d\x07\xC8z\x04x5\xE16v\xA5Z@lv^\xC5\x1B'O^Rc\xD7\xB9\x9A\xA0\xF9\xDFG\x8F\xC0\xBF\xDAO\x01 \xFF[\xD7G\x98r\x81PCH\xB2\x03d=\x02\xBC\x9APA\xFE\xF7\xABx\xE3\xFC\x86\x96\xD4\xD8u\xAE&h\xFE\xF7\xD2#\xF0\xAE\xF6S\xD4\xFFL_`\xDF\xBA>\xC2\x94\v\x84\x1A\xC2\xC7Mz\x04x5\x81\xFB\xFF#\xBB\xC4\xBE\x10\b\x04\x02\x81p}\xE0\xAEx\xF3\x1FZ\xCE\xE7\xDF\xFA^\x893\n\x9E\xDC\x18K/\xF1\xE4n\xC2\xB8\xAE\xDA\xE9\xC3\x90\xF8#\x7F5A\xD48\xB5e\x1ChGt~\xC0]\xF1\x83\xAB\xFA6\x87\x16\x13Q\xC5\x0F\x7F\b\x9E\\\xD5w\xD6yr\xB7\xFFoR\xED\xB4\xE1\x8ER\xFE\xC7\x91\xB4x5!\xAB\xDD\x9D\x06\xD3b\x9Bu\x95\xE4e'?\x8C\xD9\xFB\xC7\x9F[\x81\x9BVp\xDC\xFB\xD2\x17\xC1\xC5\xFFW;\xA5\xFC\xBF.bt\xEFP\xA2\xD3\xAB\xEB8:=\xCF\xFF\xD9\xAC\xBB\xCDy/\xBD\\\xCE\xFF\xD5?\x03\x80\x8F\xB2\xD7\xFF\x03\xEA\xE1\xA3\xD5?\x03\xBE\x1D\xF9\xCB\xA4\x7F\xC4-\xFF\x95v\xAE/8\xFD\xFF\x92\xC7\xFC\x7F\xC2f\xFF\x91\xD7\xCA\xF8\x9F\xF3\xE4\x9A\xBE\xB6\x81'\x9F\xD0\xFC\xFFw\xE5\xFC\x1F\\\x16k\x1Fx\xAD\xED\xE1\xFEe\b\xD8\x96>d\x7F\xE1k\x96\x8C\x03\x86\x8BC\xB3\xB7\xF5#/\x9D\xDB\x86\xD9\xEDx\xAF\xF8\xDFv\xFD9\xDA,1\xAE\xDB\xFE\xA4)\xFC\x8F5\x9Du\x9E\xFC\x1E\xB7\xFFg\xB7=\xFD\x7F\xB1\x94\xFFOD-%\xEE\x9AC\xD78\xB8h\xCB8\xD0\xD8\x9B\xEF\x9B\xAB\xBB[\xFD\xCF\x99\xD2\x17\xAD\xF6\x97aT2\x9E\\\xD5Z\xD5xro\xFF\x7F\xC6\xFD,_\xCA\xFF\x97\x1E)\xA6q\xE0\xF3\xEBo\xA9\xEEn\xF7\xD5\x17\xCB\xDBo\xF7\x7F\xD6\xA7\x97\xBE\xB0\x7F\x9F\x13\x85\x92q`\xC2P\x9F\xE1\x853\x0E\x9C\x15o\xB0\xAF\f(\xC5hI\xAA\xC1\xCE\xB3\xFF\x9E\xDB\xAB\xBA\x9D\xB6+y9\xFF{k\x07X3\x0E\xB4\xB3/9\xE7\xBF\xCETsUw\x9Fhj\x7F`\xD5`\xF7\xD9os\xFB_\xB3s\xC2\xFE\xCF]M\x905\x0El\xF3\x7F\xCE\xF9$\x92S\xF1\xA65y\xFFc\xD5`\xF7\xD9+\xDE\xFEw\x87\xF6\x9C(u\xFD\xF4XM\x904\x0El\x86\x9Cp^\xFFs*\xDE\xB4\xC03\x9A\xBD\xA8\xFF}\xEA\xEDT\xBC\xAF?n\xFF\xB7K\xFE:xW:\xB2e\x1Chg\xAFR- \x02\x81@ \x10n0\xBC\xAB\xD5\xB4\xB7\xD5\xF0)\x00\xF4\x14\xE3b\xD4\xE5\x96c\xFF\xCA\x00\xDE\xF0_\x05\xE8\xEE\x1E\xB6e\x97\xC7k\x15\xCC8\xC0\xEC\xE8r\xA4\xEE\x93\xE3\xBD\x82\x9C3\xAA8\xC1\x19u\xFE<\xA22\xEArK7c\\\xD8\x06\x8F>\xCB=\xAF\xD9Z\xCE\xF3\xE1\xA0\x11\xF9\xE0\xDFh\xFE\xE7\xFC\xF0_),q!0\x16=\xB1\x96\xBD\xFE\x18{\xAD2\xEArK\xB7\xAF\xFE\xDDW\xF7op\xFF\x7F\x94\x0F\x07\x8D\xC8\x07\x98\x8B\xFE\x02\xE2\x87\x1B\nK\\\xEC1>\v\xE6?\xD1\x8F_?\xAC\xF9\xA1\xC3\x8E\xE3\x96_p\xFA\xAA\xB0\r\x1E}\x96{^\xB6\xF9\xBF\x13\xB1\xE1\x04\x83B\x16bv\xE8\xA2\xA3\xE2M\xD9\xEB\x0F~\x12t\xC7\xE7\xE70\xF6Q\x19\xDE\xC3\x7F\x15\xC0\xFFy\xF9\xC4D\x9Fg\xC7Z\x1Drs\xC5\x9BB\xB0j\xEC\xA2\xCF\xE2\xF5\x91\xDAr\n\xBF\xBF0\x85g\xFFK-\x1Bw\x04%2\x0E0;\xE1\xACxS\x1A-#\xA3\x1Eh,WN\xC6\xC1\xD9p\xAA\xF7?\xD7\v\xF8j\xE6\xACxS\x04V\x8D]\xDCgGi\xD9\xF0\xAE\xCC\xE3\x8FF\x81Z+\x87\xF5\xA4\xAE\bP\xD4\xFF\xCE\x8A7\x85~\x7F-\x1A\xBB\x16=\\\x8E\x0FzW\xE6\x99\x86\xFF\x17\x0F=\x93u\xCD\xE2\xC2\xBF&\xCE\x1A>\x87\xF1\xBF[\x0F\xD7\xC7W'\xFA7\x8A\xFFm\xDF\x14\xA6\\P8\xE3@\xFA\xDDw\xD6\xF0)w\xFD\t\xC0W\x0Fw\xC1\xBF2\x8F7\x16\xAE\xE1\xFCg\xCA\x05\xC7I\xE1\x97@ \x10\b\x84_\x16\xB8\xE2\xF3\x012E\x80\xFA\xDE\n{\x0E]aUYV\xB4\x1Cv\xAC\xF1z\xDFZ\x13\x00\x9Ef\xFF}\xDA\xA9\xF1\xCA\xFB1\xF4\x99H\xAD\x95\xB9\xF3\x14v\x8A\xBDb\xA78\xE2\xB6\x13\xD7\xD8\xD7{\xB3\xDD\xEB\xDE\xD7R{s\xC3\x15\x9F\xCFb\xCE\x93\x83\xD5N\x12\xF7\xC8\xCB\r\x992)\xC4\xC7Wa\x15\x87\xAAZ\xEDh=\xE3#\xE9g\b\xE3\xA1\xA4d8\xE6\xAF\xEBW\xCBL\xA9\xD4N\x00\xB3\x9D\xE2\x88\xDBN\x9C\xF1\xE1\xD6\xB6\xC3\xF3\x96G\xD1T\xA7\xE0\xFF1\xD3#\x1EG\xD0\x18\xA6\xFE\xE1\x9F\xFEO\x8EA\xE5X\xE3'\xC7D0\xF6W\xD6V\x00\xE0=\xF6\x87\xEF95vy?c6\xFF\xC7\x13\x9A\xFF\xBC\xD6\xC4\xD8R\xBD\x1C\xCF\xFF\xAF\xB0\xF9\xAFk|\xE8\xF3\xFF rqJXu\xA2\xDB\x82B\x951\\\xF1\xF9\x00p\xE4rr\xF0\xC8\xE5\xA46\xD1P\xD3#f\xB5\x89\x9A\xBD\x8188\xB7\xD64\xEA\x11\x1B4\xA6S\xDE\x15\x8B&g98\xD5\xF3e\x9E|e\x8D\t\x01\xAE1qWo'c6\xD6\xF6\x84\x9Dn\x8D\x89\x86\xA6\xEE\x81\x81\xBD1\xC7\xFC\xFF\xFF\xF7\xF7\xFF\xA7\xEC\xF1\xF9,\xE6?9x\xB4\xD9x\xA3\xC3-iG\x06U\x88v\xBF#\xAA\x15\xCD\xFD_\xDE\x1A\xBB\xDC\xFFC\xAD\xCFTj\xB0\x84\xFF\xDF\xDF\xEF\x88\x9E\x8Dvf\xBC\x13\xAB\x8C\xF49o\x8D\x03\x1B\xA7qR\xF3\xBF\x7Fe*)>\x1F#a\x9ECq\xD1k\f\x9A\xFC\xB3\xEE\xC9\xD7\x7F\xAE\n\xD1\x1B4E\xB5\xA2;;\xBE\x1A\xBBB\xB5D\xED3\xD1\xD8-\xB3\xF2%\xECT\xAE\xD8\xC2Nq\xC4m'\xD68\xD0\xBFM\x18\xB8b\x15\xCF\"9_\xC0\xFF\x99\x9D\xCEh\xF6a3\x9DQ\xB9z\xB8w\xA2\xDF \x1F\x8D]\x9F>\xFD\xD1D3\x7Fbvj\xDF&\x9F>\xBD\xFC\xEF\x8A\xCF\x07\\i\xBFi\xD3\xC3\xD54v\x1F\xF4\x8E\xF9\x17\xB34Wc\xB7\x80\xFF\xBD\x15~\xDDv\x82\xC9N#0\x93\xFF\xA0;\x87B\x833>\x1F2E\x80\xFA\xA8m\xD3\xC3\xD54v7Z\xBE1\xFF\xED\x94\xF7\xCE\xD5\xD8-\xC0\xEBz+\xFC\xBA\xED\x04\x93\x9D\xB9\xFE\xDFp\xC7\xF0\x1B\xC8\xEB\x1C\x96>)\xFCXm\xF4lz\xB8\x9A\xC6n\xC5;\xE6\xBF\x87\xFC\xEF\xD6\xD8\xF5G/\xF2\xCF8\xF0\xD58\xE89\xFD\x7FB\xBB\xFF/\xEA\x7F\x07K\x9F\x14xL+\xED\x1B\xF4p5\x8D\xDDJ\xCB_c\x17<5v\v \xF2\xCF8(\xA3q`\xF8\xC6\xB5T\xFF\x93\n0\x81@ \x10\b7\x10\x10\xA7\xF7\x91J\xFC\xF0y+{\x8DK\x10\xDEZ\x19\x02\xDFL\xEC\xB7\x81\x03\x9F\x19\x940\xC4\xD6\xE7\xCA\xC6 \xEE\x10\xF5\xF9\x11K\x0F\xB7jG\x8E1\x9B\x8F\xF1[W\x8F\x11\xD9\xA0\xD7\xD8\xF7\xA9\xB4\xC9\xFB\\\x88\xD4\x1E\x92\x1A\xFB\xBC\xCC~}\xBB\xD4\x1D\x9D\x9B\x03\x0F'\xD9\xA7\xA6\xF1W\x0E]\xEF*\xE2:t\x8D\t/>\x19\xA9K\x184&\xB8\xCCD\xF5\xA9\xCCBo\xFD\b[vL\x82z\xF9\xFC\x14/\x8D\xE9]_\x0F'#b\xEDq\xC6GQ\x8D\x8F\xDBJ\xCD\xFF1\x9A\xF9\x8F\xDA\xE6?\xBA\xFE\x04\xB9\x15\x9F\x14\x96r\b\xE6\xEAX\xE5X\xFA\x02\x1A\xD3f\xE8\xAA\xA3|D\xBA\"\x83>\"\xB7\xC6\xC4\xA3Z\r\xA5\x7F\x1E\xF9\xF2~V\x8D\t.3\x81\xAAH\xCD\x1E\xF9\x97\x00\xF0\xAF#\xD5\xDA\x7F\xFD\xD5\x7F\tG\xD8\xA6\xB1\x94f\x0E\xF0\xE6\xA7\x0E\xC9R\xE2>_y\xFE\xA9\xB8C\xD4\xE7\xAC\xA5\x07]\xF5\xF8CL\x14\xFBKl\xFE\xE3X\xC1\xDF\xFC\xEAq8\xC26q\x16o\x8D\x89s\xDA\xEA\x80\r\xAF \xCF\x8Fu\x8D\t.3\x818m\xACq\x8C\xE7\x98^\x91\xFE\x15\xB4\xFA`X\x83(\xB5Jh\xEB\xD3\xA0q\xEC=\xFF\x9F\x94\xEA&\x95\xBF\xFE\x83V\xC3\xA1\x1A\x15\xFBEkx\xFC\xA2\xFD+\x96\x07q\xA0\xCD\x16\xBD\xE2\x10\xCE\x0E8\x98\xD0\xF5\xDF\xD6\xA7~\xFD\x7F\xDAr\xFD7D\xC3\xD6G\xC6\x8C\x03}Dco\x8D\t\xFF\xDF_<\x96\xAE\xAE1QW\xA3^\x03\xDB|\xD0X\xC7F\xCE\xFD\x0F\x94\xF6\xBF\xA1O\xED\xEC\xF3\xDE}\x1E\xEC\xB6\x8C\x19\x07A\xD0)\xA4\xF1\xD4(\xF5\xFB\xDB\xB0\xE4\x105\x9EC\xDFh\x1C\x1F\xCE\xEE\x07t\xF6\xBB\xCB\xD9o\xF4I\xD9\xB2\x03\xD2\xFB\xFF\xB7K\xDF\xFF\xF8\x9C}\xDE\xFB\x0E\x93\x8F\xA8\xED\xD1gQ\x8D\x83'\xBD\xFD\xFFh\xE4<\xBBE\xBB6\xA7~\xBE%;\xC06c\xFD\xEF\xFF\xFD4v\xCD\x1D\xE8\x8A\x00\xAE\x8C\x83\xC3i\x1C\xB4\xBC\xBF\xD19#\xB2h\xD7\xE6\xD4\xCF\xB7d\x07\x1Cf\xFE\x17\xD1\xD85c\xD5\xE2\x7F\x9F\x11\x15\xD58\xF0\xE1\xF3\x17\x0E=\"\x02\x81@ \x10\b\xD3\xC31\xB4\x97x\xF2\x84O\xC8(\xB6\x8Fx3\xEA\xFE\xC8\xE2\xF3+\xE1\xCA\xC6\xC0\xC1<\x8C\xB6.\xC7{v/1Bw\x14\xF1\xF1:\xDBR\xFC\x8C\xC5\xB4\xEB\xCF\xAAz\xC4;\xEF\xD3\x8A\xFA\xE5\x12#\xCA\xEC\xAC_\xD6\xEDt\x9F\xD1?\xEAoR\xF1\x81Y|~}\x0F\xD77\xD0\x99\x87 \xEA\xB0=\x88=:\xCE\xB7\x04\xB7D\xB1\x87\xB9\\\xDD,\xD6\xA2\x8D\x8Fo\xB3\xBD\xF8[\xB7\x8AA\x19\x8D\x03dgG\xB7\x93\xBF+yr\x17\xCC<9\xFF[\xBD\x86\x95\x07\xA3^\xE0\xC9W\xC4\xE7WB\x9C\r\xA1\xCF\xFF`\xEB\xB5x\x16\xB1/\xD9\b}\xD5Fo\xBD\x06u\xB6\t\xFFo\xED\x183\x0E\xDE\xDB\xDA\x81\xFA\xCE{[Y\xCCy\xF0\xD6\xE4\xE7\x7F \xD4E\xEB\xFB\x07\x1A\xF3s\xB0\xB5\xAF=\xA7\x80\x99'O\xAE?\x19O\xEE\xCF\xA8\x17`~\xB0\xC6q/\xBB\xFE\xE8\xCC\xFF\xC8\x7F\xFE\x9Fm\xC6Vi\xF3\x7F\xFEl\x13*\xCD\xF9\xB3M\xD4\xE7\xE4\xE7\xFF\xA8\xE0\xFC\xFF\x10\xDB\x1Bx\xF2$\xD5\"\xE3\xC9g\xBD\x19\xF5\x02\xFE\x17\xF1\xF9A\xE7\x95\xE73\x9E\x9F\xC7\xE7\xE3\x98\xFF\xE0'\xF1g\x11j+z\xC7\xCF\x0E\xA0\xC2\xB6\x14\x7F\xDF\xCB2>\xDEqf|\x04g\x9D\xAB\xD5\x952k\xD9\xB5\xB3\xA9\x9D\x95\x81n\xE7q\xED\x8C\x98'wg\xDF\xCFM\xE1\xD7?\x8B\xCF\x97\xC3\xFBy|>>\x18\x9E\x8F\xAFE\xF7j\x8C\xE2\xF0|\b\xC7\xD8&\xE6\xFF\xF3\xF1_\xBD\xACq\xF5/?\xDF\x84\x9B\x9B/?\xAF\xF6i\xBF5)\xC3eev\x1E\vu;\x87\x963\x1Axr\xFE\xB9 \x9E\xFC\xC9\xD7}\x19u\x7FH\xF1\xF9\x9B;\xAEq\xB16\xBB\x1E\xF1\xF9\xB7 \xCF\xBB[\x86\xC3\xC9\xCF(\x7F;\xB1\x9Fu\x8D\xDD\xE4\xBBPm8\x18\xB3Cq\x9E\xDC\xFF\x92\xC6n\xF6\xDD\xD4\xA3\xEE\xEF\xDD\xF4\x8D\xCF_\xF6\x8E\xF9\xBF\xD7]Q\xA7\x14Kv\xAF\xAC\x1A\xEC8;\xF6\xB3\xAE\xB1k\xC8z\xF0^#\xF0G\x1Bk\xECnf\xFE\xD7\xA3\xEEw#\xDF\xF8\xFCK\xDE1\xFF\xBB\xEE\x8A^\xA5\xE6\xD5\xAE\xAC\x1A\xEC8;\xF6\xBFUc\xB7\xDC\x1A\x817\xB0\xC6q\v\xF5\xA03\xFF\x10\xF9\xC6\xE7\x07\xDE1\xFF0\x05\xFF+\xAA\xC1\xAE\xB3#\xFF[5v\xCB\xAD\x11\x14\xB46\xD1\xD8E\xCF\xBF\xA6\xA8{\xDF\xF8\xFC \xF2\xCF8\b'~\xFDQT\x83]g'\x10\b\x04\x02\x81p\xCD\xF1\x8E\x93'\xC7\xD1\xE9\x98uws\xDA\xEF\xF83\xD8\x9B\xBE\x11\xD7V\xE6?RY\xCA\x9C\xC84mD\xFAk\x83\x9D\xD3\x18\x11{w\xDE\xC9\x93\xB3M\xDC\xD1\xB1\xC7/\xB4O\x1E\xC8\xA2u\x80u\xB6O9\xC6\xA8\xD8}\x9AO\xCC\xBF\x9D\xF9\xE7\xFFv\x90\xE5\xEESnk\x7F\xAB\xBE\xCEy\xD2\x9F\xD8\x88\x98\xAF\xB6\xF6<\xA3\xEEk\xDE\xF3\xFFV\x7Fk\xBDgK\xE0=\xFFs\xFC_\xDF1\xFA|4)\xFF\x17\x9D\xFFN\x9E<\xDE\xE4\xF6\x93\x9E\xFF\x19\x9F\x1CF\x98\xBF\x1A\x00\xF0-={\xEF\x14\x00,3\xAEl\x191f\xC9k\xA4\xC4\x9Ds\xFD\t\xCC\xD7\x9F\xE5\t\xF9\xBF[p\xFE\x8F\x9D<\xB9\x94\x9D\x81\xBC\xE4\xE6\xB4\v\\\xFF\x99\xFF\x8Fb\xAE\xD5\xE2\xFF\xE5+\x03\xC1\x94\xE2\x15\xA5$o\x02\xAD\xD1|:\xC7\xFFM\xA3\xCF\xC7\x13\xBA\xFE\xC3\xD6\b\x00*\xDA\x88t~\x98{r\xDE\xC9\x93\xC7[\x8A\xF7\xB1wm\xDC;\xE6\xB4\xFD\xAF?\xE1\xD6\xC8\x18\xCF\xA9[\xBB\x8C\xAE\x93\x18\xA2\x18\xA08\xF2P\xCE\xF5g\xCFw\xCE\x03\x94hYA5\xF6\xDD9\x14\x10e\xD7\n/\x9E\xDC\x9B\xD3\xF6\xBF\xFE\x84\xDE\xCA\xB9\xB8\xDE\x8B\xBBe^\xA5\xA9\xA6\xDA\xA7\xC7\xD9\x97\v\xD4\xAE\xCF\"\xDE5\x8D\x83\x96\xAEq\xB0\xE4\xCD\xA8\xDF\xEBR\x04\x908\xED%\x7F\xFFo\xFAj\xEC.\xD8Zj\f\xE1\x9A\xFB\xEC\xB6\x98\xDB\t\xF9\x9FG\xBC\x07\xE6\x11\x194\x0E^\xF6f\xD4w]\x8A\x00\x12\xA7\xFD\xB2\xB7\xB5G\xC1\xF7\xECc\x9B\x9D\x1AC\x9E\xA3sai\xE9\x9E\xFF\xB7{_\xFE\x03\xEF\x11}0\xB9\xF2\xF82\xEA\xEE\xF8|\xCCiW\v|[\xFD3\x0EB\xCF\x15\x8A\xAA\xB7\xFF\xF1\xFCl\xE5\xD8Y\xC6\xFF>\x19\x07\xD5\xA8L\xC5\x1B7\xA7]D\xE5\xD6?\xE3 \xF4\\\xA1\xA8z_\x7F@\xEF\xE7\xD0\x98T\xC6\x01\x81@ \x10\b\x84\xE9Ag\x14\xD3\xE7\xF4R\x8C\xBAw|>f\b\xBB\xCE\xFBp\x17\xA3.\xC7f\x17\x18\xB5\xB7\x9DR\xCB\xAD\xCBJKi\xD5\xC3?\xE3@\xE3\xBDM\xECw9F\xDD7>\xD9^\xEDG\xE7\x1E\x1D\x8Cb\xC9ZC\xFEvF\x83\xB8\xFF(\xCA^g\xC7\xC3\x10\x1F\xE1u\xA4y]\xD0\x9E\xB3\xCAt\x84\xE36\xAD5\x1C\xF6\xBD\xE7\xFF^\x89y\x05\xDE\xF3\x1F\xA60\xFF\x03o;\xA3\xAD\xF3\xC2c\xFBoeuu\xE2\xD7\xF5\xF3\xF8Hok\x05\x006X\xCB\xBFC}\xFE\xDD\xD6\n\xD4W\xFEn+\xD38\x88\x86\xD7\x7F\xFEw\xAF\xEB\xFC\x1F\x15\x9C\xFF\xFBC\xDF\xF9\xFFN\xC1\xF9\x1FZu\x1C\x06\xBE|&Z\xA3\t\xD1z\xCA\xD8\xB9\x9E\xC2=i\xE0\xC9\xB5'\xFD\xAE\x83QWTk\xFD\xE7\xFFY\xDF<\x82\xFD\xBD\xEC\xFAsfs\xCF\xE1\xFF\xBFA\xD7\x9Fg\x9C\xFE\xDF\xD7\xD6\x1D\x1A\xCE\x1A2U\xEF\xDF_\x10y7r\x9FR\xC5\x15P=\x8F3\x0E\f\xD9\x07\x11LD\x93Tb=p\x1E\x01\x82\x9EG\x101\x9F'3\x16E*\xC6\x9FEm\x0F\x7F\"\xBD\xCDm\xE1\x7F\xEC\xB1g6\xB7\xA1\xB6\xFD\xCC\xE6\xB6q\xFE7l\x8C:\xCA\xBA\xCA\xB9\xFE\xA352\x9E\xC9\xA5\xF7\xA9gr\xE1\x88\xF7n\x94\xEF\x7F\x1F\x96\xB2\x80\xFF\xBD\xD72\x92\x99\xEF\x91\x9B\x80g~N\x9FC\xD5\xFF\xE0\xAC\xA1\xB1\xE4\xCDh5\xD8obC\xF7\x9B\xC6\xE7s?\xCF\xF9x\xD8\xB5Fp\xE8\xF8\xFC<;#\xA9\xA5\x9A\x9B\x80W=z\xDE\x19\x07\x91\xC6\xBB\x1AF\x8D\x98\xD2\xBB\xBD\x19\xDD\x86\xF7j\xC2\xA2\xE5\xECz\r\x99\n\xE4\xE8\x11\x94\xF0\xBF\x7F\x1E\xC1\x19\xDCR\xCBM\xC0\xAB\x1EO{g\x1C\x9C\xD1\xFC\xEF\xAE\xE1\xB3T\xCA\xFF\xEE\xD5\x84\x9C\x8C\x03\xC0\xBF\xC8\xBE\xAA\xC1\x05P`\xD5\x03\xB5\xD4r\x13\xE4U\x0F\xFF\x8C\x03\xC4K{\xD4\xF0)\xB2\xA2\xE7\xBB\x9A\x90\x93q _\xAD=U\x83\x8B\xFA\xDFo\xD5\x03\xB5\xD4r\x13\xE4U\x8Fb\x1A\x07\x04\x02\x81@ \x10n \x1C\xB2\xE2\r\xDB\vR\xB1(On\xCB80qh\xD9\xEBw\xBCk\xD2z\xC6\xE7w\xA3\x9C\xB3c\xF8k\x9Bz\xF5\x19\x1E+sC\x87y\xF2({\xC4+\xCA\x93\xE3j\x0F\xA27\x073\x80\x9F\xFD{\x1E~h\x05\x96\xE7\x8E\x80E\xAD\x05\xD9c\x91\xFB\xEC:\xF3\xE0\xE5%\x9F>\xEBe*~D[\x03\xC1~\xBF\x17e%w\xB8\xD6\xC0\xFEV\xD6go\xAB)\xF4(1G\xFA\xCEV\x13\xEAlK\xC1{\xDB\xB0X\x8B\xAB\xFA\xF0\xDE|4.[\xB5\xF8>\xBC\xCB'9\xFE^\xD4\xDE\x06\xBE\xA5o\xE9\xBA\t6\xF8\xC7{{\xF5Yr\xFE\xAF\x88\x9E\xF1\xFC\xDF\x18\xAC@\xB8\xB21XA\xF3|\xCF\xC8\x93\x9F\x1F\xECA\xC86y\xB6\xEC{\xCF\x7F\x1F?t\x8B\xCE\xFF\xE15\x9F\xFFa\x99'\xFA\xF7\xD0\xF5\xE7L\x94Q\x1C\xFA\xF5\xE7\xAA\x93'\xC7\xD7\x9F}\xE7\xFC\xC7\xC7\xAF\xF8\xCF\xFF\x99}\xEBS\xEA\f\xDB\xD2\xC7\xF0\xD3\xCC\xF3\xA7=\xFA|\xD6\xDB\xFF\xBC\xB7\x9C>ke\xAA\xC7\xCB<y\xF6\x88]\x94'\x8F7\xD9\xC3\xB6\xD9rF\xBB\xFEx]\xFF\xFD4\x0E\x02c\xDD~\v\n\xC4[z\xF7Y\xD8\xFF\x98'\x8F\\S\xA2\x00O\x1E\xA9~\xF6\xE9\xD3\x8D\xD5-/\x8D\x83\x83]I\x8F\xC0\r\xFFx{\xAF>K1Z2O\x9E-\x19\x17\xE5\xC9A\xE7\xC9=4v{\xDEJ\x04%5\x0E&\xEA\x7F\xF0\x8F\xD0\xF6\xC6\x19\x99\xFD\x16S\xB1(O\x0E\x1AO\xEE\xA3\xB1\xFB\xB4wMxO\x8D\x83n$\xE9\x11\xB81\xF6\xF6\xBFW\x9F\x93`\xD4\x05e]\x94'\xB7e\x1C\xE88\xA1i\xB2\xF8\xF8\xCA3\xE3`>\xEF\xEC\x87\xB9\xFE\xE7\xF49\tF\xFD\xBE\b\xDDW\x14\xE1\xC9\xCBi\xECV\xBDk\xF2{f\x1Ct\xA3\x9C\xB3\x1F\xC6\xFF\xA4\x05L \x10\b\x04\xC2\x8D\x02S|\xBE\x0F\x8AV\xBC\xB1a\xA4i\xCC\xF9\xC0\x15q-\xAFe\xE4d\x1C\xE0\x1A\xEFbD\xB5\xFDn\x945NF\xA4\xD9l=\xBB\x87\x9D\x12\xED\x86\x98\xB7\x96\xF7\xE7\xE6\xC9\xA8\xE7\xF2~:\x9F\xE9uC'\xAF;(\xC7\xF5\x11\x19\xEC\xD4\x1E\x8C\xB3\x11\x05R\xC9\x80V\xA0\xAAH\xE2\xF3\x1A\xCE\xEEa'\x9A\xFF\x03\xCC\xFC\xFB\xFB\xBF\xEB\xC7\xA8\xE7\xF2\xDE\xFB\xDAz\x96\x0F\xF8\xCA\x82Y\xE3X^\xCB\xE8j{|\x1C\xDB\x99\xAD\x11\xD4\xDE\xEE\xA2\xC6]y8\xCAy\rg\xC7\xFEgG\\\x8C\xBA<\xFF\xBB\xD7|\xFEo\xDC0\xF3\xBF;\xB5\xF9\xBF\xEF\x98\xFF\xB5\xCB\xF1V\xE2\xFA\x83\x18u\xCC(*\x8Cz.\xEF\x8D\xDF}\xC6\x9FQ\xDF\xBC,\xFE\x16\xF30\xFC\xB8>\"\x83\x9DI\x06\xFD\xBEaD3\xFB\x07\xBBY\xE3dD\x9A\xCD:\xAB\x9F\x9C\x1D\x7FS\xE4\xF5\x11\x03\xE4\xF8p\x7F\xFF\xAFF\x16v\xD1\xF2\xF4\xED\xF3n\xB5T\xBD\xB5\x863;f\xD5\x1D\xE5\xAE\x7F#\xBC\xF9\x04{n\x0E:\x80\xD7G\xCC\xF7?R\xB5\xB7\x02\x1C\xC5\xD44v\xBD\x18E\x94\xF1\xA1j\xEC\xCAYl)\xFF\x06\xB9\x1A\x07\xD9\x1AA}\x84\xD72\x92\x11i\xFE\xD7s\xE8t\x85\x17e}$\x177\x82\xC6\xAE\x0F\x1A(\xE3C\xD5\xD8\x95\xB3HJk\x1Cd\xE9o:3\xEC\xADY\x1CYV=\xA4\xAF\x9D\x87\xC6\xAE\x8E\xE9i\xECz\xF9\x9F\x8D\xEBQ[v\xA4\x16q]L\xE3\x80\xDD\xFF?\x13\xC9#\xC2s\xCF\xA5Y,\xE1\x8Ce\xD5\x03]\xFF\xBD4v\r\xFE\x9F\x9A\xC6\xAE\x97\xFF#\xDF\xEC\x802\x1A\x07\x81\xBE\x96\xF1\x82>\xFF\xADg\xD7~\xA7Z\x8E\xDF\x97\xB2\x8A\xB4\xD3\xD3\xD8\xF5\x81+\xE3\xC04\xFF\x8Bi\x1C\xB0\xEA\xFD\xF2Z\xC6q\xDD\xFF\xD6\xB3k\xFE_%\xFE\x9F@ \x10\b\x84\x1B\x00z\xC5\x8F\xF1\xD6\xE5Q\x94\x17\xC9\xCF\xDA\xBF\xEB]\xF1f\xBCuy\xE2\x96\x8F\x9D5L0\x03\xFF\xAEw\xC6\xC1\xD8\xC9\xE7K}\xDA\x9E\xD6\xE5\x0Es\xD7Gx|\xAC\x14s\x1B\x85Y\x00'\x8A\xE4L*x#^\xA5\x1A5\x05WS\x95\xD8\x9B&@\x93\xBF\x9B\xFE\xED\xB1\xC9O\x1Dw\xA5\xF1(\x94\xED\xB1\xDA\x89+\x12\xF3~f\xD0\x9Ec&Z\x11{\x9D\xA1:&\xDDO\xEE\xB1\r?X-\x88\xE7Y\xFCT\xCB\x15cy|>\xE6\xC9;\xFD\xF3\x9D!tX\x9F\xF1\x8B4\x00\xBB\xF3\xC6y\b\xCE\xC7\xFB\xF8\xA6?\xDE?\xF6\\l\xCF\xE3\xAC\xE5\xE3\xC8\x86\xC7\x9F[\x81\x9BV\x1E\x7F.\xB3\xB6\xF3\xC6`\xE2\xEE\xEF\xF4wD\xB5s\\\xF3\xFC\xD3\xFD\x1D\bv>\xDD\xCFj5<\xF6\\\xEC\x90\xCF\xB16\x9FC-?\xF7\xDC\x1E\xDC\xC46\xF1\xB7|\xD4h\x9F\x9Ek \xF6\xC9\xDF\xA2w\xA5\x8A\xD375\xE3M\xF1s\xEA\xF9\xAE\xA6\xD8\xAB\xCF\xFFN\x7F\xD0\x89\x12\xB7\xC7/\"dC0Hl\b\x06l\\MqvlC|\xFC\xA6&\x7FW|\xA6S\xF0\xFF\xC0\xEA+a\xA7\xB0\xC7n'vW\x07}\x9A\xEAg\x9A\xEEu\x9F\x7FN\xF2\xBF\xF4\x81\xC6~\xAEe\xD7\x9F\x00\xF2\xAF?\x9D7\x06\xC2\xED\xF8\xFA/\x8D\x8B]\xFF\x1FG\xE3z7\xC7\xFF\x93\x9F\xFF\x9FF\xFE\x1F9\xFD\xFF9\xA7\x9D\xBA\xFF\xCD}\xCA\xA3x\xCCv\xFD\xD7\xE7?\x8Ax\xC7\xAC\x0E_\xDB\xE1\xF1\xF98\xE6\xBF\xB3\xB57\x16\xD3\x1E]\xFF\xB9\"I\xAA\x0F\x1E\x7F^\x8F\xA1\xDF\xB5\xAA\xF3\xF7\xB7\xB3\xB57\xF9\xF9\xCF\xFA\xECh\xD7\x7F\xD9N\xC8\xB5\x13\xFF\\\xE2\xEB\x8F\xDAg\xBA\xD7\xE7|\xD5\xFD\xFB\xCB\xD8l}e\xC4\xC0f\xA390vG\xF2\xB3\xEF\xD4c\xDE\xDA\x01\x9D)h\xEC*v:P\xC0\xCE\x82}\x02\xE4\xB7\xC43\xDFP\xDDQ\x8B\xBA\xEFl\xEEw\xA3\xBCH~\xD6\xE9c\xDE\x15o:\x9B\xFB\x93\xF7\xBF\xF7\xD9\x1F\xF3\xCE8\xE8\xB84\x0E@\xEA\xD3V\xB3.\b\x15\x823\xA8\xB94\x0E\xF4\xA8\xFB\x83(\f\xA3\xBCH~\xD6\xE7\xD8\xBB\xE2\xCDA\x14N\xDC\xFF\x07\xDEg\x1F{g\x1C\x1C\xB84\x0E`\xCEG;\xA0\xA6\xAE\x11\xB8\x15\x01\x8C\x15o\x84\xFF\xAD\x91\xFC\x01\x14\xACx\x13N\xE9\xFE\xDFO\x8F`\x12\x1A\x07\x006\x8D\x03\xD9\xDD\xACO<O\x9C\x19\x07\xC6\x8A7a\x94\x17\xC9\xCF\xC2\x00\xAA\x93\xD2\xD8=\x84\xFF\xFD\xF4\b&\xA1q\x00`\xD38\x90\xF8\xFC\x19\xD6\xA7\x04\xE7\xFA\b\x81@ \x10\b\x84k\x0F\xEF\xF8|\x1C\x1D\xE7\x0F\xFF*:\xB6\xF8|%\x89 ~\xF7Ug|~\x81\x11]>\xE4\x88T%V\xB9\xC3\xEE.X3\x0E\x84\x9D\x8C\x1D5<\xC7\x19P./X\xE5'\xDD\xD0yr`<\xAD\xA3\xFD|\xDE\xD9\xA71\"\xC3\xB8\"W\x87V#\xD1\xD0r\xBC\x14\fJ\xB34\x9D\xA8\x98\xE7\xA5\xF9\xAF\xF9\x7FN0\xEA\x95\x05<\xFF9\xA3^dD;\x87\x1C\x91\xC4\x91F\xAA\x8B\xE6,#\x9A\xC7\x83B\xDF\xD6\x1Ck\xEBWK[;\xF2\xF6?\xB7s\x1E\\\xD7\x9F\xB9Zv\xFD\x91\xBE\xEF\xDA\xF5\xA73\x85\xEB\x8F4\"\xE7\xF5g\xCE\xC2\xCEI\xD7\x1F\xF4L<r\xB3\x94\x95\xB0\xF4\xD5\x12\n\xCE\x7F)\xFAQ\x9B\xFF]Y/\xC0\x11*9\x9A\xC2\xF5\x07\x8F\xE8\xC0y\xFD\xE9:u\r\xD290\xF2\xBDZ\x96\xFA\xFD\xF5\xAFxc\x98\xF9\xC2B\x85'\x17\xFF\xAD\x8FpJ\x8A\x1E\xF1>\xBD\x11\x194\x0E\"C\xB8\xBB\xC0\"\xC8\x9FE\xDD@\xFEO\xA3.\x90\x7F\x15\x1D<\xF3\xF3\"\xE4\x85\xC6q\v\xAFP\xD84v'\xFB\x8D\xC6\x8A\x15]EI\xC1\xD4\xA1>\xA2E\x1E\xEE\xCE#\xDE5EZ+JE\xE76\n^\x7F\f\xF3Vc\xD4\x0F^M5vk\xFB\xF2\nEG\xE1\xF3\xA77\"}\\\xCC\xC3-\xDD\xF3V\x8D\x83d%\xA5\x8Crn\xD1\xD9\xD2\xF2\xBE\xF34D\xC8[\x18\xF56{\xA5\xAFP\xE8\x1A\xBB\x93\x1DQ\xC3\xB6F\xA0\xF9\xDF\x96q\x90\xB4\f\xB4\xFA\xF9S\xB0\x16\nT\xE6\x01s\x84|\xA0F\xDDg+\x1A\xC6\xF8|\xEF\x8C\x83\xC3\xFB_\xCD#\x90\x99\x7FW\xC6\x81\xB0s\xC6\xBB.}\xC9\xBA@P(\xE2\xDD\x10!?\xA3\xF2\xE4\x81;>\xDF_c\xB7\xD4\x88\x16lk\x04\x11(\xCC\xBF+\xE3@Q7&\x10\b\x04\x02\x81p\xCDa\xAD\x8D\xA3U\xBC)p\xE7\xEF\xAD1\xBAr\x7F\xFC,\xB5\xC2n\xD1\x1A\xFCF\xAD\x12\x1Fi\xDC\x1F\xC4/*Y\xEC\xDE}\xF7\xDF\x12\xEFY\x9B9tK7w\xFF-P\xB9e\x8E\xBD\x9B\xF4\xE9\xBE\xE5\xAD\x04%F\xA4\xD8\xD9HOQ\xD4\xCEx\xF3|\x0E=\f\xDC\xF1\xF9\x98\xAAz\xE4\rq\x8B<\xE6\xD6\xD6\xE3#\xE3G\xDE\x88_\xB0\xD7\x89\xDB\x1E\xF9\x8Bx\xCF\xDA\xFC\x02\x8D\xEB\x17\x8F\xFC\x05\xD4\xFF\xE2\x17\xEC]DQ8\x98\x9F7\xCB\x8CH\xB6s\x9C\x9E\xA2\xA8\x9D\xF1f\xE7\x1E\xF5\x18\xF5r\xEEw\xC7\x87c\xAA|\xBC\xB6)<\xDF\xFC\";T\x8D\x8F4\x9F\xDE\x8C_\xB0\xD7\x89\xFDk\xDF\x8A\xF7\xECI\xEDN\xC4(\xDE\xF9\xF2\xB7\xA0\xFA\xADx/\xFA\xFC\xA2\xD3\xB8j\xBF\xCC7z\xAD\x9F\xD9\xD9\x8A7\x8E\xE6Z?\xEE\x10\xF5\xF9\x8B\xB5o\n\xCF\xDF\x89\xFC\x7F\xE7\xDA7\xA1\xCA6\x93\xFF\xCD\xDA\xDFe\xAF?\xFE\xFE\x87v[x>\xC9\xC2\x0E\xDA\xECp;~\x11\xB4\xB3y\xD5~B\x8C\xE8A4\xAE\x07\xDBO@\xF0\xC4\x83\xEC]\xAF\xF9\x1F\x9C,3\xA4\xF6g\xC5\xE7\xFE\xE0n\xBC%g\xBF\xF4Y\b\xD8\x96\xD9\xF9\xDB\xC2\xCE\x93\xC8\x92\x93\xED\xDF\x86\x80m\xF6k\xCE\xA4\x94^;\xCE\xF8|\xEC\xFF\x95\xDFn\v\xCF'\xD7\xED\x99\xBE\xD1\xFF\xF7]zBx\xFE>\xA7\xFFs\xAE\xFF\xA8\xCF\x02\xD7\xFF\xB6d\xA78\x85\xC1Nf\xC9I\x8B\x9D\xF1f\xFA\xFD5p2\x96\x18u/\xFF\xE3\xF8|\xE9wyO\xA9u\xD3~\xA0\x9F\xCD|T\x8Ej\xE5\x81~\xFCA\xCCd\xDF\xEB\x07\x1F\xF8\xA6\xF0\x7F\x05\x8D\xEB\xBE\x07\xBE\t3\xDF\xBC\xEF\x81\xEC{\xDDv\xFB\x7F\xA6\xCC\xF5G\xB53=EQ;\xE3\xCD\xCE\x80MJc\xD7?\x96\x1E\xCF\xFCU\xFE\xED\x9B\xF9\xCF\xC6\x96x\xE6\xAF:\xBF\xA7\xED/N\xFE.\x91_p\x84\x9D\xBFf7\xE0\xA4\xB7\x9D6\xC6,\xF9^\xF4\xCB\xC7\xCDv\xBC\xA3\xEE\xDB\x0F\x8C4\xA2\xF0\xD1\xD8\xF2\x97\x03\x80\x05\xA8\xEC\xA3y52R\x8A\xBCexv\xDFw\xFEW\xF6K\xCD\x7F\xE9\xEC7\xB5\xA4\xB3\xFB\xDBi;\xBB5B\xBE\x14\x0E\xBC\xA3\xEEWX\t?~\x9B\x85\xE7\xFFB<\x8A\x05\xA8\xA2\xFBj\xBD%\xE7$Y\xCB\xB0\x17\xF8^\xFF\xAB\xA5\xEE\xFF\xE5\xB3\xFFZK:\xBB\xBF\x9D\xFA\xD9m\xDC\xBB\xA1\xE2M\xC1\xFB\x7F\xAF\xA8{dmr\xB3\xCB\xD6\xE6\x16\xD6\x02\x80\xBF\xC4\xD6V\xF4\x96\xFC5k\xF9\x81\xB5\xC0\xF7\xFE\xA7\x94\xFF\x15;\x17[\xD2\xD9\xFD\xED\xB4\x9D}\xC21\xEA\xFEQ\xF7\xCC\xDA\x8F\xB09\xC0\xF7Py-~\xFD\xA3\x11\xCC\x1C\xC1\xDF\xD6\x8A\xDE\x92\x81\xB7\\Z\xDC\xF7\xF5\x7F\xA9\xEB\x8Fb\xE7\x87w\xA5\xB3\xFB\xDBY\xF2\xEC\x04\x02\x81@ \x10&\x04\x03\xF7\xCE\xC09\xED\xC6\xFD\xF8\x9E\x16\x8C\x9C\xB6\xCEf\xDFj\xD0\xF8ki\xF1i\xF1~\x85WO\xD5\xCE\x0EZ=d\xCE\xA8\xCF\x19\xEFjdF\xDD\xDA'\xEF\x10\xF5y+\xB20P\x9F\x84\xA43\x1D\xB3\x8E\b\x8C5f\xF5\xB3\xE3u\r\x8Ed\xB5B\xE7\xDE9K\xC38\xED\xF1#\x88\xD3Fl\x06\xE6\xB4u6\x1BW$\xC6\xD5}\xA5\xF8L\xBE\xE7u\x15\xB4\xB3\x83V\x0F\x993\xEA\x07F\xFF+\x8C\xBA\xAD\xCF\xBA\xCA;\xE1g\x1F\x89u\xB4D\x9C\x1AF\xA4Err\xBEE?;^\xD7H\xCE\xCBF4f\x8C:\x7F\xD7\xCD\xA8\xFF\x02y\xFE.<\xAE\xEA\x1F\xAA#\xFA\x91Vq\x88G\xEC\xE3\xF8|\xB6\x1F\xF7\x06\x9CK\x17{\xD4\xED \xDED\x9F\xCC\xCE;\x8D\\J565\x1B\xA9\xADO\xDE!\xEEs\x17<3>\xF0\x88p\xBD\xE2y\xADq3\xCA\xCE\x8B9\x90\xC4rd\xE7\x9Dk\x7F(\xB8w\xFE.n\xCF9\xD5v\xBB\xAD\xCC\xFF\xBB4\xEE]gS\xE7\x99m\x8B\x9A\xB5\x8B<\xE8\x94\xC7\x9D\xB2}\xB3\x7FJpe*c\x16\x9C\x8A7am\xFB\t\xF5\xBC\xD8\x00dC\xB3\xDF\x11c\x91X\xA0\xA0\x93l2\xEB.\xD9)\xAC\x95\xCBA\xCF\xA1\x11\xDD\x9A\xB8c\xA8F\xD2r\xBFE\x19Sw\xDF\xAE\xCA1b\x8E\x9A\xB3\xE5\xF7]\xFA\xACx\x17\xB7\xE7k\n\x0F^\xCA\xD6\x14>\x8E<\xFFqi\\\xEAj\xC2\"\xB3\xEDV\xCD\xDA[+C\xE0[z\xA4\xFD7\x03\xF1\xEB\xA3263\x83x\x13\xF6\xFC\xF8\x9B\n\x97\x8EZJ\x8Cn{\xC3\xD2'\xEF\x10\xF5\x89\xFDy\xAB4\xFFS#\x05op6\x1B\x11\xBE\xFE\xDC\xAA5^\x89\xB2\xF3\x9Ei\x81\xCAG!\x8E\x9A\xB3\xE5\x9C\xD3N\x96rp{\xC6i\xAF<\xD0W\xB8\xDF\x93\x1A\xA7\xAD\xB3\xD9\x8B\xDE\xBF\xBFm\xF6[\x19\xB2\x03\xA1\xF3\xF7\xF7A\xEF\xDF_k\x9F\xDA\xEF\xEF\"\xF8^\x7F>\x82\xA7\x9B\x9B\xE0\x88\xB27C\xA7\xCCF\xA5u\x8B\x99{\xB7\xB1\xDF\xDE\x9C\xF6\xAD\xDE\xBF\xBF+\xEC\xB7\xB2\xCB\xFA\xEC\xEE\xBA~\x7F\xEF;\xF93\xD1RE\xEDg\xF1&f\x8E\xADO\xED\xF7\xF7\xD6R\xBF\xBF\xA9^\xD2\x8E\xE3\xF7\xB7\xABy)\xB1\x1C\xD9\xF9\x95\x93\x7F\xC1\xBE\xD7\xBE\x8C\xFAI\x9B\x80\x8A\xC6\xE6\x994v\x19\x89\x8A9\xCF \xBB[s\x96\x05O\xAF\xC0\x1Em\xF0\x1D\xA0\xA1O-\xDA\xD9\x99q\xA0\xDC#\xE9\x1A\x07/8\xEE?C\xED\xEC\xE9w\xA1\xAF\xDC\x7F\xAEx3\xEA|\xE6\xEB-aF]\xA04h\xEC\xB2\xD9\")\x02\xF0\nBl\x8D\xC6\xD0'\xA8z\x04]\xB6\xA2a\t\xC5\x90V4\xAC}\xD6\xF6\x8D\x1A\x07^\x19\x07\xBA\xC6\x01\x1FQ\x04F\x8D\x83\xA66\xFF\x93\xD7\xC8\xCE\x0F&k4\xBE\x8Cz\x05\xF9\x7F\xC1\xC9\xA5\x1B*\xDE\x04\vj|~\x90q\xD4\x86>5=\x02\xCC\xA8k\x90\x19u[\x9FAh\xD48(\x96q\xA0\x8C\bG\xF2\xA3\xF9o\xF0gK\xF5\xD5\\\"\x1C\xE5\xCB\xA8s\xFF\xEB-\xA1\xA2/\xD0k\xCC\xFF\xCC\xEF\xAB\xF1\xF9\\H\x88\xF9\xCA\xD0\xA7\xA6G\x80\x19u\xED\xFEGf\xD4m}\xCE\xEC\x1B5\x0E\x8Ae\x1C(#\xD2\"\xF9yv\x80\xC1\x9F\xDA\xFC_l\x05D\xBF\x10\b\x04\x02\x81p]0\xA7\xF3\xF9\x1A\xAB\xDF8\x1B\x989m-\xEE\xDD\xC4\x93\x83\xF19E\xAC\x11\x04\xF1\x1DX\v\xB5\xD4\xD6\bl\x8C\xFAYUa\xCD\xBD\x96Q.\xE6\x7F\xDA\xF8\x85\xCE\xE7k\xAC\xFEx\xEB\r3\xA7\xAD\xC5\xBD\x1Bxrq\xA7\xAD<\xD4\xA7-\x0F^\x1F\x1D\xBC\x9E\x1D7\xAC\x11\xD8\x18u^\x8D\x19\xF3\xF9\xCE\xB5\f\xC9\xCE\x1B\x06<F\xFAS\xBA\xFF\x11\xAB\xDF\xEC\xF5\x8D\x9C\xB6\x1E\xF7n\xE0\xC9\xC5\x93\xA6Lj\x89\x96\xF3\x95\x85E\xC4\xDFJk\x04\xEC\xF8\x18=Qb>\xBF\xC9x~\xCC\xE7+\xF1\xF9\x0E;o\x1CpV\xE7c-\x13\xA9.\x18\xC5\xBE\x16\x1F\x8E\xD6\b0\xA7m\xE0\xC9\xC5g!\xF3\xE4b\x8D`\xB1\xDA\xB8\x15\xF1\xB7\xD2\x1A\x01;\xCEW4t>\xBF\xCDx~\xCC\xE7'y\x04-\xF3ZF\xB9\x98\xF3i\x83\xB3:_i\x99Huq]\xDD\xE8\v\xCFw5\x8E\x1As\xDA\x06\x9E\\|\x162O.\xD6\bn\xAD\f\xF1\xF5GZ#`\xD7\x9F6b\xD4\xF1\xA7\xBF\xC2x~\xCC\xE7+\xF1\xF9\xBF\x14\xFE\xAF\xD8~\x7F\x01\xAD\xAAG\x81\x85\xD3V%\xAE?\xA2\xCCy;\x16\xBD-l\xDB\xF8LM\xE1W\x8A\xCF\x07\xD7<\xB9q\xF0\x15\x1B\x9F_C\xBF\xBF\x9B#\xC1\xA5K\x9C\xF6\xAB#\xA8\xB1\xCD\xC1\x93[~\x7FoE\xBF\xBF\xDD\xCD\x1D\xF3\xEF/c\x1D\xF9\xFDORK\x10\xFF\xA6k\n\xBF\xFEk\x197\xDA\xFD'\xB8\xEF?\xA3\xBE\x99\xD3\x8E\x7F\xEF\xFA\x98\xD3>x\xB9a\xD5\xD8\xD5\x16U\x93\xF30qt\x89{\x94o[\xC1\x9B\xCFo\x97\x8A\xBA\xBF\xBE\xB8\xD76[\x90\xB5\x8D\x8D\x91\x99\xD3\xFE\xF1H\x19\xD7\"\x9B\xB1\x16\x8D\xDD\x96Qc\xF7\xE4\xAB\xFB\xDD\xCD\xCC\xFF\xFA\x1A\xC1\x01bt\xA5o\x9F\xA6\xF0\xBBR0\xEA\xFEF\x80\x99{\x97\x99\xEAF\xE4\x1B\xCD\xBEh\xD3\x02\xD6xr\xB1F\xB0\xD6\x87\x16:nZ#0\xDB\xA9+\xFCB\xA9\xA8\xFB\xEB\v3\xF7.\xCF\xFF\x85\xC87\x9A}\xD1V\xEB\xDEP\xF1&iy\xDF\xCC\xFE\xEAF6\xFFMk\x04f;u\x85_\xA0\xA8{\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x04\x02\x81@ \x10\b\x84\x7F\xF4\b\xEA\xE3\xA0>>\xB9\xDBjT\xDE\xFEH\x15\x02\xE8\x85\xD5\xCFUk\xE3\xB9\xEA?;yi\xBC\xDC^X\x82\x85\xB9\xFA\v\xEF\xD4\x06a\xF5\xEA\xDD?i\xB4\xD7:\xDF\xAE4\x1E\xA96\xFE\xCB\xDA\x89j\xE5\xD6\xB5\xD9\x85\xC5a\xABW\r\x1F\xB8\xB4\xB2\xB8\xBB\x1E\xDE\xDF\x98\xD9Z\xE8\xFEh\xF7\xEFv\x17\xDE\xA9~x\xAE\xBA\x12\x1Ck\xDC\xF6\xEAh\xAD\xBA\x10\xD4\xC7\xEF\xD4F\xAB\x9B\xE3\xC5\xE0\xD8#o\x8E\x16\x8F\x9D\xF9\xF5\xDA\x85*4\xFEi\xB51Wo\xFC\xA4\n\xCB\xA7\x96W\xA3V\x03Z\xABg\x17\x86/\x8F\x97\xEB\xE3\xB5J#\x80(\x80\xD6\xDC\xB1\xE3\xFF\xF7\xAB\xE3\xFB\xAB\x8D\xB9j\xA3\n\xAD\x83\xBD\xC6#\xBD\xD3\xC1\xB1\xC6\xEA\xE6\xDEj\x14\x05A\xEB\x81\x1F\x8D\xDF{\xEB\xEA{o.\x84\xB5q\xF7\xCA\xC5\x85\xEA\xC5O\xF6\x07\x17z\x8DF\xB4\xB2X\xFF\xEE\xC2\xD9\xC6\xFD\xD5\xC6/\x16Z\xF5\xB7\xFE\xFC\x17\xF7\xACT\xA1\xF5@\xFD\xC2b\xF5\x7F\x8F\xC7\x1E\xB4\x17\xA1\xB1\xF0\\\xE3\x17\xD5\xE3\xDDWG\xB7]\x99}g\xAB\xB9X\x1FCu!\xA8\x8D\xB7\xD7\xDA\xF1\xF0\x83\xC6m?\xDE\xFF\xFB\x97g\x17\xAA\xA7\xD6\x82\x85J\xE5\x8F+U\xF8\xFE\xB05\xDAj\xCCA\xEB\xFEjc\xB1:>\x18\xB6\xAE\xC0\x9F\x07\xB5\xF1\xEAn\xEB\xBE\xE5Q}\xB8p0l\xDD\xF3\xE6h\xF1\x9E\xF1\xA9a\xEB\xF6\x85\xC7\xE6n\xBE\xF8\xDF.\x9DX\xE8\xB7\xDF\x85\xD6\xE2\xEC\x859h]:\xDB\x98\xAB\xCC\xB6[\xAD\x83\xE1\v\xCB\xADV\xA3\xBA\xB0T\xFF\xE3\xD9c\xE7\x0E\xAE\xFC\xB4\xFB\xC6\xC5\x83+'\x1E\\{\xE9T\xEF\x13\xB7\xBD\xF6\x89\x83+\x9F\xF8\xCE\x9Ft\xFE\xFD\x95\x97N\xFC\xC1\xF8\x07\xDF\xD9\x7Fbk\xFC\xD0Z\xE3\xA5\xDE\x13\xDD7\xFF\xFC\x8EK\xA7\x7F~\xCF\xF8\xC1\xD9\x97\xD6\x82G\x17\xA1ufk\\=\xFA\x89`f\xFF?>\xF2\x89\x99K\xCB\x07W:\xDD\xE1\xF1w\xA1\xF5\xEC[\x7Ft0\x8C\xBE\xB1\xDBZ\xEEW\xEFx\xF9\xED\xE6r\xFB\xE4\x9F\x86?\x0F.\xFC\x9F{\xA7\xDF\xBCt\xFA\xE0oO\xD7\xDF\xFA\xE3S\xD1xak\xFC\x8B\xB7\xC6\xCBg\x17\x1EYk\x9C\x1C.,\x9E\xFC\xB3\x83\x9F4\x0E\xAE<|0l\xFFJ\x1B\x16\xAB\x8D\x83+\xE3\xF7^\x1F\x07\xC1x\xE9\xDC\xA5\xD5h\xBC\xF0\\g!\x8A\xBAo\x9CY\xAA7\xCF\x9D\x00\xA8\xFE\xB30\xF8O\x0F\xBF\xFE\x7F\xAC\xBE\xFC\xC4\xFF\xDC\xFE\xE9\xA7\xAF\x8C\xFF\xDF\xBF\xD9}\xE4\xBF\xFC\xC6{o\x8D\xEF\xF9\x9B\xF1\xE2R\xE7o\x97\xE6\x17\x17\xC2\xEE\xF0\x85v\xFF\xF8\xAF\xFD\xF4\x0Fg\xC3\xB5\x837G\x8B\xF5\xC6K\x7F\xB0\xFD\xD0\xC6r\x00\xAD_\x9F\xF9i\xFD\x8D\xF1\xDF\xFF\xA8\xD1\xFD\xF1\xF8\xE0\x8D\xEAKko\xAC\xBE:>\xB82\x1EW\xC3\v\xFF\xBF\x9F\xDE\xF6\xF2\xB9{^\xFE\xCF\x7F\xFF_\xE7\xFF\xFE\x8D\xD3_\x82\xD6\x7F\xF3\xBD\xD3\xF3\xFD\xF6\xD2\xD6\xF6=/7g\xEB\xE3\xEF\xBC:\x7F\xF0Fu\xE1\x91\xF1o.\xF5\xFF\xF6\xB6\xF1\xEF\xDE3\xBEs\xB9\xFDng\xB0t\xCF\xF8\xB6S\xBFz\xF0\xD3'\x1E\xFF\xFF\xD8;\x1F\xE06\xCA\xB3\xC1?\xBBzm\xBDV\x8C\xB4v\x130\xD3\\\xF2JY\xC7\x8AS\x90ia\xCEwg\xA2\xD7\xF2\xDA\x96\x954v\x1C\xA5\t\x99\x16\x9B\x10\x98@\x19\b\x10\xA6i\xABZ\xAF\x85L\x14\x01\xB1\xD1\x85^\xAE\xED\x14\xC7(\xD8^ \xE6Z\xA0\\.\r\x8Ac7\xC6pI/G\xB9\x1B\xCA\x80\xE2(\xB6\xE3\x04\xCB\xA1i\x11\x89X\xDD\xEC\xCA\x0E\xE1OK\xC2\xB5\xEE\xF7\xCD\xB7\xBF\xD9\x81\xD5\xEA]Y\xFA\xED\xF3>\xFBh5y\xB6\xFE\x1D\x12\x90\x9E\x8E\xD3\x9BG;V\xD1\xD4\xC2\x83B&9\xE1?\x9CF\xC6t\xF1\xA1\x943\x99\xCE\xF4\x9Bnxt\xC2\xC4\xD3U\x87\x15O\xFD\x81\x0Fc\xCA\xCF\xEDRT\x92\n,\xD1\x0FjC\x1E\xC7\xE4\xDE\xE3\x82Da\xC1q!y_\xCB\x9Ez\xD9\x8D\x1AEI\xDAN)\x0E\xCB\x99\xC9\xB4cL\xC9\x83f\xFF))3\xE9>\x1B\x94P\x9D\xBB gk\x9DY\\}(\xF5d5b\xD6\xF4\xB9z\xC5\xB9M\xF9\xB3\x8B9\xC6\xD2Oz\x96\xADM\x1CX#\t\xD6<\xA1 O8\x8B\xBA\xFE\xD8'\xDA\xC3\x9Eb\x9B\xDB\xD9*V\x07\x95\xC7(\x15\xAB[\x901\xFD\x84\xD8X`\x0Ex\xAA\xD3%I{\x81\x05\xF6R@\b\xC2\xFD>\xB2\x03\x9C\xDB\xC6I\xBBR\xD5N\x9D'\x95\v\xC9;/$\xE5\xCC\xC9]\xB7\x04\xEEq\x19\x94\x95;\x0ET\xF6\v\xB4]\xF9_F\x91\xB4\n\xC6\x81\x0E\xAB\xB8\xA2w\xD1\xB1\x9B\x1DR}\xEB\xD4iIl\f\xA6\vpW\xB4\v\xBE\x19\xB4\xAFrI>\xC9\x95I*\x8F&\xC2\xA6>\xD9Z\xBF\x00\x82\r\xC1\x12\xC5\xBA\xE2\x95\xD2 )\x00\xFB\xF2\xA3J'\x96?\xAA\x97E>\xECB\x85\xAE\xAB\xC4\vIeKX\x10k\xD3\xA2KZ\xE5R\xFC\xFD\xEEg*\v\xB5\xF8\x8F\x7Fl\v\xD6O@f\xC4\x9DIH\x7F<\xAD\\\x7F\\p$\x94\x1F\x0F+\x99\x89\x03\x99\x13J\xD4\xA24>\xDC\xB2\xCA\x1A\x9A\xE8\x12\xE6q&@\x92\x7F \xDA\xE6r\x131\xEA\xA9\x0F\xC7\xEE\x0E\xDF\xF0\xA8\xF2\xB1\x8B\xF8\x87\xE5bw\xE8\xDE\x81\x1E9\xD8\xE32%\x9E\xA1!\x8FM\xDE\xD7\xBD\x7Fr,\xFD\x9F-\xA1%\x01HN(\xB7\x8E\xBD\xBBm\xD8\xF7Q\xC0]v\xC7\xDCF\xD1\xFB\xDFE\x97\xC9\xA8\xB8\x1C\xE2\x9EE\xA9\xC5\x1B\xB7~\xF8\xC8V\xE7\xEB\xD8\x1F{;E\xA95\xB9_4\xA0\x9F\x85\x1B\xC56\xD11\xAE\x84\x90t\xDF\x19\xF9\xFE\x92\xC85Tq\x8C*\xC8\xA4X\xCE\xEC\xBC7&\x88ms\xEF\x12\xA3b{\xB9?\x11\xF9\xF7\xB1\xCD\xC1\xF673#\xD8?\x14\x17\x99/(\xC2v\x9B\x84x\x9F\\\x95\xF2\xC7|\x8D}\x03N\xE6#\x8F\x1Cp\xB2PS\xE2\x17?-\xB6\x87Ke\xB9\xDB\x83K\x14\x7Fr_`\x8E\xB7[\x1A/\x94}\xAB\xE3\xF1\x92\xC1\xF5\x17\x12J\xDBr\xDF\x0F\xED\x8D}\x89\xC6j\x12\xA8\xE6qCIK&\xB1\x85l\xFF`Uu\xCB\x8B\x92\x14\xB6\xF1\xCB\x9F\xADx\xE9\xD9\xF5\x0F\x88\x13\x99\xF7\x95\x0F\xC7y.7\xEC\x1F )Wb\x8FQ\xB90.\xA5\xDD\xAE\x98I\xB6\xBA\xE4PH\x96\xAAm\x92K\xB4\x11\xD8sFY\xDA\xD9\xD9\x9ET\x9E:-{\xA4\xE8\xC1\xF6c\xFE\xC1\xF9\xA4j\xDD\r\xF6t\xDD\xE2R[U\xEA\xDA\x92\xF4^w(\xD4*<-\xDD\xE8Y\xE1}\xB6\xFE\x1D\x12\x9221\xFCX=\xF3O6\x98\x02\x8A\xC92\x91\x19KK\xB5\xE9\xFA\x13\xA9&\xC7\x81\v#\x85\xCEG'\xDE\xFB\xFE\xFA\x06\xD4\xE22\x1D\xA8\x1D\\\xB9\xBES\xD8\x8D\x84E\xC3\xBB\xCE\xB6\x8F\x7F\x7F\xB1\xB27\x11\xF5H[n5-p\xF0Ro\xA9\xDC\x18m\x94\\\xD2v\x97\xDB\x12\xEAZ;\xE0{v0\x95I\xB8\x9A\x02EB\xC0\xFD\xEB\xC3\x98\x041q)u+a\xF5Q\xE5\xE3\x9Cr\xF1\xAA\xF4\xD9VwfL\xB9C\n\xD4\x8F\xA5\xAB=\xB2U\x8C\b\xD4\xFEA\xD0\xBE0\xDF>\xF14^\xBFW\x10[\xA7\x8Abj\xFE\xFF\xDF\x8F)\x12\x1D\x92\xDA\xBC\xA1\xE2\xB9\xCE\x87\xD3\x99I\xC9nT\xEAl\xFB2#Ro\x00K.\tu)d\x87\x94\x19\x9B\x10[\xB1\xB7{\xF3\xEAm\xBELR@\xA6\b.~\xE7{\xC3g\x9C\xAFG6\x9Ft?z\xDA\xEByz]u\xF5\xE4\x1A\x97\xB7\xB6\xDF[G\xE2\xBD\xA5\x91\x1E\x87\xCF\xFF\xFE_j\xDB\x02\xFE\xE1\xF4{\xF7\x9A\x17\xE2\x8E\xFF\x11\xDD\xE7O\xBE\xE2\xE6an\xAB\xDBpF.}^\xE6\xEA\x17\xE4^\x95\x16\x83\xC4V-\xF7=\xBE\xE5\x96\x8D\x8A\xE1p\xBA\xEF\xFD\xBB\xEF\xAF\x91\xEB\xAB\xDF\xAC\xDF\xFB\x9C\x7F\x8F\xF8`\x1Cn\f\xDB\x9B\rE\xD4\xC4\xAC\xCBe\x0F\xA5{o+\x94j\x9A\x9Do\xD4l\x12Y\xFD\xC8p\xC9\x88{\x89(\xBD\xED\xA6+\xE3\xF1\x97\xC4\xC6\x1F\x0FG>.\x9D\xB8\x7F\xE0L\xD8\x85Q@*\xE0\x9A3\xA3BA^\xA9\x1A\xFF\x87R+\x9A\xE9\x13\xB6\x97\x97\xDE\x17A&\x19\xE6(?ym\xA8\xFBhh\x15\xBC\xD8\xB7\xC1n\xDBa\x7F\xEC\xDB\xD1\xAE:\xFB\xFA\xEE\xC8\x92\x92t\xE6\xE4\xC0\xDC$Y\x7F\xBB$\xF7\xBDu\xEB\xE1c\xB5\xFD\xBE\x8F\x8A\xBD\x04\xE0\xA1\x1A\xEF\xF3R\x0F\xCAIy\x02\xE2\x9F\x0E\xA52\x8F+\xDD\x93\x8A\xBF]\xF0\xC7\x94\x07\x19\xAC\x1A;\xEF<\b\x11W\x83\xBCG\xFCAL\xC9\xE3\xE0\xC3\xE1\x97?\x12#M\xFDG\xBE\x91<\x82LG,g\xDEz\xB5Y\xC9\xC4\xE1\x0E1Z\xC0\x915R\xE4\xF0A\xA9\xBA\xF6\xCD\x1B,J\x81\x19\x89L*9I*\r\x80\r\xBE\xF3U\xA9\x1F\xB8|K\x8D^'\xF3I52\xE6\x84\xD5m\x8Dk\xFF\xA7\xF7\x89\xD2\x16\x7F\\\xC2\x8B\xE5\xBB\xFB\xF6\xD9L[\x8En\x93\\\xB2\xEF\xC4\x99\x9A\x0F\x0FCf\xDC\x97S\xEF\xABs\xB0^k\xA1\x10\x97\x9AbBs\x9B\xCF\xE3J\xC3\x9C\xF3`\xAC\xE8\xB4\x00\xB3\x81?\xD9b2\xA6\xCF\x17\x97\xF6\x9DV\xF3?\xCA\r\x7F='q\x7F\xBD\xF2J\"$wJ?2\xA4\"\xAD\xE1\xFBFe\x8A`\n\xA0\xC1\xDC\"[\x05\xF7\xF6\xD2\xBE\xF7\xFFR\x9FT\xEE\x1BV\xFC\x03\xD1\xA8\xA1\xD0?\xB0\x1F\x1B\xA6\xA2\x89\xCES%\xE7\xF7oK;\xC6\xD2\x17N+\x9E\xDDB\xF7\xCA-\x1E\xCF\x96\xBE\xFAswE\xDF\xBD\xD0\x8F\xFD\x87\xA5\xB3\x1C\x83\xB0\x908U\xEA?\x9C\x96\\\xF8\x9A\xC3\xE9\x02\x87|\xBEK\xF4\xBF>\xE1\xEF\xF7\xFC\xA1\xC6\xF7mSG\xF2\xFDw\x11\xAF8\x12JU\xA8\xFF\xDC\xD2\x1EO\xA9\xE28y\xCE\x19<\xD7d1'\xCDbrBi\x8C.\xC8Y\xDC\xD0j\x1Fq\x1CU\xDE;#;\x06RE\xA8\xA7\xE9u\xD7O\xA5\x9D\xCE6A\x0E\b\x10\xF8Y\xA5Y~\xC0*\xA4\x8B\x17H\x16\xE5\x17%\xE9\v'\xD3{\\;\x1D\xA3\xEEbOWoI\xA4*@6\xF0$s\x8A$\xAAR\xC8L\xC8\xB64\x9Fw\xCC\x7F\x904%\x14\x17\xEF\xBA\xBAx\x9D\xA9R\xC8\x9CH;\x8F\xF8\xCE\x17\xDB\xF8\x1D\xBE\x85G\x84\xE7\b\xAC\x91\x84\x98\xD1'\xAE\x14\xFC\x83\xC3\xFEC\xBF_;\xE8\xBDf\xD0\xF7\x94\xC3[W\xF9\x02.N\xBBM\x1D6\xFE\xD6?>\xB7\xF3\xEB#\xDE\xF5O\xA7\x8A\xABe1\xE8\x1D\xEB\xF7\xFE7B\xE5.~\xA3\xC5\xE7\x8F\x93\x83F\xAF\x7F\xF4E\xFF\x90\xC7\x1F\x13\x1D\x03\xE9W\x9F\xF6\xD5\xD9\noh\x9B\xBB\xFC\xA4\xFC\xEA)\x1F\xE7P\x10J\xF9\x076\xF5\xDC\xE6rlS\x90\xD9\xB7\xBC\xDF\x1D\txz=\x13&\xA6T\xD7\xA6\xFF\xE0\x12\x17\x1D\xC7\xC1\xDE\x9A\xD2\xEE\xB4I\x96w\xF3\x02\xCA;\xD6}\"\"\xE6T,\x8C\x13\x04\xCFT\x9A<\xBF\x89\xD3\xDB\x80\xDA\xDC,\xF7>\xA58qk\xD3\xF0\xAD\xCFO\x1C\x90w\x7F\xA7\x93\x13\xC8#\x03\x8D;\xA4\xC9.\x01\xE5\r\xD3J\xEA?\x94\x92$i\xA1\xED\xE5\xA5\xCDT\xDC\x11F\xFC\xE4O\x8E\xBA\xBB\xFBo\xACD;3\tI\x94$T\xBF\xFFkC\xF6\x1F\x95\xBE}]\xF7w\x9D\x83^ja\r\xBC\xB8\xC7\xE5\xBDuOa\xB5\xC7\xFB\x84\xB5Ar\xBB\xD6\xAC\xF0]'\xF5\xFC)\xF8\x7F=\xE1\x8A\xB3\x8F\x9E'm\xEB{eof\xC2\xBB\xAAYY\x93T\xEA\x8EO\x05y\xE1\xC3\x01io\xB4\xA7/\xA1\xD4Y\x83}\x13\xCF|$Fv\xA0\x8A\x07\x87\xF7[\xF2*\x8C1\x9A\x89\xFBH0:\x17h\x81\x81\xAC\x91\x84\xAA7\\^\xC7xf$$\x06\x10\x02\xFBm\xD5sm\x01\xA9\xCC\xE5}\xF6\xA8\xB2F\xF2\"\xD3\x9B6\xE6\x95j'(%k\xAA\xD7\xAD\xA9\xF5\x86\xAC-\xFE#f\xA1\x18\xB9,\x8A\x8D?\xB7\xB2\xCD\xE6~\xD8W\x17\xA3\xBF\x19\x94\x9D;\xCA\xADs|\x05%\xCA\x99{\xCC\x99\xB8\xBD\x9A\xC6\\y>\x8F'\x8D\xDC\x0Fx\xEA\xF7\xDB$\x11\x99\xC5\xBA\xD2\xC8{I\xC5\xB3\xD8\x13\xAD\x93\xFEL)B!\x12\xDC\xDC}T)\x7F\x1C}\x9D\xF7\xA9\xF1\xFF\xB8\xBC\xDB\xF3\x8D\xD2@\xA4Z\x92\xD6,\x17\xCF\xDB\xB0\xD0+\x94F\xA3\x8E\xA4R\xD2\xAF\xD6\x9F\xBD9\x8Dvc\x91\xD8\xA7dF^\xA9\xED\x9F\x88\xB6+\xBF9\x94\xBAp*U\xDA\x85\xFF\x93\xF4\xA2\xDFs\xEE\xC2\xF2s\xD1\x87\xA5\xBD\xC7\x05\xAB\xA9\xA7\xB1U2u\t\xCEV\x93?\xC6\x10\x8Fk\xD5\xF8?p!\xA9\xCC\r\x87\xC5\xC0\xDB\xAB\\\xBE\x87\xF8\x03\xB7\xB7\xBD;\x0FI\xDE\x1A\xC91\x1E\xFD\xD5\xF2\x9E\xE1\rJ\xD3\xC9s$'\xD1t8\xDD\xD4o\xEF>\xE4k\xDC\xD3(\x05\xDC\xFF\xB5\xDF-\xD5\xA6\xD7&$\xC7\xC9\xF4\xFC\x9Ct\xD3\x84X2\x82\x9Dc7\xCA\xC3\xE5\x855\xDE[v\xC8\xFE\x83\xC2\x0F\x0F\n\x99\xB1\x03\xA86\x9D\x19Sl\xD5\xC2\xF7\xFA\xCEw\xAD`V1\xF2jb\xE33\x9E\x8D\xF7\x9B7&\xEA\x15\xB39J\xDB\x95\xC6z%s\xD2\xB6v\xA0\xE1\xBB\x94\xAE\xE0W\xA0\xEB\x16\xBFw{:3i\x7Fa\xB0\xC8\xD5%\xFD\xDE\xD5(\xD7\xD9\xEE\x1Dj\xCCL\xF8\x16\x99\x1B3\x13\xBF\xA2\xB4\xA1\xEF\xA4{\xED\xA0\xF2Tq\xCB-\x81\x06\xA18\xBD\xBA\xBF<3\xB2L@\xB0\xFCd\xF9\xF7\x93\xCA\xAF\xDB\xEF\x15\x03\x8Ac\xB4\x9C\x10W\x0F\x81\xB9\xF5\xF6\xA6Aq\x8D\xCB\xEE\xEFO#\xB7+3\x12\xB5\xD5\x8A\xCE\x80\xF8\xD1\xEF~\x81\x03\xEE\x07\x13\xAE\xEE\xA3\xBEE\x83\"B)g\xB0\xA7\x93\xC6\x9B\xDA\xD2\x13#\xC2\xF2~w\xA2\xD5\xB3\xDBe\xF7\x04\x95\x87j\xD3\x0Fy\xC4E#h\xE3J\x9Fc,\xED\xE9\x92\xAD|\xB9\xD9\xA2\xFC\x9F\xC1\xC6\xF99\x1B\x07:\xA9\x19u\xDD\xCF\x1F+9.Y\x81\xEE\xF3\x84j6\xE0\xD5c\xCB\x9AV,[=\xF1K\xB5\xFE\xDFM\nLvoM\xCFd\xBF\x80\f\x01\xF5Dp\"\x15\x94$pu\x95\x12:\x8F\xEB\x17\xABV\xDE\xF2\xBA{\x8F!\xB4F\xDA)\x86|k\xDF\xF0I\xF5\xFB\xBF\xF6Z\xA9\x89\xDF\xB7<\x9A\xF0\x0F|\xE7I)\xBA\xC6\x85\xF7Tyw\x0Evmsm\xEC\xCD\xAFic\xC1F\xD1\xB7\xBE\xD7+,\xF1\x06K+\xF6U\xA5<{\x1A\xA3]o\x99\x1E\x8E\xAC.\x95\x11'\xFC\xD0\xA1\xA0\xFCck\x07$\x84\xDD\xD6\xED\xF6\x9F\xDF\xD6\xB0;\xA4\x9C\xB7wm\xC3E\xBB\xC3Ef\\\xD4\x1D\xA37\x85+(\xA3\r\x9D\xB4 \xCF\xF6\x90D\xAA\x18\xDDY\xB9\xF3\xA6\\7\xE2\xD1<\x93\xA7w\x89;\xD8\xE5[\xD8\x1F\xB9pP\x94\xDC\x91y|\xF9\xCD\xE1\b\x9A\xF3\x81\xFF`H\xEE\xDD(\xDB~\xF6\xC4\x92\xE8\x13\\3Y\x82\"\x16/\xCFK\xAB$9\xD4\xE6\x1DbtO\xA5=3\"Xy/\xB5\x06,'\xC5\x91\xED\xA5\x8F\xB7\x99\xBC]\xDE\x9F\xF3/\xE7\xB4+\xC8P\xB1(T\x9E\x83\xCA\xF3\f\xC2\x9C\x1Co\xA5\x14\xE8\xDAn\x7F\xBE\xD8\x84r\xC4ys\x16\x93\xAAu\x9EP\xCF\xDCj\xEF\x8F\x1CJp\xCFH\xC9\x88;\xDC\x13ym\xA3T}\xB7\xB2JBxH\x8D\xFFp\x9F\xEC\x18\xF1\xDE\xC4h+\xC7\x7F+\xAF(\x8F\xD0\x9B\xB6\xDB\x0E\xE6\xB8\xC4\x1Dv+\xD0\xF3\xEET\xF8\xE9\x94w\x85\xD4\xE8\x96\xE4\xE5Q\x12\x92v\xC4I!\x8FwV\n\xF2\x06a^\x8E+3\xBA\x00\x19\xE7\x87b\x94\xDB\xD12\x96<\x90\x19}f\x85\xCB\xF3\x92\xA7\xA5\xFB\x88\\\xB7T\x19\xD8$\xED\xA4\xD2\xB6\xA1\xE8\x06\xCF\xDEo\xF2o=~\x87\xF7\xC9\xBA\x0F^M*\xFEQ\xA5oR\xD9\xB7\xE3\x99\xC7\xC4\xFE\x83@\x83\xC6\xF9o\x0EH\xED\xA7\x15\xCBie\xD7Q\xF1O\xFD\xF8\xC9\xE62k\xA0\xEC\x81{\xCA~;\xF9HfTp\xC7\x05d\xFC\xE5\xCE\xDAt\xE6\xD4\xCB\xD7\xDF\xFD\xBB\xDE\xC5+\x16ob\xB6S{\xFF\xE3\xF8\xE8\xF5\x1B\xEE<\xFB\xDA\xE8\x99\xE6\xD8\xC0\xBD\xE2\xC3,\xD6\xCEh\xF3\xC1\x05k\x07\xDF\xFDn3}\xF8\xC8\x86\x81\x83/dN\xA4\x13\x93\x8F,^\xFA\xC8\xAE;%\xA1\xA6,\xEC\xAA\x90be\x89\x11%~oYf\xE2\x1E\xBA\x12\xBD7\x11x\xB6\xFF\xE5\xA76\xBC\xFC\xDB\xD1wb\xAF\xA5_\x1D\x89\xF0|\xB0\xFD\xBA\xD2\xFF2\x1E\xB9&N\x97X\xDD\xE8*\xE5\xBD\xC9\b\x9B\xCC\xC7\xF6\xC8\x7FH\xD6\xBC\xB4)u8\x18\x91\xDF\xF8\v\xC2|>\xEF\xB2\x01\xF1\x0F\x91<\xB3\x80-\x8A\xAB8\xD7\x91Tn\xC7\xE7\xE7\xE7l\xBCg\xA8\x99\xAC\xA8\xF9\xE9\xF2;\xEF\n)\xCB\xE34t_.\xE1C\x91MJAI:\xCF\x06a;z\xD0\xAE\x94F\x9F\v\x8F\xEC\xB5\xF2\x91\x81f\xDA~\xDC\x1C;ugael\xE0\xAE\x05\x96\xF1\x95%'~\xE9H*\x8F&\x95\xA0\v\x87h\xB0\xC9\x1D|n\xC5\x00\tI&5A\xB5\xEC\xBA\xDE<\xD9%l|\xEDz\xFD\n\x8C\x8E\x8E\x8E\x8E\x8E\xCE\xECC\x80\x12\x93\x80\x90\xE2\f\xB4|\xED\x88\xE0dTw2\x9B\x94\x8C)%\x13Jf$@\xDA\x99`\x9AO\xB6)\xBA\x93\xD9\xC4*v\x9C5z\x99m\x9F3PAL\tg\x90\xE9Nf\x93\x9BK\x14\xABE1\x86\x02\xA4=\xFA\xFA\x99\"\xB2-\xA5;\x99M\x8E\x8B\x1D6\xDE[\x81\xF6\xF9\x87\xF7\v\xE1Qg\x9BWw2\xBB\xF9g\xEA[\x87}\b\xC9\x05\x16F\xC2\x02i{Sw2\x9B\x14\x97\xA4Fk\xA81.g&\x94x\xD8\xE7\f\x16\xE9Nf\x93\x7F'\x86J=\xFB\xD3\xFC>\xB1\xFD\x18\t7\x94\xEA\xF1?\xBB\xF0b\x83\xCD\x13E\xA2\xFC\x87\r-\xE4\xB1\x06\x13\xD2\xF3\xFF\xAC\x82\xC4\xCD\x8B\xFA\xF7#{\xC0l9F\xB6+\x85K\xF5\xFAgV)z}\xC7\x06W\xD40\xF4\xC8M\x81\x96E!\xE1\xF8x\x87\xEEDGGGGGGG\xE7\"!]\xC1\xDF\x1B\xBB\x01\xCAs`\x9D\x01\xCA>\xFF\\\x0E\x138h\xE6?\xD9\xB0\xF9\xE2\x1A\xFE\xF2W\xFE[\x17\xB2\xB1.~\x1A/bn\x13\xEB\xC9\x81\x86\xCF?\x97\v\xE5\x06h\xCE\xFD[\x02\x05\xAC.W\xE0\x9F\x87\xCDF\xD8\xAC\xFB\x9F\xA1A\xF5\x0F_\xEC\x9F\x872\x03l\xCE\xFD\xF2\x00\xEE\xC8\xD3\xE3\xFF+\xFB\x87l\xFC\xBF\xF2\xF9\xE7\xE6\xD0\x17\xE7\xB0\x17-3\xBF\b\x1B\x00\xAEb\xBB\xF2 ea\xDA\x02)\x80\x1E\x13\xEB117b\x1D\x16\xA0\x16\x962\xA8\x1Bw\x19\xB41\x00/\x00\x14Y\x18\x18\xD9V\x80\x0E\v\x9B2\xA9\x03\xA6,lk\x9E.~\x9Ai\x999\xAC\xE3\x8B\xFD\xD3O\xFCs\x00HU-\x00\xC3\xC0\xDC\xEA2\xED\x7FS.ss@8\xC0\x1C\x10\x80\x10\x07X\x1D\x03n\x00\x8C\x19`\x16R\xD7\x196\xA9\xC3\x04`!\xA4\xFF\xCAyi\xFE\xF9+\xF9\xFF\v\xFD\xE7~\xD6\xFF+sXG\x1El\xCA\x01a\xC6\x7FO\x0E`\xA4>\x1B\x02\xB0\x9BT\xFF=\xDA\x8A}\x0E[\x97\xF5\x9F\xAB\xFB\xFF\xAC\xFF\xB2/\xF5\x9F\xAD\x97\xF2@\xC03\xFEy\x187\xB3q3\va\xD6\xC1AG\x8Ej^\xC8j\xD7\xE2\xBF'\x1B\xFF\xBC\xBA\xDE\x81\x196O\xC7?\xD6\xF3\xCF\xE5\xF9\xDF\xFF\x99\xF8\xB70;f\xAA\x7F\x0E\xB2\xFECX\x95?\x94\xCFB\x1C\xD895\xF34h\xFE1\xB0\xEC\x81\xD0T\xAB\xFE1f\x18\xCF\xF8\xC7z\xFC\x7F\xDA?bC_P\x7F\xC6\xB6\x18\xE9=\xB9\xB1K\xB7M\xE5\xAB\xFE\xA7ra+\xB0!\v\x9B\xB2\xC0\x94E\xDD>dQ\xDD\x86T\xBD\xEA)\x18[\xA0\x19\xD4s\xFAV\xB3\xEA\x7F\n 5G\xDD8\xC4A\xCA\xA2\xBE\x88n\xFE\xB2\xE0\x80\xF0_>j\xB3\xF1o\x17\x98L\xAF9\xBF\xB2\xFF\xB2\xCB\xF0\x0F\xBCz\xDA\xD5\xFD\xEB\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xE8\xFC\x9B\xA5\xC2\f\x15\xA0\xFF\xEB\xD1\x7F\x1A1\x8EQ\x8B\xAEAGGGGGGGGGGGGGGGGGG\xE7_\x1B\xD2\xDF\xF1\xB5*\xC0\xC8\xD0\x15t}\xCBG\xB9\xFF\xF0\xCF\xC7rgE\xA3%s%\xA3\xA9\t:\x90A\xC8\x07\n\x01@\xD3\x1By3P\xB3!\x95kHY\f)3\xC4g\x06\xC7-@\x9D\x90ZfH9Y\x8AP\xCA\xF1\x98 D\xD8\xD42P\x17\x7F?&A\x89\x04\xB0\x93\x11\x06\xCC\x04\xEA\v\nZ\x07>\x03\x03\x01(\xCF]\xFC\x13\xF0\xE9\x9E|\x02\xE2\xA6\xD7\xCA\xFF\xCA\x1B\xC5\xFCt?F\x8A\x00\x10\xA3\x00\xEA\xC2102\xAA\xEDK\x00(\x9E^i\xE6\xD5\xBFK\x01\xC0\b!~\xFA\x17\v:\v}_\x99\xD6\xA4\x9F\xC7\x12\xBD\x02\xFF\vQG!P\x8E\x03q\xFA\xFE\xCB\xA8\x00b\x05 \x98\xD4O\x81\v8U!\xC4\xA0\x99\x13\xCA\x18%\xAD\xC8\x1A\x00\xC2!\xCD\xBF@r\xF3\xCBZ\xB1\x95S\x17\xC4O\xFB\x07F(\xB0\x82\xACY\xCD\xBFv .\xCB\x7F\xB6\x95\xE2g\xEFCfa\x98\x87\x94\xE6\x7F+\x82\x14b\xC4\x02\x14\xB3\xADf\xE8Q\x8F\x02\xA4,\x8C\x00k\xC0\x90\xCA\x05baE<\b\x16F\xB5&\xE1!\x130\vKa`\xB3\xE1?\xF4\x15\xFC\x8B\xC1\xCE\xAC\xFFy\x90\xDD\r\x93VJ\x181\xF1@@P}j\xED\xCF\x8Bx\xBC\x98v\x92\x00\xA8\v\x0F\x9A\x7FBr\xE6\xDA\x03\x88hK\xD6\x7F\x01'p@\xC8\xCC\xCFd\x97\xF8W\x03\xF82\xFD\x7F.q1la\xC4\x12KY\x98\xDB\x18\xC3\x96\x18p\xB0\x0E37?\xED\x1F\x80\xA5T\xFF\f\xE7B\n\x18\xF0  X\xC7\xA9\xAF\xA3\xFA\xC7,\x84\x80\xFE\xE3\xF3\x8F1\xFB\xA99\xE1\xF2\xFD\x83!-\xA2\xCEB\x00\x1E\x98y\xDA\xBF@\x02\x14\x18-\xE4\xE3\xD7\x83P\xC0\xE3|\x88\xE5\x03\xE4\x02\xAE\xCB\xFAw]\xF4O\t\x8A\x8AY\xFF\xAD\x80x\\\x80$\x13'\xF0@\x84i\xFFSW\xC3\xE6\\\xD6\x8C`\xD3\xD5\xEA\x1B\xC3(g\xD75\x10\xBFZ}8\xE5\xE4\xB4\xF9\xD2\x8A\x17\xB2K\xFC\xF3\xD3\xFE\xB3\tg\xE6s0\x013\xC2\x81\x9D\x07\xB7\xD6\xDF\x9Bq\xB0\xE9\xA2\x7FKL\xEBr\xCC\x1A\xF2\x00\xE7\x00\xD1\xFCw \x18\xBF\xD4\xFF\xAC\xE4\xFE<6\xED?\x13\xBFl\xFF\xD0\xB1\xD0@\xAF\x8A\xA9\xFEg\xE2\x9F\x105\xA7\xC6\v\r\xC2\r@\xCC\x9A\xFF2c\x9AcB]\xA5\xE0\xE4\x81TM9\xF9\ng\x8Cr<#H\xB2\x05\x90\x95GV\x98R\xFD\xF3=\b:\x11\x10<\xED\x1F_\v\xA1<\xD6\xB1\x90\xED\xBAV\xCD?\x02\xCA\xDDX\xD4*\\\v\xBB\xAE\xE50\xE6\xB2\xF3\x05sZ\xFC\x97_\xE2?5\x93p\xA8\x11R&\xC6x\xCD\xBFA\xF5\x1F\xCAS\xFDS\x0E\x86\x10\xEB\xB1\xB0\x1EK\xACY\x8B\x7F\x81\x83\x06\xD3\xB4\xFFf\x04\rZKdla\xB3\xE9\xBF\xD08\xA5\xFE\xCF\x90*eW\xE0\x1F\xB1us\xD5\x90a\xE2\xB64\x18\xD3\x00\x940\xCA\x83`\x03L\x18)\xE0\x8A\xB4\xF4\x0F\xD0L\xEA*\x85\x99\xF8W\xF3\x7F\xA5\x81\x12\x84\xAC\x01\xB4\x8CG\xCB\x00_\xF4\x8F\x81\xA0i\xFF[\x85V\x10Z1\xE2\xB0\xC0(\xCF\x11\x84$!\x80\x85V\xAC\xF5\xAB\xD7\xE6\x8Bz\x86lF\x10\xCB\xCEY\xD5\xBFA\xEB\xE0\xAD&\x1C\xB6\x95\x03lb[yV\xF6i\xFF\x98\x077b\xBBx\xC0\x1C4h\xBD\xF1\xCB8p\xE7\x03\xCE\x83\x9E\x1C(B\xEA;psj.\n\x99 \xA4\xF5l\x9F\r\xFF\xC0\xFC\xAA)z\x05\xFE\ri\xC4\xA26\xCD?\x9A\x8E\x7FF\x18E\x805\xFF\x94\xB0q\x00(\x03\xE0\x18\xAD\xABJ\xA9\xF2/\xFA\xE7\x89Z\xFF\x04\x10Q\xE3_\xCD\xFF&\xBE\xC7\x04TP-fgbH\xF3\x9F\x9A\xF1O?\xF1\x0FS\xAA\x7F\xF5xu -\xFE\r\xEC\x12\xFFY\xE1\x9C\xD6\xB2\xDB\xC4\xC0\x00\r\xC0H\x0E\xB8-\fg\xEF\xEF\xC0\xAB[\xB0\xE6\xDF\xCD\xA9\xBBl\xE2\xC0\x8D\xA7\xFD\x83\xE6\xDF\x9E\x1D9\x9B\xFE\rLSH\v\xAE`\xA7\x0E\x91E\xADZ\xFE\xCF\x96lj\x99\xC7(\xE6\xB1\x9Fe\xFDk\xF9\xDF\x98\xCE\x05Z\x12\xC0\xAA\xFC\xC0E\xFF\xC2'\xFEy\xCD?'\x14\x00%@\xB8i\xFFX\xF3\x0F\bv}6\xFEA\xCD?\xDA\xF1j\xC0\x17\xCF\xBF\xB93\xF9\xDF\x00\r\xD9\x80\xD7\x1C\xAA\xF9\x9C\x03\xD5?7}\xA3\x07!G\r{\x81W\x1F\xAA\xE7_\x0E\xA2<\x840\b\x98\xF5\xF0\xEAth@P\x96\x1Di\x82\x0E\xACf\xA7Y ?\xA8\xF97\xA4\xAE\xC8\xFFBN\xB41\xE0\xD4wH\xCB\x00\xCAx(\x00*p\x02\xCF\v\x05j\x19)\xE4CL\xAD\x7F\x00\xCA\x10\x9A\xA9?\xF3\t\xA5\xB6l\xFD\xDF\x8A\t\x87\x89\x9Ad\x04\xC4\t\xEA!Ssp\xD6\x7F\x91\x96\xFFC\b6i\xFE\x05\xD5\xBF\x96\xFF\x05\x0E\xE3\xD6\"\xEDx\x11\xE1\xA2\xFF<5\x0E\xD4\n`Fx\xD6!h\x9EI\x9E\xD6\xE2~\xC6?\xBD\xD4?\xCFH\xD6?h\xFE1s\xA3\xE9[\xA2\b&:k\xFE\x8Dh \x9BU.\xDB\xBF\x96\xFF\xB9\xA2\xF9\xF4\x12\xFF\b\xCC@\x9D,\xCEsq303\x17\x07\x8E\xA9\xF5?P3B\xD9\xEF_\x04\xCE\x11J\xE7\xF3\xC8\x19T\xBF\x7F\x11\x98\"l\nA<\xEB\xDF\xC9\b\xD0\xEC|\x1F\xD7\xEA\x9F\xCD\b\xB2\xF9\x07\xAB\xFE\x99Z\xFF\b0e\x84qm<\xF9\xA4\xFE\xC9\x9B\x9E\x87\x04\xA9nSyj1\x9FR\xE3y\xFAaH\xFB\n\x90\xE2\x81`\xF5\x14E\x90\xF6\x8D\x8C\x87\x94\x96pBX=\xF0\x84\x83f\xCC\x98\x81e\xF7%&\xD6ia\x97\xD3H\xFF\xFF\x1Fl(\x9F\xB1z\xE5\x04\xD4\xFF4\x7F\xC5^\xF1\xE4\xB3\x0F\t\xFB\xF47q\xB5\xFCG\x9F<\xC0\x9F\x8E\x81O\xF2\x0FhE0UO\tjV'\xD9\xDD4\xFF`P\xA7\x83j\x92\x87\x18f\xE5\x97\xF8\xCF&\xFC\x90\x91e\xFD\x17Y\xD4\xE9G\xB2\xBD\xF1\xE7\xA8\xC5\x03\xC9\x9F\x15\xFF\xFF\xB4\xEB?\xF3?\x7F\xFD\xE7\xD3[\xE2\x97^[\xF8\x94\x7F\x8E\xCD\xCE\xF5\x1F\x1D\x1D\x9D\x7FQ\xFC\xBF\x00\x00\x00\xFF\xFF\xD6;\xD8!\x00\x00\x18\x00")));
		$r = init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = init$1(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/affine"] = (function() {
	var $pkg = {}, $init, color, math, ColorM, sliceType, ptrType, ptrType$1, colorMIdentityBody, colorMIdentityTranslate, rgbToYCbCr, yCbCrToRgb, mulSquare, clamp;
	color = $packages["image/color"];
	math = $packages["math"];
	ColorM = $pkg.ColorM = $newType(0, $kindStruct, "affine.ColorM", true, "github.com/hajimehoshi/ebiten/internal/affine", true, function(body_, translate_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.body = sliceType.nil;
			this.translate = sliceType.nil;
			return;
		}
		this.body = body_;
		this.translate = translate_;
	});
	sliceType = $sliceType($Float32);
	ptrType = $ptrType(ColorM);
	ptrType$1 = $ptrType(sliceType);
	mulSquare = function(lhs, rhs, dim) {
		var dim, e, i, j, k, lhs, result, rhs, x, x$1, x$2;
		result = $makeSlice(sliceType, lhs.$length);
		i = 0;
		while (true) {
			if (!(i < dim)) { break; }
			j = 0;
			while (true) {
				if (!(j < dim)) { break; }
				e = 0;
				k = 0;
				while (true) {
					if (!(k < dim)) { break; }
					e = $fround(e + ($fround((x = ($imul(i, dim)) + k >> 0, ((x < 0 || x >= lhs.$length) ? ($throwRuntimeError("index out of range"), undefined) : lhs.$array[lhs.$offset + x])) * (x$1 = ($imul(k, dim)) + j >> 0, ((x$1 < 0 || x$1 >= rhs.$length) ? ($throwRuntimeError("index out of range"), undefined) : rhs.$array[rhs.$offset + x$1])))));
					k = k + (1) >> 0;
				}
				(x$2 = ($imul(i, dim)) + j >> 0, ((x$2 < 0 || x$2 >= result.$length) ? ($throwRuntimeError("index out of range"), undefined) : result.$array[result.$offset + x$2] = e));
				j = j + (1) >> 0;
			}
			i = i + (1) >> 0;
		}
		return result;
	};
	clamp = function(x) {
		var x;
		if (x > 1) {
			return 1;
		}
		if (x < 0) {
			return 0;
		}
		return x;
	};
	ColorM.ptr.prototype.isInited = function() {
		var c;
		c = this;
		return !(c === ptrType.nil) && (!(c.body === sliceType.nil) || !(c.translate === sliceType.nil));
	};
	ColorM.prototype.isInited = function() { return this.$val.isInited(); };
	ColorM.ptr.prototype.ScaleOnly = function() {
		var _i, _ref, c, e, x, x$1, x$10, x$11, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		c = this;
		if (c === ptrType.nil) {
			return true;
		}
		if (!(c.body === sliceType.nil)) {
			if (!(((x = c.body, (1 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 1])) === 0))) {
				return false;
			}
			if (!(((x$1 = c.body, (2 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 2])) === 0))) {
				return false;
			}
			if (!(((x$2 = c.body, (3 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 3])) === 0))) {
				return false;
			}
			if (!(((x$3 = c.body, (4 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 4])) === 0))) {
				return false;
			}
			if (!(((x$4 = c.body, (6 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 6])) === 0))) {
				return false;
			}
			if (!(((x$5 = c.body, (7 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 7])) === 0))) {
				return false;
			}
			if (!(((x$6 = c.body, (8 >= x$6.$length ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + 8])) === 0))) {
				return false;
			}
			if (!(((x$7 = c.body, (9 >= x$7.$length ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + 9])) === 0))) {
				return false;
			}
			if (!(((x$8 = c.body, (11 >= x$8.$length ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + 11])) === 0))) {
				return false;
			}
			if (!(((x$9 = c.body, (12 >= x$9.$length ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + 12])) === 0))) {
				return false;
			}
			if (!(((x$10 = c.body, (13 >= x$10.$length ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + 13])) === 0))) {
				return false;
			}
			if (!(((x$11 = c.body, (14 >= x$11.$length ? ($throwRuntimeError("index out of range"), undefined) : x$11.$array[x$11.$offset + 14])) === 0))) {
				return false;
			}
		}
		if (!(c.translate === sliceType.nil)) {
			_ref = c.translate;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				e = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (!((e === 0))) {
					return false;
				}
				_i++;
			}
		}
		return true;
	};
	ColorM.prototype.ScaleOnly = function() { return this.$val.ScaleOnly(); };
	ColorM.ptr.prototype.Apply = function(clr) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, a, af, af2, b, bf, bf2, c, clr, eb, et, g, gf, gf2, r, rf, rf2, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; a = $f.a; af = $f.af; af2 = $f.af2; b = $f.b; bf = $f.bf; bf2 = $f.bf2; c = $f.c; clr = $f.clr; eb = $f.eb; et = $f.et; g = $f.g; gf = $f.gf; gf2 = $f.gf2; r = $f.r; rf = $f.rf; rf2 = $f.rf2; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		if (!c.isInited()) {
			$s = -1; return clr;
		}
		_r = clr.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		g = _tuple[1];
		b = _tuple[2];
		a = _tuple[3];
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = 0;
		_tmp$3 = 0;
		rf = _tmp;
		gf = _tmp$1;
		bf = _tmp$2;
		af = _tmp$3;
		if (a > 0) {
			rf = $fround((r) / (a));
			gf = $fround((g) / (a));
			bf = $fround((b) / (a));
			af = $fround((a) / 65535);
		}
		eb = c.body;
		if (eb === sliceType.nil) {
			eb = colorMIdentityBody;
		}
		et = c.translate;
		if (et === sliceType.nil) {
			et = colorMIdentityTranslate;
		}
		rf2 = $fround($fround($fround($fround($fround((0 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 0]) * rf) + $fround((4 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 4]) * gf)) + $fround((8 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 8]) * bf)) + $fround((12 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 12]) * af)) + (0 >= et.$length ? ($throwRuntimeError("index out of range"), undefined) : et.$array[et.$offset + 0]));
		gf2 = $fround($fround($fround($fround($fround((1 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 1]) * rf) + $fround((5 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 5]) * gf)) + $fround((9 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 9]) * bf)) + $fround((13 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 13]) * af)) + (1 >= et.$length ? ($throwRuntimeError("index out of range"), undefined) : et.$array[et.$offset + 1]));
		bf2 = $fround($fround($fround($fround($fround((2 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 2]) * rf) + $fround((6 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 6]) * gf)) + $fround((10 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 10]) * bf)) + $fround((14 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 14]) * af)) + (2 >= et.$length ? ($throwRuntimeError("index out of range"), undefined) : et.$array[et.$offset + 2]));
		af2 = $fround($fround($fround($fround($fround((3 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 3]) * rf) + $fround((7 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 7]) * gf)) + $fround((11 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 11]) * bf)) + $fround((15 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 15]) * af)) + (3 >= et.$length ? ($throwRuntimeError("index out of range"), undefined) : et.$array[et.$offset + 3]));
		rf2 = clamp(rf2);
		gf2 = clamp(gf2);
		bf2 = clamp(bf2);
		af2 = clamp(af2);
		$s = -1; return (x = new color.NRGBA64.ptr((($fround(rf2 * 65535) >> 0)), (($fround(gf2 * 65535) >> 0)), (($fround(bf2 * 65535) >> 0)), (($fround(af2 * 65535) >> 0))), new x.constructor.elem(x));
		/* */ } return; } if ($f === undefined) { $f = { $blk: ColorM.ptr.prototype.Apply }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.a = a; $f.af = af; $f.af2 = af2; $f.b = b; $f.bf = bf; $f.bf2 = bf2; $f.c = c; $f.clr = clr; $f.eb = eb; $f.et = et; $f.g = g; $f.gf = gf; $f.gf2 = gf2; $f.r = r; $f.rf = rf; $f.rf2 = rf2; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	ColorM.prototype.Apply = function(clr) { return this.$val.Apply(clr); };
	ColorM.ptr.prototype.UnsafeElements = function() {
		var c, eb, et;
		c = this;
		if (!c.isInited()) {
			return [colorMIdentityBody, colorMIdentityTranslate];
		}
		eb = c.body;
		if (eb === sliceType.nil) {
			eb = colorMIdentityBody;
		}
		et = c.translate;
		if (et === sliceType.nil) {
			et = colorMIdentityTranslate;
		}
		return [eb, et];
	};
	ColorM.prototype.UnsafeElements = function() { return this.$val.UnsafeElements(); };
	ColorM.ptr.prototype.SetElement = function(i, j, element) {
		var c, element, i, j, newC, x, x$1, x$2;
		c = this;
		newC = new ColorM.ptr($makeSlice(sliceType, 16), $makeSlice(sliceType, 4));
		$copySlice(newC.body, colorMIdentityBody);
		$copySlice(newC.translate, colorMIdentityTranslate);
		if (c.isInited()) {
			if (!(c.body === sliceType.nil)) {
				$copySlice(newC.body, c.body);
			}
			if (!(c.translate === sliceType.nil)) {
				$copySlice(newC.translate, c.translate);
			}
		}
		if (j < 4) {
			(x = newC.body, x$1 = i + ($imul(j, 4)) >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1] = element));
		} else {
			(x$2 = newC.translate, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i] = element));
		}
		return newC;
	};
	ColorM.prototype.SetElement = function(i, j, element) { return this.$val.SetElement(i, j, element); };
	ColorM.ptr.prototype.Equals = function(other) {
		var _i, _i$1, _ref, _ref$1, c, i, i$1, lhsb, lhsb$24ptr, lhst, lhst$24ptr, other, rhsb, rhsb$24ptr, rhst, rhst$24ptr;
		c = this;
		if (!c.isInited() && !other.isInited()) {
			return true;
		}
		lhsb = colorMIdentityBody;
		lhst = colorMIdentityTranslate;
		rhsb = colorMIdentityBody;
		rhst = colorMIdentityTranslate;
		if (other.isInited()) {
			if (!(other.body === sliceType.nil)) {
				lhsb = other.body;
			}
			if (!(other.translate === sliceType.nil)) {
				lhst = other.translate;
			}
		}
		if (c.isInited()) {
			if (!(c.body === sliceType.nil)) {
				rhsb = c.body;
			}
			if (!(c.translate === sliceType.nil)) {
				rhst = c.translate;
			}
		}
		if ((lhsb$24ptr || (lhsb$24ptr = new ptrType$1(function() { return lhsb; }, function($v) { lhsb = $subslice(new sliceType($v.$array), $v.$offset, $v.$offset + $v.$length); }))) === (rhsb$24ptr || (rhsb$24ptr = new ptrType$1(function() { return rhsb; }, function($v) { rhsb = $subslice(new sliceType($v.$array), $v.$offset, $v.$offset + $v.$length); }))) && (lhst$24ptr || (lhst$24ptr = new ptrType$1(function() { return lhst; }, function($v) { lhst = $subslice(new sliceType($v.$array), $v.$offset, $v.$offset + $v.$length); }))) === (rhst$24ptr || (rhst$24ptr = new ptrType$1(function() { return rhst; }, function($v) { rhst = $subslice(new sliceType($v.$array), $v.$offset, $v.$offset + $v.$length); })))) {
			return true;
		}
		_ref = lhsb;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			if (!((((i < 0 || i >= lhsb.$length) ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + i]) === ((i < 0 || i >= rhsb.$length) ? ($throwRuntimeError("index out of range"), undefined) : rhsb.$array[rhsb.$offset + i])))) {
				return false;
			}
			_i++;
		}
		_ref$1 = lhst;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			if (!((((i$1 < 0 || i$1 >= lhst.$length) ? ($throwRuntimeError("index out of range"), undefined) : lhst.$array[lhst.$offset + i$1]) === ((i$1 < 0 || i$1 >= rhst.$length) ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + i$1])))) {
				return false;
			}
			_i$1++;
		}
		return true;
	};
	ColorM.prototype.Equals = function(other) { return this.$val.Equals(other); };
	ColorM.ptr.prototype.Concat = function(other) {
		var c, lhsb, lhst, other, rhsb, rhst;
		c = this;
		if (!c.isInited()) {
			return other;
		}
		if (!other.isInited()) {
			return c;
		}
		lhsb = colorMIdentityBody;
		lhst = colorMIdentityTranslate;
		rhsb = colorMIdentityBody;
		rhst = colorMIdentityTranslate;
		if (other.isInited()) {
			if (!(other.body === sliceType.nil)) {
				lhsb = other.body;
			}
			if (!(other.translate === sliceType.nil)) {
				lhst = other.translate;
			}
		}
		if (c.isInited()) {
			if (!(c.body === sliceType.nil)) {
				rhsb = c.body;
			}
			if (!(c.translate === sliceType.nil)) {
				rhst = c.translate;
			}
		}
		return new ColorM.ptr(mulSquare(rhsb, lhsb, 4), new sliceType([$fround($fround($fround($fround($fround((0 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 0]) * (0 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 0])) + $fround((4 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 4]) * (1 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 1]))) + $fround((8 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 8]) * (2 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 2]))) + $fround((12 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 12]) * (3 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 3]))) + (0 >= lhst.$length ? ($throwRuntimeError("index out of range"), undefined) : lhst.$array[lhst.$offset + 0])), $fround($fround($fround($fround($fround((1 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 1]) * (0 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 0])) + $fround((5 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 5]) * (1 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 1]))) + $fround((9 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 9]) * (2 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 2]))) + $fround((13 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 13]) * (3 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 3]))) + (1 >= lhst.$length ? ($throwRuntimeError("index out of range"), undefined) : lhst.$array[lhst.$offset + 1])), $fround($fround($fround($fround($fround((2 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 2]) * (0 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 0])) + $fround((6 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 6]) * (1 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 1]))) + $fround((10 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 10]) * (2 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 2]))) + $fround((14 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 14]) * (3 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 3]))) + (2 >= lhst.$length ? ($throwRuntimeError("index out of range"), undefined) : lhst.$array[lhst.$offset + 2])), $fround($fround($fround($fround($fround((3 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 3]) * (0 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 0])) + $fround((7 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 7]) * (1 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 1]))) + $fround((11 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 11]) * (2 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 2]))) + $fround((15 >= lhsb.$length ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + 15]) * (3 >= rhst.$length ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + 3]))) + (3 >= lhst.$length ? ($throwRuntimeError("index out of range"), undefined) : lhst.$array[lhst.$offset + 3]))]));
	};
	ColorM.prototype.Concat = function(other) { return this.$val.Concat(other); };
	ColorM.ptr.prototype.Add = function(other) {
		var _i, _i$1, _ref, _ref$1, c, i, i$1, lhsb, lhst, newC, other, rhsb, rhst, x, x$1;
		c = this;
		lhsb = colorMIdentityBody;
		lhst = colorMIdentityTranslate;
		rhsb = colorMIdentityBody;
		rhst = colorMIdentityTranslate;
		if (other.isInited()) {
			if (!(other.body === sliceType.nil)) {
				lhsb = other.body;
			}
			if (!(other.translate === sliceType.nil)) {
				lhst = other.translate;
			}
		}
		if (c.isInited()) {
			if (!(c.body === sliceType.nil)) {
				rhsb = c.body;
			}
			if (!(c.translate === sliceType.nil)) {
				rhst = c.translate;
			}
		}
		newC = new ColorM.ptr($makeSlice(sliceType, 16), $makeSlice(sliceType, 4));
		_ref = lhsb;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			(x = newC.body, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i] = $fround(((i < 0 || i >= lhsb.$length) ? ($throwRuntimeError("index out of range"), undefined) : lhsb.$array[lhsb.$offset + i]) + ((i < 0 || i >= rhsb.$length) ? ($throwRuntimeError("index out of range"), undefined) : rhsb.$array[rhsb.$offset + i]))));
			_i++;
		}
		_ref$1 = lhst;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			(x$1 = newC.translate, ((i$1 < 0 || i$1 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i$1] = $fround(((i$1 < 0 || i$1 >= lhst.$length) ? ($throwRuntimeError("index out of range"), undefined) : lhst.$array[lhst.$offset + i$1]) + ((i$1 < 0 || i$1 >= rhst.$length) ? ($throwRuntimeError("index out of range"), undefined) : rhst.$array[rhst.$offset + i$1]))));
			_i$1++;
		}
		return newC;
	};
	ColorM.prototype.Add = function(other) { return this.$val.Add(other); };
	ColorM.ptr.prototype.Scale = function(r, g, b, a) {
		var _index, _index$1, _index$2, _index$3, a, b, c, eb, et, g, i, r, x, x$1, x$2, x$3;
		c = this;
		if (!c.isInited()) {
			return new ColorM.ptr(new sliceType([r, 0, 0, 0, 0, g, 0, 0, 0, 0, b, 0, 0, 0, 0, a]), sliceType.nil);
		}
		eb = $makeSlice(sliceType, colorMIdentityBody.$length);
		if (!(c.body === sliceType.nil)) {
			$copySlice(eb, c.body);
			i = 0;
			while (true) {
				if (!(i < 4)) { break; }
				_index = $imul(i, 4);
				((_index < 0 || _index >= eb.$length) ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + _index] = $fround(((_index < 0 || _index >= eb.$length) ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + _index]) * (r)));
				_index$1 = ($imul(i, 4)) + 1 >> 0;
				((_index$1 < 0 || _index$1 >= eb.$length) ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + _index$1] = $fround(((_index$1 < 0 || _index$1 >= eb.$length) ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + _index$1]) * (g)));
				_index$2 = ($imul(i, 4)) + 2 >> 0;
				((_index$2 < 0 || _index$2 >= eb.$length) ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + _index$2] = $fround(((_index$2 < 0 || _index$2 >= eb.$length) ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + _index$2]) * (b)));
				_index$3 = ($imul(i, 4)) + 3 >> 0;
				((_index$3 < 0 || _index$3 >= eb.$length) ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + _index$3] = $fround(((_index$3 < 0 || _index$3 >= eb.$length) ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + _index$3]) * (a)));
				i = i + (1) >> 0;
			}
		} else {
			(0 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 0] = r);
			(5 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 5] = g);
			(10 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 10] = b);
			(15 >= eb.$length ? ($throwRuntimeError("index out of range"), undefined) : eb.$array[eb.$offset + 15] = a);
		}
		et = $makeSlice(sliceType, colorMIdentityTranslate.$length);
		if (!(c.translate === sliceType.nil)) {
			(0 >= et.$length ? ($throwRuntimeError("index out of range"), undefined) : et.$array[et.$offset + 0] = $fround((x = c.translate, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) * r));
			(1 >= et.$length ? ($throwRuntimeError("index out of range"), undefined) : et.$array[et.$offset + 1] = $fround((x$1 = c.translate, (1 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 1])) * g));
			(2 >= et.$length ? ($throwRuntimeError("index out of range"), undefined) : et.$array[et.$offset + 2] = $fround((x$2 = c.translate, (2 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 2])) * b));
			(3 >= et.$length ? ($throwRuntimeError("index out of range"), undefined) : et.$array[et.$offset + 3] = $fround((x$3 = c.translate, (3 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 3])) * a));
		}
		return new ColorM.ptr(eb, et);
	};
	ColorM.prototype.Scale = function(r, g, b, a) { return this.$val.Scale(r, g, b, a); };
	ColorM.ptr.prototype.Translate = function(r, g, b, a) {
		var a, b, c, es, g, r;
		c = this;
		if (!c.isInited()) {
			return new ColorM.ptr(sliceType.nil, new sliceType([r, g, b, a]));
		}
		es = $makeSlice(sliceType, colorMIdentityTranslate.$length);
		if (!(c.translate === sliceType.nil)) {
			$copySlice(es, c.translate);
		}
		(0 >= es.$length ? ($throwRuntimeError("index out of range"), undefined) : es.$array[es.$offset + 0] = $fround((0 >= es.$length ? ($throwRuntimeError("index out of range"), undefined) : es.$array[es.$offset + 0]) + (r)));
		(1 >= es.$length ? ($throwRuntimeError("index out of range"), undefined) : es.$array[es.$offset + 1] = $fround((1 >= es.$length ? ($throwRuntimeError("index out of range"), undefined) : es.$array[es.$offset + 1]) + (g)));
		(2 >= es.$length ? ($throwRuntimeError("index out of range"), undefined) : es.$array[es.$offset + 2] = $fround((2 >= es.$length ? ($throwRuntimeError("index out of range"), undefined) : es.$array[es.$offset + 2]) + (b)));
		(3 >= es.$length ? ($throwRuntimeError("index out of range"), undefined) : es.$array[es.$offset + 3] = $fround((3 >= es.$length ? ($throwRuntimeError("index out of range"), undefined) : es.$array[es.$offset + 3]) + (a)));
		return new ColorM.ptr(c.body, es);
	};
	ColorM.prototype.Translate = function(r, g, b, a) { return this.$val.Translate(r, g, b, a); };
	ColorM.ptr.prototype.ChangeHSV = function(hueTheta, saturationScale, valueScale) {
		var _tmp, _tmp$1, _tuple, c, c32, cos, hueTheta, s, s32, saturationScale, sin, v, valueScale;
		c = this;
		_tuple = math.Sincos(hueTheta);
		sin = _tuple[0];
		cos = _tuple[1];
		_tmp = ($fround(sin));
		_tmp$1 = ($fround(cos));
		s32 = _tmp;
		c32 = _tmp$1;
		c = c.Concat(rgbToYCbCr);
		c = c.Concat(new ColorM.ptr(new sliceType([1, 0, 0, 0, 0, c32, s32, 0, 0, -s32, c32, 0, 0, 0, 0, 1]), sliceType.nil));
		s = saturationScale;
		v = valueScale;
		c = c.Scale(v, $fround(s * v), $fround(s * v), 1);
		c = c.Concat(yCbCrToRgb);
		return c;
	};
	ColorM.prototype.ChangeHSV = function(hueTheta, saturationScale, valueScale) { return this.$val.ChangeHSV(hueTheta, saturationScale, valueScale); };
	ptrType.methods = [{prop: "isInited", name: "isInited", pkg: "github.com/hajimehoshi/ebiten/internal/affine", typ: $funcType([], [$Bool], false)}, {prop: "ScaleOnly", name: "ScaleOnly", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Apply", name: "Apply", pkg: "", typ: $funcType([color.Color], [color.Color], false)}, {prop: "UnsafeElements", name: "UnsafeElements", pkg: "", typ: $funcType([], [sliceType, sliceType], false)}, {prop: "SetElement", name: "SetElement", pkg: "", typ: $funcType([$Int, $Int, $Float32], [ptrType], false)}, {prop: "Equals", name: "Equals", pkg: "", typ: $funcType([ptrType], [$Bool], false)}, {prop: "Concat", name: "Concat", pkg: "", typ: $funcType([ptrType], [ptrType], false)}, {prop: "Add", name: "Add", pkg: "", typ: $funcType([ptrType], [ptrType], false)}, {prop: "Scale", name: "Scale", pkg: "", typ: $funcType([$Float32, $Float32, $Float32, $Float32], [ptrType], false)}, {prop: "Translate", name: "Translate", pkg: "", typ: $funcType([$Float32, $Float32, $Float32, $Float32], [ptrType], false)}, {prop: "ChangeHSV", name: "ChangeHSV", pkg: "", typ: $funcType([$Float64, $Float32, $Float32], [ptrType], false)}];
	ColorM.init("github.com/hajimehoshi/ebiten/internal/affine", [{prop: "body", name: "body", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "translate", name: "translate", embedded: false, exported: false, typ: sliceType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = color.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		colorMIdentityBody = new sliceType([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
		colorMIdentityTranslate = new sliceType([0, 0, 0, 0]);
		rgbToYCbCr = new ColorM.ptr(new sliceType([0.29899999499320984, -0.16869999468326569, 0.5, 0, 0.5870000123977661, -0.3312999904155731, -0.4187000095844269, 0, 0.11400000005960464, 0.5, -0.08129999786615372, 0, 0, 0, 0, 1]), sliceType.nil);
		yCbCrToRgb = new ColorM.ptr(new sliceType([1, 1, 1, 0, 0, -0.3441399931907654, 1.7719999551773071, 0, 1.4019999504089355, -0.714139997959137, 0, 0, 0, 0, 0, 1]), sliceType.nil);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["syscall/js"] = (function() {
	var $pkg = {}, $init, js, reflect, Type, Func, Value, TypedArray, ValueError, sliceType, mapType, sliceType$1, sliceType$2, sliceType$3, sliceType$4, sliceType$5, sliceType$6, sliceType$7, sliceType$8, sliceType$9, ptrType, ptrType$1, ptrType$2, id, instanceOf, getValueType, Global, Null, Undefined, FuncOf, objectToValue, init, ValueOf, convertArgs, TypedArrayOf;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	reflect = $packages["reflect"];
	Type = $pkg.Type = $newType(4, $kindInt, "js.Type", true, "syscall/js", true, null);
	Func = $pkg.Func = $newType(0, $kindStruct, "js.Func", true, "syscall/js", true, function(Value_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Value = new Value.ptr(null, false);
			return;
		}
		this.Value = Value_;
	});
	Value = $pkg.Value = $newType(0, $kindStruct, "js.Value", true, "syscall/js", true, function(v_, inited_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.v = null;
			this.inited = false;
			return;
		}
		this.v = v_;
		this.inited = inited_;
	});
	TypedArray = $pkg.TypedArray = $newType(0, $kindStruct, "js.TypedArray", true, "syscall/js", true, function(Value_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Value = new Value.ptr(null, false);
			return;
		}
		this.Value = Value_;
	});
	ValueError = $pkg.ValueError = $newType(0, $kindStruct, "js.ValueError", true, "syscall/js", true, function(Method_, Type_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Method = "";
			this.Type = 0;
			return;
		}
		this.Method = Method_;
		this.Type = Type_;
	});
	sliceType = $sliceType(Value);
	mapType = $mapType($String, $emptyInterface);
	sliceType$1 = $sliceType($emptyInterface);
	sliceType$2 = $sliceType($Int8);
	sliceType$3 = $sliceType($Int16);
	sliceType$4 = $sliceType($Int32);
	sliceType$5 = $sliceType($Uint8);
	sliceType$6 = $sliceType($Uint16);
	sliceType$7 = $sliceType($Uint32);
	sliceType$8 = $sliceType($Float32);
	sliceType$9 = $sliceType($Float64);
	ptrType = $ptrType(js.Object);
	ptrType$1 = $ptrType(TypedArray);
	ptrType$2 = $ptrType(ValueError);
	Type.prototype.String = function() {
		var _1, t;
		t = this.$val;
		_1 = t;
		if (_1 === (0)) {
			return "undefined";
		} else if (_1 === (1)) {
			return "null";
		} else if (_1 === (2)) {
			return "boolean";
		} else if (_1 === (3)) {
			return "number";
		} else if (_1 === (4)) {
			return "string";
		} else if (_1 === (5)) {
			return "symbol";
		} else if (_1 === (6)) {
			return "object";
		} else if (_1 === (7)) {
			return "function";
		} else {
			$panic(new $String("bad type"));
		}
	};
	$ptrType(Type).prototype.String = function() { return new Type(this.$get()).String(); };
	Global = function() {
		return objectToValue($global);
	};
	$pkg.Global = Global;
	Null = function() {
		return objectToValue(null);
	};
	$pkg.Null = Null;
	Undefined = function() {
		return objectToValue(undefined);
	};
	$pkg.Undefined = Undefined;
	Func.ptr.prototype.Release = function() {
		var f;
		f = this;
		Value.copy(f.Value, Null());
	};
	Func.prototype.Release = function() { return this.$val.Release(); };
	FuncOf = function(fn) {
		var fn;
		return new Func.ptr($clone(objectToValue(js.MakeFunc((function $b(this$1, args) {
			var _i, _r, _ref, a, args, i, this$1, vargs, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; a = $f.a; args = $f.args; i = $f.i; this$1 = $f.this$1; vargs = $f.vargs; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			vargs = $makeSlice(sliceType, args.$length);
			_ref = args;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				a = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				Value.copy(((i < 0 || i >= vargs.$length) ? ($throwRuntimeError("index out of range"), undefined) : vargs.$array[vargs.$offset + i]), objectToValue(a));
				_i++;
			}
			_r = fn($clone(objectToValue(this$1), Value), vargs); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.a = a; $f.args = args; $f.i = i; $f.this$1 = this$1; $f.vargs = vargs; $f.$s = $s; $f.$r = $r; return $f;
		}))), Value));
	};
	$pkg.FuncOf = FuncOf;
	objectToValue = function(obj) {
		var obj;
		if (obj === undefined) {
			return new Value.ptr(null, false);
		}
		return new Value.ptr(obj, true);
	};
	init = function() {
		if (!($global === null)) {
			id = $global.eval($externalize("(function(x) { return x; })", $String));
			instanceOf = $global.eval($externalize("(function(x, y) { return x instanceof y; })", $String));
			getValueType = $global.eval($externalize("(function(x) {\n  if (typeof(x) === \"undefined\") {\n    return 0; // TypeUndefined\n  }\n  if (x === null) {\n    return 1; // TypeNull\n  }\n  if (typeof(x) === \"boolean\") {\n    return 2; // TypeBoolean\n  }\n  if (typeof(x) === \"number\") {\n    return 3; // TypeNumber\n  }\n  if (typeof(x) === \"string\") {\n    return 4; // TypeString\n  }\n  if (typeof(x) === \"symbol\") {\n    return 5; // TypeSymbol\n  }\n  if (typeof(x) === \"function\") {\n    return 7; // TypeFunction\n  }\n  return 6; // TypeObject\n})", $String));
		}
	};
	ValueOf = function(x) {
		var _r, _ref, x, x$1, x$2, x$3, x$4, x$5, x$6, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _ref = $f._ref; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_ref = x;
		/* */ if ($assertType(_ref, Value, true)[1]) { $s = 1; continue; }
		/* */ if ($assertType(_ref, Func, true)[1]) { $s = 2; continue; }
		/* */ if ($assertType(_ref, TypedArray, true)[1]) { $s = 3; continue; }
		/* */ if (_ref === $ifaceNil) { $s = 4; continue; }
		/* */ if ($assertType(_ref, $Bool, true)[1] || $assertType(_ref, $Int, true)[1] || $assertType(_ref, $Int8, true)[1] || $assertType(_ref, $Int16, true)[1] || $assertType(_ref, $Int32, true)[1] || $assertType(_ref, $Int64, true)[1] || $assertType(_ref, $Uint, true)[1] || $assertType(_ref, $Uint8, true)[1] || $assertType(_ref, $Uint16, true)[1] || $assertType(_ref, $Uint32, true)[1] || $assertType(_ref, $Uint64, true)[1] || $assertType(_ref, $Float32, true)[1] || $assertType(_ref, $Float64, true)[1] || $assertType(_ref, $UnsafePointer, true)[1] || $assertType(_ref, $String, true)[1] || $assertType(_ref, mapType, true)[1] || $assertType(_ref, sliceType$1, true)[1]) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if ($assertType(_ref, Value, true)[1]) { */ case 1:
			x$1 = $clone(_ref.$val, Value);
			$s = -1; return x$1;
		/* } else if ($assertType(_ref, Func, true)[1]) { */ case 2:
			x$2 = $clone(_ref.$val, Func);
			$s = -1; return x$2.Value;
		/* } else if ($assertType(_ref, TypedArray, true)[1]) { */ case 3:
			x$3 = $clone(_ref.$val, TypedArray);
			$s = -1; return x$3.Value;
		/* } else if (_ref === $ifaceNil) { */ case 4:
			x$4 = _ref;
			$s = -1; return Null();
		/* } else if ($assertType(_ref, $Bool, true)[1] || $assertType(_ref, $Int, true)[1] || $assertType(_ref, $Int8, true)[1] || $assertType(_ref, $Int16, true)[1] || $assertType(_ref, $Int32, true)[1] || $assertType(_ref, $Int64, true)[1] || $assertType(_ref, $Uint, true)[1] || $assertType(_ref, $Uint8, true)[1] || $assertType(_ref, $Uint16, true)[1] || $assertType(_ref, $Uint32, true)[1] || $assertType(_ref, $Uint64, true)[1] || $assertType(_ref, $Float32, true)[1] || $assertType(_ref, $Float64, true)[1] || $assertType(_ref, $UnsafePointer, true)[1] || $assertType(_ref, $String, true)[1] || $assertType(_ref, mapType, true)[1] || $assertType(_ref, sliceType$1, true)[1]) { */ case 5:
			x$5 = _ref;
			$s = -1; return objectToValue(id($externalize(x$5, $emptyInterface)));
		/* } else { */ case 6:
			x$6 = _ref;
			_r = reflect.TypeOf(x$6).String(); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$panic(new $String("invalid arg: " + _r));
		/* } */ case 7:
		$s = -1; return new Value.ptr(null, false);
		/* */ } return; } if ($f === undefined) { $f = { $blk: ValueOf }; } $f._r = _r; $f._ref = _ref; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ValueOf = ValueOf;
	Value.ptr.prototype.internal = function() {
		var v;
		v = this;
		if (!v.inited) {
			return undefined;
		}
		return v.v;
	};
	Value.prototype.internal = function() { return this.$val.internal(); };
	Value.ptr.prototype.Bool = function() {
		var v, vType;
		v = this;
		vType = $clone(v, Value).Type();
		if (!((vType === 2))) {
			$panic(new ValueError.ptr("Value.Bool", vType));
		}
		return !!($clone(v, Value).internal());
	};
	Value.prototype.Bool = function() { return this.$val.Bool(); };
	convertArgs = function(args) {
		var _i, _r, _ref, arg, args, newArgs, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; arg = $f.arg; args = $f.args; newArgs = $f.newArgs; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		newArgs = new sliceType$1([]);
		_ref = args;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			arg = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r = ValueOf(arg); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			v = $clone(_r, Value);
			newArgs = $append(newArgs, new $jsObjectPtr($clone(v, Value).internal()));
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return newArgs;
		/* */ } return; } if ($f === undefined) { $f = { $blk: convertArgs }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.arg = arg; $f.args = args; $f.newArgs = newArgs; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.ptr.prototype.Call = function(m, args) {
		var _r, _r$1, args, m, obj, propType, v, vType, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; args = $f.args; m = $f.m; obj = $f.obj; propType = $f.propType; v = $f.v; vType = $f.vType; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		vType = $clone(v, Value).Type();
		if (!((vType === 6)) && !((vType === 7))) {
			$panic(new ValueError.ptr("Value.Call", vType));
		}
		propType = $clone($clone(v, Value).Get(m), Value).Type();
		if (!((propType === 7))) {
			$panic(new $String("js: Value.Call: property " + m + " is not a function, got " + new Type(propType).String()));
		}
		_r = convertArgs(args); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = objectToValue((obj = $clone(v, Value).internal(), obj[$externalize(m, $String)].apply(obj, $externalize(_r, sliceType$1)))); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Call }; } $f._r = _r; $f._r$1 = _r$1; $f.args = args; $f.m = m; $f.obj = obj; $f.propType = propType; $f.v = v; $f.vType = vType; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Call = function(m, args) { return this.$val.Call(m, args); };
	Value.ptr.prototype.Float = function() {
		var v, vType;
		v = this;
		vType = $clone(v, Value).Type();
		if (!((vType === 3))) {
			$panic(new ValueError.ptr("Value.Float", vType));
		}
		return $parseFloat($clone(v, Value).internal());
	};
	Value.prototype.Float = function() { return this.$val.Float(); };
	Value.ptr.prototype.Get = function(p) {
		var p, v;
		v = this;
		return objectToValue($clone(v, Value).internal()[$externalize(p, $String)]);
	};
	Value.prototype.Get = function(p) { return this.$val.Get(p); };
	Value.ptr.prototype.Index = function(i) {
		var i, v;
		v = this;
		return objectToValue($clone(v, Value).internal()[i]);
	};
	Value.prototype.Index = function(i) { return this.$val.Index(i); };
	Value.ptr.prototype.Int = function() {
		var v, vType;
		v = this;
		vType = $clone(v, Value).Type();
		if (!((vType === 3))) {
			$panic(new ValueError.ptr("Value.Int", vType));
		}
		return $parseInt($clone(v, Value).internal()) >> 0;
	};
	Value.prototype.Int = function() { return this.$val.Int(); };
	Value.ptr.prototype.InstanceOf = function(t) {
		var t, v;
		v = this;
		return !!(instanceOf($clone(v, Value).internal(), $clone(t, Value).internal()));
	};
	Value.prototype.InstanceOf = function(t) { return this.$val.InstanceOf(t); };
	Value.ptr.prototype.Invoke = function(args) {
		var _r, _r$1, args, v, vType, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; args = $f.args; v = $f.v; vType = $f.vType; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		vType = $clone(v, Value).Type();
		if (!((vType === 7))) {
			$panic(new ValueError.ptr("Value.Invoke", vType));
		}
		_r = convertArgs(args); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = objectToValue($clone(v, Value).internal().apply(undefined, $externalize(_r, sliceType$1))); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Invoke }; } $f._r = _r; $f._r$1 = _r$1; $f.args = args; $f.v = v; $f.vType = vType; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Invoke = function(args) { return this.$val.Invoke(args); };
	Value.ptr.prototype.JSValue = function() {
		var v;
		v = this;
		return v;
	};
	Value.prototype.JSValue = function() { return this.$val.JSValue(); };
	Value.ptr.prototype.Length = function() {
		var v;
		v = this;
		return $parseInt($clone(v, Value).internal().length);
	};
	Value.prototype.Length = function() { return this.$val.Length(); };
	Value.ptr.prototype.New = function(args) {
		var _r, _r$1, args, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; args = $f.args; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		_r = convertArgs(args); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = objectToValue(new ($global.Function.prototype.bind.apply($clone(v, Value).internal(), [undefined].concat($externalize(_r, sliceType$1))))); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.New }; } $f._r = _r; $f._r$1 = _r$1; $f.args = args; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.New = function(args) { return this.$val.New(args); };
	Value.ptr.prototype.Set = function(p, x) {
		var _r, p, v, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; v = $f.v; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		_r = convertArgs(new sliceType$1([x])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$clone(v, Value).internal()[$externalize(p, $String)] = $externalize((x$1 = _r, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])), $emptyInterface);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Set }; } $f._r = _r; $f.p = p; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.Set = function(p, x) { return this.$val.Set(p, x); };
	Value.ptr.prototype.SetIndex = function(i, x) {
		var _r, i, v, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; v = $f.v; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		_r = convertArgs(new sliceType$1([x])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$clone(v, Value).internal()[i] = $externalize((x$1 = _r, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])), $emptyInterface);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.SetIndex }; } $f._r = _r; $f.i = i; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Value.prototype.SetIndex = function(i, x) { return this.$val.SetIndex(i, x); };
	Value.ptr.prototype.String = function() {
		var v;
		v = this;
		return $internalize($clone(v, Value).internal(), $String);
	};
	Value.prototype.String = function() { return this.$val.String(); };
	Value.ptr.prototype.Truthy = function() {
		var v;
		v = this;
		return !!($clone(v, Value).internal());
	};
	Value.prototype.Truthy = function() { return this.$val.Truthy(); };
	Value.ptr.prototype.Type = function() {
		var v;
		v = this;
		return ((($parseInt(getValueType($clone(v, Value).internal())) >> 0) >> 0));
	};
	Value.prototype.Type = function() { return this.$val.Type(); };
	TypedArrayOf = function(slice) {
		var _ref, slice, slice$1, slice$2;
		_ref = slice;
		if ($assertType(_ref, sliceType$2, true)[1] || $assertType(_ref, sliceType$3, true)[1] || $assertType(_ref, sliceType$4, true)[1] || $assertType(_ref, sliceType$5, true)[1] || $assertType(_ref, sliceType$6, true)[1] || $assertType(_ref, sliceType$7, true)[1] || $assertType(_ref, sliceType$8, true)[1] || $assertType(_ref, sliceType$9, true)[1]) {
			slice$1 = _ref;
			return new TypedArray.ptr($clone(objectToValue(id($externalize(slice$1, $emptyInterface))), Value));
		} else {
			slice$2 = _ref;
			$panic(new $String("TypedArrayOf: not a supported slice"));
		}
	};
	$pkg.TypedArrayOf = TypedArrayOf;
	TypedArray.ptr.prototype.Release = function() {
		var t;
		t = this;
		Value.copy(t.Value, new Value.ptr(null, false));
	};
	TypedArray.prototype.Release = function() { return this.$val.Release(); };
	ValueError.ptr.prototype.Error = function() {
		var e;
		e = this;
		return "syscall/js: call of " + e.Method + " on " + new Type(e.Type).String();
	};
	ValueError.prototype.Error = function() { return this.$val.Error(); };
	Type.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	Func.methods = [{prop: "Release", name: "Release", pkg: "", typ: $funcType([], [], false)}];
	Value.methods = [{prop: "internal", name: "internal", pkg: "syscall/js", typ: $funcType([], [ptrType], false)}, {prop: "Bool", name: "Bool", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Call", name: "Call", pkg: "", typ: $funcType([$String, sliceType$1], [Value], true)}, {prop: "Float", name: "Float", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Get", name: "Get", pkg: "", typ: $funcType([$String], [Value], false)}, {prop: "Index", name: "Index", pkg: "", typ: $funcType([$Int], [Value], false)}, {prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "InstanceOf", name: "InstanceOf", pkg: "", typ: $funcType([Value], [$Bool], false)}, {prop: "Invoke", name: "Invoke", pkg: "", typ: $funcType([sliceType$1], [Value], true)}, {prop: "JSValue", name: "JSValue", pkg: "", typ: $funcType([], [Value], false)}, {prop: "Length", name: "Length", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "New", name: "New", pkg: "", typ: $funcType([sliceType$1], [Value], true)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$String, $emptyInterface], [], false)}, {prop: "SetIndex", name: "SetIndex", pkg: "", typ: $funcType([$Int, $emptyInterface], [], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Truthy", name: "Truthy", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Type", name: "Type", pkg: "", typ: $funcType([], [Type], false)}];
	ptrType$1.methods = [{prop: "Release", name: "Release", pkg: "", typ: $funcType([], [], false)}];
	ptrType$2.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	Func.init("", [{prop: "Value", name: "Value", embedded: true, exported: true, typ: Value, tag: ""}]);
	Value.init("syscall/js", [{prop: "v", name: "v", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "inited", name: "inited", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	TypedArray.init("", [{prop: "Value", name: "Value", embedded: true, exported: true, typ: Value, tag: ""}]);
	ValueError.init("", [{prop: "Method", name: "Method", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Type", name: "Type", embedded: false, exported: true, typ: Type, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = reflect.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		id = null;
		instanceOf = null;
		getValueType = null;
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/clock"] = (function() {
	var $pkg = {}, $init, sync, js, time, sliceType, lastNow, lastSystemTime, currentFPS, currentTPS, lastUpdated, fpsCount, tpsCount, m, init, calcCountFromTPS, updateFPSAndTPS, Update, now;
	sync = $packages["sync"];
	js = $packages["syscall/js"];
	time = $packages["time"];
	sliceType = $sliceType($emptyInterface);
	init = function() {
		var _r, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = now(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		n = _r;
		lastNow = n;
		lastSystemTime = n;
		lastUpdated = n;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f._r = _r; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	calcCountFromTPS = function(tps, now$1) {
		var count, diff, now$1, syncWithSystemClock, tps, x, x$1, x$2, x$3;
		if ((tps.$high === 0 && tps.$low === 0)) {
			return 0;
		}
		if ((tps.$high < 0 || (tps.$high === 0 && tps.$low < 0))) {
			$panic(new $String("clock: tps must >= 0"));
		}
		diff = new $Int64(now$1.$high - lastSystemTime.$high, now$1.$low - lastSystemTime.$low);
		if ((diff.$high < 0 || (diff.$high === 0 && diff.$low < 0))) {
			return 0;
		}
		count = 0;
		syncWithSystemClock = false;
		if ((diff.$high > 0 || (diff.$high === 0 && diff.$low > 83333333))) {
			syncWithSystemClock = true;
		} else {
			count = (((x = $div64($mul64(diff, tps), new $Int64(0, 1000000000), false), x.$low + ((x.$high >> 31) * 4294967296)) >> 0));
		}
		if ((count === 0) && (x$1 = $div64($div64(new $Int64(0, 1000000000), tps, false), new $Int64(0, 2), false), (x$1.$high < diff.$high || (x$1.$high === diff.$high && x$1.$low < diff.$low)))) {
			count = 1;
		}
		if ((count === 2) && (x$2 = $div64($mul64($div64(new $Int64(0, 1000000000), tps, false), new $Int64(0, 3)), new $Int64(0, 2), false), (x$2.$high > diff.$high || (x$2.$high === diff.$high && x$2.$low > diff.$low)))) {
			count = 1;
		}
		if (syncWithSystemClock) {
			lastSystemTime = now$1;
		} else {
			lastSystemTime = (x$3 = $div64($mul64((new $Int64(0, count)), new $Int64(0, 1000000000)), tps, false), new $Int64(lastSystemTime.$high + x$3.$high, lastSystemTime.$low + x$3.$low));
		}
		return count;
	};
	updateFPSAndTPS = function(now$1, count) {
		var count, now$1, x, x$1;
		fpsCount = fpsCount + (1) >> 0;
		tpsCount = tpsCount + (count) >> 0;
		if ((now$1.$high < lastUpdated.$high || (now$1.$high === lastUpdated.$high && now$1.$low < lastUpdated.$low))) {
			$panic(new $String("clock: lastUpdated must be older than now"));
		}
		if ((x = ((x$1 = new $Int64(now$1.$high - lastUpdated.$high, now$1.$low - lastUpdated.$low), new time.Duration(x$1.$high, x$1.$low))), (0 > x.$high || (0 === x.$high && 1000000000 > x.$low)))) {
			return;
		}
		currentFPS = (fpsCount) * 1e+09 / ($flatten64(new $Int64(now$1.$high - lastUpdated.$high, now$1.$low - lastUpdated.$low)));
		currentTPS = (tpsCount) * 1e+09 / ($flatten64(new $Int64(now$1.$high - lastUpdated.$high, now$1.$low - lastUpdated.$low)));
		lastUpdated = now$1;
		fpsCount = 0;
		tpsCount = 0;
	};
	Update = function(tps) {
		var _r, c, n, tps, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; n = $f.n; tps = $f.tps; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = m.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(m, "Unlock"), []]);
		_r = now(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		n = _r;
		if ((lastNow.$high > n.$high || (lastNow.$high === n.$high && lastNow.$low > n.$low))) {
			$panic(new $String("clock: lastNow must be older than n"));
		}
		lastNow = n;
		c = 0;
		if (tps === -1) {
			c = 1;
		} else if (tps > 0) {
			c = calcCountFromTPS((new $Int64(0, tps)), n);
		}
		updateFPSAndTPS(n, c);
		$s = -1; return c;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return 0; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Update }; } $f._r = _r; $f.c = c; $f.n = n; $f.tps = tps; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.Update = Update;
	now = function() {
		var _r, _r$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = $clone($clone(js.Global(), js.Value).Get("performance"), js.Value).Call("now", new sliceType([])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = $clone(_r, js.Value).Float(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return (new $Int64(0, _r$1 * 1e+06));
		/* */ } return; } if ($f === undefined) { $f = { $blk: now }; } $f._r = _r; $f._r$1 = _r$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = sync.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		lastNow = new $Int64(0, 0);
		lastSystemTime = new $Int64(0, 0);
		currentFPS = 0;
		currentTPS = 0;
		lastUpdated = new $Int64(0, 0);
		m = new sync.Mutex.ptr(0, 0);
		fpsCount = 0;
		tpsCount = 0;
		$r = init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["context"] = (function() {
	var $pkg = {}, $init, errors, fmt, reflect, sync, time, Context, emptyCtx, ptrType, structType, ptrType$1, chanType, background, todo, closedchan, init;
	errors = $packages["errors"];
	fmt = $packages["fmt"];
	reflect = $packages["reflect"];
	sync = $packages["sync"];
	time = $packages["time"];
	Context = $pkg.Context = $newType(8, $kindInterface, "context.Context", true, "context", true, null);
	emptyCtx = $pkg.emptyCtx = $newType(4, $kindInt, "context.emptyCtx", true, "context", false, null);
	ptrType = $ptrType(emptyCtx);
	structType = $structType("", []);
	ptrType$1 = $ptrType(time.Location);
	chanType = $chanType(structType, false, true);
	$ptrType(emptyCtx).prototype.Deadline = function() {
		var deadline, ok;
		deadline = new time.Time.ptr(new $Uint64(0, 0), new $Int64(0, 0), ptrType$1.nil);
		ok = false;
		return [deadline, ok];
	};
	$ptrType(emptyCtx).prototype.Done = function() {
		return $chanNil;
	};
	$ptrType(emptyCtx).prototype.Err = function() {
		return $ifaceNil;
	};
	$ptrType(emptyCtx).prototype.Value = function(key) {
		var key;
		return $ifaceNil;
	};
	$ptrType(emptyCtx).prototype.String = function() {
		var _1, e;
		e = this;
		_1 = e;
		if (_1 === (background)) {
			return "context.Background";
		} else if (_1 === (todo)) {
			return "context.TODO";
		}
		return "unknown empty Context";
	};
	init = function() {
		$close(closedchan);
	};
	ptrType.methods = [{prop: "Deadline", name: "Deadline", pkg: "", typ: $funcType([], [time.Time, $Bool], false)}, {prop: "Done", name: "Done", pkg: "", typ: $funcType([], [chanType], false)}, {prop: "Err", name: "Err", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Value", name: "Value", pkg: "", typ: $funcType([$emptyInterface], [$emptyInterface], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	Context.init([{prop: "Deadline", name: "Deadline", pkg: "", typ: $funcType([], [time.Time, $Bool], false)}, {prop: "Done", name: "Done", pkg: "", typ: $funcType([], [chanType], false)}, {prop: "Err", name: "Err", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Value", name: "Value", pkg: "", typ: $funcType([$emptyInterface], [$emptyInterface], false)}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = reflect.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.Canceled = errors.New("context canceled");
		background = $newDataPointer(0, ptrType);
		todo = $newDataPointer(0, ptrType);
		closedchan = new $Chan(structType, 0);
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/thread"] = (function() {
	var $pkg = {}, $init, context, Thread, funcType, structType, funcType$1, ptrType, chanType;
	context = $packages["context"];
	Thread = $pkg.Thread = $newType(0, $kindStruct, "thread.Thread", true, "github.com/hajimehoshi/ebiten/internal/thread", true, function(funcs_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.funcs = $chanNil;
			return;
		}
		this.funcs = funcs_;
	});
	funcType = $funcType([], [], false);
	structType = $structType("", []);
	funcType$1 = $funcType([], [$error], false);
	ptrType = $ptrType(Thread);
	chanType = $chanType(funcType, false, false);
	Thread.ptr.prototype.Loop = function(context$1) {
		var _r, _r$1, _selection, context$1, f, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _selection = $f._selection; context$1 = $f.context$1; f = $f.f; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		/* while (true) { */ case 1:
			_r = context$1.Done(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r$1 = $select([[t.funcs], [_r]]); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_selection = _r$1;
			/* */ if (_selection[0] === 0) { $s = 5; continue; }
			/* */ if (_selection[0] === 1) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_selection[0] === 0) { */ case 5:
				f = _selection[1][0];
				$r = f(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 7; continue;
			/* } else if (_selection[0] === 1) { */ case 6:
				/* break loop; */ $s = 2; continue s;
			/* } */ case 7:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Thread.ptr.prototype.Loop }; } $f._r = _r; $f._r$1 = _r$1; $f._selection = _selection; $f.context$1 = context$1; $f.f = f; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Thread.prototype.Loop = function(context$1) { return this.$val.Loop(context$1); };
	Thread.ptr.prototype.Call = function(f) {
		var _r, ch, err, f, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; ch = $f.ch; err = $f.err; f = $f.f; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ch = [ch];
		err = [err];
		f = [f];
		t = this;
		ch[0] = new $Chan(structType, 0);
		err[0] = $ifaceNil;
		$r = $send(t.funcs, (function(ch, err, f) { return function $b() {
			var _r, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r = f[0](); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			err[0] = _r;
			$close(ch[0]);
			$s = -1; return;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch, err, f)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r = $recv(ch[0]); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r[0];
		$s = -1; return err[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Thread.ptr.prototype.Call }; } $f._r = _r; $f.ch = ch; $f.err = err; $f.f = f; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Thread.prototype.Call = function(f) { return this.$val.Call(f); };
	ptrType.methods = [{prop: "Loop", name: "Loop", pkg: "", typ: $funcType([context.Context], [], false)}, {prop: "Call", name: "Call", pkg: "", typ: $funcType([funcType$1], [$error], false)}];
	Thread.init("github.com/hajimehoshi/ebiten/internal/thread", [{prop: "funcs", name: "funcs", embedded: false, exported: false, typ: chanType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = context.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/driver"] = (function() {
	var $pkg = {}, $init, errors, fmt, affine, thread, image, CompositeMode, Operation, Filter, Address, GamepadButton, Graphics, Image, VDirection, Input, Key, MouseButton, UIContext, sliceType, ptrType, ptrType$1, sliceType$1, sliceType$2, sliceType$3, sliceType$4, sliceType$5, funcType;
	errors = $packages["errors"];
	fmt = $packages["fmt"];
	affine = $packages["github.com/hajimehoshi/ebiten/internal/affine"];
	thread = $packages["github.com/hajimehoshi/ebiten/internal/thread"];
	image = $packages["image"];
	CompositeMode = $pkg.CompositeMode = $newType(4, $kindInt, "driver.CompositeMode", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	Operation = $pkg.Operation = $newType(4, $kindInt, "driver.Operation", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	Filter = $pkg.Filter = $newType(4, $kindInt, "driver.Filter", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	Address = $pkg.Address = $newType(4, $kindInt, "driver.Address", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	GamepadButton = $pkg.GamepadButton = $newType(4, $kindInt, "driver.GamepadButton", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	Graphics = $pkg.Graphics = $newType(8, $kindInterface, "driver.Graphics", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	Image = $pkg.Image = $newType(8, $kindInterface, "driver.Image", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	VDirection = $pkg.VDirection = $newType(4, $kindInt, "driver.VDirection", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	Input = $pkg.Input = $newType(8, $kindInterface, "driver.Input", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	Key = $pkg.Key = $newType(4, $kindInt, "driver.Key", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	MouseButton = $pkg.MouseButton = $newType(4, $kindInt, "driver.MouseButton", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	UIContext = $pkg.UIContext = $newType(8, $kindInterface, "driver.UIContext", true, "github.com/hajimehoshi/ebiten/internal/driver", true, null);
	sliceType = $sliceType($emptyInterface);
	ptrType = $ptrType(affine.ColorM);
	ptrType$1 = $ptrType(thread.Thread);
	sliceType$1 = $sliceType($Float32);
	sliceType$2 = $sliceType($Uint16);
	sliceType$3 = $sliceType($Uint8);
	sliceType$4 = $sliceType($Int);
	sliceType$5 = $sliceType($Int32);
	funcType = $funcType([], [], false);
	CompositeMode.prototype.Operations = function() {
		var _1, _r, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, c, dst, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$18 = $f._tmp$18; _tmp$19 = $f._tmp$19; _tmp$2 = $f._tmp$2; _tmp$20 = $f._tmp$20; _tmp$21 = $f._tmp$21; _tmp$22 = $f._tmp$22; _tmp$23 = $f._tmp$23; _tmp$24 = $f._tmp$24; _tmp$25 = $f._tmp$25; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; c = $f.c; dst = $f.dst; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		src = 0;
		dst = 0;
		c = this.$val;
			_1 = c;
			/* */ if (_1 === (0)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ if (_1 === (4)) { $s = 6; continue; }
			/* */ if (_1 === (5)) { $s = 7; continue; }
			/* */ if (_1 === (6)) { $s = 8; continue; }
			/* */ if (_1 === (7)) { $s = 9; continue; }
			/* */ if (_1 === (8)) { $s = 10; continue; }
			/* */ if (_1 === (9)) { $s = 11; continue; }
			/* */ if (_1 === (10)) { $s = 12; continue; }
			/* */ if (_1 === (11)) { $s = 13; continue; }
			/* */ if (_1 === (12)) { $s = 14; continue; }
			/* */ $s = 15; continue;
			/* if (_1 === (0)) { */ case 2:
				_tmp = 1;
				_tmp$1 = 4;
				src = _tmp;
				dst = _tmp$1;
				$s = -1; return [src, dst];
			/* } else if (_1 === (1)) { */ case 3:
				_tmp$2 = 0;
				_tmp$3 = 0;
				src = _tmp$2;
				dst = _tmp$3;
				$s = -1; return [src, dst];
			/* } else if (_1 === (2)) { */ case 4:
				_tmp$4 = 1;
				_tmp$5 = 0;
				src = _tmp$4;
				dst = _tmp$5;
				$s = -1; return [src, dst];
			/* } else if (_1 === (3)) { */ case 5:
				_tmp$6 = 0;
				_tmp$7 = 1;
				src = _tmp$6;
				dst = _tmp$7;
				$s = -1; return [src, dst];
			/* } else if (_1 === (4)) { */ case 6:
				_tmp$8 = 5;
				_tmp$9 = 1;
				src = _tmp$8;
				dst = _tmp$9;
				$s = -1; return [src, dst];
			/* } else if (_1 === (5)) { */ case 7:
				_tmp$10 = 3;
				_tmp$11 = 0;
				src = _tmp$10;
				dst = _tmp$11;
				$s = -1; return [src, dst];
			/* } else if (_1 === (6)) { */ case 8:
				_tmp$12 = 0;
				_tmp$13 = 2;
				src = _tmp$12;
				dst = _tmp$13;
				$s = -1; return [src, dst];
			/* } else if (_1 === (7)) { */ case 9:
				_tmp$14 = 5;
				_tmp$15 = 0;
				src = _tmp$14;
				dst = _tmp$15;
				$s = -1; return [src, dst];
			/* } else if (_1 === (8)) { */ case 10:
				_tmp$16 = 0;
				_tmp$17 = 4;
				src = _tmp$16;
				dst = _tmp$17;
				$s = -1; return [src, dst];
			/* } else if (_1 === (9)) { */ case 11:
				_tmp$18 = 3;
				_tmp$19 = 4;
				src = _tmp$18;
				dst = _tmp$19;
				$s = -1; return [src, dst];
			/* } else if (_1 === (10)) { */ case 12:
				_tmp$20 = 5;
				_tmp$21 = 2;
				src = _tmp$20;
				dst = _tmp$21;
				$s = -1; return [src, dst];
			/* } else if (_1 === (11)) { */ case 13:
				_tmp$22 = 5;
				_tmp$23 = 4;
				src = _tmp$22;
				dst = _tmp$23;
				$s = -1; return [src, dst];
			/* } else if (_1 === (12)) { */ case 14:
				_tmp$24 = 1;
				_tmp$25 = 1;
				src = _tmp$24;
				dst = _tmp$25;
				$s = -1; return [src, dst];
			/* } else { */ case 15:
				_r = fmt.Sprintf("graphics: invalid composite mode: %d", new sliceType([new CompositeMode(c)])); /* */ $s = 17; case 17: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$panic(new $String(_r));
			/* } */ case 16:
		case 1:
		$s = -1; return [src, dst];
		/* */ } return; } if ($f === undefined) { $f = { $blk: CompositeMode.prototype.Operations }; } $f._1 = _1; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$18 = _tmp$18; $f._tmp$19 = _tmp$19; $f._tmp$2 = _tmp$2; $f._tmp$20 = _tmp$20; $f._tmp$21 = _tmp$21; $f._tmp$22 = _tmp$22; $f._tmp$23 = _tmp$23; $f._tmp$24 = _tmp$24; $f._tmp$25 = _tmp$25; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f.c = c; $f.dst = dst; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(CompositeMode).prototype.Operations = function() { return new CompositeMode(this.$get()).Operations(); };
	CompositeMode.methods = [{prop: "Operations", name: "Operations", pkg: "", typ: $funcType([], [Operation, Operation], false)}];
	Graphics.init([{prop: "Begin", name: "Begin", pkg: "", typ: $funcType([], [], false)}, {prop: "Draw", name: "Draw", pkg: "", typ: $funcType([$Int, $Int, CompositeMode, ptrType, Filter, Address], [$error], false)}, {prop: "End", name: "End", pkg: "", typ: $funcType([], [], false)}, {prop: "Flush", name: "Flush", pkg: "", typ: $funcType([], [], false)}, {prop: "HasHighPrecisionFloat", name: "HasHighPrecisionFloat", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "IsGL", name: "IsGL", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "MaxImageSize", name: "MaxImageSize", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NeedsRestoring", name: "NeedsRestoring", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "NewImage", name: "NewImage", pkg: "", typ: $funcType([$Int, $Int], [Image, $error], false)}, {prop: "NewScreenFramebufferImage", name: "NewScreenFramebufferImage", pkg: "", typ: $funcType([$Int, $Int], [Image, $error], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [$error], false)}, {prop: "SetThread", name: "SetThread", pkg: "", typ: $funcType([ptrType$1], [], false)}, {prop: "SetVertices", name: "SetVertices", pkg: "", typ: $funcType([sliceType$1, sliceType$2], [], false)}, {prop: "SetVsyncEnabled", name: "SetVsyncEnabled", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetWindow", name: "SetWindow", pkg: "", typ: $funcType([$Uintptr], [], false)}, {prop: "VDirection", name: "VDirection", pkg: "", typ: $funcType([], [VDirection], false)}]);
	Image.init([{prop: "Dispose", name: "Dispose", pkg: "", typ: $funcType([], [], false)}, {prop: "IsInvalidated", name: "IsInvalidated", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Pixels", name: "Pixels", pkg: "", typ: $funcType([], [sliceType$3, $error], false)}, {prop: "ReplacePixels", name: "ReplacePixels", pkg: "", typ: $funcType([sliceType$3, $Int, $Int, $Int, $Int], [], false)}, {prop: "SetAsDestination", name: "SetAsDestination", pkg: "", typ: $funcType([], [], false)}, {prop: "SetAsSource", name: "SetAsSource", pkg: "", typ: $funcType([], [], false)}]);
	Input.init([{prop: "CursorPosition", name: "CursorPosition", pkg: "", typ: $funcType([], [$Int, $Int], false)}, {prop: "GamepadAxis", name: "GamepadAxis", pkg: "", typ: $funcType([$Int, $Int], [$Float64], false)}, {prop: "GamepadAxisNum", name: "GamepadAxisNum", pkg: "", typ: $funcType([$Int], [$Int], false)}, {prop: "GamepadButtonNum", name: "GamepadButtonNum", pkg: "", typ: $funcType([$Int], [$Int], false)}, {prop: "GamepadIDs", name: "GamepadIDs", pkg: "", typ: $funcType([], [sliceType$4], false)}, {prop: "IsGamepadButtonPressed", name: "IsGamepadButtonPressed", pkg: "", typ: $funcType([$Int, GamepadButton], [$Bool], false)}, {prop: "IsKeyPressed", name: "IsKeyPressed", pkg: "", typ: $funcType([Key], [$Bool], false)}, {prop: "IsMouseButtonPressed", name: "IsMouseButtonPressed", pkg: "", typ: $funcType([MouseButton], [$Bool], false)}, {prop: "ResetForFrame", name: "ResetForFrame", pkg: "", typ: $funcType([], [], false)}, {prop: "RuneBuffer", name: "RuneBuffer", pkg: "", typ: $funcType([], [sliceType$5], false)}, {prop: "TouchIDs", name: "TouchIDs", pkg: "", typ: $funcType([], [sliceType$4], false)}, {prop: "TouchPosition", name: "TouchPosition", pkg: "", typ: $funcType([$Int], [$Int, $Int], false)}, {prop: "Wheel", name: "Wheel", pkg: "", typ: $funcType([], [$Float64, $Float64], false)}]);
	UIContext.init([{prop: "ResumeAudio", name: "ResumeAudio", pkg: "", typ: $funcType([], [], false)}, {prop: "SetSize", name: "SetSize", pkg: "", typ: $funcType([$Int, $Int, $Float64], [], false)}, {prop: "SuspendAudio", name: "SuspendAudio", pkg: "", typ: $funcType([], [], false)}, {prop: "Update", name: "Update", pkg: "", typ: $funcType([funcType], [$error], false)}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = affine.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = thread.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = image.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.RegularTermination = errors.New("regular termination");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/graphics"] = (function() {
	var $pkg = {}, $init, sliceType, quadIndices, InternalImageSize, PutQuadVertices, QuadIndices;
	sliceType = $sliceType($Uint16);
	InternalImageSize = function(x) {
		var r, x, y;
		if (x <= 0) {
			$panic(new $String("graphics: x must be positive"));
		}
		if (x < 16) {
			return 16;
		}
		r = 1;
		while (true) {
			if (!(r < x)) { break; }
			r = (y = (1), y < 32 ? (r << y) : 0) >> 0;
		}
		return r;
	};
	$pkg.InternalImageSize = InternalImageSize;
	PutQuadVertices = function(dst, putter, sx0, sy0, sx1, sy1, a, b, c, d, tx, ty, cr, cg, cb, ca) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, a, ax, b, by, c, ca, cb, cg, cr, cx, d, dst, dy, putter, sx0, sx1, sy0, sy1, tx, ty, u0, u1, v0, v1, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; a = $f.a; ax = $f.ax; b = $f.b; by = $f.by; c = $f.c; ca = $f.ca; cb = $f.cb; cg = $f.cg; cr = $f.cr; cx = $f.cx; d = $f.d; dst = $f.dst; dy = $f.dy; putter = $f.putter; sx0 = $f.sx0; sx1 = $f.sx1; sy0 = $f.sy0; sy1 = $f.sy1; tx = $f.tx; ty = $f.ty; u0 = $f.u0; u1 = $f.u1; v0 = $f.v0; v1 = $f.v1; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = ((sx1 - sx0 >> 0));
		y = ((sy1 - sy0 >> 0));
		_tmp = $fround(a * x);
		_tmp$1 = $fround(b * y);
		_tmp$2 = $fround(c * x);
		_tmp$3 = $fround(d * y);
		ax = _tmp;
		by = _tmp$1;
		cx = _tmp$2;
		dy = _tmp$3;
		_tmp$4 = (sx0);
		_tmp$5 = (sy0);
		_tmp$6 = (sx1);
		_tmp$7 = (sy1);
		u0 = _tmp$4;
		v0 = _tmp$5;
		u1 = _tmp$6;
		v1 = _tmp$7;
		$r = putter.PutVertex($subslice(dst, 0, 12), tx, ty, u0, v0, u0, v0, u1, v1, cr, cg, cb, ca); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = putter.PutVertex($subslice(dst, 12, 24), $fround(ax + tx), $fround(cx + ty), u1, v0, u0, v0, u1, v1, cr, cg, cb, ca); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = putter.PutVertex($subslice(dst, 24, 36), $fround(by + tx), $fround(dy + ty), u0, v1, u0, v0, u1, v1, cr, cg, cb, ca); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = putter.PutVertex($subslice(dst, 36, 48), $fround($fround(ax + by) + tx), $fround($fround(cx + dy) + ty), u1, v1, u0, v0, u1, v1, cr, cg, cb, ca); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: PutQuadVertices }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f.a = a; $f.ax = ax; $f.b = b; $f.by = by; $f.c = c; $f.ca = ca; $f.cb = cb; $f.cg = cg; $f.cr = cr; $f.cx = cx; $f.d = d; $f.dst = dst; $f.dy = dy; $f.putter = putter; $f.sx0 = sx0; $f.sx1 = sx1; $f.sy0 = sy0; $f.sy1 = sy1; $f.tx = tx; $f.ty = ty; $f.u0 = u0; $f.u1 = u1; $f.v0 = v0; $f.v1 = v1; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.PutQuadVertices = PutQuadVertices;
	QuadIndices = function() {
		return quadIndices;
	};
	$pkg.QuadIndices = QuadIndices;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		quadIndices = new sliceType([0, 1, 2, 1, 2, 3]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/graphicscommand"] = (function() {
	var $pkg = {}, $init, fmt, affine, driver, graphics, command, size, commandQueue, drawTrianglesCommand, replacePixelsCommand, copyPixelsCommand, pixelsCommand, disposeCommand, newImageCommand, newScreenFramebufferImageCommand, lastCommand, Image, sliceType, sliceType$1, sliceType$2, sliceType$3, sliceType$4, ptrType, ptrType$1, sliceType$5, ptrType$2, ptrType$3, ptrType$4, ptrType$5, ptrType$6, ptrType$7, ptrType$8, ptrType$9, theGraphicsDriver, theCommandQueue, SetGraphicsDriver, NeedsRestoring, Error, FlushCommands, ResetGraphicsDriverState, recordLog, NewImage, NewScreenFramebufferImage;
	fmt = $packages["fmt"];
	affine = $packages["github.com/hajimehoshi/ebiten/internal/affine"];
	driver = $packages["github.com/hajimehoshi/ebiten/internal/driver"];
	graphics = $packages["github.com/hajimehoshi/ebiten/internal/graphics"];
	command = $pkg.command = $newType(8, $kindInterface, "graphicscommand.command", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, null);
	size = $pkg.size = $newType(0, $kindStruct, "graphicscommand.size", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, function(width_, height_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.width = 0;
			this.height = 0;
			return;
		}
		this.width = width_;
		this.height = height_;
	});
	commandQueue = $pkg.commandQueue = $newType(0, $kindStruct, "graphicscommand.commandQueue", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, function(commands_, vertices_, nvertices_, srcSizes_, indices_, nindices_, tmpNumIndices_, nextIndex_, err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.commands = sliceType.nil;
			this.vertices = sliceType$1.nil;
			this.nvertices = 0;
			this.srcSizes = sliceType$2.nil;
			this.indices = sliceType$3.nil;
			this.nindices = 0;
			this.tmpNumIndices = 0;
			this.nextIndex = 0;
			this.err = $ifaceNil;
			return;
		}
		this.commands = commands_;
		this.vertices = vertices_;
		this.nvertices = nvertices_;
		this.srcSizes = srcSizes_;
		this.indices = indices_;
		this.nindices = nindices_;
		this.tmpNumIndices = tmpNumIndices_;
		this.nextIndex = nextIndex_;
		this.err = err_;
	});
	drawTrianglesCommand = $pkg.drawTrianglesCommand = $newType(0, $kindStruct, "graphicscommand.drawTrianglesCommand", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, function(dst_, src_, nvertices_, nindices_, color_, mode_, filter_, address_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.dst = ptrType.nil;
			this.src = ptrType.nil;
			this.nvertices = 0;
			this.nindices = 0;
			this.color = ptrType$1.nil;
			this.mode = 0;
			this.filter = 0;
			this.address = 0;
			return;
		}
		this.dst = dst_;
		this.src = src_;
		this.nvertices = nvertices_;
		this.nindices = nindices_;
		this.color = color_;
		this.mode = mode_;
		this.filter = filter_;
		this.address = address_;
	});
	replacePixelsCommand = $pkg.replacePixelsCommand = $newType(0, $kindStruct, "graphicscommand.replacePixelsCommand", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, function(dst_, pixels_, x_, y_, width_, height_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.dst = ptrType.nil;
			this.pixels = sliceType$5.nil;
			this.x = 0;
			this.y = 0;
			this.width = 0;
			this.height = 0;
			return;
		}
		this.dst = dst_;
		this.pixels = pixels_;
		this.x = x_;
		this.y = y_;
		this.width = width_;
		this.height = height_;
	});
	copyPixelsCommand = $pkg.copyPixelsCommand = $newType(0, $kindStruct, "graphicscommand.copyPixelsCommand", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, function(dst_, src_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.dst = ptrType.nil;
			this.src = ptrType.nil;
			return;
		}
		this.dst = dst_;
		this.src = src_;
	});
	pixelsCommand = $pkg.pixelsCommand = $newType(0, $kindStruct, "graphicscommand.pixelsCommand", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, function(result_, img_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.result = sliceType$5.nil;
			this.img = ptrType.nil;
			return;
		}
		this.result = result_;
		this.img = img_;
	});
	disposeCommand = $pkg.disposeCommand = $newType(0, $kindStruct, "graphicscommand.disposeCommand", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, function(target_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.target = ptrType.nil;
			return;
		}
		this.target = target_;
	});
	newImageCommand = $pkg.newImageCommand = $newType(0, $kindStruct, "graphicscommand.newImageCommand", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, function(result_, width_, height_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.result = ptrType.nil;
			this.width = 0;
			this.height = 0;
			return;
		}
		this.result = result_;
		this.width = width_;
		this.height = height_;
	});
	newScreenFramebufferImageCommand = $pkg.newScreenFramebufferImageCommand = $newType(0, $kindStruct, "graphicscommand.newScreenFramebufferImageCommand", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, function(result_, width_, height_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.result = ptrType.nil;
			this.width = 0;
			this.height = 0;
			return;
		}
		this.result = result_;
		this.width = width_;
		this.height = height_;
	});
	lastCommand = $pkg.lastCommand = $newType(4, $kindInt, "graphicscommand.lastCommand", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", false, null);
	Image = $pkg.Image = $newType(0, $kindStruct, "graphicscommand.Image", true, "github.com/hajimehoshi/ebiten/internal/graphicscommand", true, function(image_, width_, height_, internalWidth_, internalHeight_, screen_, lastCommand_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.image = $ifaceNil;
			this.width = 0;
			this.height = 0;
			this.internalWidth = 0;
			this.internalHeight = 0;
			this.screen = false;
			this.lastCommand = 0;
			return;
		}
		this.image = image_;
		this.width = width_;
		this.height = height_;
		this.internalWidth = internalWidth_;
		this.internalHeight = internalHeight_;
		this.screen = screen_;
		this.lastCommand = lastCommand_;
	});
	sliceType = $sliceType(command);
	sliceType$1 = $sliceType($Float32);
	sliceType$2 = $sliceType(size);
	sliceType$3 = $sliceType($Uint16);
	sliceType$4 = $sliceType($emptyInterface);
	ptrType = $ptrType(Image);
	ptrType$1 = $ptrType(affine.ColorM);
	sliceType$5 = $sliceType($Uint8);
	ptrType$2 = $ptrType(commandQueue);
	ptrType$3 = $ptrType(drawTrianglesCommand);
	ptrType$4 = $ptrType(replacePixelsCommand);
	ptrType$5 = $ptrType(copyPixelsCommand);
	ptrType$6 = $ptrType(pixelsCommand);
	ptrType$7 = $ptrType(disposeCommand);
	ptrType$8 = $ptrType(newImageCommand);
	ptrType$9 = $ptrType(newScreenFramebufferImageCommand);
	SetGraphicsDriver = function(driver$1) {
		var driver$1;
		theGraphicsDriver = driver$1;
	};
	$pkg.SetGraphicsDriver = SetGraphicsDriver;
	NeedsRestoring = function() {
		var _r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if ($interfaceIsEqual(theGraphicsDriver, $ifaceNil)) {
			$s = -1; return true;
		}
		_r = theGraphicsDriver.NeedsRestoring(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NeedsRestoring }; } $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.NeedsRestoring = NeedsRestoring;
	commandQueue.ptr.prototype.appendVertices = function(vertices, width, height) {
		var _q, _q$1, _q$2, height, i, idx, n, q, vertices, width, x, x$1;
		q = this;
		if (q.vertices.$length < (q.nvertices + vertices.$length >> 0)) {
			n = (q.nvertices + vertices.$length >> 0) - q.vertices.$length >> 0;
			q.vertices = $appendSlice(q.vertices, $makeSlice(sliceType$1, n));
			q.srcSizes = $appendSlice(q.srcSizes, $makeSlice(sliceType$2, (_q = n / 12, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"))));
		}
		$copySlice($subslice(q.vertices, q.nvertices), vertices);
		i = 0;
		while (true) {
			if (!(i < (_q$1 = vertices.$length / 12, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")))) { break; }
			idx = (_q$2 = q.nvertices / 12, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero")) + i >> 0;
			(x = q.srcSizes, ((idx < 0 || idx >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + idx])).width = width;
			(x$1 = q.srcSizes, ((idx < 0 || idx >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + idx])).height = height;
			i = i + (1) >> 0;
		}
		q.nvertices = q.nvertices + (vertices.$length) >> 0;
	};
	commandQueue.prototype.appendVertices = function(vertices, width, height) { return this.$val.appendVertices(vertices, width, height); };
	commandQueue.ptr.prototype.appendIndices = function(indices, offset) {
		var _i, _ref, i, indices, n, offset, q, x, x$1;
		q = this;
		if (q.indices.$length < (q.nindices + indices.$length >> 0)) {
			n = (q.nindices + indices.$length >> 0) - q.indices.$length >> 0;
			q.indices = $appendSlice(q.indices, $makeSlice(sliceType$3, n));
		}
		_ref = indices;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			(x = q.indices, x$1 = q.nindices + i >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1] = (((i < 0 || i >= indices.$length) ? ($throwRuntimeError("index out of range"), undefined) : indices.$array[indices.$offset + i]) + offset << 16 >>> 16)));
			_i++;
		}
		q.nindices = q.nindices + (indices.$length) >> 0;
	};
	commandQueue.prototype.appendIndices = function(indices, offset) { return this.$val.appendIndices(indices, offset); };
	commandQueue.ptr.prototype.doEnqueueDrawTrianglesCommand = function(dst, src, nvertices, nindices, color, mode, filter, address, forceNewCommand) {
		var _r, _r$1, address, c, color, dst, filter, forceNewCommand, last, mode, nindices, nvertices, q, src, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; address = $f.address; c = $f.c; color = $f.color; dst = $f.dst; filter = $f.filter; forceNewCommand = $f.forceNewCommand; last = $f.last; mode = $f.mode; nindices = $f.nindices; nvertices = $f.nvertices; q = $f.q; src = $f.src; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		q = this;
		/* */ if (nindices > 65535) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (nindices > 65535) { */ case 1:
			_r = fmt.Sprintf("graphicscommand: nindices must be <= graphics.IndicesNum but not at doEnqueueDrawTrianglesCommand: nindices: %d, graphics.IndicesNum: %d", new sliceType$4([new $Int(nindices), new $Int(65535)])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$panic(new $String(_r));
		/* } */ case 2:
		/* */ if (!forceNewCommand && 0 < q.commands.$length) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!forceNewCommand && 0 < q.commands.$length) { */ case 4:
			last = (x = q.commands, x$1 = q.commands.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			_r$1 = last.CanMerge(dst, src, color, mode, filter, address); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (_r$1) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_r$1) { */ case 6:
				$r = last.AddNumVertices(nvertices); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$r = last.AddNumIndices(nindices); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return;
			/* } */ case 7:
		/* } */ case 5:
		c = new drawTrianglesCommand.ptr(dst, src, nvertices, nindices, color, mode, filter, address);
		q.commands = $append(q.commands, c);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: commandQueue.ptr.prototype.doEnqueueDrawTrianglesCommand }; } $f._r = _r; $f._r$1 = _r$1; $f.address = address; $f.c = c; $f.color = color; $f.dst = dst; $f.filter = filter; $f.forceNewCommand = forceNewCommand; $f.last = last; $f.mode = mode; $f.nindices = nindices; $f.nvertices = nvertices; $f.q = q; $f.src = src; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	commandQueue.prototype.doEnqueueDrawTrianglesCommand = function(dst, src, nvertices, nindices, color, mode, filter, address, forceNewCommand) { return this.$val.doEnqueueDrawTrianglesCommand(dst, src, nvertices, nindices, color, mode, filter, address, forceNewCommand); };
	commandQueue.ptr.prototype.EnqueueDrawTrianglesCommand = function(dst, src, vertices, indices, color, mode, filter, address) {
		var _q, _r, address, color, dst, filter, indices, mode, n, q, split, src, vertices, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; address = $f.address; color = $f.color; dst = $f.dst; filter = $f.filter; indices = $f.indices; mode = $f.mode; n = $f.n; q = $f.q; split = $f.split; src = $f.src; vertices = $f.vertices; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		q = this;
		/* */ if (indices.$length > 65535) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (indices.$length > 65535) { */ case 1:
			_r = fmt.Sprintf("graphicscommand: len(indices) must be <= graphics.IndicesNum but not at EnqueueDrawTrianglesCommand: len(indices): %d, graphics.IndicesNum: %d", new sliceType$4([new $Int(indices.$length), new $Int(65535)])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$panic(new $String(_r));
		/* } */ case 2:
		split = false;
		if ((q.tmpNumIndices + indices.$length >> 0) > 65535) {
			q.tmpNumIndices = 0;
			q.nextIndex = 0;
			split = true;
		}
		n = (_q = vertices.$length / 12, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		q.appendVertices(vertices, (graphics.InternalImageSize(src.width)), (graphics.InternalImageSize(src.height)));
		q.appendIndices(indices, ((q.nextIndex << 16 >>> 16)));
		q.nextIndex = q.nextIndex + (n) >> 0;
		q.tmpNumIndices = q.tmpNumIndices + (indices.$length) >> 0;
		$r = q.doEnqueueDrawTrianglesCommand(dst, src, vertices.$length, indices.$length, color, mode, filter, address, split); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: commandQueue.ptr.prototype.EnqueueDrawTrianglesCommand }; } $f._q = _q; $f._r = _r; $f.address = address; $f.color = color; $f.dst = dst; $f.filter = filter; $f.indices = indices; $f.mode = mode; $f.n = n; $f.q = q; $f.split = split; $f.src = src; $f.vertices = vertices; $f.$s = $s; $f.$r = $r; return $f;
	};
	commandQueue.prototype.EnqueueDrawTrianglesCommand = function(dst, src, vertices, indices, color, mode, filter, address) { return this.$val.EnqueueDrawTrianglesCommand(dst, src, vertices, indices, color, mode, filter, address); };
	commandQueue.ptr.prototype.Enqueue = function(command$1) {
		var command$1, q;
		q = this;
		q.commands = $append(q.commands, command$1);
	};
	commandQueue.prototype.Enqueue = function(command$1) { return this.$val.Enqueue(command$1); };
	commandQueue.ptr.prototype.Flush = function() {
		var _arg, _i, _i$1, _index, _index$1, _q, _r, _r$1, _r$10, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, c, c$1, err, es, i, indexOffset, nc, ne, nv, q, s, vs, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _i = $f._i; _i$1 = $f._i$1; _index = $f._index; _index$1 = $f._index$1; _q = $f._q; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; c = $f.c; c$1 = $f.c$1; err = $f.err; es = $f.es; i = $f.i; indexOffset = $f.indexOffset; nc = $f.nc; ne = $f.ne; nv = $f.nv; q = $f.q; s = $f.s; vs = $f.vs; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		q = this;
		if (!($interfaceIsEqual(q.err, $ifaceNil))) {
			$s = -1; return;
		}
		es = q.indices;
		vs = q.vertices;
		/* */ if (recordLog()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (recordLog()) { */ case 1:
			_r = fmt.Println(new sliceType$4([new $String("--")])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
		/* } */ case 2:
		_r$1 = theGraphicsDriver.HasHighPrecisionFloat(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (_r$1) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (_r$1) { */ case 4:
			i = 0;
			while (true) {
				if (!(i < (_q = q.nvertices / 12, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")))) { break; }
				s = $clone((x = q.srcSizes, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])), size);
				_index = ($imul(i, 12)) + 6 >> 0;
				((_index < 0 || _index >= vs.$length) ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + _index] = $fround(((_index < 0 || _index >= vs.$length) ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + _index]) - ($fround($fround(1 / s.width) * 0.001953125))));
				_index$1 = ($imul(i, 12)) + 7 >> 0;
				((_index$1 < 0 || _index$1 >= vs.$length) ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + _index$1] = $fround(((_index$1 < 0 || _index$1 >= vs.$length) ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + _index$1]) - ($fround($fround(1 / s.height) * 0.001953125))));
				i = i + (1) >> 0;
			}
		/* } */ case 5:
		$r = theGraphicsDriver.Begin(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* while (true) { */ case 8:
			/* if (!(q.commands.$length > 0)) { break; } */ if(!(q.commands.$length > 0)) { $s = 9; continue; }
			nv = 0;
			ne = 0;
			nc = 0;
			_ref = q.commands;
			_i = 0;
			/* while (true) { */ case 10:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 11; continue; }
				c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				_r$2 = c.NumIndices(); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				/* */ if (_r$2 > 65535) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (_r$2 > 65535) { */ case 12:
					_r$3 = c.NumIndices(); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					_arg = new $Int(_r$3);
					_r$4 = fmt.Sprintf("graphicscommand: c.NumIndices() must be <= graphics.IndicesNum but not at Flush: c.NumIndices(): %d, graphics.IndicesNum: %d", new sliceType$4([_arg, new $Int(65535)])); /* */ $s = 16; case 16: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					$panic(new $String(_r$4));
				/* } */ case 13:
				_r$5 = c.NumIndices(); /* */ $s = 19; case 19: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				/* */ if ((ne + _r$5 >> 0) > 65535) { $s = 17; continue; }
				/* */ $s = 18; continue;
				/* if ((ne + _r$5 >> 0) > 65535) { */ case 17:
					/* break; */ $s = 11; continue;
				/* } */ case 18:
				_r$6 = c.NumVertices(); /* */ $s = 20; case 20: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				nv = nv + (_r$6) >> 0;
				_r$7 = c.NumIndices(); /* */ $s = 21; case 21: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				ne = ne + (_r$7) >> 0;
				nc = nc + (1) >> 0;
				_i++;
			/* } */ $s = 10; continue; case 11:
			/* */ if (0 < ne) { $s = 22; continue; }
			/* */ $s = 23; continue;
			/* if (0 < ne) { */ case 22:
				$r = theGraphicsDriver.SetVertices($subslice(vs, 0, nv), $subslice(es, 0, ne)); /* */ $s = 24; case 24: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				es = $subslice(es, ne);
				vs = $subslice(vs, nv);
			/* } */ case 23:
			indexOffset = 0;
			_ref$1 = $subslice(q.commands, 0, nc);
			_i$1 = 0;
			/* while (true) { */ case 25:
				/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 26; continue; }
				c$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
				_r$8 = c$1.Exec(indexOffset); /* */ $s = 27; case 27: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				err = _r$8;
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					q.err = err;
					$s = -1; return;
				}
				/* */ if (recordLog()) { $s = 28; continue; }
				/* */ $s = 29; continue;
				/* if (recordLog()) { */ case 28:
					_r$9 = fmt.Printf("%s\n", new sliceType$4([c$1])); /* */ $s = 30; case 30: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
					_r$9;
				/* } */ case 29:
				_r$10 = c$1.NumIndices(); /* */ $s = 31; case 31: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
				indexOffset = indexOffset + (_r$10) >> 0;
				_i$1++;
			/* } */ $s = 25; continue; case 26:
			/* */ if (0 < nc) { $s = 32; continue; }
			/* */ $s = 33; continue;
			/* if (0 < nc) { */ case 32:
				$r = theGraphicsDriver.Flush(); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 33:
			q.commands = $subslice(q.commands, nc);
		/* } */ $s = 8; continue; case 9:
		$r = theGraphicsDriver.End(); /* */ $s = 35; case 35: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		q.commands = sliceType.nil;
		q.nvertices = 0;
		q.nindices = 0;
		q.tmpNumIndices = 0;
		q.nextIndex = 0;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: commandQueue.ptr.prototype.Flush }; } $f._arg = _arg; $f._i = _i; $f._i$1 = _i$1; $f._index = _index; $f._index$1 = _index$1; $f._q = _q; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f.c = c; $f.c$1 = c$1; $f.err = err; $f.es = es; $f.i = i; $f.indexOffset = indexOffset; $f.nc = nc; $f.ne = ne; $f.nv = nv; $f.q = q; $f.s = s; $f.vs = vs; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	commandQueue.prototype.Flush = function() { return this.$val.Flush(); };
	Error = function() {
		return theCommandQueue.err;
	};
	$pkg.Error = Error;
	FlushCommands = function() {
		var $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = theCommandQueue.Flush(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FlushCommands }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.FlushCommands = FlushCommands;
	drawTrianglesCommand.ptr.prototype.String = function() {
		var _r, c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = fmt.Sprintf("draw-triangles: dst: %p <- src: %p, colorm: %v, mode %d, filter: %d, address: %d", new sliceType$4([c.dst, c.src, c.color, new driver.CompositeMode(c.mode), new driver.Filter(c.filter), new driver.Address(c.address)])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: drawTrianglesCommand.ptr.prototype.String }; } $f._r = _r; $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	drawTrianglesCommand.prototype.String = function() { return this.$val.String(); };
	drawTrianglesCommand.ptr.prototype.Exec = function(indexOffset) {
		var _r, c, err, indexOffset, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; err = $f.err; indexOffset = $f.indexOffset; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		if (c.nindices === 0) {
			$s = -1; return $ifaceNil;
		}
		$r = c.dst.image.SetAsDestination(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = c.src.image.SetAsSource(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r = theGraphicsDriver.Draw(c.nindices, indexOffset, c.mode, c.color, c.filter, c.address); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: drawTrianglesCommand.ptr.prototype.Exec }; } $f._r = _r; $f.c = c; $f.err = err; $f.indexOffset = indexOffset; $f.$s = $s; $f.$r = $r; return $f;
	};
	drawTrianglesCommand.prototype.Exec = function(indexOffset) { return this.$val.Exec(indexOffset); };
	drawTrianglesCommand.ptr.prototype.NumVertices = function() {
		var c;
		c = this;
		return c.nvertices;
	};
	drawTrianglesCommand.prototype.NumVertices = function() { return this.$val.NumVertices(); };
	drawTrianglesCommand.ptr.prototype.NumIndices = function() {
		var c;
		c = this;
		return c.nindices;
	};
	drawTrianglesCommand.prototype.NumIndices = function() { return this.$val.NumIndices(); };
	drawTrianglesCommand.ptr.prototype.AddNumVertices = function(n) {
		var c, n;
		c = this;
		c.nvertices = c.nvertices + (n) >> 0;
	};
	drawTrianglesCommand.prototype.AddNumVertices = function(n) { return this.$val.AddNumVertices(n); };
	drawTrianglesCommand.ptr.prototype.AddNumIndices = function(n) {
		var c, n;
		c = this;
		c.nindices = c.nindices + (n) >> 0;
	};
	drawTrianglesCommand.prototype.AddNumIndices = function(n) { return this.$val.AddNumIndices(n); };
	drawTrianglesCommand.ptr.prototype.CanMerge = function(dst, src, color, mode, filter, address) {
		var address, c, color, dst, filter, mode, src;
		c = this;
		if (!(c.dst === dst)) {
			return false;
		}
		if (!(c.src === src)) {
			return false;
		}
		if (!c.color.Equals(color)) {
			return false;
		}
		if (!((c.mode === mode))) {
			return false;
		}
		if (!((c.filter === filter))) {
			return false;
		}
		if (!((c.address === address))) {
			return false;
		}
		return true;
	};
	drawTrianglesCommand.prototype.CanMerge = function(dst, src, color, mode, filter, address) { return this.$val.CanMerge(dst, src, color, mode, filter, address); };
	replacePixelsCommand.ptr.prototype.String = function() {
		var _r, c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = fmt.Sprintf("replace-pixels: dst: %p, x: %d, y: %d, width: %d, height: %d", new sliceType$4([c.dst, new $Int(c.x), new $Int(c.y), new $Int(c.width), new $Int(c.height)])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: replacePixelsCommand.ptr.prototype.String }; } $f._r = _r; $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	replacePixelsCommand.prototype.String = function() { return this.$val.String(); };
	replacePixelsCommand.ptr.prototype.Exec = function(indexOffset) {
		var c, indexOffset, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; c = $f.c; indexOffset = $f.indexOffset; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.dst.image.ReplacePixels(c.pixels, c.x, c.y, c.width, c.height); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: replacePixelsCommand.ptr.prototype.Exec }; } $f.c = c; $f.indexOffset = indexOffset; $f.$s = $s; $f.$r = $r; return $f;
	};
	replacePixelsCommand.prototype.Exec = function(indexOffset) { return this.$val.Exec(indexOffset); };
	replacePixelsCommand.ptr.prototype.NumVertices = function() {
		var c;
		c = this;
		return 0;
	};
	replacePixelsCommand.prototype.NumVertices = function() { return this.$val.NumVertices(); };
	replacePixelsCommand.ptr.prototype.NumIndices = function() {
		var c;
		c = this;
		return 0;
	};
	replacePixelsCommand.prototype.NumIndices = function() { return this.$val.NumIndices(); };
	replacePixelsCommand.ptr.prototype.AddNumVertices = function(n) {
		var c, n;
		c = this;
	};
	replacePixelsCommand.prototype.AddNumVertices = function(n) { return this.$val.AddNumVertices(n); };
	replacePixelsCommand.ptr.prototype.AddNumIndices = function(n) {
		var c, n;
		c = this;
	};
	replacePixelsCommand.prototype.AddNumIndices = function(n) { return this.$val.AddNumIndices(n); };
	replacePixelsCommand.ptr.prototype.CanMerge = function(dst, src, color, mode, filter, address) {
		var address, c, color, dst, filter, mode, src;
		c = this;
		return false;
	};
	replacePixelsCommand.prototype.CanMerge = function(dst, src, color, mode, filter, address) { return this.$val.CanMerge(dst, src, color, mode, filter, address); };
	copyPixelsCommand.ptr.prototype.String = function() {
		var _r, c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = fmt.Sprintf("copy-pixels: dst: %p <- src: %p", new sliceType$4([c.dst, c.src])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: copyPixelsCommand.ptr.prototype.String }; } $f._r = _r; $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	copyPixelsCommand.prototype.String = function() { return this.$val.String(); };
	copyPixelsCommand.ptr.prototype.Exec = function(indexOffset) {
		var _r, _r$1, _tuple, c, err, indexOffset, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; c = $f.c; err = $f.err; indexOffset = $f.indexOffset; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = c.src.image.Pixels(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		p = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		/* */ if (c.dst.width < c.src.width || c.dst.height < c.src.height) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (c.dst.width < c.src.width || c.dst.height < c.src.height) { */ case 2:
			_r$1 = fmt.Errorf("graphicscommand: the destination size (%d, %d) must include the source size (%d, %d)", new sliceType$4([new $Int(c.dst.width), new $Int(c.dst.height), new $Int(c.src.width), new $Int(c.src.height)])); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
		/* } */ case 3:
		$r = c.dst.image.ReplacePixels(p, 0, 0, c.src.width, c.src.height); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: copyPixelsCommand.ptr.prototype.Exec }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.c = c; $f.err = err; $f.indexOffset = indexOffset; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	copyPixelsCommand.prototype.Exec = function(indexOffset) { return this.$val.Exec(indexOffset); };
	copyPixelsCommand.ptr.prototype.NumVertices = function() {
		var c;
		c = this;
		return 0;
	};
	copyPixelsCommand.prototype.NumVertices = function() { return this.$val.NumVertices(); };
	copyPixelsCommand.ptr.prototype.NumIndices = function() {
		var c;
		c = this;
		return 0;
	};
	copyPixelsCommand.prototype.NumIndices = function() { return this.$val.NumIndices(); };
	copyPixelsCommand.ptr.prototype.AddNumVertices = function(n) {
		var c, n;
		c = this;
	};
	copyPixelsCommand.prototype.AddNumVertices = function(n) { return this.$val.AddNumVertices(n); };
	copyPixelsCommand.ptr.prototype.AddNumIndices = function(n) {
		var c, n;
		c = this;
	};
	copyPixelsCommand.prototype.AddNumIndices = function(n) { return this.$val.AddNumIndices(n); };
	copyPixelsCommand.ptr.prototype.CanMerge = function(dst, src, color, mode, filter, address) {
		var address, c, color, dst, filter, mode, src;
		c = this;
		return false;
	};
	copyPixelsCommand.prototype.CanMerge = function(dst, src, color, mode, filter, address) { return this.$val.CanMerge(dst, src, color, mode, filter, address); };
	pixelsCommand.ptr.prototype.Exec = function(indexOffset) {
		var _r, _tuple, c, err, indexOffset, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; c = $f.c; err = $f.err; indexOffset = $f.indexOffset; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = c.img.image.Pixels(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		p = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		c.result = p;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pixelsCommand.ptr.prototype.Exec }; } $f._r = _r; $f._tuple = _tuple; $f.c = c; $f.err = err; $f.indexOffset = indexOffset; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	pixelsCommand.prototype.Exec = function(indexOffset) { return this.$val.Exec(indexOffset); };
	pixelsCommand.ptr.prototype.String = function() {
		var _r, c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = fmt.Sprintf("pixels: img: %p", new sliceType$4([c.img])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: pixelsCommand.ptr.prototype.String }; } $f._r = _r; $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	pixelsCommand.prototype.String = function() { return this.$val.String(); };
	pixelsCommand.ptr.prototype.NumVertices = function() {
		var c;
		c = this;
		return 0;
	};
	pixelsCommand.prototype.NumVertices = function() { return this.$val.NumVertices(); };
	pixelsCommand.ptr.prototype.NumIndices = function() {
		var c;
		c = this;
		return 0;
	};
	pixelsCommand.prototype.NumIndices = function() { return this.$val.NumIndices(); };
	pixelsCommand.ptr.prototype.AddNumVertices = function(n) {
		var c, n;
		c = this;
	};
	pixelsCommand.prototype.AddNumVertices = function(n) { return this.$val.AddNumVertices(n); };
	pixelsCommand.ptr.prototype.AddNumIndices = function(n) {
		var c, n;
		c = this;
	};
	pixelsCommand.prototype.AddNumIndices = function(n) { return this.$val.AddNumIndices(n); };
	pixelsCommand.ptr.prototype.CanMerge = function(dst, src, color, mode, filter, address) {
		var address, c, color, dst, filter, mode, src;
		c = this;
		return false;
	};
	pixelsCommand.prototype.CanMerge = function(dst, src, color, mode, filter, address) { return this.$val.CanMerge(dst, src, color, mode, filter, address); };
	disposeCommand.ptr.prototype.String = function() {
		var _r, c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = fmt.Sprintf("dispose: target: %p", new sliceType$4([c.target])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: disposeCommand.ptr.prototype.String }; } $f._r = _r; $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	disposeCommand.prototype.String = function() { return this.$val.String(); };
	disposeCommand.ptr.prototype.Exec = function(indexOffset) {
		var c, indexOffset, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; c = $f.c; indexOffset = $f.indexOffset; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.target.image.Dispose(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: disposeCommand.ptr.prototype.Exec }; } $f.c = c; $f.indexOffset = indexOffset; $f.$s = $s; $f.$r = $r; return $f;
	};
	disposeCommand.prototype.Exec = function(indexOffset) { return this.$val.Exec(indexOffset); };
	disposeCommand.ptr.prototype.NumVertices = function() {
		var c;
		c = this;
		return 0;
	};
	disposeCommand.prototype.NumVertices = function() { return this.$val.NumVertices(); };
	disposeCommand.ptr.prototype.NumIndices = function() {
		var c;
		c = this;
		return 0;
	};
	disposeCommand.prototype.NumIndices = function() { return this.$val.NumIndices(); };
	disposeCommand.ptr.prototype.AddNumVertices = function(n) {
		var c, n;
		c = this;
	};
	disposeCommand.prototype.AddNumVertices = function(n) { return this.$val.AddNumVertices(n); };
	disposeCommand.ptr.prototype.AddNumIndices = function(n) {
		var c, n;
		c = this;
	};
	disposeCommand.prototype.AddNumIndices = function(n) { return this.$val.AddNumIndices(n); };
	disposeCommand.ptr.prototype.CanMerge = function(dst, src, color, mode, filter, address) {
		var address, c, color, dst, filter, mode, src;
		c = this;
		return false;
	};
	disposeCommand.prototype.CanMerge = function(dst, src, color, mode, filter, address) { return this.$val.CanMerge(dst, src, color, mode, filter, address); };
	newImageCommand.ptr.prototype.String = function() {
		var _r, c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = fmt.Sprintf("new-image: result: %p, width: %d, height: %d", new sliceType$4([c.result, new $Int(c.width), new $Int(c.height)])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: newImageCommand.ptr.prototype.String }; } $f._r = _r; $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	newImageCommand.prototype.String = function() { return this.$val.String(); };
	newImageCommand.ptr.prototype.Exec = function(indexOffset) {
		var _r, _tuple, c, err, i, indexOffset, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; c = $f.c; err = $f.err; i = $f.i; indexOffset = $f.indexOffset; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = theGraphicsDriver.NewImage(c.width, c.height); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		i = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		c.result.image = i;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: newImageCommand.ptr.prototype.Exec }; } $f._r = _r; $f._tuple = _tuple; $f.c = c; $f.err = err; $f.i = i; $f.indexOffset = indexOffset; $f.$s = $s; $f.$r = $r; return $f;
	};
	newImageCommand.prototype.Exec = function(indexOffset) { return this.$val.Exec(indexOffset); };
	newImageCommand.ptr.prototype.NumVertices = function() {
		var c;
		c = this;
		return 0;
	};
	newImageCommand.prototype.NumVertices = function() { return this.$val.NumVertices(); };
	newImageCommand.ptr.prototype.NumIndices = function() {
		var c;
		c = this;
		return 0;
	};
	newImageCommand.prototype.NumIndices = function() { return this.$val.NumIndices(); };
	newImageCommand.ptr.prototype.AddNumVertices = function(n) {
		var c, n;
		c = this;
	};
	newImageCommand.prototype.AddNumVertices = function(n) { return this.$val.AddNumVertices(n); };
	newImageCommand.ptr.prototype.AddNumIndices = function(n) {
		var c, n;
		c = this;
	};
	newImageCommand.prototype.AddNumIndices = function(n) { return this.$val.AddNumIndices(n); };
	newImageCommand.ptr.prototype.CanMerge = function(dst, src, color, mode, filter, address) {
		var address, c, color, dst, filter, mode, src;
		c = this;
		return false;
	};
	newImageCommand.prototype.CanMerge = function(dst, src, color, mode, filter, address) { return this.$val.CanMerge(dst, src, color, mode, filter, address); };
	newScreenFramebufferImageCommand.ptr.prototype.String = function() {
		var _r, c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = fmt.Sprintf("new-screen-framebuffer-image: result: %p, width: %d, height: %d", new sliceType$4([c.result, new $Int(c.width), new $Int(c.height)])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: newScreenFramebufferImageCommand.ptr.prototype.String }; } $f._r = _r; $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	newScreenFramebufferImageCommand.prototype.String = function() { return this.$val.String(); };
	newScreenFramebufferImageCommand.ptr.prototype.Exec = function(indexOffset) {
		var _r, _tuple, c, err, indexOffset, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; c = $f.c; err = $f.err; indexOffset = $f.indexOffset; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		err = $ifaceNil;
		_r = theGraphicsDriver.NewScreenFramebufferImage(c.width, c.height); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		c.result.image = _tuple[0];
		err = _tuple[1];
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: newScreenFramebufferImageCommand.ptr.prototype.Exec }; } $f._r = _r; $f._tuple = _tuple; $f.c = c; $f.err = err; $f.indexOffset = indexOffset; $f.$s = $s; $f.$r = $r; return $f;
	};
	newScreenFramebufferImageCommand.prototype.Exec = function(indexOffset) { return this.$val.Exec(indexOffset); };
	newScreenFramebufferImageCommand.ptr.prototype.NumVertices = function() {
		var c;
		c = this;
		return 0;
	};
	newScreenFramebufferImageCommand.prototype.NumVertices = function() { return this.$val.NumVertices(); };
	newScreenFramebufferImageCommand.ptr.prototype.NumIndices = function() {
		var c;
		c = this;
		return 0;
	};
	newScreenFramebufferImageCommand.prototype.NumIndices = function() { return this.$val.NumIndices(); };
	newScreenFramebufferImageCommand.ptr.prototype.AddNumVertices = function(n) {
		var c, n;
		c = this;
	};
	newScreenFramebufferImageCommand.prototype.AddNumVertices = function(n) { return this.$val.AddNumVertices(n); };
	newScreenFramebufferImageCommand.ptr.prototype.AddNumIndices = function(n) {
		var c, n;
		c = this;
	};
	newScreenFramebufferImageCommand.prototype.AddNumIndices = function(n) { return this.$val.AddNumIndices(n); };
	newScreenFramebufferImageCommand.ptr.prototype.CanMerge = function(dst, src, color, mode, filter, address) {
		var address, c, color, dst, filter, mode, src;
		c = this;
		return false;
	};
	newScreenFramebufferImageCommand.prototype.CanMerge = function(dst, src, color, mode, filter, address) { return this.$val.CanMerge(dst, src, color, mode, filter, address); };
	ResetGraphicsDriverState = function() {
		var _r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = theGraphicsDriver.Reset(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ResetGraphicsDriverState }; } $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ResetGraphicsDriverState = ResetGraphicsDriverState;
	recordLog = function() {
		return false;
	};
	NewImage = function(width, height) {
		var c, height, i, width;
		i = new Image.ptr($ifaceNil, width, height, graphics.InternalImageSize(width), graphics.InternalImageSize(height), false, 0);
		c = new newImageCommand.ptr(i, width, height);
		theCommandQueue.Enqueue(c);
		return i;
	};
	$pkg.NewImage = NewImage;
	NewScreenFramebufferImage = function(width, height) {
		var c, height, i, width;
		i = new Image.ptr($ifaceNil, width, height, graphics.InternalImageSize(width), graphics.InternalImageSize(height), true, 0);
		c = new newScreenFramebufferImageCommand.ptr(i, width, height);
		theCommandQueue.Enqueue(c);
		return i;
	};
	$pkg.NewScreenFramebufferImage = NewScreenFramebufferImage;
	Image.ptr.prototype.Dispose = function() {
		var c, i;
		i = this;
		c = new disposeCommand.ptr(i);
		theCommandQueue.Enqueue(c);
	};
	Image.prototype.Dispose = function() { return this.$val.Dispose(); };
	Image.ptr.prototype.Size = function() {
		var i;
		i = this;
		return [i.width, i.height];
	};
	Image.prototype.Size = function() { return this.$val.Size(); };
	Image.ptr.prototype.InternalSize = function() {
		var i;
		i = this;
		return [i.internalWidth, i.internalHeight];
	};
	Image.prototype.InternalSize = function() { return this.$val.InternalSize(); };
	Image.ptr.prototype.DrawTriangles = function(src, vertices, indices, clr, mode, filter, address) {
		var address, clr, filter, i, indices, mode, src, vertices, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; address = $f.address; clr = $f.clr; filter = $f.filter; i = $f.i; indices = $f.indices; mode = $f.mode; src = $f.src; vertices = $f.vertices; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (src.screen) {
			$panic(new $String("graphicscommand: the screen image cannot be the rendering source"));
		}
		if (i.lastCommand === 0) {
			if (!i.screen && !((mode === 1))) {
				$panic(new $String("graphicscommand: the image must be cleared first"));
			}
		}
		$r = theCommandQueue.EnqueueDrawTrianglesCommand(i, src, vertices, indices, clr, mode, filter, address); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if ((i.lastCommand === 0) && !i.screen) {
			i.lastCommand = 1;
		} else {
			i.lastCommand = 2;
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.DrawTriangles }; } $f.address = address; $f.clr = clr; $f.filter = filter; $f.i = i; $f.indices = indices; $f.mode = mode; $f.src = src; $f.vertices = vertices; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.DrawTriangles = function(src, vertices, indices, clr, mode, filter, address) { return this.$val.DrawTriangles(src, vertices, indices, clr, mode, filter, address); };
	Image.ptr.prototype.Pixels = function() {
		var c, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; c = $f.c; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		c = new pixelsCommand.ptr(sliceType$5.nil, i);
		theCommandQueue.Enqueue(c);
		$r = theCommandQueue.Flush(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return c.result;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.Pixels }; } $f.c = c; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.Pixels = function() { return this.$val.Pixels(); };
	Image.ptr.prototype.ReplacePixels = function(p, x, y, width, height) {
		var c, height, i, p, pixels, width, x, y;
		i = this;
		if (i.lastCommand === 2) {
			if (!((x === 0)) || !((y === 0)) || !((i.width === width)) || !((i.height === height))) {
				$panic(new $String("graphicscommand: ReplacePixels for a part after DrawTriangles is forbidden"));
			}
		}
		pixels = $makeSlice(sliceType$5, p.$length);
		$copySlice(pixels, p);
		c = new replacePixelsCommand.ptr(i, pixels, x, y, width, height);
		theCommandQueue.Enqueue(c);
		i.lastCommand = 3;
	};
	Image.prototype.ReplacePixels = function(p, x, y, width, height) { return this.$val.ReplacePixels(p, x, y, width, height); };
	Image.ptr.prototype.CopyPixels = function(src) {
		var c, i, src;
		i = this;
		if (i.lastCommand === 2) {
			if (!((i.width === src.width)) || !((i.height === src.height))) {
				$panic(new $String("graphicscommand: Copy for a part after DrawTriangles is forbidden"));
			}
		}
		c = new copyPixelsCommand.ptr(i, src);
		theCommandQueue.Enqueue(c);
		i.lastCommand = 3;
	};
	Image.prototype.CopyPixels = function(src) { return this.$val.CopyPixels(src); };
	Image.ptr.prototype.IsInvalidated = function() {
		var _r, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (i.screen) {
			$panic(new $String("graphicscommand: IsInvalidated cannot be called on the screen image"));
		}
		if ($interfaceIsEqual(i.image, $ifaceNil)) {
			$s = -1; return false;
		}
		_r = i.image.IsInvalidated(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.IsInvalidated }; } $f._r = _r; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.IsInvalidated = function() { return this.$val.IsInvalidated(); };
	ptrType$2.methods = [{prop: "appendVertices", name: "appendVertices", pkg: "github.com/hajimehoshi/ebiten/internal/graphicscommand", typ: $funcType([sliceType$1, $Float32, $Float32], [], false)}, {prop: "appendIndices", name: "appendIndices", pkg: "github.com/hajimehoshi/ebiten/internal/graphicscommand", typ: $funcType([sliceType$3, $Uint16], [], false)}, {prop: "doEnqueueDrawTrianglesCommand", name: "doEnqueueDrawTrianglesCommand", pkg: "github.com/hajimehoshi/ebiten/internal/graphicscommand", typ: $funcType([ptrType, ptrType, $Int, $Int, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address, $Bool], [], false)}, {prop: "EnqueueDrawTrianglesCommand", name: "EnqueueDrawTrianglesCommand", pkg: "", typ: $funcType([ptrType, ptrType, sliceType$1, sliceType$3, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address], [], false)}, {prop: "Enqueue", name: "Enqueue", pkg: "", typ: $funcType([command], [], false)}, {prop: "Flush", name: "Flush", pkg: "", typ: $funcType([], [], false)}];
	ptrType$3.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Exec", name: "Exec", pkg: "", typ: $funcType([$Int], [$error], false)}, {prop: "NumVertices", name: "NumVertices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIndices", name: "NumIndices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "AddNumVertices", name: "AddNumVertices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "AddNumIndices", name: "AddNumIndices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "CanMerge", name: "CanMerge", pkg: "", typ: $funcType([ptrType, ptrType, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address], [$Bool], false)}];
	ptrType$4.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Exec", name: "Exec", pkg: "", typ: $funcType([$Int], [$error], false)}, {prop: "NumVertices", name: "NumVertices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIndices", name: "NumIndices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "AddNumVertices", name: "AddNumVertices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "AddNumIndices", name: "AddNumIndices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "CanMerge", name: "CanMerge", pkg: "", typ: $funcType([ptrType, ptrType, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address], [$Bool], false)}];
	ptrType$5.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Exec", name: "Exec", pkg: "", typ: $funcType([$Int], [$error], false)}, {prop: "NumVertices", name: "NumVertices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIndices", name: "NumIndices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "AddNumVertices", name: "AddNumVertices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "AddNumIndices", name: "AddNumIndices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "CanMerge", name: "CanMerge", pkg: "", typ: $funcType([ptrType, ptrType, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address], [$Bool], false)}];
	ptrType$6.methods = [{prop: "Exec", name: "Exec", pkg: "", typ: $funcType([$Int], [$error], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "NumVertices", name: "NumVertices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIndices", name: "NumIndices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "AddNumVertices", name: "AddNumVertices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "AddNumIndices", name: "AddNumIndices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "CanMerge", name: "CanMerge", pkg: "", typ: $funcType([ptrType, ptrType, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address], [$Bool], false)}];
	ptrType$7.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Exec", name: "Exec", pkg: "", typ: $funcType([$Int], [$error], false)}, {prop: "NumVertices", name: "NumVertices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIndices", name: "NumIndices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "AddNumVertices", name: "AddNumVertices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "AddNumIndices", name: "AddNumIndices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "CanMerge", name: "CanMerge", pkg: "", typ: $funcType([ptrType, ptrType, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address], [$Bool], false)}];
	ptrType$8.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Exec", name: "Exec", pkg: "", typ: $funcType([$Int], [$error], false)}, {prop: "NumVertices", name: "NumVertices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIndices", name: "NumIndices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "AddNumVertices", name: "AddNumVertices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "AddNumIndices", name: "AddNumIndices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "CanMerge", name: "CanMerge", pkg: "", typ: $funcType([ptrType, ptrType, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address], [$Bool], false)}];
	ptrType$9.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Exec", name: "Exec", pkg: "", typ: $funcType([$Int], [$error], false)}, {prop: "NumVertices", name: "NumVertices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumIndices", name: "NumIndices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "AddNumVertices", name: "AddNumVertices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "AddNumIndices", name: "AddNumIndices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "CanMerge", name: "CanMerge", pkg: "", typ: $funcType([ptrType, ptrType, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address], [$Bool], false)}];
	ptrType.methods = [{prop: "Dispose", name: "Dispose", pkg: "", typ: $funcType([], [], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int, $Int], false)}, {prop: "InternalSize", name: "InternalSize", pkg: "", typ: $funcType([], [$Int, $Int], false)}, {prop: "DrawTriangles", name: "DrawTriangles", pkg: "", typ: $funcType([ptrType, sliceType$1, sliceType$3, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address], [], false)}, {prop: "Pixels", name: "Pixels", pkg: "", typ: $funcType([], [sliceType$5], false)}, {prop: "ReplacePixels", name: "ReplacePixels", pkg: "", typ: $funcType([sliceType$5, $Int, $Int, $Int, $Int], [], false)}, {prop: "CopyPixels", name: "CopyPixels", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "IsInvalidated", name: "IsInvalidated", pkg: "", typ: $funcType([], [$Bool], false)}];
	command.init([{prop: "AddNumIndices", name: "AddNumIndices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "AddNumVertices", name: "AddNumVertices", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "CanMerge", name: "CanMerge", pkg: "", typ: $funcType([ptrType, ptrType, ptrType$1, driver.CompositeMode, driver.Filter, driver.Address], [$Bool], false)}, {prop: "Exec", name: "Exec", pkg: "", typ: $funcType([$Int], [$error], false)}, {prop: "NumIndices", name: "NumIndices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "NumVertices", name: "NumVertices", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}]);
	size.init("github.com/hajimehoshi/ebiten/internal/graphicscommand", [{prop: "width", name: "width", embedded: false, exported: false, typ: $Float32, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Float32, tag: ""}]);
	commandQueue.init("github.com/hajimehoshi/ebiten/internal/graphicscommand", [{prop: "commands", name: "commands", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "vertices", name: "vertices", embedded: false, exported: false, typ: sliceType$1, tag: ""}, {prop: "nvertices", name: "nvertices", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "srcSizes", name: "srcSizes", embedded: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "indices", name: "indices", embedded: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "nindices", name: "nindices", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "tmpNumIndices", name: "tmpNumIndices", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "nextIndex", name: "nextIndex", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "err", name: "err", embedded: false, exported: false, typ: $error, tag: ""}]);
	drawTrianglesCommand.init("github.com/hajimehoshi/ebiten/internal/graphicscommand", [{prop: "dst", name: "dst", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "src", name: "src", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "nvertices", name: "nvertices", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "nindices", name: "nindices", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "color", name: "color", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "mode", name: "mode", embedded: false, exported: false, typ: driver.CompositeMode, tag: ""}, {prop: "filter", name: "filter", embedded: false, exported: false, typ: driver.Filter, tag: ""}, {prop: "address", name: "address", embedded: false, exported: false, typ: driver.Address, tag: ""}]);
	replacePixelsCommand.init("github.com/hajimehoshi/ebiten/internal/graphicscommand", [{prop: "dst", name: "dst", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "pixels", name: "pixels", embedded: false, exported: false, typ: sliceType$5, tag: ""}, {prop: "x", name: "x", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "y", name: "y", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}]);
	copyPixelsCommand.init("github.com/hajimehoshi/ebiten/internal/graphicscommand", [{prop: "dst", name: "dst", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "src", name: "src", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	pixelsCommand.init("github.com/hajimehoshi/ebiten/internal/graphicscommand", [{prop: "result", name: "result", embedded: false, exported: false, typ: sliceType$5, tag: ""}, {prop: "img", name: "img", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	disposeCommand.init("github.com/hajimehoshi/ebiten/internal/graphicscommand", [{prop: "target", name: "target", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	newImageCommand.init("github.com/hajimehoshi/ebiten/internal/graphicscommand", [{prop: "result", name: "result", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}]);
	newScreenFramebufferImageCommand.init("github.com/hajimehoshi/ebiten/internal/graphicscommand", [{prop: "result", name: "result", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}]);
	Image.init("github.com/hajimehoshi/ebiten/internal/graphicscommand", [{prop: "image", name: "image", embedded: false, exported: false, typ: driver.Image, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "internalWidth", name: "internalWidth", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "internalHeight", name: "internalHeight", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "screen", name: "screen", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "lastCommand", name: "lastCommand", embedded: false, exported: false, typ: lastCommand, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = fmt.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = affine.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = driver.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = graphics.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		theGraphicsDriver = $ifaceNil;
		theCommandQueue = new commandQueue.ptr(sliceType.nil, sliceType$1.nil, 0, sliceType$2.nil, sliceType$3.nil, 0, 0, 0, $ifaceNil);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/jsutil"] = (function() {
	var $pkg = {}, $init, js, sliceType, sliceType$1, Uint8ArrayToSlice, SliceToTypedArray;
	js = $packages["syscall/js"];
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType($emptyInterface);
	Uint8ArrayToSlice = function(value) {
		var _r, a, s, value, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; s = $f.s; value = $f.value; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = $makeSlice(sliceType, $clone($clone(value, js.Value).Get("byteLength"), js.Value).Int());
		a = $clone(js.TypedArrayOf(s), js.TypedArray);
		_r = $clone(a.Value, js.Value).Call("set", new sliceType$1([new value.constructor.elem(value)])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		a.Release();
		$s = -1; return s;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Uint8ArrayToSlice }; } $f._r = _r; $f.a = a; $f.s = s; $f.value = value; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Uint8ArrayToSlice = Uint8ArrayToSlice;
	SliceToTypedArray = function(s) {
		var a, s;
		a = $clone(js.TypedArrayOf(s), js.TypedArray);
		return [a.Value, (function() {
			a.Release();
		})];
	};
	$pkg.SliceToTypedArray = SliceToTypedArray;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/web"] = (function() {
	var $pkg = {}, $init, runtime, strings, js, userAgent, IsGopherJS, IsBrowser, IsIOSSafari, IsAndroidChrome, IsMobileBrowser;
	runtime = $packages["runtime"];
	strings = $packages["strings"];
	js = $packages["syscall/js"];
	IsGopherJS = function() {
		return true;
	};
	$pkg.IsGopherJS = IsGopherJS;
	IsBrowser = function() {
		return true;
	};
	$pkg.IsBrowser = IsBrowser;
	IsIOSSafari = function() {
		if (!strings.Contains(userAgent, "iPhone")) {
			return false;
		}
		return true;
	};
	$pkg.IsIOSSafari = IsIOSSafari;
	IsAndroidChrome = function() {
		if (!strings.Contains(userAgent, "Android")) {
			return false;
		}
		if (!strings.Contains(userAgent, "Chrome")) {
			return false;
		}
		return true;
	};
	$pkg.IsAndroidChrome = IsAndroidChrome;
	IsMobileBrowser = function() {
		return IsIOSSafari() || IsAndroidChrome();
	};
	$pkg.IsMobileBrowser = IsMobileBrowser;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = runtime.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		userAgent = $clone($clone($clone(js.Global(), js.Value).Get("navigator"), js.Value).Get("userAgent"), js.Value).String();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["regexp/syntax"] = (function() {
	var $pkg = {}, $init, sort, strconv, strings, unicode, utf8, patchList, frag, compiler, Error, ErrorCode, Flags, parser, charGroup, ranges, Prog, InstOp, EmptyOp, Inst, Regexp, Op, sliceType, sliceType$1, sliceType$2, sliceType$3, ptrType, sliceType$4, ptrType$1, sliceType$5, arrayType, arrayType$1, ptrType$2, ptrType$3, ptrType$4, sliceType$6, ptrType$5, ptrType$6, ptrType$7, ptrType$8, anyRuneNotNL, anyRune, _Op_index_0, anyTable, code1, code2, code3, perlGroup, code4, code5, code6, code7, code8, code9, code10, code11, code12, code13, code14, code15, code16, code17, posixGroup, instOpNames, Compile, minFoldRune, repeatIsValid, cleanAlt, literalRegexp, Parse, isValidCaptureName, isCharClass, matchRune, mergeCharClass, unicodeTable, cleanClass, appendLiteral, appendRange, appendFoldedRange, appendClass, appendFoldedClass, appendNegatedClass, appendTable, appendNegatedTable, negateClass, checkUTF8, nextRune, isalnum, unhex, IsWordChar, bw, dumpProg, u32, dumpInst, writeRegexp, escape, simplify1;
	sort = $packages["sort"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	patchList = $pkg.patchList = $newType(4, $kindUint32, "syntax.patchList", true, "regexp/syntax", false, null);
	frag = $pkg.frag = $newType(0, $kindStruct, "syntax.frag", true, "regexp/syntax", false, function(i_, out_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.i = 0;
			this.out = 0;
			return;
		}
		this.i = i_;
		this.out = out_;
	});
	compiler = $pkg.compiler = $newType(0, $kindStruct, "syntax.compiler", true, "regexp/syntax", false, function(p_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.p = ptrType.nil;
			return;
		}
		this.p = p_;
	});
	Error = $pkg.Error = $newType(0, $kindStruct, "syntax.Error", true, "regexp/syntax", true, function(Code_, Expr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Code = "";
			this.Expr = "";
			return;
		}
		this.Code = Code_;
		this.Expr = Expr_;
	});
	ErrorCode = $pkg.ErrorCode = $newType(8, $kindString, "syntax.ErrorCode", true, "regexp/syntax", true, null);
	Flags = $pkg.Flags = $newType(2, $kindUint16, "syntax.Flags", true, "regexp/syntax", true, null);
	parser = $pkg.parser = $newType(0, $kindStruct, "syntax.parser", true, "regexp/syntax", false, function(flags_, stack_, free_, numCap_, wholeRegexp_, tmpClass_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.flags = 0;
			this.stack = sliceType$5.nil;
			this.free = ptrType$1.nil;
			this.numCap = 0;
			this.wholeRegexp = "";
			this.tmpClass = sliceType.nil;
			return;
		}
		this.flags = flags_;
		this.stack = stack_;
		this.free = free_;
		this.numCap = numCap_;
		this.wholeRegexp = wholeRegexp_;
		this.tmpClass = tmpClass_;
	});
	charGroup = $pkg.charGroup = $newType(0, $kindStruct, "syntax.charGroup", true, "regexp/syntax", false, function(sign_, class$1_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.sign = 0;
			this.class$1 = sliceType.nil;
			return;
		}
		this.sign = sign_;
		this.class$1 = class$1_;
	});
	ranges = $pkg.ranges = $newType(0, $kindStruct, "syntax.ranges", true, "regexp/syntax", false, function(p_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.p = ptrType$2.nil;
			return;
		}
		this.p = p_;
	});
	Prog = $pkg.Prog = $newType(0, $kindStruct, "syntax.Prog", true, "regexp/syntax", true, function(Inst_, Start_, NumCap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Inst = sliceType$4.nil;
			this.Start = 0;
			this.NumCap = 0;
			return;
		}
		this.Inst = Inst_;
		this.Start = Start_;
		this.NumCap = NumCap_;
	});
	InstOp = $pkg.InstOp = $newType(1, $kindUint8, "syntax.InstOp", true, "regexp/syntax", true, null);
	EmptyOp = $pkg.EmptyOp = $newType(1, $kindUint8, "syntax.EmptyOp", true, "regexp/syntax", true, null);
	Inst = $pkg.Inst = $newType(0, $kindStruct, "syntax.Inst", true, "regexp/syntax", true, function(Op_, Out_, Arg_, Rune_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Op = 0;
			this.Out = 0;
			this.Arg = 0;
			this.Rune = sliceType.nil;
			return;
		}
		this.Op = Op_;
		this.Out = Out_;
		this.Arg = Arg_;
		this.Rune = Rune_;
	});
	Regexp = $pkg.Regexp = $newType(0, $kindStruct, "syntax.Regexp", true, "regexp/syntax", true, function(Op_, Flags_, Sub_, Sub0_, Rune_, Rune0_, Min_, Max_, Cap_, Name_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Op = 0;
			this.Flags = 0;
			this.Sub = sliceType$5.nil;
			this.Sub0 = arrayType.zero();
			this.Rune = sliceType.nil;
			this.Rune0 = arrayType$1.zero();
			this.Min = 0;
			this.Max = 0;
			this.Cap = 0;
			this.Name = "";
			return;
		}
		this.Op = Op_;
		this.Flags = Flags_;
		this.Sub = Sub_;
		this.Sub0 = Sub0_;
		this.Rune = Rune_;
		this.Rune0 = Rune0_;
		this.Min = Min_;
		this.Max = Max_;
		this.Cap = Cap_;
		this.Name = Name_;
	});
	Op = $pkg.Op = $newType(1, $kindUint8, "syntax.Op", true, "regexp/syntax", true, null);
	sliceType = $sliceType($Int32);
	sliceType$1 = $sliceType(unicode.Range16);
	sliceType$2 = $sliceType(unicode.Range32);
	sliceType$3 = $sliceType($String);
	ptrType = $ptrType(Prog);
	sliceType$4 = $sliceType(Inst);
	ptrType$1 = $ptrType(Regexp);
	sliceType$5 = $sliceType(ptrType$1);
	arrayType = $arrayType(ptrType$1, 1);
	arrayType$1 = $arrayType($Int32, 2);
	ptrType$2 = $ptrType(sliceType);
	ptrType$3 = $ptrType(unicode.RangeTable);
	ptrType$4 = $ptrType(strings.Builder);
	sliceType$6 = $sliceType($Uint8);
	ptrType$5 = $ptrType(compiler);
	ptrType$6 = $ptrType(Error);
	ptrType$7 = $ptrType(parser);
	ptrType$8 = $ptrType(Inst);
	patchList.prototype.next = function(p) {
		var i, l, p, x, x$1;
		l = this.$val;
		i = (x = p.Inst, x$1 = l >>> 1 >>> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (((l & 1) >>> 0) === 0) {
			return ((i.Out >>> 0));
		}
		return ((i.Arg >>> 0));
	};
	$ptrType(patchList).prototype.next = function(p) { return new patchList(this.$get()).next(p); };
	patchList.prototype.patch = function(p, val) {
		var i, l, p, val, x, x$1;
		l = this.$val;
		while (true) {
			if (!(!((l === 0)))) { break; }
			i = (x = p.Inst, x$1 = l >>> 1 >>> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			if (((l & 1) >>> 0) === 0) {
				l = ((i.Out >>> 0));
				i.Out = val;
			} else {
				l = ((i.Arg >>> 0));
				i.Arg = val;
			}
		}
	};
	$ptrType(patchList).prototype.patch = function(p, val) { return new patchList(this.$get()).patch(p, val); };
	patchList.prototype.append = function(p, l2) {
		var i, l1, l2, last, next, p, x, x$1;
		l1 = this.$val;
		if (l1 === 0) {
			return l2;
		}
		if (l2 === 0) {
			return l1;
		}
		last = l1;
		while (true) {
			next = new patchList(last).next(p);
			if (next === 0) {
				break;
			}
			last = next;
		}
		i = (x = p.Inst, x$1 = last >>> 1 >>> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (((last & 1) >>> 0) === 0) {
			i.Out = ((l2 >>> 0));
		} else {
			i.Arg = ((l2 >>> 0));
		}
		return l1;
	};
	$ptrType(patchList).prototype.append = function(p, l2) { return new patchList(this.$get()).append(p, l2); };
	Compile = function(re) {
		var c, f, re;
		c = new compiler.ptr(ptrType.nil);
		c.init();
		f = $clone(c.compile(re), frag);
		new patchList(f.out).patch(c.p, c.inst(4).i);
		c.p.Start = ((f.i >> 0));
		return [c.p, $ifaceNil];
	};
	$pkg.Compile = Compile;
	compiler.ptr.prototype.init = function() {
		var c;
		c = this;
		c.p = new Prog.ptr(sliceType$4.nil, 0, 0);
		c.p.NumCap = 2;
		c.inst(5);
	};
	compiler.prototype.init = function() { return this.$val.init(); };
	compiler.ptr.prototype.compile = function(re) {
		var _1, _i, _i$1, _i$2, _ref, _ref$1, _ref$2, bra, c, f, f$1, f$2, f1, i, j, ket, re, sub, sub$1, sub$2, x, x$1, x$2, x$3;
		c = this;
		_1 = re.Op;
		if (_1 === (1)) {
			return c.fail();
		} else if (_1 === (2)) {
			return c.nop();
		} else if (_1 === (3)) {
			if (re.Rune.$length === 0) {
				return c.nop();
			}
			f = new frag.ptr(0, 0);
			_ref = re.Rune;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				j = _i;
				f1 = $clone(c.rune($subslice(re.Rune, j, (j + 1 >> 0)), re.Flags), frag);
				if (j === 0) {
					frag.copy(f, f1);
				} else {
					frag.copy(f, c.cat($clone(f, frag), $clone(f1, frag)));
				}
				_i++;
			}
			return f;
		} else if (_1 === (4)) {
			return c.rune(re.Rune, re.Flags);
		} else if (_1 === (5)) {
			return c.rune(anyRuneNotNL, 0);
		} else if (_1 === (6)) {
			return c.rune(anyRune, 0);
		} else if (_1 === (7)) {
			return c.empty(1);
		} else if (_1 === (8)) {
			return c.empty(2);
		} else if (_1 === (9)) {
			return c.empty(4);
		} else if (_1 === (10)) {
			return c.empty(8);
		} else if (_1 === (11)) {
			return c.empty(16);
		} else if (_1 === (12)) {
			return c.empty(32);
		} else if (_1 === (13)) {
			bra = $clone(c.cap((((re.Cap << 1 >> 0) >>> 0))), frag);
			sub = $clone(c.compile((x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]))), frag);
			ket = $clone(c.cap(((((re.Cap << 1 >> 0) | 1) >>> 0))), frag);
			return c.cat($clone(c.cat($clone(bra, frag), $clone(sub, frag)), frag), $clone(ket, frag));
		} else if (_1 === (14)) {
			return c.star($clone(c.compile((x$1 = re.Sub, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0]))), frag), !((((re.Flags & 32) >>> 0) === 0)));
		} else if (_1 === (15)) {
			return c.plus($clone(c.compile((x$2 = re.Sub, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0]))), frag), !((((re.Flags & 32) >>> 0) === 0)));
		} else if (_1 === (16)) {
			return c.quest($clone(c.compile((x$3 = re.Sub, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0]))), frag), !((((re.Flags & 32) >>> 0) === 0)));
		} else if (_1 === (18)) {
			if (re.Sub.$length === 0) {
				return c.nop();
			}
			f$1 = new frag.ptr(0, 0);
			_ref$1 = re.Sub;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.$length)) { break; }
				i = _i$1;
				sub$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
				if (i === 0) {
					frag.copy(f$1, c.compile(sub$1));
				} else {
					frag.copy(f$1, c.cat($clone(f$1, frag), $clone(c.compile(sub$1), frag)));
				}
				_i$1++;
			}
			return f$1;
		} else if (_1 === (19)) {
			f$2 = new frag.ptr(0, 0);
			_ref$2 = re.Sub;
			_i$2 = 0;
			while (true) {
				if (!(_i$2 < _ref$2.$length)) { break; }
				sub$2 = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
				frag.copy(f$2, c.alt($clone(f$2, frag), $clone(c.compile(sub$2), frag)));
				_i$2++;
			}
			return f$2;
		}
		$panic(new $String("regexp: unhandled case in compile"));
	};
	compiler.prototype.compile = function(re) { return this.$val.compile(re); };
	compiler.ptr.prototype.inst = function(op) {
		var c, f, op;
		c = this;
		f = new frag.ptr(((c.p.Inst.$length >>> 0)), 0);
		c.p.Inst = $append(c.p.Inst, new Inst.ptr(op, 0, 0, sliceType.nil));
		return f;
	};
	compiler.prototype.inst = function(op) { return this.$val.inst(op); };
	compiler.ptr.prototype.nop = function() {
		var c, f;
		c = this;
		f = $clone(c.inst(6), frag);
		f.out = (((f.i << 1 >>> 0) >>> 0));
		return f;
	};
	compiler.prototype.nop = function() { return this.$val.nop(); };
	compiler.ptr.prototype.fail = function() {
		var c;
		c = this;
		return new frag.ptr(0, 0);
	};
	compiler.prototype.fail = function() { return this.$val.fail(); };
	compiler.ptr.prototype.cap = function(arg) {
		var arg, c, f, x, x$1;
		c = this;
		f = $clone(c.inst(2), frag);
		f.out = (((f.i << 1 >>> 0) >>> 0));
		(x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Arg = arg;
		if (c.p.NumCap < (((arg >> 0)) + 1 >> 0)) {
			c.p.NumCap = ((arg >> 0)) + 1 >> 0;
		}
		return f;
	};
	compiler.prototype.cap = function(arg) { return this.$val.cap(arg); };
	compiler.ptr.prototype.cat = function(f1, f2) {
		var c, f1, f2;
		c = this;
		if ((f1.i === 0) || (f2.i === 0)) {
			return new frag.ptr(0, 0);
		}
		new patchList(f1.out).patch(c.p, f2.i);
		return new frag.ptr(f1.i, f2.out);
	};
	compiler.prototype.cat = function(f1, f2) { return this.$val.cat(f1, f2); };
	compiler.ptr.prototype.alt = function(f1, f2) {
		var c, f, f1, f2, i, x, x$1;
		c = this;
		if (f1.i === 0) {
			return f2;
		}
		if (f2.i === 0) {
			return f1;
		}
		f = $clone(c.inst(0), frag);
		i = (x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		i.Out = f1.i;
		i.Arg = f2.i;
		f.out = new patchList(f1.out).append(c.p, f2.out);
		return f;
	};
	compiler.prototype.alt = function(f1, f2) { return this.$val.alt(f1, f2); };
	compiler.ptr.prototype.quest = function(f1, nongreedy) {
		var c, f, f1, i, nongreedy, x, x$1;
		c = this;
		f = $clone(c.inst(0), frag);
		i = (x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (nongreedy) {
			i.Arg = f1.i;
			f.out = (((f.i << 1 >>> 0) >>> 0));
		} else {
			i.Out = f1.i;
			f.out = (((((f.i << 1 >>> 0) | 1) >>> 0) >>> 0));
		}
		f.out = new patchList(f.out).append(c.p, f1.out);
		return f;
	};
	compiler.prototype.quest = function(f1, nongreedy) { return this.$val.quest(f1, nongreedy); };
	compiler.ptr.prototype.star = function(f1, nongreedy) {
		var c, f, f1, i, nongreedy, x, x$1;
		c = this;
		f = $clone(c.inst(0), frag);
		i = (x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (nongreedy) {
			i.Arg = f1.i;
			f.out = (((f.i << 1 >>> 0) >>> 0));
		} else {
			i.Out = f1.i;
			f.out = (((((f.i << 1 >>> 0) | 1) >>> 0) >>> 0));
		}
		new patchList(f1.out).patch(c.p, f.i);
		return f;
	};
	compiler.prototype.star = function(f1, nongreedy) { return this.$val.star(f1, nongreedy); };
	compiler.ptr.prototype.plus = function(f1, nongreedy) {
		var c, f1, nongreedy;
		c = this;
		return new frag.ptr(f1.i, c.star($clone(f1, frag), nongreedy).out);
	};
	compiler.prototype.plus = function(f1, nongreedy) { return this.$val.plus(f1, nongreedy); };
	compiler.ptr.prototype.empty = function(op) {
		var c, f, op, x, x$1;
		c = this;
		f = $clone(c.inst(3), frag);
		(x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Arg = ((op >>> 0));
		f.out = (((f.i << 1 >>> 0) >>> 0));
		return f;
	};
	compiler.prototype.empty = function(op) { return this.$val.empty(op); };
	compiler.ptr.prototype.rune = function(r, flags) {
		var c, f, flags, i, r, x, x$1;
		c = this;
		f = $clone(c.inst(7), frag);
		i = (x = c.p.Inst, x$1 = f.i, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		i.Rune = r;
		flags = (flags & (1)) >>> 0;
		if (!((r.$length === 1)) || (unicode.SimpleFold((0 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 0])) === (0 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 0]))) {
			flags = (flags & ~(1)) << 16 >>> 16;
		}
		i.Arg = ((flags >>> 0));
		f.out = (((f.i << 1 >>> 0) >>> 0));
		if ((((flags & 1) >>> 0) === 0) && ((r.$length === 1) || (r.$length === 2) && ((0 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 0]) === (1 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 1])))) {
			i.Op = 8;
		} else if ((r.$length === 2) && ((0 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 0]) === 0) && ((1 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 1]) === 1114111)) {
			i.Op = 9;
		} else if ((r.$length === 4) && ((0 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 0]) === 0) && ((1 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 1]) === 9) && ((2 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 2]) === 11) && ((3 >= r.$length ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + 3]) === 1114111)) {
			i.Op = 10;
		}
		return f;
	};
	compiler.prototype.rune = function(r, flags) { return this.$val.rune(r, flags); };
	Op.prototype.String = function() {
		var i, x;
		i = this.$val;
		if (1 <= i && i <= 19) {
			i = i - (1) << 24 >>> 24;
			return $substring("NoMatchEmptyMatchLiteralCharClassAnyCharNotNLAnyCharBeginLineEndLineBeginTextEndTextWordBoundaryNoWordBoundaryCaptureStarPlusQuestRepeatConcatAlternate", ((i < 0 || i >= _Op_index_0.length) ? ($throwRuntimeError("index out of range"), undefined) : _Op_index_0[i]), (x = i + 1 << 24 >>> 24, ((x < 0 || x >= _Op_index_0.length) ? ($throwRuntimeError("index out of range"), undefined) : _Op_index_0[x])));
		} else if ((i === 128)) {
			return "opPseudo";
		} else {
			return "Op(" + strconv.FormatInt((new $Int64(0, i)), 10) + ")";
		}
	};
	$ptrType(Op).prototype.String = function() { return new Op(this.$get()).String(); };
	Error.ptr.prototype.Error = function() {
		var e;
		e = this;
		return "error parsing regexp: " + new ErrorCode(e.Code).String() + ": `" + e.Expr + "`";
	};
	Error.prototype.Error = function() { return this.$val.Error(); };
	ErrorCode.prototype.String = function() {
		var e;
		e = this.$val;
		return (e);
	};
	$ptrType(ErrorCode).prototype.String = function() { return new ErrorCode(this.$get()).String(); };
	parser.ptr.prototype.newRegexp = function(op) {
		var op, p, re;
		p = this;
		re = p.free;
		if (!(re === ptrType$1.nil)) {
			p.free = re.Sub0[0];
			Regexp.copy(re, new Regexp.ptr(0, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, ""));
		} else {
			re = new Regexp.ptr(0, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
		}
		re.Op = op;
		return re;
	};
	parser.prototype.newRegexp = function(op) { return this.$val.newRegexp(op); };
	parser.ptr.prototype.reuse = function(re) {
		var p, re;
		p = this;
		re.Sub0[0] = p.free;
		p.free = re;
	};
	parser.prototype.reuse = function(re) { return this.$val.reuse(re); };
	parser.ptr.prototype.push = function(re) {
		var p, re, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		p = this;
		if ((re.Op === 4) && (re.Rune.$length === 2) && ((x = re.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) === (x$1 = re.Rune, (1 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 1])))) {
			if (p.maybeConcat((x$16 = re.Rune, (0 >= x$16.$length ? ($throwRuntimeError("index out of range"), undefined) : x$16.$array[x$16.$offset + 0])), (p.flags & ~1) << 16 >>> 16)) {
				return ptrType$1.nil;
			}
			re.Op = 3;
			re.Rune = $subslice(re.Rune, 0, 1);
			re.Flags = (p.flags & ~1) << 16 >>> 16;
		} else if ((re.Op === 4) && (re.Rune.$length === 4) && ((x$2 = re.Rune, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0])) === (x$3 = re.Rune, (1 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 1]))) && ((x$4 = re.Rune, (2 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 2])) === (x$5 = re.Rune, (3 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 3]))) && (unicode.SimpleFold((x$6 = re.Rune, (0 >= x$6.$length ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + 0]))) === (x$7 = re.Rune, (2 >= x$7.$length ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + 2]))) && (unicode.SimpleFold((x$8 = re.Rune, (2 >= x$8.$length ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + 2]))) === (x$9 = re.Rune, (0 >= x$9.$length ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + 0]))) || (re.Op === 4) && (re.Rune.$length === 2) && (((x$10 = re.Rune, (0 >= x$10.$length ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + 0])) + 1 >> 0) === (x$11 = re.Rune, (1 >= x$11.$length ? ($throwRuntimeError("index out of range"), undefined) : x$11.$array[x$11.$offset + 1]))) && (unicode.SimpleFold((x$12 = re.Rune, (0 >= x$12.$length ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + 0]))) === (x$13 = re.Rune, (1 >= x$13.$length ? ($throwRuntimeError("index out of range"), undefined) : x$13.$array[x$13.$offset + 1]))) && (unicode.SimpleFold((x$14 = re.Rune, (1 >= x$14.$length ? ($throwRuntimeError("index out of range"), undefined) : x$14.$array[x$14.$offset + 1]))) === (x$15 = re.Rune, (0 >= x$15.$length ? ($throwRuntimeError("index out of range"), undefined) : x$15.$array[x$15.$offset + 0])))) {
			if (p.maybeConcat((x$17 = re.Rune, (0 >= x$17.$length ? ($throwRuntimeError("index out of range"), undefined) : x$17.$array[x$17.$offset + 0])), (p.flags | 1) >>> 0)) {
				return ptrType$1.nil;
			}
			re.Op = 3;
			re.Rune = $subslice(re.Rune, 0, 1);
			re.Flags = (p.flags | 1) >>> 0;
		} else {
			p.maybeConcat(-1, 0);
		}
		p.stack = $append(p.stack, re);
		return re;
	};
	parser.prototype.push = function(re) { return this.$val.push(re); };
	parser.ptr.prototype.maybeConcat = function(r, flags) {
		var flags, n, p, r, re1, re2, x, x$1, x$2, x$3, x$4;
		p = this;
		n = p.stack.$length;
		if (n < 2) {
			return false;
		}
		re1 = (x = p.stack, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		re2 = (x$2 = p.stack, x$3 = n - 2 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
		if (!((re1.Op === 3)) || !((re2.Op === 3)) || !((((re1.Flags & 1) >>> 0) === ((re2.Flags & 1) >>> 0)))) {
			return false;
		}
		re2.Rune = $appendSlice(re2.Rune, re1.Rune);
		if (r >= 0) {
			re1.Rune = $subslice(new sliceType(re1.Rune0), 0, 1);
			(x$4 = re1.Rune, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0] = r));
			re1.Flags = flags;
			return true;
		}
		p.stack = $subslice(p.stack, 0, (n - 1 >> 0));
		p.reuse(re1);
		return false;
	};
	parser.prototype.maybeConcat = function(r, flags) { return this.$val.maybeConcat(r, flags); };
	parser.ptr.prototype.newLiteral = function(r, flags) {
		var flags, p, r, re;
		p = this;
		re = p.newRegexp(3);
		re.Flags = flags;
		if (!((((flags & 1) >>> 0) === 0))) {
			r = minFoldRune(r);
		}
		re.Rune0[0] = r;
		re.Rune = $subslice(new sliceType(re.Rune0), 0, 1);
		return re;
	};
	parser.prototype.newLiteral = function(r, flags) { return this.$val.newLiteral(r, flags); };
	minFoldRune = function(r) {
		var min, r, r0;
		if (r < 65 || r > 125251) {
			return r;
		}
		min = r;
		r0 = r;
		r = unicode.SimpleFold(r);
		while (true) {
			if (!(!((r === r0)))) { break; }
			if (min > r) {
				min = r;
			}
			r = unicode.SimpleFold(r);
		}
		return min;
	};
	parser.ptr.prototype.literal = function(r) {
		var p, r;
		p = this;
		p.push(p.newLiteral(r, p.flags));
	};
	parser.prototype.literal = function(r) { return this.$val.literal(r); };
	parser.ptr.prototype.op = function(op) {
		var op, p, re;
		p = this;
		re = p.newRegexp(op);
		re.Flags = p.flags;
		return p.push(re);
	};
	parser.prototype.op = function(op) { return this.$val.op(op); };
	parser.ptr.prototype.repeat = function(op, min, max, before, after, lastRepeat) {
		var after, before, flags, lastRepeat, max, min, n, op, p, re, sub, x, x$1, x$2, x$3, x$4;
		p = this;
		flags = p.flags;
		if (!((((p.flags & 64) >>> 0) === 0))) {
			if (after.length > 0 && (after.charCodeAt(0) === 63)) {
				after = $substring(after, 1);
				flags = (flags ^ (32)) << 16 >>> 16;
			}
			if (!(lastRepeat === "")) {
				return ["", new Error.ptr("invalid nested repetition operator", $substring(lastRepeat, 0, (lastRepeat.length - after.length >> 0)))];
			}
		}
		n = p.stack.$length;
		if (n === 0) {
			return ["", new Error.ptr("missing argument to repetition operator", $substring(before, 0, (before.length - after.length >> 0)))];
		}
		sub = (x = p.stack, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (sub.Op >= 128) {
			return ["", new Error.ptr("missing argument to repetition operator", $substring(before, 0, (before.length - after.length >> 0)))];
		}
		re = p.newRegexp(op);
		re.Min = min;
		re.Max = max;
		re.Flags = flags;
		re.Sub = $subslice(new sliceType$5(re.Sub0), 0, 1);
		(x$2 = re.Sub, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0] = sub));
		(x$3 = p.stack, x$4 = n - 1 >> 0, ((x$4 < 0 || x$4 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + x$4] = re));
		if ((op === 17) && (min >= 2 || max >= 2) && !repeatIsValid(re, 1000)) {
			return ["", new Error.ptr("invalid repeat count", $substring(before, 0, (before.length - after.length >> 0)))];
		}
		return [after, $ifaceNil];
	};
	parser.prototype.repeat = function(op, min, max, before, after, lastRepeat) { return this.$val.repeat(op, min, max, before, after, lastRepeat); };
	repeatIsValid = function(re, n) {
		var _i, _q, _ref, m, n, re, sub;
		if (re.Op === 17) {
			m = re.Max;
			if (m === 0) {
				return true;
			}
			if (m < 0) {
				m = re.Min;
			}
			if (m > n) {
				return false;
			}
			if (m > 0) {
				n = (_q = n / (m), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			}
		}
		_ref = re.Sub;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			sub = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!repeatIsValid(sub, n)) {
				return false;
			}
			_i++;
		}
		return true;
	};
	parser.ptr.prototype.concat = function() {
		var _r, _r$1, i, p, subs, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; i = $f.i; p = $f.p; subs = $f.subs; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		p.maybeConcat(-1, 0);
		i = p.stack.$length;
		while (true) {
			if (!(i > 0 && (x = p.stack, x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Op < 128)) { break; }
			i = i - (1) >> 0;
		}
		subs = $subslice(p.stack, i);
		p.stack = $subslice(p.stack, 0, i);
		if (subs.$length === 0) {
			$s = -1; return p.push(p.newRegexp(2));
		}
		_r = p.collapse(subs, 18); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = p.push(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.concat }; } $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.p = p; $f.subs = subs; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.concat = function() { return this.$val.concat(); };
	parser.ptr.prototype.alternate = function() {
		var _r, _r$1, i, p, subs, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; i = $f.i; p = $f.p; subs = $f.subs; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		i = p.stack.$length;
		while (true) {
			if (!(i > 0 && (x = p.stack, x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Op < 128)) { break; }
			i = i - (1) >> 0;
		}
		subs = $subslice(p.stack, i);
		p.stack = $subslice(p.stack, 0, i);
		/* */ if (subs.$length > 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (subs.$length > 0) { */ case 1:
			$r = cleanAlt((x$2 = subs.$length - 1 >> 0, ((x$2 < 0 || x$2 >= subs.$length) ? ($throwRuntimeError("index out of range"), undefined) : subs.$array[subs.$offset + x$2]))); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		if (subs.$length === 0) {
			$s = -1; return p.push(p.newRegexp(1));
		}
		_r = p.collapse(subs, 19); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = p.push(_r); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.alternate }; } $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.p = p; $f.subs = subs; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.alternate = function() { return this.$val.alternate(); };
	cleanAlt = function(re) {
		var _1, _r, re, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; re = $f.re; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = re.Op;
			/* */ if (_1 === (4)) { $s = 2; continue; }
			/* */ $s = 3; continue;
			/* if (_1 === (4)) { */ case 2:
				_r = cleanClass((re.$ptr_Rune || (re.$ptr_Rune = new ptrType$2(function() { return this.$target.Rune; }, function($v) { this.$target.Rune = $v; }, re)))); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				re.Rune = _r;
				if ((re.Rune.$length === 2) && ((x = re.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) === 0) && ((x$1 = re.Rune, (1 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 1])) === 1114111)) {
					re.Rune = sliceType.nil;
					re.Op = 6;
					$s = -1; return;
				}
				if ((re.Rune.$length === 4) && ((x$2 = re.Rune, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0])) === 0) && ((x$3 = re.Rune, (1 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 1])) === 9) && ((x$4 = re.Rune, (2 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 2])) === 11) && ((x$5 = re.Rune, (3 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 3])) === 1114111)) {
					re.Rune = sliceType.nil;
					re.Op = 5;
					$s = -1; return;
				}
				if ((re.Rune.$capacity - re.Rune.$length >> 0) > 100) {
					re.Rune = $appendSlice($subslice(new sliceType(re.Rune0), 0, 0), re.Rune);
				}
			/* } */ case 3:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: cleanAlt }; } $f._1 = _1; $f._r = _r; $f.re = re; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.ptr.prototype.collapse = function(subs, op) {
		var _i, _r, _ref, old, op, p, re, sub, subs, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; old = $f.old; op = $f.op; p = $f.p; re = $f.re; sub = $f.sub; subs = $f.subs; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (subs.$length === 1) {
			$s = -1; return (0 >= subs.$length ? ($throwRuntimeError("index out of range"), undefined) : subs.$array[subs.$offset + 0]);
		}
		re = p.newRegexp(op);
		re.Sub = $subslice(new sliceType$5(re.Sub0), 0, 0);
		_ref = subs;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			sub = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (sub.Op === op) {
				re.Sub = $appendSlice(re.Sub, sub.Sub);
				p.reuse(sub);
			} else {
				re.Sub = $append(re.Sub, sub);
			}
			_i++;
		}
		/* */ if (op === 19) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (op === 19) { */ case 1:
			_r = p.factor(re.Sub); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			re.Sub = _r;
			if (re.Sub.$length === 1) {
				old = re;
				re = (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
				p.reuse(old);
			}
		/* } */ case 2:
		$s = -1; return re;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.collapse }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.old = old; $f.op = op; $f.p = p; $f.re = re; $f.sub = sub; $f.subs = subs; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.collapse = function(subs, op) { return this.$val.collapse(subs, op); };
	parser.ptr.prototype.factor = function(sub) {
		var _i, _r, _r$1, _ref, _tmp, _tmp$1, _tuple, first, i, i$1, i$2, i$3, ifirst, iflags, istr, j, j$1, j$2, j$3, max, out, p, prefix, prefix$1, re, re$1, reuse, same, start, str, strflags, sub, suffix, suffix$1, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; first = $f.first; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; ifirst = $f.ifirst; iflags = $f.iflags; istr = $f.istr; j = $f.j; j$1 = $f.j$1; j$2 = $f.j$2; j$3 = $f.j$3; max = $f.max; out = $f.out; p = $f.p; prefix = $f.prefix; prefix$1 = $f.prefix$1; re = $f.re; re$1 = $f.re$1; reuse = $f.reuse; same = $f.same; start = $f.start; str = $f.str; strflags = $f.strflags; sub = $f.sub; suffix = $f.suffix; suffix$1 = $f.suffix$1; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (sub.$length < 2) {
			$s = -1; return sub;
		}
		str = sliceType.nil;
		strflags = 0;
		start = 0;
		out = $subslice(sub, 0, 0);
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i <= sub.$length)) { break; } */ if(!(i <= sub.$length)) { $s = 2; continue; }
			istr = sliceType.nil;
			iflags = 0;
			/* */ if (i < sub.$length) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (i < sub.$length) { */ case 3:
				_tuple = p.leadingString(((i < 0 || i >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i]));
				istr = _tuple[0];
				iflags = _tuple[1];
				if (iflags === strflags) {
					same = 0;
					while (true) {
						if (!(same < str.$length && same < istr.$length && (((same < 0 || same >= str.$length) ? ($throwRuntimeError("index out of range"), undefined) : str.$array[str.$offset + same]) === ((same < 0 || same >= istr.$length) ? ($throwRuntimeError("index out of range"), undefined) : istr.$array[istr.$offset + same])))) { break; }
						same = same + (1) >> 0;
					}
					if (same > 0) {
						str = $subslice(str, 0, same);
						i = i + (1) >> 0;
						/* continue; */ $s = 1; continue;
					}
				}
			/* } */ case 4:
			/* */ if (i === start) { $s = 5; continue; }
			/* */ if (i === (start + 1 >> 0)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (i === start) { */ case 5:
				$s = 8; continue;
			/* } else if (i === (start + 1 >> 0)) { */ case 6:
				out = $append(out, ((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]));
				$s = 8; continue;
			/* } else { */ case 7:
				prefix = p.newRegexp(3);
				prefix.Flags = strflags;
				prefix.Rune = $appendSlice($subslice(prefix.Rune, 0, 0), str);
				j = start;
				while (true) {
					if (!(j < i)) { break; }
					((j < 0 || j >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j] = p.removeLeadingString(((j < 0 || j >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j]), str.$length));
					j = j + (1) >> 0;
				}
				_r = p.collapse($subslice(sub, start, i), 19); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				suffix = _r;
				re = p.newRegexp(18);
				re.Sub = $append($subslice(re.Sub, 0, 0), prefix, suffix);
				out = $append(out, re);
			/* } */ case 8:
			start = i;
			str = istr;
			strflags = iflags;
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		sub = out;
		start = 0;
		out = $subslice(sub, 0, 0);
		first = ptrType$1.nil;
		i$1 = 0;
		/* while (true) { */ case 10:
			/* if (!(i$1 <= sub.$length)) { break; } */ if(!(i$1 <= sub.$length)) { $s = 11; continue; }
			ifirst = ptrType$1.nil;
			/* */ if (i$1 < sub.$length) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (i$1 < sub.$length) { */ case 12:
				ifirst = p.leadingRegexp(((i$1 < 0 || i$1 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$1]));
				if (!(first === ptrType$1.nil) && first.Equal(ifirst) && (isCharClass(first) || ((first.Op === 17) && (first.Min === first.Max) && isCharClass((x = first.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])))))) {
					i$1 = i$1 + (1) >> 0;
					/* continue; */ $s = 10; continue;
				}
			/* } */ case 13:
			/* */ if (i$1 === start) { $s = 14; continue; }
			/* */ if (i$1 === (start + 1 >> 0)) { $s = 15; continue; }
			/* */ $s = 16; continue;
			/* if (i$1 === start) { */ case 14:
				$s = 17; continue;
			/* } else if (i$1 === (start + 1 >> 0)) { */ case 15:
				out = $append(out, ((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]));
				$s = 17; continue;
			/* } else { */ case 16:
				prefix$1 = first;
				j$1 = start;
				while (true) {
					if (!(j$1 < i$1)) { break; }
					reuse = !((j$1 === start));
					((j$1 < 0 || j$1 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$1] = p.removeLeadingRegexp(((j$1 < 0 || j$1 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$1]), reuse));
					j$1 = j$1 + (1) >> 0;
				}
				_r$1 = p.collapse($subslice(sub, start, i$1), 19); /* */ $s = 18; case 18: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				suffix$1 = _r$1;
				re$1 = p.newRegexp(18);
				re$1.Sub = $append($subslice(re$1.Sub, 0, 0), prefix$1, suffix$1);
				out = $append(out, re$1);
			/* } */ case 17:
			start = i$1;
			first = ifirst;
			i$1 = i$1 + (1) >> 0;
		/* } */ $s = 10; continue; case 11:
		sub = out;
		start = 0;
		out = $subslice(sub, 0, 0);
		i$2 = 0;
		/* while (true) { */ case 19:
			/* if (!(i$2 <= sub.$length)) { break; } */ if(!(i$2 <= sub.$length)) { $s = 20; continue; }
			/* */ if (i$2 < sub.$length && isCharClass(((i$2 < 0 || i$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$2]))) { $s = 21; continue; }
			/* */ $s = 22; continue;
			/* if (i$2 < sub.$length && isCharClass(((i$2 < 0 || i$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$2]))) { */ case 21:
				i$2 = i$2 + (1) >> 0;
				/* continue; */ $s = 19; continue;
			/* } */ case 22:
			/* */ if (i$2 === start) { $s = 23; continue; }
			/* */ if (i$2 === (start + 1 >> 0)) { $s = 24; continue; }
			/* */ $s = 25; continue;
			/* if (i$2 === start) { */ case 23:
				$s = 26; continue;
			/* } else if (i$2 === (start + 1 >> 0)) { */ case 24:
				out = $append(out, ((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]));
				$s = 26; continue;
			/* } else { */ case 25:
				max = start;
				j$2 = start + 1 >> 0;
				while (true) {
					if (!(j$2 < i$2)) { break; }
					if (((max < 0 || max >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + max]).Op < ((j$2 < 0 || j$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$2]).Op || (((max < 0 || max >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + max]).Op === ((j$2 < 0 || j$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$2]).Op) && ((max < 0 || max >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + max]).Rune.$length < ((j$2 < 0 || j$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$2]).Rune.$length) {
						max = j$2;
					}
					j$2 = j$2 + (1) >> 0;
				}
				_tmp = ((max < 0 || max >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + max]);
				_tmp$1 = ((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]);
				((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start] = _tmp);
				((max < 0 || max >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + max] = _tmp$1);
				j$3 = start + 1 >> 0;
				while (true) {
					if (!(j$3 < i$2)) { break; }
					mergeCharClass(((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]), ((j$3 < 0 || j$3 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$3]));
					p.reuse(((j$3 < 0 || j$3 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + j$3]));
					j$3 = j$3 + (1) >> 0;
				}
				$r = cleanAlt(((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start])); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				out = $append(out, ((start < 0 || start >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + start]));
			/* } */ case 26:
			if (i$2 < sub.$length) {
				out = $append(out, ((i$2 < 0 || i$2 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$2]));
			}
			start = i$2 + 1 >> 0;
			i$2 = i$2 + (1) >> 0;
		/* } */ $s = 19; continue; case 20:
		sub = out;
		start = 0;
		out = $subslice(sub, 0, 0);
		_ref = sub;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i$3 = _i;
			if ((i$3 + 1 >> 0) < sub.$length && (((i$3 < 0 || i$3 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$3]).Op === 2) && ((x$1 = i$3 + 1 >> 0, ((x$1 < 0 || x$1 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + x$1])).Op === 2)) {
				_i++;
				continue;
			}
			out = $append(out, ((i$3 < 0 || i$3 >= sub.$length) ? ($throwRuntimeError("index out of range"), undefined) : sub.$array[sub.$offset + i$3]));
			_i++;
		}
		sub = out;
		$s = -1; return sub;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.factor }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.first = first; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.ifirst = ifirst; $f.iflags = iflags; $f.istr = istr; $f.j = j; $f.j$1 = j$1; $f.j$2 = j$2; $f.j$3 = j$3; $f.max = max; $f.out = out; $f.p = p; $f.prefix = prefix; $f.prefix$1 = prefix$1; $f.re = re; $f.re$1 = re$1; $f.reuse = reuse; $f.same = same; $f.start = start; $f.str = str; $f.strflags = strflags; $f.sub = sub; $f.suffix = suffix; $f.suffix$1 = suffix$1; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.factor = function(sub) { return this.$val.factor(sub); };
	parser.ptr.prototype.leadingString = function(re) {
		var p, re, x;
		p = this;
		if ((re.Op === 18) && re.Sub.$length > 0) {
			re = (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
		}
		if (!((re.Op === 3))) {
			return [sliceType.nil, 0];
		}
		return [re.Rune, (re.Flags & 1) >>> 0];
	};
	parser.prototype.leadingString = function(re) { return this.$val.leadingString(re); };
	parser.ptr.prototype.removeLeadingString = function(re, n) {
		var _1, n, old, p, re, sub, x, x$1, x$2;
		p = this;
		if ((re.Op === 18) && re.Sub.$length > 0) {
			sub = (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
			sub = p.removeLeadingString(sub, n);
			(x$1 = re.Sub, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0] = sub));
			if (sub.Op === 2) {
				p.reuse(sub);
				_1 = re.Sub.$length;
				if ((_1 === (0)) || (_1 === (1))) {
					re.Op = 2;
					re.Sub = sliceType$5.nil;
				} else if (_1 === (2)) {
					old = re;
					re = (x$2 = re.Sub, (1 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 1]));
					p.reuse(old);
				} else {
					$copySlice(re.Sub, $subslice(re.Sub, 1));
					re.Sub = $subslice(re.Sub, 0, (re.Sub.$length - 1 >> 0));
				}
			}
			return re;
		}
		if (re.Op === 3) {
			re.Rune = $subslice(re.Rune, 0, $copySlice(re.Rune, $subslice(re.Rune, n)));
			if (re.Rune.$length === 0) {
				re.Op = 2;
			}
		}
		return re;
	};
	parser.prototype.removeLeadingString = function(re, n) { return this.$val.removeLeadingString(re, n); };
	parser.ptr.prototype.leadingRegexp = function(re) {
		var p, re, sub, x;
		p = this;
		if (re.Op === 2) {
			return ptrType$1.nil;
		}
		if ((re.Op === 18) && re.Sub.$length > 0) {
			sub = (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
			if (sub.Op === 2) {
				return ptrType$1.nil;
			}
			return sub;
		}
		return re;
	};
	parser.prototype.leadingRegexp = function(re) { return this.$val.leadingRegexp(re); };
	parser.ptr.prototype.removeLeadingRegexp = function(re, reuse) {
		var _1, old, p, re, reuse, x, x$1;
		p = this;
		if ((re.Op === 18) && re.Sub.$length > 0) {
			if (reuse) {
				p.reuse((x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])));
			}
			re.Sub = $subslice(re.Sub, 0, $copySlice(re.Sub, $subslice(re.Sub, 1)));
			_1 = re.Sub.$length;
			if (_1 === (0)) {
				re.Op = 2;
				re.Sub = sliceType$5.nil;
			} else if (_1 === (1)) {
				old = re;
				re = (x$1 = re.Sub, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0]));
				p.reuse(old);
			}
			return re;
		}
		if (reuse) {
			p.reuse(re);
		}
		return p.newRegexp(2);
	};
	parser.prototype.removeLeadingRegexp = function(re, reuse) { return this.$val.removeLeadingRegexp(re, reuse); };
	literalRegexp = function(s, flags) {
		var _i, _ref, _rune, c, flags, re, s;
		re = new Regexp.ptr(3, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
		re.Flags = flags;
		re.Rune = $subslice(new sliceType(re.Rune0), 0, 0);
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			if (re.Rune.$length >= re.Rune.$capacity) {
				re.Rune = (new sliceType($stringToRunes(s)));
				break;
			}
			re.Rune = $append(re.Rune, c);
			_i += _rune[1];
		}
		return re;
	};
	Parse = function(s, flags) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _struct, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, after, after$1, before, before$1, c, c$1, err, err$1, err$2, err$3, flags, i, lastRepeat, lit, max, min, n, ok, op, p, r, r$1, re, repeat, rest, rest$1, rest$2, s, t, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _struct = $f._struct; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; _tuple$9 = $f._tuple$9; after = $f.after; after$1 = $f.after$1; before = $f.before; before$1 = $f.before$1; c = $f.c; c$1 = $f.c$1; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; flags = $f.flags; i = $f.i; lastRepeat = $f.lastRepeat; lit = $f.lit; max = $f.max; min = $f.min; n = $f.n; ok = $f.ok; op = $f.op; p = $f.p; r = $f.r; r$1 = $f.r$1; re = $f.re; repeat = $f.repeat; rest = $f.rest; rest$1 = $f.rest$1; rest$2 = $f.rest$2; s = $f.s; t = $f.t; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (!((((flags & 2) >>> 0) === 0))) {
			err = checkUTF8(s);
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return [ptrType$1.nil, err];
			}
			$s = -1; return [literalRegexp(s, flags), $ifaceNil];
		}
		p = new parser.ptr(0, sliceType$5.nil, ptrType$1.nil, 0, "", sliceType.nil);
		err$1 = $ifaceNil;
		c = 0;
		op = 0;
		lastRepeat = "";
		p.flags = flags;
		p.wholeRegexp = s;
		t = s;
		/* while (true) { */ case 1:
			/* if (!(!(t === ""))) { break; } */ if(!(!(t === ""))) { $s = 2; continue; }
			repeat = "";
				_1 = t.charCodeAt(0);
				/* */ if (_1 === (40)) { $s = 4; continue; }
				/* */ if (_1 === (124)) { $s = 5; continue; }
				/* */ if (_1 === (41)) { $s = 6; continue; }
				/* */ if (_1 === (94)) { $s = 7; continue; }
				/* */ if (_1 === (36)) { $s = 8; continue; }
				/* */ if (_1 === (46)) { $s = 9; continue; }
				/* */ if (_1 === (91)) { $s = 10; continue; }
				/* */ if ((_1 === (42)) || (_1 === (43)) || (_1 === (63))) { $s = 11; continue; }
				/* */ if (_1 === (123)) { $s = 12; continue; }
				/* */ if (_1 === (92)) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if (_1 === (40)) { */ case 4:
					if (!((((p.flags & 64) >>> 0) === 0)) && t.length >= 2 && (t.charCodeAt(1) === 63)) {
						_tuple = p.parsePerlFlags(t);
						t = _tuple[0];
						err$1 = _tuple[1];
						if (!($interfaceIsEqual(err$1, $ifaceNil))) {
							$s = -1; return [ptrType$1.nil, err$1];
						}
						/* break; */ $s = 3; continue;
					}
					p.numCap = p.numCap + (1) >> 0;
					p.op(128).Cap = p.numCap;
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (124)) { */ case 5:
					_r = p.parseVerticalBar(); /* */ $s = 16; case 16: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					err$1 = _r;
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (41)) { */ case 6:
					_r$1 = p.parseRightParen(); /* */ $s = 17; case 17: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					err$1 = _r$1;
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (94)) { */ case 7:
					if (!((((p.flags & 16) >>> 0) === 0))) {
						p.op(9);
					} else {
						p.op(7);
					}
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (36)) { */ case 8:
					if (!((((p.flags & 16) >>> 0) === 0))) {
						_struct = p.op(10);
						_struct.Flags = (_struct.Flags | (256)) >>> 0;
					} else {
						p.op(8);
					}
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (46)) { */ case 9:
					if (!((((p.flags & 8) >>> 0) === 0))) {
						p.op(6);
					} else {
						p.op(5);
					}
					t = $substring(t, 1);
					$s = 15; continue;
				/* } else if (_1 === (91)) { */ case 10:
					_r$2 = p.parseClass(t); /* */ $s = 18; case 18: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_tuple$1 = _r$2;
					t = _tuple$1[0];
					err$1 = _tuple$1[1];
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					$s = 15; continue;
				/* } else if ((_1 === (42)) || (_1 === (43)) || (_1 === (63))) { */ case 11:
					before = t;
					_2 = t.charCodeAt(0);
					if (_2 === (42)) {
						op = 14;
					} else if (_2 === (43)) {
						op = 15;
					} else if (_2 === (63)) {
						op = 16;
					}
					after = $substring(t, 1);
					_tuple$2 = p.repeat(op, 0, 0, before, after, lastRepeat);
					after = _tuple$2[0];
					err$1 = _tuple$2[1];
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					repeat = before;
					t = after;
					$s = 15; continue;
				/* } else if (_1 === (123)) { */ case 12:
					op = 17;
					before$1 = t;
					_tuple$3 = p.parseRepeat(t);
					min = _tuple$3[0];
					max = _tuple$3[1];
					after$1 = _tuple$3[2];
					ok = _tuple$3[3];
					if (!ok) {
						p.literal(123);
						t = $substring(t, 1);
						/* break; */ $s = 3; continue;
					}
					if (min < 0 || min > 1000 || max > 1000 || max >= 0 && min > max) {
						$s = -1; return [ptrType$1.nil, new Error.ptr("invalid repeat count", $substring(before$1, 0, (before$1.length - after$1.length >> 0)))];
					}
					_tuple$4 = p.repeat(op, min, max, before$1, after$1, lastRepeat);
					after$1 = _tuple$4[0];
					err$1 = _tuple$4[1];
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					repeat = before$1;
					t = after$1;
					$s = 15; continue;
				/* } else if (_1 === (92)) { */ case 13:
					if (!((((p.flags & 64) >>> 0) === 0)) && t.length >= 2) {
						_3 = t.charCodeAt(1);
						if (_3 === (65)) {
							p.op(9);
							t = $substring(t, 2);
							/* break BigSwitch; */ $s = 3; continue s;
						} else if (_3 === (98)) {
							p.op(11);
							t = $substring(t, 2);
							/* break BigSwitch; */ $s = 3; continue s;
						} else if (_3 === (66)) {
							p.op(12);
							t = $substring(t, 2);
							/* break BigSwitch; */ $s = 3; continue s;
						} else if (_3 === (67)) {
							$s = -1; return [ptrType$1.nil, new Error.ptr("invalid escape sequence", $substring(t, 0, 2))];
						} else if (_3 === (81)) {
							lit = "";
							i = strings.Index(t, "\\E");
							if (i < 0) {
								lit = $substring(t, 2);
								t = "";
							} else {
								lit = $substring(t, 2, i);
								t = $substring(t, (i + 2 >> 0));
							}
							while (true) {
								if (!(!(lit === ""))) { break; }
								_tuple$5 = nextRune(lit);
								c$1 = _tuple$5[0];
								rest = _tuple$5[1];
								err$2 = _tuple$5[2];
								if (!($interfaceIsEqual(err$2, $ifaceNil))) {
									$s = -1; return [ptrType$1.nil, err$2];
								}
								p.literal(c$1);
								lit = rest;
							}
							/* break BigSwitch; */ $s = 3; continue s;
						} else if (_3 === (122)) {
							p.op(10);
							t = $substring(t, 2);
							/* break BigSwitch; */ $s = 3; continue s;
						}
					}
					re = p.newRegexp(4);
					re.Flags = p.flags;
					/* */ if (t.length >= 2 && ((t.charCodeAt(1) === 112) || (t.charCodeAt(1) === 80))) { $s = 19; continue; }
					/* */ $s = 20; continue;
					/* if (t.length >= 2 && ((t.charCodeAt(1) === 112) || (t.charCodeAt(1) === 80))) { */ case 19:
						_r$3 = p.parseUnicodeClass(t, $subslice(new sliceType(re.Rune0), 0, 0)); /* */ $s = 21; case 21: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						_tuple$6 = _r$3;
						r = _tuple$6[0];
						rest$1 = _tuple$6[1];
						err$3 = _tuple$6[2];
						if (!($interfaceIsEqual(err$3, $ifaceNil))) {
							$s = -1; return [ptrType$1.nil, err$3];
						}
						if (!(r === sliceType.nil)) {
							re.Rune = r;
							t = rest$1;
							p.push(re);
							/* break BigSwitch; */ $s = 3; continue s;
						}
					/* } */ case 20:
					_r$4 = p.parsePerlClassEscape(t, $subslice(new sliceType(re.Rune0), 0, 0)); /* */ $s = 22; case 22: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					_tuple$7 = _r$4;
					r$1 = _tuple$7[0];
					rest$2 = _tuple$7[1];
					if (!(r$1 === sliceType.nil)) {
						re.Rune = r$1;
						t = rest$2;
						p.push(re);
						/* break BigSwitch; */ $s = 3; continue s;
					}
					p.reuse(re);
					_tuple$8 = p.parseEscape(t);
					c = _tuple$8[0];
					t = _tuple$8[1];
					err$1 = _tuple$8[2];
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					p.literal(c);
					$s = 15; continue;
				/* } else { */ case 14:
					_tuple$9 = nextRune(t);
					c = _tuple$9[0];
					t = _tuple$9[1];
					err$1 = _tuple$9[2];
					if (!($interfaceIsEqual(err$1, $ifaceNil))) {
						$s = -1; return [ptrType$1.nil, err$1];
					}
					p.literal(c);
				/* } */ case 15:
			case 3:
			lastRepeat = repeat;
		/* } */ $s = 1; continue; case 2:
		_r$5 = p.concat(); /* */ $s = 23; case 23: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_r$5;
		_r$6 = p.swapVerticalBar(); /* */ $s = 26; case 26: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		/* */ if (_r$6) { $s = 24; continue; }
		/* */ $s = 25; continue;
		/* if (_r$6) { */ case 24:
			p.stack = $subslice(p.stack, 0, (p.stack.$length - 1 >> 0));
		/* } */ case 25:
		_r$7 = p.alternate(); /* */ $s = 27; case 27: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_r$7;
		n = p.stack.$length;
		if (!((n === 1))) {
			$s = -1; return [ptrType$1.nil, new Error.ptr("missing closing )", s)];
		}
		$s = -1; return [(x = p.stack, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Parse }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._struct = _struct; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f._tuple$9 = _tuple$9; $f.after = after; $f.after$1 = after$1; $f.before = before; $f.before$1 = before$1; $f.c = c; $f.c$1 = c$1; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.flags = flags; $f.i = i; $f.lastRepeat = lastRepeat; $f.lit = lit; $f.max = max; $f.min = min; $f.n = n; $f.ok = ok; $f.op = op; $f.p = p; $f.r = r; $f.r$1 = r$1; $f.re = re; $f.repeat = repeat; $f.rest = rest; $f.rest$1 = rest$1; $f.rest$2 = rest$2; $f.s = s; $f.t = t; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Parse = Parse;
	parser.ptr.prototype.parseRepeat = function(s) {
		var _tuple, _tuple$1, max, min, ok, ok1, p, rest, s;
		min = 0;
		max = 0;
		rest = "";
		ok = false;
		p = this;
		if (s === "" || !((s.charCodeAt(0) === 123))) {
			return [min, max, rest, ok];
		}
		s = $substring(s, 1);
		ok1 = false;
		_tuple = p.parseInt(s);
		min = _tuple[0];
		s = _tuple[1];
		ok1 = _tuple[2];
		if (!ok1) {
			return [min, max, rest, ok];
		}
		if (s === "") {
			return [min, max, rest, ok];
		}
		if (!((s.charCodeAt(0) === 44))) {
			max = min;
		} else {
			s = $substring(s, 1);
			if (s === "") {
				return [min, max, rest, ok];
			}
			if (s.charCodeAt(0) === 125) {
				max = -1;
			} else {
				_tuple$1 = p.parseInt(s);
				max = _tuple$1[0];
				s = _tuple$1[1];
				ok1 = _tuple$1[2];
				if (!ok1) {
					return [min, max, rest, ok];
				} else if (max < 0) {
					min = -1;
				}
			}
		}
		if (s === "" || !((s.charCodeAt(0) === 125))) {
			return [min, max, rest, ok];
		}
		rest = $substring(s, 1);
		ok = true;
		return [min, max, rest, ok];
	};
	parser.prototype.parseRepeat = function(s) { return this.$val.parseRepeat(s); };
	parser.ptr.prototype.parsePerlFlags = function(s) {
		var _1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, c, capture, end, err, flags, name, p, re, rest, s, sawFlag, sign, t;
		rest = "";
		err = $ifaceNil;
		p = this;
		t = s;
		if (t.length > 4 && (t.charCodeAt(2) === 80) && (t.charCodeAt(3) === 60)) {
			end = strings.IndexRune(t, 62);
			if (end < 0) {
				err = checkUTF8(t);
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					_tmp = "";
					_tmp$1 = err;
					rest = _tmp;
					err = _tmp$1;
					return [rest, err];
				}
				_tmp$2 = "";
				_tmp$3 = new Error.ptr("invalid named capture", s);
				rest = _tmp$2;
				err = _tmp$3;
				return [rest, err];
			}
			capture = $substring(t, 0, (end + 1 >> 0));
			name = $substring(t, 4, end);
			err = checkUTF8(name);
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp$4 = "";
				_tmp$5 = err;
				rest = _tmp$4;
				err = _tmp$5;
				return [rest, err];
			}
			if (!isValidCaptureName(name)) {
				_tmp$6 = "";
				_tmp$7 = new Error.ptr("invalid named capture", capture);
				rest = _tmp$6;
				err = _tmp$7;
				return [rest, err];
			}
			p.numCap = p.numCap + (1) >> 0;
			re = p.op(128);
			re.Cap = p.numCap;
			re.Name = name;
			_tmp$8 = $substring(t, (end + 1 >> 0));
			_tmp$9 = $ifaceNil;
			rest = _tmp$8;
			err = _tmp$9;
			return [rest, err];
		}
		c = 0;
		t = $substring(t, 2);
		flags = p.flags;
		sign = 1;
		sawFlag = false;
		Loop:
		while (true) {
			if (!(!(t === ""))) { break; }
			_tuple = nextRune(t);
			c = _tuple[0];
			t = _tuple[1];
			err = _tuple[2];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp$10 = "";
				_tmp$11 = err;
				rest = _tmp$10;
				err = _tmp$11;
				return [rest, err];
			}
			_1 = c;
			if (_1 === (105)) {
				flags = (flags | (1)) >>> 0;
				sawFlag = true;
			} else if (_1 === (109)) {
				flags = (flags & ~(16)) << 16 >>> 16;
				sawFlag = true;
			} else if (_1 === (115)) {
				flags = (flags | (8)) >>> 0;
				sawFlag = true;
			} else if (_1 === (85)) {
				flags = (flags | (32)) >>> 0;
				sawFlag = true;
			} else if (_1 === (45)) {
				if (sign < 0) {
					break Loop;
				}
				sign = -1;
				flags = ~flags << 16 >>> 16;
				sawFlag = false;
			} else if ((_1 === (58)) || (_1 === (41))) {
				if (sign < 0) {
					if (!sawFlag) {
						break Loop;
					}
					flags = ~flags << 16 >>> 16;
				}
				if (c === 58) {
					p.op(128);
				}
				p.flags = flags;
				_tmp$12 = t;
				_tmp$13 = $ifaceNil;
				rest = _tmp$12;
				err = _tmp$13;
				return [rest, err];
			} else {
				break Loop;
			}
		}
		_tmp$14 = "";
		_tmp$15 = new Error.ptr("invalid or unsupported Perl syntax", $substring(s, 0, (s.length - t.length >> 0)));
		rest = _tmp$14;
		err = _tmp$15;
		return [rest, err];
	};
	parser.prototype.parsePerlFlags = function(s) { return this.$val.parsePerlFlags(s); };
	isValidCaptureName = function(name) {
		var _i, _ref, _rune, c, name;
		if (name === "") {
			return false;
		}
		_ref = name;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			if (!((c === 95)) && !isalnum(c)) {
				return false;
			}
			_i += _rune[1];
		}
		return true;
	};
	parser.ptr.prototype.parseInt = function(s) {
		var i, n, ok, p, rest, s, t;
		n = 0;
		rest = "";
		ok = false;
		p = this;
		if (s === "" || s.charCodeAt(0) < 48 || 57 < s.charCodeAt(0)) {
			return [n, rest, ok];
		}
		if (s.length >= 2 && (s.charCodeAt(0) === 48) && 48 <= s.charCodeAt(1) && s.charCodeAt(1) <= 57) {
			return [n, rest, ok];
		}
		t = s;
		while (true) {
			if (!(!(s === "") && 48 <= s.charCodeAt(0) && s.charCodeAt(0) <= 57)) { break; }
			s = $substring(s, 1);
		}
		rest = s;
		ok = true;
		t = $substring(t, 0, (t.length - s.length >> 0));
		i = 0;
		while (true) {
			if (!(i < t.length)) { break; }
			if (n >= 100000000) {
				n = -1;
				break;
			}
			n = (($imul(n, 10)) + ((t.charCodeAt(i) >> 0)) >> 0) - 48 >> 0;
			i = i + (1) >> 0;
		}
		return [n, rest, ok];
	};
	parser.prototype.parseInt = function(s) { return this.$val.parseInt(s); };
	isCharClass = function(re) {
		var re;
		return (re.Op === 3) && (re.Rune.$length === 1) || (re.Op === 4) || (re.Op === 5) || (re.Op === 6);
	};
	matchRune = function(re, r) {
		var _1, i, r, re, x, x$1, x$2, x$3;
		_1 = re.Op;
		if (_1 === (3)) {
			return (re.Rune.$length === 1) && ((x = re.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) === r);
		} else if (_1 === (4)) {
			i = 0;
			while (true) {
				if (!(i < re.Rune.$length)) { break; }
				if ((x$1 = re.Rune, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])) <= r && r <= (x$2 = re.Rune, x$3 = i + 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]))) {
					return true;
				}
				i = i + (2) >> 0;
			}
			return false;
		} else if (_1 === (5)) {
			return !((r === 10));
		} else if (_1 === (6)) {
			return true;
		}
		return false;
	};
	parser.ptr.prototype.parseVerticalBar = function() {
		var _r, _r$1, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r = p.concat(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		_r$1 = p.swapVerticalBar(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (!_r$1) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!_r$1) { */ case 2:
			p.op(129);
		/* } */ case 3:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseVerticalBar }; } $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseVerticalBar = function() { return this.$val.parseVerticalBar(); };
	mergeCharClass = function(dst, src) {
		var _1, dst, src, x, x$1, x$2, x$3, x$4;
		switch (0) { default:
			_1 = dst.Op;
			if (_1 === (6)) {
			} else if (_1 === (5)) {
				if (matchRune(src, 10)) {
					dst.Op = 6;
				}
			} else if (_1 === (4)) {
				if (src.Op === 3) {
					dst.Rune = appendLiteral(dst.Rune, (x = src.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])), src.Flags);
				} else {
					dst.Rune = appendClass(dst.Rune, src.Rune);
				}
			} else if (_1 === (3)) {
				if (((x$1 = src.Rune, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) === (x$2 = dst.Rune, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0]))) && (src.Flags === dst.Flags)) {
					break;
				}
				dst.Op = 4;
				dst.Rune = appendLiteral($subslice(dst.Rune, 0, 0), (x$3 = dst.Rune, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])), dst.Flags);
				dst.Rune = appendLiteral(dst.Rune, (x$4 = src.Rune, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])), src.Flags);
			}
		}
	};
	parser.ptr.prototype.swapVerticalBar = function() {
		var _tmp, _tmp$1, n, p, re1, re1$1, re2, re3, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; n = $f.n; p = $f.p; re1 = $f.re1; re1$1 = $f.re1$1; re2 = $f.re2; re3 = $f.re3; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$16 = $f.x$16; x$17 = $f.x$17; x$18 = $f.x$18; x$19 = $f.x$19; x$2 = $f.x$2; x$20 = $f.x$20; x$21 = $f.x$21; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		n = p.stack.$length;
		if (n >= 3 && ((x = p.stack, x$1 = n - 2 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Op === 129) && isCharClass((x$2 = p.stack, x$3 = n - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]))) && isCharClass((x$4 = p.stack, x$5 = n - 3 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])))) {
			re1 = (x$6 = p.stack, x$7 = n - 1 >> 0, ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7]));
			re3 = (x$8 = p.stack, x$9 = n - 3 >> 0, ((x$9 < 0 || x$9 >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + x$9]));
			if (re1.Op > re3.Op) {
				_tmp = re3;
				_tmp$1 = re1;
				re1 = _tmp;
				re3 = _tmp$1;
				(x$10 = p.stack, x$11 = n - 3 >> 0, ((x$11 < 0 || x$11 >= x$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + x$11] = re3));
			}
			mergeCharClass(re3, re1);
			p.reuse(re1);
			p.stack = $subslice(p.stack, 0, (n - 1 >> 0));
			$s = -1; return true;
		}
		/* */ if (n >= 2) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (n >= 2) { */ case 1:
			re1$1 = (x$12 = p.stack, x$13 = n - 1 >> 0, ((x$13 < 0 || x$13 >= x$12.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + x$13]));
			re2 = (x$14 = p.stack, x$15 = n - 2 >> 0, ((x$15 < 0 || x$15 >= x$14.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$14.$array[x$14.$offset + x$15]));
			/* */ if (re2.Op === 129) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (re2.Op === 129) { */ case 3:
				/* */ if (n >= 3) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (n >= 3) { */ case 5:
					$r = cleanAlt((x$16 = p.stack, x$17 = n - 3 >> 0, ((x$17 < 0 || x$17 >= x$16.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$16.$array[x$16.$offset + x$17]))); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				/* } */ case 6:
				(x$18 = p.stack, x$19 = n - 2 >> 0, ((x$19 < 0 || x$19 >= x$18.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$18.$array[x$18.$offset + x$19] = re1$1));
				(x$20 = p.stack, x$21 = n - 1 >> 0, ((x$21 < 0 || x$21 >= x$20.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$20.$array[x$20.$offset + x$21] = re2));
				$s = -1; return true;
			/* } */ case 4:
		/* } */ case 2:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.swapVerticalBar }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.n = n; $f.p = p; $f.re1 = re1; $f.re1$1 = re1$1; $f.re2 = re2; $f.re3 = re3; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$16 = x$16; $f.x$17 = x$17; $f.x$18 = x$18; $f.x$19 = x$19; $f.x$2 = x$2; $f.x$20 = x$20; $f.x$21 = x$21; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.swapVerticalBar = function() { return this.$val.swapVerticalBar(); };
	parser.ptr.prototype.parseRightParen = function() {
		var _r, _r$1, _r$2, n, p, re1, re2, x, x$1, x$2, x$3, x$4, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; n = $f.n; p = $f.p; re1 = $f.re1; re2 = $f.re2; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_r = p.concat(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		_r$1 = p.swapVerticalBar(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (_r$1) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (_r$1) { */ case 2:
			p.stack = $subslice(p.stack, 0, (p.stack.$length - 1 >> 0));
		/* } */ case 3:
		_r$2 = p.alternate(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		n = p.stack.$length;
		if (n < 2) {
			$s = -1; return new Error.ptr("unexpected )", p.wholeRegexp);
		}
		re1 = (x = p.stack, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		re2 = (x$2 = p.stack, x$3 = n - 2 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
		p.stack = $subslice(p.stack, 0, (n - 2 >> 0));
		if (!((re2.Op === 128))) {
			$s = -1; return new Error.ptr("unexpected )", p.wholeRegexp);
		}
		p.flags = re2.Flags;
		if (re2.Cap === 0) {
			p.push(re1);
		} else {
			re2.Op = 13;
			re2.Sub = $subslice(new sliceType$5(re2.Sub0), 0, 1);
			(x$4 = re2.Sub, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0] = re1));
			p.push(re2);
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseRightParen }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.n = n; $f.p = p; $f.re1 = re1; $f.re2 = re2; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseRightParen = function() { return this.$val.parseRightParen(); };
	parser.ptr.prototype.parseEscape = function(s) {
		var _1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$29, _tmp$3, _tmp$30, _tmp$31, _tmp$32, _tmp$33, _tmp$34, _tmp$35, _tmp$36, _tmp$37, _tmp$38, _tmp$39, _tmp$4, _tmp$40, _tmp$41, _tmp$42, _tmp$43, _tmp$44, _tmp$45, _tmp$46, _tmp$47, _tmp$48, _tmp$49, _tmp$5, _tmp$50, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, c, err, i, nhex, p, r, rest, s, t, v, x, y;
		r = 0;
		rest = "";
		err = $ifaceNil;
		p = this;
		t = $substring(s, 1);
		if (t === "") {
			_tmp = 0;
			_tmp$1 = "";
			_tmp$2 = new Error.ptr("trailing backslash at end of expression", "");
			r = _tmp;
			rest = _tmp$1;
			err = _tmp$2;
			return [r, rest, err];
		}
		_tuple = nextRune(t);
		c = _tuple[0];
		t = _tuple[1];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			_tmp$3 = 0;
			_tmp$4 = "";
			_tmp$5 = err;
			r = _tmp$3;
			rest = _tmp$4;
			err = _tmp$5;
			return [r, rest, err];
		}
		Switch:
		switch (0) { default:
			_1 = c;
			if ((_1 === (49)) || (_1 === (50)) || (_1 === (51)) || (_1 === (52)) || (_1 === (53)) || (_1 === (54)) || (_1 === (55))) {
				if (t === "" || t.charCodeAt(0) < 48 || t.charCodeAt(0) > 55) {
					break;
				}
				r = c - 48 >> 0;
				i = 1;
				while (true) {
					if (!(i < 3)) { break; }
					if (t === "" || t.charCodeAt(0) < 48 || t.charCodeAt(0) > 55) {
						break;
					}
					r = (($imul(r, 8)) + ((t.charCodeAt(0) >> 0)) >> 0) - 48 >> 0;
					t = $substring(t, 1);
					i = i + (1) >> 0;
				}
				_tmp$6 = r;
				_tmp$7 = t;
				_tmp$8 = $ifaceNil;
				r = _tmp$6;
				rest = _tmp$7;
				err = _tmp$8;
				return [r, rest, err];
			} else if (_1 === (48)) {
				r = c - 48 >> 0;
				i = 1;
				while (true) {
					if (!(i < 3)) { break; }
					if (t === "" || t.charCodeAt(0) < 48 || t.charCodeAt(0) > 55) {
						break;
					}
					r = (($imul(r, 8)) + ((t.charCodeAt(0) >> 0)) >> 0) - 48 >> 0;
					t = $substring(t, 1);
					i = i + (1) >> 0;
				}
				_tmp$9 = r;
				_tmp$10 = t;
				_tmp$11 = $ifaceNil;
				r = _tmp$9;
				rest = _tmp$10;
				err = _tmp$11;
				return [r, rest, err];
			} else if (_1 === (120)) {
				if (t === "") {
					break;
				}
				_tuple$1 = nextRune(t);
				c = _tuple$1[0];
				t = _tuple$1[1];
				err = _tuple$1[2];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					_tmp$12 = 0;
					_tmp$13 = "";
					_tmp$14 = err;
					r = _tmp$12;
					rest = _tmp$13;
					err = _tmp$14;
					return [r, rest, err];
				}
				if (c === 123) {
					nhex = 0;
					r = 0;
					while (true) {
						if (t === "") {
							break Switch;
						}
						_tuple$2 = nextRune(t);
						c = _tuple$2[0];
						t = _tuple$2[1];
						err = _tuple$2[2];
						if (!($interfaceIsEqual(err, $ifaceNil))) {
							_tmp$15 = 0;
							_tmp$16 = "";
							_tmp$17 = err;
							r = _tmp$15;
							rest = _tmp$16;
							err = _tmp$17;
							return [r, rest, err];
						}
						if (c === 125) {
							break;
						}
						v = unhex(c);
						if (v < 0) {
							break Switch;
						}
						r = ($imul(r, 16)) + v >> 0;
						if (r > 1114111) {
							break Switch;
						}
						nhex = nhex + (1) >> 0;
					}
					if (nhex === 0) {
						break Switch;
					}
					_tmp$18 = r;
					_tmp$19 = t;
					_tmp$20 = $ifaceNil;
					r = _tmp$18;
					rest = _tmp$19;
					err = _tmp$20;
					return [r, rest, err];
				}
				x = unhex(c);
				_tuple$3 = nextRune(t);
				c = _tuple$3[0];
				t = _tuple$3[1];
				err = _tuple$3[2];
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					_tmp$21 = 0;
					_tmp$22 = "";
					_tmp$23 = err;
					r = _tmp$21;
					rest = _tmp$22;
					err = _tmp$23;
					return [r, rest, err];
				}
				y = unhex(c);
				if (x < 0 || y < 0) {
					break;
				}
				_tmp$24 = ($imul(x, 16)) + y >> 0;
				_tmp$25 = t;
				_tmp$26 = $ifaceNil;
				r = _tmp$24;
				rest = _tmp$25;
				err = _tmp$26;
				return [r, rest, err];
			} else if (_1 === (97)) {
				_tmp$27 = 7;
				_tmp$28 = t;
				_tmp$29 = err;
				r = _tmp$27;
				rest = _tmp$28;
				err = _tmp$29;
				return [r, rest, err];
			} else if (_1 === (102)) {
				_tmp$30 = 12;
				_tmp$31 = t;
				_tmp$32 = err;
				r = _tmp$30;
				rest = _tmp$31;
				err = _tmp$32;
				return [r, rest, err];
			} else if (_1 === (110)) {
				_tmp$33 = 10;
				_tmp$34 = t;
				_tmp$35 = err;
				r = _tmp$33;
				rest = _tmp$34;
				err = _tmp$35;
				return [r, rest, err];
			} else if (_1 === (114)) {
				_tmp$36 = 13;
				_tmp$37 = t;
				_tmp$38 = err;
				r = _tmp$36;
				rest = _tmp$37;
				err = _tmp$38;
				return [r, rest, err];
			} else if (_1 === (116)) {
				_tmp$39 = 9;
				_tmp$40 = t;
				_tmp$41 = err;
				r = _tmp$39;
				rest = _tmp$40;
				err = _tmp$41;
				return [r, rest, err];
			} else if (_1 === (118)) {
				_tmp$42 = 11;
				_tmp$43 = t;
				_tmp$44 = err;
				r = _tmp$42;
				rest = _tmp$43;
				err = _tmp$44;
				return [r, rest, err];
			} else if (c < 128 && !isalnum(c)) {
				_tmp$45 = c;
				_tmp$46 = t;
				_tmp$47 = $ifaceNil;
				r = _tmp$45;
				rest = _tmp$46;
				err = _tmp$47;
				return [r, rest, err];
			}
		}
		_tmp$48 = 0;
		_tmp$49 = "";
		_tmp$50 = new Error.ptr("invalid escape sequence", $substring(s, 0, (s.length - t.length >> 0)));
		r = _tmp$48;
		rest = _tmp$49;
		err = _tmp$50;
		return [r, rest, err];
	};
	parser.prototype.parseEscape = function(s) { return this.$val.parseEscape(s); };
	parser.ptr.prototype.parseClassChar = function(s, wholeClass) {
		var _tmp, _tmp$1, _tmp$2, _tuple, _tuple$1, err, p, r, rest, s, wholeClass;
		r = 0;
		rest = "";
		err = $ifaceNil;
		p = this;
		if (s === "") {
			_tmp = 0;
			_tmp$1 = "";
			_tmp$2 = new Error.ptr("missing closing ]", wholeClass);
			r = _tmp;
			rest = _tmp$1;
			err = _tmp$2;
			return [r, rest, err];
		}
		if (s.charCodeAt(0) === 92) {
			_tuple = p.parseEscape(s);
			r = _tuple[0];
			rest = _tuple[1];
			err = _tuple[2];
			return [r, rest, err];
		}
		_tuple$1 = nextRune(s);
		r = _tuple$1[0];
		rest = _tuple$1[1];
		err = _tuple$1[2];
		return [r, rest, err];
	};
	parser.prototype.parseClassChar = function(s, wholeClass) { return this.$val.parseClassChar(s, wholeClass); };
	parser.ptr.prototype.parsePerlClassEscape = function(s, r) {
		var _entry, _r, _tmp, _tmp$1, g, out, p, r, rest, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; g = $f.g; out = $f.out; p = $f.p; r = $f.r; rest = $f.rest; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		out = sliceType.nil;
		rest = "";
		p = this;
		if ((((p.flags & 64) >>> 0) === 0) || s.length < 2 || !((s.charCodeAt(0) === 92))) {
			$s = -1; return [out, rest];
		}
		g = $clone((_entry = perlGroup[$String.keyFor($substring(s, 0, 2))], _entry !== undefined ? _entry.v : new charGroup.ptr(0, sliceType.nil)), charGroup);
		if (g.sign === 0) {
			$s = -1; return [out, rest];
		}
		_r = p.appendGroup(r, $clone(g, charGroup)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tmp = _r;
		_tmp$1 = $substring(s, 2);
		out = _tmp;
		rest = _tmp$1;
		$s = -1; return [out, rest];
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parsePerlClassEscape }; } $f._entry = _entry; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.g = g; $f.out = out; $f.p = p; $f.r = r; $f.rest = rest; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parsePerlClassEscape = function(s, r) { return this.$val.parsePerlClassEscape(s, r); };
	parser.ptr.prototype.parseNamedClass = function(s, r) {
		var _entry, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, err, g, i, name, out, p, r, rest, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; err = $f.err; g = $f.g; i = $f.i; name = $f.name; out = $f.out; p = $f.p; r = $f.r; rest = $f.rest; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		out = sliceType.nil;
		rest = "";
		err = $ifaceNil;
		p = this;
		if (s.length < 2 || !((s.charCodeAt(0) === 91)) || !((s.charCodeAt(1) === 58))) {
			$s = -1; return [out, rest, err];
		}
		i = strings.Index($substring(s, 2), ":]");
		if (i < 0) {
			$s = -1; return [out, rest, err];
		}
		i = i + (2) >> 0;
		_tmp = $substring(s, 0, (i + 2 >> 0));
		_tmp$1 = $substring(s, (i + 2 >> 0));
		name = _tmp;
		s = _tmp$1;
		g = $clone((_entry = posixGroup[$String.keyFor(name)], _entry !== undefined ? _entry.v : new charGroup.ptr(0, sliceType.nil)), charGroup);
		if (g.sign === 0) {
			_tmp$2 = sliceType.nil;
			_tmp$3 = "";
			_tmp$4 = new Error.ptr("invalid character class range", name);
			out = _tmp$2;
			rest = _tmp$3;
			err = _tmp$4;
			$s = -1; return [out, rest, err];
		}
		_r = p.appendGroup(r, $clone(g, charGroup)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tmp$5 = _r;
		_tmp$6 = s;
		_tmp$7 = $ifaceNil;
		out = _tmp$5;
		rest = _tmp$6;
		err = _tmp$7;
		$s = -1; return [out, rest, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseNamedClass }; } $f._entry = _entry; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f.err = err; $f.g = g; $f.i = i; $f.name = name; $f.out = out; $f.p = p; $f.r = r; $f.rest = rest; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseNamedClass = function(s, r) { return this.$val.parseNamedClass(s, r); };
	parser.ptr.prototype.appendGroup = function(r, g) {
		var _r, g, p, r, tmp, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; g = $f.g; p = $f.p; r = $f.r; tmp = $f.tmp; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (((p.flags & 1) >>> 0) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (((p.flags & 1) >>> 0) === 0) { */ case 1:
			if (g.sign < 0) {
				r = appendNegatedClass(r, g.class$1);
			} else {
				r = appendClass(r, g.class$1);
			}
			$s = 3; continue;
		/* } else { */ case 2:
			tmp = $subslice(p.tmpClass, 0, 0);
			tmp = appendFoldedClass(tmp, g.class$1);
			p.tmpClass = tmp;
			_r = cleanClass((p.$ptr_tmpClass || (p.$ptr_tmpClass = new ptrType$2(function() { return this.$target.tmpClass; }, function($v) { this.$target.tmpClass = $v; }, p)))); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			tmp = _r;
			if (g.sign < 0) {
				r = appendNegatedClass(r, tmp);
			} else {
				r = appendClass(r, tmp);
			}
		/* } */ case 3:
		$s = -1; return r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.appendGroup }; } $f._r = _r; $f.g = g; $f.p = p; $f.r = r; $f.tmp = tmp; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.appendGroup = function(r, g) { return this.$val.appendGroup(r, g); };
	unicodeTable = function(name) {
		var _entry, _entry$1, _entry$2, _entry$3, name, t, t$1;
		if (name === "Any") {
			return [anyTable, anyTable];
		}
		t = (_entry = unicode.Categories[$String.keyFor(name)], _entry !== undefined ? _entry.v : ptrType$3.nil);
		if (!(t === ptrType$3.nil)) {
			return [t, (_entry$1 = unicode.FoldCategory[$String.keyFor(name)], _entry$1 !== undefined ? _entry$1.v : ptrType$3.nil)];
		}
		t$1 = (_entry$2 = unicode.Scripts[$String.keyFor(name)], _entry$2 !== undefined ? _entry$2.v : ptrType$3.nil);
		if (!(t$1 === ptrType$3.nil)) {
			return [t$1, (_entry$3 = unicode.FoldScript[$String.keyFor(name)], _entry$3 !== undefined ? _entry$3.v : ptrType$3.nil)];
		}
		return [ptrType$3.nil, ptrType$3.nil];
	};
	parser.ptr.prototype.parseUnicodeClass = function(s, r) {
		var _r, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, c, end, err, fold, name, out, p, r, rest, s, seq, sign, t, tab, tmp, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; c = $f.c; end = $f.end; err = $f.err; fold = $f.fold; name = $f.name; out = $f.out; p = $f.p; r = $f.r; rest = $f.rest; s = $f.s; seq = $f.seq; sign = $f.sign; t = $f.t; tab = $f.tab; tmp = $f.tmp; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		out = sliceType.nil;
		rest = "";
		err = $ifaceNil;
		p = this;
		if ((((p.flags & 128) >>> 0) === 0) || s.length < 2 || !((s.charCodeAt(0) === 92)) || !((s.charCodeAt(1) === 112)) && !((s.charCodeAt(1) === 80))) {
			$s = -1; return [out, rest, err];
		}
		sign = 1;
		if (s.charCodeAt(1) === 80) {
			sign = -1;
		}
		t = $substring(s, 2);
		_tuple = nextRune(t);
		c = _tuple[0];
		t = _tuple[1];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [out, rest, err];
		}
		_tmp = "";
		_tmp$1 = "";
		seq = _tmp;
		name = _tmp$1;
		if (!((c === 123))) {
			seq = $substring(s, 0, (s.length - t.length >> 0));
			name = $substring(seq, 2);
		} else {
			end = strings.IndexRune(s, 125);
			if (end < 0) {
				err = checkUTF8(s);
				if (!($interfaceIsEqual(err, $ifaceNil))) {
					$s = -1; return [out, rest, err];
				}
				_tmp$2 = sliceType.nil;
				_tmp$3 = "";
				_tmp$4 = new Error.ptr("invalid character class range", s);
				out = _tmp$2;
				rest = _tmp$3;
				err = _tmp$4;
				$s = -1; return [out, rest, err];
			}
			_tmp$5 = $substring(s, 0, (end + 1 >> 0));
			_tmp$6 = $substring(s, (end + 1 >> 0));
			seq = _tmp$5;
			t = _tmp$6;
			name = $substring(s, 3, end);
			err = checkUTF8(name);
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return [out, rest, err];
			}
		}
		if (!(name === "") && (name.charCodeAt(0) === 94)) {
			sign = -sign;
			name = $substring(name, 1);
		}
		_tuple$1 = unicodeTable(name);
		tab = _tuple$1[0];
		fold = _tuple$1[1];
		if (tab === ptrType$3.nil) {
			_tmp$7 = sliceType.nil;
			_tmp$8 = "";
			_tmp$9 = new Error.ptr("invalid character class range", seq);
			out = _tmp$7;
			rest = _tmp$8;
			err = _tmp$9;
			$s = -1; return [out, rest, err];
		}
		/* */ if ((((p.flags & 1) >>> 0) === 0) || fold === ptrType$3.nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((((p.flags & 1) >>> 0) === 0) || fold === ptrType$3.nil) { */ case 1:
			if (sign > 0) {
				r = appendTable(r, tab);
			} else {
				r = appendNegatedTable(r, tab);
			}
			$s = 3; continue;
		/* } else { */ case 2:
			tmp = $subslice(p.tmpClass, 0, 0);
			tmp = appendTable(tmp, tab);
			tmp = appendTable(tmp, fold);
			p.tmpClass = tmp;
			_r = cleanClass((p.$ptr_tmpClass || (p.$ptr_tmpClass = new ptrType$2(function() { return this.$target.tmpClass; }, function($v) { this.$target.tmpClass = $v; }, p)))); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			tmp = _r;
			if (sign > 0) {
				r = appendClass(r, tmp);
			} else {
				r = appendNegatedClass(r, tmp);
			}
		/* } */ case 3:
		_tmp$10 = r;
		_tmp$11 = t;
		_tmp$12 = $ifaceNil;
		out = _tmp$10;
		rest = _tmp$11;
		err = _tmp$12;
		$s = -1; return [out, rest, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseUnicodeClass }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.c = c; $f.end = end; $f.err = err; $f.fold = fold; $f.name = name; $f.out = out; $f.p = p; $f.r = r; $f.rest = rest; $f.s = s; $f.seq = seq; $f.sign = sign; $f.t = t; $f.tab = tab; $f.tmp = tmp; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseUnicodeClass = function(s, r) { return this.$val.parseUnicodeClass(s, r); };
	parser.ptr.prototype.parseClass = function(s) {
		var _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, class$1, err, err$1, err$2, first, hi, lo, nclass, nclass$1, nclass$2, nt, nt$1, nt$2, p, re, rest, rng, s, sign, size, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$18 = $f._tmp$18; _tmp$19 = $f._tmp$19; _tmp$2 = $f._tmp$2; _tmp$20 = $f._tmp$20; _tmp$21 = $f._tmp$21; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; class$1 = $f.class$1; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; first = $f.first; hi = $f.hi; lo = $f.lo; nclass = $f.nclass; nclass$1 = $f.nclass$1; nclass$2 = $f.nclass$2; nt = $f.nt; nt$1 = $f.nt$1; nt$2 = $f.nt$2; p = $f.p; re = $f.re; rest = $f.rest; rng = $f.rng; s = $f.s; sign = $f.sign; size = $f.size; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		rest = "";
		err = $ifaceNil;
		p = this;
		t = $substring(s, 1);
		re = p.newRegexp(4);
		re.Flags = p.flags;
		re.Rune = $subslice(new sliceType(re.Rune0), 0, 0);
		sign = 1;
		if (!(t === "") && (t.charCodeAt(0) === 94)) {
			sign = -1;
			t = $substring(t, 1);
			if (((p.flags & 4) >>> 0) === 0) {
				re.Rune = $append(re.Rune, 10, 10);
			}
		}
		class$1 = re.Rune;
		first = true;
		/* while (true) { */ case 1:
			/* if (!(t === "" || !((t.charCodeAt(0) === 93)) || first)) { break; } */ if(!(t === "" || !((t.charCodeAt(0) === 93)) || first)) { $s = 2; continue; }
			if (!(t === "") && (t.charCodeAt(0) === 45) && (((p.flags & 64) >>> 0) === 0) && !first && ((t.length === 1) || !((t.charCodeAt(1) === 93)))) {
				_tuple = utf8.DecodeRuneInString($substring(t, 1));
				size = _tuple[1];
				_tmp = "";
				_tmp$1 = new Error.ptr("invalid character class range", $substring(t, 0, (1 + size >> 0)));
				rest = _tmp;
				err = _tmp$1;
				$s = -1; return [rest, err];
			}
			first = false;
			/* */ if (t.length > 2 && (t.charCodeAt(0) === 91) && (t.charCodeAt(1) === 58)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (t.length > 2 && (t.charCodeAt(0) === 91) && (t.charCodeAt(1) === 58)) { */ case 3:
				_r = p.parseNamedClass(t, class$1); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple$1 = _r;
				nclass = _tuple$1[0];
				nt = _tuple$1[1];
				err$1 = _tuple$1[2];
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					_tmp$2 = "";
					_tmp$3 = err$1;
					rest = _tmp$2;
					err = _tmp$3;
					$s = -1; return [rest, err];
				}
				if (!(nclass === sliceType.nil)) {
					_tmp$4 = nclass;
					_tmp$5 = nt;
					class$1 = _tmp$4;
					t = _tmp$5;
					/* continue; */ $s = 1; continue;
				}
			/* } */ case 4:
			_r$1 = p.parseUnicodeClass(t, class$1); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$2 = _r$1;
			nclass$1 = _tuple$2[0];
			nt$1 = _tuple$2[1];
			err$2 = _tuple$2[2];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				_tmp$6 = "";
				_tmp$7 = err$2;
				rest = _tmp$6;
				err = _tmp$7;
				$s = -1; return [rest, err];
			}
			/* */ if (!(nclass$1 === sliceType.nil)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!(nclass$1 === sliceType.nil)) { */ case 7:
				_tmp$8 = nclass$1;
				_tmp$9 = nt$1;
				class$1 = _tmp$8;
				t = _tmp$9;
				/* continue; */ $s = 1; continue;
			/* } */ case 8:
			_r$2 = p.parsePerlClassEscape(t, class$1); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple$3 = _r$2;
			nclass$2 = _tuple$3[0];
			nt$2 = _tuple$3[1];
			if (!(nclass$2 === sliceType.nil)) {
				_tmp$10 = nclass$2;
				_tmp$11 = nt$2;
				class$1 = _tmp$10;
				t = _tmp$11;
				/* continue; */ $s = 1; continue;
			}
			rng = t;
			_tmp$12 = 0;
			_tmp$13 = 0;
			lo = _tmp$12;
			hi = _tmp$13;
			_tuple$4 = p.parseClassChar(t, s);
			lo = _tuple$4[0];
			t = _tuple$4[1];
			err$2 = _tuple$4[2];
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				_tmp$14 = "";
				_tmp$15 = err$2;
				rest = _tmp$14;
				err = _tmp$15;
				$s = -1; return [rest, err];
			}
			hi = lo;
			if (t.length >= 2 && (t.charCodeAt(0) === 45) && !((t.charCodeAt(1) === 93))) {
				t = $substring(t, 1);
				_tuple$5 = p.parseClassChar(t, s);
				hi = _tuple$5[0];
				t = _tuple$5[1];
				err$2 = _tuple$5[2];
				if (!($interfaceIsEqual(err$2, $ifaceNil))) {
					_tmp$16 = "";
					_tmp$17 = err$2;
					rest = _tmp$16;
					err = _tmp$17;
					$s = -1; return [rest, err];
				}
				if (hi < lo) {
					rng = $substring(rng, 0, (rng.length - t.length >> 0));
					_tmp$18 = "";
					_tmp$19 = new Error.ptr("invalid character class range", rng);
					rest = _tmp$18;
					err = _tmp$19;
					$s = -1; return [rest, err];
				}
			}
			if (((p.flags & 1) >>> 0) === 0) {
				class$1 = appendRange(class$1, lo, hi);
			} else {
				class$1 = appendFoldedRange(class$1, lo, hi);
			}
		/* } */ $s = 1; continue; case 2:
		t = $substring(t, 1);
		re.Rune = class$1;
		_r$3 = cleanClass((re.$ptr_Rune || (re.$ptr_Rune = new ptrType$2(function() { return this.$target.Rune; }, function($v) { this.$target.Rune = $v; }, re)))); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		class$1 = _r$3;
		if (sign < 0) {
			class$1 = negateClass(class$1);
		}
		re.Rune = class$1;
		p.push(re);
		_tmp$20 = t;
		_tmp$21 = $ifaceNil;
		rest = _tmp$20;
		err = _tmp$21;
		$s = -1; return [rest, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseClass }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$18 = _tmp$18; $f._tmp$19 = _tmp$19; $f._tmp$2 = _tmp$2; $f._tmp$20 = _tmp$20; $f._tmp$21 = _tmp$21; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.class$1 = class$1; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.first = first; $f.hi = hi; $f.lo = lo; $f.nclass = nclass; $f.nclass$1 = nclass$1; $f.nclass$2 = nclass$2; $f.nt = nt; $f.nt$1 = nt$1; $f.nt$2 = nt$2; $f.p = p; $f.re = re; $f.rest = rest; $f.rng = rng; $f.s = s; $f.sign = sign; $f.size = size; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseClass = function(s) { return this.$val.parseClass(s); };
	cleanClass = function(rp) {
		var _tmp, _tmp$1, hi, i, lo, r, rp, w, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; hi = $f.hi; i = $f.i; lo = $f.lo; r = $f.r; rp = $f.rp; w = $f.w; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = sort.Sort((x = new ranges.ptr(rp), new x.constructor.elem(x))); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		r = rp.$get();
		if (r.$length < 2) {
			$s = -1; return r;
		}
		w = 2;
		i = 2;
		while (true) {
			if (!(i < r.$length)) { break; }
			_tmp = ((i < 0 || i >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + i]);
			_tmp$1 = (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$1]));
			lo = _tmp;
			hi = _tmp$1;
			if (lo <= ((x$2 = w - 1 >> 0, ((x$2 < 0 || x$2 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$2])) + 1 >> 0)) {
				if (hi > (x$3 = w - 1 >> 0, ((x$3 < 0 || x$3 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$3]))) {
					(x$4 = w - 1 >> 0, ((x$4 < 0 || x$4 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$4] = hi));
				}
				i = i + (2) >> 0;
				continue;
			}
			((w < 0 || w >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + w] = lo);
			(x$5 = w + 1 >> 0, ((x$5 < 0 || x$5 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$5] = hi));
			w = w + (2) >> 0;
			i = i + (2) >> 0;
		}
		$s = -1; return $subslice(r, 0, w);
		/* */ } return; } if ($f === undefined) { $f = { $blk: cleanClass }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.hi = hi; $f.i = i; $f.lo = lo; $f.r = r; $f.rp = rp; $f.w = w; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	appendLiteral = function(r, x, flags) {
		var flags, r, x;
		if (!((((flags & 1) >>> 0) === 0))) {
			return appendFoldedRange(r, x, x);
		}
		return appendRange(r, x, x);
	};
	appendRange = function(r, lo, hi) {
		var _tmp, _tmp$1, hi, i, lo, n, r, rhi, rlo, x, x$1, x$2, x$3;
		n = r.$length;
		i = 2;
		while (true) {
			if (!(i <= 4)) { break; }
			if (n >= i) {
				_tmp = (x = n - i >> 0, ((x < 0 || x >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x]));
				_tmp$1 = (x$1 = (n - i >> 0) + 1 >> 0, ((x$1 < 0 || x$1 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$1]));
				rlo = _tmp;
				rhi = _tmp$1;
				if (lo <= (rhi + 1 >> 0) && rlo <= (hi + 1 >> 0)) {
					if (lo < rlo) {
						(x$2 = n - i >> 0, ((x$2 < 0 || x$2 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$2] = lo));
					}
					if (hi > rhi) {
						(x$3 = (n - i >> 0) + 1 >> 0, ((x$3 < 0 || x$3 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$3] = hi));
					}
					return r;
				}
			}
			i = i + (2) >> 0;
		}
		return $append(r, lo, hi);
	};
	appendFoldedRange = function(r, lo, hi) {
		var c, f, hi, lo, r;
		if (lo <= 65 && hi >= 125251) {
			return appendRange(r, lo, hi);
		}
		if (hi < 65 || lo > 125251) {
			return appendRange(r, lo, hi);
		}
		if (lo < 65) {
			r = appendRange(r, lo, 64);
			lo = 65;
		}
		if (hi > 125251) {
			r = appendRange(r, 125252, hi);
			hi = 125251;
		}
		c = lo;
		while (true) {
			if (!(c <= hi)) { break; }
			r = appendRange(r, c, c);
			f = unicode.SimpleFold(c);
			while (true) {
				if (!(!((f === c)))) { break; }
				r = appendRange(r, f, f);
				f = unicode.SimpleFold(f);
			}
			c = c + (1) >> 0;
		}
		return r;
	};
	appendClass = function(r, x) {
		var i, r, x, x$1;
		i = 0;
		while (true) {
			if (!(i < x.$length)) { break; }
			r = appendRange(r, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])));
			i = i + (2) >> 0;
		}
		return r;
	};
	appendFoldedClass = function(r, x) {
		var i, r, x, x$1;
		i = 0;
		while (true) {
			if (!(i < x.$length)) { break; }
			r = appendFoldedRange(r, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]), (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])));
			i = i + (2) >> 0;
		}
		return r;
	};
	appendNegatedClass = function(r, x) {
		var _tmp, _tmp$1, hi, i, lo, nextLo, r, x, x$1;
		nextLo = 0;
		i = 0;
		while (true) {
			if (!(i < x.$length)) { break; }
			_tmp = ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]);
			_tmp$1 = (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			lo = _tmp;
			hi = _tmp$1;
			if (nextLo <= (lo - 1 >> 0)) {
				r = appendRange(r, nextLo, lo - 1 >> 0);
			}
			nextLo = hi + 1 >> 0;
			i = i + (2) >> 0;
		}
		if (nextLo <= 1114111) {
			r = appendRange(r, nextLo, 1114111);
		}
		return r;
	};
	appendTable = function(r, x) {
		var _i, _i$1, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, c, c$1, hi, hi$1, lo, lo$1, r, stride, stride$1, x, xr, xr$1;
		_ref = x.R16;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			xr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), unicode.Range16);
			_tmp = ((xr.Lo >> 0));
			_tmp$1 = ((xr.Hi >> 0));
			_tmp$2 = ((xr.Stride >> 0));
			lo = _tmp;
			hi = _tmp$1;
			stride = _tmp$2;
			if (stride === 1) {
				r = appendRange(r, lo, hi);
				_i++;
				continue;
			}
			c = lo;
			while (true) {
				if (!(c <= hi)) { break; }
				r = appendRange(r, c, c);
				c = c + (stride) >> 0;
			}
			_i++;
		}
		_ref$1 = x.R32;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			xr$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), unicode.Range32);
			_tmp$3 = ((xr$1.Lo >> 0));
			_tmp$4 = ((xr$1.Hi >> 0));
			_tmp$5 = ((xr$1.Stride >> 0));
			lo$1 = _tmp$3;
			hi$1 = _tmp$4;
			stride$1 = _tmp$5;
			if (stride$1 === 1) {
				r = appendRange(r, lo$1, hi$1);
				_i$1++;
				continue;
			}
			c$1 = lo$1;
			while (true) {
				if (!(c$1 <= hi$1)) { break; }
				r = appendRange(r, c$1, c$1);
				c$1 = c$1 + (stride$1) >> 0;
			}
			_i$1++;
		}
		return r;
	};
	appendNegatedTable = function(r, x) {
		var _i, _i$1, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, c, c$1, hi, hi$1, lo, lo$1, nextLo, r, stride, stride$1, x, xr, xr$1;
		nextLo = 0;
		_ref = x.R16;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			xr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), unicode.Range16);
			_tmp = ((xr.Lo >> 0));
			_tmp$1 = ((xr.Hi >> 0));
			_tmp$2 = ((xr.Stride >> 0));
			lo = _tmp;
			hi = _tmp$1;
			stride = _tmp$2;
			if (stride === 1) {
				if (nextLo <= (lo - 1 >> 0)) {
					r = appendRange(r, nextLo, lo - 1 >> 0);
				}
				nextLo = hi + 1 >> 0;
				_i++;
				continue;
			}
			c = lo;
			while (true) {
				if (!(c <= hi)) { break; }
				if (nextLo <= (c - 1 >> 0)) {
					r = appendRange(r, nextLo, c - 1 >> 0);
				}
				nextLo = c + 1 >> 0;
				c = c + (stride) >> 0;
			}
			_i++;
		}
		_ref$1 = x.R32;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			xr$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), unicode.Range32);
			_tmp$3 = ((xr$1.Lo >> 0));
			_tmp$4 = ((xr$1.Hi >> 0));
			_tmp$5 = ((xr$1.Stride >> 0));
			lo$1 = _tmp$3;
			hi$1 = _tmp$4;
			stride$1 = _tmp$5;
			if (stride$1 === 1) {
				if (nextLo <= (lo$1 - 1 >> 0)) {
					r = appendRange(r, nextLo, lo$1 - 1 >> 0);
				}
				nextLo = hi$1 + 1 >> 0;
				_i$1++;
				continue;
			}
			c$1 = lo$1;
			while (true) {
				if (!(c$1 <= hi$1)) { break; }
				if (nextLo <= (c$1 - 1 >> 0)) {
					r = appendRange(r, nextLo, c$1 - 1 >> 0);
				}
				nextLo = c$1 + 1 >> 0;
				c$1 = c$1 + (stride$1) >> 0;
			}
			_i$1++;
		}
		if (nextLo <= 1114111) {
			r = appendRange(r, nextLo, 1114111);
		}
		return r;
	};
	negateClass = function(r) {
		var _tmp, _tmp$1, hi, i, lo, nextLo, r, w, x, x$1;
		nextLo = 0;
		w = 0;
		i = 0;
		while (true) {
			if (!(i < r.$length)) { break; }
			_tmp = ((i < 0 || i >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + i]);
			_tmp$1 = (x = i + 1 >> 0, ((x < 0 || x >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x]));
			lo = _tmp;
			hi = _tmp$1;
			if (nextLo <= (lo - 1 >> 0)) {
				((w < 0 || w >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + w] = nextLo);
				(x$1 = w + 1 >> 0, ((x$1 < 0 || x$1 >= r.$length) ? ($throwRuntimeError("index out of range"), undefined) : r.$array[r.$offset + x$1] = (lo - 1 >> 0)));
				w = w + (2) >> 0;
			}
			nextLo = hi + 1 >> 0;
			i = i + (2) >> 0;
		}
		r = $subslice(r, 0, w);
		if (nextLo <= 1114111) {
			r = $append(r, nextLo, 1114111);
		}
		return r;
	};
	ranges.ptr.prototype.Less = function(i, j) {
		var i, j, p, ra, x, x$1;
		ra = this;
		p = ra.p.$get();
		i = $imul(i, (2));
		j = $imul(j, (2));
		return ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]) < ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j]) || (((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]) === ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j])) && (x = i + 1 >> 0, ((x < 0 || x >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x])) > (x$1 = j + 1 >> 0, ((x$1 < 0 || x$1 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$1]));
	};
	ranges.prototype.Less = function(i, j) { return this.$val.Less(i, j); };
	ranges.ptr.prototype.Len = function() {
		var _q, ra;
		ra = this;
		return (_q = ra.p.$get().$length / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
	};
	ranges.prototype.Len = function() { return this.$val.Len(); };
	ranges.ptr.prototype.Swap = function(i, j) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, i, j, p, ra, x, x$1, x$2, x$3;
		ra = this;
		p = ra.p.$get();
		i = $imul(i, (2));
		j = $imul(j, (2));
		_tmp = ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j]);
		_tmp$1 = (x = j + 1 >> 0, ((x < 0 || x >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x]));
		_tmp$2 = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]);
		_tmp$3 = (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$1]));
		((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i] = _tmp);
		(x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$2] = _tmp$1));
		((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j] = _tmp$2);
		(x$3 = j + 1 >> 0, ((x$3 < 0 || x$3 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$3] = _tmp$3));
	};
	ranges.prototype.Swap = function(i, j) { return this.$val.Swap(i, j); };
	checkUTF8 = function(s) {
		var _tuple, rune, s, size;
		while (true) {
			if (!(!(s === ""))) { break; }
			_tuple = utf8.DecodeRuneInString(s);
			rune = _tuple[0];
			size = _tuple[1];
			if ((rune === 65533) && (size === 1)) {
				return new Error.ptr("invalid UTF-8", s);
			}
			s = $substring(s, size);
		}
		return $ifaceNil;
	};
	nextRune = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, c, err, s, size, t;
		c = 0;
		t = "";
		err = $ifaceNil;
		_tuple = utf8.DecodeRuneInString(s);
		c = _tuple[0];
		size = _tuple[1];
		if ((c === 65533) && (size === 1)) {
			_tmp = 0;
			_tmp$1 = "";
			_tmp$2 = new Error.ptr("invalid UTF-8", s);
			c = _tmp;
			t = _tmp$1;
			err = _tmp$2;
			return [c, t, err];
		}
		_tmp$3 = c;
		_tmp$4 = $substring(s, size);
		_tmp$5 = $ifaceNil;
		c = _tmp$3;
		t = _tmp$4;
		err = _tmp$5;
		return [c, t, err];
	};
	isalnum = function(c) {
		var c;
		return 48 <= c && c <= 57 || 65 <= c && c <= 90 || 97 <= c && c <= 122;
	};
	unhex = function(c) {
		var c;
		if (48 <= c && c <= 57) {
			return c - 48 >> 0;
		}
		if (97 <= c && c <= 102) {
			return (c - 97 >> 0) + 10 >> 0;
		}
		if (65 <= c && c <= 70) {
			return (c - 65 >> 0) + 10 >> 0;
		}
		return -1;
	};
	InstOp.prototype.String = function() {
		var i;
		i = this.$val;
		if (((i >>> 0)) >= ((instOpNames.$length >>> 0))) {
			return "";
		}
		return ((i < 0 || i >= instOpNames.$length) ? ($throwRuntimeError("index out of range"), undefined) : instOpNames.$array[instOpNames.$offset + i]);
	};
	$ptrType(InstOp).prototype.String = function() { return new InstOp(this.$get()).String(); };
	IsWordChar = function(r) {
		var r;
		return 65 <= r && r <= 90 || 97 <= r && r <= 122 || 48 <= r && r <= 57 || (r === 95);
	};
	$pkg.IsWordChar = IsWordChar;
	Prog.ptr.prototype.String = function() {
		var b, p;
		p = this;
		b = new strings.Builder.ptr(ptrType$4.nil, sliceType$6.nil);
		dumpProg(b, p);
		return b.String();
	};
	Prog.prototype.String = function() { return this.$val.String(); };
	Prog.ptr.prototype.skipNop = function(pc) {
		var i, p, pc, x, x$1, x$2;
		p = this;
		i = (x = p.Inst, ((pc < 0 || pc >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pc]));
		while (true) {
			if (!((i.Op === 6) || (i.Op === 2))) { break; }
			i = (x$1 = p.Inst, x$2 = i.Out, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2]));
		}
		return i;
	};
	Prog.prototype.skipNop = function(pc) { return this.$val.skipNop(pc); };
	Inst.ptr.prototype.op = function() {
		var _1, i, op;
		i = this;
		op = i.Op;
		_1 = op;
		if ((_1 === (8)) || (_1 === (9)) || (_1 === (10))) {
			op = 7;
		}
		return op;
	};
	Inst.prototype.op = function() { return this.$val.op(); };
	Prog.ptr.prototype.Prefix = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, buf, complete, i, p, prefix, x;
		prefix = "";
		complete = false;
		p = this;
		i = p.skipNop(((p.Start >>> 0)));
		if (!((i.op() === 7)) || !((i.Rune.$length === 1))) {
			_tmp = "";
			_tmp$1 = i.Op === 4;
			prefix = _tmp;
			complete = _tmp$1;
			return [prefix, complete];
		}
		buf = new strings.Builder.ptr(ptrType$4.nil, sliceType$6.nil);
		while (true) {
			if (!((i.op() === 7) && (i.Rune.$length === 1) && (((((i.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { break; }
			buf.WriteRune((x = i.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])));
			i = p.skipNop(i.Out);
		}
		_tmp$2 = buf.String();
		_tmp$3 = i.Op === 4;
		prefix = _tmp$2;
		complete = _tmp$3;
		return [prefix, complete];
	};
	Prog.prototype.Prefix = function() { return this.$val.Prefix(); };
	Prog.ptr.prototype.StartCond = function() {
		var _1, flag, i, p, pc, x, x$1;
		p = this;
		flag = 0;
		pc = ((p.Start >>> 0));
		i = (x = p.Inst, ((pc < 0 || pc >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pc]));
		Loop:
		while (true) {
			_1 = i.Op;
			if (_1 === (3)) {
				flag = (flag | (((i.Arg << 24 >>> 24)))) >>> 0;
			} else if (_1 === (5)) {
				return 255;
			} else if ((_1 === (2)) || (_1 === (6))) {
			} else {
				break Loop;
			}
			pc = i.Out;
			i = (x$1 = p.Inst, ((pc < 0 || pc >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + pc]));
		}
		return flag;
	};
	Prog.prototype.StartCond = function() { return this.$val.StartCond(); };
	Inst.ptr.prototype.MatchRune = function(r) {
		var i, r;
		i = this;
		return !((i.MatchRunePos(r) === -1));
	};
	Inst.prototype.MatchRune = function(r) { return this.$val.MatchRune(r); };
	Inst.ptr.prototype.MatchRunePos = function(r) {
		var _1, _q, _q$1, _q$2, c, hi, i, j, lo, m, r, r0, r1, rune, x, x$1, x$2;
		i = this;
		rune = i.Rune;
		_1 = rune.$length;
		if (_1 === (0)) {
			return -1;
		} else if (_1 === (1)) {
			r0 = (0 >= rune.$length ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + 0]);
			if (r === r0) {
				return 0;
			}
			if (!((((((i.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) {
				r1 = unicode.SimpleFold(r0);
				while (true) {
					if (!(!((r1 === r0)))) { break; }
					if (r === r1) {
						return 0;
					}
					r1 = unicode.SimpleFold(r1);
				}
			}
			return -1;
		} else if (_1 === (2)) {
			if (r >= (0 >= rune.$length ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + 0]) && r <= (1 >= rune.$length ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + 1])) {
				return 0;
			}
			return -1;
		} else if ((_1 === (4)) || (_1 === (6)) || (_1 === (8))) {
			j = 0;
			while (true) {
				if (!(j < rune.$length)) { break; }
				if (r < ((j < 0 || j >= rune.$length) ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + j])) {
					return -1;
				}
				if (r <= (x = j + 1 >> 0, ((x < 0 || x >= rune.$length) ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + x]))) {
					return (_q = j / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
				}
				j = j + (2) >> 0;
			}
			return -1;
		}
		lo = 0;
		hi = (_q$1 = rune.$length / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"));
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q$2 = ((hi - lo >> 0)) / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			c = (x$1 = $imul(2, m), ((x$1 < 0 || x$1 >= rune.$length) ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + x$1]));
			if (c <= r) {
				if (r <= (x$2 = ($imul(2, m)) + 1 >> 0, ((x$2 < 0 || x$2 >= rune.$length) ? ($throwRuntimeError("index out of range"), undefined) : rune.$array[rune.$offset + x$2]))) {
					return m;
				}
				lo = m + 1 >> 0;
			} else {
				hi = m;
			}
		}
		return -1;
	};
	Inst.prototype.MatchRunePos = function(r) { return this.$val.MatchRunePos(r); };
	Inst.ptr.prototype.MatchEmptyWidth = function(before, after) {
		var _1, after, before, i;
		i = this;
		_1 = ((i.Arg << 24 >>> 24));
		if (_1 === (1)) {
			return (before === 10) || (before === -1);
		} else if (_1 === (2)) {
			return (after === 10) || (after === -1);
		} else if (_1 === (4)) {
			return before === -1;
		} else if (_1 === (8)) {
			return after === -1;
		} else if (_1 === (16)) {
			return !(IsWordChar(before) === IsWordChar(after));
		} else if (_1 === (32)) {
			return IsWordChar(before) === IsWordChar(after);
		}
		$panic(new $String("unknown empty width arg"));
	};
	Inst.prototype.MatchEmptyWidth = function(before, after) { return this.$val.MatchEmptyWidth(before, after); };
	Inst.ptr.prototype.String = function() {
		var b, i;
		i = this;
		b = new strings.Builder.ptr(ptrType$4.nil, sliceType$6.nil);
		dumpInst(b, i);
		return b.String();
	};
	Inst.prototype.String = function() { return this.$val.String(); };
	bw = function(b, args) {
		var _i, _ref, args, b, s;
		_ref = args;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			s = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			b.WriteString(s);
			_i++;
		}
	};
	dumpProg = function(b, p) {
		var _i, _ref, b, i, j, p, pc, x;
		_ref = p.Inst;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			j = _i;
			i = (x = p.Inst, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]));
			pc = strconv.Itoa(j);
			if (pc.length < 3) {
				b.WriteString($substring("   ", pc.length));
			}
			if (j === p.Start) {
				pc = pc + ("*");
			}
			bw(b, new sliceType$3([pc, "\t"]));
			dumpInst(b, i);
			bw(b, new sliceType$3(["\n"]));
			_i++;
		}
	};
	u32 = function(i) {
		var i;
		return strconv.FormatUint((new $Uint64(0, i)), 10);
	};
	dumpInst = function(b, i) {
		var _1, b, i;
		_1 = i.Op;
		if (_1 === (0)) {
			bw(b, new sliceType$3(["alt -> ", u32(i.Out), ", ", u32(i.Arg)]));
		} else if (_1 === (1)) {
			bw(b, new sliceType$3(["altmatch -> ", u32(i.Out), ", ", u32(i.Arg)]));
		} else if (_1 === (2)) {
			bw(b, new sliceType$3(["cap ", u32(i.Arg), " -> ", u32(i.Out)]));
		} else if (_1 === (3)) {
			bw(b, new sliceType$3(["empty ", u32(i.Arg), " -> ", u32(i.Out)]));
		} else if (_1 === (4)) {
			bw(b, new sliceType$3(["match"]));
		} else if (_1 === (5)) {
			bw(b, new sliceType$3(["fail"]));
		} else if (_1 === (6)) {
			bw(b, new sliceType$3(["nop -> ", u32(i.Out)]));
		} else if (_1 === (7)) {
			if (i.Rune === sliceType.nil) {
				bw(b, new sliceType$3(["rune <nil>"]));
			}
			bw(b, new sliceType$3(["rune ", strconv.QuoteToASCII(($runesToString(i.Rune)))]));
			if (!((((((i.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) {
				bw(b, new sliceType$3(["/i"]));
			}
			bw(b, new sliceType$3([" -> ", u32(i.Out)]));
		} else if (_1 === (8)) {
			bw(b, new sliceType$3(["rune1 ", strconv.QuoteToASCII(($runesToString(i.Rune))), " -> ", u32(i.Out)]));
		} else if (_1 === (9)) {
			bw(b, new sliceType$3(["any -> ", u32(i.Out)]));
		} else if (_1 === (10)) {
			bw(b, new sliceType$3(["anynotnl -> ", u32(i.Out)]));
		}
	};
	Regexp.ptr.prototype.Equal = function(y) {
		var _1, _i, _i$1, _ref, _ref$1, i, i$1, r, sub, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, y;
		x = this;
		if (x === ptrType$1.nil || y === ptrType$1.nil) {
			return x === y;
		}
		if (!((x.Op === y.Op))) {
			return false;
		}
		_1 = x.Op;
		if (_1 === (10)) {
			if (!((((x.Flags & 256) >>> 0) === ((y.Flags & 256) >>> 0)))) {
				return false;
			}
		} else if ((_1 === (3)) || (_1 === (4))) {
			if (!((x.Rune.$length === y.Rune.$length))) {
				return false;
			}
			_ref = x.Rune;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				r = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (!((r === (x$1 = y.Rune, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]))))) {
					return false;
				}
				_i++;
			}
		} else if ((_1 === (19)) || (_1 === (18))) {
			if (!((x.Sub.$length === y.Sub.$length))) {
				return false;
			}
			_ref$1 = x.Sub;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.$length)) { break; }
				i$1 = _i$1;
				sub = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
				if (!sub.Equal((x$2 = y.Sub, ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1])))) {
					return false;
				}
				_i$1++;
			}
		} else if ((_1 === (14)) || (_1 === (15)) || (_1 === (16))) {
			if (!((((x.Flags & 32) >>> 0) === ((y.Flags & 32) >>> 0))) || !(x$3 = x.Sub, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])).Equal((x$4 = y.Sub, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])))) {
				return false;
			}
		} else if (_1 === (17)) {
			if (!((((x.Flags & 32) >>> 0) === ((y.Flags & 32) >>> 0))) || !((x.Min === y.Min)) || !((x.Max === y.Max)) || !(x$5 = x.Sub, (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0])).Equal((x$6 = y.Sub, (0 >= x$6.$length ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + 0])))) {
				return false;
			}
		} else if (_1 === (13)) {
			if (!((x.Cap === y.Cap)) || !(x.Name === y.Name) || !(x$7 = x.Sub, (0 >= x$7.$length ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + 0])).Equal((x$8 = y.Sub, (0 >= x$8.$length ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + 0])))) {
				return false;
			}
		}
		return true;
	};
	Regexp.prototype.Equal = function(y) { return this.$val.Equal(y); };
	writeRegexp = function(b, re) {
		var _1, _2, _i, _i$1, _i$2, _r, _ref, _ref$1, _ref$2, _tmp, _tmp$1, _tmp$2, _tmp$3, b, hi, hi$1, i, i$1, i$2, lo, lo$1, r, re, sub, sub$1, sub$2, x, x$1, x$10, x$11, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		switch (0) { default:
			_1 = re.Op;
			if (_1 === (1)) {
				b.WriteString("[^\\x00-\\x{10FFFF}]");
			} else if (_1 === (2)) {
				b.WriteString("(?:)");
			} else if (_1 === (3)) {
				if (!((((re.Flags & 1) >>> 0) === 0))) {
					b.WriteString("(?i:");
				}
				_ref = re.Rune;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					r = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
					escape(b, r, false);
					_i++;
				}
				if (!((((re.Flags & 1) >>> 0) === 0))) {
					b.WriteString(")");
				}
			} else if (_1 === (4)) {
				if (!(((_r = re.Rune.$length % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0))) {
					b.WriteString("[invalid char class]");
					break;
				}
				b.WriteRune(91);
				if (re.Rune.$length === 0) {
					b.WriteString("^\\x00-\\x{10FFFF}");
				} else if (((x = re.Rune, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) === 0) && ((x$1 = re.Rune, x$2 = re.Rune.$length - 1 >> 0, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2])) === 1114111)) {
					b.WriteRune(94);
					i = 1;
					while (true) {
						if (!(i < (re.Rune.$length - 1 >> 0))) { break; }
						_tmp = (x$3 = re.Rune, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i])) + 1 >> 0;
						_tmp$1 = (x$4 = re.Rune, x$5 = i + 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])) - 1 >> 0;
						lo = _tmp;
						hi = _tmp$1;
						escape(b, lo, lo === 45);
						if (!((lo === hi))) {
							b.WriteRune(45);
							escape(b, hi, hi === 45);
						}
						i = i + (2) >> 0;
					}
				} else {
					i$1 = 0;
					while (true) {
						if (!(i$1 < re.Rune.$length)) { break; }
						_tmp$2 = (x$6 = re.Rune, ((i$1 < 0 || i$1 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + i$1]));
						_tmp$3 = (x$7 = re.Rune, x$8 = i$1 + 1 >> 0, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8]));
						lo$1 = _tmp$2;
						hi$1 = _tmp$3;
						escape(b, lo$1, lo$1 === 45);
						if (!((lo$1 === hi$1))) {
							b.WriteRune(45);
							escape(b, hi$1, hi$1 === 45);
						}
						i$1 = i$1 + (2) >> 0;
					}
				}
				b.WriteRune(93);
			} else if (_1 === (5)) {
				b.WriteString("(?-s:.)");
			} else if (_1 === (6)) {
				b.WriteString("(?s:.)");
			} else if (_1 === (7)) {
				b.WriteString("(?m:^)");
			} else if (_1 === (8)) {
				b.WriteString("(?m:$)");
			} else if (_1 === (9)) {
				b.WriteString("\\A");
			} else if (_1 === (10)) {
				if (!((((re.Flags & 256) >>> 0) === 0))) {
					b.WriteString("(?-m:$)");
				} else {
					b.WriteString("\\z");
				}
			} else if (_1 === (11)) {
				b.WriteString("\\b");
			} else if (_1 === (12)) {
				b.WriteString("\\B");
			} else if (_1 === (13)) {
				if (!(re.Name === "")) {
					b.WriteString("(?P<");
					b.WriteString(re.Name);
					b.WriteRune(62);
				} else {
					b.WriteRune(40);
				}
				if (!(((x$9 = re.Sub, (0 >= x$9.$length ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + 0])).Op === 2))) {
					writeRegexp(b, (x$10 = re.Sub, (0 >= x$10.$length ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + 0])));
				}
				b.WriteRune(41);
			} else if ((_1 === (14)) || (_1 === (15)) || (_1 === (16)) || (_1 === (17))) {
				sub = (x$11 = re.Sub, (0 >= x$11.$length ? ($throwRuntimeError("index out of range"), undefined) : x$11.$array[x$11.$offset + 0]));
				if (sub.Op > 13 || (sub.Op === 3) && sub.Rune.$length > 1) {
					b.WriteString("(?:");
					writeRegexp(b, sub);
					b.WriteString(")");
				} else {
					writeRegexp(b, sub);
				}
				_2 = re.Op;
				if (_2 === (14)) {
					b.WriteRune(42);
				} else if (_2 === (15)) {
					b.WriteRune(43);
				} else if (_2 === (16)) {
					b.WriteRune(63);
				} else if (_2 === (17)) {
					b.WriteRune(123);
					b.WriteString(strconv.Itoa(re.Min));
					if (!((re.Max === re.Min))) {
						b.WriteRune(44);
						if (re.Max >= 0) {
							b.WriteString(strconv.Itoa(re.Max));
						}
					}
					b.WriteRune(125);
				}
				if (!((((re.Flags & 32) >>> 0) === 0))) {
					b.WriteRune(63);
				}
			} else if (_1 === (18)) {
				_ref$1 = re.Sub;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					sub$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
					if (sub$1.Op === 19) {
						b.WriteString("(?:");
						writeRegexp(b, sub$1);
						b.WriteString(")");
					} else {
						writeRegexp(b, sub$1);
					}
					_i$1++;
				}
			} else if (_1 === (19)) {
				_ref$2 = re.Sub;
				_i$2 = 0;
				while (true) {
					if (!(_i$2 < _ref$2.$length)) { break; }
					i$2 = _i$2;
					sub$2 = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
					if (i$2 > 0) {
						b.WriteRune(124);
					}
					writeRegexp(b, sub$2);
					_i$2++;
				}
			} else {
				b.WriteString("<invalid op" + strconv.Itoa(((re.Op >> 0))) + ">");
			}
		}
	};
	Regexp.ptr.prototype.String = function() {
		var b, re;
		re = this;
		b = new strings.Builder.ptr(ptrType$4.nil, sliceType$6.nil);
		writeRegexp(b, re);
		return b.String();
	};
	Regexp.prototype.String = function() { return this.$val.String(); };
	escape = function(b, r, force) {
		var _1, b, force, r, s;
		if (unicode.IsPrint(r)) {
			if (strings.ContainsRune("\\.+*?()|[]{}^$", r) || force) {
				b.WriteRune(92);
			}
			b.WriteRune(r);
			return;
		}
		switch (0) { default:
			_1 = r;
			if (_1 === (7)) {
				b.WriteString("\\a");
			} else if (_1 === (12)) {
				b.WriteString("\\f");
			} else if (_1 === (10)) {
				b.WriteString("\\n");
			} else if (_1 === (13)) {
				b.WriteString("\\r");
			} else if (_1 === (9)) {
				b.WriteString("\\t");
			} else if (_1 === (11)) {
				b.WriteString("\\v");
			} else {
				if (r < 256) {
					b.WriteString("\\x");
					s = strconv.FormatInt((new $Int64(0, r)), 16);
					if (s.length === 1) {
						b.WriteRune(48);
					}
					b.WriteString(s);
					break;
				}
				b.WriteString("\\x{");
				b.WriteString(strconv.FormatInt((new $Int64(0, r)), 16));
				b.WriteString("}");
			}
		}
	};
	Regexp.ptr.prototype.MaxCap = function() {
		var _i, _ref, m, n, re, sub;
		re = this;
		m = 0;
		if (re.Op === 13) {
			m = re.Cap;
		}
		_ref = re.Sub;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			sub = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			n = sub.MaxCap();
			if (m < n) {
				m = n;
			}
			_i++;
		}
		return m;
	};
	Regexp.prototype.MaxCap = function() { return this.$val.MaxCap(); };
	Regexp.ptr.prototype.CapNames = function() {
		var names, re;
		re = this;
		names = $makeSlice(sliceType$3, (re.MaxCap() + 1 >> 0));
		re.capNames(names);
		return names;
	};
	Regexp.prototype.CapNames = function() { return this.$val.CapNames(); };
	Regexp.ptr.prototype.capNames = function(names) {
		var _i, _ref, names, re, sub, x;
		re = this;
		if (re.Op === 13) {
			(x = re.Cap, ((x < 0 || x >= names.$length) ? ($throwRuntimeError("index out of range"), undefined) : names.$array[names.$offset + x] = re.Name));
		}
		_ref = re.Sub;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			sub = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			sub.capNames(names);
			_i++;
		}
	};
	Regexp.prototype.capNames = function(names) { return this.$val.capNames(names); };
	Regexp.ptr.prototype.Simplify = function() {
		var _1, _i, _ref, i, i$1, i$2, i$3, nre, nre$1, nre2, nsub, prefix, re, sub, sub$1, sub$2, suffix, x, x$1;
		re = this;
		if (re === ptrType$1.nil) {
			return ptrType$1.nil;
		}
		_1 = re.Op;
		if ((_1 === (13)) || (_1 === (18)) || (_1 === (19))) {
			nre = re;
			_ref = re.Sub;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				sub = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				nsub = sub.Simplify();
				if (nre === re && !(nsub === sub)) {
					nre = new Regexp.ptr(0, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
					Regexp.copy(nre, re);
					nre.Rune = sliceType.nil;
					nre.Sub = $appendSlice($subslice(new sliceType$5(nre.Sub0), 0, 0), $subslice(re.Sub, 0, i));
				}
				if (!(nre === re)) {
					nre.Sub = $append(nre.Sub, nsub);
				}
				_i++;
			}
			return nre;
		} else if ((_1 === (14)) || (_1 === (15)) || (_1 === (16))) {
			sub$1 = (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])).Simplify();
			return simplify1(re.Op, re.Flags, sub$1, re);
		} else if (_1 === (17)) {
			if ((re.Min === 0) && (re.Max === 0)) {
				return new Regexp.ptr(2, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
			}
			sub$2 = (x$1 = re.Sub, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])).Simplify();
			if (re.Max === -1) {
				if (re.Min === 0) {
					return simplify1(14, re.Flags, sub$2, ptrType$1.nil);
				}
				if (re.Min === 1) {
					return simplify1(15, re.Flags, sub$2, ptrType$1.nil);
				}
				nre$1 = new Regexp.ptr(18, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
				nre$1.Sub = $subslice(new sliceType$5(nre$1.Sub0), 0, 0);
				i$1 = 0;
				while (true) {
					if (!(i$1 < (re.Min - 1 >> 0))) { break; }
					nre$1.Sub = $append(nre$1.Sub, sub$2);
					i$1 = i$1 + (1) >> 0;
				}
				nre$1.Sub = $append(nre$1.Sub, simplify1(15, re.Flags, sub$2, ptrType$1.nil));
				return nre$1;
			}
			if ((re.Min === 1) && (re.Max === 1)) {
				return sub$2;
			}
			prefix = ptrType$1.nil;
			if (re.Min > 0) {
				prefix = new Regexp.ptr(18, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
				prefix.Sub = $subslice(new sliceType$5(prefix.Sub0), 0, 0);
				i$2 = 0;
				while (true) {
					if (!(i$2 < re.Min)) { break; }
					prefix.Sub = $append(prefix.Sub, sub$2);
					i$2 = i$2 + (1) >> 0;
				}
			}
			if (re.Max > re.Min) {
				suffix = simplify1(16, re.Flags, sub$2, ptrType$1.nil);
				i$3 = re.Min + 1 >> 0;
				while (true) {
					if (!(i$3 < re.Max)) { break; }
					nre2 = new Regexp.ptr(18, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
					nre2.Sub = $append($subslice(new sliceType$5(nre2.Sub0), 0, 0), sub$2, suffix);
					suffix = simplify1(16, re.Flags, nre2, ptrType$1.nil);
					i$3 = i$3 + (1) >> 0;
				}
				if (prefix === ptrType$1.nil) {
					return suffix;
				}
				prefix.Sub = $append(prefix.Sub, suffix);
			}
			if (!(prefix === ptrType$1.nil)) {
				return prefix;
			}
			return new Regexp.ptr(1, 0, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
		}
		return re;
	};
	Regexp.prototype.Simplify = function() { return this.$val.Simplify(); };
	simplify1 = function(op, flags, sub, re) {
		var flags, op, re, sub, x;
		if (sub.Op === 2) {
			return sub;
		}
		if ((op === sub.Op) && (((flags & 32) >>> 0) === ((sub.Flags & 32) >>> 0))) {
			return sub;
		}
		if (!(re === ptrType$1.nil) && (re.Op === op) && (((re.Flags & 32) >>> 0) === ((flags & 32) >>> 0)) && sub === (x = re.Sub, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]))) {
			return re;
		}
		re = new Regexp.ptr(op, flags, sliceType$5.nil, arrayType.zero(), sliceType.nil, arrayType$1.zero(), 0, 0, 0, "");
		re.Sub = $append($subslice(new sliceType$5(re.Sub0), 0, 0), sub);
		return re;
	};
	patchList.methods = [{prop: "next", name: "next", pkg: "regexp/syntax", typ: $funcType([ptrType], [patchList], false)}, {prop: "patch", name: "patch", pkg: "regexp/syntax", typ: $funcType([ptrType, $Uint32], [], false)}, {prop: "append", name: "append", pkg: "regexp/syntax", typ: $funcType([ptrType, patchList], [patchList], false)}];
	ptrType$5.methods = [{prop: "init", name: "init", pkg: "regexp/syntax", typ: $funcType([], [], false)}, {prop: "compile", name: "compile", pkg: "regexp/syntax", typ: $funcType([ptrType$1], [frag], false)}, {prop: "inst", name: "inst", pkg: "regexp/syntax", typ: $funcType([InstOp], [frag], false)}, {prop: "nop", name: "nop", pkg: "regexp/syntax", typ: $funcType([], [frag], false)}, {prop: "fail", name: "fail", pkg: "regexp/syntax", typ: $funcType([], [frag], false)}, {prop: "cap", name: "cap", pkg: "regexp/syntax", typ: $funcType([$Uint32], [frag], false)}, {prop: "cat", name: "cat", pkg: "regexp/syntax", typ: $funcType([frag, frag], [frag], false)}, {prop: "alt", name: "alt", pkg: "regexp/syntax", typ: $funcType([frag, frag], [frag], false)}, {prop: "quest", name: "quest", pkg: "regexp/syntax", typ: $funcType([frag, $Bool], [frag], false)}, {prop: "star", name: "star", pkg: "regexp/syntax", typ: $funcType([frag, $Bool], [frag], false)}, {prop: "plus", name: "plus", pkg: "regexp/syntax", typ: $funcType([frag, $Bool], [frag], false)}, {prop: "empty", name: "empty", pkg: "regexp/syntax", typ: $funcType([EmptyOp], [frag], false)}, {prop: "rune", name: "rune", pkg: "regexp/syntax", typ: $funcType([sliceType, Flags], [frag], false)}];
	ptrType$6.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	ErrorCode.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$7.methods = [{prop: "newRegexp", name: "newRegexp", pkg: "regexp/syntax", typ: $funcType([Op], [ptrType$1], false)}, {prop: "reuse", name: "reuse", pkg: "regexp/syntax", typ: $funcType([ptrType$1], [], false)}, {prop: "push", name: "push", pkg: "regexp/syntax", typ: $funcType([ptrType$1], [ptrType$1], false)}, {prop: "maybeConcat", name: "maybeConcat", pkg: "regexp/syntax", typ: $funcType([$Int32, Flags], [$Bool], false)}, {prop: "newLiteral", name: "newLiteral", pkg: "regexp/syntax", typ: $funcType([$Int32, Flags], [ptrType$1], false)}, {prop: "literal", name: "literal", pkg: "regexp/syntax", typ: $funcType([$Int32], [], false)}, {prop: "op", name: "op", pkg: "regexp/syntax", typ: $funcType([Op], [ptrType$1], false)}, {prop: "repeat", name: "repeat", pkg: "regexp/syntax", typ: $funcType([Op, $Int, $Int, $String, $String, $String], [$String, $error], false)}, {prop: "concat", name: "concat", pkg: "regexp/syntax", typ: $funcType([], [ptrType$1], false)}, {prop: "alternate", name: "alternate", pkg: "regexp/syntax", typ: $funcType([], [ptrType$1], false)}, {prop: "collapse", name: "collapse", pkg: "regexp/syntax", typ: $funcType([sliceType$5, Op], [ptrType$1], false)}, {prop: "factor", name: "factor", pkg: "regexp/syntax", typ: $funcType([sliceType$5], [sliceType$5], false)}, {prop: "leadingString", name: "leadingString", pkg: "regexp/syntax", typ: $funcType([ptrType$1], [sliceType, Flags], false)}, {prop: "removeLeadingString", name: "removeLeadingString", pkg: "regexp/syntax", typ: $funcType([ptrType$1, $Int], [ptrType$1], false)}, {prop: "leadingRegexp", name: "leadingRegexp", pkg: "regexp/syntax", typ: $funcType([ptrType$1], [ptrType$1], false)}, {prop: "removeLeadingRegexp", name: "removeLeadingRegexp", pkg: "regexp/syntax", typ: $funcType([ptrType$1, $Bool], [ptrType$1], false)}, {prop: "parseRepeat", name: "parseRepeat", pkg: "regexp/syntax", typ: $funcType([$String], [$Int, $Int, $String, $Bool], false)}, {prop: "parsePerlFlags", name: "parsePerlFlags", pkg: "regexp/syntax", typ: $funcType([$String], [$String, $error], false)}, {prop: "parseInt", name: "parseInt", pkg: "regexp/syntax", typ: $funcType([$String], [$Int, $String, $Bool], false)}, {prop: "parseVerticalBar", name: "parseVerticalBar", pkg: "regexp/syntax", typ: $funcType([], [$error], false)}, {prop: "swapVerticalBar", name: "swapVerticalBar", pkg: "regexp/syntax", typ: $funcType([], [$Bool], false)}, {prop: "parseRightParen", name: "parseRightParen", pkg: "regexp/syntax", typ: $funcType([], [$error], false)}, {prop: "parseEscape", name: "parseEscape", pkg: "regexp/syntax", typ: $funcType([$String], [$Int32, $String, $error], false)}, {prop: "parseClassChar", name: "parseClassChar", pkg: "regexp/syntax", typ: $funcType([$String, $String], [$Int32, $String, $error], false)}, {prop: "parsePerlClassEscape", name: "parsePerlClassEscape", pkg: "regexp/syntax", typ: $funcType([$String, sliceType], [sliceType, $String], false)}, {prop: "parseNamedClass", name: "parseNamedClass", pkg: "regexp/syntax", typ: $funcType([$String, sliceType], [sliceType, $String, $error], false)}, {prop: "appendGroup", name: "appendGroup", pkg: "regexp/syntax", typ: $funcType([sliceType, charGroup], [sliceType], false)}, {prop: "parseUnicodeClass", name: "parseUnicodeClass", pkg: "regexp/syntax", typ: $funcType([$String, sliceType], [sliceType, $String, $error], false)}, {prop: "parseClass", name: "parseClass", pkg: "regexp/syntax", typ: $funcType([$String], [$String, $error], false)}];
	ranges.methods = [{prop: "Less", name: "Less", pkg: "", typ: $funcType([$Int, $Int], [$Bool], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Swap", name: "Swap", pkg: "", typ: $funcType([$Int, $Int], [], false)}];
	ptrType.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "skipNop", name: "skipNop", pkg: "regexp/syntax", typ: $funcType([$Uint32], [ptrType$8], false)}, {prop: "Prefix", name: "Prefix", pkg: "", typ: $funcType([], [$String, $Bool], false)}, {prop: "StartCond", name: "StartCond", pkg: "", typ: $funcType([], [EmptyOp], false)}];
	InstOp.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$8.methods = [{prop: "op", name: "op", pkg: "regexp/syntax", typ: $funcType([], [InstOp], false)}, {prop: "MatchRune", name: "MatchRune", pkg: "", typ: $funcType([$Int32], [$Bool], false)}, {prop: "MatchRunePos", name: "MatchRunePos", pkg: "", typ: $funcType([$Int32], [$Int], false)}, {prop: "MatchEmptyWidth", name: "MatchEmptyWidth", pkg: "", typ: $funcType([$Int32, $Int32], [$Bool], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$1.methods = [{prop: "Equal", name: "Equal", pkg: "", typ: $funcType([ptrType$1], [$Bool], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "MaxCap", name: "MaxCap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "CapNames", name: "CapNames", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "capNames", name: "capNames", pkg: "regexp/syntax", typ: $funcType([sliceType$3], [], false)}, {prop: "Simplify", name: "Simplify", pkg: "", typ: $funcType([], [ptrType$1], false)}];
	Op.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	frag.init("regexp/syntax", [{prop: "i", name: "i", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "out", name: "out", embedded: false, exported: false, typ: patchList, tag: ""}]);
	compiler.init("regexp/syntax", [{prop: "p", name: "p", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	Error.init("", [{prop: "Code", name: "Code", embedded: false, exported: true, typ: ErrorCode, tag: ""}, {prop: "Expr", name: "Expr", embedded: false, exported: true, typ: $String, tag: ""}]);
	parser.init("regexp/syntax", [{prop: "flags", name: "flags", embedded: false, exported: false, typ: Flags, tag: ""}, {prop: "stack", name: "stack", embedded: false, exported: false, typ: sliceType$5, tag: ""}, {prop: "free", name: "free", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "numCap", name: "numCap", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "wholeRegexp", name: "wholeRegexp", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "tmpClass", name: "tmpClass", embedded: false, exported: false, typ: sliceType, tag: ""}]);
	charGroup.init("regexp/syntax", [{prop: "sign", name: "sign", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "class$1", name: "class", embedded: false, exported: false, typ: sliceType, tag: ""}]);
	ranges.init("regexp/syntax", [{prop: "p", name: "p", embedded: false, exported: false, typ: ptrType$2, tag: ""}]);
	Prog.init("", [{prop: "Inst", name: "Inst", embedded: false, exported: true, typ: sliceType$4, tag: ""}, {prop: "Start", name: "Start", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "NumCap", name: "NumCap", embedded: false, exported: true, typ: $Int, tag: ""}]);
	Inst.init("", [{prop: "Op", name: "Op", embedded: false, exported: true, typ: InstOp, tag: ""}, {prop: "Out", name: "Out", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Arg", name: "Arg", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Rune", name: "Rune", embedded: false, exported: true, typ: sliceType, tag: ""}]);
	Regexp.init("", [{prop: "Op", name: "Op", embedded: false, exported: true, typ: Op, tag: ""}, {prop: "Flags", name: "Flags", embedded: false, exported: true, typ: Flags, tag: ""}, {prop: "Sub", name: "Sub", embedded: false, exported: true, typ: sliceType$5, tag: ""}, {prop: "Sub0", name: "Sub0", embedded: false, exported: true, typ: arrayType, tag: ""}, {prop: "Rune", name: "Rune", embedded: false, exported: true, typ: sliceType, tag: ""}, {prop: "Rune0", name: "Rune0", embedded: false, exported: true, typ: arrayType$1, tag: ""}, {prop: "Min", name: "Min", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Max", name: "Max", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Cap", name: "Cap", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Name", name: "Name", embedded: false, exported: true, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = sort.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		anyRuneNotNL = new sliceType([0, 9, 11, 1114111]);
		anyRune = new sliceType([0, 1114111]);
		_Op_index_0 = $toNativeArray($kindUint8, [0, 7, 17, 24, 33, 45, 52, 61, 68, 77, 84, 96, 110, 117, 121, 125, 130, 136, 142, 151]);
		anyTable = new unicode.RangeTable.ptr(new sliceType$1([new unicode.Range16.ptr(0, 65535, 1)]), new sliceType$2([new unicode.Range32.ptr(65536, 1114111, 1)]), 0);
		code1 = new sliceType([48, 57]);
		code2 = new sliceType([9, 10, 12, 13, 32, 32]);
		code3 = new sliceType([48, 57, 65, 90, 95, 95, 97, 122]);
		perlGroup = $makeMap($String.keyFor, [{ k: "\\d", v: new charGroup.ptr(1, code1) }, { k: "\\D", v: new charGroup.ptr(-1, code1) }, { k: "\\s", v: new charGroup.ptr(1, code2) }, { k: "\\S", v: new charGroup.ptr(-1, code2) }, { k: "\\w", v: new charGroup.ptr(1, code3) }, { k: "\\W", v: new charGroup.ptr(-1, code3) }]);
		code4 = new sliceType([48, 57, 65, 90, 97, 122]);
		code5 = new sliceType([65, 90, 97, 122]);
		code6 = new sliceType([0, 127]);
		code7 = new sliceType([9, 9, 32, 32]);
		code8 = new sliceType([0, 31, 127, 127]);
		code9 = new sliceType([48, 57]);
		code10 = new sliceType([33, 126]);
		code11 = new sliceType([97, 122]);
		code12 = new sliceType([32, 126]);
		code13 = new sliceType([33, 47, 58, 64, 91, 96, 123, 126]);
		code14 = new sliceType([9, 13, 32, 32]);
		code15 = new sliceType([65, 90]);
		code16 = new sliceType([48, 57, 65, 90, 95, 95, 97, 122]);
		code17 = new sliceType([48, 57, 65, 70, 97, 102]);
		posixGroup = $makeMap($String.keyFor, [{ k: "[:alnum:]", v: new charGroup.ptr(1, code4) }, { k: "[:^alnum:]", v: new charGroup.ptr(-1, code4) }, { k: "[:alpha:]", v: new charGroup.ptr(1, code5) }, { k: "[:^alpha:]", v: new charGroup.ptr(-1, code5) }, { k: "[:ascii:]", v: new charGroup.ptr(1, code6) }, { k: "[:^ascii:]", v: new charGroup.ptr(-1, code6) }, { k: "[:blank:]", v: new charGroup.ptr(1, code7) }, { k: "[:^blank:]", v: new charGroup.ptr(-1, code7) }, { k: "[:cntrl:]", v: new charGroup.ptr(1, code8) }, { k: "[:^cntrl:]", v: new charGroup.ptr(-1, code8) }, { k: "[:digit:]", v: new charGroup.ptr(1, code9) }, { k: "[:^digit:]", v: new charGroup.ptr(-1, code9) }, { k: "[:graph:]", v: new charGroup.ptr(1, code10) }, { k: "[:^graph:]", v: new charGroup.ptr(-1, code10) }, { k: "[:lower:]", v: new charGroup.ptr(1, code11) }, { k: "[:^lower:]", v: new charGroup.ptr(-1, code11) }, { k: "[:print:]", v: new charGroup.ptr(1, code12) }, { k: "[:^print:]", v: new charGroup.ptr(-1, code12) }, { k: "[:punct:]", v: new charGroup.ptr(1, code13) }, { k: "[:^punct:]", v: new charGroup.ptr(-1, code13) }, { k: "[:space:]", v: new charGroup.ptr(1, code14) }, { k: "[:^space:]", v: new charGroup.ptr(-1, code14) }, { k: "[:upper:]", v: new charGroup.ptr(1, code15) }, { k: "[:^upper:]", v: new charGroup.ptr(-1, code15) }, { k: "[:word:]", v: new charGroup.ptr(1, code16) }, { k: "[:^word:]", v: new charGroup.ptr(-1, code16) }, { k: "[:xdigit:]", v: new charGroup.ptr(1, code17) }, { k: "[:^xdigit:]", v: new charGroup.ptr(-1, code17) }]);
		instOpNames = new sliceType$3(["InstAlt", "InstAltMatch", "InstCapture", "InstEmptyWidth", "InstMatch", "InstFail", "InstNop", "InstRune", "InstRune1", "InstRuneAny", "InstRuneAnyNotNL"]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["regexp"] = (function() {
	var $pkg = {}, $init, bytes, nosync, io, syntax, sort, strconv, strings, unicode, utf8, job, bitState, queue, entry, thread, machine, inputs, lazyFlag, onePassMachine, onePassProg, onePassInst, queueOnePass, runeSlice, Regexp, input, inputString, inputBytes, inputReader, sliceType, arrayType, arrayType$1, arrayType$2, sliceType$1, sliceType$2, ptrType, sliceType$3, sliceType$4, sliceType$5, ptrType$1, ptrType$2, ptrType$3, ptrType$4, ptrType$5, ptrType$6, ptrType$7, ptrType$8, sliceType$6, ptrType$9, sliceType$7, ptrType$10, sliceType$8, ptrType$11, ptrType$12, sliceType$9, ptrType$13, sliceType$10, sliceType$11, arrayType$3, arrayType$4, sliceType$12, sliceType$13, sliceType$14, sliceType$15, ptrType$14, ptrType$15, funcType, funcType$1, funcType$2, funcType$3, ptrType$16, ptrType$17, ptrType$18, bitStatePool, onePassPool, arrayNoInts, noRune, noNext, anyRuneNotNL, anyRune, matchSize, matchPool, specialBytes, newBitState, freeBitState, maxBitStateLen, shouldBacktrack, newLazyFlag, newOnePassMachine, freeOnePassMachine, onePassPrefix, onePassNext, iop, newQueue, mergeRuneSets, cleanupOnePass, onePassCopy, makeOnePass, compileOnePass, Compile, compile, MustCompile, quote, init, extract;
	bytes = $packages["bytes"];
	nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
	io = $packages["io"];
	syntax = $packages["regexp/syntax"];
	sort = $packages["sort"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	job = $pkg.job = $newType(0, $kindStruct, "regexp.job", true, "regexp", false, function(pc_, arg_, pos_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.pc = 0;
			this.arg = false;
			this.pos = 0;
			return;
		}
		this.pc = pc_;
		this.arg = arg_;
		this.pos = pos_;
	});
	bitState = $pkg.bitState = $newType(0, $kindStruct, "regexp.bitState", true, "regexp", false, function(end_, cap_, matchcap_, jobs_, visited_, inputs_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.end = 0;
			this.cap = sliceType$3.nil;
			this.matchcap = sliceType$3.nil;
			this.jobs = sliceType$4.nil;
			this.visited = sliceType$2.nil;
			this.inputs = new inputs.ptr(new inputBytes.ptr(sliceType$5.nil), new inputString.ptr(""), new inputReader.ptr($ifaceNil, false, 0));
			return;
		}
		this.end = end_;
		this.cap = cap_;
		this.matchcap = matchcap_;
		this.jobs = jobs_;
		this.visited = visited_;
		this.inputs = inputs_;
	});
	queue = $pkg.queue = $newType(0, $kindStruct, "regexp.queue", true, "regexp", false, function(sparse_, dense_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.sparse = sliceType$2.nil;
			this.dense = sliceType$10.nil;
			return;
		}
		this.sparse = sparse_;
		this.dense = dense_;
	});
	entry = $pkg.entry = $newType(0, $kindStruct, "regexp.entry", true, "regexp", false, function(pc_, t_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.pc = 0;
			this.t = ptrType$1.nil;
			return;
		}
		this.pc = pc_;
		this.t = t_;
	});
	thread = $pkg.thread = $newType(0, $kindStruct, "regexp.thread", true, "regexp", false, function(inst_, cap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.inst = ptrType$2.nil;
			this.cap = sliceType$3.nil;
			return;
		}
		this.inst = inst_;
		this.cap = cap_;
	});
	machine = $pkg.machine = $newType(0, $kindStruct, "regexp.machine", true, "regexp", false, function(re_, p_, q0_, q1_, pool_, matched_, matchcap_, inputs_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.re = ptrType$11.nil;
			this.p = ptrType$12.nil;
			this.q0 = new queue.ptr(sliceType$2.nil, sliceType$10.nil);
			this.q1 = new queue.ptr(sliceType$2.nil, sliceType$10.nil);
			this.pool = sliceType$11.nil;
			this.matched = false;
			this.matchcap = sliceType$3.nil;
			this.inputs = new inputs.ptr(new inputBytes.ptr(sliceType$5.nil), new inputString.ptr(""), new inputReader.ptr($ifaceNil, false, 0));
			return;
		}
		this.re = re_;
		this.p = p_;
		this.q0 = q0_;
		this.q1 = q1_;
		this.pool = pool_;
		this.matched = matched_;
		this.matchcap = matchcap_;
		this.inputs = inputs_;
	});
	inputs = $pkg.inputs = $newType(0, $kindStruct, "regexp.inputs", true, "regexp", false, function(bytes_, string_, reader_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.bytes = new inputBytes.ptr(sliceType$5.nil);
			this.string = new inputString.ptr("");
			this.reader = new inputReader.ptr($ifaceNil, false, 0);
			return;
		}
		this.bytes = bytes_;
		this.string = string_;
		this.reader = reader_;
	});
	lazyFlag = $pkg.lazyFlag = $newType(8, $kindUint64, "regexp.lazyFlag", true, "regexp", false, null);
	onePassMachine = $pkg.onePassMachine = $newType(0, $kindStruct, "regexp.onePassMachine", true, "regexp", false, function(inputs_, matchcap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.inputs = new inputs.ptr(new inputBytes.ptr(sliceType$5.nil), new inputString.ptr(""), new inputReader.ptr($ifaceNil, false, 0));
			this.matchcap = sliceType$3.nil;
			return;
		}
		this.inputs = inputs_;
		this.matchcap = matchcap_;
	});
	onePassProg = $pkg.onePassProg = $newType(0, $kindStruct, "regexp.onePassProg", true, "regexp", false, function(Inst_, Start_, NumCap_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Inst = sliceType$6.nil;
			this.Start = 0;
			this.NumCap = 0;
			return;
		}
		this.Inst = Inst_;
		this.Start = Start_;
		this.NumCap = NumCap_;
	});
	onePassInst = $pkg.onePassInst = $newType(0, $kindStruct, "regexp.onePassInst", true, "regexp", false, function(Inst_, Next_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Inst = new syntax.Inst.ptr(0, 0, 0, sliceType$1.nil);
			this.Next = sliceType$2.nil;
			return;
		}
		this.Inst = Inst_;
		this.Next = Next_;
	});
	queueOnePass = $pkg.queueOnePass = $newType(0, $kindStruct, "regexp.queueOnePass", true, "regexp", false, function(sparse_, dense_, size_, nextIndex_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.sparse = sliceType$2.nil;
			this.dense = sliceType$2.nil;
			this.size = 0;
			this.nextIndex = 0;
			return;
		}
		this.sparse = sparse_;
		this.dense = dense_;
		this.size = size_;
		this.nextIndex = nextIndex_;
	});
	runeSlice = $pkg.runeSlice = $newType(12, $kindSlice, "regexp.runeSlice", true, "regexp", false, null);
	Regexp = $pkg.Regexp = $newType(0, $kindStruct, "regexp.Regexp", true, "regexp", true, function(expr_, prog_, onepass_, numSubexp_, maxBitStateLen_, subexpNames_, prefix_, prefixBytes_, prefixRune_, prefixEnd_, mpool_, matchcap_, prefixComplete_, cond_, longest_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.expr = "";
			this.prog = ptrType$12.nil;
			this.onepass = ptrType$6.nil;
			this.numSubexp = 0;
			this.maxBitStateLen = 0;
			this.subexpNames = sliceType$9.nil;
			this.prefix = "";
			this.prefixBytes = sliceType$5.nil;
			this.prefixRune = 0;
			this.prefixEnd = 0;
			this.mpool = 0;
			this.matchcap = 0;
			this.prefixComplete = false;
			this.cond = 0;
			this.longest = false;
			return;
		}
		this.expr = expr_;
		this.prog = prog_;
		this.onepass = onepass_;
		this.numSubexp = numSubexp_;
		this.maxBitStateLen = maxBitStateLen_;
		this.subexpNames = subexpNames_;
		this.prefix = prefix_;
		this.prefixBytes = prefixBytes_;
		this.prefixRune = prefixRune_;
		this.prefixEnd = prefixEnd_;
		this.mpool = mpool_;
		this.matchcap = matchcap_;
		this.prefixComplete = prefixComplete_;
		this.cond = cond_;
		this.longest = longest_;
	});
	input = $pkg.input = $newType(8, $kindInterface, "regexp.input", true, "regexp", false, null);
	inputString = $pkg.inputString = $newType(0, $kindStruct, "regexp.inputString", true, "regexp", false, function(str_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.str = "";
			return;
		}
		this.str = str_;
	});
	inputBytes = $pkg.inputBytes = $newType(0, $kindStruct, "regexp.inputBytes", true, "regexp", false, function(str_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.str = sliceType$5.nil;
			return;
		}
		this.str = str_;
	});
	inputReader = $pkg.inputReader = $newType(0, $kindStruct, "regexp.inputReader", true, "regexp", false, function(r_, atEOT_, pos_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.r = $ifaceNil;
			this.atEOT = false;
			this.pos = 0;
			return;
		}
		this.r = r_;
		this.atEOT = atEOT_;
		this.pos = pos_;
	});
	sliceType = $sliceType($emptyInterface);
	arrayType = $arrayType($Int, 0);
	arrayType$1 = $arrayType(nosync.Pool, 5);
	arrayType$2 = $arrayType($Uint8, 16);
	sliceType$1 = $sliceType($Int32);
	sliceType$2 = $sliceType($Uint32);
	ptrType = $ptrType(bitState);
	sliceType$3 = $sliceType($Int);
	sliceType$4 = $sliceType(job);
	sliceType$5 = $sliceType($Uint8);
	ptrType$1 = $ptrType(thread);
	ptrType$2 = $ptrType(syntax.Inst);
	ptrType$3 = $ptrType(lazyFlag);
	ptrType$4 = $ptrType($Int);
	ptrType$5 = $ptrType(onePassMachine);
	ptrType$6 = $ptrType(onePassProg);
	ptrType$7 = $ptrType(strings.Builder);
	ptrType$8 = $ptrType(queueOnePass);
	sliceType$6 = $sliceType(onePassInst);
	ptrType$9 = $ptrType($Uint32);
	sliceType$7 = $sliceType(sliceType$1);
	ptrType$10 = $ptrType(sliceType$1);
	sliceType$8 = $sliceType($Bool);
	ptrType$11 = $ptrType(Regexp);
	ptrType$12 = $ptrType(syntax.Prog);
	sliceType$9 = $sliceType($String);
	ptrType$13 = $ptrType(machine);
	sliceType$10 = $sliceType(entry);
	sliceType$11 = $sliceType(ptrType$1);
	arrayType$3 = $arrayType($Int, 2);
	arrayType$4 = $arrayType($Int, 4);
	sliceType$12 = $sliceType(sliceType$5);
	sliceType$13 = $sliceType(sliceType$3);
	sliceType$14 = $sliceType(sliceType$12);
	sliceType$15 = $sliceType(sliceType$9);
	ptrType$14 = $ptrType(queue);
	ptrType$15 = $ptrType(inputs);
	funcType = $funcType([$String], [$String], false);
	funcType$1 = $funcType([sliceType$5, sliceType$3], [sliceType$5], false);
	funcType$2 = $funcType([sliceType$5], [sliceType$5], false);
	funcType$3 = $funcType([sliceType$3], [], false);
	ptrType$16 = $ptrType(inputString);
	ptrType$17 = $ptrType(inputBytes);
	ptrType$18 = $ptrType(inputReader);
	newBitState = function() {
		var _r, _tuple, b, ok, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; ok = $f.ok; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = bitStatePool.Get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = $assertType(_r, ptrType, true);
		b = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			b = new bitState.ptr(0, sliceType$3.nil, sliceType$3.nil, sliceType$4.nil, sliceType$2.nil, new inputs.ptr(new inputBytes.ptr(sliceType$5.nil), new inputString.ptr(""), new inputReader.ptr($ifaceNil, false, 0)));
		}
		$s = -1; return b;
		/* */ } return; } if ($f === undefined) { $f = { $blk: newBitState }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.ok = ok; $f.$s = $s; $f.$r = $r; return $f;
	};
	freeBitState = function(b) {
		var b;
		b.inputs.clear();
		bitStatePool.Put(b);
	};
	maxBitStateLen = function(prog) {
		var _q, prog;
		if (!shouldBacktrack(prog)) {
			return 0;
		}
		return (_q = 262144 / prog.Inst.$length, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
	};
	shouldBacktrack = function(prog) {
		var prog;
		return prog.Inst.$length <= 500;
	};
	bitState.ptr.prototype.reset = function(prog, end, ncap) {
		var _i, _i$1, _i$2, _q, _ref, _ref$1, _ref$2, b, end, i, i$1, i$2, ncap, prog, visitedSize, x, x$1, x$2;
		b = this;
		b.end = end;
		if (b.jobs.$capacity === 0) {
			b.jobs = $makeSlice(sliceType$4, 0, 256);
		} else {
			b.jobs = $subslice(b.jobs, 0, 0);
		}
		visitedSize = (_q = (((($imul(prog.Inst.$length, ((end + 1 >> 0)))) + 32 >> 0) - 1 >> 0)) / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		if (b.visited.$capacity < visitedSize) {
			b.visited = $makeSlice(sliceType$2, visitedSize, 8192);
		} else {
			b.visited = $subslice(b.visited, 0, visitedSize);
			_ref = b.visited;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				(x = b.visited, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i] = 0));
				_i++;
			}
		}
		if (b.cap.$capacity < ncap) {
			b.cap = $makeSlice(sliceType$3, ncap);
		} else {
			b.cap = $subslice(b.cap, 0, ncap);
		}
		_ref$1 = b.cap;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i$1 = _i$1;
			(x$1 = b.cap, ((i$1 < 0 || i$1 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i$1] = -1));
			_i$1++;
		}
		if (b.matchcap.$capacity < ncap) {
			b.matchcap = $makeSlice(sliceType$3, ncap);
		} else {
			b.matchcap = $subslice(b.matchcap, 0, ncap);
		}
		_ref$2 = b.matchcap;
		_i$2 = 0;
		while (true) {
			if (!(_i$2 < _ref$2.$length)) { break; }
			i$2 = _i$2;
			(x$2 = b.matchcap, ((i$2 < 0 || i$2 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$2] = -1));
			_i$2++;
		}
	};
	bitState.prototype.reset = function(prog, end, ncap) { return this.$val.reset(prog, end, ncap); };
	bitState.ptr.prototype.shouldVisit = function(pc, pos) {
		var _index, _q, _q$1, b, n, pc, pos, x, x$1, x$2, x$3, y, y$1;
		b = this;
		n = (((($imul(((pc >> 0)), ((b.end + 1 >> 0)))) + pos >> 0) >>> 0));
		if (!(((((x = b.visited, x$1 = (_q = n / 32, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero")), ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])) & (((y = (((n & 31) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0) === 0))) {
			return false;
		}
		_index = (_q$1 = n / 32, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
		(x$3 = b.visited, ((_index < 0 || _index >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + _index] = (((x$2 = b.visited, ((_index < 0 || _index >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + _index])) | (((y$1 = (((n & 31) >>> 0)), y$1 < 32 ? (1 << y$1) : 0) >>> 0))) >>> 0)));
		return true;
	};
	bitState.prototype.shouldVisit = function(pc, pos) { return this.$val.shouldVisit(pc, pos); };
	bitState.ptr.prototype.push = function(re, pc, pos, arg) {
		var arg, b, pc, pos, re, x;
		b = this;
		if (!(((x = re.prog.Inst, ((pc < 0 || pc >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pc])).Op === 5)) && (arg || b.shouldVisit(pc, pos))) {
			b.jobs = $append(b.jobs, new job.ptr(pc, arg, pos));
		}
	};
	bitState.prototype.push = function(re, pc, pos, arg) { return this.$val.push(re, pc, pos, arg); };
	Regexp.ptr.prototype.tryBacktrack = function(b, i, pc, pos) {
		var _1, _2, _r, _r$1, _r$2, _r$3, _r$4, _tuple, _tuple$1, _tuple$2, _tuple$3, arg, b, flag, i, inst, l, longest, old, pc, pc$1, pos, pos$1, r, r$1, r$2, r$3, re, width, width$1, width$2, width$3, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; arg = $f.arg; b = $f.b; flag = $f.flag; i = $f.i; inst = $f.inst; l = $f.l; longest = $f.longest; old = $f.old; pc = $f.pc; pc$1 = $f.pc$1; pos = $f.pos; pos$1 = $f.pos$1; r = $f.r; r$1 = $f.r$1; r$2 = $f.r$2; r$3 = $f.r$3; re = $f.re; width = $f.width; width$1 = $f.width$1; width$2 = $f.width$2; width$3 = $f.width$3; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		longest = re.longest;
		b.push(re, pc, pos, false);
		/* while (true) { */ case 1:
			/* if (!(b.jobs.$length > 0)) { break; } */ if(!(b.jobs.$length > 0)) { $s = 2; continue; }
			l = b.jobs.$length - 1 >> 0;
			pc$1 = (x = b.jobs, ((l < 0 || l >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + l])).pc;
			pos$1 = (x$1 = b.jobs, ((l < 0 || l >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + l])).pos;
			arg = (x$2 = b.jobs, ((l < 0 || l >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + l])).arg;
			b.jobs = $subslice(b.jobs, 0, l);
			/* goto Skip */ $s = 3; continue;
			/* CheckAndLoop: */ case 4:
			if (!b.shouldVisit(pc$1, pos$1)) {
				/* continue; */ $s = 1; continue;
			}
			/* Skip: */ case 3:
			inst = $clone((x$3 = re.prog.Inst, ((pc$1 < 0 || pc$1 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + pc$1])), syntax.Inst);
				_1 = inst.Op;
				/* */ if (_1 === (5)) { $s = 6; continue; }
				/* */ if (_1 === (0)) { $s = 7; continue; }
				/* */ if (_1 === (1)) { $s = 8; continue; }
				/* */ if (_1 === (7)) { $s = 9; continue; }
				/* */ if (_1 === (8)) { $s = 10; continue; }
				/* */ if (_1 === (10)) { $s = 11; continue; }
				/* */ if (_1 === (9)) { $s = 12; continue; }
				/* */ if (_1 === (2)) { $s = 13; continue; }
				/* */ if (_1 === (3)) { $s = 14; continue; }
				/* */ if (_1 === (6)) { $s = 15; continue; }
				/* */ if (_1 === (4)) { $s = 16; continue; }
				/* */ $s = 17; continue;
				/* if (_1 === (5)) { */ case 6:
					$panic(new $String("unexpected InstFail"));
					$s = 18; continue;
				/* } else if (_1 === (0)) { */ case 7:
					/* */ if (arg) { $s = 19; continue; }
					/* */ $s = 20; continue;
					/* if (arg) { */ case 19:
						arg = false;
						pc$1 = inst.Arg;
						/* goto CheckAndLoop */ $s = 4; continue;
						$s = 21; continue;
					/* } else { */ case 20:
						b.push(re, pc$1, pos$1, true);
						pc$1 = inst.Out;
						/* goto CheckAndLoop */ $s = 4; continue;
					/* } */ case 21:
					$s = 18; continue;
				/* } else if (_1 === (1)) { */ case 8:
						_2 = (x$4 = re.prog.Inst, x$5 = inst.Out, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])).Op;
						/* */ if ((_2 === (7)) || (_2 === (8)) || (_2 === (9)) || (_2 === (10))) { $s = 23; continue; }
						/* */ $s = 24; continue;
						/* if ((_2 === (7)) || (_2 === (8)) || (_2 === (9)) || (_2 === (10))) { */ case 23:
							b.push(re, inst.Arg, pos$1, false);
							pc$1 = inst.Arg;
							pos$1 = b.end;
							/* goto CheckAndLoop */ $s = 4; continue;
						/* } */ case 24:
					case 22:
					b.push(re, inst.Out, b.end, false);
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (7)) { */ case 9:
					_r = i.step(pos$1); /* */ $s = 25; case 25: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					_tuple = _r;
					r = _tuple[0];
					width = _tuple[1];
					/* */ if (!inst.MatchRune(r)) { $s = 26; continue; }
					/* */ $s = 27; continue;
					/* if (!inst.MatchRune(r)) { */ case 26:
						/* continue; */ $s = 1; continue;
					/* } */ case 27:
					pos$1 = pos$1 + (width) >> 0;
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (8)) { */ case 10:
					_r$1 = i.step(pos$1); /* */ $s = 28; case 28: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_tuple$1 = _r$1;
					r$1 = _tuple$1[0];
					width$1 = _tuple$1[1];
					/* */ if (!((r$1 === (x$6 = inst.Rune, (0 >= x$6.$length ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + 0]))))) { $s = 29; continue; }
					/* */ $s = 30; continue;
					/* if (!((r$1 === (x$6 = inst.Rune, (0 >= x$6.$length ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + 0]))))) { */ case 29:
						/* continue; */ $s = 1; continue;
					/* } */ case 30:
					pos$1 = pos$1 + (width$1) >> 0;
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (10)) { */ case 11:
					_r$2 = i.step(pos$1); /* */ $s = 31; case 31: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_tuple$2 = _r$2;
					r$2 = _tuple$2[0];
					width$2 = _tuple$2[1];
					/* */ if ((r$2 === 10) || (r$2 === -1)) { $s = 32; continue; }
					/* */ $s = 33; continue;
					/* if ((r$2 === 10) || (r$2 === -1)) { */ case 32:
						/* continue; */ $s = 1; continue;
					/* } */ case 33:
					pos$1 = pos$1 + (width$2) >> 0;
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (9)) { */ case 12:
					_r$3 = i.step(pos$1); /* */ $s = 34; case 34: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					_tuple$3 = _r$3;
					r$3 = _tuple$3[0];
					width$3 = _tuple$3[1];
					/* */ if (r$3 === -1) { $s = 35; continue; }
					/* */ $s = 36; continue;
					/* if (r$3 === -1) { */ case 35:
						/* continue; */ $s = 1; continue;
					/* } */ case 36:
					pos$1 = pos$1 + (width$3) >> 0;
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (2)) { */ case 13:
					/* */ if (arg) { $s = 37; continue; }
					/* */ $s = 38; continue;
					/* if (arg) { */ case 37:
						(x$7 = b.cap, x$8 = inst.Arg, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8] = pos$1));
						/* continue; */ $s = 1; continue;
						$s = 39; continue;
					/* } else { */ case 38:
						if (0 <= inst.Arg && inst.Arg < ((b.cap.$length >>> 0))) {
							b.push(re, pc$1, (x$9 = b.cap, x$10 = inst.Arg, ((x$10 < 0 || x$10 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + x$10])), true);
							(x$11 = b.cap, x$12 = inst.Arg, ((x$12 < 0 || x$12 >= x$11.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$11.$array[x$11.$offset + x$12] = pos$1));
						}
						pc$1 = inst.Out;
						/* goto CheckAndLoop */ $s = 4; continue;
					/* } */ case 39:
					$s = 18; continue;
				/* } else if (_1 === (3)) { */ case 14:
					_r$4 = i.context(pos$1); /* */ $s = 40; case 40: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					flag = _r$4;
					/* */ if (!flag.match(((inst.Arg << 24 >>> 24)))) { $s = 41; continue; }
					/* */ $s = 42; continue;
					/* if (!flag.match(((inst.Arg << 24 >>> 24)))) { */ case 41:
						/* continue; */ $s = 1; continue;
					/* } */ case 42:
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (6)) { */ case 15:
					pc$1 = inst.Out;
					/* goto CheckAndLoop */ $s = 4; continue;
					$s = 18; continue;
				/* } else if (_1 === (4)) { */ case 16:
					if (b.cap.$length === 0) {
						$s = -1; return true;
					}
					if (b.cap.$length > 1) {
						(x$13 = b.cap, (1 >= x$13.$length ? ($throwRuntimeError("index out of range"), undefined) : x$13.$array[x$13.$offset + 1] = pos$1));
					}
					old = (x$14 = b.matchcap, (1 >= x$14.$length ? ($throwRuntimeError("index out of range"), undefined) : x$14.$array[x$14.$offset + 1]));
					if ((old === -1) || (longest && pos$1 > 0 && pos$1 > old)) {
						$copySlice(b.matchcap, b.cap);
					}
					if (!longest) {
						$s = -1; return true;
					}
					if (pos$1 === b.end) {
						$s = -1; return true;
					}
					/* continue; */ $s = 1; continue;
					$s = 18; continue;
				/* } else { */ case 17:
					$panic(new $String("bad inst"));
				/* } */ case 18:
			case 5:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return longest && b.matchcap.$length > 1 && (x$15 = b.matchcap, (1 >= x$15.$length ? ($throwRuntimeError("index out of range"), undefined) : x$15.$array[x$15.$offset + 1])) >= 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.tryBacktrack }; } $f._1 = _1; $f._2 = _2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f.arg = arg; $f.b = b; $f.flag = flag; $f.i = i; $f.inst = inst; $f.l = l; $f.longest = longest; $f.old = old; $f.pc = pc; $f.pc$1 = pc$1; $f.pos = pos; $f.pos$1 = pos$1; $f.r = r; $f.r$1 = r$1; $f.r$2 = r$2; $f.r$3 = r$3; $f.re = re; $f.width = width; $f.width$1 = width$1; $f.width$2 = width$2; $f.width$3 = width$3; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.tryBacktrack = function(b, i, pc, pos) { return this.$val.tryBacktrack(b, i, pc, pos); };
	Regexp.ptr.prototype.backtrack = function(ib, is, pos, ncap, dstCap) {
		var _r, _r$1, _r$2, _r$3, _r$4, _tuple, _tuple$1, advance, b, dstCap, end, i, ib, is, ncap, pos, re, startCond, width, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; advance = $f.advance; b = $f.b; dstCap = $f.dstCap; end = $f.end; i = $f.i; ib = $f.ib; is = $f.is; ncap = $f.ncap; pos = $f.pos; re = $f.re; startCond = $f.startCond; width = $f.width; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		startCond = re.cond;
		if (startCond === 255) {
			$s = -1; return sliceType$3.nil;
		}
		if (!((((startCond & 4) >>> 0) === 0)) && !((pos === 0))) {
			$s = -1; return sliceType$3.nil;
		}
		_r = newBitState(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		b = _r;
		_tuple = b.inputs.init($ifaceNil, ib, is);
		i = _tuple[0];
		end = _tuple[1];
		b.reset(re.prog, end, ncap);
		/* */ if (!((((startCond & 4) >>> 0) === 0))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((((startCond & 4) >>> 0) === 0))) { */ case 2:
			if (b.cap.$length > 0) {
				(x = b.cap, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0] = pos));
			}
			_r$1 = re.tryBacktrack(b, i, ((re.prog.Start >>> 0)), pos); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (!_r$1) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (!_r$1) { */ case 5:
				freeBitState(b);
				$s = -1; return sliceType$3.nil;
			/* } */ case 6:
			$s = 4; continue;
		/* } else { */ case 3:
			width = -1;
			/* while (true) { */ case 8:
				/* if (!(pos <= end && !((width === 0)))) { break; } */ if(!(pos <= end && !((width === 0)))) { $s = 9; continue; }
				/* */ if (re.prefix.length > 0) { $s = 10; continue; }
				/* */ $s = 11; continue;
				/* if (re.prefix.length > 0) { */ case 10:
					_r$2 = i.index(re, pos); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					advance = _r$2;
					if (advance < 0) {
						freeBitState(b);
						$s = -1; return sliceType$3.nil;
					}
					pos = pos + (advance) >> 0;
				/* } */ case 11:
				if (b.cap.$length > 0) {
					(x$1 = b.cap, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0] = pos));
				}
				_r$3 = re.tryBacktrack(b, i, ((re.prog.Start >>> 0)), pos); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				/* */ if (_r$3) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if (_r$3) { */ case 13:
					/* goto Match */ $s = 16; continue;
				/* } */ case 14:
				_r$4 = i.step(pos); /* */ $s = 17; case 17: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				_tuple$1 = _r$4;
				width = _tuple$1[1];
				pos = pos + (width) >> 0;
			/* } */ $s = 8; continue; case 9:
			freeBitState(b);
			$s = -1; return sliceType$3.nil;
		/* } */ case 4:
		/* Match: */ case 16:
		dstCap = $appendSlice(dstCap, b.matchcap);
		freeBitState(b);
		$s = -1; return dstCap;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.backtrack }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.advance = advance; $f.b = b; $f.dstCap = dstCap; $f.end = end; $f.i = i; $f.ib = ib; $f.is = is; $f.ncap = ncap; $f.pos = pos; $f.re = re; $f.startCond = startCond; $f.width = width; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.backtrack = function(ib, is, pos, ncap, dstCap) { return this.$val.backtrack(ib, is, pos, ncap, dstCap); };
	inputs.ptr.prototype.newBytes = function(b) {
		var b, i;
		i = this;
		i.bytes.str = b;
		return i.bytes;
	};
	inputs.prototype.newBytes = function(b) { return this.$val.newBytes(b); };
	inputs.ptr.prototype.newString = function(s) {
		var i, s;
		i = this;
		i.string.str = s;
		return i.string;
	};
	inputs.prototype.newString = function(s) { return this.$val.newString(s); };
	inputs.ptr.prototype.newReader = function(r) {
		var i, r;
		i = this;
		i.reader.r = r;
		i.reader.atEOT = false;
		i.reader.pos = 0;
		return i.reader;
	};
	inputs.prototype.newReader = function(r) { return this.$val.newReader(r); };
	inputs.ptr.prototype.clear = function() {
		var i;
		i = this;
		if (!(i.bytes.str === sliceType$5.nil)) {
			i.bytes.str = sliceType$5.nil;
		} else if (!($interfaceIsEqual(i.reader.r, $ifaceNil))) {
			i.reader.r = $ifaceNil;
		} else {
			i.string.str = "";
		}
	};
	inputs.prototype.clear = function() { return this.$val.clear(); };
	inputs.ptr.prototype.init = function(r, b, s) {
		var b, i, r, s;
		i = this;
		if (!($interfaceIsEqual(r, $ifaceNil))) {
			return [i.newReader(r), 0];
		}
		if (!(b === sliceType$5.nil)) {
			return [i.newBytes(b), b.$length];
		}
		return [i.newString(s), s.length];
	};
	inputs.prototype.init = function(r, b, s) { return this.$val.init(r, b, s); };
	machine.ptr.prototype.init = function(ncap) {
		var _i, _ref, m, ncap, t;
		m = this;
		_ref = m.pool;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			t = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			t.cap = $subslice(t.cap, 0, ncap);
			_i++;
		}
		m.matchcap = $subslice(m.matchcap, 0, ncap);
	};
	machine.prototype.init = function(ncap) { return this.$val.init(ncap); };
	machine.ptr.prototype.alloc = function(i) {
		var i, m, n, t, x, x$1;
		m = this;
		t = ptrType$1.nil;
		n = m.pool.$length;
		if (n > 0) {
			t = (x = m.pool, x$1 = n - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			m.pool = $subslice(m.pool, 0, (n - 1 >> 0));
		} else {
			t = new thread.ptr(ptrType$2.nil, sliceType$3.nil);
			t.cap = $makeSlice(sliceType$3, m.matchcap.$length, m.matchcap.$capacity);
		}
		t.inst = i;
		return t;
	};
	machine.prototype.alloc = function(i) { return this.$val.alloc(i); };
	newLazyFlag = function(r1, r2) {
		var r1, r2, x, x$1, x$2;
		return ((x = (x$1 = $shiftLeft64((new $Uint64(0, r1)), 32), x$2 = (new $Uint64(0, ((r2 >>> 0)))), new $Uint64(x$1.$high | x$2.$high, (x$1.$low | x$2.$low) >>> 0)), new lazyFlag(x.$high, x.$low)));
	};
	lazyFlag.prototype.match = function(op) {
		var f, op, r1, r2;
		f = this;
		if (op === 0) {
			return true;
		}
		r1 = (($shiftRightUint64(f, 32).$low >> 0));
		if (!((((op & 1) >>> 0) === 0))) {
			if (!((r1 === 10)) && r1 >= 0) {
				return false;
			}
			op = (op & ~(1)) << 24 >>> 24;
		}
		if (!((((op & 4) >>> 0) === 0))) {
			if (r1 >= 0) {
				return false;
			}
			op = (op & ~(4)) << 24 >>> 24;
		}
		if (op === 0) {
			return true;
		}
		r2 = ((f.$low >> 0));
		if (!((((op & 2) >>> 0) === 0))) {
			if (!((r2 === 10)) && r2 >= 0) {
				return false;
			}
			op = (op & ~(2)) << 24 >>> 24;
		}
		if (!((((op & 8) >>> 0) === 0))) {
			if (r2 >= 0) {
				return false;
			}
			op = (op & ~(8)) << 24 >>> 24;
		}
		if (op === 0) {
			return true;
		}
		if (!(syntax.IsWordChar(r1) === syntax.IsWordChar(r2))) {
			op = (op & ~(16)) << 24 >>> 24;
		} else {
			op = (op & ~(32)) << 24 >>> 24;
		}
		return op === 0;
	};
	$ptrType(lazyFlag).prototype.match = function(op) { return this.$get().match(op); };
	machine.ptr.prototype.match = function(i, pos) {
		var _i, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _v, advance, flag, i, i$1, m, nextq, pos, r, r1, runq, startCond, width, width1, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _v = $f._v; advance = $f.advance; flag = $f.flag; i = $f.i; i$1 = $f.i$1; m = $f.m; nextq = $f.nextq; pos = $f.pos; r = $f.r; r1 = $f.r1; runq = $f.runq; startCond = $f.startCond; width = $f.width; width1 = $f.width1; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		flag = [flag];
		m = this;
		startCond = m.re.cond;
		if (startCond === 255) {
			$s = -1; return false;
		}
		m.matched = false;
		_ref = m.matchcap;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i$1 = _i;
			(x = m.matchcap, ((i$1 < 0 || i$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i$1] = -1));
			_i++;
		}
		_tmp = m.q0;
		_tmp$1 = m.q1;
		runq = _tmp;
		nextq = _tmp$1;
		_tmp$2 = -1;
		_tmp$3 = -1;
		r = _tmp$2;
		r1 = _tmp$3;
		_tmp$4 = 0;
		_tmp$5 = 0;
		width = _tmp$4;
		width1 = _tmp$5;
		_r = i.step(pos); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		width = _tuple[1];
		/* */ if (!((r === -1))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((r === -1))) { */ case 2:
			_r$1 = i.step(pos + width >> 0); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			r1 = _tuple$1[0];
			width1 = _tuple$1[1];
		/* } */ case 3:
		flag[0] = new lazyFlag(0, 0);
		/* */ if (pos === 0) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (pos === 0) { */ case 5:
			flag[0] = newLazyFlag(-1, r);
			$s = 7; continue;
		/* } else { */ case 6:
			_r$2 = i.context(pos); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			flag[0] = _r$2;
		/* } */ case 7:
		/* while (true) { */ case 9:
			/* */ if (runq.dense.$length === 0) { $s = 11; continue; }
			/* */ $s = 12; continue;
			/* if (runq.dense.$length === 0) { */ case 11:
				if (!((((startCond & 4) >>> 0) === 0)) && !((pos === 0))) {
					/* break; */ $s = 10; continue;
				}
				if (m.matched) {
					/* break; */ $s = 10; continue;
				}
				if (!(m.re.prefix.length > 0 && !((r1 === m.re.prefixRune)))) { _v = false; $s = 15; continue s; }
				_r$3 = i.canCheckPrefix(); /* */ $s = 16; case 16: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				_v = _r$3; case 15:
				/* */ if (_v) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if (_v) { */ case 13:
					_r$4 = i.index(m.re, pos); /* */ $s = 17; case 17: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					advance = _r$4;
					if (advance < 0) {
						/* break; */ $s = 10; continue;
					}
					pos = pos + (advance) >> 0;
					_r$5 = i.step(pos); /* */ $s = 18; case 18: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					_tuple$2 = _r$5;
					r = _tuple$2[0];
					width = _tuple$2[1];
					_r$6 = i.step(pos + width >> 0); /* */ $s = 19; case 19: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
					_tuple$3 = _r$6;
					r1 = _tuple$3[0];
					width1 = _tuple$3[1];
				/* } */ case 14:
			/* } */ case 12:
			if (!m.matched) {
				if (m.matchcap.$length > 0) {
					(x$1 = m.matchcap, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0] = pos));
				}
				m.add(runq, ((m.p.Start >>> 0)), pos, m.matchcap, (flag.$ptr || (flag.$ptr = new ptrType$3(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, flag))), ptrType$1.nil);
			}
			flag[0] = newLazyFlag(r, r1);
			m.step(runq, nextq, pos, pos + width >> 0, r, (flag.$ptr || (flag.$ptr = new ptrType$3(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, flag))));
			if (width === 0) {
				/* break; */ $s = 10; continue;
			}
			if ((m.matchcap.$length === 0) && m.matched) {
				/* break; */ $s = 10; continue;
			}
			pos = pos + (width) >> 0;
			_tmp$6 = r1;
			_tmp$7 = width1;
			r = _tmp$6;
			width = _tmp$7;
			/* */ if (!((r === -1))) { $s = 20; continue; }
			/* */ $s = 21; continue;
			/* if (!((r === -1))) { */ case 20:
				_r$7 = i.step(pos + width >> 0); /* */ $s = 22; case 22: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				_tuple$4 = _r$7;
				r1 = _tuple$4[0];
				width1 = _tuple$4[1];
			/* } */ case 21:
			_tmp$8 = nextq;
			_tmp$9 = runq;
			runq = _tmp$8;
			nextq = _tmp$9;
		/* } */ $s = 9; continue; case 10:
		m.clear(nextq);
		$s = -1; return m.matched;
		/* */ } return; } if ($f === undefined) { $f = { $blk: machine.ptr.prototype.match }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._v = _v; $f.advance = advance; $f.flag = flag; $f.i = i; $f.i$1 = i$1; $f.m = m; $f.nextq = nextq; $f.pos = pos; $f.r = r; $f.r1 = r1; $f.runq = runq; $f.startCond = startCond; $f.width = width; $f.width1 = width1; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	machine.prototype.match = function(i, pos) { return this.$val.match(i, pos); };
	machine.ptr.prototype.clear = function(q) {
		var _i, _ref, d, m, q;
		m = this;
		_ref = q.dense;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			d = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), entry);
			if (!(d.t === ptrType$1.nil)) {
				m.pool = $append(m.pool, d.t);
			}
			_i++;
		}
		q.dense = $subslice(q.dense, 0, 0);
	};
	machine.prototype.clear = function(q) { return this.$val.clear(q); };
	machine.ptr.prototype.step = function(runq, nextq, pos, nextPos, c, nextCond) {
		var _1, _i, _ref, add, c, d, d$1, i, j, longest, m, nextCond, nextPos, nextq, pos, runq, t, x, x$1, x$2, x$3, x$4, x$5;
		m = this;
		longest = m.re.longest;
		j = 0;
		while (true) {
			if (!(j < runq.dense.$length)) { break; }
			d = (x = runq.dense, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j]));
			t = d.t;
			if (t === ptrType$1.nil) {
				j = j + (1) >> 0;
				continue;
			}
			if (longest && m.matched && t.cap.$length > 0 && (x$1 = m.matchcap, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) < (x$2 = t.cap, (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0]))) {
				m.pool = $append(m.pool, t);
				j = j + (1) >> 0;
				continue;
			}
			i = t.inst;
			add = false;
			_1 = i.Op;
			if (_1 === (4)) {
				if (t.cap.$length > 0 && (!longest || !m.matched || (x$3 = m.matchcap, (1 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 1])) < pos)) {
					(x$4 = t.cap, (1 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 1] = pos));
					$copySlice(m.matchcap, t.cap);
				}
				if (!longest) {
					_ref = $subslice(runq.dense, (j + 1 >> 0));
					_i = 0;
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						d$1 = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), entry);
						if (!(d$1.t === ptrType$1.nil)) {
							m.pool = $append(m.pool, d$1.t);
						}
						_i++;
					}
					runq.dense = $subslice(runq.dense, 0, 0);
				}
				m.matched = true;
			} else if (_1 === (7)) {
				add = i.MatchRune(c);
			} else if (_1 === (8)) {
				add = c === (x$5 = i.Rune, (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0]));
			} else if (_1 === (9)) {
				add = true;
			} else if (_1 === (10)) {
				add = !((c === 10));
			} else {
				$panic(new $String("bad inst"));
			}
			if (add) {
				t = m.add(nextq, i.Out, nextPos, t.cap, nextCond, t);
			}
			if (!(t === ptrType$1.nil)) {
				m.pool = $append(m.pool, t);
			}
			j = j + (1) >> 0;
		}
		runq.dense = $subslice(runq.dense, 0, 0);
	};
	machine.prototype.step = function(runq, nextq, pos, nextPos, c, nextCond) { return this.$val.step(runq, nextq, pos, nextPos, c, nextCond); };
	machine.ptr.prototype.add = function(q, pc, pos, cap, cond, t) {
		var _1, cap, cond, d, i, j, j$1, m, opos, pc, pos, q, t, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, $s;
		/* */ $s = 0; s: while (true) { switch ($s) { case 0:
		m = this;
		/* Again: */ case 1:
		if (pc === 0) {
			$s = -1; return t;
		}
		j = (x = q.sparse, ((pc < 0 || pc >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pc]));
		if (j < ((q.dense.$length >>> 0)) && ((x$1 = q.dense, ((j < 0 || j >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + j])).pc === pc)) {
			$s = -1; return t;
		}
		j$1 = q.dense.$length;
		q.dense = $subslice(q.dense, 0, (j$1 + 1 >> 0));
		d = (x$2 = q.dense, ((j$1 < 0 || j$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j$1]));
		d.t = ptrType$1.nil;
		d.pc = pc;
		(x$3 = q.sparse, ((pc < 0 || pc >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + pc] = ((j$1 >>> 0))));
		i = (x$4 = m.p.Inst, ((pc < 0 || pc >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + pc]));
			_1 = i.Op;
			/* */ if (_1 === (5)) { $s = 3; continue; }
			/* */ if ((_1 === (0)) || (_1 === (1))) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ if (_1 === (2)) { $s = 7; continue; }
			/* */ if ((_1 === (4)) || (_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10))) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (_1 === (5)) { */ case 3:
				$s = 10; continue;
			/* } else if ((_1 === (0)) || (_1 === (1))) { */ case 4:
				t = m.add(q, i.Out, pos, cap, cond, t);
				pc = i.Arg;
				/* goto Again */ $s = 1; continue;
				$s = 10; continue;
			/* } else if (_1 === (3)) { */ case 5:
				/* */ if (cond.match(((i.Arg << 24 >>> 24)))) { $s = 11; continue; }
				/* */ $s = 12; continue;
				/* if (cond.match(((i.Arg << 24 >>> 24)))) { */ case 11:
					pc = i.Out;
					/* goto Again */ $s = 1; continue;
				/* } */ case 12:
				$s = 10; continue;
			/* } else if (_1 === (6)) { */ case 6:
				pc = i.Out;
				/* goto Again */ $s = 1; continue;
				$s = 10; continue;
			/* } else if (_1 === (2)) { */ case 7:
				/* */ if (((i.Arg >> 0)) < cap.$length) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if (((i.Arg >> 0)) < cap.$length) { */ case 13:
					opos = (x$5 = i.Arg, ((x$5 < 0 || x$5 >= cap.$length) ? ($throwRuntimeError("index out of range"), undefined) : cap.$array[cap.$offset + x$5]));
					(x$6 = i.Arg, ((x$6 < 0 || x$6 >= cap.$length) ? ($throwRuntimeError("index out of range"), undefined) : cap.$array[cap.$offset + x$6] = pos));
					m.add(q, i.Out, pos, cap, cond, ptrType$1.nil);
					(x$7 = i.Arg, ((x$7 < 0 || x$7 >= cap.$length) ? ($throwRuntimeError("index out of range"), undefined) : cap.$array[cap.$offset + x$7] = opos));
					$s = 15; continue;
				/* } else { */ case 14:
					pc = i.Out;
					/* goto Again */ $s = 1; continue;
				/* } */ case 15:
				$s = 10; continue;
			/* } else if ((_1 === (4)) || (_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10))) { */ case 8:
				if (t === ptrType$1.nil) {
					t = m.alloc(i);
				} else {
					t.inst = i;
				}
				if (cap.$length > 0 && !((x$8 = t.cap, $indexPtr(x$8.$array, x$8.$offset + 0, ptrType$4)) === $indexPtr(cap.$array, cap.$offset + 0, ptrType$4))) {
					$copySlice(t.cap, cap);
				}
				d.t = t;
				t = ptrType$1.nil;
				$s = 10; continue;
			/* } else { */ case 9:
				$panic(new $String("unhandled"));
			/* } */ case 10:
		case 2:
		$s = -1; return t;
		/* */ } return; }
	};
	machine.prototype.add = function(q, pc, pos, cap, cond, t) { return this.$val.add(q, pc, pos, cap, cond, t); };
	newOnePassMachine = function() {
		var _r, _tuple, m, ok, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; m = $f.m; ok = $f.ok; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = onePassPool.Get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = $assertType(_r, ptrType$5, true);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = new onePassMachine.ptr(new inputs.ptr(new inputBytes.ptr(sliceType$5.nil), new inputString.ptr(""), new inputReader.ptr($ifaceNil, false, 0)), sliceType$3.nil);
		}
		$s = -1; return m;
		/* */ } return; } if ($f === undefined) { $f = { $blk: newOnePassMachine }; } $f._r = _r; $f._tuple = _tuple; $f.m = m; $f.ok = ok; $f.$s = $s; $f.$r = $r; return $f;
	};
	freeOnePassMachine = function(m) {
		var m;
		m.inputs.clear();
		onePassPool.Put(m);
	};
	Regexp.ptr.prototype.doOnePass = function(ir, ib, is, pos, ncap, dstCap) {
		var _1, _i, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _v, dstCap, flag, i, i$1, ib, inst, ir, is, m, matched, ncap, pc, pos, r, r1, re, startCond, width, width1, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _v = $f._v; dstCap = $f.dstCap; flag = $f.flag; i = $f.i; i$1 = $f.i$1; ib = $f.ib; inst = $f.inst; ir = $f.ir; is = $f.is; m = $f.m; matched = $f.matched; ncap = $f.ncap; pc = $f.pc; pos = $f.pos; r = $f.r; r1 = $f.r1; re = $f.re; startCond = $f.startCond; width = $f.width; width1 = $f.width1; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		inst = [inst];
		re = this;
		startCond = re.cond;
		if (startCond === 255) {
			$s = -1; return sliceType$3.nil;
		}
		_r = newOnePassMachine(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		m = _r;
		if (m.matchcap.$capacity < ncap) {
			m.matchcap = $makeSlice(sliceType$3, ncap);
		} else {
			m.matchcap = $subslice(m.matchcap, 0, ncap);
		}
		matched = false;
		_ref = m.matchcap;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			(x = m.matchcap, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i] = -1));
			_i++;
		}
		_tuple = m.inputs.init(ir, ib, is);
		i$1 = _tuple[0];
		_tmp = -1;
		_tmp$1 = -1;
		r = _tmp;
		r1 = _tmp$1;
		_tmp$2 = 0;
		_tmp$3 = 0;
		width = _tmp$2;
		width1 = _tmp$3;
		_r$1 = i$1.step(pos); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$1 = _r$1;
		r = _tuple$1[0];
		width = _tuple$1[1];
		/* */ if (!((r === -1))) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (!((r === -1))) { */ case 3:
			_r$2 = i$1.step(pos + width >> 0); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_tuple$2 = _r$2;
			r1 = _tuple$2[0];
			width1 = _tuple$2[1];
		/* } */ case 4:
		flag = new lazyFlag(0, 0);
		/* */ if (pos === 0) { $s = 6; continue; }
		/* */ $s = 7; continue;
		/* if (pos === 0) { */ case 6:
			flag = newLazyFlag(-1, r);
			$s = 8; continue;
		/* } else { */ case 7:
			_r$3 = i$1.context(pos); /* */ $s = 9; case 9: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			flag = _r$3;
		/* } */ case 8:
		pc = re.onepass.Start;
		inst[0] = $clone((x$1 = re.onepass.Inst, ((pc < 0 || pc >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + pc])), onePassInst);
		if (!((pos === 0) && flag.match(((inst[0].Inst.Arg << 24 >>> 24))) && re.prefix.length > 0)) { _v = false; $s = 12; continue s; }
		_r$4 = i$1.canCheckPrefix(); /* */ $s = 13; case 13: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_v = _r$4; case 12:
		/* */ if (_v) { $s = 10; continue; }
		/* */ $s = 11; continue;
		/* if (_v) { */ case 10:
			_r$5 = i$1.hasPrefix(re); /* */ $s = 16; case 16: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			/* */ if (!_r$5) { $s = 14; continue; }
			/* */ $s = 15; continue;
			/* if (!_r$5) { */ case 14:
				/* goto Return */ $s = 17; continue;
			/* } */ case 15:
			pos = pos + (re.prefix.length) >> 0;
			_r$6 = i$1.step(pos); /* */ $s = 18; case 18: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			_tuple$3 = _r$6;
			r = _tuple$3[0];
			width = _tuple$3[1];
			_r$7 = i$1.step(pos + width >> 0); /* */ $s = 19; case 19: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			_tuple$4 = _r$7;
			r1 = _tuple$4[0];
			width1 = _tuple$4[1];
			_r$8 = i$1.context(pos); /* */ $s = 20; case 20: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			flag = _r$8;
			pc = ((re.prefixEnd >> 0));
		/* } */ case 11:
		/* while (true) { */ case 21:
			onePassInst.copy(inst[0], (x$2 = re.onepass.Inst, ((pc < 0 || pc >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + pc])));
			pc = ((inst[0].Inst.Out >> 0));
				_1 = inst[0].Inst.Op;
				/* */ if (_1 === (4)) { $s = 24; continue; }
				/* */ if (_1 === (7)) { $s = 25; continue; }
				/* */ if (_1 === (8)) { $s = 26; continue; }
				/* */ if (_1 === (9)) { $s = 27; continue; }
				/* */ if (_1 === (10)) { $s = 28; continue; }
				/* */ if ((_1 === (0)) || (_1 === (1))) { $s = 29; continue; }
				/* */ if (_1 === (5)) { $s = 30; continue; }
				/* */ if (_1 === (6)) { $s = 31; continue; }
				/* */ if (_1 === (3)) { $s = 32; continue; }
				/* */ if (_1 === (2)) { $s = 33; continue; }
				/* */ $s = 34; continue;
				/* if (_1 === (4)) { */ case 24:
					matched = true;
					if (m.matchcap.$length > 0) {
						(x$3 = m.matchcap, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0] = 0));
						(x$4 = m.matchcap, (1 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 1] = pos));
					}
					/* goto Return */ $s = 17; continue;
					$s = 35; continue;
				/* } else if (_1 === (7)) { */ case 25:
					/* */ if (!inst[0].Inst.MatchRune(r)) { $s = 36; continue; }
					/* */ $s = 37; continue;
					/* if (!inst[0].Inst.MatchRune(r)) { */ case 36:
						/* goto Return */ $s = 17; continue;
					/* } */ case 37:
					$s = 35; continue;
				/* } else if (_1 === (8)) { */ case 26:
					/* */ if (!((r === (x$5 = inst[0].Inst.Rune, (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0]))))) { $s = 38; continue; }
					/* */ $s = 39; continue;
					/* if (!((r === (x$5 = inst[0].Inst.Rune, (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0]))))) { */ case 38:
						/* goto Return */ $s = 17; continue;
					/* } */ case 39:
					$s = 35; continue;
				/* } else if (_1 === (9)) { */ case 27:
					$s = 35; continue;
				/* } else if (_1 === (10)) { */ case 28:
					/* */ if (r === 10) { $s = 40; continue; }
					/* */ $s = 41; continue;
					/* if (r === 10) { */ case 40:
						/* goto Return */ $s = 17; continue;
					/* } */ case 41:
					$s = 35; continue;
				/* } else if ((_1 === (0)) || (_1 === (1))) { */ case 29:
					pc = ((onePassNext(inst[0], r) >> 0));
					/* continue; */ $s = 21; continue;
					$s = 35; continue;
				/* } else if (_1 === (5)) { */ case 30:
					/* goto Return */ $s = 17; continue;
					$s = 35; continue;
				/* } else if (_1 === (6)) { */ case 31:
					/* continue; */ $s = 21; continue;
					$s = 35; continue;
				/* } else if (_1 === (3)) { */ case 32:
					/* */ if (!flag.match(((inst[0].Inst.Arg << 24 >>> 24)))) { $s = 42; continue; }
					/* */ $s = 43; continue;
					/* if (!flag.match(((inst[0].Inst.Arg << 24 >>> 24)))) { */ case 42:
						/* goto Return */ $s = 17; continue;
					/* } */ case 43:
					/* continue; */ $s = 21; continue;
					$s = 35; continue;
				/* } else if (_1 === (2)) { */ case 33:
					if (((inst[0].Inst.Arg >> 0)) < m.matchcap.$length) {
						(x$6 = m.matchcap, x$7 = inst[0].Inst.Arg, ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7] = pos));
					}
					/* continue; */ $s = 21; continue;
					$s = 35; continue;
				/* } else { */ case 34:
					$panic(new $String("bad inst"));
				/* } */ case 35:
			case 23:
			if (width === 0) {
				/* break; */ $s = 22; continue;
			}
			flag = newLazyFlag(r, r1);
			pos = pos + (width) >> 0;
			_tmp$4 = r1;
			_tmp$5 = width1;
			r = _tmp$4;
			width = _tmp$5;
			/* */ if (!((r === -1))) { $s = 44; continue; }
			/* */ $s = 45; continue;
			/* if (!((r === -1))) { */ case 44:
				_r$9 = i$1.step(pos + width >> 0); /* */ $s = 46; case 46: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				_tuple$5 = _r$9;
				r1 = _tuple$5[0];
				width1 = _tuple$5[1];
			/* } */ case 45:
		/* } */ $s = 21; continue; case 22:
		/* Return: */ case 17:
		if (!matched) {
			freeOnePassMachine(m);
			$s = -1; return sliceType$3.nil;
		}
		dstCap = $appendSlice(dstCap, m.matchcap);
		freeOnePassMachine(m);
		$s = -1; return dstCap;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.doOnePass }; } $f._1 = _1; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._v = _v; $f.dstCap = dstCap; $f.flag = flag; $f.i = i; $f.i$1 = i$1; $f.ib = ib; $f.inst = inst; $f.ir = ir; $f.is = is; $f.m = m; $f.matched = matched; $f.ncap = ncap; $f.pc = pc; $f.pos = pos; $f.r = r; $f.r1 = r1; $f.re = re; $f.startCond = startCond; $f.width = width; $f.width1 = width1; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.doOnePass = function(ir, ib, is, pos, ncap, dstCap) { return this.$val.doOnePass(ir, ib, is, pos, ncap, dstCap); };
	Regexp.ptr.prototype.doMatch = function(r, b, s) {
		var _r, b, r, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; r = $f.r; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doExecute(r, b, s, 0, 0, sliceType$3.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return !(_r === sliceType$3.nil);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.doMatch }; } $f._r = _r; $f.b = b; $f.r = r; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.doMatch = function(r, b, s) { return this.$val.doMatch(r, b, s); };
	Regexp.ptr.prototype.doExecute = function(r, b, s, pos, ncap, dstCap) {
		var _r, _r$1, _r$2, _r$3, _tuple, b, dstCap, i, m, ncap, pos, r, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tuple = $f._tuple; b = $f.b; dstCap = $f.dstCap; i = $f.i; m = $f.m; ncap = $f.ncap; pos = $f.pos; r = $f.r; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		if (dstCap === sliceType$3.nil) {
			dstCap = $subslice(new sliceType$3(arrayNoInts), 0, 0, 0);
		}
		/* */ if (!(re.onepass === ptrType$6.nil)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(re.onepass === ptrType$6.nil)) { */ case 1:
			_r = re.doOnePass(r, b, s, pos, ncap, dstCap); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		/* */ if ($interfaceIsEqual(r, $ifaceNil) && (b.$length + s.length >> 0) < re.maxBitStateLen) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if ($interfaceIsEqual(r, $ifaceNil) && (b.$length + s.length >> 0) < re.maxBitStateLen) { */ case 4:
			_r$1 = re.backtrack(b, s, pos, ncap, dstCap); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$s = -1; return _r$1;
		/* } */ case 5:
		_r$2 = re.get(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		m = _r$2;
		_tuple = m.inputs.init(r, b, s);
		i = _tuple[0];
		m.init(ncap);
		_r$3 = m.match(i, pos); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		/* */ if (!_r$3) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if (!_r$3) { */ case 8:
			re.put(m);
			$s = -1; return sliceType$3.nil;
		/* } */ case 9:
		dstCap = $appendSlice(dstCap, m.matchcap);
		re.put(m);
		$s = -1; return dstCap;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.doExecute }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tuple = _tuple; $f.b = b; $f.dstCap = dstCap; $f.i = i; $f.m = m; $f.ncap = ncap; $f.pos = pos; $f.r = r; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.doExecute = function(r, b, s, pos, ncap, dstCap) { return this.$val.doExecute(r, b, s, pos, ncap, dstCap); };
	onePassPrefix = function(p) {
		var _tmp, _tmp$1, _tmp$10, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, buf, complete, i, p, pc, prefix, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8;
		prefix = "";
		complete = false;
		pc = 0;
		i = (x = p.Inst, x$1 = p.Start, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (!((i.Op === 3)) || ((((((i.Arg << 24 >>> 24))) & 4) >>> 0) === 0)) {
			_tmp = "";
			_tmp$1 = i.Op === 4;
			_tmp$2 = ((p.Start >>> 0));
			prefix = _tmp;
			complete = _tmp$1;
			pc = _tmp$2;
			return [prefix, complete, pc];
		}
		pc = i.Out;
		i = (x$2 = p.Inst, ((pc < 0 || pc >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + pc]));
		while (true) {
			if (!(i.Op === 6)) { break; }
			pc = i.Out;
			i = (x$3 = p.Inst, ((pc < 0 || pc >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + pc]));
		}
		if (!((iop(i) === 7)) || !((i.Rune.$length === 1))) {
			_tmp$3 = "";
			_tmp$4 = i.Op === 4;
			_tmp$5 = ((p.Start >>> 0));
			prefix = _tmp$3;
			complete = _tmp$4;
			pc = _tmp$5;
			return [prefix, complete, pc];
		}
		buf = new strings.Builder.ptr(ptrType$7.nil, sliceType$5.nil);
		while (true) {
			if (!((iop(i) === 7) && (i.Rune.$length === 1) && (((((i.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { break; }
			buf.WriteRune((x$4 = i.Rune, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])));
			_tmp$6 = i.Out;
			_tmp$7 = (x$5 = p.Inst, x$6 = i.Out, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6]));
			pc = _tmp$6;
			i = _tmp$7;
		}
		if ((i.Op === 3) && !((((((i.Arg << 24 >>> 24)) & 8) >>> 0) === 0)) && ((x$7 = p.Inst, x$8 = i.Out, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8])).Op === 4)) {
			complete = true;
		}
		_tmp$8 = buf.String();
		_tmp$9 = complete;
		_tmp$10 = pc;
		prefix = _tmp$8;
		complete = _tmp$9;
		pc = _tmp$10;
		return [prefix, complete, pc];
	};
	onePassNext = function(i, r) {
		var i, next, r, x;
		next = i.Inst.MatchRunePos(r);
		if (next >= 0) {
			return (x = i.Next, ((next < 0 || next >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + next]));
		}
		if (i.Inst.Op === 1) {
			return i.Inst.Out;
		}
		return 0;
	};
	iop = function(i) {
		var _1, i, op;
		op = i.Op;
		_1 = op;
		if ((_1 === (8)) || (_1 === (9)) || (_1 === (10))) {
			op = 7;
		}
		return op;
	};
	queueOnePass.ptr.prototype.empty = function() {
		var q;
		q = this;
		return q.nextIndex >= q.size;
	};
	queueOnePass.prototype.empty = function() { return this.$val.empty(); };
	queueOnePass.ptr.prototype.next = function() {
		var n, q, x, x$1;
		n = 0;
		q = this;
		n = (x = q.dense, x$1 = q.nextIndex, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		q.nextIndex = q.nextIndex + (1) >>> 0;
		return n;
	};
	queueOnePass.prototype.next = function() { return this.$val.next(); };
	queueOnePass.ptr.prototype.clear = function() {
		var q;
		q = this;
		q.size = 0;
		q.nextIndex = 0;
	};
	queueOnePass.prototype.clear = function() { return this.$val.clear(); };
	queueOnePass.ptr.prototype.contains = function(u) {
		var q, u, x, x$1, x$2, x$3;
		q = this;
		if (u >= ((q.sparse.$length >>> 0))) {
			return false;
		}
		return (x = q.sparse, ((u < 0 || u >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + u])) < q.size && ((x$1 = q.dense, x$2 = (x$3 = q.sparse, ((u < 0 || u >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + u])), ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2])) === u);
	};
	queueOnePass.prototype.contains = function(u) { return this.$val.contains(u); };
	queueOnePass.ptr.prototype.insert = function(u) {
		var q, u;
		q = this;
		if (!q.contains(u)) {
			q.insertNew(u);
		}
	};
	queueOnePass.prototype.insert = function(u) { return this.$val.insert(u); };
	queueOnePass.ptr.prototype.insertNew = function(u) {
		var q, u, x, x$1, x$2;
		q = this;
		if (u >= ((q.sparse.$length >>> 0))) {
			return;
		}
		(x = q.sparse, ((u < 0 || u >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + u] = q.size));
		(x$1 = q.dense, x$2 = q.size, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2] = u));
		q.size = q.size + (1) >>> 0;
	};
	queueOnePass.prototype.insertNew = function(u) { return this.$val.insertNew(u); };
	newQueue = function(size) {
		var q, size;
		q = ptrType$8.nil;
		q = new queueOnePass.ptr($makeSlice(sliceType$2, size), $makeSlice(sliceType$2, size), 0, 0);
		return q;
	};
	mergeRuneSets = function(leftRunes, rightRunes, leftPC, rightPC) {
		var _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, extend, ix, leftLen, leftPC, leftRunes, lx, merged, next, ok, rightLen, rightPC, rightRunes, rx, x, x$1, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; extend = $f.extend; ix = $f.ix; leftLen = $f.leftLen; leftPC = $f.leftPC; leftRunes = $f.leftRunes; lx = $f.lx; merged = $f.merged; next = $f.next; ok = $f.ok; rightLen = $f.rightLen; rightPC = $f.rightPC; rightRunes = $f.rightRunes; rx = $f.rx; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		ix = [ix];
		lx = [lx];
		merged = [merged];
		next = [next];
		ok = [ok];
		rx = [rx];
		leftLen = leftRunes.$get().$length;
		rightLen = rightRunes.$get().$length;
		if (!(((leftLen & 1) === 0)) || !(((rightLen & 1) === 0))) {
			$panic(new $String("mergeRuneSets odd length []rune"));
		}
		_tmp = 0;
		_tmp$1 = 0;
		lx[0] = _tmp;
		rx[0] = _tmp$1;
		merged[0] = $makeSlice(sliceType$1, 0);
		next[0] = $makeSlice(sliceType$2, 0);
		ok[0] = true;
		$deferred.push([(function(ix, lx, merged, next, ok, rx) { return function() {
			if (!ok[0]) {
				merged[0] = sliceType$1.nil;
				next[0] = sliceType$2.nil;
			}
		}; })(ix, lx, merged, next, ok, rx), []]);
		ix[0] = -1;
		extend = (function(ix, lx, merged, next, ok, rx) { return function(newLow, newArray, pc) {
			var newArray, newLow, pc, x, x$1, x$2, x$3, x$4, x$5;
			if (ix[0] > 0 && (x = newArray.$get(), x$1 = newLow.$get(), ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])) <= ((ix[0] < 0 || ix[0] >= merged[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : merged[0].$array[merged[0].$offset + ix[0]])) {
				return false;
			}
			merged[0] = $append(merged[0], (x$2 = newArray.$get(), x$3 = newLow.$get(), ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])), (x$4 = newArray.$get(), x$5 = newLow.$get() + 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])));
			newLow.$set(newLow.$get() + (2) >> 0);
			ix[0] = ix[0] + (2) >> 0;
			next[0] = $append(next[0], pc);
			return true;
		}; })(ix, lx, merged, next, ok, rx);
		/* while (true) { */ case 1:
			/* if (!(lx[0] < leftLen || rx[0] < rightLen)) { break; } */ if(!(lx[0] < leftLen || rx[0] < rightLen)) { $s = 2; continue; }
				/* */ if (rx[0] >= rightLen) { $s = 4; continue; }
				/* */ if (lx[0] >= leftLen) { $s = 5; continue; }
				/* */ if ((x = rightRunes.$get(), ((rx[0] < 0 || rx[0] >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + rx[0]])) < (x$1 = leftRunes.$get(), ((lx[0] < 0 || lx[0] >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + lx[0]]))) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if (rx[0] >= rightLen) { */ case 4:
					_r = extend((lx.$ptr || (lx.$ptr = new ptrType$4(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, lx))), leftRunes, leftPC); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					ok[0] = _r;
					$s = 8; continue;
				/* } else if (lx[0] >= leftLen) { */ case 5:
					_r$1 = extend((rx.$ptr || (rx.$ptr = new ptrType$4(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, rx))), rightRunes, rightPC); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					ok[0] = _r$1;
					$s = 8; continue;
				/* } else if ((x = rightRunes.$get(), ((rx[0] < 0 || rx[0] >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + rx[0]])) < (x$1 = leftRunes.$get(), ((lx[0] < 0 || lx[0] >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + lx[0]]))) { */ case 6:
					_r$2 = extend((rx.$ptr || (rx.$ptr = new ptrType$4(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, rx))), rightRunes, rightPC); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					ok[0] = _r$2;
					$s = 8; continue;
				/* } else { */ case 7:
					_r$3 = extend((lx.$ptr || (lx.$ptr = new ptrType$4(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, lx))), leftRunes, leftPC); /* */ $s = 12; case 12: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					ok[0] = _r$3;
				/* } */ case 8:
			case 3:
			if (!ok[0]) {
				$s = -1; return [noRune, noNext];
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [merged[0], next[0]];
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [sliceType$1.nil, sliceType$2.nil]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: mergeRuneSets }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.extend = extend; $f.ix = ix; $f.leftLen = leftLen; $f.leftPC = leftPC; $f.leftRunes = leftRunes; $f.lx = lx; $f.merged = merged; $f.next = next; $f.ok = ok; $f.rightLen = rightLen; $f.rightPC = rightPC; $f.rightRunes = rightRunes; $f.rx = rx; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	cleanupOnePass = function(prog, original) {
		var _1, _i, _ref, instOriginal, ix, original, prog, x, x$1, x$2;
		_ref = original.Inst;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			ix = _i;
			instOriginal = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), syntax.Inst);
			_1 = instOriginal.Op;
			if ((_1 === (0)) || (_1 === (1)) || (_1 === (7))) {
			} else if ((_1 === (2)) || (_1 === (3)) || (_1 === (6)) || (_1 === (4)) || (_1 === (5))) {
				(x = prog.Inst, ((ix < 0 || ix >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + ix])).Next = sliceType$2.nil;
			} else if ((_1 === (8)) || (_1 === (9)) || (_1 === (10))) {
				(x$1 = prog.Inst, ((ix < 0 || ix >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + ix])).Next = sliceType$2.nil;
				onePassInst.copy((x$2 = prog.Inst, ((ix < 0 || ix >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + ix])), new onePassInst.ptr($clone(instOriginal, syntax.Inst), sliceType$2.nil));
			}
			_i++;
		}
	};
	onePassCopy = function(prog) {
		var _1, _i, _i$1, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, i, inst, instAlt, instOther, p, p_A_Alt, p_A_Other, p_B_Alt, p_B_Other, patch, pc, prog, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		p = new onePassProg.ptr($makeSlice(sliceType$6, prog.Inst.$length), prog.Start, prog.NumCap);
		_ref = prog.Inst;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			inst = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), syntax.Inst);
			onePassInst.copy((x = p.Inst, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])), new onePassInst.ptr($clone(inst, syntax.Inst), sliceType$2.nil));
			_i++;
		}
		_ref$1 = p.Inst;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			pc = _i$1;
			_1 = (x$1 = p.Inst, ((pc < 0 || pc >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + pc])).Inst.Op;
			if ((_1 === (0)) || (_1 === (1))) {
				p_A_Other = (x$2 = (x$3 = p.Inst, ((pc < 0 || pc >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + pc])), (x$2.$ptr_Out || (x$2.$ptr_Out = new ptrType$9(function() { return this.$target.Inst.Out; }, function($v) { this.$target.Inst.Out = $v; }, x$2))));
				p_A_Alt = (x$4 = (x$5 = p.Inst, ((pc < 0 || pc >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + pc])), (x$4.$ptr_Arg || (x$4.$ptr_Arg = new ptrType$9(function() { return this.$target.Inst.Arg; }, function($v) { this.$target.Inst.Arg = $v; }, x$4))));
				instAlt = $clone((x$6 = p.Inst, x$7 = p_A_Alt.$get(), ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7])), onePassInst);
				if (!((instAlt.Inst.Op === 0) || (instAlt.Inst.Op === 1))) {
					_tmp = p_A_Other;
					_tmp$1 = p_A_Alt;
					p_A_Alt = _tmp;
					p_A_Other = _tmp$1;
					onePassInst.copy(instAlt, (x$8 = p.Inst, x$9 = p_A_Alt.$get(), ((x$9 < 0 || x$9 >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + x$9])));
					if (!((instAlt.Inst.Op === 0) || (instAlt.Inst.Op === 1))) {
						_i$1++;
						continue;
					}
				}
				instOther = $clone((x$10 = p.Inst, x$11 = p_A_Other.$get(), ((x$11 < 0 || x$11 >= x$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + x$11])), onePassInst);
				if ((instOther.Inst.Op === 0) || (instOther.Inst.Op === 1)) {
					_i$1++;
					continue;
				}
				p_B_Alt = (x$12 = (x$13 = p.Inst, x$14 = p_A_Alt.$get(), ((x$14 < 0 || x$14 >= x$13.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$13.$array[x$13.$offset + x$14])), (x$12.$ptr_Out || (x$12.$ptr_Out = new ptrType$9(function() { return this.$target.Inst.Out; }, function($v) { this.$target.Inst.Out = $v; }, x$12))));
				p_B_Other = (x$15 = (x$16 = p.Inst, x$17 = p_A_Alt.$get(), ((x$17 < 0 || x$17 >= x$16.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$16.$array[x$16.$offset + x$17])), (x$15.$ptr_Arg || (x$15.$ptr_Arg = new ptrType$9(function() { return this.$target.Inst.Arg; }, function($v) { this.$target.Inst.Arg = $v; }, x$15))));
				patch = false;
				if (instAlt.Inst.Out === ((pc >>> 0))) {
					patch = true;
				} else if (instAlt.Inst.Arg === ((pc >>> 0))) {
					patch = true;
					_tmp$2 = p_B_Other;
					_tmp$3 = p_B_Alt;
					p_B_Alt = _tmp$2;
					p_B_Other = _tmp$3;
				}
				if (patch) {
					p_B_Alt.$set(p_A_Other.$get());
				}
				if (p_A_Other.$get() === p_B_Alt.$get()) {
					p_A_Alt.$set(p_B_Other.$get());
				}
			} else {
				_i$1++;
				continue;
			}
			_i$1++;
		}
		return p;
	};
	runeSlice.prototype.Len = function() {
		var p;
		p = this;
		return p.$length;
	};
	$ptrType(runeSlice).prototype.Len = function() { return this.$get().Len(); };
	runeSlice.prototype.Less = function(i, j) {
		var i, j, p;
		p = this;
		return ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]) < ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j]);
	};
	$ptrType(runeSlice).prototype.Less = function(i, j) { return this.$get().Less(i, j); };
	runeSlice.prototype.Swap = function(i, j) {
		var _tmp, _tmp$1, i, j, p;
		p = this;
		_tmp = ((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j]);
		_tmp$1 = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]);
		((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i] = _tmp);
		((j < 0 || j >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + j] = _tmp$1);
	};
	$ptrType(runeSlice).prototype.Swap = function(i, j) { return this.$get().Swap(i, j); };
	makeOnePass = function(p) {
		var _i, _r, _ref, check, i, instQueue, m, onePassRunes, p, pc, visitQueue, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; check = $f.check; i = $f.i; instQueue = $f.instQueue; m = $f.m; onePassRunes = $f.onePassRunes; p = $f.p; pc = $f.pc; visitQueue = $f.visitQueue; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		check = [check];
		instQueue = [instQueue];
		onePassRunes = [onePassRunes];
		p = [p];
		visitQueue = [visitQueue];
		if (p[0].Inst.$length >= 1000) {
			$s = -1; return ptrType$6.nil;
		}
		instQueue[0] = newQueue(p[0].Inst.$length);
		visitQueue[0] = newQueue(p[0].Inst.$length);
		check[0] = $throwNilPointerError;
		onePassRunes[0] = $makeSlice(sliceType$7, p[0].Inst.$length);
		check[0] = (function(check, instQueue, onePassRunes, p, visitQueue) { return function $b(pc, m) {
			var _1, _i, _i$1, _i$2, _i$3, _i$4, _q, _q$1, _q$2, _q$3, _q$4, _r, _r$1, _r$2, _r$3, _r$4, _ref, _ref$1, _ref$2, _ref$3, _ref$4, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _v, i, i$1, i$2, i$3, i$4, inst, m, matchArg, matchOut, ok, pc, r0, r0$1, r1, r1$1, runes, runes$1, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _i$3 = $f._i$3; _i$4 = $f._i$4; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _q$3 = $f._q$3; _q$4 = $f._q$4; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _ref$3 = $f._ref$3; _ref$4 = $f._ref$4; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; _v = $f._v; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; i$4 = $f.i$4; inst = $f.inst; m = $f.m; matchArg = $f.matchArg; matchOut = $f.matchOut; ok = $f.ok; pc = $f.pc; r0 = $f.r0; r0$1 = $f.r0$1; r1 = $f.r1; r1$1 = $f.r1$1; runes = $f.runes; runes$1 = $f.runes$1; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$16 = $f.x$16; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			ok = false;
			ok = true;
			inst = (x = p[0].Inst, ((pc < 0 || pc >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pc]));
			if (visitQueue[0].contains(pc)) {
				$s = -1; return ok;
			}
			visitQueue[0].insert(pc);
				_1 = inst.Inst.Op;
				/* */ if ((_1 === (0)) || (_1 === (1))) { $s = 2; continue; }
				/* */ if ((_1 === (2)) || (_1 === (6))) { $s = 3; continue; }
				/* */ if (_1 === (3)) { $s = 4; continue; }
				/* */ if ((_1 === (4)) || (_1 === (5))) { $s = 5; continue; }
				/* */ if (_1 === (7)) { $s = 6; continue; }
				/* */ if (_1 === (8)) { $s = 7; continue; }
				/* */ if (_1 === (9)) { $s = 8; continue; }
				/* */ if (_1 === (10)) { $s = 9; continue; }
				/* */ $s = 10; continue;
				/* if ((_1 === (0)) || (_1 === (1))) { */ case 2:
					_r = check[0](inst.Inst.Out, m); /* */ $s = 12; case 12: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					if (!(_r)) { _v = false; $s = 11; continue s; }
					_r$1 = check[0](inst.Inst.Arg, m); /* */ $s = 13; case 13: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_v = _r$1; case 11:
					ok = _v;
					matchOut = (x$1 = inst.Inst.Out, ((x$1 < 0 || x$1 >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + x$1]));
					matchArg = (x$2 = inst.Inst.Arg, ((x$2 < 0 || x$2 >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + x$2]));
					if (matchOut && matchArg) {
						ok = false;
						/* break; */ $s = 1; continue;
					}
					if (matchArg) {
						_tmp = inst.Inst.Arg;
						_tmp$1 = inst.Inst.Out;
						inst.Inst.Out = _tmp;
						inst.Inst.Arg = _tmp$1;
						_tmp$2 = matchArg;
						_tmp$3 = matchOut;
						matchOut = _tmp$2;
						matchArg = _tmp$3;
					}
					if (matchOut) {
						((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = true);
						inst.Inst.Op = 1;
					}
					_r$2 = mergeRuneSets($indexPtr(onePassRunes[0].$array, onePassRunes[0].$offset + inst.Inst.Out, ptrType$10), $indexPtr(onePassRunes[0].$array, onePassRunes[0].$offset + inst.Inst.Arg, ptrType$10), inst.Inst.Out, inst.Inst.Arg); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_tuple = _r$2;
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = _tuple[0]);
					inst.Next = _tuple[1];
					if (inst.Next.$length > 0 && ((x$3 = inst.Next, (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])) === 4294967295)) {
						ok = false;
						/* break; */ $s = 1; continue;
					}
					$s = 10; continue;
				/* } else if ((_1 === (2)) || (_1 === (6))) { */ case 3:
					_r$3 = check[0](inst.Inst.Out, m); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					ok = _r$3;
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = (x$4 = inst.Inst.Out, ((x$4 < 0 || x$4 >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + x$4])));
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = $appendSlice(new sliceType$1([]), (x$5 = inst.Inst.Out, ((x$5 < 0 || x$5 >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + x$5]))));
					inst.Next = $makeSlice(sliceType$2, ((_q = ((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc]).$length / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0));
					_ref = inst.Next;
					_i = 0;
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						i = _i;
						(x$6 = inst.Next, ((i < 0 || i >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + i] = inst.Inst.Out));
						_i++;
					}
					$s = 10; continue;
				/* } else if (_1 === (3)) { */ case 4:
					_r$4 = check[0](inst.Inst.Out, m); /* */ $s = 16; case 16: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					ok = _r$4;
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = (x$7 = inst.Inst.Out, ((x$7 < 0 || x$7 >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + x$7])));
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = $appendSlice(new sliceType$1([]), (x$8 = inst.Inst.Out, ((x$8 < 0 || x$8 >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + x$8]))));
					inst.Next = $makeSlice(sliceType$2, ((_q$1 = ((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc]).$length / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0));
					_ref$1 = inst.Next;
					_i$1 = 0;
					while (true) {
						if (!(_i$1 < _ref$1.$length)) { break; }
						i$1 = _i$1;
						(x$9 = inst.Next, ((i$1 < 0 || i$1 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + i$1] = inst.Inst.Out));
						_i$1++;
					}
					$s = 10; continue;
				/* } else if ((_1 === (4)) || (_1 === (5))) { */ case 5:
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = (inst.Inst.Op === 4));
					$s = 10; continue;
				/* } else if (_1 === (7)) { */ case 6:
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = false);
					if (inst.Next.$length > 0) {
						/* break; */ $s = 1; continue;
					}
					instQueue[0].insert(inst.Inst.Out);
					if (inst.Inst.Rune.$length === 0) {
						((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = new sliceType$1([]));
						inst.Next = new sliceType$2([inst.Inst.Out]);
						/* break; */ $s = 1; continue;
					}
					runes = $makeSlice(sliceType$1, 0);
					/* */ if ((inst.Inst.Rune.$length === 1) && !((((((inst.Inst.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { $s = 17; continue; }
					/* */ $s = 18; continue;
					/* if ((inst.Inst.Rune.$length === 1) && !((((((inst.Inst.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { */ case 17:
						r0 = (x$10 = inst.Inst.Rune, (0 >= x$10.$length ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + 0]));
						runes = $append(runes, r0, r0);
						r1 = unicode.SimpleFold(r0);
						while (true) {
							if (!(!((r1 === r0)))) { break; }
							runes = $append(runes, r1, r1);
							r1 = unicode.SimpleFold(r1);
						}
						$r = sort.Sort(($subslice(new runeSlice(runes.$array), runes.$offset, runes.$offset + runes.$length))); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = 19; continue;
					/* } else { */ case 18:
						runes = $appendSlice(runes, inst.Inst.Rune);
					/* } */ case 19:
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = runes);
					inst.Next = $makeSlice(sliceType$2, ((_q$2 = ((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc]).$length / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0));
					_ref$2 = inst.Next;
					_i$2 = 0;
					while (true) {
						if (!(_i$2 < _ref$2.$length)) { break; }
						i$2 = _i$2;
						(x$11 = inst.Next, ((i$2 < 0 || i$2 >= x$11.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$11.$array[x$11.$offset + i$2] = inst.Inst.Out));
						_i$2++;
					}
					inst.Inst.Op = 7;
					$s = 10; continue;
				/* } else if (_1 === (8)) { */ case 7:
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = false);
					if (inst.Next.$length > 0) {
						/* break; */ $s = 1; continue;
					}
					instQueue[0].insert(inst.Inst.Out);
					runes$1 = new sliceType$1([]);
					/* */ if (!((((((inst.Inst.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { $s = 21; continue; }
					/* */ $s = 22; continue;
					/* if (!((((((inst.Inst.Arg << 16 >>> 16)) & 1) >>> 0) === 0))) { */ case 21:
						r0$1 = (x$12 = inst.Inst.Rune, (0 >= x$12.$length ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + 0]));
						runes$1 = $append(runes$1, r0$1, r0$1);
						r1$1 = unicode.SimpleFold(r0$1);
						while (true) {
							if (!(!((r1$1 === r0$1)))) { break; }
							runes$1 = $append(runes$1, r1$1, r1$1);
							r1$1 = unicode.SimpleFold(r1$1);
						}
						$r = sort.Sort(($subslice(new runeSlice(runes$1.$array), runes$1.$offset, runes$1.$offset + runes$1.$length))); /* */ $s = 24; case 24: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = 23; continue;
					/* } else { */ case 22:
						runes$1 = $append(runes$1, (x$13 = inst.Inst.Rune, (0 >= x$13.$length ? ($throwRuntimeError("index out of range"), undefined) : x$13.$array[x$13.$offset + 0])), (x$14 = inst.Inst.Rune, (0 >= x$14.$length ? ($throwRuntimeError("index out of range"), undefined) : x$14.$array[x$14.$offset + 0])));
					/* } */ case 23:
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = runes$1);
					inst.Next = $makeSlice(sliceType$2, ((_q$3 = ((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc]).$length / 2, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0));
					_ref$3 = inst.Next;
					_i$3 = 0;
					while (true) {
						if (!(_i$3 < _ref$3.$length)) { break; }
						i$3 = _i$3;
						(x$15 = inst.Next, ((i$3 < 0 || i$3 >= x$15.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$15.$array[x$15.$offset + i$3] = inst.Inst.Out));
						_i$3++;
					}
					inst.Inst.Op = 7;
					$s = 10; continue;
				/* } else if (_1 === (9)) { */ case 8:
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = false);
					if (inst.Next.$length > 0) {
						/* break; */ $s = 1; continue;
					}
					instQueue[0].insert(inst.Inst.Out);
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = $appendSlice(new sliceType$1([]), anyRune));
					inst.Next = new sliceType$2([inst.Inst.Out]);
					$s = 10; continue;
				/* } else if (_1 === (10)) { */ case 9:
					((pc < 0 || pc >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + pc] = false);
					if (inst.Next.$length > 0) {
						/* break; */ $s = 1; continue;
					}
					instQueue[0].insert(inst.Inst.Out);
					((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc] = $appendSlice(new sliceType$1([]), anyRuneNotNL));
					inst.Next = $makeSlice(sliceType$2, ((_q$4 = ((pc < 0 || pc >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + pc]).$length / 2, (_q$4 === _q$4 && _q$4 !== 1/0 && _q$4 !== -1/0) ? _q$4 >> 0 : $throwRuntimeError("integer divide by zero")) + 1 >> 0));
					_ref$4 = inst.Next;
					_i$4 = 0;
					while (true) {
						if (!(_i$4 < _ref$4.$length)) { break; }
						i$4 = _i$4;
						(x$16 = inst.Next, ((i$4 < 0 || i$4 >= x$16.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$16.$array[x$16.$offset + i$4] = inst.Inst.Out));
						_i$4++;
					}
				/* } */ case 10:
			case 1:
			$s = -1; return ok;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._1 = _1; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._i$3 = _i$3; $f._i$4 = _i$4; $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._q$3 = _q$3; $f._q$4 = _q$4; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._ref$3 = _ref$3; $f._ref$4 = _ref$4; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f._v = _v; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.i$4 = i$4; $f.inst = inst; $f.m = m; $f.matchArg = matchArg; $f.matchOut = matchOut; $f.ok = ok; $f.pc = pc; $f.r0 = r0; $f.r0$1 = r0$1; $f.r1 = r1; $f.r1$1 = r1$1; $f.runes = runes; $f.runes$1 = runes$1; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$16 = x$16; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
		}; })(check, instQueue, onePassRunes, p, visitQueue);
		instQueue[0].clear();
		instQueue[0].insert(((p[0].Start >>> 0)));
		m = $makeSlice(sliceType$8, p[0].Inst.$length);
		/* while (true) { */ case 1:
			/* if (!(!instQueue[0].empty())) { break; } */ if(!(!instQueue[0].empty())) { $s = 2; continue; }
			visitQueue[0].clear();
			pc = instQueue[0].next();
			_r = check[0](pc, m); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (!_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!_r) { */ case 3:
				p[0] = ptrType$6.nil;
				/* break; */ $s = 2; continue;
			/* } */ case 4:
		/* } */ $s = 1; continue; case 2:
		if (!(p[0] === ptrType$6.nil)) {
			_ref = p[0].Inst;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				(x = p[0].Inst, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).Inst.Rune = ((i < 0 || i >= onePassRunes[0].$length) ? ($throwRuntimeError("index out of range"), undefined) : onePassRunes[0].$array[onePassRunes[0].$offset + i]);
				_i++;
			}
		}
		$s = -1; return p[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeOnePass }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.check = check; $f.i = i; $f.instQueue = instQueue; $f.m = m; $f.onePassRunes = onePassRunes; $f.p = p; $f.pc = pc; $f.visitQueue = visitQueue; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	compileOnePass = function(prog) {
		var _1, _i, _r, _ref, inst, opOut, p, prog, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _r = $f._r; _ref = $f._ref; inst = $f.inst; opOut = $f.opOut; p = $f.p; prog = $f.prog; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = ptrType$6.nil;
		if (prog.Start === 0) {
			p = ptrType$6.nil;
			$s = -1; return p;
		}
		if (!(((x = prog.Inst, x$1 = prog.Start, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])).Op === 3)) || !(((((((x$2 = prog.Inst, x$3 = prog.Start, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])).Arg << 24 >>> 24)) & 4) >>> 0) === 4))) {
			p = ptrType$6.nil;
			$s = -1; return p;
		}
		_ref = prog.Inst;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			inst = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), syntax.Inst);
			opOut = (x$4 = prog.Inst, x$5 = inst.Out, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])).Op;
			_1 = inst.Op;
			if ((_1 === (0)) || (_1 === (1))) {
				if ((opOut === 4) || ((x$6 = prog.Inst, x$7 = inst.Arg, ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7])).Op === 4)) {
					p = ptrType$6.nil;
					$s = -1; return p;
				}
			} else if (_1 === (3)) {
				if (opOut === 4) {
					if (((((inst.Arg << 24 >>> 24)) & 8) >>> 0) === 8) {
						_i++;
						/* continue; */ $s = 1; continue;
					}
					p = ptrType$6.nil;
					$s = -1; return p;
				}
			} else if (opOut === 4) {
				p = ptrType$6.nil;
				$s = -1; return p;
			}
			_i++;
		/* } */ $s = 1; continue; case 2:
		p = onePassCopy(prog);
		_r = makeOnePass(p); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = _r;
		if (!(p === ptrType$6.nil)) {
			cleanupOnePass(p, prog);
		}
		p = p;
		$s = -1; return p;
		/* */ } return; } if ($f === undefined) { $f = { $blk: compileOnePass }; } $f._1 = _1; $f._i = _i; $f._r = _r; $f._ref = _ref; $f.inst = inst; $f.opOut = opOut; $f.p = p; $f.prog = prog; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.ptr.prototype.String = function() {
		var re;
		re = this;
		return re.expr;
	};
	Regexp.prototype.String = function() { return this.$val.String(); };
	Regexp.ptr.prototype.Copy = function() {
		var re, re2;
		re = this;
		re2 = $clone(re, Regexp);
		return re2;
	};
	Regexp.prototype.Copy = function() { return this.$val.Copy(); };
	Compile = function(expr) {
		var _r, expr, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; expr = $f.expr; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = compile(expr, 212, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Compile }; } $f._r = _r; $f.expr = expr; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Compile = Compile;
	Regexp.ptr.prototype.Longest = function() {
		var re;
		re = this;
		re.longest = true;
	};
	Regexp.prototype.Longest = function() { return this.$val.Longest(); };
	compile = function(expr, mode, longest) {
		var _r, _r$1, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, capNames, err, expr, i, longest, matchcap, maxCap, mode, n, prog, re, regexp, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; capNames = $f.capNames; err = $f.err; expr = $f.expr; i = $f.i; longest = $f.longest; matchcap = $f.matchcap; maxCap = $f.maxCap; mode = $f.mode; n = $f.n; prog = $f.prog; re = $f.re; regexp = $f.regexp; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = syntax.Parse(expr, mode); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		re = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [ptrType$11.nil, err];
		}
		maxCap = re.MaxCap();
		capNames = re.CapNames();
		re = re.Simplify();
		_tuple$1 = syntax.Compile(re);
		prog = _tuple$1[0];
		err = _tuple$1[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [ptrType$11.nil, err];
		}
		matchcap = prog.NumCap;
		if (matchcap < 2) {
			matchcap = 2;
		}
		_r$1 = compileOnePass(prog); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		regexp = new Regexp.ptr(expr, prog, _r$1, maxCap, 0, capNames, "", sliceType$5.nil, 0, 0, 0, matchcap, false, prog.StartCond(), longest);
		if (regexp.onepass === ptrType$6.nil) {
			_tuple$2 = prog.Prefix();
			regexp.prefix = _tuple$2[0];
			regexp.prefixComplete = _tuple$2[1];
			regexp.maxBitStateLen = maxBitStateLen(prog);
		} else {
			_tuple$3 = onePassPrefix(prog);
			regexp.prefix = _tuple$3[0];
			regexp.prefixComplete = _tuple$3[1];
			regexp.prefixEnd = _tuple$3[2];
		}
		if (!(regexp.prefix === "")) {
			regexp.prefixBytes = (new sliceType$5($stringToBytes(regexp.prefix)));
			_tuple$4 = utf8.DecodeRuneInString(regexp.prefix);
			regexp.prefixRune = _tuple$4[0];
		}
		n = prog.Inst.$length;
		i = 0;
		while (true) {
			if (!(!((((i < 0 || i >= matchSize.length) ? ($throwRuntimeError("index out of range"), undefined) : matchSize[i]) === 0)) && ((i < 0 || i >= matchSize.length) ? ($throwRuntimeError("index out of range"), undefined) : matchSize[i]) < n)) { break; }
			i = i + (1) >> 0;
		}
		regexp.mpool = i;
		$s = -1; return [regexp, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: compile }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f.capNames = capNames; $f.err = err; $f.expr = expr; $f.i = i; $f.longest = longest; $f.matchcap = matchcap; $f.maxCap = maxCap; $f.mode = mode; $f.n = n; $f.prog = prog; $f.re = re; $f.regexp = regexp; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.ptr.prototype.get = function() {
		var _i, _r, _ref, _tuple, m, n, ok, re, t, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _tuple = $f._tuple; m = $f.m; n = $f.n; ok = $f.ok; re = $f.re; t = $f.t; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = (x = re.mpool, ((x < 0 || x >= matchPool.length) ? ($throwRuntimeError("index out of range"), undefined) : matchPool[x])).Get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = $assertType(_r, ptrType$13, true);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = new machine.ptr(ptrType$11.nil, ptrType$12.nil, new queue.ptr(sliceType$2.nil, sliceType$10.nil), new queue.ptr(sliceType$2.nil, sliceType$10.nil), sliceType$11.nil, false, sliceType$3.nil, new inputs.ptr(new inputBytes.ptr(sliceType$5.nil), new inputString.ptr(""), new inputReader.ptr($ifaceNil, false, 0)));
		}
		m.re = re;
		m.p = re.prog;
		if (m.matchcap.$capacity < re.matchcap) {
			m.matchcap = $makeSlice(sliceType$3, re.matchcap);
			_ref = m.pool;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				t = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				t.cap = $makeSlice(sliceType$3, re.matchcap);
				_i++;
			}
		}
		n = (x$1 = re.mpool, ((x$1 < 0 || x$1 >= matchSize.length) ? ($throwRuntimeError("index out of range"), undefined) : matchSize[x$1]));
		if (n === 0) {
			n = re.prog.Inst.$length;
		}
		if (m.q0.sparse.$length < n) {
			queue.copy(m.q0, new queue.ptr($makeSlice(sliceType$2, n), $makeSlice(sliceType$10, 0, n)));
			queue.copy(m.q1, new queue.ptr($makeSlice(sliceType$2, n), $makeSlice(sliceType$10, 0, n)));
		}
		$s = -1; return m;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.get }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._tuple = _tuple; $f.m = m; $f.n = n; $f.ok = ok; $f.re = re; $f.t = t; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.get = function() { return this.$val.get(); };
	Regexp.ptr.prototype.put = function(m) {
		var m, re, x;
		re = this;
		m.re = ptrType$11.nil;
		m.p = ptrType$12.nil;
		m.inputs.clear();
		(x = re.mpool, ((x < 0 || x >= matchPool.length) ? ($throwRuntimeError("index out of range"), undefined) : matchPool[x])).Put(m);
	};
	Regexp.prototype.put = function(m) { return this.$val.put(m); };
	MustCompile = function(str) {
		var _r, _r$1, _tuple, err, regexp, str, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; err = $f.err; regexp = $f.regexp; str = $f.str; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = Compile(str); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		regexp = _tuple[0];
		err = _tuple[1];
		/* */ if (!($interfaceIsEqual(err, $ifaceNil))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
			_r$1 = err.Error(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$panic(new $String("regexp: Compile(" + quote(str) + "): " + _r$1));
		/* } */ case 3:
		$s = -1; return regexp;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MustCompile }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.err = err; $f.regexp = regexp; $f.str = str; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MustCompile = MustCompile;
	quote = function(s) {
		var s;
		if (strconv.CanBackquote(s)) {
			return "`" + s + "`";
		}
		return strconv.Quote(s);
	};
	Regexp.ptr.prototype.NumSubexp = function() {
		var re;
		re = this;
		return re.numSubexp;
	};
	Regexp.prototype.NumSubexp = function() { return this.$val.NumSubexp(); };
	Regexp.ptr.prototype.SubexpNames = function() {
		var re;
		re = this;
		return re.subexpNames;
	};
	Regexp.prototype.SubexpNames = function() { return this.$val.SubexpNames(); };
	inputString.ptr.prototype.step = function(pos) {
		var c, i, pos;
		i = this;
		if (pos < i.str.length) {
			c = i.str.charCodeAt(pos);
			if (c < 128) {
				return [((c >> 0)), 1];
			}
			return utf8.DecodeRuneInString($substring(i.str, pos));
		}
		return [-1, 0];
	};
	inputString.prototype.step = function(pos) { return this.$val.step(pos); };
	inputString.ptr.prototype.canCheckPrefix = function() {
		var i;
		i = this;
		return true;
	};
	inputString.prototype.canCheckPrefix = function() { return this.$val.canCheckPrefix(); };
	inputString.ptr.prototype.hasPrefix = function(re) {
		var i, re;
		i = this;
		return strings.HasPrefix(i.str, re.prefix);
	};
	inputString.prototype.hasPrefix = function(re) { return this.$val.hasPrefix(re); };
	inputString.ptr.prototype.index = function(re, pos) {
		var i, pos, re;
		i = this;
		return strings.Index($substring(i.str, pos), re.prefix);
	};
	inputString.prototype.index = function(re, pos) { return this.$val.index(re, pos); };
	inputString.ptr.prototype.context = function(pos) {
		var _tmp, _tmp$1, _tuple, _tuple$1, i, pos, r1, r2;
		i = this;
		_tmp = -1;
		_tmp$1 = -1;
		r1 = _tmp;
		r2 = _tmp$1;
		if ((((pos - 1 >> 0) >>> 0)) < ((i.str.length >>> 0))) {
			r1 = ((i.str.charCodeAt((pos - 1 >> 0)) >> 0));
			if (r1 >= 128) {
				_tuple = utf8.DecodeLastRuneInString($substring(i.str, 0, pos));
				r1 = _tuple[0];
			}
		}
		if (((pos >>> 0)) < ((i.str.length >>> 0))) {
			r2 = ((i.str.charCodeAt(pos) >> 0));
			if (r2 >= 128) {
				_tuple$1 = utf8.DecodeRuneInString($substring(i.str, pos));
				r2 = _tuple$1[0];
			}
		}
		return newLazyFlag(r1, r2);
	};
	inputString.prototype.context = function(pos) { return this.$val.context(pos); };
	inputBytes.ptr.prototype.step = function(pos) {
		var c, i, pos, x;
		i = this;
		if (pos < i.str.$length) {
			c = (x = i.str, ((pos < 0 || pos >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + pos]));
			if (c < 128) {
				return [((c >> 0)), 1];
			}
			return utf8.DecodeRune($subslice(i.str, pos));
		}
		return [-1, 0];
	};
	inputBytes.prototype.step = function(pos) { return this.$val.step(pos); };
	inputBytes.ptr.prototype.canCheckPrefix = function() {
		var i;
		i = this;
		return true;
	};
	inputBytes.prototype.canCheckPrefix = function() { return this.$val.canCheckPrefix(); };
	inputBytes.ptr.prototype.hasPrefix = function(re) {
		var i, re;
		i = this;
		return bytes.HasPrefix(i.str, re.prefixBytes);
	};
	inputBytes.prototype.hasPrefix = function(re) { return this.$val.hasPrefix(re); };
	inputBytes.ptr.prototype.index = function(re, pos) {
		var i, pos, re;
		i = this;
		return bytes.Index($subslice(i.str, pos), re.prefixBytes);
	};
	inputBytes.prototype.index = function(re, pos) { return this.$val.index(re, pos); };
	inputBytes.ptr.prototype.context = function(pos) {
		var _tmp, _tmp$1, _tuple, _tuple$1, i, pos, r1, r2, x, x$1, x$2;
		i = this;
		_tmp = -1;
		_tmp$1 = -1;
		r1 = _tmp;
		r2 = _tmp$1;
		if ((((pos - 1 >> 0) >>> 0)) < ((i.str.$length >>> 0))) {
			r1 = (((x = i.str, x$1 = pos - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])) >> 0));
			if (r1 >= 128) {
				_tuple = utf8.DecodeLastRune($subslice(i.str, 0, pos));
				r1 = _tuple[0];
			}
		}
		if (((pos >>> 0)) < ((i.str.$length >>> 0))) {
			r2 = (((x$2 = i.str, ((pos < 0 || pos >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + pos])) >> 0));
			if (r2 >= 128) {
				_tuple$1 = utf8.DecodeRune($subslice(i.str, pos));
				r2 = _tuple$1[0];
			}
		}
		return newLazyFlag(r1, r2);
	};
	inputBytes.prototype.context = function(pos) { return this.$val.context(pos); };
	inputReader.ptr.prototype.step = function(pos) {
		var _r, _tuple, err, i, pos, r, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; i = $f.i; pos = $f.pos; r = $f.r; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (!i.atEOT && !((pos === i.pos))) {
			$s = -1; return [-1, 0];
		}
		_r = i.r.ReadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		w = _tuple[1];
		err = _tuple[2];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			i.atEOT = true;
			$s = -1; return [-1, 0];
		}
		i.pos = i.pos + (w) >> 0;
		$s = -1; return [r, w];
		/* */ } return; } if ($f === undefined) { $f = { $blk: inputReader.ptr.prototype.step }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.i = i; $f.pos = pos; $f.r = r; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	inputReader.prototype.step = function(pos) { return this.$val.step(pos); };
	inputReader.ptr.prototype.canCheckPrefix = function() {
		var i;
		i = this;
		return false;
	};
	inputReader.prototype.canCheckPrefix = function() { return this.$val.canCheckPrefix(); };
	inputReader.ptr.prototype.hasPrefix = function(re) {
		var i, re;
		i = this;
		return false;
	};
	inputReader.prototype.hasPrefix = function(re) { return this.$val.hasPrefix(re); };
	inputReader.ptr.prototype.index = function(re, pos) {
		var i, pos, re;
		i = this;
		return -1;
	};
	inputReader.prototype.index = function(re, pos) { return this.$val.index(re, pos); };
	inputReader.ptr.prototype.context = function(pos) {
		var i, pos;
		i = this;
		return new lazyFlag(0, 0);
	};
	inputReader.prototype.context = function(pos) { return this.$val.context(pos); };
	Regexp.ptr.prototype.LiteralPrefix = function() {
		var _tmp, _tmp$1, complete, prefix, re;
		prefix = "";
		complete = false;
		re = this;
		_tmp = re.prefix;
		_tmp$1 = re.prefixComplete;
		prefix = _tmp;
		complete = _tmp$1;
		return [prefix, complete];
	};
	Regexp.prototype.LiteralPrefix = function() { return this.$val.LiteralPrefix(); };
	Regexp.ptr.prototype.MatchReader = function(r) {
		var _r, r, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doMatch(r, sliceType$5.nil, ""); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.MatchReader }; } $f._r = _r; $f.r = r; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.MatchReader = function(r) { return this.$val.MatchReader(r); };
	Regexp.ptr.prototype.MatchString = function(s) {
		var _r, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doMatch($ifaceNil, sliceType$5.nil, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.MatchString }; } $f._r = _r; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.MatchString = function(s) { return this.$val.MatchString(s); };
	Regexp.ptr.prototype.Match = function(b) {
		var _r, b, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doMatch($ifaceNil, b, ""); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.Match }; } $f._r = _r; $f.b = b; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.Match = function(b) { return this.$val.Match(b); };
	Regexp.ptr.prototype.ReplaceAllString = function(src, repl) {
		var _r, b, n, re, repl, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; n = $f.n; re = $f.re; repl = $f.repl; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = [re];
		repl = [repl];
		src = [src];
		re[0] = this;
		n = 2;
		if (strings.Contains(repl[0], "$")) {
			n = $imul(2, ((re[0].numSubexp + 1 >> 0)));
		}
		_r = re[0].replaceAll(sliceType$5.nil, src[0], n, (function(re, repl, src) { return function(dst, match) {
			var dst, match;
			return re[0].expand(dst, repl[0], sliceType$5.nil, src[0], match);
		}; })(re, repl, src)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		b = _r;
		$s = -1; return ($bytesToString(b));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAllString }; } $f._r = _r; $f.b = b; $f.n = n; $f.re = re; $f.repl = repl; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAllString = function(src, repl) { return this.$val.ReplaceAllString(src, repl); };
	Regexp.ptr.prototype.ReplaceAllLiteralString = function(src, repl) {
		var _r, re, repl, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; re = $f.re; repl = $f.repl; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		repl = [repl];
		re = this;
		_r = re.replaceAll(sliceType$5.nil, src, 2, (function(repl) { return function(dst, match) {
			var dst, match;
			return $appendSlice(dst, repl[0]);
		}; })(repl)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return ($bytesToString(_r));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAllLiteralString }; } $f._r = _r; $f.re = re; $f.repl = repl; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAllLiteralString = function(src, repl) { return this.$val.ReplaceAllLiteralString(src, repl); };
	Regexp.ptr.prototype.ReplaceAllStringFunc = function(src, repl) {
		var _r, b, re, repl, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; re = $f.re; repl = $f.repl; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		repl = [repl];
		src = [src];
		re = this;
		_r = re.replaceAll(sliceType$5.nil, src[0], 2, (function(repl, src) { return function $b(dst, match) {
			var _arg, _arg$1, _r, dst, match, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; dst = $f.dst; match = $f.match; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_arg = dst;
			_r = repl[0]($substring(src[0], (0 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 0]), (1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1]))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_arg$1 = _r;
			$s = -1; return $appendSlice(_arg, _arg$1);
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f.dst = dst; $f.match = match; $f.$s = $s; $f.$r = $r; return $f;
		}; })(repl, src)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		b = _r;
		$s = -1; return ($bytesToString(b));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAllStringFunc }; } $f._r = _r; $f.b = b; $f.re = re; $f.repl = repl; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAllStringFunc = function(src, repl) { return this.$val.ReplaceAllStringFunc(src, repl); };
	Regexp.ptr.prototype.replaceAll = function(bsrc, src, nmatch, repl) {
		var _r, _r$1, _tuple, _tuple$1, a, bsrc, buf, dstCap, endPos, lastMatchEnd, nmatch, re, repl, searchPos, src, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; a = $f.a; bsrc = $f.bsrc; buf = $f.buf; dstCap = $f.dstCap; endPos = $f.endPos; lastMatchEnd = $f.lastMatchEnd; nmatch = $f.nmatch; re = $f.re; repl = $f.repl; searchPos = $f.searchPos; src = $f.src; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		lastMatchEnd = 0;
		searchPos = 0;
		buf = sliceType$5.nil;
		endPos = 0;
		if (!(bsrc === sliceType$5.nil)) {
			endPos = bsrc.$length;
		} else {
			endPos = src.length;
		}
		if (nmatch > re.prog.NumCap) {
			nmatch = re.prog.NumCap;
		}
		dstCap = arrayType$3.zero();
		/* while (true) { */ case 1:
			/* if (!(searchPos <= endPos)) { break; } */ if(!(searchPos <= endPos)) { $s = 2; continue; }
			_r = re.doExecute($ifaceNil, bsrc, src, searchPos, nmatch, $subslice(new sliceType$3(dstCap), 0, 0)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			a = _r;
			if (a.$length === 0) {
				/* break; */ $s = 2; continue;
			}
			if (!(bsrc === sliceType$5.nil)) {
				buf = $appendSlice(buf, $subslice(bsrc, lastMatchEnd, (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0])));
			} else {
				buf = $appendSlice(buf, $substring(src, lastMatchEnd, (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0])));
			}
			/* */ if ((1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]) > lastMatchEnd || ((0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]) === 0)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if ((1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]) > lastMatchEnd || ((0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]) === 0)) { */ case 4:
				_r$1 = repl(buf, a); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				buf = _r$1;
			/* } */ case 5:
			lastMatchEnd = (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]);
			width = 0;
			if (!(bsrc === sliceType$5.nil)) {
				_tuple = utf8.DecodeRune($subslice(bsrc, searchPos));
				width = _tuple[1];
			} else {
				_tuple$1 = utf8.DecodeRuneInString($substring(src, searchPos));
				width = _tuple$1[1];
			}
			if ((searchPos + width >> 0) > (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1])) {
				searchPos = searchPos + (width) >> 0;
			} else if ((searchPos + 1 >> 0) > (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1])) {
				searchPos = searchPos + (1) >> 0;
			} else {
				searchPos = (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]);
			}
		/* } */ $s = 1; continue; case 2:
		if (!(bsrc === sliceType$5.nil)) {
			buf = $appendSlice(buf, $subslice(bsrc, lastMatchEnd));
		} else {
			buf = $appendSlice(buf, $substring(src, lastMatchEnd));
		}
		$s = -1; return buf;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.replaceAll }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.a = a; $f.bsrc = bsrc; $f.buf = buf; $f.dstCap = dstCap; $f.endPos = endPos; $f.lastMatchEnd = lastMatchEnd; $f.nmatch = nmatch; $f.re = re; $f.repl = repl; $f.searchPos = searchPos; $f.src = src; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.replaceAll = function(bsrc, src, nmatch, repl) { return this.$val.replaceAll(bsrc, src, nmatch, repl); };
	Regexp.ptr.prototype.ReplaceAll = function(src, repl) {
		var _r, b, n, re, repl, src, srepl, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; n = $f.n; re = $f.re; repl = $f.repl; src = $f.src; srepl = $f.srepl; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = [re];
		repl = [repl];
		src = [src];
		srepl = [srepl];
		re[0] = this;
		n = 2;
		if (bytes.IndexByte(repl[0], 36) >= 0) {
			n = $imul(2, ((re[0].numSubexp + 1 >> 0)));
		}
		srepl[0] = "";
		_r = re[0].replaceAll(src[0], "", n, (function(re, repl, src, srepl) { return function(dst, match) {
			var dst, match;
			if (!((srepl[0].length === repl[0].$length))) {
				srepl[0] = ($bytesToString(repl[0]));
			}
			return re[0].expand(dst, srepl[0], src[0], "", match);
		}; })(re, repl, src, srepl)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		b = _r;
		$s = -1; return b;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAll }; } $f._r = _r; $f.b = b; $f.n = n; $f.re = re; $f.repl = repl; $f.src = src; $f.srepl = srepl; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAll = function(src, repl) { return this.$val.ReplaceAll(src, repl); };
	Regexp.ptr.prototype.ReplaceAllLiteral = function(src, repl) {
		var _r, re, repl, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; re = $f.re; repl = $f.repl; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		repl = [repl];
		re = this;
		_r = re.replaceAll(src, "", 2, (function(repl) { return function(dst, match) {
			var dst, match;
			return $appendSlice(dst, repl[0]);
		}; })(repl)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAllLiteral }; } $f._r = _r; $f.re = re; $f.repl = repl; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAllLiteral = function(src, repl) { return this.$val.ReplaceAllLiteral(src, repl); };
	Regexp.ptr.prototype.ReplaceAllFunc = function(src, repl) {
		var _r, re, repl, src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; re = $f.re; repl = $f.repl; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		repl = [repl];
		src = [src];
		re = this;
		_r = re.replaceAll(src[0], "", 2, (function(repl, src) { return function $b(dst, match) {
			var _arg, _arg$1, _r, dst, match, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; dst = $f.dst; match = $f.match; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_arg = dst;
			_r = repl[0]($subslice(src[0], (0 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 0]), (1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1]))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_arg$1 = _r;
			$s = -1; return $appendSlice(_arg, _arg$1);
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f.dst = dst; $f.match = match; $f.$s = $s; $f.$r = $r; return $f;
		}; })(repl, src)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.ReplaceAllFunc }; } $f._r = _r; $f.re = re; $f.repl = repl; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.ReplaceAllFunc = function(src, repl) { return this.$val.ReplaceAllFunc(src, repl); };
	init = function() {
		var _i, _index, _q, _r, _ref, b, y;
		_ref = (new sliceType$5($stringToBytes("\\.+*?()|[]{}^$")));
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_index = (_r = b % 16, _r === _r ? _r : $throwRuntimeError("integer divide by zero"));
			((_index < 0 || _index >= specialBytes.length) ? ($throwRuntimeError("index out of range"), undefined) : specialBytes[_index] = ((((_index < 0 || _index >= specialBytes.length) ? ($throwRuntimeError("index out of range"), undefined) : specialBytes[_index]) | (((y = ((_q = b / 16, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"))), y < 32 ? (1 << y) : 0) << 24 >>> 24))) >>> 0));
			_i++;
		}
	};
	Regexp.ptr.prototype.pad = function(a) {
		var a, n, re;
		re = this;
		if (a === sliceType$3.nil) {
			return sliceType$3.nil;
		}
		n = $imul(((1 + re.numSubexp >> 0)), 2);
		while (true) {
			if (!(a.$length < n)) { break; }
			a = $append(a, -1);
		}
		return a;
	};
	Regexp.prototype.pad = function(a) { return this.$val.pad(a); };
	Regexp.ptr.prototype.allMatches = function(s, b, n, deliver) {
		var _r, _tmp, _tmp$1, _tmp$2, _tuple, _tuple$1, accept, b, deliver, end, i, matches, n, pos, prevMatchEnd, re, s, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; accept = $f.accept; b = $f.b; deliver = $f.deliver; end = $f.end; i = $f.i; matches = $f.matches; n = $f.n; pos = $f.pos; prevMatchEnd = $f.prevMatchEnd; re = $f.re; s = $f.s; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		end = 0;
		if (b === sliceType$5.nil) {
			end = s.length;
		} else {
			end = b.$length;
		}
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = -1;
		pos = _tmp;
		i = _tmp$1;
		prevMatchEnd = _tmp$2;
		/* while (true) { */ case 1:
			/* if (!(i < n && pos <= end)) { break; } */ if(!(i < n && pos <= end)) { $s = 2; continue; }
			_r = re.doExecute($ifaceNil, b, s, pos, re.prog.NumCap, sliceType$3.nil); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			matches = _r;
			if (matches.$length === 0) {
				/* break; */ $s = 2; continue;
			}
			accept = true;
			if ((1 >= matches.$length ? ($throwRuntimeError("index out of range"), undefined) : matches.$array[matches.$offset + 1]) === pos) {
				if ((0 >= matches.$length ? ($throwRuntimeError("index out of range"), undefined) : matches.$array[matches.$offset + 0]) === prevMatchEnd) {
					accept = false;
				}
				width = 0;
				if (b === sliceType$5.nil) {
					_tuple = utf8.DecodeRuneInString($substring(s, pos, end));
					width = _tuple[1];
				} else {
					_tuple$1 = utf8.DecodeRune($subslice(b, pos, end));
					width = _tuple$1[1];
				}
				if (width > 0) {
					pos = pos + (width) >> 0;
				} else {
					pos = end + 1 >> 0;
				}
			} else {
				pos = (1 >= matches.$length ? ($throwRuntimeError("index out of range"), undefined) : matches.$array[matches.$offset + 1]);
			}
			prevMatchEnd = (1 >= matches.$length ? ($throwRuntimeError("index out of range"), undefined) : matches.$array[matches.$offset + 1]);
			/* */ if (accept) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (accept) { */ case 4:
				$r = deliver(re.pad(matches)); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				i = i + (1) >> 0;
			/* } */ case 5:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.allMatches }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.accept = accept; $f.b = b; $f.deliver = deliver; $f.end = end; $f.i = i; $f.matches = matches; $f.n = n; $f.pos = pos; $f.prevMatchEnd = prevMatchEnd; $f.re = re; $f.s = s; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.allMatches = function(s, b, n, deliver) { return this.$val.allMatches(s, b, n, deliver); };
	Regexp.ptr.prototype.Find = function(b) {
		var _r, a, b, dstCap, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; b = $f.b; dstCap = $f.dstCap; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		dstCap = arrayType$3.zero();
		_r = re.doExecute($ifaceNil, b, "", 0, 2, $subslice(new sliceType$3(dstCap), 0, 0)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$3.nil) {
			$s = -1; return sliceType$5.nil;
		}
		$s = -1; return $subslice(b, (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]), (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.Find }; } $f._r = _r; $f.a = a; $f.b = b; $f.dstCap = dstCap; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.Find = function(b) { return this.$val.Find(b); };
	Regexp.ptr.prototype.FindIndex = function(b) {
		var _r, a, b, loc, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; b = $f.b; loc = $f.loc; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		loc = sliceType$3.nil;
		re = this;
		_r = re.doExecute($ifaceNil, b, "", 0, 2, sliceType$3.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$3.nil) {
			loc = sliceType$3.nil;
			$s = -1; return loc;
		}
		loc = $subslice(a, 0, 2);
		$s = -1; return loc;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindIndex }; } $f._r = _r; $f.a = a; $f.b = b; $f.loc = loc; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindIndex = function(b) { return this.$val.FindIndex(b); };
	Regexp.ptr.prototype.FindString = function(s) {
		var _r, a, dstCap, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; dstCap = $f.dstCap; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		dstCap = arrayType$3.zero();
		_r = re.doExecute($ifaceNil, sliceType$5.nil, s, 0, 2, $subslice(new sliceType$3(dstCap), 0, 0)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$3.nil) {
			$s = -1; return "";
		}
		$s = -1; return $substring(s, (0 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 0]), (1 >= a.$length ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + 1]));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindString }; } $f._r = _r; $f.a = a; $f.dstCap = dstCap; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindString = function(s) { return this.$val.FindString(s); };
	Regexp.ptr.prototype.FindStringIndex = function(s) {
		var _r, a, loc, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; loc = $f.loc; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		loc = sliceType$3.nil;
		re = this;
		_r = re.doExecute($ifaceNil, sliceType$5.nil, s, 0, 2, sliceType$3.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$3.nil) {
			loc = sliceType$3.nil;
			$s = -1; return loc;
		}
		loc = $subslice(a, 0, 2);
		$s = -1; return loc;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindStringIndex }; } $f._r = _r; $f.a = a; $f.loc = loc; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindStringIndex = function(s) { return this.$val.FindStringIndex(s); };
	Regexp.ptr.prototype.FindReaderIndex = function(r) {
		var _r, a, loc, r, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; loc = $f.loc; r = $f.r; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		loc = sliceType$3.nil;
		re = this;
		_r = re.doExecute(r, sliceType$5.nil, "", 0, 2, sliceType$3.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$3.nil) {
			loc = sliceType$3.nil;
			$s = -1; return loc;
		}
		loc = $subslice(a, 0, 2);
		$s = -1; return loc;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindReaderIndex }; } $f._r = _r; $f.a = a; $f.loc = loc; $f.r = r; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindReaderIndex = function(r) { return this.$val.FindReaderIndex(r); };
	Regexp.ptr.prototype.FindSubmatch = function(b) {
		var _i, _r, _ref, a, b, dstCap, i, re, ret, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; a = $f.a; b = $f.b; dstCap = $f.dstCap; i = $f.i; re = $f.re; ret = $f.ret; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		dstCap = arrayType$4.zero();
		_r = re.doExecute($ifaceNil, b, "", 0, re.prog.NumCap, $subslice(new sliceType$3(dstCap), 0, 0)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$3.nil) {
			$s = -1; return sliceType$12.nil;
		}
		ret = $makeSlice(sliceType$12, (1 + re.numSubexp >> 0));
		_ref = ret;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			if (($imul(2, i)) < a.$length && (x = $imul(2, i), ((x < 0 || x >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x])) >= 0) {
				((i < 0 || i >= ret.$length) ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + i] = $subslice(b, (x$1 = $imul(2, i), ((x$1 < 0 || x$1 >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x$1])), (x$2 = ($imul(2, i)) + 1 >> 0, ((x$2 < 0 || x$2 >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x$2]))));
			}
			_i++;
		}
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindSubmatch }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.a = a; $f.b = b; $f.dstCap = dstCap; $f.i = i; $f.re = re; $f.ret = ret; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindSubmatch = function(b) { return this.$val.FindSubmatch(b); };
	Regexp.ptr.prototype.Expand = function(dst, template, src, match) {
		var dst, match, re, src, template;
		re = this;
		return re.expand(dst, ($bytesToString(template)), src, "", match);
	};
	Regexp.prototype.Expand = function(dst, template, src, match) { return this.$val.Expand(dst, template, src, match); };
	Regexp.ptr.prototype.ExpandString = function(dst, template, src, match) {
		var dst, match, re, src, template;
		re = this;
		return re.expand(dst, template, sliceType$5.nil, src, match);
	};
	Regexp.prototype.ExpandString = function(dst, template, src, match) { return this.$val.ExpandString(dst, template, src, match); };
	Regexp.ptr.prototype.expand = function(dst, template, bsrc, src, match) {
		var _i, _ref, _tuple, bsrc, dst, i, i$1, match, name, namei, num, ok, re, rest, src, template, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		re = this;
		while (true) {
			if (!(template.length > 0)) { break; }
			i = strings.Index(template, "$");
			if (i < 0) {
				break;
			}
			dst = $appendSlice(dst, $substring(template, 0, i));
			template = $substring(template, i);
			if (template.length > 1 && (template.charCodeAt(1) === 36)) {
				dst = $append(dst, 36);
				template = $substring(template, 2);
				continue;
			}
			_tuple = extract(template);
			name = _tuple[0];
			num = _tuple[1];
			rest = _tuple[2];
			ok = _tuple[3];
			if (!ok) {
				dst = $append(dst, 36);
				template = $substring(template, 1);
				continue;
			}
			template = rest;
			if (num >= 0) {
				if ((($imul(2, num)) + 1 >> 0) < match.$length && (x = $imul(2, num), ((x < 0 || x >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x])) >= 0) {
					if (!(bsrc === sliceType$5.nil)) {
						dst = $appendSlice(dst, $subslice(bsrc, (x$1 = $imul(2, num), ((x$1 < 0 || x$1 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$1])), (x$2 = ($imul(2, num)) + 1 >> 0, ((x$2 < 0 || x$2 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$2]))));
					} else {
						dst = $appendSlice(dst, $substring(src, (x$3 = $imul(2, num), ((x$3 < 0 || x$3 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$3])), (x$4 = ($imul(2, num)) + 1 >> 0, ((x$4 < 0 || x$4 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$4]))));
					}
				}
			} else {
				_ref = re.subexpNames;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					i$1 = _i;
					namei = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
					if (name === namei && (($imul(2, i$1)) + 1 >> 0) < match.$length && (x$5 = $imul(2, i$1), ((x$5 < 0 || x$5 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$5])) >= 0) {
						if (!(bsrc === sliceType$5.nil)) {
							dst = $appendSlice(dst, $subslice(bsrc, (x$6 = $imul(2, i$1), ((x$6 < 0 || x$6 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$6])), (x$7 = ($imul(2, i$1)) + 1 >> 0, ((x$7 < 0 || x$7 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$7]))));
						} else {
							dst = $appendSlice(dst, $substring(src, (x$8 = $imul(2, i$1), ((x$8 < 0 || x$8 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$8])), (x$9 = ($imul(2, i$1)) + 1 >> 0, ((x$9 < 0 || x$9 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$9]))));
						}
						break;
					}
					_i++;
				}
			}
		}
		dst = $appendSlice(dst, template);
		return dst;
	};
	Regexp.prototype.expand = function(dst, template, bsrc, src, match) { return this.$val.expand(dst, template, bsrc, src, match); };
	extract = function(str) {
		var _tuple, brace, i, i$1, name, num, ok, rest, rune, size, str;
		name = "";
		num = 0;
		rest = "";
		ok = false;
		if (str.length < 2 || !((str.charCodeAt(0) === 36))) {
			return [name, num, rest, ok];
		}
		brace = false;
		if (str.charCodeAt(1) === 123) {
			brace = true;
			str = $substring(str, 2);
		} else {
			str = $substring(str, 1);
		}
		i = 0;
		while (true) {
			if (!(i < str.length)) { break; }
			_tuple = utf8.DecodeRuneInString($substring(str, i));
			rune = _tuple[0];
			size = _tuple[1];
			if (!unicode.IsLetter(rune) && !unicode.IsDigit(rune) && !((rune === 95))) {
				break;
			}
			i = i + (size) >> 0;
		}
		if (i === 0) {
			return [name, num, rest, ok];
		}
		name = $substring(str, 0, i);
		if (brace) {
			if (i >= str.length || !((str.charCodeAt(i) === 125))) {
				return [name, num, rest, ok];
			}
			i = i + (1) >> 0;
		}
		num = 0;
		i$1 = 0;
		while (true) {
			if (!(i$1 < name.length)) { break; }
			if (name.charCodeAt(i$1) < 48 || 57 < name.charCodeAt(i$1) || num >= 100000000) {
				num = -1;
				break;
			}
			num = (($imul(num, 10)) + ((name.charCodeAt(i$1) >> 0)) >> 0) - 48 >> 0;
			i$1 = i$1 + (1) >> 0;
		}
		if ((name.charCodeAt(0) === 48) && name.length > 1) {
			num = -1;
		}
		rest = $substring(str, i);
		ok = true;
		return [name, num, rest, ok];
	};
	Regexp.ptr.prototype.FindSubmatchIndex = function(b) {
		var _r, _r$1, b, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; b = $f.b; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doExecute($ifaceNil, b, "", 0, re.prog.NumCap, sliceType$3.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = re.pad(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindSubmatchIndex }; } $f._r = _r; $f._r$1 = _r$1; $f.b = b; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindSubmatchIndex = function(b) { return this.$val.FindSubmatchIndex(b); };
	Regexp.ptr.prototype.FindStringSubmatch = function(s) {
		var _i, _r, _ref, a, dstCap, i, re, ret, s, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; a = $f.a; dstCap = $f.dstCap; i = $f.i; re = $f.re; ret = $f.ret; s = $f.s; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		dstCap = arrayType$4.zero();
		_r = re.doExecute($ifaceNil, sliceType$5.nil, s, 0, re.prog.NumCap, $subslice(new sliceType$3(dstCap), 0, 0)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		if (a === sliceType$3.nil) {
			$s = -1; return sliceType$9.nil;
		}
		ret = $makeSlice(sliceType$9, (1 + re.numSubexp >> 0));
		_ref = ret;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			if (($imul(2, i)) < a.$length && (x = $imul(2, i), ((x < 0 || x >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x])) >= 0) {
				((i < 0 || i >= ret.$length) ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + i] = $substring(s, (x$1 = $imul(2, i), ((x$1 < 0 || x$1 >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x$1])), (x$2 = ($imul(2, i)) + 1 >> 0, ((x$2 < 0 || x$2 >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x$2]))));
			}
			_i++;
		}
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindStringSubmatch }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.a = a; $f.dstCap = dstCap; $f.i = i; $f.re = re; $f.ret = ret; $f.s = s; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindStringSubmatch = function(s) { return this.$val.FindStringSubmatch(s); };
	Regexp.ptr.prototype.FindStringSubmatchIndex = function(s) {
		var _r, _r$1, re, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; re = $f.re; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doExecute($ifaceNil, sliceType$5.nil, s, 0, re.prog.NumCap, sliceType$3.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = re.pad(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindStringSubmatchIndex }; } $f._r = _r; $f._r$1 = _r$1; $f.re = re; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindStringSubmatchIndex = function(s) { return this.$val.FindStringSubmatchIndex(s); };
	Regexp.ptr.prototype.FindReaderSubmatchIndex = function(r) {
		var _r, _r$1, r, re, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; r = $f.r; re = $f.re; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		_r = re.doExecute(r, sliceType$5.nil, "", 0, re.prog.NumCap, sliceType$3.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = re.pad(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindReaderSubmatchIndex }; } $f._r = _r; $f._r$1 = _r$1; $f.r = r; $f.re = re; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindReaderSubmatchIndex = function(r) { return this.$val.FindReaderSubmatchIndex(r); };
	Regexp.ptr.prototype.FindAll = function(b, n) {
		var b, n, re, result, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; n = $f.n; re = $f.re; result = $f.result; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = [b];
		result = [result];
		re = this;
		if (n < 0) {
			n = b[0].$length + 1 >> 0;
		}
		result[0] = sliceType$12.nil;
		$r = re.allMatches("", b[0], n, (function(b, result) { return function(match) {
			var match;
			if (result[0] === sliceType$12.nil) {
				result[0] = $makeSlice(sliceType$12, 0, 10);
			}
			result[0] = $append(result[0], $subslice(b[0], (0 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 0]), (1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1])));
		}; })(b, result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAll }; } $f.b = b; $f.n = n; $f.re = re; $f.result = result; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAll = function(b, n) { return this.$val.FindAll(b, n); };
	Regexp.ptr.prototype.FindAllIndex = function(b, n) {
		var b, n, re, result, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; n = $f.n; re = $f.re; result = $f.result; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		re = this;
		if (n < 0) {
			n = b.$length + 1 >> 0;
		}
		result[0] = sliceType$13.nil;
		$r = re.allMatches("", b, n, (function(result) { return function(match) {
			var match;
			if (result[0] === sliceType$13.nil) {
				result[0] = $makeSlice(sliceType$13, 0, 10);
			}
			result[0] = $append(result[0], $subslice(match, 0, 2));
		}; })(result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllIndex }; } $f.b = b; $f.n = n; $f.re = re; $f.result = result; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllIndex = function(b, n) { return this.$val.FindAllIndex(b, n); };
	Regexp.ptr.prototype.FindAllString = function(s, n) {
		var n, re, result, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; n = $f.n; re = $f.re; result = $f.result; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		s = [s];
		re = this;
		if (n < 0) {
			n = s[0].length + 1 >> 0;
		}
		result[0] = sliceType$9.nil;
		$r = re.allMatches(s[0], sliceType$5.nil, n, (function(result, s) { return function(match) {
			var match;
			if (result[0] === sliceType$9.nil) {
				result[0] = $makeSlice(sliceType$9, 0, 10);
			}
			result[0] = $append(result[0], $substring(s[0], (0 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 0]), (1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1])));
		}; })(result, s)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllString }; } $f.n = n; $f.re = re; $f.result = result; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllString = function(s, n) { return this.$val.FindAllString(s, n); };
	Regexp.ptr.prototype.FindAllStringIndex = function(s, n) {
		var n, re, result, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; n = $f.n; re = $f.re; result = $f.result; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		re = this;
		if (n < 0) {
			n = s.length + 1 >> 0;
		}
		result[0] = sliceType$13.nil;
		$r = re.allMatches(s, sliceType$5.nil, n, (function(result) { return function(match) {
			var match;
			if (result[0] === sliceType$13.nil) {
				result[0] = $makeSlice(sliceType$13, 0, 10);
			}
			result[0] = $append(result[0], $subslice(match, 0, 2));
		}; })(result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllStringIndex }; } $f.n = n; $f.re = re; $f.result = result; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllStringIndex = function(s, n) { return this.$val.FindAllStringIndex(s, n); };
	Regexp.ptr.prototype.FindAllSubmatch = function(b, n) {
		var b, n, re, result, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; n = $f.n; re = $f.re; result = $f.result; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = [b];
		result = [result];
		re = this;
		if (n < 0) {
			n = b[0].$length + 1 >> 0;
		}
		result[0] = sliceType$14.nil;
		$r = re.allMatches("", b[0], n, (function(b, result) { return function(match) {
			var _i, _q, _ref, j, match, slice, x, x$1, x$2;
			if (result[0] === sliceType$14.nil) {
				result[0] = $makeSlice(sliceType$14, 0, 10);
			}
			slice = $makeSlice(sliceType$12, (_q = match.$length / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")));
			_ref = slice;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				j = _i;
				if ((x = $imul(2, j), ((x < 0 || x >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x])) >= 0) {
					((j < 0 || j >= slice.$length) ? ($throwRuntimeError("index out of range"), undefined) : slice.$array[slice.$offset + j] = $subslice(b[0], (x$1 = $imul(2, j), ((x$1 < 0 || x$1 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$1])), (x$2 = ($imul(2, j)) + 1 >> 0, ((x$2 < 0 || x$2 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$2]))));
				}
				_i++;
			}
			result[0] = $append(result[0], slice);
		}; })(b, result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllSubmatch }; } $f.b = b; $f.n = n; $f.re = re; $f.result = result; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllSubmatch = function(b, n) { return this.$val.FindAllSubmatch(b, n); };
	Regexp.ptr.prototype.FindAllSubmatchIndex = function(b, n) {
		var b, n, re, result, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; b = $f.b; n = $f.n; re = $f.re; result = $f.result; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		re = this;
		if (n < 0) {
			n = b.$length + 1 >> 0;
		}
		result[0] = sliceType$13.nil;
		$r = re.allMatches("", b, n, (function(result) { return function(match) {
			var match;
			if (result[0] === sliceType$13.nil) {
				result[0] = $makeSlice(sliceType$13, 0, 10);
			}
			result[0] = $append(result[0], match);
		}; })(result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllSubmatchIndex }; } $f.b = b; $f.n = n; $f.re = re; $f.result = result; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllSubmatchIndex = function(b, n) { return this.$val.FindAllSubmatchIndex(b, n); };
	Regexp.ptr.prototype.FindAllStringSubmatch = function(s, n) {
		var n, re, result, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; n = $f.n; re = $f.re; result = $f.result; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		s = [s];
		re = this;
		if (n < 0) {
			n = s[0].length + 1 >> 0;
		}
		result[0] = sliceType$15.nil;
		$r = re.allMatches(s[0], sliceType$5.nil, n, (function(result, s) { return function(match) {
			var _i, _q, _ref, j, match, slice, x, x$1, x$2;
			if (result[0] === sliceType$15.nil) {
				result[0] = $makeSlice(sliceType$15, 0, 10);
			}
			slice = $makeSlice(sliceType$9, (_q = match.$length / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")));
			_ref = slice;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				j = _i;
				if ((x = $imul(2, j), ((x < 0 || x >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x])) >= 0) {
					((j < 0 || j >= slice.$length) ? ($throwRuntimeError("index out of range"), undefined) : slice.$array[slice.$offset + j] = $substring(s[0], (x$1 = $imul(2, j), ((x$1 < 0 || x$1 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$1])), (x$2 = ($imul(2, j)) + 1 >> 0, ((x$2 < 0 || x$2 >= match.$length) ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + x$2]))));
				}
				_i++;
			}
			result[0] = $append(result[0], slice);
		}; })(result, s)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllStringSubmatch }; } $f.n = n; $f.re = re; $f.result = result; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllStringSubmatch = function(s, n) { return this.$val.FindAllStringSubmatch(s, n); };
	Regexp.ptr.prototype.FindAllStringSubmatchIndex = function(s, n) {
		var n, re, result, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; n = $f.n; re = $f.re; result = $f.result; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		result = [result];
		re = this;
		if (n < 0) {
			n = s.length + 1 >> 0;
		}
		result[0] = sliceType$13.nil;
		$r = re.allMatches(s, sliceType$5.nil, n, (function(result) { return function(match) {
			var match;
			if (result[0] === sliceType$13.nil) {
				result[0] = $makeSlice(sliceType$13, 0, 10);
			}
			result[0] = $append(result[0], match);
		}; })(result)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return result[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.FindAllStringSubmatchIndex }; } $f.n = n; $f.re = re; $f.result = result; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.FindAllStringSubmatchIndex = function(s, n) { return this.$val.FindAllStringSubmatchIndex(s, n); };
	Regexp.ptr.prototype.Split = function(s, n) {
		var _i, _r, _ref, beg, end, match, matches, n, re, s, strings$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; beg = $f.beg; end = $f.end; match = $f.match; matches = $f.matches; n = $f.n; re = $f.re; s = $f.s; strings$1 = $f.strings$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		re = this;
		if (n === 0) {
			$s = -1; return sliceType$9.nil;
		}
		if (re.expr.length > 0 && (s.length === 0)) {
			$s = -1; return new sliceType$9([""]);
		}
		_r = re.FindAllStringIndex(s, n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		matches = _r;
		strings$1 = $makeSlice(sliceType$9, 0, matches.$length);
		beg = 0;
		end = 0;
		_ref = matches;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			match = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (n > 0 && strings$1.$length >= (n - 1 >> 0)) {
				break;
			}
			end = (0 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 0]);
			if (!(((1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1]) === 0))) {
				strings$1 = $append(strings$1, $substring(s, beg, end));
			}
			beg = (1 >= match.$length ? ($throwRuntimeError("index out of range"), undefined) : match.$array[match.$offset + 1]);
			_i++;
		}
		if (!((end === s.length))) {
			strings$1 = $append(strings$1, $substring(s, beg));
		}
		$s = -1; return strings$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Regexp.ptr.prototype.Split }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.beg = beg; $f.end = end; $f.match = match; $f.matches = matches; $f.n = n; $f.re = re; $f.s = s; $f.strings$1 = strings$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Regexp.prototype.Split = function(s, n) { return this.$val.Split(s, n); };
	ptrType.methods = [{prop: "reset", name: "reset", pkg: "regexp", typ: $funcType([ptrType$12, $Int, $Int], [], false)}, {prop: "shouldVisit", name: "shouldVisit", pkg: "regexp", typ: $funcType([$Uint32, $Int], [$Bool], false)}, {prop: "push", name: "push", pkg: "regexp", typ: $funcType([ptrType$11, $Uint32, $Int, $Bool], [], false)}];
	ptrType$13.methods = [{prop: "init", name: "init", pkg: "regexp", typ: $funcType([$Int], [], false)}, {prop: "alloc", name: "alloc", pkg: "regexp", typ: $funcType([ptrType$2], [ptrType$1], false)}, {prop: "match", name: "match", pkg: "regexp", typ: $funcType([input, $Int], [$Bool], false)}, {prop: "clear", name: "clear", pkg: "regexp", typ: $funcType([ptrType$14], [], false)}, {prop: "step", name: "step", pkg: "regexp", typ: $funcType([ptrType$14, ptrType$14, $Int, $Int, $Int32, ptrType$3], [], false)}, {prop: "add", name: "add", pkg: "regexp", typ: $funcType([ptrType$14, $Uint32, $Int, sliceType$3, ptrType$3, ptrType$1], [ptrType$1], false)}];
	ptrType$15.methods = [{prop: "newBytes", name: "newBytes", pkg: "regexp", typ: $funcType([sliceType$5], [input], false)}, {prop: "newString", name: "newString", pkg: "regexp", typ: $funcType([$String], [input], false)}, {prop: "newReader", name: "newReader", pkg: "regexp", typ: $funcType([io.RuneReader], [input], false)}, {prop: "clear", name: "clear", pkg: "regexp", typ: $funcType([], [], false)}, {prop: "init", name: "init", pkg: "regexp", typ: $funcType([io.RuneReader, sliceType$5, $String], [input, $Int], false)}];
	lazyFlag.methods = [{prop: "match", name: "match", pkg: "regexp", typ: $funcType([syntax.EmptyOp], [$Bool], false)}];
	ptrType$8.methods = [{prop: "empty", name: "empty", pkg: "regexp", typ: $funcType([], [$Bool], false)}, {prop: "next", name: "next", pkg: "regexp", typ: $funcType([], [$Uint32], false)}, {prop: "clear", name: "clear", pkg: "regexp", typ: $funcType([], [], false)}, {prop: "contains", name: "contains", pkg: "regexp", typ: $funcType([$Uint32], [$Bool], false)}, {prop: "insert", name: "insert", pkg: "regexp", typ: $funcType([$Uint32], [], false)}, {prop: "insertNew", name: "insertNew", pkg: "regexp", typ: $funcType([$Uint32], [], false)}];
	runeSlice.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Less", name: "Less", pkg: "", typ: $funcType([$Int, $Int], [$Bool], false)}, {prop: "Swap", name: "Swap", pkg: "", typ: $funcType([$Int, $Int], [], false)}];
	ptrType$11.methods = [{prop: "tryBacktrack", name: "tryBacktrack", pkg: "regexp", typ: $funcType([ptrType, input, $Uint32, $Int], [$Bool], false)}, {prop: "backtrack", name: "backtrack", pkg: "regexp", typ: $funcType([sliceType$5, $String, $Int, $Int, sliceType$3], [sliceType$3], false)}, {prop: "doOnePass", name: "doOnePass", pkg: "regexp", typ: $funcType([io.RuneReader, sliceType$5, $String, $Int, $Int, sliceType$3], [sliceType$3], false)}, {prop: "doMatch", name: "doMatch", pkg: "regexp", typ: $funcType([io.RuneReader, sliceType$5, $String], [$Bool], false)}, {prop: "doExecute", name: "doExecute", pkg: "regexp", typ: $funcType([io.RuneReader, sliceType$5, $String, $Int, $Int, sliceType$3], [sliceType$3], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Copy", name: "Copy", pkg: "", typ: $funcType([], [ptrType$11], false)}, {prop: "Longest", name: "Longest", pkg: "", typ: $funcType([], [], false)}, {prop: "get", name: "get", pkg: "regexp", typ: $funcType([], [ptrType$13], false)}, {prop: "put", name: "put", pkg: "regexp", typ: $funcType([ptrType$13], [], false)}, {prop: "NumSubexp", name: "NumSubexp", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "SubexpNames", name: "SubexpNames", pkg: "", typ: $funcType([], [sliceType$9], false)}, {prop: "LiteralPrefix", name: "LiteralPrefix", pkg: "", typ: $funcType([], [$String, $Bool], false)}, {prop: "MatchReader", name: "MatchReader", pkg: "", typ: $funcType([io.RuneReader], [$Bool], false)}, {prop: "MatchString", name: "MatchString", pkg: "", typ: $funcType([$String], [$Bool], false)}, {prop: "Match", name: "Match", pkg: "", typ: $funcType([sliceType$5], [$Bool], false)}, {prop: "ReplaceAllString", name: "ReplaceAllString", pkg: "", typ: $funcType([$String, $String], [$String], false)}, {prop: "ReplaceAllLiteralString", name: "ReplaceAllLiteralString", pkg: "", typ: $funcType([$String, $String], [$String], false)}, {prop: "ReplaceAllStringFunc", name: "ReplaceAllStringFunc", pkg: "", typ: $funcType([$String, funcType], [$String], false)}, {prop: "replaceAll", name: "replaceAll", pkg: "regexp", typ: $funcType([sliceType$5, $String, $Int, funcType$1], [sliceType$5], false)}, {prop: "ReplaceAll", name: "ReplaceAll", pkg: "", typ: $funcType([sliceType$5, sliceType$5], [sliceType$5], false)}, {prop: "ReplaceAllLiteral", name: "ReplaceAllLiteral", pkg: "", typ: $funcType([sliceType$5, sliceType$5], [sliceType$5], false)}, {prop: "ReplaceAllFunc", name: "ReplaceAllFunc", pkg: "", typ: $funcType([sliceType$5, funcType$2], [sliceType$5], false)}, {prop: "pad", name: "pad", pkg: "regexp", typ: $funcType([sliceType$3], [sliceType$3], false)}, {prop: "allMatches", name: "allMatches", pkg: "regexp", typ: $funcType([$String, sliceType$5, $Int, funcType$3], [], false)}, {prop: "Find", name: "Find", pkg: "", typ: $funcType([sliceType$5], [sliceType$5], false)}, {prop: "FindIndex", name: "FindIndex", pkg: "", typ: $funcType([sliceType$5], [sliceType$3], false)}, {prop: "FindString", name: "FindString", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "FindStringIndex", name: "FindStringIndex", pkg: "", typ: $funcType([$String], [sliceType$3], false)}, {prop: "FindReaderIndex", name: "FindReaderIndex", pkg: "", typ: $funcType([io.RuneReader], [sliceType$3], false)}, {prop: "FindSubmatch", name: "FindSubmatch", pkg: "", typ: $funcType([sliceType$5], [sliceType$12], false)}, {prop: "Expand", name: "Expand", pkg: "", typ: $funcType([sliceType$5, sliceType$5, sliceType$5, sliceType$3], [sliceType$5], false)}, {prop: "ExpandString", name: "ExpandString", pkg: "", typ: $funcType([sliceType$5, $String, $String, sliceType$3], [sliceType$5], false)}, {prop: "expand", name: "expand", pkg: "regexp", typ: $funcType([sliceType$5, $String, sliceType$5, $String, sliceType$3], [sliceType$5], false)}, {prop: "FindSubmatchIndex", name: "FindSubmatchIndex", pkg: "", typ: $funcType([sliceType$5], [sliceType$3], false)}, {prop: "FindStringSubmatch", name: "FindStringSubmatch", pkg: "", typ: $funcType([$String], [sliceType$9], false)}, {prop: "FindStringSubmatchIndex", name: "FindStringSubmatchIndex", pkg: "", typ: $funcType([$String], [sliceType$3], false)}, {prop: "FindReaderSubmatchIndex", name: "FindReaderSubmatchIndex", pkg: "", typ: $funcType([io.RuneReader], [sliceType$3], false)}, {prop: "FindAll", name: "FindAll", pkg: "", typ: $funcType([sliceType$5, $Int], [sliceType$12], false)}, {prop: "FindAllIndex", name: "FindAllIndex", pkg: "", typ: $funcType([sliceType$5, $Int], [sliceType$13], false)}, {prop: "FindAllString", name: "FindAllString", pkg: "", typ: $funcType([$String, $Int], [sliceType$9], false)}, {prop: "FindAllStringIndex", name: "FindAllStringIndex", pkg: "", typ: $funcType([$String, $Int], [sliceType$13], false)}, {prop: "FindAllSubmatch", name: "FindAllSubmatch", pkg: "", typ: $funcType([sliceType$5, $Int], [sliceType$14], false)}, {prop: "FindAllSubmatchIndex", name: "FindAllSubmatchIndex", pkg: "", typ: $funcType([sliceType$5, $Int], [sliceType$13], false)}, {prop: "FindAllStringSubmatch", name: "FindAllStringSubmatch", pkg: "", typ: $funcType([$String, $Int], [sliceType$15], false)}, {prop: "FindAllStringSubmatchIndex", name: "FindAllStringSubmatchIndex", pkg: "", typ: $funcType([$String, $Int], [sliceType$13], false)}, {prop: "Split", name: "Split", pkg: "", typ: $funcType([$String, $Int], [sliceType$9], false)}];
	ptrType$16.methods = [{prop: "step", name: "step", pkg: "regexp", typ: $funcType([$Int], [$Int32, $Int], false)}, {prop: "canCheckPrefix", name: "canCheckPrefix", pkg: "regexp", typ: $funcType([], [$Bool], false)}, {prop: "hasPrefix", name: "hasPrefix", pkg: "regexp", typ: $funcType([ptrType$11], [$Bool], false)}, {prop: "index", name: "index", pkg: "regexp", typ: $funcType([ptrType$11, $Int], [$Int], false)}, {prop: "context", name: "context", pkg: "regexp", typ: $funcType([$Int], [lazyFlag], false)}];
	ptrType$17.methods = [{prop: "step", name: "step", pkg: "regexp", typ: $funcType([$Int], [$Int32, $Int], false)}, {prop: "canCheckPrefix", name: "canCheckPrefix", pkg: "regexp", typ: $funcType([], [$Bool], false)}, {prop: "hasPrefix", name: "hasPrefix", pkg: "regexp", typ: $funcType([ptrType$11], [$Bool], false)}, {prop: "index", name: "index", pkg: "regexp", typ: $funcType([ptrType$11, $Int], [$Int], false)}, {prop: "context", name: "context", pkg: "regexp", typ: $funcType([$Int], [lazyFlag], false)}];
	ptrType$18.methods = [{prop: "step", name: "step", pkg: "regexp", typ: $funcType([$Int], [$Int32, $Int], false)}, {prop: "canCheckPrefix", name: "canCheckPrefix", pkg: "regexp", typ: $funcType([], [$Bool], false)}, {prop: "hasPrefix", name: "hasPrefix", pkg: "regexp", typ: $funcType([ptrType$11], [$Bool], false)}, {prop: "index", name: "index", pkg: "regexp", typ: $funcType([ptrType$11, $Int], [$Int], false)}, {prop: "context", name: "context", pkg: "regexp", typ: $funcType([$Int], [lazyFlag], false)}];
	job.init("regexp", [{prop: "pc", name: "pc", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "arg", name: "arg", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "pos", name: "pos", embedded: false, exported: false, typ: $Int, tag: ""}]);
	bitState.init("regexp", [{prop: "end", name: "end", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "cap", name: "cap", embedded: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "matchcap", name: "matchcap", embedded: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "jobs", name: "jobs", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "visited", name: "visited", embedded: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "inputs", name: "inputs", embedded: false, exported: false, typ: inputs, tag: ""}]);
	queue.init("regexp", [{prop: "sparse", name: "sparse", embedded: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "dense", name: "dense", embedded: false, exported: false, typ: sliceType$10, tag: ""}]);
	entry.init("regexp", [{prop: "pc", name: "pc", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "t", name: "t", embedded: false, exported: false, typ: ptrType$1, tag: ""}]);
	thread.init("regexp", [{prop: "inst", name: "inst", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "cap", name: "cap", embedded: false, exported: false, typ: sliceType$3, tag: ""}]);
	machine.init("regexp", [{prop: "re", name: "re", embedded: false, exported: false, typ: ptrType$11, tag: ""}, {prop: "p", name: "p", embedded: false, exported: false, typ: ptrType$12, tag: ""}, {prop: "q0", name: "q0", embedded: false, exported: false, typ: queue, tag: ""}, {prop: "q1", name: "q1", embedded: false, exported: false, typ: queue, tag: ""}, {prop: "pool", name: "pool", embedded: false, exported: false, typ: sliceType$11, tag: ""}, {prop: "matched", name: "matched", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "matchcap", name: "matchcap", embedded: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "inputs", name: "inputs", embedded: false, exported: false, typ: inputs, tag: ""}]);
	inputs.init("regexp", [{prop: "bytes", name: "bytes", embedded: false, exported: false, typ: inputBytes, tag: ""}, {prop: "string", name: "string", embedded: false, exported: false, typ: inputString, tag: ""}, {prop: "reader", name: "reader", embedded: false, exported: false, typ: inputReader, tag: ""}]);
	onePassMachine.init("regexp", [{prop: "inputs", name: "inputs", embedded: false, exported: false, typ: inputs, tag: ""}, {prop: "matchcap", name: "matchcap", embedded: false, exported: false, typ: sliceType$3, tag: ""}]);
	onePassProg.init("", [{prop: "Inst", name: "Inst", embedded: false, exported: true, typ: sliceType$6, tag: ""}, {prop: "Start", name: "Start", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "NumCap", name: "NumCap", embedded: false, exported: true, typ: $Int, tag: ""}]);
	onePassInst.init("", [{prop: "Inst", name: "Inst", embedded: true, exported: true, typ: syntax.Inst, tag: ""}, {prop: "Next", name: "Next", embedded: false, exported: true, typ: sliceType$2, tag: ""}]);
	queueOnePass.init("regexp", [{prop: "sparse", name: "sparse", embedded: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "dense", name: "dense", embedded: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "size", name: "size", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "nextIndex", name: "nextIndex", embedded: false, exported: false, typ: $Uint32, tag: ""}]);
	runeSlice.init($Int32);
	Regexp.init("regexp", [{prop: "expr", name: "expr", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "prog", name: "prog", embedded: false, exported: false, typ: ptrType$12, tag: ""}, {prop: "onepass", name: "onepass", embedded: false, exported: false, typ: ptrType$6, tag: ""}, {prop: "numSubexp", name: "numSubexp", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "maxBitStateLen", name: "maxBitStateLen", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "subexpNames", name: "subexpNames", embedded: false, exported: false, typ: sliceType$9, tag: ""}, {prop: "prefix", name: "prefix", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "prefixBytes", name: "prefixBytes", embedded: false, exported: false, typ: sliceType$5, tag: ""}, {prop: "prefixRune", name: "prefixRune", embedded: false, exported: false, typ: $Int32, tag: ""}, {prop: "prefixEnd", name: "prefixEnd", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "mpool", name: "mpool", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "matchcap", name: "matchcap", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "prefixComplete", name: "prefixComplete", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "cond", name: "cond", embedded: false, exported: false, typ: syntax.EmptyOp, tag: ""}, {prop: "longest", name: "longest", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	input.init([{prop: "canCheckPrefix", name: "canCheckPrefix", pkg: "regexp", typ: $funcType([], [$Bool], false)}, {prop: "context", name: "context", pkg: "regexp", typ: $funcType([$Int], [lazyFlag], false)}, {prop: "hasPrefix", name: "hasPrefix", pkg: "regexp", typ: $funcType([ptrType$11], [$Bool], false)}, {prop: "index", name: "index", pkg: "regexp", typ: $funcType([ptrType$11, $Int], [$Int], false)}, {prop: "step", name: "step", pkg: "regexp", typ: $funcType([$Int], [$Int32, $Int], false)}]);
	inputString.init("regexp", [{prop: "str", name: "str", embedded: false, exported: false, typ: $String, tag: ""}]);
	inputBytes.init("regexp", [{prop: "str", name: "str", embedded: false, exported: false, typ: sliceType$5, tag: ""}]);
	inputReader.init("regexp", [{prop: "r", name: "r", embedded: false, exported: false, typ: io.RuneReader, tag: ""}, {prop: "atEOT", name: "atEOT", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "pos", name: "pos", embedded: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = nosync.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = syntax.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sort.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		bitStatePool = new nosync.Pool.ptr(sliceType.nil, $throwNilPointerError);
		onePassPool = new nosync.Pool.ptr(sliceType.nil, $throwNilPointerError);
		arrayNoInts = arrayType.zero();
		matchPool = arrayType$1.zero();
		specialBytes = arrayType$2.zero();
		noRune = new sliceType$1([]);
		noNext = new sliceType$2([4294967295]);
		anyRuneNotNL = new sliceType$1([0, 9, 11, 1114111]);
		anyRune = new sliceType$1([0, 1114111]);
		matchSize = $toNativeArray($kindInt, [128, 512, 2048, 16384, 0]);
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl"] = (function() {
	var $pkg = {}, $init, errors, fmt, affine, driver, graphics, jsutil, thread, web, reflect, regexp, strings, sync, js, context, textureNative, framebufferNative, shader, buffer, uniformLocation, programID, program, contextImpl, Driver, framebuffer, Image, locationCache, arrayBufferLayoutPart, arrayBufferLayout, programKey, openGLState, shaderType, bufferType, dataType, sliceType, ptrType, ptrType$1, ptrType$2, ptrType$3, ptrType$4, sliceType$1, structType, sliceType$2, sliceType$3, sliceType$4, ptrType$9, ptrType$10, sliceType$5, sliceType$6, sliceType$7, sliceType$8, sliceType$9, ptrType$11, ptrType$12, ptrType$13, mapType, mapType$1, ptrType$14, ptrType$15, mapType$2, contextPrototype, vertexShader, fragmentShader, arrayBuffer, elementArrayBuffer, dynamicDraw, short$1, float$1, zero, one, srcAlpha, dstAlpha, oneMinusSrcAlpha, oneMinusDstAlpha, blend, clampToEdge, compileStatus, colorAttachment0, framebuffer_, framebufferBinding, framebufferComplete, highFloat, linkStatus, maxTextureSize, nearest, noError, rgba, texture2d, textureMagFilter, textureMinFilter, textureWrapS, textureWrapT, triangles, unpackAlignment, unsignedByte, unsignedShort, theDriver, theDriver$24ptr, theArrayBufferLayout, zeroBuffer, zeroProgram, glslReservedKeywords, glslIdentifier, _r, convertOperation, getProgramID, Get, newFramebufferFromTexture, newScreenFramebuffer, newLocationCache, init, areSameFloat32Array, checkGLSL, vertexShaderStr, fragmentShaderStr;
	errors = $packages["errors"];
	fmt = $packages["fmt"];
	affine = $packages["github.com/hajimehoshi/ebiten/internal/affine"];
	driver = $packages["github.com/hajimehoshi/ebiten/internal/driver"];
	graphics = $packages["github.com/hajimehoshi/ebiten/internal/graphics"];
	jsutil = $packages["github.com/hajimehoshi/ebiten/internal/jsutil"];
	thread = $packages["github.com/hajimehoshi/ebiten/internal/thread"];
	web = $packages["github.com/hajimehoshi/ebiten/internal/web"];
	reflect = $packages["reflect"];
	regexp = $packages["regexp"];
	strings = $packages["strings"];
	sync = $packages["sync"];
	js = $packages["syscall/js"];
	context = $pkg.context = $newType(0, $kindStruct, "opengl.context", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(locationCache_, screenFramebuffer_, lastFramebuffer_, lastTexture_, lastViewportWidth_, lastViewportHeight_, lastCompositeMode_, maxTextureSize_, maxTextureSizeOnce_, highp_, highpOnce_, t_, contextImpl_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.locationCache = ptrType$3.nil;
			this.screenFramebuffer = new framebufferNative.ptr(null, false);
			this.lastFramebuffer = new framebufferNative.ptr(null, false);
			this.lastTexture = new textureNative.ptr(null, false);
			this.lastViewportWidth = 0;
			this.lastViewportHeight = 0;
			this.lastCompositeMode = 0;
			this.maxTextureSize = 0;
			this.maxTextureSizeOnce = new sync.Once.ptr(new sync.Mutex.ptr(0, 0), 0);
			this.highp = false;
			this.highpOnce = new sync.Once.ptr(new sync.Mutex.ptr(0, 0), 0);
			this.t = ptrType$4.nil;
			this.contextImpl = new contextImpl.ptr(new js.Value.ptr(null, false), 0);
			return;
		}
		this.locationCache = locationCache_;
		this.screenFramebuffer = screenFramebuffer_;
		this.lastFramebuffer = lastFramebuffer_;
		this.lastTexture = lastTexture_;
		this.lastViewportWidth = lastViewportWidth_;
		this.lastViewportHeight = lastViewportHeight_;
		this.lastCompositeMode = lastCompositeMode_;
		this.maxTextureSize = maxTextureSize_;
		this.maxTextureSizeOnce = maxTextureSizeOnce_;
		this.highp = highp_;
		this.highpOnce = highpOnce_;
		this.t = t_;
		this.contextImpl = contextImpl_;
	});
	textureNative = $pkg.textureNative = $newType(0, $kindStruct, "opengl.textureNative", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(v_, inited_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.v = null;
			this.inited = false;
			return;
		}
		this.v = v_;
		this.inited = inited_;
	});
	framebufferNative = $pkg.framebufferNative = $newType(0, $kindStruct, "opengl.framebufferNative", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(v_, inited_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.v = null;
			this.inited = false;
			return;
		}
		this.v = v_;
		this.inited = inited_;
	});
	shader = $pkg.shader = $newType(0, $kindStruct, "opengl.shader", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(v_, inited_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.v = null;
			this.inited = false;
			return;
		}
		this.v = v_;
		this.inited = inited_;
	});
	buffer = $pkg.buffer = $newType(0, $kindStruct, "opengl.buffer", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(v_, inited_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.v = null;
			this.inited = false;
			return;
		}
		this.v = v_;
		this.inited = inited_;
	});
	uniformLocation = $pkg.uniformLocation = $newType(0, $kindStruct, "opengl.uniformLocation", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(v_, inited_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.v = null;
			this.inited = false;
			return;
		}
		this.v = v_;
		this.inited = inited_;
	});
	programID = $pkg.programID = $newType(4, $kindInt, "opengl.programID", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, null);
	program = $pkg.program = $newType(0, $kindStruct, "opengl.program", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(value_, id_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.value = new js.Value.ptr(null, false);
			this.id = 0;
			return;
		}
		this.value = value_;
		this.id = id_;
	});
	contextImpl = $pkg.contextImpl = $newType(0, $kindStruct, "opengl.contextImpl", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(gl_, lastProgramID_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.gl = new js.Value.ptr(null, false);
			this.lastProgramID = 0;
			return;
		}
		this.gl = gl_;
		this.lastProgramID = lastProgramID_;
	});
	Driver = $pkg.Driver = $newType(0, $kindStruct, "opengl.Driver", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", true, function(state_, context_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.state = new openGLState.ptr(new buffer.ptr(null, false), new buffer.ptr(null, false), false, new program.ptr(new js.Value.ptr(null, false), 0), 0, 0, sliceType.nil, sliceType.nil, 0, 0, ptrType.nil, ptrType$1.nil, ptrType$2.nil, ptrType$2.nil);
			this.context = new context.ptr(ptrType$3.nil, new framebufferNative.ptr(null, false), new framebufferNative.ptr(null, false), new textureNative.ptr(null, false), 0, 0, 0, 0, new sync.Once.ptr(new sync.Mutex.ptr(0, 0), 0), false, new sync.Once.ptr(new sync.Mutex.ptr(0, 0), 0), ptrType$4.nil, new contextImpl.ptr(new js.Value.ptr(null, false), 0));
			return;
		}
		this.state = state_;
		this.context = context_;
	});
	framebuffer = $pkg.framebuffer = $newType(0, $kindStruct, "opengl.framebuffer", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(driver_, native$1_, width_, height_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.driver = ptrType$9.nil;
			this.native$1 = new framebufferNative.ptr(null, false);
			this.width = 0;
			this.height = 0;
			return;
		}
		this.driver = driver_;
		this.native$1 = native$1_;
		this.width = width_;
		this.height = height_;
	});
	Image = $pkg.Image = $newType(0, $kindStruct, "opengl.Image", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", true, function(driver_, textureNative_, framebuffer_, width_, height_, screen_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.driver = ptrType$9.nil;
			this.textureNative = new textureNative.ptr(null, false);
			this.framebuffer = ptrType$10.nil;
			this.width = 0;
			this.height = 0;
			this.screen = false;
			return;
		}
		this.driver = driver_;
		this.textureNative = textureNative_;
		this.framebuffer = framebuffer_;
		this.width = width_;
		this.height = height_;
		this.screen = screen_;
	});
	locationCache = $pkg.locationCache = $newType(0, $kindStruct, "opengl.locationCache", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(uniformLocationCache_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.uniformLocationCache = false;
			return;
		}
		this.uniformLocationCache = uniformLocationCache_;
	});
	arrayBufferLayoutPart = $pkg.arrayBufferLayoutPart = $newType(0, $kindStruct, "opengl.arrayBufferLayoutPart", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(name_, num_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.name = "";
			this.num = 0;
			return;
		}
		this.name = name_;
		this.num = num_;
	});
	arrayBufferLayout = $pkg.arrayBufferLayout = $newType(0, $kindStruct, "opengl.arrayBufferLayout", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(parts_, total_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.parts = sliceType$1.nil;
			this.total = 0;
			return;
		}
		this.parts = parts_;
		this.total = total_;
	});
	programKey = $pkg.programKey = $newType(0, $kindStruct, "opengl.programKey", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(useColorM_, filter_, address_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.useColorM = false;
			this.filter = 0;
			this.address = 0;
			return;
		}
		this.useColorM = useColorM_;
		this.filter = filter_;
		this.address = address_;
	});
	openGLState = $pkg.openGLState = $newType(0, $kindStruct, "opengl.openGLState", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, function(arrayBuffer_, elementArrayBuffer_, programs_, lastProgram_, lastViewportWidth_, lastViewportHeight_, lastColorMatrix_, lastColorMatrixTranslation_, lastSourceWidth_, lastSourceHeight_, lastFilter_, lastAddress_, source_, destination_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.arrayBuffer = new buffer.ptr(null, false);
			this.elementArrayBuffer = new buffer.ptr(null, false);
			this.programs = false;
			this.lastProgram = new program.ptr(new js.Value.ptr(null, false), 0);
			this.lastViewportWidth = 0;
			this.lastViewportHeight = 0;
			this.lastColorMatrix = sliceType.nil;
			this.lastColorMatrixTranslation = sliceType.nil;
			this.lastSourceWidth = 0;
			this.lastSourceHeight = 0;
			this.lastFilter = ptrType.nil;
			this.lastAddress = ptrType$1.nil;
			this.source = ptrType$2.nil;
			this.destination = ptrType$2.nil;
			return;
		}
		this.arrayBuffer = arrayBuffer_;
		this.elementArrayBuffer = elementArrayBuffer_;
		this.programs = programs_;
		this.lastProgram = lastProgram_;
		this.lastViewportWidth = lastViewportWidth_;
		this.lastViewportHeight = lastViewportHeight_;
		this.lastColorMatrix = lastColorMatrix_;
		this.lastColorMatrixTranslation = lastColorMatrixTranslation_;
		this.lastSourceWidth = lastSourceWidth_;
		this.lastSourceHeight = lastSourceHeight_;
		this.lastFilter = lastFilter_;
		this.lastAddress = lastAddress_;
		this.source = source_;
		this.destination = destination_;
	});
	shaderType = $pkg.shaderType = $newType(4, $kindInt, "opengl.shaderType", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, null);
	bufferType = $pkg.bufferType = $newType(4, $kindInt, "opengl.bufferType", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, null);
	dataType = $pkg.dataType = $newType(4, $kindInt, "opengl.dataType", true, "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", false, null);
	sliceType = $sliceType($Float32);
	ptrType = $ptrType(driver.Filter);
	ptrType$1 = $ptrType(driver.Address);
	ptrType$2 = $ptrType(Image);
	ptrType$3 = $ptrType(locationCache);
	ptrType$4 = $ptrType(thread.Thread);
	sliceType$1 = $sliceType(arrayBufferLayoutPart);
	structType = $structType("", []);
	sliceType$2 = $sliceType($Uint8);
	sliceType$3 = $sliceType($Uint16);
	sliceType$4 = $sliceType($emptyInterface);
	ptrType$9 = $ptrType(Driver);
	ptrType$10 = $ptrType(framebuffer);
	sliceType$5 = $sliceType($String);
	sliceType$6 = $sliceType($Bool);
	sliceType$7 = $sliceType(driver.Address);
	sliceType$8 = $sliceType(driver.Filter);
	sliceType$9 = $sliceType(shader);
	ptrType$11 = $ptrType(affine.ColorM);
	ptrType$12 = $ptrType(context);
	ptrType$13 = $ptrType($packages["github.com/gopherjs/gopherjs/js"].Object);
	mapType = $mapType($String, uniformLocation);
	mapType$1 = $mapType(programID, mapType);
	ptrType$14 = $ptrType(arrayBufferLayout);
	ptrType$15 = $ptrType(openGLState);
	mapType$2 = $mapType(programKey, program);
	convertOperation = function(op) {
		var _1, _r$1, op, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r$1 = $f._r$1; op = $f.op; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = op;
			/* */ if (_1 === (0)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ if (_1 === (4)) { $s = 6; continue; }
			/* */ if (_1 === (5)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (0)) { */ case 2:
				$s = -1; return zero;
			/* } else if (_1 === (1)) { */ case 3:
				$s = -1; return one;
			/* } else if (_1 === (2)) { */ case 4:
				$s = -1; return srcAlpha;
			/* } else if (_1 === (3)) { */ case 5:
				$s = -1; return dstAlpha;
			/* } else if (_1 === (4)) { */ case 6:
				$s = -1; return oneMinusSrcAlpha;
			/* } else if (_1 === (5)) { */ case 7:
				$s = -1; return oneMinusDstAlpha;
			/* } else { */ case 8:
				_r$1 = fmt.Sprintf("opengl: invalid operation %d at convertOperation", new sliceType$4([new driver.Operation(op)])); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$panic(new $String(_r$1));
			/* } */ case 9:
		case 1:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: convertOperation }; } $f._1 = _1; $f._r$1 = _r$1; $f.op = op; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.ptr.prototype.bindTexture = function(t) {
		var c, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; c = $f.c; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		if ($equal(c.lastTexture, t, textureNative)) {
			$s = -1; return;
		}
		$r = c.bindTextureImpl($clone(t, textureNative)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		textureNative.copy(c.lastTexture, t);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.bindTexture }; } $f.c = c; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.bindTexture = function(t) { return this.$val.bindTexture(t); };
	context.ptr.prototype.bindFramebuffer = function(f) {
		var c, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; c = $f.c; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		if ($equal(c.lastFramebuffer, f, framebufferNative)) {
			$s = -1; return;
		}
		$r = c.bindFramebufferImpl($clone(f, framebufferNative)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		framebufferNative.copy(c.lastFramebuffer, f);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.bindFramebuffer }; } $f.c = c; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.bindFramebuffer = function(f) { return this.$val.bindFramebuffer(f); };
	context.ptr.prototype.setViewport = function(f) {
		var c, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; c = $f.c; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.bindFramebuffer($clone(f.native$1, framebufferNative)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ if (!((c.lastViewportWidth === f.width)) || !((c.lastViewportHeight === f.height))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((c.lastViewportWidth === f.width)) || !((c.lastViewportHeight === f.height))) { */ case 2:
			$r = c.setViewportImpl(f.width, f.height); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			if ($equal(f.native$1, c.screenFramebuffer, framebufferNative)) {
				c.lastViewportWidth = 0;
				c.lastViewportHeight = 0;
			} else {
				c.lastViewportWidth = f.width;
				c.lastViewportHeight = f.height;
			}
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.setViewport }; } $f.c = c; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.setViewport = function(f) { return this.$val.setViewport(f); };
	context.ptr.prototype.getScreenFramebuffer = function() {
		var c;
		c = this;
		return c.screenFramebuffer;
	};
	context.prototype.getScreenFramebuffer = function() { return this.$val.getScreenFramebuffer(); };
	context.ptr.prototype.getMaxTextureSize = function() {
		var c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = [c];
		c[0] = this;
		$r = c[0].maxTextureSizeOnce.Do((function(c) { return function $b() {
			var _r$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r$1 = c[0].maxTextureSizeImpl(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			c[0].maxTextureSize = _r$1;
			$s = -1; return;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$1 = _r$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(c)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return c[0].maxTextureSize;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.getMaxTextureSize }; } $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.getMaxTextureSize = function() { return this.$val.getMaxTextureSize(); };
	context.ptr.prototype.hasHighPrecisionFloat = function() {
		var c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = [c];
		c[0] = this;
		$r = c[0].highpOnce.Do((function(c) { return function $b() {
			var _r$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r$1 = c[0].getShaderPrecisionFormatPrecision(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			c[0].highp = _r$1 >= 23;
			$s = -1; return;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$1 = _r$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(c)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return c[0].highp;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.hasHighPrecisionFloat }; } $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.hasHighPrecisionFloat = function() { return this.$val.hasHighPrecisionFloat(); };
	getProgramID = function(p) {
		var p;
		return p.id;
	};
	context.ptr.prototype.ensureGL = function() {
		var _r$1, _r$2, _r$3, _r$4, attr, c, canvas, gl, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; attr = $f.attr; c = $f.c; canvas = $f.canvas; gl = $f.gl; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		if (!($equal(c.contextImpl.gl, (new js.Value.ptr(null, false)), js.Value))) {
			$s = -1; return;
		}
		if ($equal($clone(js.Global(), js.Value).Get("WebGLRenderingContext"), js.Undefined(), js.Value)) {
			$panic(new $String("opengl: WebGL is not supported"));
		}
		_r$1 = $clone($clone(js.Global(), js.Value).Get("document"), js.Value).Call("querySelector", new sliceType$4([new $String("canvas")])); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		canvas = $clone(_r$1, js.Value);
		_r$2 = $clone($clone(js.Global(), js.Value).Get("Object"), js.Value).New(new sliceType$4([])); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		attr = $clone(_r$2, js.Value);
		$r = $clone(attr, js.Value).Set("alpha", new $Bool(true)); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(attr, js.Value).Set("premultipliedAlpha", new $Bool(true)); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$3 = $clone(canvas, js.Value).Call("getContext", new sliceType$4([new $String("webgl"), new attr.constructor.elem(attr)])); /* */ $s = 5; case 5: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		gl = $clone(_r$3, js.Value);
		/* */ if ($equal(gl, js.Null(), js.Value)) { $s = 6; continue; }
		/* */ $s = 7; continue;
		/* if ($equal(gl, js.Null(), js.Value)) { */ case 6:
			_r$4 = $clone(canvas, js.Value).Call("getContext", new sliceType$4([new $String("experimental-webgl"), new attr.constructor.elem(attr)])); /* */ $s = 8; case 8: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			js.Value.copy(gl, _r$4);
			if ($equal(gl, js.Null(), js.Value)) {
				$panic(new $String("opengl: getContext failed"));
			}
		/* } */ case 7:
		js.Value.copy(c.contextImpl.gl, gl);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.ensureGL }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.attr = attr; $f.c = c; $f.canvas = canvas; $f.gl = gl; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.ensureGL = function() { return this.$val.ensureGL(); };
	context.ptr.prototype.reset = function() {
		var _r$1, _r$2, _r$3, _r$4, _r$5, c, f, gl, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; c = $f.c; f = $f.f; gl = $f.gl; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		c.locationCache = newLocationCache();
		textureNative.copy(c.lastTexture, ($clone(js.Null(), textureNative)));
		framebufferNative.copy(c.lastFramebuffer, ($clone(js.Null(), framebufferNative)));
		c.lastViewportWidth = 0;
		c.lastViewportHeight = 0;
		c.lastCompositeMode = 13;
		js.Value.copy(c.contextImpl.gl, new js.Value.ptr(null, false));
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$1 = $clone(c.contextImpl.gl, js.Value).Call("isContextLost", new sliceType$4([])); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = $clone(_r$1, js.Value).Bool(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		/* */ if (_r$2) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (_r$2) { */ case 2:
			_r$3 = fmt.Errorf("opengl: the context is lost", new sliceType$4([])); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			$s = -1; return _r$3;
		/* } */ case 3:
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$4 = $clone(gl, js.Value).Call("enable", new sliceType$4([new blend.constructor.elem(blend)])); /* */ $s = 7; case 7: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_r$4;
		$r = c.blendFunc(0); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$5 = $clone(gl, js.Value).Call("getParameter", new sliceType$4([new framebufferBinding.constructor.elem(framebufferBinding)])); /* */ $s = 9; case 9: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		f = $clone(_r$5, js.Value);
		framebufferNative.copy(c.screenFramebuffer, ($clone(f, framebufferNative)));
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.reset }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f.c = c; $f.f = f; $f.gl = gl; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.reset = function() { return this.$val.reset(); };
	context.ptr.prototype.blendFunc = function(mode) {
		var _r$1, _r$2, _r$3, _r$4, _tmp, _tmp$1, _tuple, c, d, d2, gl, mode, s, s2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; c = $f.c; d = $f.d; d2 = $f.d2; gl = $f.gl; mode = $f.mode; s = $f.s; s2 = $f.s2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		if (c.lastCompositeMode === mode) {
			$s = -1; return;
		}
		c.lastCompositeMode = mode;
		_r$1 = new driver.CompositeMode(mode).Operations(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		s = _tuple[0];
		d = _tuple[1];
		_r$2 = convertOperation(s); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_tmp = _r$2;
		_r$3 = convertOperation(d); /* */ $s = 3; case 3: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_tmp$1 = _r$3;
		s2 = _tmp;
		d2 = _tmp$1;
		$r = c.ensureGL(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$4 = $clone(gl, js.Value).Call("blendFunc", new sliceType$4([new $Int(((s2 >> 0))), new $Int(((d2 >> 0)))])); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_r$4;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.blendFunc }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.c = c; $f.d = d; $f.d2 = d2; $f.gl = gl; $f.mode = mode; $f.s = s; $f.s2 = s2; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.blendFunc = function(mode) { return this.$val.blendFunc(mode); };
	context.ptr.prototype.newTexture = function(width, height) {
		var _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, c, gl, height, t, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; c = $f.c; gl = $f.gl; height = $f.height; t = $f.t; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("createTexture", new sliceType$4([])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		t = $clone(_r$1, js.Value);
		if ($equal(t, js.Null(), js.Value)) {
			$s = -1; return [($clone(js.Null(), textureNative)), errors.New("opengl: glGenTexture failed")];
		}
		_r$2 = $clone(gl, js.Value).Call("pixelStorei", new sliceType$4([new unpackAlignment.constructor.elem(unpackAlignment), new $Int(4)])); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		$r = c.bindTexture($clone(($clone(t, textureNative)), textureNative)); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$3 = $clone(gl, js.Value).Call("texParameteri", new sliceType$4([new texture2d.constructor.elem(texture2d), new textureMagFilter.constructor.elem(textureMagFilter), new nearest.constructor.elem(nearest)])); /* */ $s = 5; case 5: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$3;
		_r$4 = $clone(gl, js.Value).Call("texParameteri", new sliceType$4([new texture2d.constructor.elem(texture2d), new textureMinFilter.constructor.elem(textureMinFilter), new nearest.constructor.elem(nearest)])); /* */ $s = 6; case 6: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_r$4;
		_r$5 = $clone(gl, js.Value).Call("texParameteri", new sliceType$4([new texture2d.constructor.elem(texture2d), new textureWrapS.constructor.elem(textureWrapS), new clampToEdge.constructor.elem(clampToEdge)])); /* */ $s = 7; case 7: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_r$5;
		_r$6 = $clone(gl, js.Value).Call("texParameteri", new sliceType$4([new texture2d.constructor.elem(texture2d), new textureWrapT.constructor.elem(textureWrapT), new clampToEdge.constructor.elem(clampToEdge)])); /* */ $s = 8; case 8: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_r$6;
		_r$7 = $clone(gl, js.Value).Call("texImage2D", new sliceType$4([new texture2d.constructor.elem(texture2d), new $Int(0), new rgba.constructor.elem(rgba), new $Int(width), new $Int(height), new $Int(0), new rgba.constructor.elem(rgba), new unsignedByte.constructor.elem(unsignedByte), $ifaceNil])); /* */ $s = 9; case 9: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_r$7;
		$s = -1; return [($clone(t, textureNative)), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.newTexture }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f.c = c; $f.gl = gl; $f.height = height; $f.t = t; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.newTexture = function(width, height) { return this.$val.newTexture(width, height); };
	context.ptr.prototype.bindFramebufferImpl = function(f) {
		var _r$1, c, f, gl, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; c = $f.c; f = $f.f; gl = $f.gl; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("bindFramebuffer", new sliceType$4([new framebuffer_.constructor.elem(framebuffer_), (x = ($clone(f, js.Value)), new x.constructor.elem(x))])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.bindFramebufferImpl }; } $f._r$1 = _r$1; $f.c = c; $f.f = f; $f.gl = gl; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.bindFramebufferImpl = function(f) { return this.$val.bindFramebufferImpl(f); };
	context.ptr.prototype.framebufferPixels = function(f, width, height) {
		var _r$1, _r$2, _r$3, c, f, gl, height, p, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; c = $f.c; f = $f.f; gl = $f.gl; height = $f.height; p = $f.p; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		$r = c.bindFramebuffer($clone(f.native$1, framebufferNative)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$1 = $clone($clone(js.Global(), js.Value).Get("Uint8Array"), js.Value).New(new sliceType$4([new $Int(($imul(($imul(4, width)), height)))])); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		p = $clone(_r$1, js.Value);
		_r$2 = $clone(gl, js.Value).Call("readPixels", new sliceType$4([new $Int(0), new $Int(0), new $Int(width), new $Int(height), new rgba.constructor.elem(rgba), new unsignedByte.constructor.elem(unsignedByte), new p.constructor.elem(p)])); /* */ $s = 4; case 4: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		_r$3 = jsutil.Uint8ArrayToSlice($clone(p, js.Value)); /* */ $s = 5; case 5: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		$s = -1; return [_r$3, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.framebufferPixels }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.c = c; $f.f = f; $f.gl = gl; $f.height = height; $f.p = p; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.framebufferPixels = function(f, width, height) { return this.$val.framebufferPixels(f, width, height); };
	context.ptr.prototype.bindTextureImpl = function(t) {
		var _r$1, c, gl, t, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; c = $f.c; gl = $f.gl; t = $f.t; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("bindTexture", new sliceType$4([new texture2d.constructor.elem(texture2d), (x = ($clone(t, js.Value)), new x.constructor.elem(x))])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.bindTextureImpl }; } $f._r$1 = _r$1; $f.c = c; $f.gl = gl; $f.t = t; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.bindTextureImpl = function(t) { return this.$val.bindTextureImpl(t); };
	context.ptr.prototype.deleteTexture = function(t) {
		var _r$1, _r$2, _r$3, c, gl, t, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; c = $f.c; gl = $f.gl; t = $f.t; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("isTexture", new sliceType$4([(x = ($clone(t, js.Value)), new x.constructor.elem(x))])); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = $clone(_r$1, js.Value).Bool(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		/* */ if (!_r$2) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!_r$2) { */ case 2:
			$s = -1; return;
		/* } */ case 3:
		if ($equal(c.lastTexture, t, textureNative)) {
			textureNative.copy(c.lastTexture, ($clone(js.Null(), textureNative)));
		}
		_r$3 = $clone(gl, js.Value).Call("deleteTexture", new sliceType$4([(x$1 = ($clone(t, js.Value)), new x$1.constructor.elem(x$1))])); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$3;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.deleteTexture }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.c = c; $f.gl = gl; $f.t = t; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.deleteTexture = function(t) { return this.$val.deleteTexture(t); };
	context.ptr.prototype.isTexture = function(t) {
		var _r$1, _r$2, c, gl, t, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; c = $f.c; gl = $f.gl; t = $f.t; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("isTexture", new sliceType$4([(x = ($clone(t, js.Value)), new x.constructor.elem(x))])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = $clone(_r$1, js.Value).Bool(); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.isTexture }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f.c = c; $f.gl = gl; $f.t = t; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.isTexture = function(t) { return this.$val.isTexture(t); };
	context.ptr.prototype.texSubImage2D = function(t, pixels, x, y, width, height) {
		var _r$1, _tuple, c, free, gl, height, p, pixels, t, width, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _tuple = $f._tuple; c = $f.c; free = $f.free; gl = $f.gl; height = $f.height; p = $f.p; pixels = $f.pixels; t = $f.t; width = $f.width; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.bindTexture($clone(t, textureNative)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = c.ensureGL(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_tuple = jsutil.SliceToTypedArray(pixels);
		p = $clone(_tuple[0], js.Value);
		free = _tuple[1];
		_r$1 = $clone(gl, js.Value).Call("texSubImage2D", new sliceType$4([new texture2d.constructor.elem(texture2d), new $Int(0), new $Int(x), new $Int(y), new $Int(width), new $Int(height), new rgba.constructor.elem(rgba), new unsignedByte.constructor.elem(unsignedByte), new p.constructor.elem(p)])); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$r = free(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.texSubImage2D }; } $f._r$1 = _r$1; $f._tuple = _tuple; $f.c = c; $f.free = free; $f.gl = gl; $f.height = height; $f.p = p; $f.pixels = pixels; $f.t = t; $f.width = width; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.texSubImage2D = function(t, pixels, x, y, width, height) { return this.$val.texSubImage2D(t, pixels, x, y, width, height); };
	context.ptr.prototype.newFramebuffer = function(t) {
		var _r$1, _r$2, _r$3, _r$4, _r$5, c, f, gl, s, t, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; c = $f.c; f = $f.f; gl = $f.gl; s = $f.s; t = $f.t; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("createFramebuffer", new sliceType$4([])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		f = $clone(_r$1, js.Value);
		$r = c.bindFramebuffer($clone(($clone(f, framebufferNative)), framebufferNative)); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$2 = $clone(gl, js.Value).Call("framebufferTexture2D", new sliceType$4([new framebuffer_.constructor.elem(framebuffer_), new colorAttachment0.constructor.elem(colorAttachment0), new texture2d.constructor.elem(texture2d), (x = ($clone(t, js.Value)), new x.constructor.elem(x)), new $Int(0)])); /* */ $s = 4; case 4: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		_r$3 = $clone(gl, js.Value).Call("checkFramebufferStatus", new sliceType$4([new framebuffer_.constructor.elem(framebuffer_)])); /* */ $s = 5; case 5: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		s = $clone(_r$3, js.Value);
		/* */ if (!(($clone(s, js.Value).Int() === $clone(framebufferComplete, js.Value).Int()))) { $s = 6; continue; }
		/* */ $s = 7; continue;
		/* if (!(($clone(s, js.Value).Int() === $clone(framebufferComplete, js.Value).Int()))) { */ case 6:
			_r$4 = fmt.Sprintf("opengl: creating framebuffer failed: %d", new sliceType$4([new $Int($clone(s, js.Value).Int())])); /* */ $s = 8; case 8: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			_r$5 = errors.New(_r$4); /* */ $s = 9; case 9: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			$s = -1; return [($clone(js.Null(), framebufferNative)), _r$5];
		/* } */ case 7:
		$s = -1; return [($clone(f, framebufferNative)), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.newFramebuffer }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f.c = c; $f.f = f; $f.gl = gl; $f.s = s; $f.t = t; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.newFramebuffer = function(t) { return this.$val.newFramebuffer(t); };
	context.ptr.prototype.setViewportImpl = function(width, height) {
		var _r$1, c, gl, height, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; c = $f.c; gl = $f.gl; height = $f.height; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("viewport", new sliceType$4([new $Int(0), new $Int(0), new $Int(width), new $Int(height)])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.setViewportImpl }; } $f._r$1 = _r$1; $f.c = c; $f.gl = gl; $f.height = height; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.setViewportImpl = function(width, height) { return this.$val.setViewportImpl(width, height); };
	context.ptr.prototype.deleteFramebuffer = function(f) {
		var _r$1, _r$2, _r$3, c, f, gl, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; c = $f.c; f = $f.f; gl = $f.gl; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("isFramebuffer", new sliceType$4([(x = ($clone(f, js.Value)), new x.constructor.elem(x))])); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = $clone(_r$1, js.Value).Bool(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		/* */ if (!_r$2) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!_r$2) { */ case 2:
			$s = -1; return;
		/* } */ case 3:
		if ($equal(c.lastFramebuffer, f, framebufferNative)) {
			framebufferNative.copy(c.lastFramebuffer, ($clone(js.Null(), framebufferNative)));
			c.lastViewportWidth = 0;
			c.lastViewportHeight = 0;
		}
		_r$3 = $clone(gl, js.Value).Call("deleteFramebuffer", new sliceType$4([(x$1 = ($clone(f, js.Value)), new x$1.constructor.elem(x$1))])); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$3;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.deleteFramebuffer }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.c = c; $f.f = f; $f.gl = gl; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.deleteFramebuffer = function(f) { return this.$val.deleteFramebuffer(f); };
	context.ptr.prototype.newShader = function(shaderType$1, source) {
		var _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, c, gl, log, s, shaderType$1, source, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; c = $f.c; gl = $f.gl; log = $f.log; s = $f.s; shaderType$1 = $f.shaderType$1; source = $f.source; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("createShader", new sliceType$4([new $Int(((shaderType$1 >> 0)))])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		s = $clone(_r$1, js.Value);
		/* */ if ($equal(s, js.Null(), js.Value)) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if ($equal(s, js.Null(), js.Value)) { */ case 3:
			_r$2 = fmt.Errorf("opengl: glCreateShader failed: shader type: %d", new sliceType$4([new shaderType(shaderType$1)])); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			$s = -1; return [($clone(js.Null(), shader)), _r$2];
		/* } */ case 4:
		_r$3 = $clone(gl, js.Value).Call("shaderSource", new sliceType$4([(x = (s), new x.constructor.elem(x)), new $String(source)])); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$3;
		_r$4 = $clone(gl, js.Value).Call("compileShader", new sliceType$4([(x$1 = (s), new x$1.constructor.elem(x$1))])); /* */ $s = 7; case 7: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_r$4;
		_r$5 = $clone(gl, js.Value).Call("getShaderParameter", new sliceType$4([(x$2 = (s), new x$2.constructor.elem(x$2)), new compileStatus.constructor.elem(compileStatus)])); /* */ $s = 10; case 10: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_r$6 = $clone(_r$5, js.Value).Bool(); /* */ $s = 11; case 11: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		/* */ if (!_r$6) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if (!_r$6) { */ case 8:
			_r$7 = $clone(gl, js.Value).Call("getShaderInfoLog", new sliceType$4([(x$3 = (s), new x$3.constructor.elem(x$3))])); /* */ $s = 12; case 12: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			log = $clone(_r$7, js.Value);
			_r$8 = fmt.Errorf("opengl: shader compile failed: %s", new sliceType$4([new log.constructor.elem(log)])); /* */ $s = 13; case 13: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
			$s = -1; return [($clone(js.Null(), shader)), _r$8];
		/* } */ case 9:
		$s = -1; return [($clone(s, shader)), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.newShader }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f.c = c; $f.gl = gl; $f.log = log; $f.s = s; $f.shaderType$1 = shaderType$1; $f.source = source; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.newShader = function(shaderType$1, source) { return this.$val.newShader(shaderType$1, source); };
	context.ptr.prototype.deleteShader = function(s) {
		var _r$1, c, gl, s, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; c = $f.c; gl = $f.gl; s = $f.s; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("deleteShader", new sliceType$4([(x = ($clone(s, js.Value)), new x.constructor.elem(x))])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.deleteShader }; } $f._r$1 = _r$1; $f.c = c; $f.gl = gl; $f.s = s; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.deleteShader = function(s) { return this.$val.deleteShader(s); };
	context.ptr.prototype.newProgram = function(shaders, attributes) {
		var _i, _i$1, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _ref, _ref$1, attributes, c, gl, i, id, name, shader$1, shaders, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _ref = $f._ref; _ref$1 = $f._ref$1; attributes = $f.attributes; c = $f.c; gl = $f.gl; i = $f.i; id = $f.id; name = $f.name; shader$1 = $f.shader$1; shaders = $f.shaders; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("createProgram", new sliceType$4([])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		v = $clone(_r$1, js.Value);
		if ($equal(v, js.Null(), js.Value)) {
			$s = -1; return [new program.ptr(new js.Value.ptr(null, false), 0), errors.New("opengl: glCreateProgram failed")];
		}
		_ref = shaders;
		_i = 0;
		/* while (true) { */ case 3:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }
			shader$1 = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), shader);
			_r$2 = $clone(gl, js.Value).Call("attachShader", new sliceType$4([new v.constructor.elem(v), (x = ($clone(shader$1, js.Value)), new x.constructor.elem(x))])); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_r$2;
			_i++;
		/* } */ $s = 3; continue; case 4:
		_ref$1 = attributes;
		_i$1 = 0;
		/* while (true) { */ case 6:
			/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 7; continue; }
			i = _i$1;
			name = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			_r$3 = $clone(gl, js.Value).Call("bindAttribLocation", new sliceType$4([new v.constructor.elem(v), new $Int(i), new $String(name)])); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			_r$3;
			_i$1++;
		/* } */ $s = 6; continue; case 7:
		_r$4 = $clone(gl, js.Value).Call("linkProgram", new sliceType$4([new v.constructor.elem(v)])); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_r$4;
		_r$5 = $clone(gl, js.Value).Call("getProgramParameter", new sliceType$4([new v.constructor.elem(v), new linkStatus.constructor.elem(linkStatus)])); /* */ $s = 12; case 12: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_r$6 = $clone(_r$5, js.Value).Bool(); /* */ $s = 13; case 13: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		/* */ if (!_r$6) { $s = 10; continue; }
		/* */ $s = 11; continue;
		/* if (!_r$6) { */ case 10:
			$s = -1; return [new program.ptr(new js.Value.ptr(null, false), 0), errors.New("opengl: program error")];
		/* } */ case 11:
		id = c.contextImpl.lastProgramID;
		c.contextImpl.lastProgramID = c.contextImpl.lastProgramID + (1) >> 0;
		$s = -1; return [new program.ptr($clone(v, js.Value), id), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.newProgram }; } $f._i = _i; $f._i$1 = _i$1; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._ref = _ref; $f._ref$1 = _ref$1; $f.attributes = attributes; $f.c = c; $f.gl = gl; $f.i = i; $f.id = id; $f.name = name; $f.shader$1 = shader$1; $f.shaders = shaders; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.newProgram = function(shaders, attributes) { return this.$val.newProgram(shaders, attributes); };
	context.ptr.prototype.useProgram = function(p) {
		var _r$1, c, gl, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; c = $f.c; gl = $f.gl; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("useProgram", new sliceType$4([(x = p.value, new x.constructor.elem(x))])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.useProgram }; } $f._r$1 = _r$1; $f.c = c; $f.gl = gl; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.useProgram = function(p) { return this.$val.useProgram(p); };
	context.ptr.prototype.deleteProgram = function(p) {
		var _r$1, _r$2, _r$3, c, gl, p, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; c = $f.c; gl = $f.gl; p = $f.p; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("isProgram", new sliceType$4([(x = p.value, new x.constructor.elem(x))])); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = $clone(_r$1, js.Value).Bool(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		/* */ if (!_r$2) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!_r$2) { */ case 2:
			$s = -1; return;
		/* } */ case 3:
		_r$3 = $clone(gl, js.Value).Call("deleteProgram", new sliceType$4([(x$1 = p.value, new x$1.constructor.elem(x$1))])); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$3;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.deleteProgram }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.c = c; $f.gl = gl; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.deleteProgram = function(p) { return this.$val.deleteProgram(p); };
	context.ptr.prototype.getUniformLocationImpl = function(p, location) {
		var _r$1, c, gl, location, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; c = $f.c; gl = $f.gl; location = $f.location; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("getUniformLocation", new sliceType$4([(x = p.value, new x.constructor.elem(x)), new $String(location)])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return ($clone(_r$1, uniformLocation));
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.getUniformLocationImpl }; } $f._r$1 = _r$1; $f.c = c; $f.gl = gl; $f.location = location; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.getUniformLocationImpl = function(p, location) { return this.$val.getUniformLocationImpl(p, location); };
	context.ptr.prototype.uniformInt = function(p, location, v) {
		var _r$1, _r$2, c, gl, l, location, p, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; c = $f.c; gl = $f.gl; l = $f.l; location = $f.location; p = $f.p; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = c.locationCache.GetUniformLocation(c, $clone(p, program), location); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		l = $clone(_r$1, uniformLocation);
		_r$2 = $clone(gl, js.Value).Call("uniform1i", new sliceType$4([(x = ($clone(l, js.Value)), new x.constructor.elem(x)), new $Int(v)])); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.uniformInt }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f.c = c; $f.gl = gl; $f.l = l; $f.location = location; $f.p = p; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.uniformInt = function(p, location, v) { return this.$val.uniformInt(p, location, v); };
	context.ptr.prototype.uniformFloat = function(p, location, v) {
		var _r$1, _r$2, c, gl, l, location, p, v, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; c = $f.c; gl = $f.gl; l = $f.l; location = $f.location; p = $f.p; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = c.locationCache.GetUniformLocation(c, $clone(p, program), location); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		l = $clone(_r$1, uniformLocation);
		_r$2 = $clone(gl, js.Value).Call("uniform1f", new sliceType$4([(x = ($clone(l, js.Value)), new x.constructor.elem(x)), new $Float32(v)])); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.uniformFloat }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f.c = c; $f.gl = gl; $f.l = l; $f.location = location; $f.p = p; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.uniformFloat = function(p, location, v) { return this.$val.uniformFloat(p, location, v); };
	context.ptr.prototype.uniformFloats = function(p, location, v) {
		var _1, _r$1, _r$2, _r$3, _r$4, _r$5, _tuple, arr, c, free, gl, l, location, p, v, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _tuple = $f._tuple; arr = $f.arr; c = $f.c; free = $f.free; gl = $f.gl; l = $f.l; location = $f.location; p = $f.p; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = c.locationCache.GetUniformLocation(c, $clone(p, program), location); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		l = $clone(_r$1, uniformLocation);
			_1 = v.$length;
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (4)) { $s = 5; continue; }
			/* */ if (_1 === (16)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (2)) { */ case 4:
				_r$2 = $clone(gl, js.Value).Call("uniform2f", new sliceType$4([(x = ($clone(l, js.Value)), new x.constructor.elem(x)), new $Float32((0 >= v.$length ? ($throwRuntimeError("index out of range"), undefined) : v.$array[v.$offset + 0])), new $Float32((1 >= v.$length ? ($throwRuntimeError("index out of range"), undefined) : v.$array[v.$offset + 1]))])); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$2;
				$s = 8; continue;
			/* } else if (_1 === (4)) { */ case 5:
				_r$3 = $clone(gl, js.Value).Call("uniform4f", new sliceType$4([(x$1 = ($clone(l, js.Value)), new x$1.constructor.elem(x$1)), new $Float32((0 >= v.$length ? ($throwRuntimeError("index out of range"), undefined) : v.$array[v.$offset + 0])), new $Float32((1 >= v.$length ? ($throwRuntimeError("index out of range"), undefined) : v.$array[v.$offset + 1])), new $Float32((2 >= v.$length ? ($throwRuntimeError("index out of range"), undefined) : v.$array[v.$offset + 2])), new $Float32((3 >= v.$length ? ($throwRuntimeError("index out of range"), undefined) : v.$array[v.$offset + 3]))])); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				_r$3;
				$s = 8; continue;
			/* } else if (_1 === (16)) { */ case 6:
				_tuple = jsutil.SliceToTypedArray(v);
				arr = $clone(_tuple[0], js.Value);
				free = _tuple[1];
				_r$4 = $clone(gl, js.Value).Call("uniformMatrix4fv", new sliceType$4([(x$2 = ($clone(l, js.Value)), new x$2.constructor.elem(x$2)), new $Bool(false), new arr.constructor.elem(arr)])); /* */ $s = 11; case 11: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				_r$4;
				$r = free(); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 8; continue;
			/* } else { */ case 7:
				_r$5 = fmt.Sprintf("opengl: invalid uniform floats num: %d", new sliceType$4([new $Int(v.$length)])); /* */ $s = 13; case 13: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				$panic(new $String(_r$5));
			/* } */ case 8:
		case 3:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.uniformFloats }; } $f._1 = _1; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._tuple = _tuple; $f.arr = arr; $f.c = c; $f.free = free; $f.gl = gl; $f.l = l; $f.location = location; $f.p = p; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.uniformFloats = function(p, location, v) { return this.$val.uniformFloats(p, location, v); };
	context.ptr.prototype.vertexAttribPointer = function(p, index, size, dataType$1, stride, offset) {
		var _r$1, c, dataType$1, gl, index, offset, p, size, stride, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; c = $f.c; dataType$1 = $f.dataType$1; gl = $f.gl; index = $f.index; offset = $f.offset; p = $f.p; size = $f.size; stride = $f.stride; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("vertexAttribPointer", new sliceType$4([new $Int(index), new $Int(size), new $Int(((dataType$1 >> 0))), new $Bool(false), new $Int(stride), new $Int(offset)])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.vertexAttribPointer }; } $f._r$1 = _r$1; $f.c = c; $f.dataType$1 = dataType$1; $f.gl = gl; $f.index = index; $f.offset = offset; $f.p = p; $f.size = size; $f.stride = stride; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.vertexAttribPointer = function(p, index, size, dataType$1, stride, offset) { return this.$val.vertexAttribPointer(p, index, size, dataType$1, stride, offset); };
	context.ptr.prototype.enableVertexAttribArray = function(p, index) {
		var _r$1, c, gl, index, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; c = $f.c; gl = $f.gl; index = $f.index; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("enableVertexAttribArray", new sliceType$4([new $Int(index)])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.enableVertexAttribArray }; } $f._r$1 = _r$1; $f.c = c; $f.gl = gl; $f.index = index; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.enableVertexAttribArray = function(p, index) { return this.$val.enableVertexAttribArray(p, index); };
	context.ptr.prototype.newArrayBuffer = function(size) {
		var _r$1, _r$2, _r$3, b, c, gl, size, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; b = $f.b; c = $f.c; gl = $f.gl; size = $f.size; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("createBuffer", new sliceType$4([])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		b = $clone(_r$1, js.Value);
		_r$2 = $clone(gl, js.Value).Call("bindBuffer", new sliceType$4([new $Int(((arrayBuffer >> 0))), (x = (b), new x.constructor.elem(x))])); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		_r$3 = $clone(gl, js.Value).Call("bufferData", new sliceType$4([new $Int(((arrayBuffer >> 0))), new $Int(size), new $Int(((dynamicDraw >> 0)))])); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$3;
		$s = -1; return ($clone(b, buffer));
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.newArrayBuffer }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.b = b; $f.c = c; $f.gl = gl; $f.size = size; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.newArrayBuffer = function(size) { return this.$val.newArrayBuffer(size); };
	context.ptr.prototype.newElementArrayBuffer = function(size) {
		var _r$1, _r$2, _r$3, b, c, gl, size, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; b = $f.b; c = $f.c; gl = $f.gl; size = $f.size; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("createBuffer", new sliceType$4([])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		b = $clone(_r$1, js.Value);
		_r$2 = $clone(gl, js.Value).Call("bindBuffer", new sliceType$4([new $Int(((elementArrayBuffer >> 0))), (x = (b), new x.constructor.elem(x))])); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		_r$3 = $clone(gl, js.Value).Call("bufferData", new sliceType$4([new $Int(((elementArrayBuffer >> 0))), new $Int(size), new $Int(((dynamicDraw >> 0)))])); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$3;
		$s = -1; return ($clone(b, buffer));
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.newElementArrayBuffer }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.b = b; $f.c = c; $f.gl = gl; $f.size = size; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.newElementArrayBuffer = function(size) { return this.$val.newElementArrayBuffer(size); };
	context.ptr.prototype.bindBuffer = function(bufferType$1, b) {
		var _r$1, b, bufferType$1, c, gl, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; b = $f.b; bufferType$1 = $f.bufferType$1; c = $f.c; gl = $f.gl; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("bindBuffer", new sliceType$4([new $Int(((bufferType$1 >> 0))), (x = ($clone(b, js.Value)), new x.constructor.elem(x))])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.bindBuffer }; } $f._r$1 = _r$1; $f.b = b; $f.bufferType$1 = bufferType$1; $f.c = c; $f.gl = gl; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.bindBuffer = function(bufferType$1, b) { return this.$val.bindBuffer(bufferType$1, b); };
	context.ptr.prototype.arrayBufferSubData = function(data) {
		var _r$1, _tuple, arr, c, data, free, gl, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _tuple = $f._tuple; arr = $f.arr; c = $f.c; data = $f.data; free = $f.free; gl = $f.gl; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_tuple = jsutil.SliceToTypedArray(data);
		arr = $clone(_tuple[0], js.Value);
		free = _tuple[1];
		_r$1 = $clone(gl, js.Value).Call("bufferSubData", new sliceType$4([new $Int(((arrayBuffer >> 0))), new $Int(0), new arr.constructor.elem(arr)])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$r = free(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.arrayBufferSubData }; } $f._r$1 = _r$1; $f._tuple = _tuple; $f.arr = arr; $f.c = c; $f.data = data; $f.free = free; $f.gl = gl; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.arrayBufferSubData = function(data) { return this.$val.arrayBufferSubData(data); };
	context.ptr.prototype.elementArrayBufferSubData = function(data) {
		var _r$1, _tuple, arr, c, data, free, gl, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _tuple = $f._tuple; arr = $f.arr; c = $f.c; data = $f.data; free = $f.free; gl = $f.gl; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_tuple = jsutil.SliceToTypedArray(data);
		arr = $clone(_tuple[0], js.Value);
		free = _tuple[1];
		_r$1 = $clone(gl, js.Value).Call("bufferSubData", new sliceType$4([new $Int(((elementArrayBuffer >> 0))), new $Int(0), new arr.constructor.elem(arr)])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$r = free(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.elementArrayBufferSubData }; } $f._r$1 = _r$1; $f._tuple = _tuple; $f.arr = arr; $f.c = c; $f.data = data; $f.free = free; $f.gl = gl; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.elementArrayBufferSubData = function(data) { return this.$val.elementArrayBufferSubData(data); };
	context.ptr.prototype.deleteBuffer = function(b) {
		var _r$1, b, c, gl, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; b = $f.b; c = $f.c; gl = $f.gl; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("deleteBuffer", new sliceType$4([(x = ($clone(b, js.Value)), new x.constructor.elem(x))])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.deleteBuffer }; } $f._r$1 = _r$1; $f.b = b; $f.c = c; $f.gl = gl; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.deleteBuffer = function(b) { return this.$val.deleteBuffer(b); };
	context.ptr.prototype.drawElements = function(len, offsetInBytes) {
		var _r$1, c, gl, len, offsetInBytes, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; c = $f.c; gl = $f.gl; len = $f.len; offsetInBytes = $f.offsetInBytes; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("drawElements", new sliceType$4([new triangles.constructor.elem(triangles), new $Int(len), new unsignedShort.constructor.elem(unsignedShort), new $Int(offsetInBytes)])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.drawElements }; } $f._r$1 = _r$1; $f.c = c; $f.gl = gl; $f.len = len; $f.offsetInBytes = offsetInBytes; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.drawElements = function(len, offsetInBytes) { return this.$val.drawElements(len, offsetInBytes); };
	context.ptr.prototype.maxTextureSizeImpl = function() {
		var _r$1, _r$2, c, gl, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; c = $f.c; gl = $f.gl; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("getParameter", new sliceType$4([new maxTextureSize.constructor.elem(maxTextureSize)])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = $clone(_r$1, js.Value).Int(); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.maxTextureSizeImpl }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f.c = c; $f.gl = gl; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.maxTextureSizeImpl = function() { return this.$val.maxTextureSizeImpl(); };
	context.ptr.prototype.getShaderPrecisionFormatPrecision = function() {
		var _arg, _arg$1, _r$1, _r$2, _r$3, _r$4, c, gl, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; c = $f.c; gl = $f.gl; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = js.ValueOf(new $Int(((fragmentShader >> 0)))); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_arg = (x = _r$1, new x.constructor.elem(x));
		_arg$1 = new highFloat.constructor.elem(highFloat);
		_r$2 = $clone(gl, js.Value).Call("getShaderPrecisionFormat", new sliceType$4([_arg, _arg$1])); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$3 = $clone(_r$2, js.Value).Get("precision"); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$4 = $clone(_r$3, js.Value).Int(); /* */ $s = 5; case 5: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		$s = -1; return _r$4;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.getShaderPrecisionFormatPrecision }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.c = c; $f.gl = gl; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.getShaderPrecisionFormatPrecision = function() { return this.$val.getShaderPrecisionFormatPrecision(); };
	context.ptr.prototype.flush = function() {
		var _r$1, c, gl, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; c = $f.c; gl = $f.gl; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = c.ensureGL(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		gl = $clone(c.contextImpl.gl, js.Value);
		_r$1 = $clone(gl, js.Value).Call("flush", new sliceType$4([])); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: context.ptr.prototype.flush }; } $f._r$1 = _r$1; $f.c = c; $f.gl = gl; $f.$s = $s; $f.$r = $r; return $f;
	};
	context.prototype.flush = function() { return this.$val.flush(); };
	context.ptr.prototype.needsRestoring = function() {
		var c;
		c = this;
		return !web.IsMobileBrowser();
	};
	context.prototype.needsRestoring = function() { return this.$val.needsRestoring(); };
	Get = function() {
		return theDriver;
	};
	$pkg.Get = Get;
	Driver.ptr.prototype.SetThread = function(thread$1) {
		var d, thread$1;
		d = this;
		d.context.t = thread$1;
	};
	Driver.prototype.SetThread = function(thread$1) { return this.$val.SetThread(thread$1); };
	Driver.ptr.prototype.Begin = function() {
		var d;
		d = this;
	};
	Driver.prototype.Begin = function() { return this.$val.Begin(); };
	Driver.ptr.prototype.End = function() {
		var d;
		d = this;
	};
	Driver.prototype.End = function() { return this.$val.End(); };
	Driver.ptr.prototype.SetWindow = function(window) {
		var d, window;
		d = this;
	};
	Driver.prototype.SetWindow = function(window) { return this.$val.SetWindow(window); };
	Driver.ptr.prototype.checkSize = function(width, height) {
		var _r$1, _r$2, _r$3, _r$4, _r$5, d, height, m, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; d = $f.d; height = $f.height; m = $f.m; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		/* */ if (width < 1) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (width < 1) { */ case 1:
			_r$1 = fmt.Sprintf("opengl: width (%d) must be equal or more than %d", new sliceType$4([new $Int(width), new $Int(1)])); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$panic(new $String(_r$1));
		/* } */ case 2:
		/* */ if (height < 1) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (height < 1) { */ case 4:
			_r$2 = fmt.Sprintf("opengl: height (%d) must be equal or more than %d", new sliceType$4([new $Int(height), new $Int(1)])); /* */ $s = 6; case 6: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			$panic(new $String(_r$2));
		/* } */ case 5:
		_r$3 = d.context.getMaxTextureSize(); /* */ $s = 7; case 7: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		m = _r$3;
		/* */ if (width > m) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if (width > m) { */ case 8:
			_r$4 = fmt.Sprintf("opengl: width (%d) must be less than or equal to %d", new sliceType$4([new $Int(width), new $Int(m)])); /* */ $s = 10; case 10: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			$panic(new $String(_r$4));
		/* } */ case 9:
		/* */ if (height > m) { $s = 11; continue; }
		/* */ $s = 12; continue;
		/* if (height > m) { */ case 11:
			_r$5 = fmt.Sprintf("opengl: height (%d) must be less than or equal to %d", new sliceType$4([new $Int(height), new $Int(m)])); /* */ $s = 13; case 13: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			$panic(new $String(_r$5));
		/* } */ case 12:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Driver.ptr.prototype.checkSize }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f.d = d; $f.height = height; $f.m = m; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	Driver.prototype.checkSize = function(width, height) { return this.$val.checkSize(width, height); };
	Driver.ptr.prototype.NewImage = function(width, height) {
		var _r$1, _tuple, d, err, h, height, i, t, w, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _tuple = $f._tuple; d = $f.d; err = $f.err; h = $f.h; height = $f.height; i = $f.i; t = $f.t; w = $f.w; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		i = new Image.ptr(d, new textureNative.ptr(null, false), ptrType$10.nil, width, height, false);
		w = graphics.InternalImageSize(width);
		h = graphics.InternalImageSize(height);
		$r = d.checkSize(w, h); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$1 = d.context.newTexture(w, h); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		t = $clone(_tuple[0], textureNative);
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [$ifaceNil, err];
		}
		textureNative.copy(i.textureNative, t);
		$s = -1; return [i, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Driver.ptr.prototype.NewImage }; } $f._r$1 = _r$1; $f._tuple = _tuple; $f.d = d; $f.err = err; $f.h = h; $f.height = height; $f.i = i; $f.t = t; $f.w = w; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	Driver.prototype.NewImage = function(width, height) { return this.$val.NewImage(width, height); };
	Driver.ptr.prototype.NewScreenFramebufferImage = function(width, height) {
		var d, height, i, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; d = $f.d; height = $f.height; i = $f.i; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		$r = d.checkSize(width, height); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		i = new Image.ptr(d, new textureNative.ptr(null, false), ptrType$10.nil, width, height, true);
		$s = -1; return [i, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Driver.ptr.prototype.NewScreenFramebufferImage }; } $f.d = d; $f.height = height; $f.i = i; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	Driver.prototype.NewScreenFramebufferImage = function(width, height) { return this.$val.NewScreenFramebufferImage(width, height); };
	Driver.ptr.prototype.Reset = function() {
		var _r$1, d, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; d = $f.d; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		_r$1 = d.state.reset(d.context); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Driver.ptr.prototype.Reset }; } $f._r$1 = _r$1; $f.d = d; $f.$s = $s; $f.$r = $r; return $f;
	};
	Driver.prototype.Reset = function() { return this.$val.Reset(); };
	Driver.ptr.prototype.SetVertices = function(vertices, indices) {
		var d, indices, vertices, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; d = $f.d; indices = $f.indices; vertices = $f.vertices; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		$r = d.context.arrayBufferSubData(vertices); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = d.context.elementArrayBufferSubData(indices); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Driver.ptr.prototype.SetVertices }; } $f.d = d; $f.indices = indices; $f.vertices = vertices; $f.$s = $s; $f.$r = $r; return $f;
	};
	Driver.prototype.SetVertices = function(vertices, indices) { return this.$val.SetVertices(vertices, indices); };
	Driver.ptr.prototype.Draw = function(indexLen, indexOffset, mode, colorM, filter, address) {
		var _r$1, address, colorM, d, err, filter, indexLen, indexOffset, mode, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; address = $f.address; colorM = $f.colorM; d = $f.d; err = $f.err; filter = $f.filter; indexLen = $f.indexLen; indexOffset = $f.indexOffset; mode = $f.mode; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		_r$1 = d.useProgram(mode, colorM, filter, address); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err = _r$1;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$r = d.context.drawElements(indexLen, $imul(indexOffset, 2)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Driver.ptr.prototype.Draw }; } $f._r$1 = _r$1; $f.address = address; $f.colorM = colorM; $f.d = d; $f.err = err; $f.filter = filter; $f.indexLen = indexLen; $f.indexOffset = indexOffset; $f.mode = mode; $f.$s = $s; $f.$r = $r; return $f;
	};
	Driver.prototype.Draw = function(indexLen, indexOffset, mode, colorM, filter, address) { return this.$val.Draw(indexLen, indexOffset, mode, colorM, filter, address); };
	Driver.ptr.prototype.Flush = function() {
		var d, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; d = $f.d; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		$r = d.context.flush(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Driver.ptr.prototype.Flush }; } $f.d = d; $f.$s = $s; $f.$r = $r; return $f;
	};
	Driver.prototype.Flush = function() { return this.$val.Flush(); };
	Driver.ptr.prototype.SetVsyncEnabled = function(enabled) {
		var d, enabled;
		d = this;
	};
	Driver.prototype.SetVsyncEnabled = function(enabled) { return this.$val.SetVsyncEnabled(enabled); };
	Driver.ptr.prototype.VDirection = function() {
		var d;
		d = this;
		return 1;
	};
	Driver.prototype.VDirection = function() { return this.$val.VDirection(); };
	Driver.ptr.prototype.NeedsRestoring = function() {
		var d;
		d = this;
		return d.context.needsRestoring();
	};
	Driver.prototype.NeedsRestoring = function() { return this.$val.NeedsRestoring(); };
	Driver.ptr.prototype.IsGL = function() {
		var d;
		d = this;
		return true;
	};
	Driver.prototype.IsGL = function() { return this.$val.IsGL(); };
	Driver.ptr.prototype.HasHighPrecisionFloat = function() {
		var _r$1, d, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; d = $f.d; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		_r$1 = d.context.hasHighPrecisionFloat(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Driver.ptr.prototype.HasHighPrecisionFloat }; } $f._r$1 = _r$1; $f.d = d; $f.$s = $s; $f.$r = $r; return $f;
	};
	Driver.prototype.HasHighPrecisionFloat = function() { return this.$val.HasHighPrecisionFloat(); };
	Driver.ptr.prototype.MaxImageSize = function() {
		var _r$1, d, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; d = $f.d; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		_r$1 = d.context.getMaxTextureSize(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Driver.ptr.prototype.MaxImageSize }; } $f._r$1 = _r$1; $f.d = d; $f.$s = $s; $f.$r = $r; return $f;
	};
	Driver.prototype.MaxImageSize = function() { return this.$val.MaxImageSize(); };
	newFramebufferFromTexture = function(context$1, texture, width, height) {
		var _r$1, _tuple, context$1, err, height, native$1, texture, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _tuple = $f._tuple; context$1 = $f.context$1; err = $f.err; height = $f.height; native$1 = $f.native$1; texture = $f.texture; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r$1 = context$1.newFramebuffer($clone(texture, textureNative)); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		native$1 = $clone(_tuple[0], framebufferNative);
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [ptrType$10.nil, err];
		}
		$s = -1; return [new framebuffer.ptr(ptrType$9.nil, $clone(native$1, framebufferNative), width, height), $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: newFramebufferFromTexture }; } $f._r$1 = _r$1; $f._tuple = _tuple; $f.context$1 = context$1; $f.err = err; $f.height = height; $f.native$1 = native$1; $f.texture = texture; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	newScreenFramebuffer = function(context$1, width, height) {
		var context$1, height, width;
		return new framebuffer.ptr(ptrType$9.nil, $clone(context$1.getScreenFramebuffer(), framebufferNative), width, height);
	};
	framebuffer.ptr.prototype.delete$ = function(context$1) {
		var context$1, f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; context$1 = $f.context$1; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		f = this;
		/* */ if (!($equal(f.native$1, context$1.getScreenFramebuffer(), framebufferNative))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!($equal(f.native$1, context$1.getScreenFramebuffer(), framebufferNative))) { */ case 1:
			$r = context$1.deleteFramebuffer($clone(f.native$1, framebufferNative)); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: framebuffer.ptr.prototype.delete$ }; } $f.context$1 = context$1; $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	framebuffer.prototype.delete$ = function(context$1) { return this.$val.delete$(context$1); };
	Image.ptr.prototype.IsInvalidated = function() {
		var _r$1, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_r$1 = i.driver.context.isTexture($clone(i.textureNative, textureNative)); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return !_r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.IsInvalidated }; } $f._r$1 = _r$1; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.IsInvalidated = function() { return this.$val.IsInvalidated(); };
	Image.ptr.prototype.Dispose = function() {
		var i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		/* */ if (!(i.framebuffer === ptrType$10.nil)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(i.framebuffer === ptrType$10.nil)) { */ case 1:
			$r = i.framebuffer.delete$(i.driver.context); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		/* */ if (!($equal(i.textureNative, new textureNative.ptr(null, false), textureNative))) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!($equal(i.textureNative, new textureNative.ptr(null, false), textureNative))) { */ case 4:
			$r = i.driver.context.deleteTexture($clone(i.textureNative, textureNative)); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 5:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.Dispose }; } $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.Dispose = function() { return this.$val.Dispose(); };
	Image.ptr.prototype.SetAsDestination = function() {
		var i;
		i = this;
		i.driver.state.destination = i;
	};
	Image.prototype.SetAsDestination = function() { return this.$val.SetAsDestination(); };
	Image.ptr.prototype.setViewport = function() {
		var _r$1, err, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; err = $f.err; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_r$1 = i.ensureFramebuffer(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err = _r$1;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$r = i.driver.context.setViewport(i.framebuffer); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.setViewport }; } $f._r$1 = _r$1; $f.err = err; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.setViewport = function() { return this.$val.setViewport(); };
	Image.ptr.prototype.Pixels = function() {
		var _r$1, _r$2, _tuple, err, err$1, i, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; i = $f.i; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_r$1 = i.ensureFramebuffer(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err = _r$1;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [sliceType$2.nil, err];
		}
		_r$2 = i.driver.context.framebufferPixels(i.framebuffer, i.width, i.height); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_tuple = _r$2;
		p = _tuple[0];
		err$1 = _tuple[1];
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return [sliceType$2.nil, err$1];
		}
		$s = -1; return [p, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.Pixels }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.i = i; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.Pixels = function() { return this.$val.Pixels(); };
	Image.ptr.prototype.ensureFramebuffer = function() {
		var _r$1, _tmp, _tmp$1, _tuple, err, f, h, i, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; err = $f.err; f = $f.f; h = $f.h; i = $f.i; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (!(i.framebuffer === ptrType$10.nil)) {
			$s = -1; return $ifaceNil;
		}
		if (i.screen) {
			i.framebuffer = newScreenFramebuffer(i.driver.context, i.width, i.height);
			$s = -1; return $ifaceNil;
		}
		_tmp = graphics.InternalImageSize(i.width);
		_tmp$1 = graphics.InternalImageSize(i.height);
		w = _tmp;
		h = _tmp$1;
		_r$1 = newFramebufferFromTexture(i.driver.context, $clone(i.textureNative, textureNative), w, h); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		f = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		i.framebuffer = f;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.ensureFramebuffer }; } $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.err = err; $f.f = f; $f.h = h; $f.i = i; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.ensureFramebuffer = function() { return this.$val.ensureFramebuffer(); };
	Image.ptr.prototype.ReplacePixels = function(p, x, y, width, height) {
		var height, i, p, width, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; height = $f.height; i = $f.i; p = $f.p; width = $f.width; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (i.screen) {
			$panic(new $String("opengl: ReplacePixels cannot be called on the screen, that doesn't have a texture"));
		}
		$r = i.driver.context.flush(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = i.driver.context.texSubImage2D($clone(i.textureNative, textureNative), p, x, y, width, height); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.ReplacePixels }; } $f.height = height; $f.i = i; $f.p = p; $f.width = width; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.ReplacePixels = function(p, x, y, width, height) { return this.$val.ReplacePixels(p, x, y, width, height); };
	Image.ptr.prototype.SetAsSource = function() {
		var i;
		i = this;
		i.driver.state.source = i;
	};
	Image.prototype.SetAsSource = function() { return this.$val.SetAsSource(); };
	newLocationCache = function() {
		return new locationCache.ptr($makeMap(programID.keyFor, []));
	};
	locationCache.ptr.prototype.GetUniformLocation = function(context$1, p, location) {
		var _entry, _entry$1, _entry$2, _entry$3, _key, _key$1, _r$1, _tuple, _tuple$1, c, context$1, id, l, location, ok, ok$1, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _key = $f._key; _key$1 = $f._key$1; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; c = $f.c; context$1 = $f.context$1; id = $f.id; l = $f.l; location = $f.location; ok = $f.ok; ok$1 = $f.ok$1; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		id = getProgramID($clone(p, program));
		_tuple = (_entry = c.uniformLocationCache[programID.keyFor(id)], _entry !== undefined ? [_entry.v, true] : [false, false]);
		ok = _tuple[1];
		if (!ok) {
			_key = id; (c.uniformLocationCache || $throwRuntimeError("assignment to entry in nil map"))[programID.keyFor(_key)] = { k: _key, v: $makeMap($String.keyFor, []) };
		}
		_tuple$1 = (_entry$1 = (_entry$2 = c.uniformLocationCache[programID.keyFor(id)], _entry$2 !== undefined ? _entry$2.v : false)[$String.keyFor(location)], _entry$1 !== undefined ? [_entry$1.v, true] : [new uniformLocation.ptr(null, false), false]);
		l = $clone(_tuple$1[0], uniformLocation);
		ok$1 = _tuple$1[1];
		/* */ if (!ok$1) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!ok$1) { */ case 1:
			_r$1 = context$1.getUniformLocationImpl($clone(p, program), location); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			uniformLocation.copy(l, _r$1);
			_key$1 = location; ((_entry$3 = c.uniformLocationCache[programID.keyFor(id)], _entry$3 !== undefined ? _entry$3.v : false) || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key$1)] = { k: _key$1, v: $clone(l, uniformLocation) };
		/* } */ case 2:
		$s = -1; return l;
		/* */ } return; } if ($f === undefined) { $f = { $blk: locationCache.ptr.prototype.GetUniformLocation }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._key = _key; $f._key$1 = _key$1; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.c = c; $f.context$1 = context$1; $f.id = id; $f.l = l; $f.location = location; $f.ok = ok; $f.ok$1 = ok$1; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	locationCache.prototype.GetUniformLocation = function(context$1, p, location) { return this.$val.GetUniformLocation(context$1, p, location); };
	arrayBufferLayout.ptr.prototype.names = function() {
		var _i, _ref, a, i, ns, p;
		a = this;
		ns = $makeSlice(sliceType$5, a.parts.$length);
		_ref = a.parts;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			p = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), arrayBufferLayoutPart);
			((i < 0 || i >= ns.$length) ? ($throwRuntimeError("index out of range"), undefined) : ns.$array[ns.$offset + i] = p.name);
			_i++;
		}
		return ns;
	};
	arrayBufferLayout.prototype.names = function() { return this.$val.names(); };
	arrayBufferLayout.ptr.prototype.totalBytes = function() {
		var _i, _r$1, _ref, a, p, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r$1 = $f._r$1; _ref = $f._ref; a = $f.a; p = $f.p; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		a = this;
		if (!((a.total === 0))) {
			$s = -1; return a.total;
		}
		t = 0;
		_ref = a.parts;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			p = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), arrayBufferLayoutPart);
			_r$1 = new dataType(float$1).SizeInBytes(); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			t = t + (($imul(_r$1, p.num))) >> 0;
			_i++;
		/* } */ $s = 1; continue; case 2:
		a.total = t;
		$s = -1; return a.total;
		/* */ } return; } if ($f === undefined) { $f = { $blk: arrayBufferLayout.ptr.prototype.totalBytes }; } $f._i = _i; $f._r$1 = _r$1; $f._ref = _ref; $f.a = a; $f.p = p; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	arrayBufferLayout.prototype.totalBytes = function() { return this.$val.totalBytes(); };
	arrayBufferLayout.ptr.prototype.newArrayBuffer = function(context$1) {
		var _r$1, _r$2, a, context$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$1 = $f._r$1; _r$2 = $f._r$2; a = $f.a; context$1 = $f.context$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		a = this;
		_r$1 = a.totalBytes(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = context$1.newArrayBuffer($imul(_r$1, 65535)); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: arrayBufferLayout.ptr.prototype.newArrayBuffer }; } $f._r$1 = _r$1; $f._r$2 = _r$2; $f.a = a; $f.context$1 = context$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	arrayBufferLayout.prototype.newArrayBuffer = function(context$1) { return this.$val.newArrayBuffer(context$1); };
	arrayBufferLayout.ptr.prototype.enable = function(context$1, program$1) {
		var _i, _i$1, _r$1, _r$2, _ref, _ref$1, a, context$1, i, i$1, offset, p, program$1, total, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _ref$1 = $f._ref$1; a = $f.a; context$1 = $f.context$1; i = $f.i; i$1 = $f.i$1; offset = $f.offset; p = $f.p; program$1 = $f.program$1; total = $f.total; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		a = this;
		_ref = a.parts;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			$r = context$1.enableVertexAttribArray($clone(program$1, program), i); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 1; continue; case 2:
		_r$1 = a.totalBytes(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		total = _r$1;
		offset = 0;
		_ref$1 = a.parts;
		_i$1 = 0;
		/* while (true) { */ case 5:
			/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 6; continue; }
			i$1 = _i$1;
			p = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), arrayBufferLayoutPart);
			$r = context$1.vertexAttribPointer($clone(program$1, program), i$1, p.num, float$1, total, offset); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$2 = new dataType(float$1).SizeInBytes(); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			offset = offset + (($imul(_r$2, p.num))) >> 0;
			_i$1++;
		/* } */ $s = 5; continue; case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: arrayBufferLayout.ptr.prototype.enable }; } $f._i = _i; $f._i$1 = _i$1; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._ref$1 = _ref$1; $f.a = a; $f.context$1 = context$1; $f.i = i; $f.i$1 = i$1; $f.offset = offset; $f.p = p; $f.program$1 = program$1; $f.total = total; $f.$s = $s; $f.$r = $r; return $f;
	};
	arrayBufferLayout.prototype.enable = function(context$1, program$1) { return this.$val.enable(context$1, program$1); };
	init = function() {
		var _q, _r$1, _r$2, _r$3, vertexFloatNum, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; vertexFloatNum = $f.vertexFloatNum; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r$1 = theArrayBufferLayout.totalBytes(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = new dataType(float$1).SizeInBytes(); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		vertexFloatNum = (_q = _r$1 / _r$2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		/* */ if (!((12 === vertexFloatNum))) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (!((12 === vertexFloatNum))) { */ case 3:
			_r$3 = fmt.Sprintf("vertex float num must be %d but %d", new sliceType$4([new $Int(12), new $Int(vertexFloatNum)])); /* */ $s = 5; case 5: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			$panic(new $String(_r$3));
		/* } */ case 4:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f._q = _q; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.vertexFloatNum = vertexFloatNum; $f.$s = $s; $f.$r = $r; return $f;
	};
	openGLState.ptr.prototype.reset = function(context$1) {
		var _arg, _arg$1, _arg$2, _arg$3, _entry, _i, _i$1, _i$2, _i$3, _key, _keys, _r$1, _r$10, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, _ref$2, _ref$3, _tuple, _tuple$1, _tuple$2, a, c, context$1, err, err$1, err$2, f, k, p, program$1, s, shaderFragmentColorMatrixNative, shaderVertexModelviewNative, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _entry = $f._entry; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _i$3 = $f._i$3; _key = $f._key; _keys = $f._keys; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _ref$3 = $f._ref$3; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; a = $f.a; c = $f.c; context$1 = $f.context$1; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; f = $f.f; k = $f.k; p = $f.p; program$1 = $f.program$1; s = $f.s; shaderFragmentColorMatrixNative = $f.shaderFragmentColorMatrixNative; shaderVertexModelviewNative = $f.shaderVertexModelviewNative; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		s = this;
		_r$1 = context$1.reset(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err = _r$1;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		program.copy(s.lastProgram, zeroProgram);
		s.lastViewportWidth = 0;
		s.lastViewportHeight = 0;
		s.lastColorMatrix = sliceType.nil;
		s.lastColorMatrixTranslation = sliceType.nil;
		s.lastSourceWidth = 0;
		s.lastSourceHeight = 0;
		s.lastFilter = ptrType.nil;
		s.lastAddress = ptrType$1.nil;
		/* */ if (s.programs === false) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (s.programs === false) { */ case 2:
			s.programs = $makeMap(programKey.keyFor, []);
			$s = 4; continue;
		/* } else { */ case 3:
			_ref = s.programs;
			_i = 0;
			_keys = $keys(_ref);
			/* while (true) { */ case 5:
				/* if (!(_i < _keys.length)) { break; } */ if(!(_i < _keys.length)) { $s = 6; continue; }
				_entry = _ref[_keys[_i]];
				if (_entry === undefined) {
					_i++;
					/* continue; */ $s = 5; continue;
				}
				k = $clone(_entry.k, programKey);
				p = $clone(_entry.v, program);
				$r = context$1.deleteProgram($clone(p, program)); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				delete s.programs[programKey.keyFor(k)];
				_i++;
			/* } */ $s = 5; continue; case 6:
		/* } */ case 4:
		/* */ if (!web.IsBrowser()) { $s = 8; continue; }
		/* */ $s = 9; continue;
		/* if (!web.IsBrowser()) { */ case 8:
			/* */ if (!($equal(s.arrayBuffer, zeroBuffer, buffer))) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (!($equal(s.arrayBuffer, zeroBuffer, buffer))) { */ case 10:
				$r = context$1.deleteBuffer($clone(s.arrayBuffer, buffer)); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 11:
			/* */ if (!($equal(s.elementArrayBuffer, zeroBuffer, buffer))) { $s = 13; continue; }
			/* */ $s = 14; continue;
			/* if (!($equal(s.elementArrayBuffer, zeroBuffer, buffer))) { */ case 13:
				$r = context$1.deleteBuffer($clone(s.elementArrayBuffer, buffer)); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 14:
		/* } */ case 9:
		_arg = vertexShader;
		_r$2 = vertexShaderStr(); /* */ $s = 16; case 16: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_arg$1 = _r$2;
		_r$3 = context$1.newShader(_arg, _arg$1); /* */ $s = 17; case 17: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_tuple = _r$3;
		shaderVertexModelviewNative = $clone(_tuple[0], shader);
		err$1 = _tuple[1];
		/* */ if (!($interfaceIsEqual(err$1, $ifaceNil))) { $s = 18; continue; }
		/* */ $s = 19; continue;
		/* if (!($interfaceIsEqual(err$1, $ifaceNil))) { */ case 18:
			_r$4 = fmt.Sprintf("graphics: shader compiling error:\n%s", new sliceType$4([err$1])); /* */ $s = 20; case 20: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			$panic(new $String(_r$4));
		/* } */ case 19:
		$deferred.push([$methodVal(context$1, "deleteShader"), [$clone(shaderVertexModelviewNative, shader)]]);
		_ref$1 = new sliceType$6([false, true]);
		_i$1 = 0;
		/* while (true) { */ case 21:
			/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 22; continue; }
			c = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			_ref$2 = new sliceType$7([0, 1]);
			_i$2 = 0;
			/* while (true) { */ case 23:
				/* if (!(_i$2 < _ref$2.$length)) { break; } */ if(!(_i$2 < _ref$2.$length)) { $s = 24; continue; }
				a = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
				_ref$3 = new sliceType$8([1, 2, 3]);
				_i$3 = 0;
				/* while (true) { */ case 25:
					/* if (!(_i$3 < _ref$3.$length)) { break; } */ if(!(_i$3 < _ref$3.$length)) { $s = 26; continue; }
					f = ((_i$3 < 0 || _i$3 >= _ref$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$3.$array[_ref$3.$offset + _i$3]);
					_arg$2 = fragmentShader;
					_r$5 = fragmentShaderStr(c, f, a); /* */ $s = 27; case 27: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					_arg$3 = _r$5;
					_r$6 = context$1.newShader(_arg$2, _arg$3); /* */ $s = 28; case 28: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
					_tuple$1 = _r$6;
					shaderFragmentColorMatrixNative = $clone(_tuple$1[0], shader);
					err$2 = _tuple$1[1];
					/* */ if (!($interfaceIsEqual(err$2, $ifaceNil))) { $s = 29; continue; }
					/* */ $s = 30; continue;
					/* if (!($interfaceIsEqual(err$2, $ifaceNil))) { */ case 29:
						_r$7 = fmt.Sprintf("graphics: shader compiling error:\n%s", new sliceType$4([err$2])); /* */ $s = 31; case 31: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
						$panic(new $String(_r$7));
					/* } */ case 30:
					$deferred.push([$methodVal(context$1, "deleteShader"), [$clone(shaderFragmentColorMatrixNative, shader)]]);
					_r$8 = context$1.newProgram(new sliceType$9([$clone(shaderVertexModelviewNative, shader), $clone(shaderFragmentColorMatrixNative, shader)]), theArrayBufferLayout.names()); /* */ $s = 32; case 32: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
					_tuple$2 = _r$8;
					program$1 = $clone(_tuple$2[0], program);
					err$2 = _tuple$2[1];
					if (!($interfaceIsEqual(err$2, $ifaceNil))) {
						$s = -1; return err$2;
					}
					_key = new programKey.ptr(c, f, a); (s.programs || $throwRuntimeError("assignment to entry in nil map"))[programKey.keyFor(_key)] = { k: _key, v: $clone(program$1, program) };
					_i$3++;
				/* } */ $s = 25; continue; case 26:
				_i$2++;
			/* } */ $s = 23; continue; case 24:
			_i$1++;
		/* } */ $s = 21; continue; case 22:
		_r$9 = theArrayBufferLayout.newArrayBuffer(context$1); /* */ $s = 33; case 33: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		buffer.copy(s.arrayBuffer, _r$9);
		_r$10 = context$1.newElementArrayBuffer(131070); /* */ $s = 34; case 34: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
		buffer.copy(s.elementArrayBuffer, _r$10);
		$s = -1; return $ifaceNil;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: openGLState.ptr.prototype.reset }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._entry = _entry; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._i$3 = _i$3; $f._key = _key; $f._keys = _keys; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._ref$3 = _ref$3; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.a = a; $f.c = c; $f.context$1 = context$1; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.f = f; $f.k = k; $f.p = p; $f.program$1 = program$1; $f.s = s; $f.shaderFragmentColorMatrixNative = shaderFragmentColorMatrixNative; $f.shaderVertexModelviewNative = shaderVertexModelviewNative; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	openGLState.prototype.reset = function(context$1) { return this.$val.reset(context$1); };
	areSameFloat32Array = function(a, b) {
		var a, b, i;
		if (!((a.$length === b.$length))) {
			return false;
		}
		i = 0;
		while (true) {
			if (!(i < a.$length)) { break; }
			if (!((((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i]) === ((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i])))) {
				return false;
			}
			i = i + (1) >> 0;
		}
		return true;
	};
	Driver.ptr.prototype.useProgram = function(mode, colorM, filter, address) {
		var _entry, _r$1, _tmp, _tmp$1, _tuple, address, colorM, d, destination, dstW, err, esBody, esTranslate, filter, mode, program$1, scale, sh, source, srcH, srcW, sw, vh, vw, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; address = $f.address; colorM = $f.colorM; d = $f.d; destination = $f.destination; dstW = $f.dstW; err = $f.err; esBody = $f.esBody; esTranslate = $f.esTranslate; filter = $f.filter; mode = $f.mode; program$1 = $f.program$1; scale = $f.scale; sh = $f.sh; source = $f.source; srcH = $f.srcH; srcW = $f.srcW; sw = $f.sw; vh = $f.vh; vw = $f.vw; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this;
		destination = d.state.destination;
		if (destination === ptrType$2.nil) {
			$panic(new $String("destination image is not set"));
		}
		source = d.state.source;
		if (source === ptrType$2.nil) {
			$panic(new $String("source image is not set"));
		}
		_r$1 = destination.setViewport(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err = _r$1;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		dstW = destination.width;
		_tmp = source.width;
		_tmp$1 = source.height;
		srcW = _tmp;
		srcH = _tmp$1;
		$r = d.context.blendFunc(mode); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		program$1 = $clone((_entry = d.state.programs[programKey.keyFor(new programKey.ptr(!(colorM === ptrType$11.nil), filter, address))], _entry !== undefined ? _entry.v : new program.ptr(new js.Value.ptr(null, false), 0)), program);
		/* */ if (!($equal(d.state.lastProgram, program$1, program))) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (!($equal(d.state.lastProgram, program$1, program))) { */ case 3:
			$r = d.context.useProgram($clone(program$1, program)); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* */ if ($equal(d.state.lastProgram, zeroProgram, program)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if ($equal(d.state.lastProgram, zeroProgram, program)) { */ case 6:
				$r = theArrayBufferLayout.enable(d.context, $clone(program$1, program)); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$r = d.context.bindBuffer(arrayBuffer, $clone(d.state.arrayBuffer, buffer)); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$r = d.context.bindBuffer(elementArrayBuffer, $clone(d.state.elementArrayBuffer, buffer)); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$r = d.context.uniformInt($clone(program$1, program), "texture", 0); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 7:
			program.copy(d.state.lastProgram, program$1);
			d.state.lastViewportWidth = 0;
			d.state.lastViewportHeight = 0;
			d.state.lastColorMatrix = sliceType.nil;
			d.state.lastColorMatrixTranslation = sliceType.nil;
			d.state.lastSourceWidth = 0;
			d.state.lastSourceHeight = 0;
		/* } */ case 4:
		vw = destination.framebuffer.width;
		vh = destination.framebuffer.height;
		/* */ if (!((d.state.lastViewportWidth === vw)) || !((d.state.lastViewportHeight === vh))) { $s = 12; continue; }
		/* */ $s = 13; continue;
		/* if (!((d.state.lastViewportWidth === vw)) || !((d.state.lastViewportHeight === vh))) { */ case 12:
			$r = d.context.uniformFloats($clone(program$1, program), "viewport_size", new sliceType([(vw), (vh)])); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			d.state.lastViewportWidth = vw;
			d.state.lastViewportHeight = vh;
		/* } */ case 13:
		/* */ if (!(colorM === ptrType$11.nil)) { $s = 15; continue; }
		/* */ $s = 16; continue;
		/* if (!(colorM === ptrType$11.nil)) { */ case 15:
			_tuple = colorM.UnsafeElements();
			esBody = _tuple[0];
			esTranslate = _tuple[1];
			/* */ if (!areSameFloat32Array(d.state.lastColorMatrix, esBody)) { $s = 17; continue; }
			/* */ $s = 18; continue;
			/* if (!areSameFloat32Array(d.state.lastColorMatrix, esBody)) { */ case 17:
				$r = d.context.uniformFloats($clone(program$1, program), "color_matrix_body", esBody); /* */ $s = 19; case 19: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				d.state.lastColorMatrix = esBody;
			/* } */ case 18:
			/* */ if (!areSameFloat32Array(d.state.lastColorMatrixTranslation, esTranslate)) { $s = 20; continue; }
			/* */ $s = 21; continue;
			/* if (!areSameFloat32Array(d.state.lastColorMatrixTranslation, esTranslate)) { */ case 20:
				$r = d.context.uniformFloats($clone(program$1, program), "color_matrix_translation", esTranslate); /* */ $s = 22; case 22: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				d.state.lastColorMatrixTranslation = esTranslate;
			/* } */ case 21:
		/* } */ case 16:
		/* */ if (!((filter === 1))) { $s = 23; continue; }
		/* */ $s = 24; continue;
		/* if (!((filter === 1))) { */ case 23:
			sw = graphics.InternalImageSize(srcW);
			sh = graphics.InternalImageSize(srcH);
			/* */ if (!((d.state.lastSourceWidth === sw)) || !((d.state.lastSourceHeight === sh))) { $s = 25; continue; }
			/* */ $s = 26; continue;
			/* if (!((d.state.lastSourceWidth === sw)) || !((d.state.lastSourceHeight === sh))) { */ case 25:
				$r = d.context.uniformFloats($clone(program$1, program), "source_size", new sliceType([(sw), (sh)])); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				d.state.lastSourceWidth = sw;
				d.state.lastSourceHeight = sh;
			/* } */ case 26:
		/* } */ case 24:
		/* */ if (filter === 3) { $s = 28; continue; }
		/* */ $s = 29; continue;
		/* if (filter === 3) { */ case 28:
			scale = $fround((dstW) / (srcW));
			$r = d.context.uniformFloat($clone(program$1, program), "scale", scale); /* */ $s = 30; case 30: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 29:
		$r = d.context.bindTexture($clone(source.textureNative, textureNative)); /* */ $s = 31; case 31: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		d.state.source = ptrType$2.nil;
		d.state.destination = ptrType$2.nil;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Driver.ptr.prototype.useProgram }; } $f._entry = _entry; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.address = address; $f.colorM = colorM; $f.d = d; $f.destination = destination; $f.dstW = dstW; $f.err = err; $f.esBody = esBody; $f.esTranslate = esTranslate; $f.filter = filter; $f.mode = mode; $f.program$1 = program$1; $f.scale = scale; $f.sh = sh; $f.source = source; $f.srcH = srcH; $f.srcW = srcW; $f.sw = sw; $f.vh = vh; $f.vw = vw; $f.$s = $s; $f.$r = $r; return $f;
	};
	Driver.prototype.useProgram = function(mode, colorM, filter, address) { return this.$val.useProgram(mode, colorM, filter, address); };
	checkGLSL = function(src) {
		var _entry, _i, _i$1, _r$1, _r$2, _ref, _ref$1, _tuple, l, ok, src, token, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _i$1 = $f._i$1; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _ref$1 = $f._ref$1; _tuple = $f._tuple; l = $f.l; ok = $f.ok; src = $f.src; token = $f.token; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_ref = strings.Split(src, "\n");
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			l = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (strings.Contains(l, "//")) {
				l = $substring(l, 0, strings.Index(l, "//"));
			}
			_r$1 = glslIdentifier.FindAllString(l, -1); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_ref$1 = _r$1;
			_i$1 = 0;
			/* while (true) { */ case 4:
				/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 5; continue; }
				token = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
				_tuple = (_entry = glslReservedKeywords[$String.keyFor(token)], _entry !== undefined ? [_entry.v, true] : [new structType.ptr(), false]);
				ok = _tuple[1];
				/* */ if (ok) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if (ok) { */ case 6:
					_r$2 = fmt.Sprintf("opengl: %q is a reserved keyword", new sliceType$4([new $String(token)])); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					$panic(new $String(_r$2));
				/* } */ case 7:
				_i$1++;
			/* } */ $s = 4; continue; case 5:
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: checkGLSL }; } $f._entry = _entry; $f._i = _i; $f._i$1 = _i$1; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tuple = _tuple; $f.l = l; $f.ok = ok; $f.src = src; $f.token = token; $f.$s = $s; $f.$r = $r; return $f;
	};
	vertexShaderStr = function() {
		var src, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		src = "\nuniform vec2 viewport_size;\nattribute vec2 vertex;\nattribute vec2 tex;\nattribute vec4 tex_region;\nattribute vec4 color_scale;\nvarying vec2 varying_tex;\nvarying vec4 varying_tex_region;\nvarying vec4 varying_color_scale;\n\nvoid main(void) {\n  varying_tex = tex;\n  varying_tex_region = tex_region;\n  varying_color_scale = color_scale;\n\n  mat4 projection_matrix = mat4(\n    vec4(2.0 / viewport_size.x, 0, 0, 0),\n    vec4(0, 2.0 / viewport_size.y, 0, 0),\n    vec4(0, 0, 1, 0),\n    vec4(-1, -1, 0, 1)\n  );\n  gl_Position = projection_matrix * vec4(vertex, 0, 1);\n}\n";
		$r = checkGLSL(src); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return src;
		/* */ } return; } if ($f === undefined) { $f = { $blk: vertexShaderStr }; } $f.src = src; $f.$s = $s; $f.$r = $r; return $f;
	};
	fragmentShaderStr = function(useColorM, filter, address) {
		var _1, _2, _entry, _i, _keys, _r$1, _r$2, _r$3, _r$4, _ref, address, defs, filter, k, replaces, src, useColorM, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; address = $f.address; defs = $f.defs; filter = $f.filter; k = $f.k; replaces = $f.replaces; src = $f.src; useColorM = $f.useColorM; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r$1 = fmt.Sprintf("%d", new sliceType$4([new driver.Address(0)])); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = fmt.Sprintf("%d", new sliceType$4([new driver.Address(1)])); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		replaces = $makeMap($String.keyFor, [{ k: "{{.AddressClampToZero}}", v: _r$1 }, { k: "{{.AddressRepeat}}", v: _r$2 }]);
		src = "\n#if defined(GL_ES)\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\n{{.Definitions}}\n\nuniform sampler2D texture;\n\n#if defined(USE_COLOR_MATRIX)\nuniform mat4 color_matrix_body;\nuniform vec4 color_matrix_translation;\n#endif\n\nuniform highp vec2 source_size;\n\n#if defined(FILTER_SCREEN)\nuniform highp float scale;\n#endif\n\nvarying highp vec2 varying_tex;\nvarying highp vec4 varying_tex_region;\nvarying highp vec4 varying_color_scale;\n\n// adjustTexel adjusts the two texels and returns the adjusted second texel.\n// When p1 - p0 is exactly equal to the texel size, jaggy can happen on macOS (#669).\n// In order to avoid this jaggy, subtract a little bit from the second texel.\nhighp vec2 adjustTexel(highp vec2 p0, highp vec2 p1) {\n  highp vec2 texel_size = 1.0 / source_size;\n  if (fract((p1.x-p0.x)*source_size.x) == 0.0) {\n    p1.x -= texel_size.x / 512.0;\n  }\n  if (fract((p1.y-p0.y)*source_size.y) == 0.0) {\n    p1.y -= texel_size.y / 512.0;\n  }\n  return p1;\n}\n\nhighp float floorMod(highp float x, highp float y) {\n  if (x < 0.0) {\n    return y - (-x - y * floor(-x/y));\n  }\n  return x - y * floor(x/y);\n}\n\nhighp vec2 adjustTexelByAddress(highp vec2 p, highp vec4 tex_region) {\n#if defined(ADDRESS_CLAMP_TO_ZERO)\n  return p;\n#endif\n\n#if defined(ADDRESS_REPEAT)\n  highp vec2 o = vec2(tex_region[0], tex_region[1]);\n  highp vec2 size = vec2(tex_region[2] - tex_region[0], tex_region[3] - tex_region[1]);\n  return vec2(floorMod((p.x - o.x), size.x) + o.x, floorMod((p.y - o.y), size.y) + o.y);\n#endif\n}\n\nvoid main(void) {\n  highp vec2 pos = varying_tex;\n\n#if defined(FILTER_NEAREST)\n  vec4 color;\n  pos = adjustTexelByAddress(pos, varying_tex_region);\n  if (varying_tex_region[0] <= pos.x &&\n      varying_tex_region[1] <= pos.y &&\n      pos.x < varying_tex_region[2] &&\n      pos.y < varying_tex_region[3]) {\n    color = texture2D(texture, pos);\n  } else {\n    color = vec4(0, 0, 0, 0);\n  }\n#endif\n\n#if defined(FILTER_LINEAR)\n  vec4 color;\n  highp vec2 texel_size = 1.0 / source_size;\n  highp vec2 p0 = pos - texel_size / 2.0;\n  highp vec2 p1 = pos + texel_size / 2.0;\n\n  p1 = adjustTexel(p0, p1);\n  p0 = adjustTexelByAddress(p0, varying_tex_region);\n  p1 = adjustTexelByAddress(p1, varying_tex_region);\n\n  vec4 c0 = texture2D(texture, p0);\n  vec4 c1 = texture2D(texture, vec2(p1.x, p0.y));\n  vec4 c2 = texture2D(texture, vec2(p0.x, p1.y));\n  vec4 c3 = texture2D(texture, p1);\n  if (p0.x < varying_tex_region[0]) {\n    c0 = vec4(0, 0, 0, 0);\n    c2 = vec4(0, 0, 0, 0);\n  }\n  if (p0.y < varying_tex_region[1]) {\n    c0 = vec4(0, 0, 0, 0);\n    c1 = vec4(0, 0, 0, 0);\n  }\n  if (varying_tex_region[2] <= p1.x) {\n    c1 = vec4(0, 0, 0, 0);\n    c3 = vec4(0, 0, 0, 0);\n  }\n  if (varying_tex_region[3] <= p1.y) {\n    c2 = vec4(0, 0, 0, 0);\n    c3 = vec4(0, 0, 0, 0);\n  }\n\n  vec2 rate = fract(p0 * source_size);\n  color = mix(mix(c0, c1, rate.x), mix(c2, c3, rate.x), rate.y);\n#endif\n\n#if defined(FILTER_SCREEN)\n  highp vec2 texel_size = 1.0 / source_size;\n  highp vec2 half_scaled_texel_size = texel_size / 2.0 / scale;\n  highp vec2 p0 = pos - half_scaled_texel_size;\n  highp vec2 p1 = pos + half_scaled_texel_size;\n\n  p1 = adjustTexel(p0, p1);\n\n  vec4 c0 = texture2D(texture, p0);\n  vec4 c1 = texture2D(texture, vec2(p1.x, p0.y));\n  vec4 c2 = texture2D(texture, vec2(p0.x, p1.y));\n  vec4 c3 = texture2D(texture, p1);\n  // Texels must be in the source rect, so it is not necessary to check that like linear filter.\n\n  vec2 rate_center = vec2(1.0, 1.0) - half_scaled_texel_size;\n  vec2 rate = clamp(((fract(p0 * source_size) - rate_center) * scale) + rate_center, 0.0, 1.0);\n  gl_FragColor = mix(mix(c0, c1, rate.x), mix(c2, c3, rate.x), rate.y);\n  // Assume that a color matrix and color vector values are not used with FILTER_SCREEN.\n\n#else\n\n#if defined(USE_COLOR_MATRIX)\n  // Un-premultiply alpha.\n  // When the alpha is 0, 1.0 - sign(alpha) is 1.0, which means division does nothing.\n  color.rgb /= color.a + (1.0 - sign(color.a));\n  // Apply the color matrix or scale.\n  color = (color_matrix_body * color) + color_matrix_translation;\n  color *= varying_color_scale;\n  // Premultiply alpha\n  color.rgb *= color.a;\n#else\n  vec4 s = varying_color_scale;\n  color *= vec4(s.r, s.g, s.b, 1.0) * s.a;\n#endif\n\n  color = min(color, color.a);\n\n  gl_FragColor = color;\n\n#endif\n\n}\n";
		_ref = replaces;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			src = strings.Replace(src, k, v, -1);
			_i++;
		}
		defs = sliceType$5.nil;
		if (useColorM) {
			defs = $append(defs, "#define USE_COLOR_MATRIX");
		}
			_1 = filter;
			/* */ if (_1 === (1)) { $s = 4; continue; }
			/* */ if (_1 === (2)) { $s = 5; continue; }
			/* */ if (_1 === (3)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (1)) { */ case 4:
				defs = $append(defs, "#define FILTER_NEAREST");
				$s = 8; continue;
			/* } else if (_1 === (2)) { */ case 5:
				defs = $append(defs, "#define FILTER_LINEAR");
				$s = 8; continue;
			/* } else if (_1 === (3)) { */ case 6:
				defs = $append(defs, "#define FILTER_SCREEN");
				$s = 8; continue;
			/* } else { */ case 7:
				_r$3 = fmt.Sprintf("opengl: invalid filter: %d", new sliceType$4([new driver.Filter(filter)])); /* */ $s = 9; case 9: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				$panic(new $String(_r$3));
			/* } */ case 8:
		case 3:
			_2 = address;
			/* */ if (_2 === (0)) { $s = 11; continue; }
			/* */ if (_2 === (1)) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (_2 === (0)) { */ case 11:
				defs = $append(defs, "#define ADDRESS_CLAMP_TO_ZERO");
				$s = 14; continue;
			/* } else if (_2 === (1)) { */ case 12:
				defs = $append(defs, "#define ADDRESS_REPEAT");
				$s = 14; continue;
			/* } else { */ case 13:
				_r$4 = fmt.Sprintf("opengl: invalid address: %d", new sliceType$4([new driver.Address(address)])); /* */ $s = 15; case 15: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				$panic(new $String(_r$4));
			/* } */ case 14:
		case 10:
		src = strings.Replace(src, "{{.Definitions}}", strings.Join(defs, "\n"), -1);
		$r = checkGLSL(src); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return src;
		/* */ } return; } if ($f === undefined) { $f = { $blk: fragmentShaderStr }; } $f._1 = _1; $f._2 = _2; $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f.address = address; $f.defs = defs; $f.filter = filter; $f.k = k; $f.replaces = replaces; $f.src = src; $f.useColorM = useColorM; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	dataType.prototype.SizeInBytes = function() {
		var _1, _r$1, d, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r$1 = $f._r$1; d = $f.d; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		d = this.$val;
			_1 = d;
			/* */ if (_1 === (short$1)) { $s = 2; continue; }
			/* */ if (_1 === (float$1)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_1 === (short$1)) { */ case 2:
				$s = -1; return 2;
			/* } else if (_1 === (float$1)) { */ case 3:
				$s = -1; return 4;
			/* } else { */ case 4:
				_r$1 = fmt.Sprintf("opengl: invalid data type: %d", new sliceType$4([new dataType(d)])); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$panic(new $String(_r$1));
			/* } */ case 5:
		case 1:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: dataType.prototype.SizeInBytes }; } $f._1 = _1; $f._r$1 = _r$1; $f.d = d; $f.$s = $s; $f.$r = $r; return $f;
	};
	$ptrType(dataType).prototype.SizeInBytes = function() { return new dataType(this.$get()).SizeInBytes(); };
	ptrType$12.methods = [{prop: "bindTexture", name: "bindTexture", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([textureNative], [], false)}, {prop: "bindFramebuffer", name: "bindFramebuffer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([framebufferNative], [], false)}, {prop: "setViewport", name: "setViewport", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([ptrType$10], [], false)}, {prop: "getScreenFramebuffer", name: "getScreenFramebuffer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [framebufferNative], false)}, {prop: "getMaxTextureSize", name: "getMaxTextureSize", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [$Int], false)}, {prop: "hasHighPrecisionFloat", name: "hasHighPrecisionFloat", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [$Bool], false)}, {prop: "ensureGL", name: "ensureGL", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [], false)}, {prop: "reset", name: "reset", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [$error], false)}, {prop: "blendFunc", name: "blendFunc", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([driver.CompositeMode], [], false)}, {prop: "newTexture", name: "newTexture", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([$Int, $Int], [textureNative, $error], false)}, {prop: "bindFramebufferImpl", name: "bindFramebufferImpl", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([framebufferNative], [], false)}, {prop: "framebufferPixels", name: "framebufferPixels", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([ptrType$10, $Int, $Int], [sliceType$2, $error], false)}, {prop: "bindTextureImpl", name: "bindTextureImpl", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([textureNative], [], false)}, {prop: "deleteTexture", name: "deleteTexture", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([textureNative], [], false)}, {prop: "isTexture", name: "isTexture", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([textureNative], [$Bool], false)}, {prop: "texSubImage2D", name: "texSubImage2D", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([textureNative, sliceType$2, $Int, $Int, $Int, $Int], [], false)}, {prop: "newFramebuffer", name: "newFramebuffer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([textureNative], [framebufferNative, $error], false)}, {prop: "setViewportImpl", name: "setViewportImpl", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([$Int, $Int], [], false)}, {prop: "deleteFramebuffer", name: "deleteFramebuffer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([framebufferNative], [], false)}, {prop: "newShader", name: "newShader", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([shaderType, $String], [shader, $error], false)}, {prop: "deleteShader", name: "deleteShader", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([shader], [], false)}, {prop: "newProgram", name: "newProgram", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([sliceType$9, sliceType$5], [program, $error], false)}, {prop: "useProgram", name: "useProgram", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([program], [], false)}, {prop: "deleteProgram", name: "deleteProgram", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([program], [], false)}, {prop: "getUniformLocationImpl", name: "getUniformLocationImpl", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([program, $String], [uniformLocation], false)}, {prop: "uniformInt", name: "uniformInt", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([program, $String, $Int], [], false)}, {prop: "uniformFloat", name: "uniformFloat", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([program, $String, $Float32], [], false)}, {prop: "uniformFloats", name: "uniformFloats", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([program, $String, sliceType], [], false)}, {prop: "vertexAttribPointer", name: "vertexAttribPointer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([program, $Int, $Int, dataType, $Int, $Int], [], false)}, {prop: "enableVertexAttribArray", name: "enableVertexAttribArray", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([program, $Int], [], false)}, {prop: "disableVertexAttribArray", name: "disableVertexAttribArray", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([program, $Int], [], false)}, {prop: "newArrayBuffer", name: "newArrayBuffer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([$Int], [buffer], false)}, {prop: "newElementArrayBuffer", name: "newElementArrayBuffer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([$Int], [buffer], false)}, {prop: "bindBuffer", name: "bindBuffer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([bufferType, buffer], [], false)}, {prop: "arrayBufferSubData", name: "arrayBufferSubData", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([sliceType], [], false)}, {prop: "elementArrayBufferSubData", name: "elementArrayBufferSubData", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([sliceType$3], [], false)}, {prop: "deleteBuffer", name: "deleteBuffer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([buffer], [], false)}, {prop: "drawElements", name: "drawElements", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([$Int, $Int], [], false)}, {prop: "maxTextureSizeImpl", name: "maxTextureSizeImpl", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [$Int], false)}, {prop: "getShaderPrecisionFormatPrecision", name: "getShaderPrecisionFormatPrecision", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [$Int], false)}, {prop: "flush", name: "flush", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [], false)}, {prop: "needsRestoring", name: "needsRestoring", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [$Bool], false)}];
	ptrType$9.methods = [{prop: "SetThread", name: "SetThread", pkg: "", typ: $funcType([ptrType$4], [], false)}, {prop: "Begin", name: "Begin", pkg: "", typ: $funcType([], [], false)}, {prop: "End", name: "End", pkg: "", typ: $funcType([], [], false)}, {prop: "SetWindow", name: "SetWindow", pkg: "", typ: $funcType([$Uintptr], [], false)}, {prop: "checkSize", name: "checkSize", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([$Int, $Int], [], false)}, {prop: "NewImage", name: "NewImage", pkg: "", typ: $funcType([$Int, $Int], [driver.Image, $error], false)}, {prop: "NewScreenFramebufferImage", name: "NewScreenFramebufferImage", pkg: "", typ: $funcType([$Int, $Int], [driver.Image, $error], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [$error], false)}, {prop: "SetVertices", name: "SetVertices", pkg: "", typ: $funcType([sliceType, sliceType$3], [], false)}, {prop: "Draw", name: "Draw", pkg: "", typ: $funcType([$Int, $Int, driver.CompositeMode, ptrType$11, driver.Filter, driver.Address], [$error], false)}, {prop: "Flush", name: "Flush", pkg: "", typ: $funcType([], [], false)}, {prop: "SetVsyncEnabled", name: "SetVsyncEnabled", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "VDirection", name: "VDirection", pkg: "", typ: $funcType([], [driver.VDirection], false)}, {prop: "NeedsRestoring", name: "NeedsRestoring", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "IsGL", name: "IsGL", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "HasHighPrecisionFloat", name: "HasHighPrecisionFloat", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "MaxImageSize", name: "MaxImageSize", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "useProgram", name: "useProgram", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([driver.CompositeMode, ptrType$11, driver.Filter, driver.Address], [$error], false)}];
	ptrType$10.methods = [{prop: "delete$", name: "delete", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([ptrType$12], [], false)}];
	ptrType$2.methods = [{prop: "IsInvalidated", name: "IsInvalidated", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Dispose", name: "Dispose", pkg: "", typ: $funcType([], [], false)}, {prop: "SetAsDestination", name: "SetAsDestination", pkg: "", typ: $funcType([], [], false)}, {prop: "setViewport", name: "setViewport", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [$error], false)}, {prop: "Pixels", name: "Pixels", pkg: "", typ: $funcType([], [sliceType$2, $error], false)}, {prop: "ensureFramebuffer", name: "ensureFramebuffer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [$error], false)}, {prop: "ReplacePixels", name: "ReplacePixels", pkg: "", typ: $funcType([sliceType$2, $Int, $Int, $Int, $Int], [], false)}, {prop: "SetAsSource", name: "SetAsSource", pkg: "", typ: $funcType([], [], false)}];
	ptrType$3.methods = [{prop: "GetUniformLocation", name: "GetUniformLocation", pkg: "", typ: $funcType([ptrType$12, program, $String], [uniformLocation], false)}];
	ptrType$14.methods = [{prop: "names", name: "names", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [sliceType$5], false)}, {prop: "totalBytes", name: "totalBytes", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([], [$Int], false)}, {prop: "newArrayBuffer", name: "newArrayBuffer", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([ptrType$12], [buffer], false)}, {prop: "enable", name: "enable", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([ptrType$12, program], [], false)}, {prop: "disable", name: "disable", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([ptrType$12, program], [], false)}];
	ptrType$15.methods = [{prop: "reset", name: "reset", pkg: "github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", typ: $funcType([ptrType$12], [$error], false)}];
	dataType.methods = [{prop: "SizeInBytes", name: "SizeInBytes", pkg: "", typ: $funcType([], [$Int], false)}];
	context.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "locationCache", name: "locationCache", embedded: false, exported: false, typ: ptrType$3, tag: ""}, {prop: "screenFramebuffer", name: "screenFramebuffer", embedded: false, exported: false, typ: framebufferNative, tag: ""}, {prop: "lastFramebuffer", name: "lastFramebuffer", embedded: false, exported: false, typ: framebufferNative, tag: ""}, {prop: "lastTexture", name: "lastTexture", embedded: false, exported: false, typ: textureNative, tag: ""}, {prop: "lastViewportWidth", name: "lastViewportWidth", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lastViewportHeight", name: "lastViewportHeight", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lastCompositeMode", name: "lastCompositeMode", embedded: false, exported: false, typ: driver.CompositeMode, tag: ""}, {prop: "maxTextureSize", name: "maxTextureSize", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "maxTextureSizeOnce", name: "maxTextureSizeOnce", embedded: false, exported: false, typ: sync.Once, tag: ""}, {prop: "highp", name: "highp", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "highpOnce", name: "highpOnce", embedded: false, exported: false, typ: sync.Once, tag: ""}, {prop: "t", name: "t", embedded: false, exported: false, typ: ptrType$4, tag: ""}, {prop: "contextImpl", name: "contextImpl", embedded: true, exported: false, typ: contextImpl, tag: ""}]);
	textureNative.init("syscall/js", [{prop: "v", name: "v", embedded: false, exported: false, typ: ptrType$13, tag: ""}, {prop: "inited", name: "inited", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	framebufferNative.init("syscall/js", [{prop: "v", name: "v", embedded: false, exported: false, typ: ptrType$13, tag: ""}, {prop: "inited", name: "inited", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	shader.init("syscall/js", [{prop: "v", name: "v", embedded: false, exported: false, typ: ptrType$13, tag: ""}, {prop: "inited", name: "inited", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	buffer.init("syscall/js", [{prop: "v", name: "v", embedded: false, exported: false, typ: ptrType$13, tag: ""}, {prop: "inited", name: "inited", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	uniformLocation.init("syscall/js", [{prop: "v", name: "v", embedded: false, exported: false, typ: ptrType$13, tag: ""}, {prop: "inited", name: "inited", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	program.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "value", name: "value", embedded: false, exported: false, typ: js.Value, tag: ""}, {prop: "id", name: "id", embedded: false, exported: false, typ: programID, tag: ""}]);
	contextImpl.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "gl", name: "gl", embedded: false, exported: false, typ: js.Value, tag: ""}, {prop: "lastProgramID", name: "lastProgramID", embedded: false, exported: false, typ: programID, tag: ""}]);
	Driver.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "state", name: "state", embedded: false, exported: false, typ: openGLState, tag: ""}, {prop: "context", name: "context", embedded: false, exported: false, typ: context, tag: ""}]);
	framebuffer.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "driver", name: "driver", embedded: false, exported: false, typ: ptrType$9, tag: ""}, {prop: "native$1", name: "native", embedded: false, exported: false, typ: framebufferNative, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}]);
	Image.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "driver", name: "driver", embedded: false, exported: false, typ: ptrType$9, tag: ""}, {prop: "textureNative", name: "textureNative", embedded: false, exported: false, typ: textureNative, tag: ""}, {prop: "framebuffer", name: "framebuffer", embedded: false, exported: false, typ: ptrType$10, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "screen", name: "screen", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	locationCache.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "uniformLocationCache", name: "uniformLocationCache", embedded: false, exported: false, typ: mapType$1, tag: ""}]);
	arrayBufferLayoutPart.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "name", name: "name", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "num", name: "num", embedded: false, exported: false, typ: $Int, tag: ""}]);
	arrayBufferLayout.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "parts", name: "parts", embedded: false, exported: false, typ: sliceType$1, tag: ""}, {prop: "total", name: "total", embedded: false, exported: false, typ: $Int, tag: ""}]);
	programKey.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "useColorM", name: "useColorM", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "filter", name: "filter", embedded: false, exported: false, typ: driver.Filter, tag: ""}, {prop: "address", name: "address", embedded: false, exported: false, typ: driver.Address, tag: ""}]);
	openGLState.init("github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl", [{prop: "arrayBuffer", name: "arrayBuffer", embedded: false, exported: false, typ: buffer, tag: ""}, {prop: "elementArrayBuffer", name: "elementArrayBuffer", embedded: false, exported: false, typ: buffer, tag: ""}, {prop: "programs", name: "programs", embedded: false, exported: false, typ: mapType$2, tag: ""}, {prop: "lastProgram", name: "lastProgram", embedded: false, exported: false, typ: program, tag: ""}, {prop: "lastViewportWidth", name: "lastViewportWidth", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lastViewportHeight", name: "lastViewportHeight", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lastColorMatrix", name: "lastColorMatrix", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "lastColorMatrixTranslation", name: "lastColorMatrixTranslation", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "lastSourceWidth", name: "lastSourceWidth", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lastSourceHeight", name: "lastSourceHeight", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lastFilter", name: "lastFilter", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "lastAddress", name: "lastAddress", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "source", name: "source", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "destination", name: "destination", embedded: false, exported: false, typ: ptrType$2, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = affine.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = driver.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = graphics.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = jsutil.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = thread.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = web.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = reflect.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = regexp.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		theDriver = new Driver.ptr(new openGLState.ptr(new buffer.ptr(null, false), new buffer.ptr(null, false), false, new program.ptr(new js.Value.ptr(null, false), 0), 0, 0, sliceType.nil, sliceType.nil, 0, 0, ptrType.nil, ptrType$1.nil, ptrType$2.nil, ptrType$2.nil), new context.ptr(ptrType$3.nil, new framebufferNative.ptr(null, false), new framebufferNative.ptr(null, false), new textureNative.ptr(null, false), 0, 0, 0, 0, new sync.Once.ptr(new sync.Mutex.ptr(0, 0), 0), false, new sync.Once.ptr(new sync.Mutex.ptr(0, 0), 0), ptrType$4.nil, new contextImpl.ptr(new js.Value.ptr(null, false), 0)));
		zeroBuffer = new buffer.ptr(null, false);
		zeroProgram = new program.ptr(new js.Value.ptr(null, false), 0);
		$pkg.InvalidTexture = $clone(($clone(js.Null(), textureNative)), textureNative);
		contextPrototype = $clone($clone($clone(js.Global(), js.Value).Get("WebGLRenderingContext"), js.Value).Get("prototype"), js.Value);
		vertexShader = (($clone($clone(contextPrototype, js.Value).Get("VERTEX_SHADER"), js.Value).Int() >> 0));
		fragmentShader = (($clone($clone(contextPrototype, js.Value).Get("FRAGMENT_SHADER"), js.Value).Int() >> 0));
		arrayBuffer = (($clone($clone(contextPrototype, js.Value).Get("ARRAY_BUFFER"), js.Value).Int() >> 0));
		elementArrayBuffer = (($clone($clone(contextPrototype, js.Value).Get("ELEMENT_ARRAY_BUFFER"), js.Value).Int() >> 0));
		dynamicDraw = (($clone($clone(contextPrototype, js.Value).Get("DYNAMIC_DRAW"), js.Value).Int() >> 0));
		short$1 = (($clone($clone(contextPrototype, js.Value).Get("SHORT"), js.Value).Int() >> 0));
		float$1 = (($clone($clone(contextPrototype, js.Value).Get("FLOAT"), js.Value).Int() >> 0));
		zero = (($clone($clone(contextPrototype, js.Value).Get("ZERO"), js.Value).Int() >> 0));
		one = (($clone($clone(contextPrototype, js.Value).Get("ONE"), js.Value).Int() >> 0));
		srcAlpha = (($clone($clone(contextPrototype, js.Value).Get("SRC_ALPHA"), js.Value).Int() >> 0));
		dstAlpha = (($clone($clone(contextPrototype, js.Value).Get("DST_ALPHA"), js.Value).Int() >> 0));
		oneMinusSrcAlpha = (($clone($clone(contextPrototype, js.Value).Get("ONE_MINUS_SRC_ALPHA"), js.Value).Int() >> 0));
		oneMinusDstAlpha = (($clone($clone(contextPrototype, js.Value).Get("ONE_MINUS_DST_ALPHA"), js.Value).Int() >> 0));
		blend = $clone($clone(contextPrototype, js.Value).Get("BLEND"), js.Value);
		clampToEdge = $clone($clone(contextPrototype, js.Value).Get("CLAMP_TO_EDGE"), js.Value);
		compileStatus = $clone($clone(contextPrototype, js.Value).Get("COMPILE_STATUS"), js.Value);
		colorAttachment0 = $clone($clone(contextPrototype, js.Value).Get("COLOR_ATTACHMENT0"), js.Value);
		framebuffer_ = $clone($clone(contextPrototype, js.Value).Get("FRAMEBUFFER"), js.Value);
		framebufferBinding = $clone($clone(contextPrototype, js.Value).Get("FRAMEBUFFER_BINDING"), js.Value);
		framebufferComplete = $clone($clone(contextPrototype, js.Value).Get("FRAMEBUFFER_COMPLETE"), js.Value);
		highFloat = $clone($clone(contextPrototype, js.Value).Get("HIGH_FLOAT"), js.Value);
		linkStatus = $clone($clone(contextPrototype, js.Value).Get("LINK_STATUS"), js.Value);
		maxTextureSize = $clone($clone(contextPrototype, js.Value).Get("MAX_TEXTURE_SIZE"), js.Value);
		nearest = $clone($clone(contextPrototype, js.Value).Get("NEAREST"), js.Value);
		noError = $clone($clone(contextPrototype, js.Value).Get("NO_ERROR"), js.Value);
		rgba = $clone($clone(contextPrototype, js.Value).Get("RGBA"), js.Value);
		texture2d = $clone($clone(contextPrototype, js.Value).Get("TEXTURE_2D"), js.Value);
		textureMagFilter = $clone($clone(contextPrototype, js.Value).Get("TEXTURE_MAG_FILTER"), js.Value);
		textureMinFilter = $clone($clone(contextPrototype, js.Value).Get("TEXTURE_MIN_FILTER"), js.Value);
		textureWrapS = $clone($clone(contextPrototype, js.Value).Get("TEXTURE_WRAP_S"), js.Value);
		textureWrapT = $clone($clone(contextPrototype, js.Value).Get("TEXTURE_WRAP_T"), js.Value);
		triangles = $clone($clone(contextPrototype, js.Value).Get("TRIANGLES"), js.Value);
		unpackAlignment = $clone($clone(contextPrototype, js.Value).Get("UNPACK_ALIGNMENT"), js.Value);
		unsignedByte = $clone($clone(contextPrototype, js.Value).Get("UNSIGNED_BYTE"), js.Value);
		unsignedShort = $clone($clone(contextPrototype, js.Value).Get("UNSIGNED_SHORT"), js.Value);
		theArrayBufferLayout = new arrayBufferLayout.ptr(new sliceType$1([new arrayBufferLayoutPart.ptr("vertex", 2), new arrayBufferLayoutPart.ptr("tex", 2), new arrayBufferLayoutPart.ptr("tex_region", 4), new arrayBufferLayoutPart.ptr("color_scale", 4)]), 0);
		glslReservedKeywords = $makeMap($String.keyFor, [{ k: "common", v: new structType.ptr() }, { k: "partition", v: new structType.ptr() }, { k: "active", v: new structType.ptr() }, { k: "asm", v: new structType.ptr() }, { k: "class", v: new structType.ptr() }, { k: "union", v: new structType.ptr() }, { k: "enum", v: new structType.ptr() }, { k: "typedef", v: new structType.ptr() }, { k: "template", v: new structType.ptr() }, { k: "this", v: new structType.ptr() }, { k: "resource", v: new structType.ptr() }, { k: "goto", v: new structType.ptr() }, { k: "inline", v: new structType.ptr() }, { k: "noinline", v: new structType.ptr() }, { k: "public", v: new structType.ptr() }, { k: "static", v: new structType.ptr() }, { k: "extern", v: new structType.ptr() }, { k: "external", v: new structType.ptr() }, { k: "interface", v: new structType.ptr() }, { k: "long", v: new structType.ptr() }, { k: "short", v: new structType.ptr() }, { k: "half", v: new structType.ptr() }, { k: "fixed", v: new structType.ptr() }, { k: "unsigned", v: new structType.ptr() }, { k: "superp", v: new structType.ptr() }, { k: "input", v: new structType.ptr() }, { k: "output", v: new structType.ptr() }, { k: "hvec2", v: new structType.ptr() }, { k: "hvec3", v: new structType.ptr() }, { k: "hvec4", v: new structType.ptr() }, { k: "fvec2", v: new structType.ptr() }, { k: "fvec3", v: new structType.ptr() }, { k: "fvec4", v: new structType.ptr() }, { k: "filter", v: new structType.ptr() }, { k: "sizeof", v: new structType.ptr() }, { k: "cast", v: new structType.ptr() }, { k: "namespace", v: new structType.ptr() }, { k: "using", v: new structType.ptr() }, { k: "sampler3DRect", v: new structType.ptr() }]);
		_r = regexp.MustCompile("[_a-zA-Z][_a-zA-Z0-9]*"); /* */ $s = 14; case 14: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		glslIdentifier = _r;
		$r = init(); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/hooks"] = (function() {
	var $pkg = {}, $init, sync, funcType, sliceType, m, onBeforeUpdateHooks, audioSuspended, onSuspendAudio, onResumeAudio, AppendHookOnBeforeUpdate, RunBeforeUpdateHooks, SuspendAudio, ResumeAudio;
	sync = $packages["sync"];
	funcType = $funcType([], [$error], false);
	sliceType = $sliceType(funcType);
	AppendHookOnBeforeUpdate = function(f) {
		var f, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; f = $f.f; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = m.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		onBeforeUpdateHooks = $append(onBeforeUpdateHooks, f);
		$r = m.Unlock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: AppendHookOnBeforeUpdate }; } $f.f = f; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.AppendHookOnBeforeUpdate = AppendHookOnBeforeUpdate;
	RunBeforeUpdateHooks = function() {
		var _i, _r, _ref, err, f, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; err = $f.err; f = $f.f; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = m.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(m, "Unlock"), []]);
		_ref = onBeforeUpdateHooks;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			f = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r = f(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			err = _r;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			_i++;
		/* } */ $s = 2; continue; case 3:
		$s = -1; return $ifaceNil;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: RunBeforeUpdateHooks }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.err = err; $f.f = f; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.RunBeforeUpdateHooks = RunBeforeUpdateHooks;
	SuspendAudio = function() {
		var $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = m.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(m, "Unlock"), []]);
		if (audioSuspended) {
			$s = -1; return;
		}
		audioSuspended = true;
		/* */ if (!(onSuspendAudio === $throwNilPointerError)) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!(onSuspendAudio === $throwNilPointerError)) { */ case 2:
			$r = onSuspendAudio(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: SuspendAudio }; } $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.SuspendAudio = SuspendAudio;
	ResumeAudio = function() {
		var $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = m.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(m, "Unlock"), []]);
		if (!audioSuspended) {
			$s = -1; return;
		}
		audioSuspended = false;
		/* */ if (!(onResumeAudio === $throwNilPointerError)) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!(onResumeAudio === $throwNilPointerError)) { */ case 2:
			$r = onResumeAudio(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: ResumeAudio }; } $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.ResumeAudio = ResumeAudio;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = sync.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		m = new sync.Mutex.ptr(0, 0);
		audioSuspended = false;
		onSuspendAudio = $throwNilPointerError;
		onResumeAudio = $throwNilPointerError;
		onBeforeUpdateHooks = new sliceType([]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/packing"] = (function() {
	var $pkg = {}, $init, errors, Page, Node, ptrType, sliceType, ptrType$1, NewPage, square, walk;
	errors = $packages["errors"];
	Page = $pkg.Page = $newType(0, $kindStruct, "packing.Page", true, "github.com/hajimehoshi/ebiten/internal/packing", true, function(root_, size_, maxSize_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.root = ptrType.nil;
			this.size = 0;
			this.maxSize = 0;
			return;
		}
		this.root = root_;
		this.size = size_;
		this.maxSize = maxSize_;
	});
	Node = $pkg.Node = $newType(0, $kindStruct, "packing.Node", true, "github.com/hajimehoshi/ebiten/internal/packing", true, function(x_, y_, width_, height_, used_, parent_, child0_, child1_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.x = 0;
			this.y = 0;
			this.width = 0;
			this.height = 0;
			this.used = false;
			this.parent = ptrType.nil;
			this.child0 = ptrType.nil;
			this.child1 = ptrType.nil;
			return;
		}
		this.x = x_;
		this.y = y_;
		this.width = width_;
		this.height = height_;
		this.used = used_;
		this.parent = parent_;
		this.child0 = child0_;
		this.child1 = child1_;
	});
	ptrType = $ptrType(Node);
	sliceType = $sliceType(ptrType);
	ptrType$1 = $ptrType(Page);
	NewPage = function(initSize, maxSize) {
		var initSize, maxSize;
		return new Page.ptr(ptrType.nil, initSize, maxSize);
	};
	$pkg.NewPage = NewPage;
	Page.ptr.prototype.IsEmpty = function() {
		var p;
		p = this;
		if (p.root === ptrType.nil) {
			return true;
		}
		return !p.root.used && p.root.child0 === ptrType.nil && p.root.child1 === ptrType.nil;
	};
	Page.prototype.IsEmpty = function() { return this.$val.IsEmpty(); };
	Node.ptr.prototype.canFree = function() {
		var n;
		n = this;
		if (n.used) {
			return false;
		}
		if (n.child0 === ptrType.nil && n.child1 === ptrType.nil) {
			return true;
		}
		return n.child0.canFree() && n.child1.canFree();
	};
	Node.prototype.canFree = function() { return this.$val.canFree(); };
	Node.ptr.prototype.Region = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, height, n, width, x, y;
		x = 0;
		y = 0;
		width = 0;
		height = 0;
		n = this;
		_tmp = n.x;
		_tmp$1 = n.y;
		_tmp$2 = n.width;
		_tmp$3 = n.height;
		x = _tmp;
		y = _tmp$1;
		width = _tmp$2;
		height = _tmp$3;
		return [x, y, width, height];
	};
	Node.prototype.Region = function() { return this.$val.Region(); };
	square = function(width, height) {
		var height, width;
		if ((width === 0) && (height === 0)) {
			return 0;
		}
		if (width <= height) {
			return (width) / (height);
		}
		return (height) / (width);
	};
	Page.ptr.prototype.alloc = function(n, width, height) {
		var height, n, node, node$1, p, width;
		p = this;
		if (n.width < width || n.height < height) {
			return ptrType.nil;
		}
		if (n.used) {
			return ptrType.nil;
		}
		if (n.child0 === ptrType.nil && n.child1 === ptrType.nil) {
			if ((n.width === width) && (n.height === height)) {
				n.used = true;
				return n;
			}
			if (square(n.width - width >> 0, n.height) >= square(n.width, n.height - height >> 0)) {
				n.child0 = new Node.ptr(n.x, n.y, width, n.height, false, n, ptrType.nil, ptrType.nil);
				n.child1 = new Node.ptr(n.x + width >> 0, n.y, n.width - width >> 0, n.height, false, n, ptrType.nil, ptrType.nil);
			} else {
				n.child0 = new Node.ptr(n.x, n.y, n.width, height, false, n, ptrType.nil, ptrType.nil);
				n.child1 = new Node.ptr(n.x, n.y + height >> 0, n.width, n.height - height >> 0, false, n, ptrType.nil, ptrType.nil);
			}
			return p.alloc(n.child0, width, height);
		}
		if (n.child0 === ptrType.nil || n.child1 === ptrType.nil) {
			$panic(new $String("packing: both two children must not be nil at alloc"));
		}
		node = p.alloc(n.child0, width, height);
		if (!(node === ptrType.nil)) {
			return node;
		}
		node$1 = p.alloc(n.child1, width, height);
		if (!(node$1 === ptrType.nil)) {
			return node$1;
		}
		return ptrType.nil;
	};
	Page.prototype.alloc = function(n, width, height) { return this.$val.alloc(n, width, height); };
	Page.ptr.prototype.Size = function() {
		var p;
		p = this;
		return p.size;
	};
	Page.prototype.Size = function() { return this.$val.Size(); };
	Page.ptr.prototype.SetMaxSize = function(size) {
		var p, size;
		p = this;
		if (p.maxSize > size) {
			$panic(new $String("packing: maxSize cannot be decreased"));
		}
		p.maxSize = size;
	};
	Page.prototype.SetMaxSize = function(size) { return this.$val.SetMaxSize(size); };
	Page.ptr.prototype.Alloc = function(width, height) {
		var height, n, p, width;
		p = this;
		if (width <= 0 || height <= 0) {
			$panic(new $String("packing: width and height must > 0"));
		}
		if (p.root === ptrType.nil) {
			p.root = new Node.ptr(0, 0, p.size, p.size, false, ptrType.nil, ptrType.nil, ptrType.nil);
		}
		if (width < 1) {
			width = 1;
		}
		if (height < 1) {
			height = 1;
		}
		n = p.alloc(p.root, width, height);
		return n;
	};
	Page.prototype.Alloc = function(width, height) { return this.$val.Alloc(width, height); };
	Page.ptr.prototype.Free = function(node) {
		var node, p;
		p = this;
		if (!(node.child0 === ptrType.nil) || !(node.child1 === ptrType.nil)) {
			$panic(new $String("packing: can't free the node including children"));
		}
		node.used = false;
		if (node.parent === ptrType.nil) {
			return;
		}
		if (node.parent.child0 === ptrType.nil || node.parent.child1 === ptrType.nil) {
			$panic(new $String("packing: both two children must not be nil at Free: double free happened?"));
		}
		if (node.parent.child0.canFree() && node.parent.child1.canFree()) {
			node.parent.child0 = ptrType.nil;
			node.parent.child1 = ptrType.nil;
			p.Free(node.parent);
		}
	};
	Page.prototype.Free = function(node) { return this.$val.Free(node); };
	walk = function(n, f) {
		var _r, _r$1, _r$2, err, err$1, err$2, f, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = f(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		/* */ if (!(n.child0 === ptrType.nil)) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!(n.child0 === ptrType.nil)) { */ case 2:
			_r$1 = walk(n.child0, f); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			err$1 = _r$1;
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				$s = -1; return err$1;
			}
		/* } */ case 3:
		/* */ if (!(n.child1 === ptrType.nil)) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (!(n.child1 === ptrType.nil)) { */ case 5:
			_r$2 = walk(n.child1, f); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			err$2 = _r$2;
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return err$2;
			}
		/* } */ case 6:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: walk }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Page.ptr.prototype.Extend = function() {
		var _i, _r, _ref, abort, aborted, edgeNodes, left, leftLower, leftUpper, n, newSize, p, right, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; abort = $f.abort; aborted = $f.aborted; edgeNodes = $f.edgeNodes; left = $f.left; leftLower = $f.leftLower; leftUpper = $f.leftUpper; n = $f.n; newSize = $f.newSize; p = $f.p; right = $f.right; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		abort = [abort];
		aborted = [aborted];
		edgeNodes = [edgeNodes];
		p = [p];
		p[0] = this;
		if (p[0].size >= p[0].maxSize) {
			$s = -1; return false;
		}
		newSize = $imul(p[0].size, 2);
		edgeNodes[0] = new sliceType([]);
		abort[0] = errors.New("abort");
		aborted[0] = false;
		_r = walk(p[0].root, (function(abort, aborted, edgeNodes, p) { return function(n) {
			var n;
			if ((n.x + n.width >> 0) < p[0].size && (n.y + n.height >> 0) < p[0].size) {
				return $ifaceNil;
			}
			if (n.used) {
				aborted[0] = true;
				return abort[0];
			}
			edgeNodes[0] = $append(edgeNodes[0], n);
			return $ifaceNil;
		}; })(abort, aborted, edgeNodes, p)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$unused(_r);
		if (aborted[0]) {
			leftUpper = p[0].root;
			leftLower = new Node.ptr(0, p[0].size, p[0].size, newSize - p[0].size >> 0, false, ptrType.nil, ptrType.nil, ptrType.nil);
			left = new Node.ptr(0, 0, p[0].size, p[0].size, false, ptrType.nil, leftUpper, leftLower);
			leftUpper.parent = left;
			leftLower.parent = left;
			right = new Node.ptr(p[0].size, 0, newSize - p[0].size >> 0, newSize, false, ptrType.nil, ptrType.nil, ptrType.nil);
			p[0].root = new Node.ptr(0, 0, newSize, newSize, false, ptrType.nil, left, right);
			left.parent = p[0].root;
			right.parent = p[0].root;
		} else {
			_ref = edgeNodes[0];
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				n = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if ((n.x + n.width >> 0) === p[0].size) {
					n.width = n.width + ((newSize - p[0].size >> 0)) >> 0;
				}
				if ((n.y + n.height >> 0) === p[0].size) {
					n.height = n.height + ((newSize - p[0].size >> 0)) >> 0;
				}
				_i++;
			}
		}
		p[0].size = newSize;
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Page.ptr.prototype.Extend }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.abort = abort; $f.aborted = aborted; $f.edgeNodes = edgeNodes; $f.left = left; $f.leftLower = leftLower; $f.leftUpper = leftUpper; $f.n = n; $f.newSize = newSize; $f.p = p; $f.right = right; $f.$s = $s; $f.$r = $r; return $f;
	};
	Page.prototype.Extend = function() { return this.$val.Extend(); };
	Node.ptr.prototype.clone = function() {
		var cloned, n;
		n = this;
		if (n === ptrType.nil) {
			return ptrType.nil;
		}
		cloned = new Node.ptr(n.x, n.y, n.width, n.height, n.used, ptrType.nil, n.child0.clone(), n.child1.clone());
		if (!(cloned.child0 === ptrType.nil)) {
			cloned.child0.parent = cloned;
		}
		if (!(cloned.child1 === ptrType.nil)) {
			cloned.child1.parent = cloned;
		}
		return cloned;
	};
	Node.prototype.clone = function() { return this.$val.clone(); };
	Page.ptr.prototype.Clone = function() {
		var p;
		p = this;
		return new Page.ptr(p.root.clone(), p.size, p.maxSize);
	};
	Page.prototype.Clone = function() { return this.$val.Clone(); };
	ptrType$1.methods = [{prop: "IsEmpty", name: "IsEmpty", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "alloc", name: "alloc", pkg: "github.com/hajimehoshi/ebiten/internal/packing", typ: $funcType([ptrType, $Int, $Int], [ptrType], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "SetMaxSize", name: "SetMaxSize", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Alloc", name: "Alloc", pkg: "", typ: $funcType([$Int, $Int], [ptrType], false)}, {prop: "Free", name: "Free", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "Extend", name: "Extend", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Clone", name: "Clone", pkg: "", typ: $funcType([], [ptrType$1], false)}];
	ptrType.methods = [{prop: "canFree", name: "canFree", pkg: "github.com/hajimehoshi/ebiten/internal/packing", typ: $funcType([], [$Bool], false)}, {prop: "Region", name: "Region", pkg: "", typ: $funcType([], [$Int, $Int, $Int, $Int], false)}, {prop: "clone", name: "clone", pkg: "github.com/hajimehoshi/ebiten/internal/packing", typ: $funcType([], [ptrType], false)}];
	Page.init("github.com/hajimehoshi/ebiten/internal/packing", [{prop: "root", name: "root", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "size", name: "size", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "maxSize", name: "maxSize", embedded: false, exported: false, typ: $Int, tag: ""}]);
	Node.init("github.com/hajimehoshi/ebiten/internal/packing", [{prop: "x", name: "x", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "y", name: "y", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "used", name: "used", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "parent", name: "parent", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "child0", name: "child0", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "child1", name: "child1", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/restorable"] = (function() {
	var $pkg = {}, $init, errors, fmt, affine, driver, graphics, graphicscommand, image, color, Pixels, drawTrianglesHistoryItem, Image, images, edge, ptrType, sliceType, sliceType$1, ptrType$1, ptrType$2, ptrType$3, sliceType$2, sliceType$3, ptrType$4, sliceType$4, structType, sliceType$6, sliceType$7, mapType, ptrType$5, emptyImage, forceRestoring, theImages, init, NewImage, NewScreenFramebufferImage, needsRestoring, ResolveStaleImages, RestoreIfNeeded, InitializeGraphicsDriverState, Error;
	errors = $packages["errors"];
	fmt = $packages["fmt"];
	affine = $packages["github.com/hajimehoshi/ebiten/internal/affine"];
	driver = $packages["github.com/hajimehoshi/ebiten/internal/driver"];
	graphics = $packages["github.com/hajimehoshi/ebiten/internal/graphics"];
	graphicscommand = $packages["github.com/hajimehoshi/ebiten/internal/graphicscommand"];
	image = $packages["image"];
	color = $packages["image/color"];
	Pixels = $pkg.Pixels = $newType(0, $kindStruct, "restorable.Pixels", true, "github.com/hajimehoshi/ebiten/internal/restorable", true, function(pixels_, length_, color_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.pixels = sliceType.nil;
			this.length = 0;
			this.color = new color.RGBA.ptr(0, 0, 0, 0);
			return;
		}
		this.pixels = pixels_;
		this.length = length_;
		this.color = color_;
	});
	drawTrianglesHistoryItem = $pkg.drawTrianglesHistoryItem = $newType(0, $kindStruct, "restorable.drawTrianglesHistoryItem", true, "github.com/hajimehoshi/ebiten/internal/restorable", false, function(image_, vertices_, indices_, colorm_, mode_, filter_, address_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.image = ptrType.nil;
			this.vertices = sliceType$3.nil;
			this.indices = sliceType$4.nil;
			this.colorm = ptrType$4.nil;
			this.mode = 0;
			this.filter = 0;
			this.address = 0;
			return;
		}
		this.image = image_;
		this.vertices = vertices_;
		this.indices = indices_;
		this.colorm = colorm_;
		this.mode = mode_;
		this.filter = filter_;
		this.address = address_;
	});
	Image = $pkg.Image = $newType(0, $kindStruct, "restorable.Image", true, "github.com/hajimehoshi/ebiten/internal/restorable", true, function(image_, basePixels_, drawTrianglesHistory_, stale_, volatile$4_, screen_, priority_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.image = ptrType$1.nil;
			this.basePixels = ptrType$2.nil;
			this.drawTrianglesHistory = sliceType$2.nil;
			this.stale = false;
			this.volatile$4 = false;
			this.screen = false;
			this.priority = false;
			return;
		}
		this.image = image_;
		this.basePixels = basePixels_;
		this.drawTrianglesHistory = drawTrianglesHistory_;
		this.stale = stale_;
		this.volatile$4 = volatile$4_;
		this.screen = screen_;
		this.priority = priority_;
	});
	images = $pkg.images = $newType(0, $kindStruct, "restorable.images", true, "github.com/hajimehoshi/ebiten/internal/restorable", false, function(images_, lastTarget_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.images = false;
			this.lastTarget = ptrType.nil;
			return;
		}
		this.images = images_;
		this.lastTarget = lastTarget_;
	});
	edge = $newType(0, $kindStruct, "restorable.edge", true, "github.com/hajimehoshi/ebiten/internal/restorable", false, function(source_, target_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.source = ptrType.nil;
			this.target = ptrType.nil;
			return;
		}
		this.source = source_;
		this.target = target_;
	});
	ptrType = $ptrType(Image);
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType($emptyInterface);
	ptrType$1 = $ptrType(graphicscommand.Image);
	ptrType$2 = $ptrType(Pixels);
	ptrType$3 = $ptrType(drawTrianglesHistoryItem);
	sliceType$2 = $sliceType(ptrType$3);
	sliceType$3 = $sliceType($Float32);
	ptrType$4 = $ptrType(affine.ColorM);
	sliceType$4 = $sliceType($Uint16);
	structType = $structType("", []);
	sliceType$6 = $sliceType(ptrType);
	sliceType$7 = $sliceType(edge);
	mapType = $mapType(ptrType, structType);
	ptrType$5 = $ptrType(images);
	Pixels.ptr.prototype.ensurePixels = function() {
		var _q, i, p, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7;
		p = this;
		if (!(p.pixels === sliceType.nil)) {
			return;
		}
		p.pixels = $makeSlice(sliceType, p.length);
		if (p.color.A === 0) {
			return;
		}
		i = 0;
		while (true) {
			if (!(i < (_q = p.length / 4, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")))) { break; }
			(x = p.pixels, x$1 = $imul(4, i), ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1] = p.color.R));
			(x$2 = p.pixels, x$3 = ($imul(4, i)) + 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3] = p.color.G));
			(x$4 = p.pixels, x$5 = ($imul(4, i)) + 2 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5] = p.color.B));
			(x$6 = p.pixels, x$7 = ($imul(4, i)) + 3 >> 0, ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7] = p.color.A));
			i = i + (1) >> 0;
		}
	};
	Pixels.prototype.ensurePixels = function() { return this.$val.ensurePixels(); };
	Pixels.ptr.prototype.CopyFrom = function(pix, from) {
		var from, p, pix;
		p = this;
		p.ensurePixels();
		$copySlice($subslice(p.pixels, from, (from + pix.$length >> 0)), pix);
	};
	Pixels.prototype.CopyFrom = function(pix, from) { return this.$val.CopyFrom(pix, from); };
	Pixels.ptr.prototype.At = function(i) {
		var _1, _r, _r$1, i, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; i = $f.i; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (i < 0 || p.length <= i) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (i < 0 || p.length <= i) { */ case 1:
			_r = fmt.Sprintf("restorable: index out of range: %d for length: %d", new sliceType$1([new $Int(i), new $Int(p.length)])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$panic(new $String(_r));
		/* } */ case 2:
		if (p.pixels === sliceType.nil) {
			_1 = (_r$1 = i % 4, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"));
			if (_1 === (0)) {
				$s = -1; return p.color.R;
			} else if (_1 === (1)) {
				$s = -1; return p.color.G;
			} else if (_1 === (2)) {
				$s = -1; return p.color.B;
			} else if (_1 === (3)) {
				$s = -1; return p.color.A;
			}
		}
		$s = -1; return (x = p.pixels, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Pixels.ptr.prototype.At }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Pixels.prototype.At = function(i) { return this.$val.At(i); };
	Pixels.ptr.prototype.Slice = function() {
		var p;
		p = this;
		p.ensurePixels();
		return p.pixels;
	};
	Pixels.prototype.Slice = function() { return this.$val.Slice(); };
	init = function() {
		var _i, _ref, i, pix, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _ref = $f._ref; i = $f.i; pix = $f.pix; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		emptyImage = new Image.ptr(graphicscommand.NewImage(16, 16), ptrType$2.nil, sliceType$2.nil, false, false, false, true);
		pix = $makeSlice(sliceType, 1024);
		_ref = pix;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			((i < 0 || i >= pix.$length) ? ($throwRuntimeError("index out of range"), undefined) : pix.$array[pix.$offset + i] = 255);
			_i++;
		}
		$r = emptyImage.ReplacePixels(pix, 0, 0, 16, 16); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		theImages.add(emptyImage);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f._i = _i; $f._ref = _ref; $f.i = i; $f.pix = pix; $f.$s = $s; $f.$r = $r; return $f;
	};
	NewImage = function(width, height) {
		var height, i, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; height = $f.height; i = $f.i; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = new Image.ptr(graphicscommand.NewImage(width, height), ptrType$2.nil, sliceType$2.nil, false, false, false, false);
		$r = i.clearForInitialization(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		theImages.add(i);
		$s = -1; return i;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NewImage }; } $f.height = height; $f.i = i; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.NewImage = NewImage;
	Image.ptr.prototype.MakeVolatile = function() {
		var i;
		i = this;
		i.volatile$4 = true;
	};
	Image.prototype.MakeVolatile = function() { return this.$val.MakeVolatile(); };
	NewScreenFramebufferImage = function(width, height) {
		var height, i, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; height = $f.height; i = $f.i; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = new Image.ptr(graphicscommand.NewScreenFramebufferImage(width, height), ptrType$2.nil, sliceType$2.nil, false, false, true, false);
		$r = i.clearForInitialization(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		theImages.add(i);
		$s = -1; return i;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NewScreenFramebufferImage }; } $f.height = height; $f.i = i; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.NewScreenFramebufferImage = NewScreenFramebufferImage;
	Image.ptr.prototype.Fill = function(r, g, b, a) {
		var a, b, g, i, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; a = $f.a; b = $f.b; g = $f.g; i = $f.i; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		theImages.makeStaleIfDependingOn(i);
		$r = i.fill(r, g, b, a); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.Fill }; } $f.a = a; $f.b = b; $f.g = g; $f.i = i; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.Fill = function(r, g, b, a) { return this.$val.Fill(r, g, b, a); };
	Image.ptr.prototype.clearForInitialization = function() {
		var i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		$r = i.fill(0, 0, 0, 0); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.clearForInitialization }; } $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.clearForInitialization = function() { return this.$val.clearForInitialization(); };
	Image.ptr.prototype.fill = function(r, g, b, a) {
		var _tuple, _tuple$1, _tuple$2, a, af, b, bf, c, dh, dw, g, gf, h, i, is, r, rf, sh, sw, vs, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; a = $f.a; af = $f.af; b = $f.b; bf = $f.bf; c = $f.c; dh = $f.dh; dw = $f.dw; g = $f.g; gf = $f.gf; h = $f.h; i = $f.i; is = $f.is; r = $f.r; rf = $f.rf; sh = $f.sh; sw = $f.sw; vs = $f.vs; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (i.priority) {
			$panic(new $String("restorable: clear cannot be called on a priority image"));
		}
		rf = 0;
		gf = 0;
		bf = 0;
		af = 0;
		if (a > 0) {
			rf = $fround((r) / (a));
			gf = $fround((g) / (a));
			bf = $fround((b) / (a));
			af = $fround((a) / 255);
		}
		_tuple = i.internalSize();
		dw = _tuple[0];
		dh = _tuple[1];
		_tuple$1 = emptyImage.Size();
		sw = _tuple$1[0];
		sh = _tuple$1[1];
		vs = $makeSlice(sliceType$3, 48);
		$r = graphics.PutQuadVertices(vs, i, 0, 0, sw, sh, $fround((dw) / (sw)), 0, 0, $fround((dh) / (sh)), 0, 0, rf, gf, bf, af); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		is = graphics.QuadIndices();
		c = 2;
		if (a === 0) {
			c = 1;
		}
		$r = i.image.DrawTriangles(emptyImage.image, vs, is, ptrType$4.nil, c, 1, 0); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_tuple$2 = i.Size();
		w = _tuple$2[0];
		h = _tuple$2[1];
		i.basePixels = new Pixels.ptr(sliceType.nil, $imul(($imul(4, w)), h), new color.RGBA.ptr(r, g, b, a));
		i.drawTrianglesHistory = sliceType$2.nil;
		i.stale = false;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.fill }; } $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.a = a; $f.af = af; $f.b = b; $f.bf = bf; $f.c = c; $f.dh = dh; $f.dw = dw; $f.g = g; $f.gf = gf; $f.h = h; $f.i = i; $f.is = is; $f.r = r; $f.rf = rf; $f.sh = sh; $f.sw = sw; $f.vs = vs; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.fill = function(r, g, b, a) { return this.$val.fill(r, g, b, a); };
	Image.ptr.prototype.IsVolatile = function() {
		var i;
		i = this;
		return i.volatile$4;
	};
	Image.prototype.IsVolatile = function() { return this.$val.IsVolatile(); };
	Image.ptr.prototype.BasePixelsForTesting = function() {
		var i;
		i = this;
		return i.basePixels;
	};
	Image.prototype.BasePixelsForTesting = function() { return this.$val.BasePixelsForTesting(); };
	Image.ptr.prototype.Size = function() {
		var i;
		i = this;
		return i.image.Size();
	};
	Image.prototype.Size = function() { return this.$val.Size(); };
	Image.ptr.prototype.internalSize = function() {
		var i;
		i = this;
		return i.image.InternalSize();
	};
	Image.prototype.internalSize = function() { return this.$val.internalSize(); };
	Image.ptr.prototype.PutVertex = function(vs, dx, dy, sx, sy, bx0, by0, bx1, by1, cr, cg, cb, ca) {
		var _tuple, bx0, bx1, by0, by1, ca, cb, cg, cr, dx, dy, h, i, sx, sy, vs, w;
		i = this;
		vs = $subslice(vs, 0, 12);
		_tuple = i.internalSize();
		w = _tuple[0];
		h = _tuple[1];
		(0 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 0] = dx);
		(1 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 1] = dy);
		(2 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 2] = $fround(sx / (w)));
		(3 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 3] = $fround(sy / (h)));
		(4 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 4] = $fround(bx0 / (w)));
		(5 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 5] = $fround(by0 / (h)));
		(6 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 6] = $fround(bx1 / (w)));
		(7 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 7] = $fround(by1 / (h)));
		(8 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 8] = cr);
		(9 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 9] = cg);
		(10 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 10] = cb);
		(11 >= vs.$length ? ($throwRuntimeError("index out of range"), undefined) : vs.$array[vs.$offset + 11] = ca);
	};
	Image.prototype.PutVertex = function(vs, dx, dy, sx, sy, bx0, by0, bx1, by1, cr, cg, cb, ca) { return this.$val.PutVertex(vs, dx, dy, sx, sy, bx0, by0, bx1, by1, cr, cg, cb, ca); };
	Image.ptr.prototype.makeStale = function() {
		var i;
		i = this;
		i.basePixels = ptrType$2.nil;
		i.drawTrianglesHistory = sliceType$2.nil;
		i.stale = true;
	};
	Image.prototype.makeStale = function() { return this.$val.makeStale(); };
	Image.ptr.prototype.CopyPixels = function(src) {
		var i, src;
		i = this;
		theImages.makeStaleIfDependingOn(i);
		i.image.CopyPixels(src.image);
		i.makeStale();
	};
	Image.prototype.CopyPixels = function(src) { return this.$val.CopyPixels(src); };
	Image.ptr.prototype.ClearPixels = function(x, y, width, height) {
		var height, i, width, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; height = $f.height; i = $f.i; width = $f.width; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		$r = i.ReplacePixels($makeSlice(sliceType, ($imul(($imul(4, width)), height))), x, y, width, height); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.ClearPixels }; } $f.height = height; $f.i = i; $f.width = width; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.ClearPixels = function(x, y, width, height) { return this.$val.ClearPixels(x, y, width, height); };
	Image.ptr.prototype.ReplacePixels = function(pixels, x, y, width, height) {
		var _r, _r$1, _tuple, h, height, i, idx, j, j$1, pixels, w, width, x, y, zeros, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; h = $f.h; height = $f.height; i = $f.i; idx = $f.idx; j = $f.j; j$1 = $f.j$1; pixels = $f.pixels; w = $f.w; width = $f.width; x = $f.x; y = $f.y; zeros = $f.zeros; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_tuple = i.image.Size();
		w = _tuple[0];
		h = _tuple[1];
		if (width <= 0 || height <= 0) {
			$panic(new $String("restorable: width/height must be positive"));
		}
		/* */ if (x < 0 || y < 0 || w <= x || h <= y || (x + width >> 0) <= 0 || (y + height >> 0) <= 0 || w < (x + width >> 0) || h < (y + height >> 0)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (x < 0 || y < 0 || w <= x || h <= y || (x + width >> 0) <= 0 || (y + height >> 0) <= 0 || w < (x + width >> 0) || h < (y + height >> 0)) { */ case 1:
			_r = fmt.Sprintf("restorable: out of range x: %d, y: %d, width: %d, height: %d", new sliceType$1([new $Int(x), new $Int(y), new $Int(width), new $Int(height)])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$panic(new $String(_r));
		/* } */ case 2:
		theImages.makeStaleIfDependingOn(i);
		if (pixels === sliceType.nil) {
			pixels = $makeSlice(sliceType, ($imul(($imul(4, width)), height)));
		}
		i.image.ReplacePixels(pixels, x, y, width, height);
		_r$1 = needsRestoring(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (!_r$1) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!_r$1) { */ case 4:
			i.makeStale();
			$s = -1; return;
		/* } */ case 5:
		if ((x === 0) && (y === 0) && (width === w) && (height === h)) {
			if (!(pixels === sliceType.nil)) {
				if (i.basePixels === ptrType$2.nil) {
					i.basePixels = new Pixels.ptr(sliceType.nil, $imul(($imul(4, w)), h), new color.RGBA.ptr(0, 0, 0, 0));
				}
				i.basePixels.CopyFrom(pixels, 0);
			} else {
				i.basePixels = ptrType$2.nil;
			}
			i.drawTrianglesHistory = sliceType$2.nil;
			i.stale = false;
			$s = -1; return;
		}
		if (i.drawTrianglesHistory.$length > 0) {
			$panic(new $String("restorable: ReplacePixels for a part after DrawTriangles is forbidden"));
		}
		if (i.stale) {
			$s = -1; return;
		}
		idx = $imul(4, ((($imul(y, w)) + x >> 0)));
		if (!(pixels === sliceType.nil)) {
			if (i.basePixels === ptrType$2.nil) {
				i.basePixels = new Pixels.ptr(sliceType.nil, $imul(($imul(4, w)), h), new color.RGBA.ptr(0, 0, 0, 0));
			}
			j = 0;
			while (true) {
				if (!(j < height)) { break; }
				i.basePixels.CopyFrom($subslice(pixels, ($imul(($imul(4, j)), width)), ($imul(($imul(4, ((j + 1 >> 0)))), width))), idx);
				idx = idx + (($imul(4, w))) >> 0;
				j = j + (1) >> 0;
			}
		} else if (!(i.basePixels === ptrType$2.nil)) {
			zeros = $makeSlice(sliceType, ($imul(4, width)));
			j$1 = 0;
			while (true) {
				if (!(j$1 < height)) { break; }
				i.basePixels.CopyFrom(zeros, idx);
				idx = idx + (($imul(4, w))) >> 0;
				j$1 = j$1 + (1) >> 0;
			}
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.ReplacePixels }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.h = h; $f.height = height; $f.i = i; $f.idx = idx; $f.j = j; $f.j$1 = j$1; $f.pixels = pixels; $f.w = w; $f.width = width; $f.x = x; $f.y = y; $f.zeros = zeros; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.ReplacePixels = function(pixels, x, y, width, height) { return this.$val.ReplacePixels(pixels, x, y, width, height); };
	Image.ptr.prototype.DrawTriangles = function(img, vertices, indices, colorm, mode, filter, address) {
		var _r, _v, address, colorm, filter, i, img, indices, mode, vertices, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _v = $f._v; address = $f.address; colorm = $f.colorm; filter = $f.filter; i = $f.i; img = $f.img; indices = $f.indices; mode = $f.mode; vertices = $f.vertices; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (i.priority) {
			$panic(new $String("restorable: DrawTriangles cannot be called on a priority image"));
		}
		if (vertices.$length === 0) {
			$s = -1; return;
		}
		theImages.makeStaleIfDependingOn(i);
		if (img.stale || img.volatile$4 || i.screen) { _v = true; $s = 4; continue s; }
		_r = needsRestoring(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_v = !_r; case 4:
		/* */ if (_v || i.volatile$4) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_v || i.volatile$4) { */ case 1:
			i.makeStale();
			$s = 3; continue;
		/* } else { */ case 2:
			i.appendDrawTrianglesHistory(img, vertices, indices, colorm, mode, filter, address);
		/* } */ case 3:
		$r = i.image.DrawTriangles(img.image, vertices, indices, colorm, mode, filter, address); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.DrawTriangles }; } $f._r = _r; $f._v = _v; $f.address = address; $f.colorm = colorm; $f.filter = filter; $f.i = i; $f.img = img; $f.indices = indices; $f.mode = mode; $f.vertices = vertices; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.DrawTriangles = function(img, vertices, indices, colorm, mode, filter, address) { return this.$val.DrawTriangles(img, vertices, indices, colorm, mode, filter, address); };
	Image.ptr.prototype.appendDrawTrianglesHistory = function(image$1, vertices, indices, colorm, mode, filter, address) {
		var address, colorm, filter, i, image$1, indices, item, mode, vertices;
		i = this;
		if (i.stale || i.volatile$4 || i.screen) {
			return;
		}
		if ((i.drawTrianglesHistory.$length + 1 >> 0) > 1024) {
			i.makeStale();
			return;
		}
		item = new drawTrianglesHistoryItem.ptr(image$1, vertices, indices, colorm, mode, filter, address);
		i.drawTrianglesHistory = $append(i.drawTrianglesHistory, item);
	};
	Image.prototype.appendDrawTrianglesHistory = function(image$1, vertices, indices, colorm, mode, filter, address) { return this.$val.appendDrawTrianglesHistory(image$1, vertices, indices, colorm, mode, filter, address); };
	Image.ptr.prototype.readPixelsFromGPUIfNeeded = function() {
		var i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		/* */ if (i.basePixels === ptrType$2.nil || i.drawTrianglesHistory.$length > 0 || i.stale) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (i.basePixels === ptrType$2.nil || i.drawTrianglesHistory.$length > 0 || i.stale) { */ case 1:
			$r = graphicscommand.FlushCommands(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = i.readPixelsFromGPU(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i.drawTrianglesHistory = sliceType$2.nil;
			i.stale = false;
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.readPixelsFromGPUIfNeeded }; } $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.readPixelsFromGPUIfNeeded = function() { return this.$val.readPixelsFromGPUIfNeeded(); };
	Image.ptr.prototype.At = function(x, y) {
		var _r, _r$1, _r$2, _r$3, _tuple, h, i, idx, w, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tuple = $f._tuple; h = $f.h; i = $f.i; idx = $f.idx; w = $f.w; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_tuple = i.image.Size();
		w = _tuple[0];
		h = _tuple[1];
		if (x < 0 || y < 0 || w <= x || h <= y) {
			$s = -1; return [0, 0, 0, 0];
		}
		$r = i.readPixelsFromGPUIfNeeded(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (i.basePixels === ptrType$2.nil) {
			$s = -1; return [0, 0, 0, 0];
		}
		idx = ($imul(4, x)) + ($imul(($imul(4, y)), w)) >> 0;
		_r = i.basePixels.At(idx); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = i.basePixels.At(idx + 1 >> 0); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = i.basePixels.At(idx + 2 >> 0); /* */ $s = 4; case 4: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$3 = i.basePixels.At(idx + 3 >> 0); /* */ $s = 5; case 5: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		$s = -1; return [_r, _r$1, _r$2, _r$3];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.At }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tuple = _tuple; $f.h = h; $f.i = i; $f.idx = idx; $f.w = w; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.At = function(x, y) { return this.$val.At(x, y); };
	Image.ptr.prototype.makeStaleIfDependingOn = function(target) {
		var i, target;
		i = this;
		if (i.stale) {
			return;
		}
		if (i.dependsOn(target)) {
			i.makeStale();
		}
	};
	Image.prototype.makeStaleIfDependingOn = function(target) { return this.$val.makeStaleIfDependingOn(target); };
	Image.ptr.prototype.readPixelsFromGPU = function() {
		var _r, i, pix, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; pix = $f.pix; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_r = i.image.Pixels(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		pix = _r;
		i.basePixels = new Pixels.ptr(pix, pix.$length, new color.RGBA.ptr(0, 0, 0, 0));
		i.drawTrianglesHistory = sliceType$2.nil;
		i.stale = false;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.readPixelsFromGPU }; } $f._r = _r; $f.i = i; $f.pix = pix; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.readPixelsFromGPU = function() { return this.$val.readPixelsFromGPU(); };
	Image.ptr.prototype.resolveStale = function() {
		var _r, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_r = needsRestoring(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!_r) { */ case 1:
			$s = -1; return;
		/* } */ case 2:
		if (i.volatile$4) {
			$s = -1; return;
		}
		if (i.screen) {
			$s = -1; return;
		}
		if (!i.stale) {
			$s = -1; return;
		}
		$r = i.readPixelsFromGPU(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.resolveStale }; } $f._r = _r; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.resolveStale = function() { return this.$val.resolveStale(); };
	Image.ptr.prototype.dependsOn = function(target) {
		var _i, _ref, c, i, target;
		i = this;
		_ref = i.drawTrianglesHistory;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (c.image === target) {
				return true;
			}
			_i++;
		}
		return false;
	};
	Image.prototype.dependsOn = function(target) { return this.$val.dependsOn(target); };
	Image.ptr.prototype.dependingImages = function() {
		var _i, _key, _ref, c, i, r;
		i = this;
		r = $makeMap(ptrType.keyFor, []);
		_ref = i.drawTrianglesHistory;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_key = c.image; (r || $throwRuntimeError("assignment to entry in nil map"))[ptrType.keyFor(_key)] = { k: _key, v: new structType.ptr() };
			_i++;
		}
		return r;
	};
	Image.prototype.dependingImages = function() { return this.$val.dependingImages(); };
	Image.ptr.prototype.hasDependency = function() {
		var i;
		i = this;
		if (i.stale) {
			return false;
		}
		return i.drawTrianglesHistory.$length > 0;
	};
	Image.prototype.hasDependency = function() { return this.$val.hasDependency(); };
	Image.ptr.prototype.restore = function() {
		var _i, _r, _ref, _tuple, c, gimg, h, i, pix, pix$1, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _tuple = $f._tuple; c = $f.c; gimg = $f.gimg; h = $f.h; i = $f.i; pix = $f.pix; pix$1 = $f.pix$1; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_tuple = i.image.Size();
		w = _tuple[0];
		h = _tuple[1];
		if (i.screen) {
			i.image = graphicscommand.NewScreenFramebufferImage(w, h);
			i.basePixels = ptrType$2.nil;
			i.drawTrianglesHistory = sliceType$2.nil;
			i.stale = false;
			$s = -1; return $ifaceNil;
		}
		/* */ if (i.volatile$4) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (i.volatile$4) { */ case 1:
			i.image = graphicscommand.NewImage(w, h);
			$r = i.clearForInitialization(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		if (i.stale) {
			$s = -1; return errors.New("restorable: pixels must not be stale when restoring");
		}
		gimg = graphicscommand.NewImage(w, h);
		if (!(i.basePixels === ptrType$2.nil)) {
			gimg.ReplacePixels(i.basePixels.Slice(), 0, 0, w, h);
		} else {
			pix = $makeSlice(sliceType, ($imul(($imul(w, h)), 4)));
			gimg.ReplacePixels(pix, 0, 0, w, h);
		}
		_ref = i.drawTrianglesHistory;
		_i = 0;
		/* while (true) { */ case 4:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (c.image.hasDependency()) {
				$panic(new $String("restorable: all dependencies must be already resolved but not"));
			}
			$r = gimg.DrawTriangles(c.image.image, c.vertices, c.indices, c.colorm, c.mode, c.filter, c.address); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 4; continue; case 5:
		i.image = gimg;
		_r = gimg.Pixels(); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		pix$1 = _r;
		i.basePixels = new Pixels.ptr(pix$1, pix$1.$length, new color.RGBA.ptr(0, 0, 0, 0));
		i.drawTrianglesHistory = sliceType$2.nil;
		i.stale = false;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.restore }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._tuple = _tuple; $f.c = c; $f.gimg = gimg; $f.h = h; $f.i = i; $f.pix = pix; $f.pix$1 = pix$1; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.restore = function() { return this.$val.restore(); };
	Image.ptr.prototype.Dispose = function() {
		var i;
		i = this;
		theImages.remove(i);
		i.image.Dispose();
		i.image = ptrType$1.nil;
		i.basePixels = ptrType$2.nil;
		i.drawTrianglesHistory = sliceType$2.nil;
		i.stale = false;
	};
	Image.prototype.Dispose = function() { return this.$val.Dispose(); };
	Image.ptr.prototype.isInvalidated = function() {
		var _r, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		$r = graphicscommand.FlushCommands(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r = i.image.IsInvalidated(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.isInvalidated }; } $f._r = _r; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.isInvalidated = function() { return this.$val.isInvalidated(); };
	needsRestoring = function() {
		var _r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (forceRestoring) {
			$s = -1; return true;
		}
		_r = graphicscommand.NeedsRestoring(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: needsRestoring }; } $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;
	};
	ResolveStaleImages = function() {
		var _r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = graphicscommand.FlushCommands(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r = needsRestoring(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!_r) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!_r) { */ case 2:
			$s = -1; return;
		/* } */ case 3:
		$r = theImages.resolveStaleImages(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ResolveStaleImages }; } $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ResolveStaleImages = ResolveStaleImages;
	RestoreIfNeeded = function() {
		var _entry, _i, _keys, _r, _r$1, _r$2, _r$3, _ref, err, img, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; err = $f.err; img = $f.img; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = needsRestoring(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!_r) { */ case 1:
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		/* */ if (!forceRestoring) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!forceRestoring) { */ case 4:
			r = false;
			_ref = theImages.images;
			_i = 0;
			_keys = $keys(_ref);
			/* while (true) { */ case 6:
				/* if (!(_i < _keys.length)) { break; } */ if(!(_i < _keys.length)) { $s = 7; continue; }
				_entry = _ref[_keys[_i]];
				if (_entry === undefined) {
					_i++;
					/* continue; */ $s = 6; continue;
				}
				img = _entry.k;
				/* */ if (img.screen) { $s = 8; continue; }
				/* */ $s = 9; continue;
				/* if (img.screen) { */ case 8:
					_i++;
					/* continue; */ $s = 6; continue;
				/* } */ case 9:
				_r$1 = img.isInvalidated(); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				r = _r$1;
				/* break; */ $s = 7; continue;
			/* } */ $s = 6; continue; case 7:
			if (!r) {
				$s = -1; return $ifaceNil;
			}
		/* } */ case 5:
		_r$2 = graphicscommand.ResetGraphicsDriverState(); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		err = _r$2;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r$3 = theImages.restore(); /* */ $s = 12; case 12: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		$s = -1; return _r$3;
		/* */ } return; } if ($f === undefined) { $f = { $blk: RestoreIfNeeded }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f.err = err; $f.img = img; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.RestoreIfNeeded = RestoreIfNeeded;
	images.ptr.prototype.add = function(img) {
		var _key, i, img;
		i = this;
		_key = img; (i.images || $throwRuntimeError("assignment to entry in nil map"))[ptrType.keyFor(_key)] = { k: _key, v: new structType.ptr() };
	};
	images.prototype.add = function(img) { return this.$val.add(img); };
	images.ptr.prototype.remove = function(img) {
		var i, img;
		i = this;
		i.makeStaleIfDependingOnImpl(img);
		delete i.images[ptrType.keyFor(img)];
	};
	images.prototype.remove = function(img) { return this.$val.remove(img); };
	images.ptr.prototype.resolveStaleImages = function() {
		var _entry, _i, _keys, _ref, i, img, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _ref = $f._ref; i = $f.i; img = $f.img; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		i.lastTarget = ptrType.nil;
		_ref = i.images;
		_i = 0;
		_keys = $keys(_ref);
		/* while (true) { */ case 1:
			/* if (!(_i < _keys.length)) { break; } */ if(!(_i < _keys.length)) { $s = 2; continue; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				/* continue; */ $s = 1; continue;
			}
			img = _entry.k;
			$r = img.resolveStale(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: images.ptr.prototype.resolveStaleImages }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._ref = _ref; $f.i = i; $f.img = img; $f.$s = $s; $f.$r = $r; return $f;
	};
	images.prototype.resolveStaleImages = function() { return this.$val.resolveStaleImages(); };
	images.ptr.prototype.makeStaleIfDependingOn = function(target) {
		var i, target;
		i = this;
		i.makeStaleIfDependingOnImpl(target);
	};
	images.prototype.makeStaleIfDependingOn = function(target) { return this.$val.makeStaleIfDependingOn(target); };
	images.ptr.prototype.makeStaleIfDependingOnImpl = function(target) {
		var _entry, _i, _keys, _ref, i, img, target;
		i = this;
		if (target === ptrType.nil) {
			$panic(new $String("restorable: target must not be nil at makeStaleIfDependingOnImpl"));
		}
		if (i.lastTarget === target) {
			return;
		}
		i.lastTarget = target;
		_ref = i.images;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			img = _entry.k;
			img.makeStaleIfDependingOn(target);
			_i++;
		}
	};
	images.prototype.makeStaleIfDependingOnImpl = function(target) { return this.$val.makeStaleIfDependingOnImpl(target); };
	images.ptr.prototype.restore = function() {
		var _entry, _entry$1, _entry$10, _entry$2, _entry$3, _entry$4, _entry$5, _entry$6, _entry$7, _entry$8, _entry$9, _i, _i$1, _i$10, _i$2, _i$3, _i$4, _i$5, _i$6, _i$7, _i$8, _i$9, _key, _key$1, _key$2, _keys, _keys$1, _keys$2, _keys$3, _keys$4, _keys$5, _keys$6, _keys$7, _keys$8, _r, _r$1, _ref, _ref$1, _ref$10, _ref$2, _ref$3, _ref$4, _ref$5, _ref$6, _ref$7, _ref$8, _ref$9, _tuple, _tuple$1, current, e, e$1, e$2, edges, err, i, i$1, i$2, i$3, i$4, images$1, img, img$1, ok, ok$1, removed, s, sorted, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$10 = $f._entry$10; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _entry$4 = $f._entry$4; _entry$5 = $f._entry$5; _entry$6 = $f._entry$6; _entry$7 = $f._entry$7; _entry$8 = $f._entry$8; _entry$9 = $f._entry$9; _i = $f._i; _i$1 = $f._i$1; _i$10 = $f._i$10; _i$2 = $f._i$2; _i$3 = $f._i$3; _i$4 = $f._i$4; _i$5 = $f._i$5; _i$6 = $f._i$6; _i$7 = $f._i$7; _i$8 = $f._i$8; _i$9 = $f._i$9; _key = $f._key; _key$1 = $f._key$1; _key$2 = $f._key$2; _keys = $f._keys; _keys$1 = $f._keys$1; _keys$2 = $f._keys$2; _keys$3 = $f._keys$3; _keys$4 = $f._keys$4; _keys$5 = $f._keys$5; _keys$6 = $f._keys$6; _keys$7 = $f._keys$7; _keys$8 = $f._keys$8; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$10 = $f._ref$10; _ref$2 = $f._ref$2; _ref$3 = $f._ref$3; _ref$4 = $f._ref$4; _ref$5 = $f._ref$5; _ref$6 = $f._ref$6; _ref$7 = $f._ref$7; _ref$8 = $f._ref$8; _ref$9 = $f._ref$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; current = $f.current; e = $f.e; e$1 = $f.e$1; e$2 = $f.e$2; edges = $f.edges; err = $f.err; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; i$4 = $f.i$4; images$1 = $f.images$1; img = $f.img; img$1 = $f.img$1; ok = $f.ok; ok$1 = $f.ok$1; removed = $f.removed; s = $f.s; sorted = $f.sorted; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_r = needsRestoring(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (!_r) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!_r) { */ case 1:
			$panic(new $String("restorable: restore cannot be called when restoring is disabled"));
		/* } */ case 2:
		_ref = i.images;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			img = _entry.k;
			img.image.Dispose();
			_i++;
		}
		images$1 = $makeMap(ptrType.keyFor, []);
		_ref$1 = i.images;
		_i$1 = 0;
		_keys$1 = $keys(_ref$1);
		while (true) {
			if (!(_i$1 < _keys$1.length)) { break; }
			_entry$1 = _ref$1[_keys$1[_i$1]];
			if (_entry$1 === undefined) {
				_i$1++;
				continue;
			}
			i$1 = _entry$1.k;
			if (!i$1.priority) {
				_key = i$1; (images$1 || $throwRuntimeError("assignment to entry in nil map"))[ptrType.keyFor(_key)] = { k: _key, v: new structType.ptr() };
			}
			_i$1++;
		}
		edges = $makeMap(edge.keyFor, []);
		_ref$2 = images$1;
		_i$2 = 0;
		_keys$2 = $keys(_ref$2);
		while (true) {
			if (!(_i$2 < _keys$2.length)) { break; }
			_entry$2 = _ref$2[_keys$2[_i$2]];
			if (_entry$2 === undefined) {
				_i$2++;
				continue;
			}
			t = _entry$2.k;
			_ref$3 = t.dependingImages();
			_i$3 = 0;
			_keys$3 = $keys(_ref$3);
			while (true) {
				if (!(_i$3 < _keys$3.length)) { break; }
				_entry$3 = _ref$3[_keys$3[_i$3]];
				if (_entry$3 === undefined) {
					_i$3++;
					continue;
				}
				s = _entry$3.k;
				_key$1 = new edge.ptr(s, t); (edges || $throwRuntimeError("assignment to entry in nil map"))[edge.keyFor(_key$1)] = { k: _key$1, v: new structType.ptr() };
				_i$3++;
			}
			_i$2++;
		}
		sorted = new sliceType$6([]);
		_ref$4 = i.images;
		_i$4 = 0;
		_keys$4 = $keys(_ref$4);
		while (true) {
			if (!(_i$4 < _keys$4.length)) { break; }
			_entry$4 = _ref$4[_keys$4[_i$4]];
			if (_entry$4 === undefined) {
				_i$4++;
				continue;
			}
			i$2 = _entry$4.k;
			if (i$2.priority) {
				sorted = $append(sorted, i$2);
			}
			_i$4++;
		}
		while (true) {
			if (!($keys(images$1).length > 0)) { break; }
			current = $makeMap(ptrType.keyFor, []);
			_ref$5 = images$1;
			_i$5 = 0;
			_keys$5 = $keys(_ref$5);
			while (true) {
				if (!(_i$5 < _keys$5.length)) { break; }
				_entry$5 = _ref$5[_keys$5[_i$5]];
				if (_entry$5 === undefined) {
					_i$5++;
					continue;
				}
				i$3 = _entry$5.k;
				_key$2 = i$3; (current || $throwRuntimeError("assignment to entry in nil map"))[ptrType.keyFor(_key$2)] = { k: _key$2, v: new structType.ptr() };
				_i$5++;
			}
			_ref$6 = edges;
			_i$6 = 0;
			_keys$6 = $keys(_ref$6);
			while (true) {
				if (!(_i$6 < _keys$6.length)) { break; }
				_entry$6 = _ref$6[_keys$6[_i$6]];
				if (_entry$6 === undefined) {
					_i$6++;
					continue;
				}
				e = $clone(_entry$6.k, edge);
				_tuple = (_entry$7 = current[ptrType.keyFor(e.target)], _entry$7 !== undefined ? [_entry$7.v, true] : [new structType.ptr(), false]);
				ok = _tuple[1];
				if (ok) {
					delete current[ptrType.keyFor(e.target)];
				}
				_i$6++;
			}
			_ref$7 = current;
			_i$7 = 0;
			_keys$7 = $keys(_ref$7);
			while (true) {
				if (!(_i$7 < _keys$7.length)) { break; }
				_entry$8 = _ref$7[_keys$7[_i$7]];
				if (_entry$8 === undefined) {
					_i$7++;
					continue;
				}
				i$4 = _entry$8.k;
				delete images$1[ptrType.keyFor(i$4)];
				sorted = $append(sorted, i$4);
				_i$7++;
			}
			removed = new sliceType$7([]);
			_ref$8 = edges;
			_i$8 = 0;
			_keys$8 = $keys(_ref$8);
			while (true) {
				if (!(_i$8 < _keys$8.length)) { break; }
				_entry$9 = _ref$8[_keys$8[_i$8]];
				if (_entry$9 === undefined) {
					_i$8++;
					continue;
				}
				e$1 = $clone(_entry$9.k, edge);
				_tuple$1 = (_entry$10 = current[ptrType.keyFor(e$1.source)], _entry$10 !== undefined ? [_entry$10.v, true] : [new structType.ptr(), false]);
				ok$1 = _tuple$1[1];
				if (ok$1) {
					removed = $append(removed, e$1);
				}
				_i$8++;
			}
			_ref$9 = removed;
			_i$9 = 0;
			while (true) {
				if (!(_i$9 < _ref$9.$length)) { break; }
				e$2 = $clone(((_i$9 < 0 || _i$9 >= _ref$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$9.$array[_ref$9.$offset + _i$9]), edge);
				delete edges[edge.keyFor(e$2)];
				_i$9++;
			}
		}
		_ref$10 = sorted;
		_i$10 = 0;
		/* while (true) { */ case 4:
			/* if (!(_i$10 < _ref$10.$length)) { break; } */ if(!(_i$10 < _ref$10.$length)) { $s = 5; continue; }
			img$1 = ((_i$10 < 0 || _i$10 >= _ref$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$10.$array[_ref$10.$offset + _i$10]);
			_r$1 = img$1.restore(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			err = _r$1;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			_i$10++;
		/* } */ $s = 4; continue; case 5:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: images.ptr.prototype.restore }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$10 = _entry$10; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._entry$4 = _entry$4; $f._entry$5 = _entry$5; $f._entry$6 = _entry$6; $f._entry$7 = _entry$7; $f._entry$8 = _entry$8; $f._entry$9 = _entry$9; $f._i = _i; $f._i$1 = _i$1; $f._i$10 = _i$10; $f._i$2 = _i$2; $f._i$3 = _i$3; $f._i$4 = _i$4; $f._i$5 = _i$5; $f._i$6 = _i$6; $f._i$7 = _i$7; $f._i$8 = _i$8; $f._i$9 = _i$9; $f._key = _key; $f._key$1 = _key$1; $f._key$2 = _key$2; $f._keys = _keys; $f._keys$1 = _keys$1; $f._keys$2 = _keys$2; $f._keys$3 = _keys$3; $f._keys$4 = _keys$4; $f._keys$5 = _keys$5; $f._keys$6 = _keys$6; $f._keys$7 = _keys$7; $f._keys$8 = _keys$8; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$10 = _ref$10; $f._ref$2 = _ref$2; $f._ref$3 = _ref$3; $f._ref$4 = _ref$4; $f._ref$5 = _ref$5; $f._ref$6 = _ref$6; $f._ref$7 = _ref$7; $f._ref$8 = _ref$8; $f._ref$9 = _ref$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.current = current; $f.e = e; $f.e$1 = e$1; $f.e$2 = e$2; $f.edges = edges; $f.err = err; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.i$4 = i$4; $f.images$1 = images$1; $f.img = img; $f.img$1 = img$1; $f.ok = ok; $f.ok$1 = ok$1; $f.removed = removed; $f.s = s; $f.sorted = sorted; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	images.prototype.restore = function() { return this.$val.restore(); };
	InitializeGraphicsDriverState = function() {
		var _r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = graphicscommand.ResetGraphicsDriverState(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: InitializeGraphicsDriverState }; } $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.InitializeGraphicsDriverState = InitializeGraphicsDriverState;
	Error = function() {
		return graphicscommand.Error();
	};
	$pkg.Error = Error;
	ptrType$2.methods = [{prop: "ensurePixels", name: "ensurePixels", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [], false)}, {prop: "CopyFrom", name: "CopyFrom", pkg: "", typ: $funcType([sliceType, $Int], [], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int], [$Uint8], false)}, {prop: "Slice", name: "Slice", pkg: "", typ: $funcType([], [sliceType], false)}];
	ptrType.methods = [{prop: "MakeVolatile", name: "MakeVolatile", pkg: "", typ: $funcType([], [], false)}, {prop: "Fill", name: "Fill", pkg: "", typ: $funcType([$Uint8, $Uint8, $Uint8, $Uint8], [], false)}, {prop: "clearForInitialization", name: "clearForInitialization", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [], false)}, {prop: "fill", name: "fill", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([$Uint8, $Uint8, $Uint8, $Uint8], [], false)}, {prop: "IsVolatile", name: "IsVolatile", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "BasePixelsForTesting", name: "BasePixelsForTesting", pkg: "", typ: $funcType([], [ptrType$2], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int, $Int], false)}, {prop: "internalSize", name: "internalSize", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [$Int, $Int], false)}, {prop: "PutVertex", name: "PutVertex", pkg: "", typ: $funcType([sliceType$3, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32], [], false)}, {prop: "makeStale", name: "makeStale", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [], false)}, {prop: "CopyPixels", name: "CopyPixels", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "ClearPixels", name: "ClearPixels", pkg: "", typ: $funcType([$Int, $Int, $Int, $Int], [], false)}, {prop: "ReplacePixels", name: "ReplacePixels", pkg: "", typ: $funcType([sliceType, $Int, $Int, $Int, $Int], [], false)}, {prop: "DrawTriangles", name: "DrawTriangles", pkg: "", typ: $funcType([ptrType, sliceType$3, sliceType$4, ptrType$4, driver.CompositeMode, driver.Filter, driver.Address], [], false)}, {prop: "appendDrawTrianglesHistory", name: "appendDrawTrianglesHistory", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([ptrType, sliceType$3, sliceType$4, ptrType$4, driver.CompositeMode, driver.Filter, driver.Address], [], false)}, {prop: "readPixelsFromGPUIfNeeded", name: "readPixelsFromGPUIfNeeded", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [$Uint8, $Uint8, $Uint8, $Uint8], false)}, {prop: "makeStaleIfDependingOn", name: "makeStaleIfDependingOn", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([ptrType], [], false)}, {prop: "readPixelsFromGPU", name: "readPixelsFromGPU", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [], false)}, {prop: "resolveStale", name: "resolveStale", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [], false)}, {prop: "dependsOn", name: "dependsOn", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([ptrType], [$Bool], false)}, {prop: "dependingImages", name: "dependingImages", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [mapType], false)}, {prop: "hasDependency", name: "hasDependency", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [$Bool], false)}, {prop: "restore", name: "restore", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [$error], false)}, {prop: "Dispose", name: "Dispose", pkg: "", typ: $funcType([], [], false)}, {prop: "isInvalidated", name: "isInvalidated", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [$Bool], false)}];
	ptrType$5.methods = [{prop: "add", name: "add", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([ptrType], [], false)}, {prop: "remove", name: "remove", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([ptrType], [], false)}, {prop: "resolveStaleImages", name: "resolveStaleImages", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [], false)}, {prop: "makeStaleIfDependingOn", name: "makeStaleIfDependingOn", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([ptrType], [], false)}, {prop: "makeStaleIfDependingOnImpl", name: "makeStaleIfDependingOnImpl", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([ptrType], [], false)}, {prop: "restore", name: "restore", pkg: "github.com/hajimehoshi/ebiten/internal/restorable", typ: $funcType([], [$error], false)}];
	Pixels.init("github.com/hajimehoshi/ebiten/internal/restorable", [{prop: "pixels", name: "pixels", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "length", name: "length", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "color", name: "color", embedded: false, exported: false, typ: color.RGBA, tag: ""}]);
	drawTrianglesHistoryItem.init("github.com/hajimehoshi/ebiten/internal/restorable", [{prop: "image", name: "image", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "vertices", name: "vertices", embedded: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "indices", name: "indices", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "colorm", name: "colorm", embedded: false, exported: false, typ: ptrType$4, tag: ""}, {prop: "mode", name: "mode", embedded: false, exported: false, typ: driver.CompositeMode, tag: ""}, {prop: "filter", name: "filter", embedded: false, exported: false, typ: driver.Filter, tag: ""}, {prop: "address", name: "address", embedded: false, exported: false, typ: driver.Address, tag: ""}]);
	Image.init("github.com/hajimehoshi/ebiten/internal/restorable", [{prop: "image", name: "image", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "basePixels", name: "basePixels", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "drawTrianglesHistory", name: "drawTrianglesHistory", embedded: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "stale", name: "stale", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "volatile$4", name: "volatile", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "screen", name: "screen", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "priority", name: "priority", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	images.init("github.com/hajimehoshi/ebiten/internal/restorable", [{prop: "images", name: "images", embedded: false, exported: false, typ: mapType, tag: ""}, {prop: "lastTarget", name: "lastTarget", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	edge.init("github.com/hajimehoshi/ebiten/internal/restorable", [{prop: "source", name: "source", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "target", name: "target", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fmt.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = affine.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = driver.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = graphics.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = graphicscommand.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = image.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = color.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		emptyImage = ptrType.nil;
		forceRestoring = false;
		theImages = new images.ptr($makeMap(ptrType.keyFor, []), ptrType.nil);
		$r = init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/shareable"] = (function() {
	var $pkg = {}, $init, fmt, affine, driver, graphics, hooks, packing, restorable, image, runtime, sync, backend, Image, ptrType, sliceType, ptrType$1, ptrType$2, sliceType$1, ptrType$3, ptrType$4, ptrType$5, sliceType$2, structType, sliceType$3, funcType, sliceType$5, graphicsDriver, minSize, maxSize, backendsM, theBackends, imagesToMakeShared, SetGraphicsDriver, min, init, makeImagesShared, isShareable, NewImage, NewScreenFramebufferImage, InitializeGraphicsDriverState, ResolveStaleImages, RestoreIfNeeded, Error;
	fmt = $packages["fmt"];
	affine = $packages["github.com/hajimehoshi/ebiten/internal/affine"];
	driver = $packages["github.com/hajimehoshi/ebiten/internal/driver"];
	graphics = $packages["github.com/hajimehoshi/ebiten/internal/graphics"];
	hooks = $packages["github.com/hajimehoshi/ebiten/internal/hooks"];
	packing = $packages["github.com/hajimehoshi/ebiten/internal/packing"];
	restorable = $packages["github.com/hajimehoshi/ebiten/internal/restorable"];
	image = $packages["image"];
	runtime = $packages["runtime"];
	sync = $packages["sync"];
	backend = $pkg.backend = $newType(0, $kindStruct, "shareable.backend", true, "github.com/hajimehoshi/ebiten/internal/shareable", false, function(restorable_, page_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.restorable = ptrType$4.nil;
			this.page = ptrType$5.nil;
			return;
		}
		this.restorable = restorable_;
		this.page = page_;
	});
	Image = $pkg.Image = $newType(0, $kindStruct, "shareable.Image", true, "github.com/hajimehoshi/ebiten/internal/shareable", true, function(width_, height_, disposed_, backend_, node_, nonUpdatedCount_, neverShared_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.width = 0;
			this.height = 0;
			this.disposed = false;
			this.backend = ptrType.nil;
			this.node = ptrType$2.nil;
			this.nonUpdatedCount = 0;
			this.neverShared = false;
			return;
		}
		this.width = width_;
		this.height = height_;
		this.disposed = disposed_;
		this.backend = backend_;
		this.node = node_;
		this.nonUpdatedCount = nonUpdatedCount_;
		this.neverShared = neverShared_;
	});
	ptrType = $ptrType(backend);
	sliceType = $sliceType(ptrType);
	ptrType$1 = $ptrType(Image);
	ptrType$2 = $ptrType(packing.Node);
	sliceType$1 = $sliceType($Float32);
	ptrType$3 = $ptrType(affine.ColorM);
	ptrType$4 = $ptrType(restorable.Image);
	ptrType$5 = $ptrType(packing.Page);
	sliceType$2 = $sliceType($Uint8);
	structType = $structType("", []);
	sliceType$3 = $sliceType($emptyInterface);
	funcType = $funcType([ptrType$1], [], false);
	sliceType$5 = $sliceType($Uint16);
	SetGraphicsDriver = function(graphics$1) {
		var graphics$1;
		graphicsDriver = graphics$1;
	};
	$pkg.SetGraphicsDriver = SetGraphicsDriver;
	min = function(a, b) {
		var a, b;
		if (a < b) {
			return a;
		}
		return b;
	};
	init = function() {
		var once, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; once = $f.once; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		once = [once];
		once[0] = new sync.Once.ptr(new sync.Mutex.ptr(0, 0), 0);
		$r = hooks.AppendHookOnBeforeUpdate((function(once) { return function $b() {
			var $s, $deferred, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
			$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$deferred.push([$methodVal(backendsM, "Unlock"), []]);
			$r = once[0].Do((function(once) { return function $b() {
				var _arg, _r, _r$1, _r$2, $s, $r;
				/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
				if (!((theBackends.$length === 0))) {
					$panic(new $String("shareable: all the images must be not-shared before the game starts"));
				}
				_r = graphicsDriver.HasHighPrecisionFloat(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				/* */ if (_r) { $s = 1; continue; }
				/* */ $s = 2; continue;
				/* if (_r) { */ case 1:
					minSize = 1024;
					_r$1 = graphicsDriver.MaxImageSize(); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_arg = _r$1;
					_r$2 = min(4096, _arg); /* */ $s = 6; case 6: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					maxSize = _r$2;
					$s = 3; continue;
				/* } else { */ case 2:
					minSize = 512;
					maxSize = 512;
				/* } */ case 3:
				$s = -1; return;
				/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._arg = _arg; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.$s = $s; $f.$r = $r; return $f;
			}; })(once)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = makeImagesShared(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: $b }; } $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
		}; })(once)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f.once = once; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeImagesShared = function() {
		var _entry, _i, _keys, _ref, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _ref = $f._ref; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_ref = imagesToMakeShared;
		_i = 0;
		_keys = $keys(_ref);
		/* while (true) { */ case 1:
			/* if (!(_i < _keys.length)) { break; } */ if(!(_i < _keys.length)) { $s = 2; continue; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				/* continue; */ $s = 1; continue;
			}
			i = _entry.k;
			i.nonUpdatedCount = i.nonUpdatedCount + (1) >> 0;
			/* */ if (i.nonUpdatedCount >= 10) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (i.nonUpdatedCount >= 10) { */ case 3:
				$r = i.makeShared(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 4:
			delete imagesToMakeShared[ptrType$1.keyFor(i)];
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: makeImagesShared }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._ref = _ref; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	backend.ptr.prototype.TryAlloc = function(width, height) {
		var _r, _r$1, _r$2, b, height, i, n, n$1, n$2, nExtended, newImg, oldImg, page, s, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; b = $f.b; height = $f.height; i = $f.i; n = $f.n; n$1 = $f.n$1; n$2 = $f.n$2; nExtended = $f.nExtended; newImg = $f.newImg; oldImg = $f.oldImg; page = $f.page; s = $f.s; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		n = b.page.Alloc(width, height);
		if (!(n === ptrType$2.nil)) {
			$s = -1; return [n, true];
		}
		page = b.page.Clone();
		nExtended = 0;
		/* while (true) { */ case 1:
			_r = page.Extend(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (!_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!_r) { */ case 3:
				$s = -1; return [ptrType$2.nil, false];
			/* } */ case 4:
			nExtended = nExtended + (1) >> 0;
			n$1 = page.Alloc(width, height);
			if (!(n$1 === ptrType$2.nil)) {
				/* break; */ $s = 2; continue;
			}
		/* } */ $s = 1; continue; case 2:
		i = 0;
		/* while (true) { */ case 6:
			/* if (!(i < nExtended)) { break; } */ if(!(i < nExtended)) { $s = 7; continue; }
			_r$1 = b.page.Extend(); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$1;
			i = i + (1) >> 0;
		/* } */ $s = 6; continue; case 7:
		s = b.page.Size();
		_r$2 = restorable.NewImage(s, s); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		newImg = _r$2;
		oldImg = b.restorable;
		newImg.CopyPixels(oldImg);
		oldImg.Dispose();
		b.restorable = newImg;
		n$2 = b.page.Alloc(width, height);
		if (n$2 === ptrType$2.nil) {
			$panic(new $String("shareable: Alloc result must not be nil at TryAlloc"));
		}
		$s = -1; return [n$2, true];
		/* */ } return; } if ($f === undefined) { $f = { $blk: backend.ptr.prototype.TryAlloc }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.b = b; $f.height = height; $f.i = i; $f.n = n; $f.n$1 = n$1; $f.n$2 = n$2; $f.nExtended = nExtended; $f.newImg = newImg; $f.oldImg = oldImg; $f.page = page; $f.s = s; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	backend.prototype.TryAlloc = function(width, height) { return this.$val.TryAlloc(width, height); };
	isShareable = function() {
		return minSize > 0 && maxSize > 0;
	};
	Image.ptr.prototype.moveTo = function(dst) {
		var dst, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; dst = $f.dst; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		$r = dst.dispose(false); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		Image.copy(dst, i);
		runtime.SetFinalizer(i, $ifaceNil);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.moveTo }; } $f.dst = dst; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.moveTo = function(dst) { return this.$val.moveTo(dst); };
	Image.ptr.prototype.isShared = function() {
		var i;
		i = this;
		return !(i.node === ptrType$2.nil);
	};
	Image.prototype.isShared = function() { return this.$val.isShared(); };
	Image.ptr.prototype.IsSharedForTesting = function() {
		var i, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		i = this;
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		$s = -1; return i.isShared();
		/* */ } return; } } catch(err) { $err = err; $s = -1; return false; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Image.ptr.prototype.IsSharedForTesting }; } $f.i = i; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Image.prototype.IsSharedForTesting = function() { return this.$val.IsSharedForTesting(); };
	Image.ptr.prototype.ensureNotShared = function() {
		var _r, _tuple, h, i, is, newImg, vs, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; h = $f.h; i = $f.i; is = $f.is; newImg = $f.newImg; vs = $f.vs; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		/* */ if (i.backend === ptrType.nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (i.backend === ptrType.nil) { */ case 1:
			$r = i.allocate(false); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return;
		/* } */ case 2:
		if (!i.isShared()) {
			$s = -1; return;
		}
		_tuple = i.region();
		w = _tuple[2];
		h = _tuple[3];
		_r = restorable.NewImage(w, h); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		newImg = _r;
		vs = $makeSlice(sliceType$1, 48);
		$r = graphics.PutQuadVertices(vs, i, 0, 0, w, h, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		is = graphics.QuadIndices();
		$r = newImg.DrawTriangles(i.backend.restorable, vs, is, ptrType$3.nil, 2, 1, 0); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = i.dispose(false); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		i.backend = new backend.ptr(newImg, ptrType$5.nil);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.ensureNotShared }; } $f._r = _r; $f._tuple = _tuple; $f.h = h; $f.i = i; $f.is = is; $f.newImg = newImg; $f.vs = vs; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.ensureNotShared = function() { return this.$val.ensureNotShared(); };
	Image.ptr.prototype.makeShared = function() {
		var _r, _tuple, a, b, g, i, newI, pixels, r, x, x$1, x$2, x$3, x$4, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; a = $f.a; b = $f.b; g = $f.g; i = $f.i; newI = $f.newI; pixels = $f.pixels; r = $f.r; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		/* */ if (i.backend === ptrType.nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (i.backend === ptrType.nil) { */ case 1:
			$r = i.allocate(true); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return;
		/* } */ case 2:
		if (i.isShared()) {
			$s = -1; return;
		}
		if (!i.shareable()) {
			$panic(new $String("shareable: makeShared cannot be called on a non-shareable image"));
		}
		newI = NewImage(i.width, i.height);
		pixels = $makeSlice(sliceType$2, ($imul(($imul(4, i.width)), i.height)));
		y = 0;
		/* while (true) { */ case 4:
			/* if (!(y < i.height)) { break; } */ if(!(y < i.height)) { $s = 5; continue; }
			x = 0;
			/* while (true) { */ case 6:
				/* if (!(x < i.width)) { break; } */ if(!(x < i.width)) { $s = 7; continue; }
				_r = i.at(x, y); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				r = _tuple[0];
				g = _tuple[1];
				b = _tuple[2];
				a = _tuple[3];
				(x$1 = $imul(4, ((x + ($imul(i.width, y)) >> 0))), ((x$1 < 0 || x$1 >= pixels.$length) ? ($throwRuntimeError("index out of range"), undefined) : pixels.$array[pixels.$offset + x$1] = r));
				(x$2 = ($imul(4, ((x + ($imul(i.width, y)) >> 0)))) + 1 >> 0, ((x$2 < 0 || x$2 >= pixels.$length) ? ($throwRuntimeError("index out of range"), undefined) : pixels.$array[pixels.$offset + x$2] = g));
				(x$3 = ($imul(4, ((x + ($imul(i.width, y)) >> 0)))) + 2 >> 0, ((x$3 < 0 || x$3 >= pixels.$length) ? ($throwRuntimeError("index out of range"), undefined) : pixels.$array[pixels.$offset + x$3] = b));
				(x$4 = ($imul(4, ((x + ($imul(i.width, y)) >> 0)))) + 3 >> 0, ((x$4 < 0 || x$4 >= pixels.$length) ? ($throwRuntimeError("index out of range"), undefined) : pixels.$array[pixels.$offset + x$4] = a));
				x = x + (1) >> 0;
			/* } */ $s = 6; continue; case 7:
			y = y + (1) >> 0;
		/* } */ $s = 4; continue; case 5:
		$r = newI.replacePixels(pixels); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = newI.moveTo(i); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		i.nonUpdatedCount = 0;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.makeShared }; } $f._r = _r; $f._tuple = _tuple; $f.a = a; $f.b = b; $f.g = g; $f.i = i; $f.newI = newI; $f.pixels = pixels; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.makeShared = function() { return this.$val.makeShared(); };
	Image.ptr.prototype.region = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _tuple$1, h, height, i, w, width, x, y;
		x = 0;
		y = 0;
		width = 0;
		height = 0;
		i = this;
		if (i.backend === ptrType.nil) {
			$panic(new $String("shareable: backend must not be nil: not allocated yet?"));
		}
		if (!i.isShared()) {
			_tuple = i.backend.restorable.Size();
			w = _tuple[0];
			h = _tuple[1];
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = w;
			_tmp$3 = h;
			x = _tmp;
			y = _tmp$1;
			width = _tmp$2;
			height = _tmp$3;
			return [x, y, width, height];
		}
		_tuple$1 = i.node.Region();
		x = _tuple$1[0];
		y = _tuple$1[1];
		width = _tuple$1[2];
		height = _tuple$1[3];
		return [x, y, width, height];
	};
	Image.prototype.region = function() { return this.$val.region(); };
	Image.ptr.prototype.Size = function() {
		var _tmp, _tmp$1, height, i, width;
		width = 0;
		height = 0;
		i = this;
		_tmp = i.width;
		_tmp$1 = i.height;
		width = _tmp;
		height = _tmp$1;
		return [width, height];
	};
	Image.prototype.Size = function() { return this.$val.Size(); };
	Image.ptr.prototype.PutVertex = function(dst, dx, dy, sx, sy, bx0, by0, bx1, by1, cr, cg, cb, ca) {
		var _tmp, _tmp$1, _tuple, bx0, bx1, by0, by1, ca, cb, cg, cr, dst, dx, dy, i, ox, oxf, oy, oyf, sx, sy, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; bx0 = $f.bx0; bx1 = $f.bx1; by0 = $f.by0; by1 = $f.by1; ca = $f.ca; cb = $f.cb; cg = $f.cg; cr = $f.cr; dst = $f.dst; dx = $f.dx; dy = $f.dy; i = $f.i; ox = $f.ox; oxf = $f.oxf; oy = $f.oy; oyf = $f.oyf; sx = $f.sx; sy = $f.sy; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		/* */ if (i.backend === ptrType.nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (i.backend === ptrType.nil) { */ case 1:
			$r = i.allocate(true); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		_tuple = i.region();
		ox = _tuple[0];
		oy = _tuple[1];
		_tmp = (ox);
		_tmp$1 = (oy);
		oxf = _tmp;
		oyf = _tmp$1;
		i.backend.restorable.PutVertex(dst, dx, dy, $fround(sx + oxf), $fround(sy + oyf), $fround(bx0 + oxf), $fround(by0 + oyf), $fround(bx1 + oxf), $fround(by1 + oyf), cr, cg, cb, ca);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.PutVertex }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.bx0 = bx0; $f.bx1 = bx1; $f.by0 = by0; $f.by1 = by1; $f.ca = ca; $f.cb = cb; $f.cg = cg; $f.cr = cr; $f.dst = dst; $f.dx = dx; $f.dy = dy; $f.i = i; $f.ox = ox; $f.oxf = oxf; $f.oy = oy; $f.oyf = oyf; $f.sx = sx; $f.sy = sy; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.PutVertex = function(dst, dx, dy, sx, sy, bx0, by0, bx1, by1, cr, cg, cb, ca) { return this.$val.PutVertex(dst, dx, dy, sx, sy, bx0, by0, bx1, by1, cr, cg, cb, ca); };
	Image.ptr.prototype.DrawTriangles = function(img, vertices, indices, colorm, mode, filter, address) {
		var _key, address, colorm, filter, i, img, indices, mode, vertices, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _key = $f._key; address = $f.address; colorm = $f.colorm; filter = $f.filter; i = $f.i; img = $f.img; indices = $f.indices; mode = $f.mode; vertices = $f.vertices; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		i = this;
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		if (img.disposed) {
			$panic(new $String("shareable: the drawing source image must not be disposed (DrawTriangles)"));
		}
		if (i.disposed) {
			$panic(new $String("shareable: the drawing target image must not be disposed (DrawTriangles)"));
		}
		/* */ if (img.backend === ptrType.nil) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (img.backend === ptrType.nil) { */ case 2:
			$r = img.allocate(true); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$r = i.ensureNotShared(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (i.backend.restorable === img.backend.restorable) {
			$panic(new $String("shareable: Image.DrawTriangles: img must be different from the receiver"));
		}
		$r = i.backend.restorable.DrawTriangles(img.backend.restorable, vertices, indices, colorm, mode, filter, address); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		i.nonUpdatedCount = 0;
		delete imagesToMakeShared[ptrType$1.keyFor(i)];
		if (!img.isShared() && img.shareable()) {
			_key = img; (imagesToMakeShared || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: new structType.ptr() };
		}
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Image.ptr.prototype.DrawTriangles }; } $f._key = _key; $f.address = address; $f.colorm = colorm; $f.filter = filter; $f.i = i; $f.img = img; $f.indices = indices; $f.mode = mode; $f.vertices = vertices; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Image.prototype.DrawTriangles = function(img, vertices, indices, colorm, mode, filter, address) { return this.$val.DrawTriangles(img, vertices, indices, colorm, mode, filter, address); };
	Image.ptr.prototype.Fill = function(r, g, b, a) {
		var a, b, g, i, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; a = $f.a; b = $f.b; g = $f.g; i = $f.i; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (i.disposed) {
			$panic(new $String("shareable: the drawing target image must not be disposed (Fill)"));
		}
		$r = i.ensureNotShared(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = i.backend.restorable.Fill(r, g, b, a); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = backendsM.Unlock(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.Fill }; } $f.a = a; $f.b = b; $f.g = g; $f.i = i; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.Fill = function(r, g, b, a) { return this.$val.Fill(r, g, b, a); };
	Image.ptr.prototype.ReplacePixels = function(p) {
		var i, p, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; p = $f.p; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		i = this;
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		$r = i.replacePixels(p); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Image.ptr.prototype.ReplacePixels }; } $f.i = i; $f.p = p; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Image.prototype.ReplacePixels = function(p) { return this.$val.ReplacePixels(p); };
	Image.ptr.prototype.replacePixels = function(p) {
		var _r, _tuple, h, i, l, p, w, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; h = $f.h; i = $f.i; l = $f.l; p = $f.p; w = $f.w; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (i.disposed) {
			$panic(new $String("shareable: the image must not be disposed at replacePixels"));
		}
		/* */ if (i.backend === ptrType.nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (i.backend === ptrType.nil) { */ case 1:
			if (p === sliceType$2.nil) {
				$s = -1; return;
			}
			$r = i.allocate(true); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		_tuple = i.region();
		x = _tuple[0];
		y = _tuple[1];
		w = _tuple[2];
		h = _tuple[3];
		/* */ if (!(p === sliceType$2.nil)) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!(p === sliceType$2.nil)) { */ case 4:
			l = $imul(($imul(4, w)), h);
			/* */ if (!((p.$length === l))) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (!((p.$length === l))) { */ case 6:
				_r = fmt.Sprintf("shareable: len(p) must be %d but %d", new sliceType$3([new $Int(l), new $Int(p.$length)])); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$panic(new $String(_r));
			/* } */ case 7:
		/* } */ case 5:
		$r = i.backend.restorable.ReplacePixels(p, x, y, w, h); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.replacePixels }; } $f._r = _r; $f._tuple = _tuple; $f.h = h; $f.i = i; $f.l = l; $f.p = p; $f.w = w; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.replacePixels = function(p) { return this.$val.replacePixels(p); };
	Image.ptr.prototype.At = function(x, y) {
		var _r, i, x, y, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; x = $f.x; y = $f.y; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		i = this;
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		_r = i.at(x, y); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return [0, 0, 0, 0]; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Image.ptr.prototype.At }; } $f._r = _r; $f.i = i; $f.x = x; $f.y = y; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Image.prototype.At = function(x, y) { return this.$val.At(x, y); };
	Image.ptr.prototype.at = function(x, y) {
		var _r, _tuple, h, i, ox, oy, w, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; h = $f.h; i = $f.i; ox = $f.ox; oy = $f.oy; w = $f.w; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (i.backend === ptrType.nil) {
			$s = -1; return [0, 0, 0, 0];
		}
		_tuple = i.region();
		ox = _tuple[0];
		oy = _tuple[1];
		w = _tuple[2];
		h = _tuple[3];
		if (x < 0 || y < 0 || x >= w || y >= h) {
			$s = -1; return [0, 0, 0, 0];
		}
		_r = i.backend.restorable.At(x + ox >> 0, y + oy >> 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.at }; } $f._r = _r; $f._tuple = _tuple; $f.h = h; $f.i = i; $f.ox = ox; $f.oy = oy; $f.w = w; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.at = function(x, y) { return this.$val.at(x, y); };
	Image.ptr.prototype.Dispose = function() {
		var i, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		i = this;
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		$r = i.dispose(true); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Image.ptr.prototype.Dispose }; } $f.i = i; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Image.prototype.Dispose = function() { return this.$val.Dispose(); };
	Image.ptr.prototype.dispose = function(markDisposed) {
		var _i, _ref, _tuple, i, idx, index, markDisposed, sh, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _ref = $f._ref; _tuple = $f._tuple; i = $f.i; idx = $f.idx; index = $f.index; markDisposed = $f.markDisposed; sh = $f.sh; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		i = [i];
		markDisposed = [markDisposed];
		i[0] = this;
		$deferred.push([(function(i, markDisposed) { return function() {
			if (markDisposed[0]) {
				i[0].disposed = true;
			}
			i[0].backend = ptrType.nil;
			i[0].node = ptrType$2.nil;
			if (markDisposed[0]) {
				runtime.SetFinalizer(i[0], $ifaceNil);
			}
		}; })(i, markDisposed), []]);
		if (i[0].disposed) {
			$s = -1; return;
		}
		if (i[0].backend === ptrType.nil) {
			$s = -1; return;
		}
		if (!i[0].isShared()) {
			i[0].backend.restorable.Dispose();
			$s = -1; return;
		}
		i[0].backend.page.Free(i[0].node);
		/* */ if (!i[0].backend.page.IsEmpty()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!i[0].backend.page.IsEmpty()) { */ case 1:
			_tuple = i[0].region();
			$r = i[0].backend.restorable.ClearPixels(_tuple[0], _tuple[1], _tuple[2], _tuple[3]); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return;
		/* } */ case 2:
		i[0].backend.restorable.Dispose();
		index = -1;
		_ref = theBackends;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			idx = _i;
			sh = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (sh === i[0].backend) {
				index = idx;
				break;
			}
			_i++;
		}
		if (index === -1) {
			$panic(new $String("shareable: backend not found at an image being disposed"));
		}
		theBackends = $appendSlice($subslice(theBackends, 0, index), $subslice(theBackends, (index + 1 >> 0)));
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Image.ptr.prototype.dispose }; } $f._i = _i; $f._ref = _ref; $f._tuple = _tuple; $f.i = i; $f.idx = idx; $f.index = index; $f.markDisposed = markDisposed; $f.sh = sh; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Image.prototype.dispose = function(markDisposed) { return this.$val.dispose(markDisposed); };
	Image.ptr.prototype.IsVolatile = function() {
		var i, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		i = this;
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		if (i.backend === ptrType.nil) {
			$s = -1; return false;
		}
		$s = -1; return i.backend.restorable.IsVolatile();
		/* */ } return; } } catch(err) { $err = err; $s = -1; return false; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Image.ptr.prototype.IsVolatile }; } $f.i = i; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Image.prototype.IsVolatile = function() { return this.$val.IsVolatile(); };
	NewImage = function(width, height) {
		var height, width;
		return new Image.ptr(width, height, false, ptrType.nil, ptrType$2.nil, 0, false);
	};
	$pkg.NewImage = NewImage;
	Image.ptr.prototype.shareable = function() {
		var i;
		i = this;
		if (!isShareable()) {
			return false;
		}
		if (i.neverShared) {
			return false;
		}
		return i.width <= maxSize && i.height <= maxSize;
	};
	Image.prototype.shareable = function() { return this.$val.shareable(); };
	Image.ptr.prototype.allocate = function(shareable) {
		var _i, _r, _r$1, _r$2, _r$3, _ref, _tuple, b, b$1, i, n, n$1, ok, shareable, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; _tuple = $f._tuple; b = $f.b; b$1 = $f.b$1; i = $f.i; n = $f.n; n$1 = $f.n$1; ok = $f.ok; shareable = $f.shareable; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (!(i.backend === ptrType.nil)) {
			$panic(new $String("shareable: the image is already allocated"));
		}
		/* */ if (!shareable || !i.shareable()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!shareable || !i.shareable()) { */ case 1:
			_r = restorable.NewImage(i.width, i.height); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			i.backend = new backend.ptr(_r, ptrType$5.nil);
			runtime.SetFinalizer(i, new funcType($methodExpr(ptrType$1, "Dispose")));
			$s = -1; return;
		/* } */ case 2:
		_ref = theBackends;
		_i = 0;
		/* while (true) { */ case 4:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r$1 = b.TryAlloc(i.width, i.height); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple = _r$1;
			n = _tuple[0];
			ok = _tuple[1];
			if (ok) {
				i.backend = b;
				i.node = n;
				runtime.SetFinalizer(i, new funcType($methodExpr(ptrType$1, "Dispose")));
				$s = -1; return;
			}
			_i++;
		/* } */ $s = 4; continue; case 5:
		size = minSize;
		/* while (true) { */ case 7:
			/* if (!(i.width > size || i.height > size)) { break; } */ if(!(i.width > size || i.height > size)) { $s = 8; continue; }
			/* */ if (size === maxSize) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (size === maxSize) { */ case 9:
				_r$2 = fmt.Sprintf("shareable: the image being shared is too big: width: %d, height: %d", new sliceType$3([new $Int(i.width), new $Int(i.height)])); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				$panic(new $String(_r$2));
			/* } */ case 10:
			size = $imul(size, (2));
		/* } */ $s = 7; continue; case 8:
		_r$3 = restorable.NewImage(size, size); /* */ $s = 12; case 12: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		b$1 = new backend.ptr(_r$3, packing.NewPage(size, maxSize));
		theBackends = $append(theBackends, b$1);
		n$1 = b$1.page.Alloc(i.width, i.height);
		if (n$1 === ptrType$2.nil) {
			$panic(new $String("shareable: Alloc result must not be nil at allocate"));
		}
		i.backend = b$1;
		i.node = n$1;
		runtime.SetFinalizer(i, new funcType($methodExpr(ptrType$1, "Dispose")));
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.allocate }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f._tuple = _tuple; $f.b = b; $f.b$1 = b$1; $f.i = i; $f.n = n; $f.n$1 = n$1; $f.ok = ok; $f.shareable = shareable; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.allocate = function(shareable) { return this.$val.allocate(shareable); };
	Image.ptr.prototype.MakeVolatile = function() {
		var i, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		i = this;
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		$r = i.ensureNotShared(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		i.backend.restorable.MakeVolatile();
		i.neverShared = true;
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Image.ptr.prototype.MakeVolatile }; } $f.i = i; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Image.prototype.MakeVolatile = function() { return this.$val.MakeVolatile(); };
	NewScreenFramebufferImage = function(width, height) {
		var _r, height, i, r, width, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; height = $f.height; i = $f.i; r = $f.r; width = $f.width; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		_r = restorable.NewScreenFramebufferImage(width, height); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		r = _r;
		i = new Image.ptr(width, height, false, new backend.ptr(r, ptrType$5.nil), ptrType$2.nil, 0, true);
		runtime.SetFinalizer(i, new funcType($methodExpr(ptrType$1, "Dispose")));
		$s = -1; return i;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return ptrType$1.nil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: NewScreenFramebufferImage }; } $f._r = _r; $f.height = height; $f.i = i; $f.r = r; $f.width = width; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.NewScreenFramebufferImage = NewScreenFramebufferImage;
	InitializeGraphicsDriverState = function() {
		var _r, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		_r = restorable.InitializeGraphicsDriverState(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: InitializeGraphicsDriverState }; } $f._r = _r; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.InitializeGraphicsDriverState = InitializeGraphicsDriverState;
	ResolveStaleImages = function() {
		var $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		$r = restorable.ResolveStaleImages(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: ResolveStaleImages }; } $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.ResolveStaleImages = ResolveStaleImages;
	RestoreIfNeeded = function() {
		var _r, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		_r = restorable.RestoreIfNeeded(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: RestoreIfNeeded }; } $f._r = _r; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.RestoreIfNeeded = RestoreIfNeeded;
	Error = function() {
		var $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = backendsM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(backendsM, "Unlock"), []]);
		$s = -1; return restorable.Error();
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Error }; } $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.Error = Error;
	ptrType.methods = [{prop: "TryAlloc", name: "TryAlloc", pkg: "", typ: $funcType([$Int, $Int], [ptrType$2, $Bool], false)}];
	ptrType$1.methods = [{prop: "moveTo", name: "moveTo", pkg: "github.com/hajimehoshi/ebiten/internal/shareable", typ: $funcType([ptrType$1], [], false)}, {prop: "isShared", name: "isShared", pkg: "github.com/hajimehoshi/ebiten/internal/shareable", typ: $funcType([], [$Bool], false)}, {prop: "IsSharedForTesting", name: "IsSharedForTesting", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "ensureNotShared", name: "ensureNotShared", pkg: "github.com/hajimehoshi/ebiten/internal/shareable", typ: $funcType([], [], false)}, {prop: "makeShared", name: "makeShared", pkg: "github.com/hajimehoshi/ebiten/internal/shareable", typ: $funcType([], [], false)}, {prop: "region", name: "region", pkg: "github.com/hajimehoshi/ebiten/internal/shareable", typ: $funcType([], [$Int, $Int, $Int, $Int], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int, $Int], false)}, {prop: "PutVertex", name: "PutVertex", pkg: "", typ: $funcType([sliceType$1, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32, $Float32], [], false)}, {prop: "DrawTriangles", name: "DrawTriangles", pkg: "", typ: $funcType([ptrType$1, sliceType$1, sliceType$5, ptrType$3, driver.CompositeMode, driver.Filter, driver.Address], [], false)}, {prop: "Fill", name: "Fill", pkg: "", typ: $funcType([$Uint8, $Uint8, $Uint8, $Uint8], [], false)}, {prop: "ReplacePixels", name: "ReplacePixels", pkg: "", typ: $funcType([sliceType$2], [], false)}, {prop: "replacePixels", name: "replacePixels", pkg: "github.com/hajimehoshi/ebiten/internal/shareable", typ: $funcType([sliceType$2], [], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [$Uint8, $Uint8, $Uint8, $Uint8], false)}, {prop: "at", name: "at", pkg: "github.com/hajimehoshi/ebiten/internal/shareable", typ: $funcType([$Int, $Int], [$Uint8, $Uint8, $Uint8, $Uint8], false)}, {prop: "Dispose", name: "Dispose", pkg: "", typ: $funcType([], [], false)}, {prop: "dispose", name: "dispose", pkg: "github.com/hajimehoshi/ebiten/internal/shareable", typ: $funcType([$Bool], [], false)}, {prop: "IsVolatile", name: "IsVolatile", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "shareable", name: "shareable", pkg: "github.com/hajimehoshi/ebiten/internal/shareable", typ: $funcType([], [$Bool], false)}, {prop: "allocate", name: "allocate", pkg: "github.com/hajimehoshi/ebiten/internal/shareable", typ: $funcType([$Bool], [], false)}, {prop: "MakeVolatile", name: "MakeVolatile", pkg: "", typ: $funcType([], [], false)}];
	backend.init("github.com/hajimehoshi/ebiten/internal/shareable", [{prop: "restorable", name: "restorable", embedded: false, exported: false, typ: ptrType$4, tag: ""}, {prop: "page", name: "page", embedded: false, exported: false, typ: ptrType$5, tag: ""}]);
	Image.init("github.com/hajimehoshi/ebiten/internal/shareable", [{prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "disposed", name: "disposed", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "backend", name: "backend", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "node", name: "node", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "nonUpdatedCount", name: "nonUpdatedCount", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "neverShared", name: "neverShared", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = fmt.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = affine.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = driver.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = graphics.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = hooks.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = packing.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = restorable.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = image.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		graphicsDriver = $ifaceNil;
		backendsM = new sync.Mutex.ptr(0, 0);
		minSize = 0;
		maxSize = 0;
		theBackends = new sliceType([]);
		imagesToMakeShared = $makeMap(ptrType$1.keyFor, []);
		$r = init(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/devicescale"] = (function() {
	var $pkg = {}, $init, sync, js, pos, m, cache, GetAt, impl;
	sync = $packages["sync"];
	js = $packages["syscall/js"];
	pos = $pkg.pos = $newType(0, $kindStruct, "devicescale.pos", true, "github.com/hajimehoshi/ebiten/internal/devicescale", false, function(x_, y_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.x = 0;
			this.y = 0;
			return;
		}
		this.x = x_;
		this.y = y_;
	});
	GetAt = function(x, y) {
		var _entry, _key, _tuple, ok, s, s$1, x, y, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _key = $f._key; _tuple = $f._tuple; ok = $f.ok; s = $f.s; s$1 = $f.s$1; x = $f.x; y = $f.y; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$r = m.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(m, "Unlock"), []]);
		_tuple = (_entry = cache[pos.keyFor(new pos.ptr(x, y))], _entry !== undefined ? [_entry.v, true] : [0, false]);
		s = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			$s = -1; return s;
		}
		s$1 = impl(x, y);
		_key = new pos.ptr(x, y); (cache || $throwRuntimeError("assignment to entry in nil map"))[pos.keyFor(_key)] = { k: _key, v: s$1 };
		$s = -1; return s$1;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return 0; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: GetAt }; } $f._entry = _entry; $f._key = _key; $f._tuple = _tuple; $f.ok = ok; $f.s = s; $f.s$1 = s$1; $f.x = x; $f.y = y; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.GetAt = GetAt;
	impl = function(x, y) {
		var ratio, x, y;
		ratio = $clone($clone($clone(js.Global(), js.Value).Get("window"), js.Value).Get("devicePixelRatio"), js.Value).Float();
		if (ratio === 0) {
			ratio = 1;
		}
		return ratio;
	};
	pos.init("github.com/hajimehoshi/ebiten/internal/devicescale", [{prop: "x", name: "x", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "y", name: "y", embedded: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = sync.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		m = new sync.Mutex.ptr(0, 0);
		cache = $makeMap(pos.keyFor, []);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["log"] = (function() {
	var $pkg = {}, $init, fmt, nosync, io, os, runtime, time, Logger, sliceType, arrayType, ptrType, sliceType$1, ptrType$1, std, New, itoa, Fatal;
	fmt = $packages["fmt"];
	nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
	io = $packages["io"];
	os = $packages["os"];
	runtime = $packages["runtime"];
	time = $packages["time"];
	Logger = $pkg.Logger = $newType(0, $kindStruct, "log.Logger", true, "log", true, function(mu_, prefix_, flag_, out_, buf_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.mu = new nosync.Mutex.ptr(false);
			this.prefix = "";
			this.flag = 0;
			this.out = $ifaceNil;
			this.buf = sliceType.nil;
			return;
		}
		this.mu = mu_;
		this.prefix = prefix_;
		this.flag = flag_;
		this.out = out_;
		this.buf = buf_;
	});
	sliceType = $sliceType($Uint8);
	arrayType = $arrayType($Uint8, 20);
	ptrType = $ptrType(sliceType);
	sliceType$1 = $sliceType($emptyInterface);
	ptrType$1 = $ptrType(Logger);
	New = function(out, prefix, flag) {
		var flag, out, prefix;
		return new Logger.ptr(new nosync.Mutex.ptr(false), prefix, flag, out, sliceType.nil);
	};
	$pkg.New = New;
	Logger.ptr.prototype.SetOutput = function(w) {
		var l, w, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		l = this;
		l.mu.Lock();
		$deferred.push([$methodVal(l.mu, "Unlock"), []]);
		l.out = w;
		/* */ } catch(err) { $err = err; } finally { $callDeferred($deferred, $err); }
	};
	Logger.prototype.SetOutput = function(w) { return this.$val.SetOutput(w); };
	itoa = function(buf, i, wid) {
		var _q, b, bp, buf, i, q, wid;
		b = arrayType.zero();
		bp = 19;
		while (true) {
			if (!(i >= 10 || wid > 1)) { break; }
			wid = wid - (1) >> 0;
			q = (_q = i / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			((bp < 0 || bp >= b.length) ? ($throwRuntimeError("index out of range"), undefined) : b[bp] = ((((48 + i >> 0) - ($imul(q, 10)) >> 0) << 24 >>> 24)));
			bp = bp - (1) >> 0;
			i = q;
		}
		((bp < 0 || bp >= b.length) ? ($throwRuntimeError("index out of range"), undefined) : b[bp] = (((48 + i >> 0) << 24 >>> 24)));
		buf.$set($appendSlice(buf.$get(), $subslice(new sliceType(b), bp)));
	};
	Logger.ptr.prototype.formatHeader = function(buf, t, file, line) {
		var _q, _r, _r$1, _tuple, _tuple$1, buf, day, file, hour, i, l, line, min, month, sec, short$1, t, year, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; buf = $f.buf; day = $f.day; file = $f.file; hour = $f.hour; i = $f.i; l = $f.l; line = $f.line; min = $f.min; month = $f.month; sec = $f.sec; short$1 = $f.short$1; t = $f.t; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		buf.$set($appendSlice(buf.$get(), l.prefix));
		/* */ if (!(((l.flag & 7) === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(((l.flag & 7) === 0))) { */ case 1:
			if (!(((l.flag & 32) === 0))) {
				time.Time.copy(t, $clone(t, time.Time).UTC());
			}
			/* */ if (!(((l.flag & 1) === 0))) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(((l.flag & 1) === 0))) { */ case 3:
				_r = $clone(t, time.Time).Date(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				year = _tuple[0];
				month = _tuple[1];
				day = _tuple[2];
				itoa(buf, year, 4);
				buf.$set($append(buf.$get(), 47));
				itoa(buf, ((month >> 0)), 2);
				buf.$set($append(buf.$get(), 47));
				itoa(buf, day, 2);
				buf.$set($append(buf.$get(), 32));
			/* } */ case 4:
			/* */ if (!(((l.flag & 6) === 0))) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (!(((l.flag & 6) === 0))) { */ case 6:
				_r$1 = $clone(t, time.Time).Clock(); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple$1 = _r$1;
				hour = _tuple$1[0];
				min = _tuple$1[1];
				sec = _tuple$1[2];
				itoa(buf, hour, 2);
				buf.$set($append(buf.$get(), 58));
				itoa(buf, min, 2);
				buf.$set($append(buf.$get(), 58));
				itoa(buf, sec, 2);
				if (!(((l.flag & 4) === 0))) {
					buf.$set($append(buf.$get(), 46));
					itoa(buf, (_q = $clone(t, time.Time).Nanosecond() / 1000, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")), 6);
				}
				buf.$set($append(buf.$get(), 32));
			/* } */ case 7:
		/* } */ case 2:
		if (!(((l.flag & 24) === 0))) {
			if (!(((l.flag & 16) === 0))) {
				short$1 = file;
				i = file.length - 1 >> 0;
				while (true) {
					if (!(i > 0)) { break; }
					if (file.charCodeAt(i) === 47) {
						short$1 = $substring(file, (i + 1 >> 0));
						break;
					}
					i = i - (1) >> 0;
				}
				file = short$1;
			}
			buf.$set($appendSlice(buf.$get(), file));
			buf.$set($append(buf.$get(), 58));
			itoa(buf, line, -1);
			buf.$set($appendSlice(buf.$get(), ": "));
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.formatHeader }; } $f._q = _q; $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.buf = buf; $f.day = day; $f.file = file; $f.hour = hour; $f.i = i; $f.l = l; $f.line = line; $f.min = min; $f.month = month; $f.sec = sec; $f.short$1 = short$1; $f.t = t; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;
	};
	Logger.prototype.formatHeader = function(buf, t, file, line) { return this.$val.formatHeader(buf, t, file, line); };
	Logger.ptr.prototype.Output = function(calldepth, s) {
		var _r, _tuple, _tuple$1, calldepth, err, file, l, line, now, ok, s, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; calldepth = $f.calldepth; err = $f.err; file = $f.file; l = $f.l; line = $f.line; now = $f.now; ok = $f.ok; s = $f.s; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		l = this;
		now = $clone(time.Now(), time.Time);
		file = "";
		line = 0;
		l.mu.Lock();
		$deferred.push([$methodVal(l.mu, "Unlock"), []]);
		if (!(((l.flag & 24) === 0))) {
			l.mu.Unlock();
			ok = false;
			_tuple = runtime.Caller(calldepth);
			file = _tuple[1];
			line = _tuple[2];
			ok = _tuple[3];
			if (!ok) {
				file = "???";
				line = 0;
			}
			l.mu.Lock();
		}
		l.buf = $subslice(l.buf, 0, 0);
		$r = l.formatHeader((l.$ptr_buf || (l.$ptr_buf = new ptrType(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, l))), $clone(now, time.Time), file, line); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		l.buf = $appendSlice(l.buf, s);
		if ((s.length === 0) || !((s.charCodeAt((s.length - 1 >> 0)) === 10))) {
			l.buf = $append(l.buf, 10);
		}
		_r = l.out.Write(l.buf); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$1 = _r;
		err = _tuple$1[1];
		$s = -1; return err;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.Output }; } $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.calldepth = calldepth; $f.err = err; $f.file = file; $f.l = l; $f.line = line; $f.now = now; $f.ok = ok; $f.s = s; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Logger.prototype.Output = function(calldepth, s) { return this.$val.Output(calldepth, s); };
	Logger.ptr.prototype.Printf = function(format, v) {
		var _arg, _r, _r$1, format, l, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _r = $f._r; _r$1 = $f._r$1; format = $f.format; l = $f.l; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = fmt.Sprintf(format, v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg = _r;
		_r$1 = l.Output(2, _arg); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.Printf }; } $f._arg = _arg; $f._r = _r; $f._r$1 = _r$1; $f.format = format; $f.l = l; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Logger.prototype.Printf = function(format, v) { return this.$val.Printf(format, v); };
	Logger.ptr.prototype.Print = function(v) {
		var _arg, _r, _r$1, l, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _r = $f._r; _r$1 = $f._r$1; l = $f.l; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = fmt.Sprint(v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg = _r;
		_r$1 = l.Output(2, _arg); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.Print }; } $f._arg = _arg; $f._r = _r; $f._r$1 = _r$1; $f.l = l; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Logger.prototype.Print = function(v) { return this.$val.Print(v); };
	Logger.ptr.prototype.Println = function(v) {
		var _arg, _r, _r$1, l, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _r = $f._r; _r$1 = $f._r$1; l = $f.l; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = fmt.Sprintln(v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg = _r;
		_r$1 = l.Output(2, _arg); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.Println }; } $f._arg = _arg; $f._r = _r; $f._r$1 = _r$1; $f.l = l; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Logger.prototype.Println = function(v) { return this.$val.Println(v); };
	Logger.ptr.prototype.Fatal = function(v) {
		var _arg, _r, _r$1, l, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _r = $f._r; _r$1 = $f._r$1; l = $f.l; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = fmt.Sprint(v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg = _r;
		_r$1 = l.Output(2, _arg); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		os.Exit(1);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.Fatal }; } $f._arg = _arg; $f._r = _r; $f._r$1 = _r$1; $f.l = l; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Logger.prototype.Fatal = function(v) { return this.$val.Fatal(v); };
	Logger.ptr.prototype.Fatalf = function(format, v) {
		var _arg, _r, _r$1, format, l, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _r = $f._r; _r$1 = $f._r$1; format = $f.format; l = $f.l; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = fmt.Sprintf(format, v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg = _r;
		_r$1 = l.Output(2, _arg); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		os.Exit(1);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.Fatalf }; } $f._arg = _arg; $f._r = _r; $f._r$1 = _r$1; $f.format = format; $f.l = l; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Logger.prototype.Fatalf = function(format, v) { return this.$val.Fatalf(format, v); };
	Logger.ptr.prototype.Fatalln = function(v) {
		var _arg, _r, _r$1, l, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _r = $f._r; _r$1 = $f._r$1; l = $f.l; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = fmt.Sprintln(v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg = _r;
		_r$1 = l.Output(2, _arg); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		os.Exit(1);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.Fatalln }; } $f._arg = _arg; $f._r = _r; $f._r$1 = _r$1; $f.l = l; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Logger.prototype.Fatalln = function(v) { return this.$val.Fatalln(v); };
	Logger.ptr.prototype.Panic = function(v) {
		var _r, _r$1, l, s, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; l = $f.l; s = $f.s; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = fmt.Sprint(v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		s = _r;
		_r$1 = l.Output(2, s); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$panic(new $String(s));
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.Panic }; } $f._r = _r; $f._r$1 = _r$1; $f.l = l; $f.s = s; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Logger.prototype.Panic = function(v) { return this.$val.Panic(v); };
	Logger.ptr.prototype.Panicf = function(format, v) {
		var _r, _r$1, format, l, s, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; format = $f.format; l = $f.l; s = $f.s; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = fmt.Sprintf(format, v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		s = _r;
		_r$1 = l.Output(2, s); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$panic(new $String(s));
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.Panicf }; } $f._r = _r; $f._r$1 = _r$1; $f.format = format; $f.l = l; $f.s = s; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Logger.prototype.Panicf = function(format, v) { return this.$val.Panicf(format, v); };
	Logger.ptr.prototype.Panicln = function(v) {
		var _r, _r$1, l, s, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; l = $f.l; s = $f.s; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		l = this;
		_r = fmt.Sprintln(v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		s = _r;
		_r$1 = l.Output(2, s); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		$panic(new $String(s));
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Logger.ptr.prototype.Panicln }; } $f._r = _r; $f._r$1 = _r$1; $f.l = l; $f.s = s; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Logger.prototype.Panicln = function(v) { return this.$val.Panicln(v); };
	Logger.ptr.prototype.Flags = function() {
		var l, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		l = this;
		l.mu.Lock();
		$deferred.push([$methodVal(l.mu, "Unlock"), []]);
		return l.flag;
		/* */ } catch(err) { $err = err; return 0; } finally { $callDeferred($deferred, $err); }
	};
	Logger.prototype.Flags = function() { return this.$val.Flags(); };
	Logger.ptr.prototype.SetFlags = function(flag) {
		var flag, l, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		l = this;
		l.mu.Lock();
		$deferred.push([$methodVal(l.mu, "Unlock"), []]);
		l.flag = flag;
		/* */ } catch(err) { $err = err; } finally { $callDeferred($deferred, $err); }
	};
	Logger.prototype.SetFlags = function(flag) { return this.$val.SetFlags(flag); };
	Logger.ptr.prototype.Prefix = function() {
		var l, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		l = this;
		l.mu.Lock();
		$deferred.push([$methodVal(l.mu, "Unlock"), []]);
		return l.prefix;
		/* */ } catch(err) { $err = err; return ""; } finally { $callDeferred($deferred, $err); }
	};
	Logger.prototype.Prefix = function() { return this.$val.Prefix(); };
	Logger.ptr.prototype.SetPrefix = function(prefix) {
		var l, prefix, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		l = this;
		l.mu.Lock();
		$deferred.push([$methodVal(l.mu, "Unlock"), []]);
		l.prefix = prefix;
		/* */ } catch(err) { $err = err; } finally { $callDeferred($deferred, $err); }
	};
	Logger.prototype.SetPrefix = function(prefix) { return this.$val.SetPrefix(prefix); };
	Logger.ptr.prototype.Writer = function() {
		var l, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		l = this;
		l.mu.Lock();
		$deferred.push([$methodVal(l.mu, "Unlock"), []]);
		return l.out;
		/* */ } catch(err) { $err = err; return $ifaceNil; } finally { $callDeferred($deferred, $err); }
	};
	Logger.prototype.Writer = function() { return this.$val.Writer(); };
	Fatal = function(v) {
		var _arg, _r, _r$1, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _r = $f._r; _r$1 = $f._r$1; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = fmt.Sprint(v); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg = _r;
		_r$1 = std.Output(2, _arg); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		os.Exit(1);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Fatal }; } $f._arg = _arg; $f._r = _r; $f._r$1 = _r$1; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Fatal = Fatal;
	ptrType$1.methods = [{prop: "SetOutput", name: "SetOutput", pkg: "", typ: $funcType([io.Writer], [], false)}, {prop: "formatHeader", name: "formatHeader", pkg: "log", typ: $funcType([ptrType, time.Time, $String, $Int], [], false)}, {prop: "Output", name: "Output", pkg: "", typ: $funcType([$Int, $String], [$error], false)}, {prop: "Printf", name: "Printf", pkg: "", typ: $funcType([$String, sliceType$1], [], true)}, {prop: "Print", name: "Print", pkg: "", typ: $funcType([sliceType$1], [], true)}, {prop: "Println", name: "Println", pkg: "", typ: $funcType([sliceType$1], [], true)}, {prop: "Fatal", name: "Fatal", pkg: "", typ: $funcType([sliceType$1], [], true)}, {prop: "Fatalf", name: "Fatalf", pkg: "", typ: $funcType([$String, sliceType$1], [], true)}, {prop: "Fatalln", name: "Fatalln", pkg: "", typ: $funcType([sliceType$1], [], true)}, {prop: "Panic", name: "Panic", pkg: "", typ: $funcType([sliceType$1], [], true)}, {prop: "Panicf", name: "Panicf", pkg: "", typ: $funcType([$String, sliceType$1], [], true)}, {prop: "Panicln", name: "Panicln", pkg: "", typ: $funcType([sliceType$1], [], true)}, {prop: "Flags", name: "Flags", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "SetFlags", name: "SetFlags", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Prefix", name: "Prefix", pkg: "", typ: $funcType([], [$String], false)}, {prop: "SetPrefix", name: "SetPrefix", pkg: "", typ: $funcType([$String], [], false)}, {prop: "Writer", name: "Writer", pkg: "", typ: $funcType([], [io.Writer], false)}];
	Logger.init("log", [{prop: "mu", name: "mu", embedded: false, exported: false, typ: nosync.Mutex, tag: ""}, {prop: "prefix", name: "prefix", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "flag", name: "flag", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "out", name: "out", embedded: false, exported: false, typ: io.Writer, tag: ""}, {prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = fmt.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = nosync.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = os.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		std = New(os.Stderr, "", 3);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/internal/uidriver/js"] = (function() {
	var $pkg = {}, $init, devicescale, driver, image, log, runtime, strconv, js, unicode, pos, gamePad, Input, UserInterface, sliceType, arrayType, arrayType$1, arrayType$2, sliceType$1, ptrType, sliceType$2, sliceType$3, sliceType$4, structType, ptrType$1, mapType, mapType$1, mapType$2, sliceType$5, chanType, codeToMouseButton, keyToCodes, keyCodeToKeyEdge, canvas, theUI, window, document, requestAnimationFrame, setTimeout, init, Get, init$1;
	devicescale = $packages["github.com/hajimehoshi/ebiten/internal/devicescale"];
	driver = $packages["github.com/hajimehoshi/ebiten/internal/driver"];
	image = $packages["image"];
	log = $packages["log"];
	runtime = $packages["runtime"];
	strconv = $packages["strconv"];
	js = $packages["syscall/js"];
	unicode = $packages["unicode"];
	pos = $pkg.pos = $newType(0, $kindStruct, "js.pos", true, "github.com/hajimehoshi/ebiten/internal/uidriver/js", false, function(X_, Y_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.X = 0;
			this.Y = 0;
			return;
		}
		this.X = X_;
		this.Y = Y_;
	});
	gamePad = $pkg.gamePad = $newType(0, $kindStruct, "js.gamePad", true, "github.com/hajimehoshi/ebiten/internal/uidriver/js", false, function(valid_, axisNum_, axes_, buttonNum_, buttonPressed_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.valid = false;
			this.axisNum = 0;
			this.axes = arrayType.zero();
			this.buttonNum = 0;
			this.buttonPressed = arrayType$1.zero();
			return;
		}
		this.valid = valid_;
		this.axisNum = axisNum_;
		this.axes = axes_;
		this.buttonNum = buttonNum_;
		this.buttonPressed = buttonPressed_;
	});
	Input = $pkg.Input = $newType(0, $kindStruct, "js.Input", true, "github.com/hajimehoshi/ebiten/internal/uidriver/js", true, function(keyPressed_, keyPressedEdge_, mouseButtonPressed_, cursorX_, cursorY_, wheelX_, wheelY_, gamepads_, touches_, runeBuffer_, ui_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.keyPressed = false;
			this.keyPressedEdge = false;
			this.mouseButtonPressed = false;
			this.cursorX = 0;
			this.cursorY = 0;
			this.wheelX = 0;
			this.wheelY = 0;
			this.gamepads = arrayType$2.zero();
			this.touches = false;
			this.runeBuffer = sliceType$1.nil;
			this.ui = ptrType.nil;
			return;
		}
		this.keyPressed = keyPressed_;
		this.keyPressedEdge = keyPressedEdge_;
		this.mouseButtonPressed = mouseButtonPressed_;
		this.cursorX = cursorX_;
		this.cursorY = cursorY_;
		this.wheelX = wheelX_;
		this.wheelY = wheelY_;
		this.gamepads = gamepads_;
		this.touches = touches_;
		this.runeBuffer = runeBuffer_;
		this.ui = ui_;
	});
	UserInterface = $pkg.UserInterface = $newType(0, $kindStruct, "js.UserInterface", true, "github.com/hajimehoshi/ebiten/internal/uidriver/js", true, function(width_, height_, scale_, fullscreen_, runnableInBackground_, vsync_, sizeChanged_, windowFocus_, pageVisible_, contextLost_, lastActualScale_, context_, input_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.width = 0;
			this.height = 0;
			this.scale = 0;
			this.fullscreen = false;
			this.runnableInBackground = false;
			this.vsync = false;
			this.sizeChanged = false;
			this.windowFocus = false;
			this.pageVisible = false;
			this.contextLost = false;
			this.lastActualScale = 0;
			this.context = $ifaceNil;
			this.input = new Input.ptr(false, false, false, 0, 0, 0, 0, arrayType$2.zero(), false, sliceType$1.nil, ptrType.nil);
			return;
		}
		this.width = width_;
		this.height = height_;
		this.scale = scale_;
		this.fullscreen = fullscreen_;
		this.runnableInBackground = runnableInBackground_;
		this.vsync = vsync_;
		this.sizeChanged = sizeChanged_;
		this.windowFocus = windowFocus_;
		this.pageVisible = pageVisible_;
		this.contextLost = contextLost_;
		this.lastActualScale = lastActualScale_;
		this.context = context_;
		this.input = input_;
	});
	sliceType = $sliceType($String);
	arrayType = $arrayType($Float64, 16);
	arrayType$1 = $arrayType($Bool, 256);
	arrayType$2 = $arrayType(gamePad, 16);
	sliceType$1 = $sliceType($Int32);
	ptrType = $ptrType(UserInterface);
	sliceType$2 = $sliceType($Int);
	sliceType$3 = $sliceType($emptyInterface);
	sliceType$4 = $sliceType(js.Value);
	structType = $structType("", []);
	ptrType$1 = $ptrType(Input);
	mapType = $mapType($String, $Bool);
	mapType$1 = $mapType($Int, $Bool);
	mapType$2 = $mapType($Int, pos);
	sliceType$5 = $sliceType(image.Image);
	chanType = $chanType($error, false, true);
	Input.ptr.prototype.CursorPosition = function() {
		var _r, _tuple, i, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; i = $f.i; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = 0;
		y = 0;
		i = this;
		_r = i.ui.adjustPosition(i.cursorX, i.cursorY); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		x = _tuple[0];
		y = _tuple[1];
		$s = -1; return [x, y];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Input.ptr.prototype.CursorPosition }; } $f._r = _r; $f._tuple = _tuple; $f.i = i; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Input.prototype.CursorPosition = function() { return this.$val.CursorPosition(); };
	Input.ptr.prototype.GamepadIDs = function() {
		var _i, _ref, g, i, id, r;
		i = this;
		if (false) {
			return sliceType$2.nil;
		}
		r = new sliceType$2([]);
		_ref = i.gamepads;
		_i = 0;
		while (true) {
			if (!(_i < 16)) { break; }
			id = _i;
			g = $clone(((_i < 0 || _i >= _ref.length) ? ($throwRuntimeError("index out of range"), undefined) : _ref[_i]), gamePad);
			if (g.valid) {
				r = $append(r, id);
			}
			_i++;
		}
		return r;
	};
	Input.prototype.GamepadIDs = function() { return this.$val.GamepadIDs(); };
	Input.ptr.prototype.GamepadAxisNum = function(id) {
		var i, id, x;
		i = this;
		if (16 <= id) {
			return 0;
		}
		return (x = i.gamepads, ((id < 0 || id >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[id])).axisNum;
	};
	Input.prototype.GamepadAxisNum = function(id) { return this.$val.GamepadAxisNum(id); };
	Input.ptr.prototype.GamepadAxis = function(id, axis) {
		var axis, i, id, x, x$1;
		i = this;
		if (16 <= id) {
			return 0;
		}
		return (x = (x$1 = i.gamepads, ((id < 0 || id >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[id])).axes, ((axis < 0 || axis >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[axis]));
	};
	Input.prototype.GamepadAxis = function(id, axis) { return this.$val.GamepadAxis(id, axis); };
	Input.ptr.prototype.GamepadButtonNum = function(id) {
		var i, id, x;
		i = this;
		if (16 <= id) {
			return 0;
		}
		return (x = i.gamepads, ((id < 0 || id >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[id])).buttonNum;
	};
	Input.prototype.GamepadButtonNum = function(id) { return this.$val.GamepadButtonNum(id); };
	Input.ptr.prototype.IsGamepadButtonPressed = function(id, button) {
		var button, i, id, x, x$1;
		i = this;
		if (16 <= id) {
			return false;
		}
		return (x = (x$1 = i.gamepads, ((id < 0 || id >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[id])).buttonPressed, ((button < 0 || button >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[button]));
	};
	Input.prototype.IsGamepadButtonPressed = function(id, button) { return this.$val.IsGamepadButtonPressed(id, button); };
	Input.ptr.prototype.TouchIDs = function() {
		var _entry, _i, _keys, _ref, i, id, ids;
		i = this;
		if ($keys(i.touches).length === 0) {
			return sliceType$2.nil;
		}
		ids = sliceType$2.nil;
		_ref = i.touches;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			id = _entry.k;
			ids = $append(ids, id);
			_i++;
		}
		return ids;
	};
	Input.prototype.TouchIDs = function() { return this.$val.TouchIDs(); };
	Input.ptr.prototype.TouchPosition = function(id) {
		var _entry, _i, _keys, _r, _ref, _tmp, _tmp$1, _tuple, i, id, pos$1, tid, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _r = $f._r; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; i = $f.i; id = $f.id; pos$1 = $f.pos$1; tid = $f.tid; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x = 0;
		y = 0;
		i = this;
		_ref = i.touches;
		_i = 0;
		_keys = $keys(_ref);
		/* while (true) { */ case 1:
			/* if (!(_i < _keys.length)) { break; } */ if(!(_i < _keys.length)) { $s = 2; continue; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				/* continue; */ $s = 1; continue;
			}
			tid = _entry.k;
			pos$1 = $clone(_entry.v, pos);
			/* */ if (id === tid) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (id === tid) { */ case 3:
				_r = i.ui.adjustPosition(pos$1.X, pos$1.Y); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				x = _tuple[0];
				y = _tuple[1];
				$s = -1; return [x, y];
			/* } */ case 4:
			_i++;
		/* } */ $s = 1; continue; case 2:
		_tmp = 0;
		_tmp$1 = 0;
		x = _tmp;
		y = _tmp$1;
		$s = -1; return [x, y];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Input.ptr.prototype.TouchPosition }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._r = _r; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.i = i; $f.id = id; $f.pos$1 = pos$1; $f.tid = tid; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Input.prototype.TouchPosition = function(id) { return this.$val.TouchPosition(id); };
	Input.ptr.prototype.RuneBuffer = function() {
		var i;
		i = this;
		return i.runeBuffer;
	};
	Input.prototype.RuneBuffer = function() { return this.$val.RuneBuffer(); };
	Input.ptr.prototype.ResetForFrame = function() {
		var i;
		i = this;
		i.runeBuffer = sliceType$1.nil;
		i.wheelX = 0;
		i.wheelY = 0;
	};
	Input.prototype.ResetForFrame = function() { return this.$val.ResetForFrame(); };
	Input.ptr.prototype.IsKeyPressed = function(key) {
		var _entry, _entry$1, _entry$2, _entry$3, _i, _i$1, _keys, _ref, _ref$1, c, c$1, i, k, key;
		i = this;
		if (!(i.keyPressed === false)) {
			_ref = (_entry = keyToCodes[driver.Key.keyFor(key)], _entry !== undefined ? _entry.v : sliceType.nil);
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if ((_entry$1 = i.keyPressed[$String.keyFor(c)], _entry$1 !== undefined ? _entry$1.v : false)) {
					return true;
				}
				_i++;
			}
		}
		if (!(i.keyPressedEdge === false)) {
			_ref$1 = keyCodeToKeyEdge;
			_i$1 = 0;
			_keys = $keys(_ref$1);
			while (true) {
				if (!(_i$1 < _keys.length)) { break; }
				_entry$2 = _ref$1[_keys[_i$1]];
				if (_entry$2 === undefined) {
					_i$1++;
					continue;
				}
				c$1 = _entry$2.k;
				k = _entry$2.v;
				if (!((k === key))) {
					_i$1++;
					continue;
				}
				if ((_entry$3 = i.keyPressedEdge[$Int.keyFor(c$1)], _entry$3 !== undefined ? _entry$3.v : false)) {
					return true;
				}
				_i$1++;
			}
		}
		return false;
	};
	Input.prototype.IsKeyPressed = function(key) { return this.$val.IsKeyPressed(key); };
	Input.ptr.prototype.IsMouseButtonPressed = function(button) {
		var _entry, _entry$1, _i, _keys, _ref, b, button, c, i;
		i = this;
		if (i.mouseButtonPressed === false) {
			i.mouseButtonPressed = $makeMap($Int.keyFor, []);
		}
		_ref = codeToMouseButton;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			c = _entry.k;
			b = _entry.v;
			if (!((b === button))) {
				_i++;
				continue;
			}
			if ((_entry$1 = i.mouseButtonPressed[$Int.keyFor(c)], _entry$1 !== undefined ? _entry$1.v : false)) {
				return true;
			}
			_i++;
		}
		return false;
	};
	Input.prototype.IsMouseButtonPressed = function(button) { return this.$val.IsMouseButtonPressed(button); };
	Input.ptr.prototype.Wheel = function() {
		var _tmp, _tmp$1, i, xoff, yoff;
		xoff = 0;
		yoff = 0;
		i = this;
		_tmp = i.wheelX;
		_tmp$1 = i.wheelY;
		xoff = _tmp;
		yoff = _tmp$1;
		return [xoff, yoff];
	};
	Input.prototype.Wheel = function() { return this.$val.Wheel(); };
	Input.ptr.prototype.keyDown = function(code) {
		var _key, code, i;
		i = this;
		if (i.keyPressed === false) {
			i.keyPressed = $makeMap($String.keyFor, []);
		}
		_key = code; (i.keyPressed || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: true };
	};
	Input.prototype.keyDown = function(code) { return this.$val.keyDown(code); };
	Input.ptr.prototype.keyUp = function(code) {
		var _key, code, i;
		i = this;
		if (i.keyPressed === false) {
			i.keyPressed = $makeMap($String.keyFor, []);
		}
		_key = code; (i.keyPressed || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: false };
	};
	Input.prototype.keyUp = function(code) { return this.$val.keyUp(code); };
	Input.ptr.prototype.keyDownEdge = function(code) {
		var _key, code, i;
		i = this;
		if (i.keyPressedEdge === false) {
			i.keyPressedEdge = $makeMap($Int.keyFor, []);
		}
		_key = code; (i.keyPressedEdge || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key)] = { k: _key, v: true };
	};
	Input.prototype.keyDownEdge = function(code) { return this.$val.keyDownEdge(code); };
	Input.ptr.prototype.keyUpEdge = function(code) {
		var _key, code, i;
		i = this;
		if (i.keyPressedEdge === false) {
			i.keyPressedEdge = $makeMap($Int.keyFor, []);
		}
		_key = code; (i.keyPressedEdge || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key)] = { k: _key, v: false };
	};
	Input.prototype.keyUpEdge = function(code) { return this.$val.keyUpEdge(code); };
	Input.ptr.prototype.mouseDown = function(code) {
		var _key, code, i;
		i = this;
		if (i.mouseButtonPressed === false) {
			i.mouseButtonPressed = $makeMap($Int.keyFor, []);
		}
		_key = code; (i.mouseButtonPressed || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key)] = { k: _key, v: true };
	};
	Input.prototype.mouseDown = function(code) { return this.$val.mouseDown(code); };
	Input.ptr.prototype.mouseUp = function(code) {
		var _key, code, i;
		i = this;
		if (i.mouseButtonPressed === false) {
			i.mouseButtonPressed = $makeMap($Int.keyFor, []);
		}
		_key = code; (i.mouseButtonPressed || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key)] = { k: _key, v: false };
	};
	Input.prototype.mouseUp = function(code) { return this.$val.mouseUp(code); };
	Input.ptr.prototype.setMouseCursor = function(x, y) {
		var _tmp, _tmp$1, i, x, y;
		i = this;
		_tmp = x;
		_tmp$1 = y;
		i.cursorX = _tmp;
		i.cursorY = _tmp$1;
	};
	Input.prototype.setMouseCursor = function(x, y) { return this.$val.setMouseCursor(x, y); };
	Input.ptr.prototype.UpdateGamepads = function() {
		var _r, a, axes, axesNum, b, buttons, buttonsNum, gamepad, gamepads, i, id, l, nav, x, x$1, x$10, x$11, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; axes = $f.axes; axesNum = $f.axesNum; b = $f.b; buttons = $f.buttons; buttonsNum = $f.buttonsNum; gamepad = $f.gamepad; gamepads = $f.gamepads; i = $f.i; id = $f.id; l = $f.l; nav = $f.nav; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		nav = $clone($clone(js.Global(), js.Value).Get("navigator"), js.Value);
		if ($equal($clone(nav, js.Value).Get("getGamepads"), js.Undefined(), js.Value)) {
			$s = -1; return;
		}
		_r = $clone(nav, js.Value).Call("getGamepads", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		gamepads = $clone(_r, js.Value);
		l = $clone($clone(gamepads, js.Value).Get("length"), js.Value).Int();
		id = 0;
		while (true) {
			if (!(id < l)) { break; }
			(x = i.gamepads, ((id < 0 || id >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[id])).valid = false;
			gamepad = $clone($clone(gamepads, js.Value).Index(id), js.Value);
			if ($equal(gamepad, js.Undefined(), js.Value) || $equal(gamepad, js.Null(), js.Value)) {
				id = id + (1) >> 0;
				continue;
			}
			(x$1 = i.gamepads, ((id < 0 || id >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[id])).valid = true;
			axes = $clone($clone(gamepad, js.Value).Get("axes"), js.Value);
			axesNum = $clone($clone(axes, js.Value).Get("length"), js.Value).Int();
			(x$2 = i.gamepads, ((id < 0 || id >= x$2.length) ? ($throwRuntimeError("index out of range"), undefined) : x$2[id])).axisNum = axesNum;
			a = 0;
			while (true) {
				if (!(a < 16)) { break; }
				if (axesNum <= a) {
					(x$3 = (x$4 = i.gamepads, ((id < 0 || id >= x$4.length) ? ($throwRuntimeError("index out of range"), undefined) : x$4[id])).axes, ((a < 0 || a >= x$3.length) ? ($throwRuntimeError("index out of range"), undefined) : x$3[a] = 0));
					a = a + (1) >> 0;
					continue;
				}
				(x$5 = (x$6 = i.gamepads, ((id < 0 || id >= x$6.length) ? ($throwRuntimeError("index out of range"), undefined) : x$6[id])).axes, ((a < 0 || a >= x$5.length) ? ($throwRuntimeError("index out of range"), undefined) : x$5[a] = $clone($clone(axes, js.Value).Index(a), js.Value).Float()));
				a = a + (1) >> 0;
			}
			buttons = $clone($clone(gamepad, js.Value).Get("buttons"), js.Value);
			buttonsNum = $clone($clone(buttons, js.Value).Get("length"), js.Value).Int();
			(x$7 = i.gamepads, ((id < 0 || id >= x$7.length) ? ($throwRuntimeError("index out of range"), undefined) : x$7[id])).buttonNum = buttonsNum;
			b = 0;
			while (true) {
				if (!(b < 256)) { break; }
				if (buttonsNum <= b) {
					(x$8 = (x$9 = i.gamepads, ((id < 0 || id >= x$9.length) ? ($throwRuntimeError("index out of range"), undefined) : x$9[id])).buttonPressed, ((b < 0 || b >= x$8.length) ? ($throwRuntimeError("index out of range"), undefined) : x$8[b] = false));
					b = b + (1) >> 0;
					continue;
				}
				(x$10 = (x$11 = i.gamepads, ((id < 0 || id >= x$11.length) ? ($throwRuntimeError("index out of range"), undefined) : x$11[id])).buttonPressed, ((b < 0 || b >= x$10.length) ? ($throwRuntimeError("index out of range"), undefined) : x$10[b] = $clone($clone($clone(buttons, js.Value).Index(b), js.Value).Get("pressed"), js.Value).Bool()));
				b = b + (1) >> 0;
			}
			id = id + (1) >> 0;
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Input.ptr.prototype.UpdateGamepads }; } $f._r = _r; $f.a = a; $f.axes = axes; $f.axesNum = axesNum; $f.b = b; $f.buttons = buttons; $f.buttonsNum = buttonsNum; $f.gamepad = gamepad; $f.gamepads = gamepads; $f.i = i; $f.id = id; $f.l = l; $f.nav = nav; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	Input.prototype.UpdateGamepads = function() { return this.$val.UpdateGamepads(); };
	Input.ptr.prototype.Update = function(e) {
		var _1, _entry, _entry$1, _entry$10, _entry$11, _entry$2, _entry$3, _entry$4, _entry$5, _entry$6, _entry$7, _entry$8, _entry$9, _r, _r$1, button, button$1, c, code, code$1, code$2, cs, e, i, r, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$10 = $f._entry$10; _entry$11 = $f._entry$11; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _entry$4 = $f._entry$4; _entry$5 = $f._entry$5; _entry$6 = $f._entry$6; _entry$7 = $f._entry$7; _entry$8 = $f._entry$8; _entry$9 = $f._entry$9; _r = $f._r; _r$1 = $f._r$1; button = $f.button; button$1 = $f.button$1; c = $f.c; code = $f.code; code$1 = $f.code$1; code$2 = $f.code$2; cs = $f.cs; e = $f.e; i = $f.i; r = $f.r; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
			_1 = $clone($clone(e, js.Value).Get("type"), js.Value).String();
			/* */ if (_1 === ("keydown")) { $s = 2; continue; }
			/* */ if (_1 === ("keypress")) { $s = 3; continue; }
			/* */ if (_1 === ("keyup")) { $s = 4; continue; }
			/* */ if (_1 === ("mousedown")) { $s = 5; continue; }
			/* */ if (_1 === ("mouseup")) { $s = 6; continue; }
			/* */ if (_1 === ("mousemove")) { $s = 7; continue; }
			/* */ if (_1 === ("wheel")) { $s = 8; continue; }
			/* */ if (_1 === ("touchstart") || _1 === ("touchend") || _1 === ("touchmove")) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_1 === ("keydown")) { */ case 2:
				c = $clone($clone(e, js.Value).Get("code"), js.Value);
				/* */ if ($equal(c, js.Undefined(), js.Value)) { $s = 11; continue; }
				/* */ $s = 12; continue;
				/* if ($equal(c, js.Undefined(), js.Value)) { */ case 11:
					code = $clone($clone(e, js.Value).Get("keyCode"), js.Value).Int();
					/* */ if (((_entry = keyCodeToKeyEdge[$Int.keyFor(code)], _entry !== undefined ? _entry.v : 0) === 99) || ((_entry$1 = keyCodeToKeyEdge[$Int.keyFor(code)], _entry$1 !== undefined ? _entry$1.v : 0) === 44) || ((_entry$2 = keyCodeToKeyEdge[$Int.keyFor(code)], _entry$2 !== undefined ? _entry$2.v : 0) === 81) || ((_entry$3 = keyCodeToKeyEdge[$Int.keyFor(code)], _entry$3 !== undefined ? _entry$3.v : 0) === 91) || ((_entry$4 = keyCodeToKeyEdge[$Int.keyFor(code)], _entry$4 !== undefined ? _entry$4.v : 0) === 39) || ((_entry$5 = keyCodeToKeyEdge[$Int.keyFor(code)], _entry$5 !== undefined ? _entry$5.v : 0) === 98)) { $s = 13; continue; }
					/* */ $s = 14; continue;
					/* if (((_entry = keyCodeToKeyEdge[$Int.keyFor(code)], _entry !== undefined ? _entry.v : 0) === 99) || ((_entry$1 = keyCodeToKeyEdge[$Int.keyFor(code)], _entry$1 !== undefined ? _entry$1.v : 0) === 44) || ((_entry$2 = keyCodeToKeyEdge[$Int.keyFor(code)], _entry$2 !== undefined ? _entry$2.v : 0) === 81) || ((_entry$3 = keyCodeToKeyEdge[$Int.keyFor(code)], _entry$3 !== undefined ? _entry$3.v : 0) === 91) || ((_entry$4 = keyCodeToKeyEdge[$Int.keyFor(code)], _entry$4 !== undefined ? _entry$4.v : 0) === 39) || ((_entry$5 = keyCodeToKeyEdge[$Int.keyFor(code)], _entry$5 !== undefined ? _entry$5.v : 0) === 98)) { */ case 13:
						_r = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 15; case 15: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						_r;
					/* } */ case 14:
					i.keyDownEdge(code);
					$s = -1; return;
				/* } */ case 12:
				cs = $clone(c, js.Value).String();
				/* */ if (cs === (x = (_entry$6 = keyToCodes[driver.Key.keyFor(99)], _entry$6 !== undefined ? _entry$6.v : sliceType.nil), (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) || cs === (x$1 = (_entry$7 = keyToCodes[driver.Key.keyFor(44)], _entry$7 !== undefined ? _entry$7.v : sliceType.nil), (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) || cs === (x$2 = (_entry$8 = keyToCodes[driver.Key.keyFor(81)], _entry$8 !== undefined ? _entry$8.v : sliceType.nil), (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0])) || cs === (x$3 = (_entry$9 = keyToCodes[driver.Key.keyFor(91)], _entry$9 !== undefined ? _entry$9.v : sliceType.nil), (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])) || cs === (x$4 = (_entry$10 = keyToCodes[driver.Key.keyFor(39)], _entry$10 !== undefined ? _entry$10.v : sliceType.nil), (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])) || cs === (x$5 = (_entry$11 = keyToCodes[driver.Key.keyFor(98)], _entry$11 !== undefined ? _entry$11.v : sliceType.nil), (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0]))) { $s = 16; continue; }
				/* */ $s = 17; continue;
				/* if (cs === (x = (_entry$6 = keyToCodes[driver.Key.keyFor(99)], _entry$6 !== undefined ? _entry$6.v : sliceType.nil), (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])) || cs === (x$1 = (_entry$7 = keyToCodes[driver.Key.keyFor(44)], _entry$7 !== undefined ? _entry$7.v : sliceType.nil), (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])) || cs === (x$2 = (_entry$8 = keyToCodes[driver.Key.keyFor(81)], _entry$8 !== undefined ? _entry$8.v : sliceType.nil), (0 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 0])) || cs === (x$3 = (_entry$9 = keyToCodes[driver.Key.keyFor(91)], _entry$9 !== undefined ? _entry$9.v : sliceType.nil), (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0])) || cs === (x$4 = (_entry$10 = keyToCodes[driver.Key.keyFor(39)], _entry$10 !== undefined ? _entry$10.v : sliceType.nil), (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0])) || cs === (x$5 = (_entry$11 = keyToCodes[driver.Key.keyFor(98)], _entry$11 !== undefined ? _entry$11.v : sliceType.nil), (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0]))) { */ case 16:
					_r$1 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 18; case 18: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_r$1;
				/* } */ case 17:
				i.keyDown(cs);
				$s = 10; continue;
			/* } else if (_1 === ("keypress")) { */ case 3:
				r = (($clone($clone(e, js.Value).Get("charCode"), js.Value).Int() >> 0));
				if (unicode.IsPrint(r)) {
					i.runeBuffer = $append(i.runeBuffer, r);
				}
				$s = 10; continue;
			/* } else if (_1 === ("keyup")) { */ case 4:
				if ($equal($clone(e, js.Value).Get("code"), js.Undefined(), js.Value)) {
					code$1 = $clone($clone(e, js.Value).Get("keyCode"), js.Value).Int();
					i.keyUpEdge(code$1);
					$s = -1; return;
				}
				code$2 = $clone($clone(e, js.Value).Get("code"), js.Value).String();
				i.keyUp(code$2);
				$s = 10; continue;
			/* } else if (_1 === ("mousedown")) { */ case 5:
				button = $clone($clone(e, js.Value).Get("button"), js.Value).Int();
				i.mouseDown(button);
				i.setMouseCursorFromEvent($clone(e, js.Value));
				$s = 10; continue;
			/* } else if (_1 === ("mouseup")) { */ case 6:
				button$1 = $clone($clone(e, js.Value).Get("button"), js.Value).Int();
				i.mouseUp(button$1);
				i.setMouseCursorFromEvent($clone(e, js.Value));
				$s = 10; continue;
			/* } else if (_1 === ("mousemove")) { */ case 7:
				i.setMouseCursorFromEvent($clone(e, js.Value));
				$s = 10; continue;
			/* } else if (_1 === ("wheel")) { */ case 8:
				i.wheelX = -$clone($clone(e, js.Value).Get("deltaX"), js.Value).Float();
				i.wheelY = -$clone($clone(e, js.Value).Get("deltaY"), js.Value).Float();
				$s = 10; continue;
			/* } else if (_1 === ("touchstart") || _1 === ("touchend") || _1 === ("touchmove")) { */ case 9:
				$r = i.updateTouches($clone(e, js.Value)); /* */ $s = 19; case 19: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 10:
		case 1:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Input.ptr.prototype.Update }; } $f._1 = _1; $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$10 = _entry$10; $f._entry$11 = _entry$11; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._entry$4 = _entry$4; $f._entry$5 = _entry$5; $f._entry$6 = _entry$6; $f._entry$7 = _entry$7; $f._entry$8 = _entry$8; $f._entry$9 = _entry$9; $f._r = _r; $f._r$1 = _r$1; $f.button = button; $f.button$1 = button$1; $f.c = c; $f.code = code; $f.code$1 = code$1; $f.code$2 = code$2; $f.cs = cs; $f.e = e; $f.i = i; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	Input.prototype.Update = function(e) { return this.$val.Update(e); };
	Input.ptr.prototype.setMouseCursorFromEvent = function(e) {
		var _tmp, _tmp$1, e, i, x, y;
		i = this;
		_tmp = $clone($clone(e, js.Value).Get("clientX"), js.Value).Int();
		_tmp$1 = $clone($clone(e, js.Value).Get("clientY"), js.Value).Int();
		x = _tmp;
		y = _tmp$1;
		i.setMouseCursor(x, y);
	};
	Input.prototype.setMouseCursorFromEvent = function(e) { return this.$val.setMouseCursorFromEvent(e); };
	Input.ptr.prototype.updateTouches = function(e) {
		var _key, _r, e, i, i$1, id, j, jj, ts, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _key = $f._key; _r = $f._r; e = $f.e; i = $f.i; i$1 = $f.i$1; id = $f.id; j = $f.j; jj = $f.jj; ts = $f.ts; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		j = $clone($clone(e, js.Value).Get("targetTouches"), js.Value);
		ts = $makeMap($Int.keyFor, []);
		i$1 = 0;
		/* while (true) { */ case 1:
			/* if (!(i$1 < $clone(j, js.Value).Length())) { break; } */ if(!(i$1 < $clone(j, js.Value).Length())) { $s = 2; continue; }
			_r = $clone(j, js.Value).Call("item", new sliceType$3([new $Int(i$1)])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			jj = $clone(_r, js.Value);
			id = $clone($clone(jj, js.Value).Get("identifier"), js.Value).Int();
			_key = id; (ts || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key)] = { k: _key, v: new pos.ptr($clone($clone(jj, js.Value).Get("clientX"), js.Value).Int(), $clone($clone(jj, js.Value).Get("clientY"), js.Value).Int()) };
			i$1 = i$1 + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		i.touches = ts;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Input.ptr.prototype.updateTouches }; } $f._key = _key; $f._r = _r; $f.e = e; $f.i = i; $f.i$1 = i$1; $f.id = id; $f.j = j; $f.jj = jj; $f.ts = ts; $f.$s = $s; $f.$r = $r; return $f;
	};
	Input.prototype.updateTouches = function(e) { return this.$val.updateTouches(e); };
	init = function() {
		theUI.input.ui = theUI;
	};
	Get = function() {
		return theUI;
	};
	$pkg.Get = Get;
	UserInterface.ptr.prototype.ScreenSizeInFullscreen = function() {
		var u;
		u = this;
		return [$clone($clone(window, js.Value).Get("innerWidth"), js.Value).Int(), $clone($clone(window, js.Value).Get("innerHeight"), js.Value).Int()];
	};
	UserInterface.prototype.ScreenSizeInFullscreen = function() { return this.$val.ScreenSizeInFullscreen(); };
	UserInterface.ptr.prototype.SetScreenSize = function(width, height) {
		var _r, height, u, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; height = $f.height; u = $f.u; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		_r = u.setScreenSize(width, height, u.scale, u.fullscreen); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.SetScreenSize }; } $f._r = _r; $f.height = height; $f.u = u; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.SetScreenSize = function(width, height) { return this.$val.SetScreenSize(width, height); };
	UserInterface.ptr.prototype.SetScreenScale = function(scale) {
		var _r, scale, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; scale = $f.scale; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		_r = u.setScreenSize(u.width, u.height, scale, u.fullscreen); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.SetScreenScale }; } $f._r = _r; $f.scale = scale; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.SetScreenScale = function(scale) { return this.$val.SetScreenScale(scale); };
	UserInterface.ptr.prototype.ScreenScale = function() {
		var u;
		u = this;
		return u.scale;
	};
	UserInterface.prototype.ScreenScale = function() { return this.$val.ScreenScale(); };
	UserInterface.ptr.prototype.SetFullscreen = function(fullscreen) {
		var _r, fullscreen, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; fullscreen = $f.fullscreen; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		_r = u.setScreenSize(u.width, u.height, u.scale, fullscreen); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.SetFullscreen }; } $f._r = _r; $f.fullscreen = fullscreen; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.SetFullscreen = function(fullscreen) { return this.$val.SetFullscreen(fullscreen); };
	UserInterface.ptr.prototype.IsFullscreen = function() {
		var u;
		u = this;
		return u.fullscreen;
	};
	UserInterface.prototype.IsFullscreen = function() { return this.$val.IsFullscreen(); };
	UserInterface.ptr.prototype.SetRunnableInBackground = function(runnableInBackground) {
		var runnableInBackground, u;
		u = this;
		u.runnableInBackground = runnableInBackground;
	};
	UserInterface.prototype.SetRunnableInBackground = function(runnableInBackground) { return this.$val.SetRunnableInBackground(runnableInBackground); };
	UserInterface.ptr.prototype.IsRunnableInBackground = function() {
		var u;
		u = this;
		return u.runnableInBackground;
	};
	UserInterface.prototype.IsRunnableInBackground = function() { return this.$val.IsRunnableInBackground(); };
	UserInterface.ptr.prototype.SetVsyncEnabled = function(enabled) {
		var enabled, u;
		u = this;
		u.vsync = enabled;
	};
	UserInterface.prototype.SetVsyncEnabled = function(enabled) { return this.$val.SetVsyncEnabled(enabled); };
	UserInterface.ptr.prototype.IsVsyncEnabled = function() {
		var u;
		u = this;
		return u.vsync;
	};
	UserInterface.prototype.IsVsyncEnabled = function() { return this.$val.IsVsyncEnabled(); };
	UserInterface.ptr.prototype.ScreenPadding = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, u, x0, x1, y0, y1;
		x0 = 0;
		y0 = 0;
		x1 = 0;
		y1 = 0;
		u = this;
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = 0;
		_tmp$3 = 0;
		x0 = _tmp;
		y0 = _tmp$1;
		x1 = _tmp$2;
		y1 = _tmp$3;
		return [x0, y0, x1, y1];
	};
	UserInterface.prototype.ScreenPadding = function() { return this.$val.ScreenPadding(); };
	UserInterface.ptr.prototype.adjustPosition = function(x, y) {
		var _r, rect, scale, u, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; rect = $f.rect; scale = $f.scale; u = $f.u; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		_r = $clone(canvas, js.Value).Call("getBoundingClientRect", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		rect = $clone(_r, js.Value);
		x = x - ($clone($clone(rect, js.Value).Get("left"), js.Value).Int()) >> 0;
		y = y - ($clone($clone(rect, js.Value).Get("top"), js.Value).Int()) >> 0;
		scale = u.getScale();
		$s = -1; return [(((x) / scale >> 0)), (((y) / scale >> 0))];
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.adjustPosition }; } $f._r = _r; $f.rect = rect; $f.scale = scale; $f.u = u; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.adjustPosition = function(x, y) { return this.$val.adjustPosition(x, y); };
	UserInterface.ptr.prototype.IsCursorVisible = function() {
		var u;
		u = this;
		return !($clone($clone($clone(canvas, js.Value).Get("style"), js.Value).Get("cursor"), js.Value).String() === "none");
	};
	UserInterface.prototype.IsCursorVisible = function() { return this.$val.IsCursorVisible(); };
	UserInterface.ptr.prototype.SetCursorVisible = function(visible) {
		var u, visible, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; u = $f.u; visible = $f.visible; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		/* */ if (visible) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (visible) { */ case 1:
			$r = $clone($clone(canvas, js.Value).Get("style"), js.Value).Set("cursor", new $String("auto")); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 3; continue;
		/* } else { */ case 2:
			$r = $clone($clone(canvas, js.Value).Get("style"), js.Value).Set("cursor", new $String("none")); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.SetCursorVisible }; } $f.u = u; $f.visible = visible; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.SetCursorVisible = function(visible) { return this.$val.SetCursorVisible(visible); };
	UserInterface.ptr.prototype.SetWindowTitle = function(title) {
		var title, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; title = $f.title; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		$r = $clone(document, js.Value).Set("title", new $String(title)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.SetWindowTitle }; } $f.title = title; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.SetWindowTitle = function(title) { return this.$val.SetWindowTitle(title); };
	UserInterface.ptr.prototype.SetWindowIcon = function(iconImages) {
		var iconImages, u;
		u = this;
	};
	UserInterface.prototype.SetWindowIcon = function(iconImages) { return this.$val.SetWindowIcon(iconImages); };
	UserInterface.ptr.prototype.IsWindowDecorated = function() {
		var u;
		u = this;
		return false;
	};
	UserInterface.prototype.IsWindowDecorated = function() { return this.$val.IsWindowDecorated(); };
	UserInterface.ptr.prototype.SetWindowDecorated = function(decorated) {
		var decorated, u;
		u = this;
	};
	UserInterface.prototype.SetWindowDecorated = function(decorated) { return this.$val.SetWindowDecorated(decorated); };
	UserInterface.ptr.prototype.IsWindowResizable = function() {
		var u;
		u = this;
		return false;
	};
	UserInterface.prototype.IsWindowResizable = function() { return this.$val.IsWindowResizable(); };
	UserInterface.ptr.prototype.SetWindowResizable = function(decorated) {
		var decorated, u;
		u = this;
	};
	UserInterface.prototype.SetWindowResizable = function(decorated) { return this.$val.SetWindowResizable(decorated); };
	UserInterface.ptr.prototype.DeviceScaleFactor = function() {
		var _r, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		_r = devicescale.GetAt(0, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.DeviceScaleFactor }; } $f._r = _r; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.DeviceScaleFactor = function() { return this.$val.DeviceScaleFactor(); };
	UserInterface.ptr.prototype.getScale = function() {
		var bh, body, bw, sh, sw, u;
		u = this;
		if (!u.fullscreen) {
			return u.scale;
		}
		body = $clone($clone(document, js.Value).Get("body"), js.Value);
		bw = $clone($clone(body, js.Value).Get("clientWidth"), js.Value).Float();
		bh = $clone($clone(body, js.Value).Get("clientHeight"), js.Value).Float();
		sw = bw / (u.width);
		sh = bh / (u.height);
		if (sw > sh) {
			return sh;
		}
		return sw;
	};
	UserInterface.prototype.getScale = function() { return this.$val.getScale(); };
	UserInterface.ptr.prototype.actualScreenScale = function() {
		var _r, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		_r = devicescale.GetAt(0, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return u.getScale() * _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.actualScreenScale }; } $f._r = _r; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.actualScreenScale = function() { return this.$val.actualScreenScale(); };
	UserInterface.ptr.prototype.updateSize = function() {
		var _r, a, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; a = $f.a; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		_r = u.actualScreenScale(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		a = _r;
		/* */ if (!((u.lastActualScale === a))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((u.lastActualScale === a))) { */ case 2:
			$r = u.updateScreenSize(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		u.lastActualScale = a;
		/* */ if (u.sizeChanged) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (u.sizeChanged) { */ case 5:
			u.sizeChanged = false;
			$r = u.context.SetSize(u.width, u.height, a); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.updateSize }; } $f._r = _r; $f.a = a; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.updateSize = function() { return this.$val.updateSize(); };
	UserInterface.ptr.prototype.suspended = function() {
		var u;
		u = this;
		return !u.runnableInBackground && (!u.windowFocus || !u.pageVisible);
	};
	UserInterface.prototype.suspended = function() { return this.$val.suspended(); };
	UserInterface.ptr.prototype.update = function() {
		var _r, err, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = [u];
		u[0] = this;
		/* */ if (u[0].suspended()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (u[0].suspended()) { */ case 1:
			$r = u[0].context.SuspendAudio(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		$r = u[0].context.ResumeAudio(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = u[0].input.UpdateGamepads(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = u[0].updateSize(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r = u[0].context.Update((function(u) { return function $b() {
			var $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			$r = u[0].updateSize(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f.$s = $s; $f.$r = $r; return $f;
		}; })(u)); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.update }; } $f._r = _r; $f.err = err; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.update = function() { return this.$val.update(); };
	UserInterface.ptr.prototype.loop = function(context) {
		var cf, ch, context, f, u;
		u = this;
		u.context = context;
		ch = new $Chan($error, 0);
		cf = new js.Func.ptr(new js.Value.ptr(null, false));
		f = (function $b(this$1, args) {
			var _r, _r$1, _r$2, _r$3, args, err, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; args = $f.args; err = $f.err; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (u.contextLost) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (u.contextLost) { */ case 1:
				_r = $clone(requestAnimationFrame, js.Value).Invoke(new sliceType$3([new cf.constructor.elem(cf)])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_r;
				$s = -1; return $ifaceNil;
			/* } */ case 2:
			_r$1 = u.update(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			err = _r$1;
			/* */ if (!($interfaceIsEqual(err, $ifaceNil))) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 5:
				$r = $send(ch, err); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$close(ch);
				$s = -1; return $ifaceNil;
			/* } */ case 6:
			/* */ if (u.vsync) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (u.vsync) { */ case 8:
				_r$2 = $clone(requestAnimationFrame, js.Value).Invoke(new sliceType$3([new cf.constructor.elem(cf)])); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$2;
				$s = 10; continue;
			/* } else { */ case 9:
				_r$3 = $clone(setTimeout, js.Value).Invoke(new sliceType$3([new cf.constructor.elem(cf), new $Int(0)])); /* */ $s = 12; case 12: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				_r$3;
			/* } */ case 10:
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.args = args; $f.err = err; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		});
		js.Func.copy(cf, js.FuncOf(f));
		$go((function $b() {
			var _r, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r = f(new js.Value.ptr(null, false), sliceType$4.nil); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
			$s = -1; return;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;
		}), []);
		return ch;
	};
	UserInterface.prototype.loop = function(context) { return this.$val.loop(context); };
	init$1 = function() {
		var _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$2, _r$20, _r$21, _r$22, _r$23, _r$24, _r$25, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, bodyStyle, canvasStyle, ch, htmlStyle, meta, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$2 = $f._r$2; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$23 = $f._r$23; _r$24 = $f._r$24; _r$25 = $f._r$25; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; bodyStyle = $f.bodyStyle; canvasStyle = $f.canvasStyle; ch = $f.ch; htmlStyle = $f.htmlStyle; meta = $f.meta; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$16 = $f.x$16; x$17 = $f.x$17; x$18 = $f.x$18; x$19 = $f.x$19; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ch = [ch];
		/* */ if ($equal($clone(document, js.Value).Get("body"), js.Null(), js.Value)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ($equal($clone(document, js.Value).Get("body"), js.Null(), js.Value)) { */ case 1:
			ch[0] = new $Chan(structType, 0);
			_r = $clone(window, js.Value).Call("addEventListener", new sliceType$3([new $String("load"), (x = js.FuncOf((function(ch) { return function(this$1, args) {
				var args, this$1;
				$close(ch[0]);
				return $ifaceNil;
			}; })(ch)), new x.constructor.elem(x))])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
			_r$1 = $recv(ch[0]); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$1[0];
		/* } */ case 2:
		_r$2 = $clone(window, js.Value).Call("addEventListener", new sliceType$3([new $String("focus"), (x$1 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var args, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; args = $f.args; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			theUI.windowFocus = true;
			/* */ if (theUI.suspended()) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (theUI.suspended()) { */ case 1:
				$r = theUI.context.SuspendAudio(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 3; continue;
			/* } else { */ case 2:
				$r = theUI.context.ResumeAudio(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 3:
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f.args = args; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$1.constructor.elem(x$1))])); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$2;
		_r$3 = $clone(window, js.Value).Call("addEventListener", new sliceType$3([new $String("blur"), (x$2 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var args, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; args = $f.args; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			theUI.windowFocus = false;
			/* */ if (theUI.suspended()) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (theUI.suspended()) { */ case 1:
				$r = theUI.context.SuspendAudio(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 3; continue;
			/* } else { */ case 2:
				$r = theUI.context.ResumeAudio(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 3:
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f.args = args; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$2.constructor.elem(x$2))])); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		_r$3;
		_r$4 = $clone(document, js.Value).Call("addEventListener", new sliceType$3([new $String("visibilitychange"), (x$3 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var args, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; args = $f.args; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			theUI.pageVisible = !$clone($clone(document, js.Value).Get("hidden"), js.Value).Bool();
			/* */ if (theUI.suspended()) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (theUI.suspended()) { */ case 1:
				$r = theUI.context.SuspendAudio(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 3; continue;
			/* } else { */ case 2:
				$r = theUI.context.ResumeAudio(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 3:
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f.args = args; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$3.constructor.elem(x$3))])); /* */ $s = 7; case 7: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_r$4;
		_r$5 = $clone(window, js.Value).Call("addEventListener", new sliceType$3([new $String("resize"), (x$4 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var args, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; args = $f.args; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			$r = theUI.updateScreenSize(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f.args = args; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$4.constructor.elem(x$4))])); /* */ $s = 8; case 8: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_r$5;
		_r$6 = $clone(document, js.Value).Call("createElement", new sliceType$3([new $String("meta")])); /* */ $s = 9; case 9: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		meta = $clone(_r$6, js.Value);
		$r = $clone(meta, js.Value).Set("name", new $String("viewport")); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(meta, js.Value).Set("content", new $String("width=device-width, initial-scale=1")); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$7 = $clone($clone(document, js.Value).Get("head"), js.Value).Call("appendChild", new sliceType$3([new meta.constructor.elem(meta)])); /* */ $s = 12; case 12: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		_r$7;
		_r$8 = $clone(document, js.Value).Call("createElement", new sliceType$3([new $String("canvas")])); /* */ $s = 13; case 13: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		js.Value.copy(canvas, _r$8);
		$r = $clone(canvas, js.Value).Set("width", new $Int(16)); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(canvas, js.Value).Set("height", new $Int(16)); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$9 = $clone($clone(document, js.Value).Get("body"), js.Value).Call("appendChild", new sliceType$3([new canvas.constructor.elem(canvas)])); /* */ $s = 16; case 16: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		_r$9;
		htmlStyle = $clone($clone($clone(document, js.Value).Get("documentElement"), js.Value).Get("style"), js.Value);
		$r = $clone(htmlStyle, js.Value).Set("height", new $String("100%")); /* */ $s = 17; case 17: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(htmlStyle, js.Value).Set("margin", new $String("0")); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(htmlStyle, js.Value).Set("padding", new $String("0")); /* */ $s = 19; case 19: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		bodyStyle = $clone($clone($clone(document, js.Value).Get("body"), js.Value).Get("style"), js.Value);
		$r = $clone(bodyStyle, js.Value).Set("backgroundColor", new $String("#000")); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(bodyStyle, js.Value).Set("position", new $String("relative")); /* */ $s = 21; case 21: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(bodyStyle, js.Value).Set("height", new $String("100%")); /* */ $s = 22; case 22: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(bodyStyle, js.Value).Set("margin", new $String("0")); /* */ $s = 23; case 23: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(bodyStyle, js.Value).Set("padding", new $String("0")); /* */ $s = 24; case 24: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(bodyStyle, js.Value).Set("display", new $String("flex")); /* */ $s = 25; case 25: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(bodyStyle, js.Value).Set("alignItems", new $String("center")); /* */ $s = 26; case 26: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(bodyStyle, js.Value).Set("justifyContent", new $String("center")); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$10 = $clone($clone(document, js.Value).Get("body"), js.Value).Call("addEventListener", new sliceType$3([new $String("click"), (x$5 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$10, args, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$10 = $f._r$10; args = $f.args; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r$10 = $clone(canvas, js.Value).Call("focus", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			_r$10;
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$10 = _r$10; $f.args = args; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$5.constructor.elem(x$5))])); /* */ $s = 28; case 28: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
		_r$10;
		canvasStyle = $clone($clone(canvas, js.Value).Get("style"), js.Value);
		$r = $clone(canvasStyle, js.Value).Set("position", new $String("absolute")); /* */ $s = 29; case 29: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$11 = $clone(canvas, js.Value).Call("setAttribute", new sliceType$3([new $String("tabindex"), new $Int(1)])); /* */ $s = 30; case 30: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
		_r$11;
		$r = $clone($clone(canvas, js.Value).Get("style"), js.Value).Set("outline", new $String("none")); /* */ $s = 31; case 31: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$12 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("keydown"), (x$6 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			$r = theUI.input.Update($clone(e, js.Value)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$6.constructor.elem(x$6))])); /* */ $s = 32; case 32: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
		_r$12;
		_r$13 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("keypress"), (x$7 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$13, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$13 = $f._r$13; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$13 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
			_r$13;
			$r = theUI.input.Update($clone(e, js.Value)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$13 = _r$13; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$7.constructor.elem(x$7))])); /* */ $s = 33; case 33: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
		_r$13;
		_r$14 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("keyup"), (x$8 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$14, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$14 = $f._r$14; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$14 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
			_r$14;
			$r = theUI.input.Update($clone(e, js.Value)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$14 = _r$14; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$8.constructor.elem(x$8))])); /* */ $s = 34; case 34: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
		_r$14;
		_r$15 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("mousedown"), (x$9 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$15, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$15 = $f._r$15; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$15 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
			_r$15;
			$r = theUI.input.Update($clone(e, js.Value)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$15 = _r$15; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$9.constructor.elem(x$9))])); /* */ $s = 35; case 35: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
		_r$15;
		_r$16 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("mouseup"), (x$10 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$16, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$16 = $f._r$16; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$16 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
			_r$16;
			$r = theUI.input.Update($clone(e, js.Value)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$16 = _r$16; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$10.constructor.elem(x$10))])); /* */ $s = 36; case 36: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
		_r$16;
		_r$17 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("mousemove"), (x$11 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$17, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$17 = $f._r$17; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$17 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
			_r$17;
			$r = theUI.input.Update($clone(e, js.Value)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$17 = _r$17; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$11.constructor.elem(x$11))])); /* */ $s = 37; case 37: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
		_r$17;
		_r$18 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("wheel"), (x$12 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$18, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$18 = $f._r$18; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$18 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
			_r$18;
			$r = theUI.input.Update($clone(e, js.Value)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$18 = _r$18; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$12.constructor.elem(x$12))])); /* */ $s = 38; case 38: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
		_r$18;
		_r$19 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("touchstart"), (x$13 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$19, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$19 = $f._r$19; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$19 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
			_r$19;
			$r = theUI.input.Update($clone(e, js.Value)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$19 = _r$19; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$13.constructor.elem(x$13))])); /* */ $s = 39; case 39: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
		_r$19;
		_r$20 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("touchend"), (x$14 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$20, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$20 = $f._r$20; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$20 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
			_r$20;
			$r = theUI.input.Update($clone(e, js.Value)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$20 = _r$20; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$14.constructor.elem(x$14))])); /* */ $s = 40; case 40: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
		_r$20;
		_r$21 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("touchmove"), (x$15 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$21, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$21 = $f._r$21; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$21 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
			_r$21;
			$r = theUI.input.Update($clone(e, js.Value)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$21 = _r$21; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$15.constructor.elem(x$15))])); /* */ $s = 41; case 41: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
		_r$21;
		_r$22 = $clone(window, js.Value).Call("addEventListener", new sliceType$3([new $String("gamepadconnected"), (x$16 = js.FuncOf((function(ch) { return function(this$1, args) {
			var args, this$1;
			return $ifaceNil;
		}; })(ch)), new x$16.constructor.elem(x$16))])); /* */ $s = 42; case 42: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
		_r$22;
		_r$23 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("contextmenu"), (x$17 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$23, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$23 = $f._r$23; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$23 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
			_r$23;
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$23 = _r$23; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$17.constructor.elem(x$17))])); /* */ $s = 43; case 43: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
		_r$23;
		_r$24 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("webglcontextlost"), (x$18 = js.FuncOf((function(ch) { return function $b(this$1, args) {
			var _r$24, args, e, this$1, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$24 = $f._r$24; args = $f.args; e = $f.e; this$1 = $f.this$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			e = $clone((0 >= args.$length ? ($throwRuntimeError("index out of range"), undefined) : args.$array[args.$offset + 0]), js.Value);
			_r$24 = $clone(e, js.Value).Call("preventDefault", new sliceType$3([])); /* */ $s = 1; case 1: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
			_r$24;
			theUI.contextLost = true;
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$24 = _r$24; $f.args = args; $f.e = e; $f.this$1 = this$1; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch)), new x$18.constructor.elem(x$18))])); /* */ $s = 44; case 44: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
		_r$24;
		_r$25 = $clone(canvas, js.Value).Call("addEventListener", new sliceType$3([new $String("webglcontextrestored"), (x$19 = js.FuncOf((function(ch) { return function(this$1, args) {
			var args, this$1;
			theUI.contextLost = false;
			return $ifaceNil;
		}; })(ch)), new x$19.constructor.elem(x$19))])); /* */ $s = 45; case 45: if($c) { $c = false; _r$25 = _r$25.$blk(); } if (_r$25 && _r$25.$blk !== undefined) { break s; }
		_r$25;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init$1 }; } $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$2 = _r$2; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$23 = _r$23; $f._r$24 = _r$24; $f._r$25 = _r$25; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f.bodyStyle = bodyStyle; $f.canvasStyle = canvasStyle; $f.ch = ch; $f.htmlStyle = htmlStyle; $f.meta = meta; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$16 = x$16; $f.x$17 = x$17; $f.x$18 = x$18; $f.x$19 = x$19; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.ptr.prototype.Run = function(width, height, scale, title, context, graphics) {
		var _r, _r$1, _r$2, ch, context, graphics, height, scale, title, u, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; ch = $f.ch; context = $f.context; graphics = $f.graphics; height = $f.height; scale = $f.scale; title = $f.title; u = $f.u; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ch = [ch];
		u = this;
		$r = $clone(document, js.Value).Set("title", new $String(title)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r = u.setScreenSize(width, height, scale, u.fullscreen); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		_r$1 = $clone(canvas, js.Value).Call("focus", new sliceType$3([])); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$1;
		ch[0] = u.loop(context);
		/* */ if (false) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (false) { */ case 4:
			_r$2 = $recv(ch[0]); /* */ $s = 6; case 6: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			$s = -1; return _r$2[0];
		/* } */ case 5:
		$go((function(ch) { return function $b() {
			var _r$3, err, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r$3 = $f._r$3; err = $f.err; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_r$3 = $recv(ch[0]); /* */ $s = 1; case 1: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			err = _r$3[0];
			/* */ if (!($interfaceIsEqual(err, $ifaceNil))) { $s = 2; continue; }
			/* */ $s = 3; continue;
			/* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
				$r = log.Fatal(new sliceType$3([err])); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 3:
			$s = -1; return;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r$3 = _r$3; $f.err = err; $f.$s = $s; $f.$r = $r; return $f;
		}; })(ch), []);
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.Run }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.ch = ch; $f.context = context; $f.graphics = graphics; $f.height = height; $f.scale = scale; $f.title = title; $f.u = u; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.Run = function(width, height, scale, title, context, graphics) { return this.$val.Run(width, height, scale, title, context, graphics); };
	UserInterface.ptr.prototype.RunWithoutMainLoop = function(width, height, scale, title, context, graphics) {
		var context, graphics, height, scale, title, u, width;
		u = this;
		$panic(new $String("js: RunWithoutMainLoop is not implemented"));
	};
	UserInterface.prototype.RunWithoutMainLoop = function(width, height, scale, title, context, graphics) { return this.$val.RunWithoutMainLoop(width, height, scale, title, context, graphics); };
	UserInterface.ptr.prototype.setScreenSize = function(width, height, scale, fullscreen) {
		var fullscreen, height, scale, u, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; fullscreen = $f.fullscreen; height = $f.height; scale = $f.scale; u = $f.u; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		if ((u.width === width) && (u.height === height) && (u.scale === scale) && fullscreen === u.fullscreen) {
			$s = -1; return false;
		}
		u.width = width;
		u.height = height;
		u.scale = scale;
		u.fullscreen = fullscreen;
		$r = u.updateScreenSize(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.setScreenSize }; } $f.fullscreen = fullscreen; $f.height = height; $f.scale = scale; $f.u = u; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.setScreenSize = function(width, height, scale, fullscreen) { return this.$val.setScreenSize(width, height, scale, fullscreen); };
	UserInterface.ptr.prototype.updateScreenSize = function() {
		var _arg, _arg$1, _r, _r$1, canvasStyle, cssHeight, cssWidth, s, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; _r$1 = $f._r$1; canvasStyle = $f.canvasStyle; cssHeight = $f.cssHeight; cssWidth = $f.cssWidth; s = $f.s; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		u = this;
		_r = u.actualScreenScale(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_arg = new $Int((((u.width) * _r >> 0)));
		$r = $clone(canvas, js.Value).Set("width", _arg); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$1 = u.actualScreenScale(); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_arg$1 = new $Int((((u.height) * _r$1 >> 0)));
		$r = $clone(canvas, js.Value).Set("height", _arg$1); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		canvasStyle = $clone($clone(canvas, js.Value).Get("style"), js.Value);
		s = u.getScale();
		cssWidth = (((u.width) * s >> 0));
		cssHeight = (((u.height) * s >> 0));
		$r = $clone(canvasStyle, js.Value).Set("width", new $String(strconv.Itoa(cssWidth) + "px")); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = $clone(canvasStyle, js.Value).Set("height", new $String(strconv.Itoa(cssHeight) + "px")); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		u.sizeChanged = true;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: UserInterface.ptr.prototype.updateScreenSize }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f._r$1 = _r$1; $f.canvasStyle = canvasStyle; $f.cssHeight = cssHeight; $f.cssWidth = cssWidth; $f.s = s; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	UserInterface.prototype.updateScreenSize = function() { return this.$val.updateScreenSize(); };
	UserInterface.ptr.prototype.Input = function() {
		var u;
		u = this;
		return u.input;
	};
	UserInterface.prototype.Input = function() { return this.$val.Input(); };
	ptrType$1.methods = [{prop: "CursorPosition", name: "CursorPosition", pkg: "", typ: $funcType([], [$Int, $Int], false)}, {prop: "GamepadIDs", name: "GamepadIDs", pkg: "", typ: $funcType([], [sliceType$2], false)}, {prop: "GamepadAxisNum", name: "GamepadAxisNum", pkg: "", typ: $funcType([$Int], [$Int], false)}, {prop: "GamepadAxis", name: "GamepadAxis", pkg: "", typ: $funcType([$Int, $Int], [$Float64], false)}, {prop: "GamepadButtonNum", name: "GamepadButtonNum", pkg: "", typ: $funcType([$Int], [$Int], false)}, {prop: "IsGamepadButtonPressed", name: "IsGamepadButtonPressed", pkg: "", typ: $funcType([$Int, driver.GamepadButton], [$Bool], false)}, {prop: "TouchIDs", name: "TouchIDs", pkg: "", typ: $funcType([], [sliceType$2], false)}, {prop: "TouchPosition", name: "TouchPosition", pkg: "", typ: $funcType([$Int], [$Int, $Int], false)}, {prop: "RuneBuffer", name: "RuneBuffer", pkg: "", typ: $funcType([], [sliceType$1], false)}, {prop: "ResetForFrame", name: "ResetForFrame", pkg: "", typ: $funcType([], [], false)}, {prop: "IsKeyPressed", name: "IsKeyPressed", pkg: "", typ: $funcType([driver.Key], [$Bool], false)}, {prop: "IsMouseButtonPressed", name: "IsMouseButtonPressed", pkg: "", typ: $funcType([driver.MouseButton], [$Bool], false)}, {prop: "Wheel", name: "Wheel", pkg: "", typ: $funcType([], [$Float64, $Float64], false)}, {prop: "keyDown", name: "keyDown", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([$String], [], false)}, {prop: "keyUp", name: "keyUp", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([$String], [], false)}, {prop: "keyDownEdge", name: "keyDownEdge", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([$Int], [], false)}, {prop: "keyUpEdge", name: "keyUpEdge", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([$Int], [], false)}, {prop: "mouseDown", name: "mouseDown", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([$Int], [], false)}, {prop: "mouseUp", name: "mouseUp", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([$Int], [], false)}, {prop: "setMouseCursor", name: "setMouseCursor", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([$Int, $Int], [], false)}, {prop: "UpdateGamepads", name: "UpdateGamepads", pkg: "", typ: $funcType([], [], false)}, {prop: "Update", name: "Update", pkg: "", typ: $funcType([js.Value], [], false)}, {prop: "setMouseCursorFromEvent", name: "setMouseCursorFromEvent", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([js.Value], [], false)}, {prop: "updateTouches", name: "updateTouches", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([js.Value], [], false)}];
	ptrType.methods = [{prop: "ScreenSizeInFullscreen", name: "ScreenSizeInFullscreen", pkg: "", typ: $funcType([], [$Int, $Int], false)}, {prop: "SetScreenSize", name: "SetScreenSize", pkg: "", typ: $funcType([$Int, $Int], [], false)}, {prop: "SetScreenScale", name: "SetScreenScale", pkg: "", typ: $funcType([$Float64], [], false)}, {prop: "ScreenScale", name: "ScreenScale", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "SetFullscreen", name: "SetFullscreen", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "IsFullscreen", name: "IsFullscreen", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "SetRunnableInBackground", name: "SetRunnableInBackground", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "IsRunnableInBackground", name: "IsRunnableInBackground", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "SetVsyncEnabled", name: "SetVsyncEnabled", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "IsVsyncEnabled", name: "IsVsyncEnabled", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "ScreenPadding", name: "ScreenPadding", pkg: "", typ: $funcType([], [$Float64, $Float64, $Float64, $Float64], false)}, {prop: "adjustPosition", name: "adjustPosition", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([$Int, $Int], [$Int, $Int], false)}, {prop: "IsCursorVisible", name: "IsCursorVisible", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "SetCursorVisible", name: "SetCursorVisible", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetWindowTitle", name: "SetWindowTitle", pkg: "", typ: $funcType([$String], [], false)}, {prop: "SetWindowIcon", name: "SetWindowIcon", pkg: "", typ: $funcType([sliceType$5], [], false)}, {prop: "IsWindowDecorated", name: "IsWindowDecorated", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "SetWindowDecorated", name: "SetWindowDecorated", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "IsWindowResizable", name: "IsWindowResizable", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "SetWindowResizable", name: "SetWindowResizable", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "DeviceScaleFactor", name: "DeviceScaleFactor", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "getScale", name: "getScale", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([], [$Float64], false)}, {prop: "actualScreenScale", name: "actualScreenScale", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([], [$Float64], false)}, {prop: "updateSize", name: "updateSize", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([], [], false)}, {prop: "suspended", name: "suspended", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([], [$Bool], false)}, {prop: "update", name: "update", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([], [$error], false)}, {prop: "loop", name: "loop", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([driver.UIContext], [chanType], false)}, {prop: "Run", name: "Run", pkg: "", typ: $funcType([$Int, $Int, $Float64, $String, driver.UIContext, driver.Graphics], [$error], false)}, {prop: "RunWithoutMainLoop", name: "RunWithoutMainLoop", pkg: "", typ: $funcType([$Int, $Int, $Float64, $String, driver.UIContext, driver.Graphics], [chanType], false)}, {prop: "setScreenSize", name: "setScreenSize", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([$Int, $Int, $Float64, $Bool], [$Bool], false)}, {prop: "updateScreenSize", name: "updateScreenSize", pkg: "github.com/hajimehoshi/ebiten/internal/uidriver/js", typ: $funcType([], [], false)}, {prop: "Input", name: "Input", pkg: "", typ: $funcType([], [driver.Input], false)}];
	pos.init("", [{prop: "X", name: "X", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Y", name: "Y", embedded: false, exported: true, typ: $Int, tag: ""}]);
	gamePad.init("github.com/hajimehoshi/ebiten/internal/uidriver/js", [{prop: "valid", name: "valid", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "axisNum", name: "axisNum", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "axes", name: "axes", embedded: false, exported: false, typ: arrayType, tag: ""}, {prop: "buttonNum", name: "buttonNum", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "buttonPressed", name: "buttonPressed", embedded: false, exported: false, typ: arrayType$1, tag: ""}]);
	Input.init("github.com/hajimehoshi/ebiten/internal/uidriver/js", [{prop: "keyPressed", name: "keyPressed", embedded: false, exported: false, typ: mapType, tag: ""}, {prop: "keyPressedEdge", name: "keyPressedEdge", embedded: false, exported: false, typ: mapType$1, tag: ""}, {prop: "mouseButtonPressed", name: "mouseButtonPressed", embedded: false, exported: false, typ: mapType$1, tag: ""}, {prop: "cursorX", name: "cursorX", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "cursorY", name: "cursorY", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "wheelX", name: "wheelX", embedded: false, exported: false, typ: $Float64, tag: ""}, {prop: "wheelY", name: "wheelY", embedded: false, exported: false, typ: $Float64, tag: ""}, {prop: "gamepads", name: "gamepads", embedded: false, exported: false, typ: arrayType$2, tag: ""}, {prop: "touches", name: "touches", embedded: false, exported: false, typ: mapType$2, tag: ""}, {prop: "runeBuffer", name: "runeBuffer", embedded: false, exported: false, typ: sliceType$1, tag: ""}, {prop: "ui", name: "ui", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	UserInterface.init("github.com/hajimehoshi/ebiten/internal/uidriver/js", [{prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "scale", name: "scale", embedded: false, exported: false, typ: $Float64, tag: ""}, {prop: "fullscreen", name: "fullscreen", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "runnableInBackground", name: "runnableInBackground", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "vsync", name: "vsync", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "sizeChanged", name: "sizeChanged", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "windowFocus", name: "windowFocus", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "pageVisible", name: "pageVisible", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "contextLost", name: "contextLost", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "lastActualScale", name: "lastActualScale", embedded: false, exported: false, typ: $Float64, tag: ""}, {prop: "context", name: "context", embedded: false, exported: false, typ: driver.UIContext, tag: ""}, {prop: "input", name: "input", embedded: false, exported: false, typ: Input, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = devicescale.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = driver.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = image.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = log.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		canvas = new js.Value.ptr(null, false);
		codeToMouseButton = $makeMap($Int.keyFor, [{ k: 0, v: 0 }, { k: 1, v: 2 }, { k: 2, v: 1 }]);
		keyToCodes = $makeMap(driver.Key.keyFor, [{ k: 0, v: new sliceType(["Digit0"]) }, { k: 1, v: new sliceType(["Digit1"]) }, { k: 2, v: new sliceType(["Digit2"]) }, { k: 3, v: new sliceType(["Digit3"]) }, { k: 4, v: new sliceType(["Digit4"]) }, { k: 5, v: new sliceType(["Digit5"]) }, { k: 6, v: new sliceType(["Digit6"]) }, { k: 7, v: new sliceType(["Digit7"]) }, { k: 8, v: new sliceType(["Digit8"]) }, { k: 9, v: new sliceType(["Digit9"]) }, { k: 10, v: new sliceType(["KeyA"]) }, { k: 36, v: new sliceType(["AltLeft", "AltRight"]) }, { k: 37, v: new sliceType(["Quote"]) }, { k: 11, v: new sliceType(["KeyB"]) }, { k: 38, v: new sliceType(["Backslash"]) }, { k: 39, v: new sliceType(["Backspace"]) }, { k: 12, v: new sliceType(["KeyC"]) }, { k: 40, v: new sliceType(["CapsLock"]) }, { k: 41, v: new sliceType(["Comma"]) }, { k: 42, v: new sliceType(["ControlLeft", "ControlRight"]) }, { k: 13, v: new sliceType(["KeyD"]) }, { k: 43, v: new sliceType(["Delete"]) }, { k: 44, v: new sliceType(["ArrowDown"]) }, { k: 14, v: new sliceType(["KeyE"]) }, { k: 45, v: new sliceType(["End"]) }, { k: 46, v: new sliceType(["Enter"]) }, { k: 47, v: new sliceType(["Equal"]) }, { k: 48, v: new sliceType(["Escape"]) }, { k: 15, v: new sliceType(["KeyF"]) }, { k: 49, v: new sliceType(["F1"]) }, { k: 58, v: new sliceType(["F10"]) }, { k: 59, v: new sliceType(["F11"]) }, { k: 60, v: new sliceType(["F12"]) }, { k: 50, v: new sliceType(["F2"]) }, { k: 51, v: new sliceType(["F3"]) }, { k: 52, v: new sliceType(["F4"]) }, { k: 53, v: new sliceType(["F5"]) }, { k: 54, v: new sliceType(["F6"]) }, { k: 55, v: new sliceType(["F7"]) }, { k: 56, v: new sliceType(["F8"]) }, { k: 57, v: new sliceType(["F9"]) }, { k: 16, v: new sliceType(["KeyG"]) }, { k: 61, v: new sliceType(["Backquote"]) }, { k: 17, v: new sliceType(["KeyH"]) }, { k: 62, v: new sliceType(["Home"]) }, { k: 18, v: new sliceType(["KeyI"]) }, { k: 63, v: new sliceType(["Insert"]) }, { k: 19, v: new sliceType(["KeyJ"]) }, { k: 20, v: new sliceType(["KeyK"]) }, { k: 64, v: new sliceType(["Numpad0"]) }, { k: 65, v: new sliceType(["Numpad1"]) }, { k: 66, v: new sliceType(["Numpad2"]) }, { k: 67, v: new sliceType(["Numpad3"]) }, { k: 68, v: new sliceType(["Numpad4"]) }, { k: 69, v: new sliceType(["Numpad5"]) }, { k: 70, v: new sliceType(["Numpad6"]) }, { k: 71, v: new sliceType(["Numpad7"]) }, { k: 72, v: new sliceType(["Numpad8"]) }, { k: 73, v: new sliceType(["Numpad9"]) }, { k: 74, v: new sliceType(["NumpadAdd"]) }, { k: 75, v: new sliceType(["NumpadDecimal"]) }, { k: 76, v: new sliceType(["NumpadDivide"]) }, { k: 77, v: new sliceType(["NumpadEnter"]) }, { k: 78, v: new sliceType(["NumpadEqual"]) }, { k: 79, v: new sliceType(["NumpadMultiply"]) }, { k: 80, v: new sliceType(["NumpadSubtract"]) }, { k: 21, v: new sliceType(["KeyL"]) }, { k: 81, v: new sliceType(["ArrowLeft"]) }, { k: 82, v: new sliceType(["BracketLeft"]) }, { k: 22, v: new sliceType(["KeyM"]) }, { k: 83, v: new sliceType(["ContextMenu"]) }, { k: 84, v: new sliceType(["Minus"]) }, { k: 23, v: new sliceType(["KeyN"]) }, { k: 85, v: new sliceType(["NumLock"]) }, { k: 24, v: new sliceType(["KeyO"]) }, { k: 25, v: new sliceType(["KeyP"]) }, { k: 86, v: new sliceType(["PageDown"]) }, { k: 87, v: new sliceType(["PageUp"]) }, { k: 88, v: new sliceType(["Pause"]) }, { k: 89, v: new sliceType(["Period"]) }, { k: 90, v: new sliceType(["PrintScreen"]) }, { k: 26, v: new sliceType(["KeyQ"]) }, { k: 27, v: new sliceType(["KeyR"]) }, { k: 91, v: new sliceType(["ArrowRight"]) }, { k: 92, v: new sliceType(["BracketRight"]) }, { k: 28, v: new sliceType(["KeyS"]) }, { k: 93, v: new sliceType(["ScrollLock"]) }, { k: 94, v: new sliceType(["Semicolon"]) }, { k: 95, v: new sliceType(["ShiftLeft", "ShiftRight"]) }, { k: 96, v: new sliceType(["Slash"]) }, { k: 97, v: new sliceType(["Space"]) }, { k: 29, v: new sliceType(["KeyT"]) }, { k: 98, v: new sliceType(["Tab"]) }, { k: 30, v: new sliceType(["KeyU"]) }, { k: 99, v: new sliceType(["ArrowUp"]) }, { k: 31, v: new sliceType(["KeyV"]) }, { k: 32, v: new sliceType(["KeyW"]) }, { k: 33, v: new sliceType(["KeyX"]) }, { k: 34, v: new sliceType(["KeyY"]) }, { k: 35, v: new sliceType(["KeyZ"]) }]);
		keyCodeToKeyEdge = $makeMap($Int.keyFor, [{ k: 8, v: 39 }, { k: 9, v: 98 }, { k: 13, v: 46 }, { k: 16, v: 95 }, { k: 17, v: 42 }, { k: 18, v: 36 }, { k: 19, v: 88 }, { k: 20, v: 40 }, { k: 27, v: 48 }, { k: 32, v: 97 }, { k: 33, v: 87 }, { k: 34, v: 86 }, { k: 35, v: 45 }, { k: 36, v: 62 }, { k: 37, v: 81 }, { k: 38, v: 99 }, { k: 39, v: 91 }, { k: 40, v: 44 }, { k: 45, v: 63 }, { k: 46, v: 43 }, { k: 48, v: 0 }, { k: 49, v: 1 }, { k: 50, v: 2 }, { k: 51, v: 3 }, { k: 52, v: 4 }, { k: 53, v: 5 }, { k: 54, v: 6 }, { k: 55, v: 7 }, { k: 56, v: 8 }, { k: 57, v: 9 }, { k: 65, v: 10 }, { k: 66, v: 11 }, { k: 67, v: 12 }, { k: 68, v: 13 }, { k: 69, v: 14 }, { k: 70, v: 15 }, { k: 71, v: 16 }, { k: 72, v: 17 }, { k: 73, v: 18 }, { k: 74, v: 19 }, { k: 75, v: 20 }, { k: 76, v: 21 }, { k: 77, v: 22 }, { k: 78, v: 23 }, { k: 79, v: 24 }, { k: 80, v: 25 }, { k: 81, v: 26 }, { k: 82, v: 27 }, { k: 83, v: 28 }, { k: 84, v: 29 }, { k: 85, v: 30 }, { k: 86, v: 31 }, { k: 87, v: 32 }, { k: 88, v: 33 }, { k: 89, v: 34 }, { k: 90, v: 35 }, { k: 93, v: 83 }, { k: 96, v: 64 }, { k: 97, v: 65 }, { k: 98, v: 66 }, { k: 99, v: 67 }, { k: 100, v: 68 }, { k: 101, v: 69 }, { k: 102, v: 70 }, { k: 103, v: 71 }, { k: 104, v: 72 }, { k: 105, v: 73 }, { k: 106, v: 79 }, { k: 107, v: 74 }, { k: 109, v: 80 }, { k: 110, v: 75 }, { k: 111, v: 76 }, { k: 112, v: 49 }, { k: 113, v: 50 }, { k: 114, v: 51 }, { k: 115, v: 52 }, { k: 116, v: 53 }, { k: 117, v: 54 }, { k: 118, v: 55 }, { k: 119, v: 56 }, { k: 120, v: 57 }, { k: 121, v: 58 }, { k: 122, v: 59 }, { k: 123, v: 60 }, { k: 144, v: 85 }, { k: 145, v: 93 }, { k: 186, v: 94 }, { k: 187, v: 47 }, { k: 188, v: 41 }, { k: 189, v: 84 }, { k: 190, v: 89 }, { k: 191, v: 96 }, { k: 192, v: 61 }, { k: 219, v: 82 }, { k: 220, v: 38 }, { k: 221, v: 92 }, { k: 222, v: 37 }]);
		theUI = new UserInterface.ptr(0, 0, 0, false, false, true, true, true, true, false, 0, $ifaceNil, new Input.ptr(false, false, false, 0, 0, 0, 0, arrayType$2.zero(), false, sliceType$1.nil, ptrType.nil));
		window = $clone($clone(js.Global(), js.Value).Get("window"), js.Value);
		document = $clone($clone(js.Global(), js.Value).Get("document"), js.Value);
		requestAnimationFrame = $clone($clone(window, js.Value).Get("requestAnimationFrame"), js.Value);
		setTimeout = $clone($clone(window, js.Value).Get("setTimeout"), js.Value);
		init();
		$r = init$1(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten"] = (function() {
	var $pkg = {}, $init, fmt, affine, clock, driver, graphics, graphicscommand, opengl, hooks, shareable, js, web, image, color, draw, math, strings, sync, atomic, time, ColorM, GamepadButton, GeoM, Filter, CompositeMode, Image, Vertex, Address, DrawTrianglesOptions, DrawImageOptions, imageDumper, ImagePart, ImageParts, imageParts, Key, mipmap, MouseButton, uiContext, verticesBackend, sliceType, sliceType$1, ptrType, sliceType$2, ptrType$1, ptrType$2, ptrType$3, sliceType$3, ptrType$4, ptrType$5, ptrType$6, ptrType$7, ptrType$8, sliceType$6, ptrType$9, ptrType$10, sliceType$7, sliceType$8, ptrType$11, funcType, mapType, funcType$1, ptrType$13, ptrType$14, isPlayground, isDrawingSkipped, isDrawingSkipped$24ptr, currentMaxTPS, currentMaxTPS$24ptr, isRunning, isRunning$24ptr, theUIContext, theVerticesBackend, x, copyImage, graphicsDriver, NewImage, NewImageFromImage, newImageWithScreenFramebuffer, IsKeyPressed, CursorPosition, IsMouseButtonPressed, GamepadIDs, GamepadButtonNum, IsGamepadButtonPressed, TouchIDs, TouchPosition, newMipmap, mipmapLevel, setDrawingSkipped, Run, MaxTPS, uiDriver, init, newUIContext, vertexSlice;
	fmt = $packages["fmt"];
	affine = $packages["github.com/hajimehoshi/ebiten/internal/affine"];
	clock = $packages["github.com/hajimehoshi/ebiten/internal/clock"];
	driver = $packages["github.com/hajimehoshi/ebiten/internal/driver"];
	graphics = $packages["github.com/hajimehoshi/ebiten/internal/graphics"];
	graphicscommand = $packages["github.com/hajimehoshi/ebiten/internal/graphicscommand"];
	opengl = $packages["github.com/hajimehoshi/ebiten/internal/graphicsdriver/opengl"];
	hooks = $packages["github.com/hajimehoshi/ebiten/internal/hooks"];
	shareable = $packages["github.com/hajimehoshi/ebiten/internal/shareable"];
	js = $packages["github.com/hajimehoshi/ebiten/internal/uidriver/js"];
	web = $packages["github.com/hajimehoshi/ebiten/internal/web"];
	image = $packages["image"];
	color = $packages["image/color"];
	draw = $packages["image/draw"];
	math = $packages["math"];
	strings = $packages["strings"];
	sync = $packages["sync"];
	atomic = $packages["sync/atomic"];
	time = $packages["time"];
	ColorM = $pkg.ColorM = $newType(0, $kindStruct, "ebiten.ColorM", true, "github.com/hajimehoshi/ebiten", true, function(impl_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.impl = ptrType.nil;
			return;
		}
		this.impl = impl_;
	});
	GamepadButton = $pkg.GamepadButton = $newType(4, $kindInt, "ebiten.GamepadButton", true, "github.com/hajimehoshi/ebiten", true, null);
	GeoM = $pkg.GeoM = $newType(0, $kindStruct, "ebiten.GeoM", true, "github.com/hajimehoshi/ebiten", true, function(a_1_, b_, c_, d_1_, tx_, ty_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.a_1 = 0;
			this.b = 0;
			this.c = 0;
			this.d_1 = 0;
			this.tx = 0;
			this.ty = 0;
			return;
		}
		this.a_1 = a_1_;
		this.b = b_;
		this.c = c_;
		this.d_1 = d_1_;
		this.tx = tx_;
		this.ty = ty_;
	});
	Filter = $pkg.Filter = $newType(4, $kindInt, "ebiten.Filter", true, "github.com/hajimehoshi/ebiten", true, null);
	CompositeMode = $pkg.CompositeMode = $newType(4, $kindInt, "ebiten.CompositeMode", true, "github.com/hajimehoshi/ebiten", true, null);
	Image = $pkg.Image = $newType(0, $kindStruct, "ebiten.Image", true, "github.com/hajimehoshi/ebiten", true, function(addr_, mipmap_, bounds_, original_, pendingPixels_, filter_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.addr = ptrType$2.nil;
			this.mipmap = ptrType$7.nil;
			this.bounds = new image.Rectangle.ptr(new image.Point.ptr(0, 0), new image.Point.ptr(0, 0));
			this.original = ptrType$2.nil;
			this.pendingPixels = sliceType$2.nil;
			this.filter = 0;
			return;
		}
		this.addr = addr_;
		this.mipmap = mipmap_;
		this.bounds = bounds_;
		this.original = original_;
		this.pendingPixels = pendingPixels_;
		this.filter = filter_;
	});
	Vertex = $pkg.Vertex = $newType(0, $kindStruct, "ebiten.Vertex", true, "github.com/hajimehoshi/ebiten", true, function(DstX_, DstY_, SrcX_, SrcY_, ColorR_, ColorG_, ColorB_, ColorA_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.DstX = 0;
			this.DstY = 0;
			this.SrcX = 0;
			this.SrcY = 0;
			this.ColorR = 0;
			this.ColorG = 0;
			this.ColorB = 0;
			this.ColorA = 0;
			return;
		}
		this.DstX = DstX_;
		this.DstY = DstY_;
		this.SrcX = SrcX_;
		this.SrcY = SrcY_;
		this.ColorR = ColorR_;
		this.ColorG = ColorG_;
		this.ColorB = ColorB_;
		this.ColorA = ColorA_;
	});
	Address = $pkg.Address = $newType(4, $kindInt, "ebiten.Address", true, "github.com/hajimehoshi/ebiten", true, null);
	DrawTrianglesOptions = $pkg.DrawTrianglesOptions = $newType(0, $kindStruct, "ebiten.DrawTrianglesOptions", true, "github.com/hajimehoshi/ebiten", true, function(ColorM_, CompositeMode_, Filter_, Address_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.ColorM = new ColorM.ptr(ptrType.nil);
			this.CompositeMode = 0;
			this.Filter = 0;
			this.Address = 0;
			return;
		}
		this.ColorM = ColorM_;
		this.CompositeMode = CompositeMode_;
		this.Filter = Filter_;
		this.Address = Address_;
	});
	DrawImageOptions = $pkg.DrawImageOptions = $newType(0, $kindStruct, "ebiten.DrawImageOptions", true, "github.com/hajimehoshi/ebiten", true, function(GeoM_, ColorM_, CompositeMode_, Filter_, ImageParts_, Parts_, SourceRect_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.GeoM = new GeoM.ptr(0, 0, 0, 0, 0, 0);
			this.ColorM = new ColorM.ptr(ptrType.nil);
			this.CompositeMode = 0;
			this.Filter = 0;
			this.ImageParts = $ifaceNil;
			this.Parts = sliceType$3.nil;
			this.SourceRect = ptrType$4.nil;
			return;
		}
		this.GeoM = GeoM_;
		this.ColorM = ColorM_;
		this.CompositeMode = CompositeMode_;
		this.Filter = Filter_;
		this.ImageParts = ImageParts_;
		this.Parts = Parts_;
		this.SourceRect = SourceRect_;
	});
	imageDumper = $pkg.imageDumper = $newType(0, $kindStruct, "ebiten.imageDumper", true, "github.com/hajimehoshi/ebiten", false, function(f_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.f = $throwNilPointerError;
			return;
		}
		this.f = f_;
	});
	ImagePart = $pkg.ImagePart = $newType(0, $kindStruct, "ebiten.ImagePart", true, "github.com/hajimehoshi/ebiten", true, function(Dst_, Src_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Dst = new image.Rectangle.ptr(new image.Point.ptr(0, 0), new image.Point.ptr(0, 0));
			this.Src = new image.Rectangle.ptr(new image.Point.ptr(0, 0), new image.Point.ptr(0, 0));
			return;
		}
		this.Dst = Dst_;
		this.Src = Src_;
	});
	ImageParts = $pkg.ImageParts = $newType(8, $kindInterface, "ebiten.ImageParts", true, "github.com/hajimehoshi/ebiten", true, null);
	imageParts = $pkg.imageParts = $newType(12, $kindSlice, "ebiten.imageParts", true, "github.com/hajimehoshi/ebiten", false, null);
	Key = $pkg.Key = $newType(4, $kindInt, "ebiten.Key", true, "github.com/hajimehoshi/ebiten", true, null);
	mipmap = $pkg.mipmap = $newType(0, $kindStruct, "ebiten.mipmap", true, "github.com/hajimehoshi/ebiten", false, function(orig_, imgs_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.orig = ptrType$5.nil;
			this.imgs = false;
			return;
		}
		this.orig = orig_;
		this.imgs = imgs_;
	});
	MouseButton = $pkg.MouseButton = $newType(4, $kindInt, "ebiten.MouseButton", true, "github.com/hajimehoshi/ebiten", true, null);
	uiContext = $pkg.uiContext = $newType(0, $kindStruct, "ebiten.uiContext", true, "github.com/hajimehoshi/ebiten", false, function(f_, offscreen_, screen_, screenWidth_, screenHeight_, screenScale_, initialized_, offsetX_, offsetY_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.f = $throwNilPointerError;
			this.offscreen = ptrType$2.nil;
			this.screen = ptrType$2.nil;
			this.screenWidth = 0;
			this.screenHeight = 0;
			this.screenScale = 0;
			this.initialized = false;
			this.offsetX = 0;
			this.offsetY = 0;
			return;
		}
		this.f = f_;
		this.offscreen = offscreen_;
		this.screen = screen_;
		this.screenWidth = screenWidth_;
		this.screenHeight = screenHeight_;
		this.screenScale = screenScale_;
		this.initialized = initialized_;
		this.offsetX = offsetX_;
		this.offsetY = offsetY_;
	});
	verticesBackend = $pkg.verticesBackend = $newType(0, $kindStruct, "ebiten.verticesBackend", true, "github.com/hajimehoshi/ebiten", false, function(backend_, head_, m_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.backend = sliceType.nil;
			this.head = 0;
			this.m = new sync.Mutex.ptr(0, 0);
			return;
		}
		this.backend = backend_;
		this.head = head_;
		this.m = m_;
	});
	sliceType = $sliceType($Float32);
	sliceType$1 = $sliceType($emptyInterface);
	ptrType = $ptrType(affine.ColorM);
	sliceType$2 = $sliceType($Uint8);
	ptrType$1 = $ptrType(image.Paletted);
	ptrType$2 = $ptrType(Image);
	ptrType$3 = $ptrType(DrawImageOptions);
	sliceType$3 = $sliceType(ImagePart);
	ptrType$4 = $ptrType(image.Rectangle);
	ptrType$5 = $ptrType(shareable.Image);
	ptrType$6 = $ptrType(DrawTrianglesOptions);
	ptrType$7 = $ptrType(mipmap);
	ptrType$8 = $ptrType($Int32);
	sliceType$6 = $sliceType(ptrType$5);
	ptrType$9 = $ptrType(ColorM);
	ptrType$10 = $ptrType(GeoM);
	sliceType$7 = $sliceType(Vertex);
	sliceType$8 = $sliceType($Uint16);
	ptrType$11 = $ptrType(imageDumper);
	funcType = $funcType([ptrType$2], [$error], false);
	mapType = $mapType(image.Rectangle, sliceType$6);
	funcType$1 = $funcType([], [], false);
	ptrType$13 = $ptrType(uiContext);
	ptrType$14 = $ptrType(verticesBackend);
	ColorM.ptr.prototype.String = function() {
		var _r, _tuple, b, c, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; c = $f.c; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_tuple = c.impl.UnsafeElements();
		b = _tuple[0];
		t = _tuple[1];
		_r = fmt.Sprintf("[[%f, %f, %f, %f, %f], [%f, %f, %f, %f, %f], [%f, %f, %f, %f, %f], [%f, %f, %f, %f, %f]]", new sliceType$1([new $Float32((0 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 0])), new $Float32((4 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 4])), new $Float32((8 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 8])), new $Float32((12 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 12])), new $Float32((0 >= t.$length ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + 0])), new $Float32((1 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 1])), new $Float32((5 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 5])), new $Float32((9 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 9])), new $Float32((13 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 13])), new $Float32((1 >= t.$length ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + 1])), new $Float32((2 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 2])), new $Float32((6 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 6])), new $Float32((10 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 10])), new $Float32((14 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 14])), new $Float32((2 >= t.$length ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + 2])), new $Float32((3 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 3])), new $Float32((7 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 7])), new $Float32((11 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 11])), new $Float32((15 >= b.$length ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + 15])), new $Float32((3 >= t.$length ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + 3]))])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ColorM.ptr.prototype.String }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.c = c; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	ColorM.prototype.String = function() { return this.$val.String(); };
	ColorM.ptr.prototype.Reset = function() {
		var c;
		c = this;
		c.impl = ptrType.nil;
	};
	ColorM.prototype.Reset = function() { return this.$val.Reset(); };
	ColorM.ptr.prototype.Apply = function(clr) {
		var _r, c, clr, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; clr = $f.clr; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = c.impl.Apply(clr); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ColorM.ptr.prototype.Apply }; } $f._r = _r; $f.c = c; $f.clr = clr; $f.$s = $s; $f.$r = $r; return $f;
	};
	ColorM.prototype.Apply = function(clr) { return this.$val.Apply(clr); };
	ColorM.ptr.prototype.Concat = function(other) {
		var c, other;
		c = this;
		c.impl = c.impl.Concat(other.impl);
	};
	ColorM.prototype.Concat = function(other) { return this.$val.Concat(other); };
	ColorM.ptr.prototype.Add = function(other) {
		var c, other;
		c = this;
		c.impl = c.impl.Add(other.impl);
	};
	ColorM.prototype.Add = function(other) { return this.$val.Add(other); };
	ColorM.ptr.prototype.Scale = function(r, g, b, a) {
		var a, b, c, g, r;
		c = this;
		c.impl = c.impl.Scale(($fround(r)), ($fround(g)), ($fround(b)), ($fround(a)));
	};
	ColorM.prototype.Scale = function(r, g, b, a) { return this.$val.Scale(r, g, b, a); };
	ColorM.ptr.prototype.Translate = function(r, g, b, a) {
		var a, b, c, g, r;
		c = this;
		c.impl = c.impl.Translate(($fround(r)), ($fround(g)), ($fround(b)), ($fround(a)));
	};
	ColorM.prototype.Translate = function(r, g, b, a) { return this.$val.Translate(r, g, b, a); };
	ColorM.ptr.prototype.RotateHue = function(theta) {
		var c, theta;
		c = this;
		c.ChangeHSV(theta, 1, 1);
	};
	ColorM.prototype.RotateHue = function(theta) { return this.$val.RotateHue(theta); };
	ColorM.ptr.prototype.ChangeHSV = function(hueTheta, saturationScale, valueScale) {
		var c, hueTheta, saturationScale, valueScale;
		c = this;
		c.impl = c.impl.ChangeHSV(hueTheta, ($fround(saturationScale)), ($fround(valueScale)));
	};
	ColorM.prototype.ChangeHSV = function(hueTheta, saturationScale, valueScale) { return this.$val.ChangeHSV(hueTheta, saturationScale, valueScale); };
	ColorM.ptr.prototype.Element = function(i, j) {
		var _tuple, b, c, i, j, t, x$1;
		c = this;
		_tuple = c.impl.UnsafeElements();
		b = _tuple[0];
		t = _tuple[1];
		if (j < 4) {
			return ((x$1 = i + ($imul(j, 4)) >> 0, ((x$1 < 0 || x$1 >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + x$1])));
		}
		return (((i < 0 || i >= t.$length) ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + i]));
	};
	ColorM.prototype.Element = function(i, j) { return this.$val.Element(i, j); };
	ColorM.ptr.prototype.SetElement = function(i, j, element) {
		var c, element, i, j;
		c = this;
		c.impl = c.impl.SetElement(i, j, ($fround(element)));
	};
	ColorM.prototype.SetElement = function(i, j, element) { return this.$val.SetElement(i, j, element); };
	copyImage = function(img) {
		var _arg, _arg$1, _arg$2, _arg$3, _i, _r, _r$1, _r$2, _r$3, _ref, _ref$1, _tmp, _tmp$1, b, bs, c, d, dstImg, h, i, i$1, idx0, idx1, img, img$1, img$2, j, p, palette, rgba, size, w, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, x0, x1, y0, y1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; _ref$1 = $f._ref$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; b = $f.b; bs = $f.bs; c = $f.c; d = $f.d; dstImg = $f.dstImg; h = $f.h; i = $f.i; i$1 = $f.i$1; idx0 = $f.idx0; idx1 = $f.idx1; img = $f.img; img$1 = $f.img$1; img$2 = $f.img$2; j = $f.j; p = $f.p; palette = $f.palette; rgba = $f.rgba; size = $f.size; w = $f.w; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; x0 = $f.x0; x1 = $f.x1; y0 = $f.y0; y1 = $f.y1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = img.Bounds(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = $clone(_r, image.Rectangle).Size(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		size = $clone(_r$1, image.Point);
		_tmp = size.X;
		_tmp$1 = size.Y;
		w = _tmp;
		h = _tmp$1;
		bs = $makeSlice(sliceType$2, ($imul(($imul(4, w)), h)));
		_ref = img;
		/* */ if ($assertType(_ref, ptrType$1, true)[1]) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if ($assertType(_ref, ptrType$1, true)[1]) { */ case 3:
			img$1 = _ref.$val;
			b = $clone(img$1.Bounds(), image.Rectangle);
			x0 = b.Min.X;
			y0 = b.Min.Y;
			x1 = b.Max.X;
			y1 = b.Max.Y;
			palette = $makeSlice(sliceType$2, ($imul(img$1.Palette.$length, 4)));
			_ref$1 = img$1.Palette;
			_i = 0;
			/* while (true) { */ case 6:
				/* if (!(_i < _ref$1.$length)) { break; } */ if(!(_i < _ref$1.$length)) { $s = 7; continue; }
				i = _i;
				c = ((_i < 0 || _i >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i]);
				_r$2 = color.RGBAModel.Convert(c); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				rgba = $clone($assertType(_r$2, color.RGBA), color.RGBA);
				(x$1 = $imul(4, i), ((x$1 < 0 || x$1 >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + x$1] = rgba.R));
				(x$2 = ($imul(4, i)) + 1 >> 0, ((x$2 < 0 || x$2 >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + x$2] = rgba.G));
				(x$3 = ($imul(4, i)) + 2 >> 0, ((x$3 < 0 || x$3 >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + x$3] = rgba.B));
				(x$4 = ($imul(4, i)) + 3 >> 0, ((x$4 < 0 || x$4 >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + x$4] = rgba.A));
				_i++;
			/* } */ $s = 6; continue; case 7:
			idx0 = 0;
			idx1 = 0;
			d = img$1.Stride - ((x1 - x0 >> 0)) >> 0;
			j = 0;
			while (true) {
				if (!(j < (y1 - y0 >> 0))) { break; }
				i$1 = 0;
				while (true) {
					if (!(i$1 < (x1 - x0 >> 0))) { break; }
					p = (((x$5 = img$1.Pix, ((idx0 < 0 || idx0 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + idx0])) >> 0));
					((idx1 < 0 || idx1 >= bs.$length) ? ($throwRuntimeError("index out of range"), undefined) : bs.$array[bs.$offset + idx1] = (x$6 = $imul(4, p), ((x$6 < 0 || x$6 >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + x$6])));
					(x$8 = idx1 + 1 >> 0, ((x$8 < 0 || x$8 >= bs.$length) ? ($throwRuntimeError("index out of range"), undefined) : bs.$array[bs.$offset + x$8] = (x$7 = ($imul(4, p)) + 1 >> 0, ((x$7 < 0 || x$7 >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + x$7]))));
					(x$10 = idx1 + 2 >> 0, ((x$10 < 0 || x$10 >= bs.$length) ? ($throwRuntimeError("index out of range"), undefined) : bs.$array[bs.$offset + x$10] = (x$9 = ($imul(4, p)) + 2 >> 0, ((x$9 < 0 || x$9 >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + x$9]))));
					(x$12 = idx1 + 3 >> 0, ((x$12 < 0 || x$12 >= bs.$length) ? ($throwRuntimeError("index out of range"), undefined) : bs.$array[bs.$offset + x$12] = (x$11 = ($imul(4, p)) + 3 >> 0, ((x$11 < 0 || x$11 >= palette.$length) ? ($throwRuntimeError("index out of range"), undefined) : palette.$array[palette.$offset + x$11]))));
					idx0 = idx0 + (1) >> 0;
					idx1 = idx1 + (4) >> 0;
					i$1 = i$1 + (1) >> 0;
				}
				idx0 = idx0 + (d) >> 0;
				j = j + (1) >> 0;
			}
			$s = 5; continue;
		/* } else { */ case 4:
			img$2 = _ref;
			dstImg = new image.RGBA.ptr(bs, $imul(4, w), $clone(image.Rect(0, 0, w, h), image.Rectangle));
			_arg = dstImg;
			_arg$1 = $clone(image.Rect(0, 0, w, h), image.Rectangle);
			_arg$2 = img$2;
			_r$3 = img$2.Bounds(); /* */ $s = 9; case 9: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			_arg$3 = $clone(_r$3.Min, image.Point);
			$r = draw.Draw(_arg, _arg$1, _arg$2, _arg$3, 1); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 5:
		$s = -1; return bs;
		/* */ } return; } if ($f === undefined) { $f = { $blk: copyImage }; } $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.b = b; $f.bs = bs; $f.c = c; $f.d = d; $f.dstImg = dstImg; $f.h = h; $f.i = i; $f.i$1 = i$1; $f.idx0 = idx0; $f.idx1 = idx1; $f.img = img; $f.img$1 = img$1; $f.img$2 = img$2; $f.j = j; $f.p = p; $f.palette = palette; $f.rgba = rgba; $f.size = size; $f.w = w; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.x0 = x0; $f.x1 = x1; $f.y0 = y0; $f.y1 = y1; $f.$s = $s; $f.$r = $r; return $f;
	};
	GeoM.ptr.prototype.String = function() {
		var _r, g, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; g = $f.g; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		g = this;
		_r = fmt.Sprintf("[[%f, %f, %f], [%f, %f, %f]]", new sliceType$1([new $Float32($fround(g.a_1 + 1)), new $Float32(g.b), new $Float32(g.tx), new $Float32(g.c), new $Float32($fround(g.d_1 + 1)), new $Float32(g.ty)])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: GeoM.ptr.prototype.String }; } $f._r = _r; $f.g = g; $f.$s = $s; $f.$r = $r; return $f;
	};
	GeoM.prototype.String = function() { return this.$val.String(); };
	GeoM.ptr.prototype.Reset = function() {
		var g;
		g = this;
		g.a_1 = 0;
		g.b = 0;
		g.c = 0;
		g.d_1 = 0;
		g.tx = 0;
		g.ty = 0;
	};
	GeoM.prototype.Reset = function() { return this.$val.Reset(); };
	GeoM.ptr.prototype.Apply = function(x$1, y) {
		var _tuple, g, x$1, x2, y, y2;
		g = this;
		_tuple = g.apply32(($fround(x$1)), ($fround(y)));
		x2 = _tuple[0];
		y2 = _tuple[1];
		return [(x2), (y2)];
	};
	GeoM.prototype.Apply = function(x$1, y) { return this.$val.Apply(x$1, y); };
	GeoM.ptr.prototype.apply32 = function(x$1, y) {
		var _tmp, _tmp$1, g, x$1, x2, y, y2;
		x2 = 0;
		y2 = 0;
		g = this;
		_tmp = $fround($fround($fround(($fround(g.a_1 + 1)) * x$1) + $fround(g.b * y)) + g.tx);
		_tmp$1 = $fround($fround($fround(g.c * x$1) + $fround(($fround(g.d_1 + 1)) * y)) + g.ty);
		x2 = _tmp;
		y2 = _tmp$1;
		return [x2, y2];
	};
	GeoM.prototype.apply32 = function(x$1, y) { return this.$val.apply32(x$1, y); };
	GeoM.ptr.prototype.elements = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, a, b, c, d, g, tx, ty;
		a = 0;
		b = 0;
		c = 0;
		d = 0;
		tx = 0;
		ty = 0;
		g = this;
		_tmp = $fround(g.a_1 + 1);
		_tmp$1 = g.b;
		_tmp$2 = g.c;
		_tmp$3 = $fround(g.d_1 + 1);
		_tmp$4 = g.tx;
		_tmp$5 = g.ty;
		a = _tmp;
		b = _tmp$1;
		c = _tmp$2;
		d = _tmp$3;
		tx = _tmp$4;
		ty = _tmp$5;
		return [a, b, c, d, tx, ty];
	};
	GeoM.prototype.elements = function() { return this.$val.elements(); };
	GeoM.ptr.prototype.Element = function(i, j) {
		var g, i, j;
		g = this;
		if ((i === 0) && (j === 0)) {
			return (g.a_1) + 1;
		} else if ((i === 0) && (j === 1)) {
			return (g.b);
		} else if ((i === 0) && (j === 2)) {
			return (g.tx);
		} else if ((i === 1) && (j === 0)) {
			return (g.c);
		} else if ((i === 1) && (j === 1)) {
			return (g.d_1) + 1;
		} else if ((i === 1) && (j === 2)) {
			return (g.ty);
		} else {
			$panic(new $String("ebiten: i or j is out of index"));
		}
	};
	GeoM.prototype.Element = function(i, j) { return this.$val.Element(i, j); };
	GeoM.ptr.prototype.Concat = function(other) {
		var a, b, c, d, g, other, tx, ty;
		g = this;
		a = $fround($fround(($fround(other.a_1 + 1)) * ($fround(g.a_1 + 1))) + $fround(other.b * g.c));
		b = $fround($fround(($fround(other.a_1 + 1)) * g.b) + $fround(other.b * ($fround(g.d_1 + 1))));
		tx = $fround($fround($fround(($fround(other.a_1 + 1)) * g.tx) + $fround(other.b * g.ty)) + other.tx);
		c = $fround($fround(other.c * ($fround(g.a_1 + 1))) + $fround(($fround(other.d_1 + 1)) * g.c));
		d = $fround($fround(other.c * g.b) + $fround(($fround(other.d_1 + 1)) * ($fround(g.d_1 + 1))));
		ty = $fround($fround($fround(other.c * g.tx) + $fround(($fround(other.d_1 + 1)) * g.ty)) + other.ty);
		g.a_1 = $fround(a - 1);
		g.b = b;
		g.c = c;
		g.d_1 = $fround(d - 1);
		g.tx = tx;
		g.ty = ty;
	};
	GeoM.prototype.Concat = function(other) { return this.$val.Concat(other); };
	GeoM.ptr.prototype.Add = function(other) {
		var g, other;
		g = this;
		g.a_1 = $fround(g.a_1 + (other.a_1));
		g.b = $fround(g.b + (other.b));
		g.c = $fround(g.c + (other.c));
		g.d_1 = $fround(g.d_1 + (other.d_1));
		g.tx = $fround(g.tx + (other.tx));
		g.ty = $fround(g.ty + (other.ty));
	};
	GeoM.prototype.Add = function(other) { return this.$val.Add(other); };
	GeoM.ptr.prototype.Scale = function(x$1, y) {
		var a, b, c, d, g, tx, ty, x$1, y;
		g = this;
		a = ((g.a_1) + 1) * x$1;
		b = (g.b) * x$1;
		tx = (g.tx) * x$1;
		c = (g.c) * y;
		d = ((g.d_1) + 1) * y;
		ty = (g.ty) * y;
		g.a_1 = $fround(($fround(a)) - 1);
		g.b = ($fround(b));
		g.c = ($fround(c));
		g.d_1 = $fround(($fround(d)) - 1);
		g.tx = ($fround(tx));
		g.ty = ($fround(ty));
	};
	GeoM.prototype.Scale = function(x$1, y) { return this.$val.Scale(x$1, y); };
	GeoM.ptr.prototype.Translate = function(tx, ty) {
		var g, tx, ty;
		g = this;
		g.tx = $fround(g.tx + (($fround(tx))));
		g.ty = $fround(g.ty + (($fround(ty))));
	};
	GeoM.prototype.Translate = function(tx, ty) { return this.$val.Translate(tx, ty); };
	GeoM.ptr.prototype.Rotate = function(theta) {
		var _tmp, _tmp$1, _tuple, a, b, c, cos, cos64, d, g, sin, sin64, theta, tx, ty;
		g = this;
		if (theta === 0) {
			return;
		}
		_tuple = math.Sincos(theta);
		sin64 = _tuple[0];
		cos64 = _tuple[1];
		_tmp = ($fround(sin64));
		_tmp$1 = ($fround(cos64));
		sin = _tmp;
		cos = _tmp$1;
		a = $fround($fround(cos * ($fround(g.a_1 + 1))) - $fround(sin * g.c));
		b = $fround($fround(cos * g.b) - $fround(sin * ($fround(g.d_1 + 1))));
		tx = $fround($fround(cos * g.tx) - $fround(sin * g.ty));
		c = $fround($fround(sin * ($fround(g.a_1 + 1))) + $fround(cos * g.c));
		d = $fround($fround(sin * g.b) + $fround(cos * ($fround(g.d_1 + 1))));
		ty = $fround($fround(sin * g.tx) + $fround(cos * g.ty));
		g.a_1 = $fround(a - 1);
		g.b = b;
		g.c = c;
		g.d_1 = $fround(d - 1);
		g.tx = tx;
		g.ty = ty;
	};
	GeoM.prototype.Rotate = function(theta) { return this.$val.Rotate(theta); };
	GeoM.ptr.prototype.Skew = function(skewX, skewY) {
		var _tmp, _tmp$1, a, b, c, d, g, skewX, skewY, sx, sx64, sy, sy64, tx, ty;
		g = this;
		sx64 = math.Tan(skewX);
		sy64 = math.Tan(skewY);
		_tmp = ($fround(sx64));
		_tmp$1 = ($fround(sy64));
		sx = _tmp;
		sy = _tmp$1;
		a = $fround(($fround(g.a_1 + 1)) + $fround(g.c * sx));
		b = $fround(g.b + $fround(($fround(g.d_1 + 1)) * sx));
		c = $fround($fround(($fround(g.a_1 + 1)) * sy) + g.c);
		d = $fround($fround(g.b * sy) + ($fround(g.d_1 + 1)));
		tx = $fround(g.tx + $fround(g.ty * sx));
		ty = $fround(g.ty + $fround(g.tx * sy));
		g.a_1 = $fround(a - 1);
		g.b = b;
		g.c = c;
		g.d_1 = $fround(d - 1);
		g.tx = tx;
		g.ty = ty;
	};
	GeoM.prototype.Skew = function(skewX, skewY) { return this.$val.Skew(skewX, skewY); };
	GeoM.ptr.prototype.det = function() {
		var g;
		g = this;
		return $fround($fround(($fround(g.a_1 + 1)) * ($fround(g.d_1 + 1))) - $fround(g.b * g.c));
	};
	GeoM.prototype.det = function() { return this.$val.det(); };
	GeoM.ptr.prototype.IsInvertible = function() {
		var g;
		g = this;
		return !((g.det() === 0));
	};
	GeoM.prototype.IsInvertible = function() { return this.$val.IsInvertible(); };
	GeoM.ptr.prototype.Invert = function() {
		var a, b, c, d, det, g, tx, ty;
		g = this;
		det = g.det();
		if (det === 0) {
			$panic(new $String("ebiten: g is not invertible"));
		}
		a = $fround(($fround(g.d_1 + 1)) / det);
		b = $fround(-g.b / det);
		c = $fround(-g.c / det);
		d = $fround(($fround(g.a_1 + 1)) / det);
		tx = $fround(($fround($fround(-($fround(g.d_1 + 1)) * g.tx) + $fround(g.b * g.ty))) / det);
		ty = $fround(($fround($fround(g.c * g.tx) + $fround(-($fround(g.a_1 + 1)) * g.ty))) / det);
		g.a_1 = $fround(a - 1);
		g.b = b;
		g.c = c;
		g.d_1 = $fround(d - 1);
		g.tx = tx;
		g.ty = ty;
	};
	GeoM.prototype.Invert = function() { return this.$val.Invert(); };
	GeoM.ptr.prototype.SetElement = function(i, j, element) {
		var e, element, g, i, j;
		g = this;
		e = ($fround(element));
		if ((i === 0) && (j === 0)) {
			g.a_1 = $fround(e - 1);
		} else if ((i === 0) && (j === 1)) {
			g.b = e;
		} else if ((i === 0) && (j === 2)) {
			g.tx = e;
		} else if ((i === 1) && (j === 0)) {
			g.c = e;
		} else if ((i === 1) && (j === 1)) {
			g.d_1 = $fround(e - 1);
		} else if ((i === 1) && (j === 2)) {
			g.ty = e;
		} else {
			$panic(new $String("ebiten: i or j is out of index"));
		}
	};
	GeoM.prototype.SetElement = function(i, j, element) { return this.$val.SetElement(i, j, element); };
	graphicsDriver = function() {
		return opengl.Get();
	};
	Image.ptr.prototype.copyCheck = function() {
		var i;
		i = this;
		if (!(i.addr === i)) {
			$panic(new $String("ebiten: illegal use of non-zero Image copied by value"));
		}
	};
	Image.prototype.copyCheck = function() { return this.$val.copyCheck(); };
	Image.ptr.prototype.Size = function() {
		var _tmp, _tmp$1, height, i, s, width;
		width = 0;
		height = 0;
		i = this;
		s = $clone($clone(i.Bounds(), image.Rectangle).Size(), image.Point);
		_tmp = s.X;
		_tmp$1 = s.Y;
		width = _tmp;
		height = _tmp$1;
		return [width, height];
	};
	Image.prototype.Size = function() { return this.$val.Size(); };
	Image.ptr.prototype.isDisposed = function() {
		var i;
		i = this;
		return i.mipmap.isDisposed();
	};
	Image.prototype.isDisposed = function() { return this.$val.isDisposed(); };
	Image.ptr.prototype.isSubImage = function() {
		var i;
		i = this;
		return !(i.original === ptrType$2.nil);
	};
	Image.prototype.isSubImage = function() { return this.$val.isSubImage(); };
	Image.ptr.prototype.Clear = function() {
		var _r, i, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_r = i.Fill((x$1 = color.Transparent, new x$1.constructor.elem(x$1))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.Clear }; } $f._r = _r; $f.i = i; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.Clear = function() { return this.$val.Clear(); };
	Image.ptr.prototype.Fill = function(clr) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, a, a16, b, b16, clr, g, g16, i, r, r16, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; a = $f.a; a16 = $f.a16; b = $f.b; b16 = $f.b16; clr = $f.clr; g = $f.g; g16 = $f.g16; i = $f.i; r = $f.r; r16 = $f.r16; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		i.copyCheck();
		if (i.isDisposed()) {
			$s = -1; return $ifaceNil;
		}
		if (i.isSubImage()) {
			$panic(new $String("ebiten: render to a subimage is not implemented (Fill)"));
		}
		$r = i.resolvePendingPixels(false); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r = clr.RGBA(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r16 = _tuple[0];
		g16 = _tuple[1];
		b16 = _tuple[2];
		a16 = _tuple[3];
		_tmp = (((r16 >>> 8 >>> 0) << 24 >>> 24));
		_tmp$1 = (((g16 >>> 8 >>> 0) << 24 >>> 24));
		_tmp$2 = (((b16 >>> 8 >>> 0) << 24 >>> 24));
		_tmp$3 = (((a16 >>> 8 >>> 0) << 24 >>> 24));
		r = _tmp;
		g = _tmp$1;
		b = _tmp$2;
		a = _tmp$3;
		$r = i.mipmap.original().Fill(r, g, b, a); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = i.disposeMipmaps(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.Fill }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.a = a; $f.a16 = a16; $f.b = b; $f.b16 = b16; $f.clr = clr; $f.g = g; $f.g16 = g16; $f.i = i; $f.r = r; $f.r16 = r16; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.Fill = function(clr) { return this.$val.Fill(clr); };
	Image.ptr.prototype.disposeMipmaps = function() {
		var i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (i.isDisposed()) {
			$panic(new $String("ebiten: the image is already disposed at disposeMipmap"));
		}
		$r = i.mipmap.disposeMipmaps(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.disposeMipmaps }; } $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.disposeMipmaps = function() { return this.$val.disposeMipmaps(); };
	Image.ptr.prototype.DrawImage = function(img, options) {
		var _q, _q$1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _v, a, b, body, bounds, c, ca, cb, cg, colorm, cr, d, det, dx0, dx1, dy0, dy1, filter, geom, h, h$1, i, idx, img, is, is$1, l, level, mode, op, options, parts, s, s$1, src, src$1, sx0, sx1, sy0, sy1, tx, ty, vs, vs$1, w, w$1, x$1, y, y$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _q = $f._q; _q$1 = $f._q$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _v = $f._v; a = $f.a; b = $f.b; body = $f.body; bounds = $f.bounds; c = $f.c; ca = $f.ca; cb = $f.cb; cg = $f.cg; colorm = $f.colorm; cr = $f.cr; d = $f.d; det = $f.det; dx0 = $f.dx0; dx1 = $f.dx1; dy0 = $f.dy0; dy1 = $f.dy1; filter = $f.filter; geom = $f.geom; h = $f.h; h$1 = $f.h$1; i = $f.i; idx = $f.idx; img = $f.img; is = $f.is; is$1 = $f.is$1; l = $f.l; level = $f.level; mode = $f.mode; op = $f.op; options = $f.options; parts = $f.parts; s = $f.s; s$1 = $f.s$1; src = $f.src; src$1 = $f.src$1; sx0 = $f.sx0; sx1 = $f.sx1; sy0 = $f.sy0; sy1 = $f.sy1; tx = $f.tx; ty = $f.ty; vs = $f.vs; vs$1 = $f.vs$1; w = $f.w; w$1 = $f.w$1; x$1 = $f.x$1; y = $f.y; y$1 = $f.y$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		i.copyCheck();
		if (img.isDisposed()) {
			$panic(new $String("ebiten: the given image to DrawImage must not be disposed"));
		}
		if (i.isDisposed()) {
			$s = -1; return $ifaceNil;
		}
		if (i.isSubImage()) {
			$panic(new $String("ebiten: render to a subimage is not implemented (drawImage)"));
		}
		$r = img.resolvePendingPixels(true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = i.resolvePendingPixels(true); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (options === ptrType$3.nil) {
			options = new DrawImageOptions.ptr(new GeoM.ptr(0, 0, 0, 0, 0, 0), new ColorM.ptr(ptrType.nil), 0, 0, $ifaceNil, sliceType$3.nil, ptrType$4.nil);
		}
		parts = options.ImageParts;
		if ($interfaceIsEqual(parts, $ifaceNil) && !(options.Parts === sliceType$3.nil)) {
			parts = ((x$1 = options.Parts, $subslice(new imageParts(x$1.$array), x$1.$offset, x$1.$offset + x$1.$length)));
		}
		/* */ if (!($interfaceIsEqual(parts, $ifaceNil))) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (!($interfaceIsEqual(parts, $ifaceNil))) { */ case 3:
			_r = parts.Len(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			l = _r;
			idx = 0;
			/* while (true) { */ case 6:
				/* if (!(idx < l)) { break; } */ if(!(idx < l)) { $s = 7; continue; }
				_r$1 = parts.Src(idx); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_tuple = _r$1;
				sx0 = _tuple[0];
				sy0 = _tuple[1];
				sx1 = _tuple[2];
				sy1 = _tuple[3];
				_r$2 = parts.Dst(idx); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_tuple$1 = _r$2;
				dx0 = _tuple$1[0];
				dy0 = _tuple$1[1];
				dx1 = _tuple$1[2];
				dy1 = _tuple$1[3];
				op = new DrawImageOptions.ptr(new GeoM.ptr(0, 0, 0, 0, 0, 0), $clone(options.ColorM, ColorM), options.CompositeMode, options.Filter, $ifaceNil, sliceType$3.nil, ptrType$4.nil);
				op.GeoM.Scale(((dx1 - dx0 >> 0)) / ((sx1 - sx0 >> 0)), ((dy1 - dy0 >> 0)) / ((sy1 - sy0 >> 0)));
				op.GeoM.Translate((dx0), (dy0));
				op.GeoM.Concat($clone(options.GeoM, GeoM));
				_r$3 = i.DrawImage($assertType(img.SubImage($clone(image.Rect(sx0, sy0, sx1, sy1), image.Rectangle)), ptrType$2), op); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				_r$3;
				idx = idx + (1) >> 0;
			/* } */ $s = 6; continue; case 7:
			$s = -1; return $ifaceNil;
		/* } */ case 4:
		bounds = $clone(img.Bounds(), image.Rectangle);
		if (!(options.SourceRect === ptrType$4.nil)) {
			image.Rectangle.copy(bounds, $clone(bounds, image.Rectangle).Intersect($clone(options.SourceRect, image.Rectangle)));
			if ($clone(bounds, image.Rectangle).Empty()) {
				$s = -1; return $ifaceNil;
			}
		}
		geom = options.GeoM;
		mode = ((options.CompositeMode >> 0));
		filter = 1;
		if (!((options.Filter === 0))) {
			filter = ((options.Filter >> 0));
		} else if (!((img.filter === 0))) {
			filter = ((img.filter >> 0));
		}
		_tuple$2 = geom.elements();
		a = _tuple$2[0];
		b = _tuple$2[1];
		c = _tuple$2[2];
		d = _tuple$2[3];
		tx = _tuple$2[4];
		ty = _tuple$2[5];
		level = 0;
		if (!(filter === 2)) { _v = false; $s = 13; continue s; }
		_r$4 = img.mipmap.original().IsVolatile(); /* */ $s = 14; case 14: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		_v = !_r$4; case 13:
		/* */ if (_v) { $s = 11; continue; }
		/* */ $s = 12; continue;
		/* if (_v) { */ case 11:
			det = geom.det();
			if (det === 0) {
				$s = -1; return $ifaceNil;
			}
			if (math.IsNaN((det))) {
				$s = -1; return $ifaceNil;
			}
			level = mipmapLevel(det);
			/* */ if (level < 0) { $s = 15; continue; }
			/* */ $s = 16; continue;
			/* if (level < 0) { */ case 15:
				_r$5 = fmt.Sprintf("ebiten: level must be >= 0 but %d", new sliceType$1([new $Int(level)])); /* */ $s = 17; case 17: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				$panic(new $String(_r$5));
			/* } */ case 16:
			_tmp = $clone(bounds, image.Rectangle).Dx();
			_tmp$1 = $clone(bounds, image.Rectangle).Dy();
			w = _tmp;
			h = _tmp$1;
			while (true) {
				if (!(level >= 0)) { break; }
				s = (y = ((level >>> 0)), y < 32 ? (1 << y) : 0) >> 0;
				if (((_q = w / s, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) === 0) || ((_q$1 = h / s, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero")) === 0)) {
					level = level - (1) >> 0;
					continue;
				}
				break;
			}
			if (level < 0) {
				$s = -1; return $ifaceNil;
			}
		/* } */ case 12:
		if (level > 6) {
			level = 6;
		}
		colorm = options.ColorM.impl;
		_tmp$2 = 1;
		_tmp$3 = 1;
		_tmp$4 = 1;
		_tmp$5 = 1;
		cr = _tmp$2;
		cg = _tmp$3;
		cb = _tmp$4;
		ca = _tmp$5;
		if (colorm.ScaleOnly()) {
			_tuple$3 = colorm.UnsafeElements();
			body = _tuple$3[0];
			cr = (0 >= body.$length ? ($throwRuntimeError("index out of range"), undefined) : body.$array[body.$offset + 0]);
			cg = (5 >= body.$length ? ($throwRuntimeError("index out of range"), undefined) : body.$array[body.$offset + 5]);
			cb = (10 >= body.$length ? ($throwRuntimeError("index out of range"), undefined) : body.$array[body.$offset + 10]);
			ca = (15 >= body.$length ? ($throwRuntimeError("index out of range"), undefined) : body.$array[body.$offset + 15]);
			colorm = ptrType.nil;
		}
		/* */ if (level === 0) { $s = 18; continue; }
		/* */ $s = 19; continue;
		/* if (level === 0) { */ case 18:
			src = img.mipmap.original();
			_r$6 = vertexSlice(4); /* */ $s = 21; case 21: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
			vs = _r$6;
			$r = graphics.PutQuadVertices(vs, src, bounds.Min.X, bounds.Min.Y, bounds.Max.X, bounds.Max.Y, a, b, c, d, tx, ty, cr, cg, cb, ca); /* */ $s = 22; case 22: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			is = graphics.QuadIndices();
			$r = i.mipmap.original().DrawTriangles(src, vs, is, colorm, mode, filter, 0); /* */ $s = 23; case 23: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 20; continue;
		/* } else { */ case 19:
			_r$7 = img.mipmap.level($clone(bounds, image.Rectangle), level); /* */ $s = 24; case 24: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			src$1 = _r$7;
			/* */ if (!(src$1 === ptrType$5.nil)) { $s = 25; continue; }
			/* */ $s = 26; continue;
			/* if (!(src$1 === ptrType$5.nil)) { */ case 25:
				_tuple$4 = src$1.Size();
				w$1 = _tuple$4[0];
				h$1 = _tuple$4[1];
				s$1 = (y$1 = ((level >>> 0)), y$1 < 32 ? (1 << y$1) : 0) >> 0;
				a = $fround(a * ((s$1)));
				b = $fround(b * ((s$1)));
				c = $fround(c * ((s$1)));
				d = $fround(d * ((s$1)));
				_r$8 = vertexSlice(4); /* */ $s = 27; case 27: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				vs$1 = _r$8;
				$r = graphics.PutQuadVertices(vs$1, src$1, 0, 0, w$1, h$1, a, b, c, d, tx, ty, cr, cg, cb, ca); /* */ $s = 28; case 28: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				is$1 = graphics.QuadIndices();
				$r = i.mipmap.original().DrawTriangles(src$1, vs$1, is$1, colorm, mode, filter, 0); /* */ $s = 29; case 29: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 26:
		/* } */ case 20:
		$r = i.disposeMipmaps(); /* */ $s = 30; case 30: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.DrawImage }; } $f._q = _q; $f._q$1 = _q$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._v = _v; $f.a = a; $f.b = b; $f.body = body; $f.bounds = bounds; $f.c = c; $f.ca = ca; $f.cb = cb; $f.cg = cg; $f.colorm = colorm; $f.cr = cr; $f.d = d; $f.det = det; $f.dx0 = dx0; $f.dx1 = dx1; $f.dy0 = dy0; $f.dy1 = dy1; $f.filter = filter; $f.geom = geom; $f.h = h; $f.h$1 = h$1; $f.i = i; $f.idx = idx; $f.img = img; $f.is = is; $f.is$1 = is$1; $f.l = l; $f.level = level; $f.mode = mode; $f.op = op; $f.options = options; $f.parts = parts; $f.s = s; $f.s$1 = s$1; $f.src = src; $f.src$1 = src$1; $f.sx0 = sx0; $f.sx1 = sx1; $f.sy0 = sy0; $f.sy1 = sy1; $f.tx = tx; $f.ty = ty; $f.vs = vs; $f.vs$1 = vs$1; $f.w = w; $f.w$1 = w$1; $f.x$1 = x$1; $f.y = y; $f.y$1 = y$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.DrawImage = function(img, options) { return this.$val.DrawImage(img, options); };
	Image.ptr.prototype.DrawTriangles = function(vertices, indices, img, options) {
		var _i, _r, _r$1, _ref, filter, i, idx, img, indices, mode, options, r, src, v, vertices, vs, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; filter = $f.filter; i = $f.i; idx = $f.idx; img = $f.img; indices = $f.indices; mode = $f.mode; options = $f.options; r = $f.r; src = $f.src; v = $f.v; vertices = $f.vertices; vs = $f.vs; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		i.copyCheck();
		if (i.isDisposed()) {
			$s = -1; return;
		}
		if (i.isSubImage()) {
			$panic(new $String("ebiten: render to a subimage is not implemented (DrawTriangles)"));
		}
		$r = img.resolvePendingPixels(true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = i.resolvePendingPixels(true); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!(((_r = indices.$length % 3, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0))) {
			$panic(new $String("ebiten: len(indices) % 3 must be 0"));
		}
		if (indices.$length > 65535) {
			$panic(new $String("ebiten: len(indices) must be <= MaxIndicesNum"));
		}
		if (options === ptrType$6.nil) {
			options = new DrawTrianglesOptions.ptr(new ColorM.ptr(ptrType.nil), 0, 0, 0);
		}
		mode = ((options.CompositeMode >> 0));
		filter = 1;
		if (!((options.Filter === 0))) {
			filter = ((options.Filter >> 0));
		} else if (!((img.filter === 0))) {
			filter = ((img.filter >> 0));
		}
		_r$1 = vertexSlice(vertices.$length); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		vs = _r$1;
		src = img.mipmap.original();
		r = $clone(img.Bounds(), image.Rectangle);
		_ref = vertices;
		_i = 0;
		/* while (true) { */ case 4:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
			idx = _i;
			v = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Vertex);
			$r = src.PutVertex($subslice(vs, ($imul(idx, 12)), ($imul(((idx + 1 >> 0)), 12))), (v.DstX), (v.DstY), v.SrcX, v.SrcY, (r.Min.X), (r.Min.Y), (r.Max.X), (r.Max.Y), v.ColorR, v.ColorG, v.ColorB, v.ColorA); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 4; continue; case 5:
		$r = i.mipmap.original().DrawTriangles(img.mipmap.original(), vs, indices, options.ColorM.impl, mode, filter, ((options.Address >> 0))); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = i.disposeMipmaps(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.DrawTriangles }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f.filter = filter; $f.i = i; $f.idx = idx; $f.img = img; $f.indices = indices; $f.mode = mode; $f.options = options; $f.r = r; $f.src = src; $f.v = v; $f.vertices = vertices; $f.vs = vs; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.DrawTriangles = function(vertices, indices, img, options) { return this.$val.DrawTriangles(vertices, indices, img, options); };
	Image.ptr.prototype.SubImage = function(r) {
		var i, img, r;
		i = this;
		i.copyCheck();
		if (i.isDisposed()) {
			return $ifaceNil;
		}
		img = new Image.ptr(ptrType$2.nil, i.mipmap, new image.Rectangle.ptr(new image.Point.ptr(0, 0), new image.Point.ptr(0, 0)), ptrType$2.nil, sliceType$2.nil, i.filter);
		if (i.isSubImage()) {
			img.original = i.original;
		} else {
			img.original = i;
		}
		img.addr = img;
		image.Rectangle.copy(r, $clone(r, image.Rectangle).Intersect($clone(i.Bounds(), image.Rectangle)));
		if ($clone(r, image.Rectangle).Empty()) {
			image.Rectangle.copy(img.bounds, image.ZR);
		} else {
			image.Rectangle.copy(img.bounds, r);
		}
		return img;
	};
	Image.prototype.SubImage = function(r) { return this.$val.SubImage(r); };
	Image.ptr.prototype.Bounds = function() {
		var _tuple, h, i, w;
		i = this;
		if (i.isDisposed()) {
			$panic(new $String("ebiten: the image is already disposed"));
		}
		if (!i.isSubImage()) {
			_tuple = i.mipmap.original().Size();
			w = _tuple[0];
			h = _tuple[1];
			return image.Rect(0, 0, w, h);
		}
		return i.bounds;
	};
	Image.prototype.Bounds = function() { return this.$val.Bounds(); };
	Image.ptr.prototype.ColorModel = function() {
		var i;
		i = this;
		return color.RGBAModel;
	};
	Image.prototype.ColorModel = function() { return this.$val.ColorModel(); };
	Image.ptr.prototype.At = function(x$1, y) {
		var _r, _tuple, a, b, g, i, r, x$1, x$2, x$3, x$4, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; a = $f.a; b = $f.b; g = $f.g; i = $f.i; r = $f.r; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (atomic.LoadInt32((isRunning$24ptr || (isRunning$24ptr = new ptrType$8(function() { return isRunning; }, function($v) { isRunning = $v; })))) === 0) {
			$panic(new $String("ebiten: (*Image).At is not available outside the main loop so far"));
		}
		if (i.isDisposed()) {
			$s = -1; return (x$2 = new color.RGBA.ptr(0, 0, 0, 0), new x$2.constructor.elem(x$2));
		}
		if (i.isSubImage() && !$clone(image.Pt(x$1, y), image.Point).In($clone(i.bounds, image.Rectangle))) {
			$s = -1; return (x$3 = new color.RGBA.ptr(0, 0, 0, 0), new x$3.constructor.elem(x$3));
		}
		$r = i.resolvePendingPixels(true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r = i.mipmap.original().At(x$1, y); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		r = _tuple[0];
		g = _tuple[1];
		b = _tuple[2];
		a = _tuple[3];
		$s = -1; return (x$4 = new color.RGBA.ptr(r, g, b, a), new x$4.constructor.elem(x$4));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.At }; } $f._r = _r; $f._tuple = _tuple; $f.a = a; $f.b = b; $f.g = g; $f.i = i; $f.r = r; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.At = function(x$1, y) { return this.$val.At(x$1, y); };
	Image.ptr.prototype.Set = function(x$1, y, clr) {
		var _r, _r$1, _tuple, _tuple$1, _tuple$2, a, a$1, b, b$1, clr, g, g$1, h, i, idx, img, j, pix, r, r$1, w, x$1, x$10, x$11, x$12, x$13, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; a = $f.a; a$1 = $f.a$1; b = $f.b; b$1 = $f.b$1; clr = $f.clr; g = $f.g; g$1 = $f.g$1; h = $f.h; i = $f.i; idx = $f.idx; img = $f.img; j = $f.j; pix = $f.pix; r = $f.r; r$1 = $f.r$1; w = $f.w; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		img = this;
		if (atomic.LoadInt32((isRunning$24ptr || (isRunning$24ptr = new ptrType$8(function() { return isRunning; }, function($v) { isRunning = $v; })))) === 0) {
			$panic(new $String("ebiten: (*Image).Set is not available outside the main loop so far"));
		}
		img.copyCheck();
		if (img.isDisposed()) {
			$s = -1; return;
		}
		if (img.isSubImage() && !$clone(image.Pt(x$1, y), image.Point).In($clone(img.bounds, image.Rectangle))) {
			$s = -1; return;
		}
		if (img.isSubImage()) {
			img = img.original;
		}
		_tuple = img.Size();
		w = _tuple[0];
		h = _tuple[1];
		/* */ if (img.pendingPixels === sliceType$2.nil) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (img.pendingPixels === sliceType$2.nil) { */ case 1:
			pix = $makeSlice(sliceType$2, ($imul(($imul(4, w)), h)));
			idx = 0;
			j = 0;
			/* while (true) { */ case 3:
				/* if (!(j < h)) { break; } */ if(!(j < h)) { $s = 4; continue; }
				i = 0;
				/* while (true) { */ case 5:
					/* if (!(i < w)) { break; } */ if(!(i < w)) { $s = 6; continue; }
					_r = img.mipmap.original().At(i, j); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					_tuple$1 = _r;
					r = _tuple$1[0];
					g = _tuple$1[1];
					b = _tuple$1[2];
					a = _tuple$1[3];
					(x$2 = $imul(4, idx), ((x$2 < 0 || x$2 >= pix.$length) ? ($throwRuntimeError("index out of range"), undefined) : pix.$array[pix.$offset + x$2] = r));
					(x$3 = ($imul(4, idx)) + 1 >> 0, ((x$3 < 0 || x$3 >= pix.$length) ? ($throwRuntimeError("index out of range"), undefined) : pix.$array[pix.$offset + x$3] = g));
					(x$4 = ($imul(4, idx)) + 2 >> 0, ((x$4 < 0 || x$4 >= pix.$length) ? ($throwRuntimeError("index out of range"), undefined) : pix.$array[pix.$offset + x$4] = b));
					(x$5 = ($imul(4, idx)) + 3 >> 0, ((x$5 < 0 || x$5 >= pix.$length) ? ($throwRuntimeError("index out of range"), undefined) : pix.$array[pix.$offset + x$5] = a));
					idx = idx + (1) >> 0;
					i = i + (1) >> 0;
				/* } */ $s = 5; continue; case 6:
				j = j + (1) >> 0;
			/* } */ $s = 3; continue; case 4:
			img.pendingPixels = pix;
		/* } */ case 2:
		_r$1 = clr.RGBA(); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$2 = _r$1;
		r$1 = _tuple$2[0];
		g$1 = _tuple$2[1];
		b$1 = _tuple$2[2];
		a$1 = _tuple$2[3];
		(x$6 = img.pendingPixels, x$7 = $imul(4, ((x$1 + ($imul(y, w)) >> 0))), ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7] = (((r$1 >>> 8 >>> 0) << 24 >>> 24))));
		(x$8 = img.pendingPixels, x$9 = ($imul(4, ((x$1 + ($imul(y, w)) >> 0)))) + 1 >> 0, ((x$9 < 0 || x$9 >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + x$9] = (((g$1 >>> 8 >>> 0) << 24 >>> 24))));
		(x$10 = img.pendingPixels, x$11 = ($imul(4, ((x$1 + ($imul(y, w)) >> 0)))) + 2 >> 0, ((x$11 < 0 || x$11 >= x$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$10.$array[x$10.$offset + x$11] = (((b$1 >>> 8 >>> 0) << 24 >>> 24))));
		(x$12 = img.pendingPixels, x$13 = ($imul(4, ((x$1 + ($imul(y, w)) >> 0)))) + 3 >> 0, ((x$13 < 0 || x$13 >= x$12.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$12.$array[x$12.$offset + x$13] = (((a$1 >>> 8 >>> 0) << 24 >>> 24))));
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.Set }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.a = a; $f.a$1 = a$1; $f.b = b; $f.b$1 = b$1; $f.clr = clr; $f.g = g; $f.g$1 = g$1; $f.h = h; $f.i = i; $f.idx = idx; $f.img = img; $f.j = j; $f.pix = pix; $f.r = r; $f.r$1 = r$1; $f.w = w; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.Set = function(x$1, y, clr) { return this.$val.Set(x$1, y, clr); };
	Image.ptr.prototype.resolvePendingPixels = function(draw$1) {
		var _r, draw$1, i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; draw$1 = $f.draw$1; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		/* */ if (i.isSubImage()) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (i.isSubImage()) { */ case 1:
			$r = i.original.resolvePendingPixels(draw$1); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return;
		/* } */ case 2:
		if (i.pendingPixels === sliceType$2.nil) {
			$s = -1; return;
		}
		if (!draw$1) {
			i.pendingPixels = sliceType$2.nil;
			$s = -1; return;
		}
		_r = i.ReplacePixels(i.pendingPixels); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		i.pendingPixels = sliceType$2.nil;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.resolvePendingPixels }; } $f._r = _r; $f.draw$1 = draw$1; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.resolvePendingPixels = function(draw$1) { return this.$val.resolvePendingPixels(draw$1); };
	Image.ptr.prototype.Dispose = function() {
		var i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		i.copyCheck();
		if (i.isDisposed()) {
			$s = -1; return $ifaceNil;
		}
		if (i.isSubImage()) {
			$s = -1; return $ifaceNil;
		}
		$r = i.mipmap.dispose(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = i.resolvePendingPixels(false); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.Dispose }; } $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.Dispose = function() { return this.$val.Dispose(); };
	Image.ptr.prototype.ReplacePixels = function(p) {
		var _r, i, l, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; l = $f.l; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		i.copyCheck();
		if (i.isDisposed()) {
			$s = -1; return $ifaceNil;
		}
		if (i.isSubImage()) {
			$panic(new $String("ebiten: render to a subimage is not implemented (ReplacePixels)"));
		}
		$r = i.resolvePendingPixels(false); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		s = $clone($clone(i.Bounds(), image.Rectangle).Size(), image.Point);
		l = $imul(($imul(4, s.X)), s.Y);
		/* */ if (!((p.$length === l))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((p.$length === l))) { */ case 2:
			_r = fmt.Sprintf("ebiten: len(p) was %d but must be %d", new sliceType$1([new $Int(p.$length), new $Int(l)])); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$panic(new $String(_r));
		/* } */ case 3:
		$r = i.mipmap.original().ReplacePixels(p); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = i.disposeMipmaps(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.ReplacePixels }; } $f._r = _r; $f.i = i; $f.l = l; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.ReplacePixels = function(p) { return this.$val.ReplacePixels(p); };
	NewImage = function(width, height, filter) {
		var filter, height, i, s, width;
		s = shareable.NewImage(width, height);
		i = new Image.ptr(ptrType$2.nil, newMipmap(s), new image.Rectangle.ptr(new image.Point.ptr(0, 0), new image.Point.ptr(0, 0)), ptrType$2.nil, sliceType$2.nil, filter);
		i.addr = i;
		return [i, $ifaceNil];
	};
	$pkg.NewImage = NewImage;
	Image.ptr.prototype.makeVolatile = function() {
		var i, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		if (i.isDisposed()) {
			$s = -1; return;
		}
		$r = i.mipmap.orig.MakeVolatile(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = i.disposeMipmaps(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Image.ptr.prototype.makeVolatile }; } $f.i = i; $f.$s = $s; $f.$r = $r; return $f;
	};
	Image.prototype.makeVolatile = function() { return this.$val.makeVolatile(); };
	NewImageFromImage = function(source, filter) {
		var _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, filter, height, i, s, size, source, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; filter = $f.filter; height = $f.height; i = $f.i; s = $f.s; size = $f.size; source = $f.source; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = source.Bounds(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = $clone(_r, image.Rectangle).Size(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		size = $clone(_r$1, image.Point);
		_tmp = size.X;
		_tmp$1 = size.Y;
		width = _tmp;
		height = _tmp$1;
		s = shareable.NewImage(width, height);
		i = new Image.ptr(ptrType$2.nil, newMipmap(s), new image.Rectangle.ptr(new image.Point.ptr(0, 0), new image.Point.ptr(0, 0)), ptrType$2.nil, sliceType$2.nil, filter);
		i.addr = i;
		_r$2 = copyImage(source); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$3 = i.ReplacePixels(_r$2); /* */ $s = 4; case 4: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		$unused(_r$3);
		$s = -1; return [i, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: NewImageFromImage }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.filter = filter; $f.height = height; $f.i = i; $f.s = s; $f.size = size; $f.source = source; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.NewImageFromImage = NewImageFromImage;
	newImageWithScreenFramebuffer = function(width, height) {
		var _r, _r$1, height, i, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; height = $f.height; i = $f.i; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = shareable.NewScreenFramebufferImage(width, height); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = newMipmap(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		i = new Image.ptr(ptrType$2.nil, _r$1, new image.Rectangle.ptr(new image.Point.ptr(0, 0), new image.Point.ptr(0, 0)), ptrType$2.nil, sliceType$2.nil, 0);
		i.addr = i;
		$s = -1; return i;
		/* */ } return; } if ($f === undefined) { $f = { $blk: newImageWithScreenFramebuffer }; } $f._r = _r; $f._r$1 = _r$1; $f.height = height; $f.i = i; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	imageDumper.ptr.prototype.update = function(screen) {
		var _r, i, screen, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; screen = $f.screen; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = this;
		_r = i.f(screen); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: imageDumper.ptr.prototype.update }; } $f._r = _r; $f.i = i; $f.screen = screen; $f.$s = $s; $f.$r = $r; return $f;
	};
	imageDumper.prototype.update = function(screen) { return this.$val.update(screen); };
	imageParts.prototype.Len = function() {
		var p;
		p = this;
		return p.$length;
	};
	$ptrType(imageParts).prototype.Len = function() { return this.$get().Len(); };
	imageParts.prototype.Dst = function(i) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, dst, i, p, x0, x1, y0, y1;
		x0 = 0;
		y0 = 0;
		x1 = 0;
		y1 = 0;
		p = this;
		dst = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]).Dst;
		_tmp = dst.Min.X;
		_tmp$1 = dst.Min.Y;
		_tmp$2 = dst.Max.X;
		_tmp$3 = dst.Max.Y;
		x0 = _tmp;
		y0 = _tmp$1;
		x1 = _tmp$2;
		y1 = _tmp$3;
		return [x0, y0, x1, y1];
	};
	$ptrType(imageParts).prototype.Dst = function(i) { return this.$get().Dst(i); };
	imageParts.prototype.Src = function(i) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, i, p, src, x0, x1, y0, y1;
		x0 = 0;
		y0 = 0;
		x1 = 0;
		y1 = 0;
		p = this;
		src = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]).Src;
		_tmp = src.Min.X;
		_tmp$1 = src.Min.Y;
		_tmp$2 = src.Max.X;
		_tmp$3 = src.Max.Y;
		x0 = _tmp;
		y0 = _tmp$1;
		x1 = _tmp$2;
		y1 = _tmp$3;
		return [x0, y0, x1, y1];
	};
	$ptrType(imageParts).prototype.Src = function(i) { return this.$get().Src(i); };
	IsKeyPressed = function(key) {
		var _r, _r$1, key, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; key = $f.key; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = uiDriver().Input(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = _r.IsKeyPressed(((key >> 0))); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: IsKeyPressed }; } $f._r = _r; $f._r$1 = _r$1; $f.key = key; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.IsKeyPressed = IsKeyPressed;
	CursorPosition = function() {
		var _r, _r$1, _tuple, x$1, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; x$1 = $f.x$1; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		x$1 = 0;
		y = 0;
		_r = uiDriver().Input(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = _r.CursorPosition(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		x$1 = _tuple[0];
		y = _tuple[1];
		$s = -1; return [x$1, y];
		/* */ } return; } if ($f === undefined) { $f = { $blk: CursorPosition }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.x$1 = x$1; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.CursorPosition = CursorPosition;
	IsMouseButtonPressed = function(mouseButton) {
		var _r, _r$1, mouseButton, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; mouseButton = $f.mouseButton; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = uiDriver().Input(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = _r.IsMouseButtonPressed(((mouseButton >> 0))); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: IsMouseButtonPressed }; } $f._r = _r; $f._r$1 = _r$1; $f.mouseButton = mouseButton; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.IsMouseButtonPressed = IsMouseButtonPressed;
	GamepadIDs = function() {
		var _r, _r$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = uiDriver().Input(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = _r.GamepadIDs(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: GamepadIDs }; } $f._r = _r; $f._r$1 = _r$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.GamepadIDs = GamepadIDs;
	GamepadButtonNum = function(id) {
		var _r, _r$1, id, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; id = $f.id; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = uiDriver().Input(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = _r.GamepadButtonNum(id); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: GamepadButtonNum }; } $f._r = _r; $f._r$1 = _r$1; $f.id = id; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.GamepadButtonNum = GamepadButtonNum;
	IsGamepadButtonPressed = function(id, button) {
		var _r, _r$1, button, id, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; button = $f.button; id = $f.id; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = uiDriver().Input(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = _r.IsGamepadButtonPressed(id, ((button >> 0))); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: IsGamepadButtonPressed }; } $f._r = _r; $f._r$1 = _r$1; $f.button = button; $f.id = id; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.IsGamepadButtonPressed = IsGamepadButtonPressed;
	TouchIDs = function() {
		var _r, _r$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = uiDriver().Input(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = _r.TouchIDs(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TouchIDs }; } $f._r = _r; $f._r$1 = _r$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TouchIDs = TouchIDs;
	TouchPosition = function(id) {
		var _i, _r, _r$1, _r$2, _r$3, _ref, found, i, id, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; found = $f.found; i = $f.i; id = $f.id; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		found = false;
		_r = uiDriver().Input(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = _r.TouchIDs(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_ref = _r$1;
		_i = 0;
		/* while (true) { */ case 3:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }
			i = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (id === i) {
				found = true;
				/* break; */ $s = 4; continue;
			}
			_i++;
		/* } */ $s = 3; continue; case 4:
		if (!found) {
			$s = -1; return [0, 0];
		}
		_r$2 = uiDriver().Input(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_r$3 = _r$2.TouchPosition(id); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		$s = -1; return _r$3;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TouchPosition }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f.found = found; $f.i = i; $f.id = id; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TouchPosition = TouchPosition;
	Key.prototype.String = function() {
		var _1, k;
		k = this.$val;
		_1 = k;
		if (_1 === (0)) {
			return "0";
		} else if (_1 === (1)) {
			return "1";
		} else if (_1 === (2)) {
			return "2";
		} else if (_1 === (3)) {
			return "3";
		} else if (_1 === (4)) {
			return "4";
		} else if (_1 === (5)) {
			return "5";
		} else if (_1 === (6)) {
			return "6";
		} else if (_1 === (7)) {
			return "7";
		} else if (_1 === (8)) {
			return "8";
		} else if (_1 === (9)) {
			return "9";
		} else if (_1 === (10)) {
			return "A";
		} else if (_1 === (11)) {
			return "B";
		} else if (_1 === (12)) {
			return "C";
		} else if (_1 === (13)) {
			return "D";
		} else if (_1 === (14)) {
			return "E";
		} else if (_1 === (15)) {
			return "F";
		} else if (_1 === (16)) {
			return "G";
		} else if (_1 === (17)) {
			return "H";
		} else if (_1 === (18)) {
			return "I";
		} else if (_1 === (19)) {
			return "J";
		} else if (_1 === (20)) {
			return "K";
		} else if (_1 === (21)) {
			return "L";
		} else if (_1 === (22)) {
			return "M";
		} else if (_1 === (23)) {
			return "N";
		} else if (_1 === (24)) {
			return "O";
		} else if (_1 === (25)) {
			return "P";
		} else if (_1 === (26)) {
			return "Q";
		} else if (_1 === (27)) {
			return "R";
		} else if (_1 === (28)) {
			return "S";
		} else if (_1 === (29)) {
			return "T";
		} else if (_1 === (30)) {
			return "U";
		} else if (_1 === (31)) {
			return "V";
		} else if (_1 === (32)) {
			return "W";
		} else if (_1 === (33)) {
			return "X";
		} else if (_1 === (34)) {
			return "Y";
		} else if (_1 === (35)) {
			return "Z";
		} else if (_1 === (36)) {
			return "Alt";
		} else if (_1 === (37)) {
			return "Apostrophe";
		} else if (_1 === (38)) {
			return "Backslash";
		} else if (_1 === (39)) {
			return "Backspace";
		} else if (_1 === (40)) {
			return "CapsLock";
		} else if (_1 === (41)) {
			return "Comma";
		} else if (_1 === (42)) {
			return "Control";
		} else if (_1 === (43)) {
			return "Delete";
		} else if (_1 === (44)) {
			return "Down";
		} else if (_1 === (45)) {
			return "End";
		} else if (_1 === (46)) {
			return "Enter";
		} else if (_1 === (47)) {
			return "Equal";
		} else if (_1 === (48)) {
			return "Escape";
		} else if (_1 === (49)) {
			return "F1";
		} else if (_1 === (50)) {
			return "F2";
		} else if (_1 === (51)) {
			return "F3";
		} else if (_1 === (52)) {
			return "F4";
		} else if (_1 === (53)) {
			return "F5";
		} else if (_1 === (54)) {
			return "F6";
		} else if (_1 === (55)) {
			return "F7";
		} else if (_1 === (56)) {
			return "F8";
		} else if (_1 === (57)) {
			return "F9";
		} else if (_1 === (58)) {
			return "F10";
		} else if (_1 === (59)) {
			return "F11";
		} else if (_1 === (60)) {
			return "F12";
		} else if (_1 === (61)) {
			return "GraveAccent";
		} else if (_1 === (62)) {
			return "Home";
		} else if (_1 === (63)) {
			return "Insert";
		} else if (_1 === (64)) {
			return "KP0";
		} else if (_1 === (65)) {
			return "KP1";
		} else if (_1 === (66)) {
			return "KP2";
		} else if (_1 === (67)) {
			return "KP3";
		} else if (_1 === (68)) {
			return "KP4";
		} else if (_1 === (69)) {
			return "KP5";
		} else if (_1 === (70)) {
			return "KP6";
		} else if (_1 === (71)) {
			return "KP7";
		} else if (_1 === (72)) {
			return "KP8";
		} else if (_1 === (73)) {
			return "KP9";
		} else if (_1 === (74)) {
			return "KPAdd";
		} else if (_1 === (75)) {
			return "KPDecimal";
		} else if (_1 === (76)) {
			return "KPDivide";
		} else if (_1 === (77)) {
			return "KPEnter";
		} else if (_1 === (78)) {
			return "KPEqual";
		} else if (_1 === (79)) {
			return "KPMultiply";
		} else if (_1 === (80)) {
			return "KPSubtract";
		} else if (_1 === (81)) {
			return "Left";
		} else if (_1 === (82)) {
			return "LeftBracket";
		} else if (_1 === (83)) {
			return "Menu";
		} else if (_1 === (84)) {
			return "Minus";
		} else if (_1 === (85)) {
			return "NumLock";
		} else if (_1 === (86)) {
			return "PageDown";
		} else if (_1 === (87)) {
			return "PageUp";
		} else if (_1 === (88)) {
			return "Pause";
		} else if (_1 === (89)) {
			return "Period";
		} else if (_1 === (90)) {
			return "PrintScreen";
		} else if (_1 === (91)) {
			return "Right";
		} else if (_1 === (92)) {
			return "RightBracket";
		} else if (_1 === (93)) {
			return "ScrollLock";
		} else if (_1 === (94)) {
			return "Semicolon";
		} else if (_1 === (95)) {
			return "Shift";
		} else if (_1 === (96)) {
			return "Slash";
		} else if (_1 === (97)) {
			return "Space";
		} else if (_1 === (98)) {
			return "Tab";
		} else if (_1 === (99)) {
			return "Up";
		}
		return "";
	};
	$ptrType(Key).prototype.String = function() { return new Key(this.$get()).String(); };
	newMipmap = function(s) {
		var s;
		return new mipmap.ptr(s, $makeMap(image.Rectangle.keyFor, []));
	};
	mipmap.ptr.prototype.original = function() {
		var m;
		m = this;
		return m.orig;
	};
	mipmap.prototype.original = function() { return this.$val.original(); };
	mipmap.ptr.prototype.level = function(r, level) {
		var _entry, _key, _key$1, _q, _q$1, _r, _r$1, _r$2, _tmp, _tmp$1, _tuple, _tuple$1, h, h2, idx, imgs, is, l, level, m, ok, r, s, size, src, vs, w, w2, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _key = $f._key; _key$1 = $f._key$1; _q = $f._q; _q$1 = $f._q$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; h = $f.h; h2 = $f.h2; idx = $f.idx; imgs = $f.imgs; is = $f.is; l = $f.l; level = $f.level; m = $f.m; ok = $f.ok; r = $f.r; s = $f.s; size = $f.size; src = $f.src; vs = $f.vs; w = $f.w; w2 = $f.w2; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		if (level <= 0) {
			$panic(new $String("ebiten: level must be positive at level"));
		}
		_tuple = (_entry = m.imgs[image.Rectangle.keyFor(r)], _entry !== undefined ? [_entry.v, true] : [sliceType$6.nil, false]);
		imgs = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			imgs = new sliceType$6([]);
			_key = $clone(r, image.Rectangle); (m.imgs || $throwRuntimeError("assignment to entry in nil map"))[image.Rectangle.keyFor(_key)] = { k: _key, v: imgs };
		}
		idx = level - 1 >> 0;
		size = $clone($clone(r, image.Rectangle).Size(), image.Point);
		_tmp = size.X;
		_tmp$1 = size.Y;
		w = _tmp;
		h = _tmp$1;
		if (imgs.$length > 0) {
			_tuple$1 = (x$1 = imgs.$length - 1 >> 0, ((x$1 < 0 || x$1 >= imgs.$length) ? ($throwRuntimeError("index out of range"), undefined) : imgs.$array[imgs.$offset + x$1])).Size();
			w = _tuple$1[0];
			h = _tuple$1[1];
		}
		/* while (true) { */ case 1:
			/* if (!(imgs.$length < (idx + 1 >> 0))) { break; } */ if(!(imgs.$length < (idx + 1 >> 0))) { $s = 2; continue; }
			_r = m.orig.IsVolatile(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r) { */ case 3:
				$panic(new $String("ebiten: mipmap images for a volatile image is not implemented yet"));
			/* } */ case 4:
			w2 = (_q = w / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
			h2 = (_q$1 = h / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"));
			if ((w2 === 0) || (h2 === 0)) {
				$s = -1; return ptrType$5.nil;
			}
			s = shareable.NewImage(w2, h2);
			src = ptrType$5.nil;
			_r$1 = vertexSlice(4); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			vs = _r$1;
			l = imgs.$length;
			/* */ if (l === 0) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (l === 0) { */ case 7:
				src = m.orig;
				$r = graphics.PutQuadVertices(vs, src, r.Min.X, r.Min.Y, r.Max.X, r.Max.Y, 0.5, 0, 0, 0.5, 0, 0, 1, 1, 1, 1); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 9; continue;
			/* } else { */ case 8:
				_r$2 = m.level($clone(r, image.Rectangle), l); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				src = _r$2;
				$r = graphics.PutQuadVertices(vs, src, 0, 0, w, h, 0.5, 0, 0, 0.5, 0, 0, 1, 1, 1, 1); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 9:
			is = graphics.QuadIndices();
			$r = s.DrawTriangles(src, vs, is, ptrType.nil, 2, 2, 0); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			imgs = $append(imgs, s);
			w = w2;
			h = h2;
		/* } */ $s = 1; continue; case 2:
		_key$1 = $clone(r, image.Rectangle); (m.imgs || $throwRuntimeError("assignment to entry in nil map"))[image.Rectangle.keyFor(_key$1)] = { k: _key$1, v: imgs };
		if (imgs.$length <= idx) {
			$s = -1; return ptrType$5.nil;
		}
		$s = -1; return ((idx < 0 || idx >= imgs.$length) ? ($throwRuntimeError("index out of range"), undefined) : imgs.$array[imgs.$offset + idx]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: mipmap.ptr.prototype.level }; } $f._entry = _entry; $f._key = _key; $f._key$1 = _key$1; $f._q = _q; $f._q$1 = _q$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.h = h; $f.h2 = h2; $f.idx = idx; $f.imgs = imgs; $f.is = is; $f.l = l; $f.level = level; $f.m = m; $f.ok = ok; $f.r = r; $f.s = s; $f.size = size; $f.src = src; $f.vs = vs; $f.w = w; $f.w2 = w2; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	mipmap.prototype.level = function(r, level) { return this.$val.level(r, level); };
	mipmap.ptr.prototype.isDisposed = function() {
		var m;
		m = this;
		return m.orig === ptrType$5.nil;
	};
	mipmap.prototype.isDisposed = function() { return this.$val.isDisposed(); };
	mipmap.ptr.prototype.dispose = function() {
		var m, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; m = $f.m; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		$r = m.disposeMipmaps(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = m.orig.Dispose(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		m.orig = ptrType$5.nil;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: mipmap.ptr.prototype.dispose }; } $f.m = m; $f.$s = $s; $f.$r = $r; return $f;
	};
	mipmap.prototype.dispose = function() { return this.$val.dispose(); };
	mipmap.ptr.prototype.disposeMipmaps = function() {
		var _entry, _entry$1, _i, _i$1, _i$2, _keys, _keys$1, _ref, _ref$1, _ref$2, a, img, k, m, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _keys = $f._keys; _keys$1 = $f._keys$1; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; a = $f.a; img = $f.img; k = $f.k; m = $f.m; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		_ref = m.imgs;
		_i = 0;
		_keys = $keys(_ref);
		/* while (true) { */ case 1:
			/* if (!(_i < _keys.length)) { break; } */ if(!(_i < _keys.length)) { $s = 2; continue; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				/* continue; */ $s = 1; continue;
			}
			a = _entry.v;
			_ref$1 = a;
			_i$1 = 0;
			/* while (true) { */ case 3:
				/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 4; continue; }
				img = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
				$r = img.Dispose(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				_i$1++;
			/* } */ $s = 3; continue; case 4:
			_i++;
		/* } */ $s = 1; continue; case 2:
		_ref$2 = m.imgs;
		_i$2 = 0;
		_keys$1 = $keys(_ref$2);
		while (true) {
			if (!(_i$2 < _keys$1.length)) { break; }
			_entry$1 = _ref$2[_keys$1[_i$2]];
			if (_entry$1 === undefined) {
				_i$2++;
				continue;
			}
			k = $clone(_entry$1.k, image.Rectangle);
			delete m.imgs[image.Rectangle.keyFor(k)];
			_i$2++;
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: mipmap.ptr.prototype.disposeMipmaps }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._keys = _keys; $f._keys$1 = _keys$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f.a = a; $f.img = img; $f.k = k; $f.m = m; $f.$s = $s; $f.$r = $r; return $f;
	};
	mipmap.prototype.disposeMipmaps = function() { return this.$val.disposeMipmaps(); };
	mipmapLevel = function(det) {
		var d, det, level;
		if (math.IsNaN((det))) {
			$panic(new $String("graphicsutil: det must be finite"));
		}
		if (det === 0) {
			return -1;
		}
		d = math.Abs((det));
		level = 0;
		while (true) {
			if (!(d < 0.25)) { break; }
			level = level + (1) >> 0;
			d = d * (4);
		}
		return level;
	};
	setDrawingSkipped = function(skipped) {
		var skipped, v;
		v = 0;
		if (skipped) {
			v = 1;
		}
		atomic.StoreInt32((isDrawingSkipped$24ptr || (isDrawingSkipped$24ptr = new ptrType$8(function() { return isDrawingSkipped; }, function($v) { isDrawingSkipped = $v; }))), v);
	};
	Run = function(f, width, height, scale, title) {
		var _r, c, err, f, height, scale, title, width, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; err = $f.err; f = $f.f; height = $f.height; scale = $f.scale; title = $f.title; width = $f.width; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		f = $methodVal((new imageDumper.ptr(f)), "update");
		c = newUIContext(f);
		theUIContext.Store(c);
		atomic.StoreInt32((isRunning$24ptr || (isRunning$24ptr = new ptrType$8(function() { return isRunning; }, function($v) { isRunning = $v; }))), 1);
		if (!web.IsGopherJS()) {
			$deferred.push([atomic.StoreInt32, [(isRunning$24ptr || (isRunning$24ptr = new ptrType$8(function() { return isRunning; }, function($v) { isRunning = $v; }))), 0]]);
		}
		_r = uiDriver().Run(width, height, scale, title, c, graphicsDriver()); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			if ($interfaceIsEqual(err, driver.RegularTermination)) {
				$s = -1; return $ifaceNil;
			}
			$s = -1; return err;
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return $ifaceNil; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Run }; } $f._r = _r; $f.c = c; $f.err = err; $f.f = f; $f.height = height; $f.scale = scale; $f.title = title; $f.width = width; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	$pkg.Run = Run;
	MaxTPS = function() {
		return ((atomic.LoadInt32((currentMaxTPS$24ptr || (currentMaxTPS$24ptr = new ptrType$8(function() { return currentMaxTPS; }, function($v) { currentMaxTPS = $v; })))) >> 0));
	};
	$pkg.MaxTPS = MaxTPS;
	uiDriver = function() {
		return js.Get();
	};
	init = function() {
		shareable.SetGraphicsDriver(graphicsDriver());
		graphicscommand.SetGraphicsDriver(graphicsDriver());
	};
	newUIContext = function(f) {
		var f;
		return new uiContext.ptr(f, ptrType$2.nil, ptrType$2.nil, 0, 0, 0, false, 0, 0);
	};
	uiContext.ptr.prototype.SetSize = function(screenWidth, screenHeight, screenScale) {
		var _r, _r$1, _r$2, _r$3, _tuple, _tuple$1, c, h, px0, px1, py0, py1, screenHeight, screenScale, screenWidth, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; c = $f.c; h = $f.h; px0 = $f.px0; px1 = $f.px1; py0 = $f.py0; py1 = $f.py1; screenHeight = $f.screenHeight; screenScale = $f.screenScale; screenWidth = $f.screenWidth; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		c.screenScale = screenScale;
		/* */ if (!(c.screen === ptrType$2.nil)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(c.screen === ptrType$2.nil)) { */ case 1:
			_r = c.screen.Dispose(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$unused(_r);
		/* } */ case 2:
		/* */ if (!(c.offscreen === ptrType$2.nil)) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (!(c.offscreen === ptrType$2.nil)) { */ case 4:
			_r$1 = c.offscreen.Dispose(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$unused(_r$1);
		/* } */ case 5:
		_tuple = NewImage(screenWidth, screenHeight, 0);
		c.offscreen = _tuple[0];
		$r = c.offscreen.makeVolatile(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		w = ((math.Ceil((screenWidth) * screenScale) >> 0));
		h = ((math.Ceil((screenHeight) * screenScale) >> 0));
		_r$2 = uiDriver().ScreenPadding(); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_tuple$1 = _r$2;
		px0 = _tuple$1[0];
		py0 = _tuple$1[1];
		px1 = _tuple$1[2];
		py1 = _tuple$1[3];
		_r$3 = newImageWithScreenFramebuffer(w + ((math.Ceil(px0 + px1) >> 0)) >> 0, h + ((math.Ceil(py0 + py1) >> 0)) >> 0); /* */ $s = 9; case 9: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		c.screen = _r$3;
		c.screenWidth = w;
		c.screenHeight = h;
		c.offsetX = px0;
		c.offsetY = py0;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: uiContext.ptr.prototype.SetSize }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.c = c; $f.h = h; $f.px0 = px0; $f.px1 = px1; $f.py0 = py0; $f.py1 = py1; $f.screenHeight = screenHeight; $f.screenScale = screenScale; $f.screenWidth = screenWidth; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	uiContext.prototype.SetSize = function(screenWidth, screenHeight, screenScale) { return this.$val.SetSize(screenWidth, screenHeight, screenScale); };
	uiContext.ptr.prototype.initializeIfNeeded = function() {
		var _r, _r$1, c, err, err$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; c = $f.c; err = $f.err; err$1 = $f.err$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		/* */ if (!c.initialized) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!c.initialized) { */ case 1:
			_r = shareable.InitializeGraphicsDriverState(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			err = _r;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			c.initialized = true;
		/* } */ case 2:
		_r$1 = c.restoreIfNeeded(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err$1 = _r$1;
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return err$1;
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: uiContext.ptr.prototype.initializeIfNeeded }; } $f._r = _r; $f._r$1 = _r$1; $f.c = c; $f.err = err; $f.err$1 = err$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	uiContext.prototype.initializeIfNeeded = function() { return this.$val.initializeIfNeeded(); };
	uiContext.ptr.prototype.Update = function(afterFrameUpdate) {
		var _1, _r, _r$1, _r$10, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, afterFrameUpdate, c, err, err$1, err$2, err$3, i, op, tps, updateCount, vd, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; afterFrameUpdate = $f.afterFrameUpdate; c = $f.c; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; err$3 = $f.err$3; i = $f.i; op = $f.op; tps = $f.tps; updateCount = $f.updateCount; vd = $f.vd; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		tps = (MaxTPS());
		_r = clock.Update(tps); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		updateCount = _r;
		_r$1 = c.initializeIfNeeded(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err = _r$1;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		i = 0;
		/* while (true) { */ case 3:
			/* if (!(i < updateCount)) { break; } */ if(!(i < updateCount)) { $s = 4; continue; }
			_r$2 = c.offscreen.Clear(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			_r$2;
			setDrawingSkipped(i < (updateCount - 1 >> 0));
			_r$3 = hooks.RunBeforeUpdateHooks(); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			err$1 = _r$3;
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				$s = -1; return err$1;
			}
			_r$4 = c.f(c.offscreen); /* */ $s = 7; case 7: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			err$2 = _r$4;
			if (!($interfaceIsEqual(err$2, $ifaceNil))) {
				$s = -1; return err$2;
			}
			_r$5 = uiDriver().Input(); /* */ $s = 8; case 8: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			$r = _r$5.ResetForFrame(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = afterFrameUpdate(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i = i + (1) >> 0;
		/* } */ $s = 3; continue; case 4:
		_r$6 = c.screen.Clear(); /* */ $s = 11; case 11: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		_r$6;
		op = new DrawImageOptions.ptr(new GeoM.ptr(0, 0, 0, 0, 0, 0), new ColorM.ptr(ptrType.nil), 0, 0, $ifaceNil, sliceType$3.nil, ptrType$4.nil);
			_r$7 = graphicsDriver().VDirection(); /* */ $s = 13; case 13: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
			vd = _r$7;
			_1 = vd;
			/* */ if (_1 === (1)) { $s = 14; continue; }
			/* */ if (_1 === (0)) { $s = 15; continue; }
			/* */ $s = 16; continue;
			/* if (_1 === (1)) { */ case 14:
				op.GeoM.Scale(c.screenScale, -c.screenScale);
				op.GeoM.Translate(0, (c.screenHeight));
				$s = 17; continue;
			/* } else if (_1 === (0)) { */ case 15:
				op.GeoM.Scale(c.screenScale, c.screenScale);
				$s = 17; continue;
			/* } else { */ case 16:
				_r$8 = fmt.Sprintf("ebiten: invalid v-direction: %d", new sliceType$1([new driver.VDirection(vd)])); /* */ $s = 18; case 18: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
				$panic(new $String(_r$8));
			/* } */ case 17:
		case 12:
		op.GeoM.Translate(c.offsetX, c.offsetY);
		op.CompositeMode = 2;
		if (c.screenScale >= 1) {
			op.Filter = 3;
		} else {
			op.Filter = 2;
		}
		_r$9 = c.screen.DrawImage(c.offscreen, op); /* */ $s = 19; case 19: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		$unused(_r$9);
		$r = shareable.ResolveStaleImages(); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r$10 = shareable.Error(); /* */ $s = 21; case 21: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
		err$3 = _r$10;
		if (!($interfaceIsEqual(err$3, $ifaceNil))) {
			$s = -1; return err$3;
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: uiContext.ptr.prototype.Update }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f.afterFrameUpdate = afterFrameUpdate; $f.c = c; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.err$3 = err$3; $f.i = i; $f.op = op; $f.tps = tps; $f.updateCount = updateCount; $f.vd = vd; $f.$s = $s; $f.$r = $r; return $f;
	};
	uiContext.prototype.Update = function(afterFrameUpdate) { return this.$val.Update(afterFrameUpdate); };
	uiContext.ptr.prototype.restoreIfNeeded = function() {
		var _r, c, err, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; err = $f.err; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		_r = shareable.RestoreIfNeeded(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: uiContext.ptr.prototype.restoreIfNeeded }; } $f._r = _r; $f.c = c; $f.err = err; $f.$s = $s; $f.$r = $r; return $f;
	};
	uiContext.prototype.restoreIfNeeded = function() { return this.$val.restoreIfNeeded(); };
	uiContext.ptr.prototype.SuspendAudio = function() {
		var c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = hooks.SuspendAudio(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: uiContext.ptr.prototype.SuspendAudio }; } $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	uiContext.prototype.SuspendAudio = function() { return this.$val.SuspendAudio(); };
	uiContext.ptr.prototype.ResumeAudio = function() {
		var c, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; c = $f.c; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		c = this;
		$r = hooks.ResumeAudio(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: uiContext.ptr.prototype.ResumeAudio }; } $f.c = c; $f.$s = $s; $f.$r = $r; return $f;
	};
	uiContext.prototype.ResumeAudio = function() { return this.$val.ResumeAudio(); };
	verticesBackend.ptr.prototype.slice = function(n) {
		var l, n, need, s, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; l = $f.l; n = $f.n; need = $f.need; s = $f.s; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		v = this;
		$r = v.m.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		need = $imul(n, 12);
		if ((v.head + need >> 0) > v.backend.$length) {
			v.backend = sliceType.nil;
			v.head = 0;
		}
		if (v.backend === sliceType.nil) {
			l = 1024;
			if (n > l) {
				l = n;
			}
			v.backend = $makeSlice(sliceType, ($imul(12, l)));
		}
		s = $subslice(v.backend, v.head, (v.head + need >> 0));
		v.head = v.head + (need) >> 0;
		$r = v.m.Unlock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return s;
		/* */ } return; } if ($f === undefined) { $f = { $blk: verticesBackend.ptr.prototype.slice }; } $f.l = l; $f.n = n; $f.need = need; $f.s = s; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	verticesBackend.prototype.slice = function(n) { return this.$val.slice(n); };
	vertexSlice = function(n) {
		var _r, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = theVerticesBackend.slice(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: vertexSlice }; } $f._r = _r; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	ptrType$9.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [], false)}, {prop: "Apply", name: "Apply", pkg: "", typ: $funcType([color.Color], [color.Color], false)}, {prop: "Concat", name: "Concat", pkg: "", typ: $funcType([ColorM], [], false)}, {prop: "Add", name: "Add", pkg: "", typ: $funcType([ColorM], [], false)}, {prop: "Scale", name: "Scale", pkg: "", typ: $funcType([$Float64, $Float64, $Float64, $Float64], [], false)}, {prop: "Translate", name: "Translate", pkg: "", typ: $funcType([$Float64, $Float64, $Float64, $Float64], [], false)}, {prop: "RotateHue", name: "RotateHue", pkg: "", typ: $funcType([$Float64], [], false)}, {prop: "ChangeHSV", name: "ChangeHSV", pkg: "", typ: $funcType([$Float64, $Float64, $Float64], [], false)}, {prop: "Element", name: "Element", pkg: "", typ: $funcType([$Int, $Int], [$Float64], false)}, {prop: "SetElement", name: "SetElement", pkg: "", typ: $funcType([$Int, $Int, $Float64], [], false)}];
	ptrType$10.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [], false)}, {prop: "Apply", name: "Apply", pkg: "", typ: $funcType([$Float64, $Float64], [$Float64, $Float64], false)}, {prop: "apply32", name: "apply32", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([$Float32, $Float32], [$Float32, $Float32], false)}, {prop: "elements", name: "elements", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [$Float32, $Float32, $Float32, $Float32, $Float32, $Float32], false)}, {prop: "Element", name: "Element", pkg: "", typ: $funcType([$Int, $Int], [$Float64], false)}, {prop: "Concat", name: "Concat", pkg: "", typ: $funcType([GeoM], [], false)}, {prop: "Add", name: "Add", pkg: "", typ: $funcType([GeoM], [], false)}, {prop: "Scale", name: "Scale", pkg: "", typ: $funcType([$Float64, $Float64], [], false)}, {prop: "Translate", name: "Translate", pkg: "", typ: $funcType([$Float64, $Float64], [], false)}, {prop: "Rotate", name: "Rotate", pkg: "", typ: $funcType([$Float64], [], false)}, {prop: "Skew", name: "Skew", pkg: "", typ: $funcType([$Float64, $Float64], [], false)}, {prop: "det", name: "det", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [$Float32], false)}, {prop: "IsInvertible", name: "IsInvertible", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "Invert", name: "Invert", pkg: "", typ: $funcType([], [], false)}, {prop: "SetElement", name: "SetElement", pkg: "", typ: $funcType([$Int, $Int, $Float64], [], false)}];
	ptrType$2.methods = [{prop: "copyCheck", name: "copyCheck", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int, $Int], false)}, {prop: "isDisposed", name: "isDisposed", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [$Bool], false)}, {prop: "isSubImage", name: "isSubImage", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [$Bool], false)}, {prop: "Clear", name: "Clear", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Fill", name: "Fill", pkg: "", typ: $funcType([color.Color], [$error], false)}, {prop: "disposeMipmaps", name: "disposeMipmaps", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [], false)}, {prop: "DrawImage", name: "DrawImage", pkg: "", typ: $funcType([ptrType$2, ptrType$3], [$error], false)}, {prop: "DrawTriangles", name: "DrawTriangles", pkg: "", typ: $funcType([sliceType$7, sliceType$8, ptrType$2, ptrType$6], [], false)}, {prop: "SubImage", name: "SubImage", pkg: "", typ: $funcType([image.Rectangle], [image.Image], false)}, {prop: "Bounds", name: "Bounds", pkg: "", typ: $funcType([], [image.Rectangle], false)}, {prop: "ColorModel", name: "ColorModel", pkg: "", typ: $funcType([], [color.Model], false)}, {prop: "At", name: "At", pkg: "", typ: $funcType([$Int, $Int], [color.Color], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$Int, $Int, color.Color], [], false)}, {prop: "resolvePendingPixels", name: "resolvePendingPixels", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([$Bool], [], false)}, {prop: "Dispose", name: "Dispose", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReplacePixels", name: "ReplacePixels", pkg: "", typ: $funcType([sliceType$2], [$error], false)}, {prop: "makeVolatile", name: "makeVolatile", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [], false)}];
	ptrType$11.methods = [{prop: "update", name: "update", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([ptrType$2], [$error], false)}];
	imageParts.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Dst", name: "Dst", pkg: "", typ: $funcType([$Int], [$Int, $Int, $Int, $Int], false)}, {prop: "Src", name: "Src", pkg: "", typ: $funcType([$Int], [$Int, $Int, $Int, $Int], false)}];
	Key.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$7.methods = [{prop: "original", name: "original", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [ptrType$5], false)}, {prop: "level", name: "level", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([image.Rectangle, $Int], [ptrType$5], false)}, {prop: "isDisposed", name: "isDisposed", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [$Bool], false)}, {prop: "dispose", name: "dispose", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [], false)}, {prop: "disposeMipmaps", name: "disposeMipmaps", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [], false)}];
	ptrType$13.methods = [{prop: "SetSize", name: "SetSize", pkg: "", typ: $funcType([$Int, $Int, $Float64], [], false)}, {prop: "initializeIfNeeded", name: "initializeIfNeeded", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [$error], false)}, {prop: "Update", name: "Update", pkg: "", typ: $funcType([funcType$1], [$error], false)}, {prop: "restoreIfNeeded", name: "restoreIfNeeded", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([], [$error], false)}, {prop: "SuspendAudio", name: "SuspendAudio", pkg: "", typ: $funcType([], [], false)}, {prop: "ResumeAudio", name: "ResumeAudio", pkg: "", typ: $funcType([], [], false)}];
	ptrType$14.methods = [{prop: "slice", name: "slice", pkg: "github.com/hajimehoshi/ebiten", typ: $funcType([$Int], [sliceType], false)}];
	ColorM.init("github.com/hajimehoshi/ebiten", [{prop: "impl", name: "impl", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	GeoM.init("github.com/hajimehoshi/ebiten", [{prop: "a_1", name: "a_1", embedded: false, exported: false, typ: $Float32, tag: ""}, {prop: "b", name: "b", embedded: false, exported: false, typ: $Float32, tag: ""}, {prop: "c", name: "c", embedded: false, exported: false, typ: $Float32, tag: ""}, {prop: "d_1", name: "d_1", embedded: false, exported: false, typ: $Float32, tag: ""}, {prop: "tx", name: "tx", embedded: false, exported: false, typ: $Float32, tag: ""}, {prop: "ty", name: "ty", embedded: false, exported: false, typ: $Float32, tag: ""}]);
	Image.init("github.com/hajimehoshi/ebiten", [{prop: "addr", name: "addr", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "mipmap", name: "mipmap", embedded: false, exported: false, typ: ptrType$7, tag: ""}, {prop: "bounds", name: "bounds", embedded: false, exported: false, typ: image.Rectangle, tag: ""}, {prop: "original", name: "original", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "pendingPixels", name: "pendingPixels", embedded: false, exported: false, typ: sliceType$2, tag: ""}, {prop: "filter", name: "filter", embedded: false, exported: false, typ: Filter, tag: ""}]);
	Vertex.init("", [{prop: "DstX", name: "DstX", embedded: false, exported: true, typ: $Float32, tag: ""}, {prop: "DstY", name: "DstY", embedded: false, exported: true, typ: $Float32, tag: ""}, {prop: "SrcX", name: "SrcX", embedded: false, exported: true, typ: $Float32, tag: ""}, {prop: "SrcY", name: "SrcY", embedded: false, exported: true, typ: $Float32, tag: ""}, {prop: "ColorR", name: "ColorR", embedded: false, exported: true, typ: $Float32, tag: ""}, {prop: "ColorG", name: "ColorG", embedded: false, exported: true, typ: $Float32, tag: ""}, {prop: "ColorB", name: "ColorB", embedded: false, exported: true, typ: $Float32, tag: ""}, {prop: "ColorA", name: "ColorA", embedded: false, exported: true, typ: $Float32, tag: ""}]);
	DrawTrianglesOptions.init("", [{prop: "ColorM", name: "ColorM", embedded: false, exported: true, typ: ColorM, tag: ""}, {prop: "CompositeMode", name: "CompositeMode", embedded: false, exported: true, typ: CompositeMode, tag: ""}, {prop: "Filter", name: "Filter", embedded: false, exported: true, typ: Filter, tag: ""}, {prop: "Address", name: "Address", embedded: false, exported: true, typ: Address, tag: ""}]);
	DrawImageOptions.init("", [{prop: "GeoM", name: "GeoM", embedded: false, exported: true, typ: GeoM, tag: ""}, {prop: "ColorM", name: "ColorM", embedded: false, exported: true, typ: ColorM, tag: ""}, {prop: "CompositeMode", name: "CompositeMode", embedded: false, exported: true, typ: CompositeMode, tag: ""}, {prop: "Filter", name: "Filter", embedded: false, exported: true, typ: Filter, tag: ""}, {prop: "ImageParts", name: "ImageParts", embedded: false, exported: true, typ: ImageParts, tag: ""}, {prop: "Parts", name: "Parts", embedded: false, exported: true, typ: sliceType$3, tag: ""}, {prop: "SourceRect", name: "SourceRect", embedded: false, exported: true, typ: ptrType$4, tag: ""}]);
	imageDumper.init("github.com/hajimehoshi/ebiten", [{prop: "f", name: "f", embedded: false, exported: false, typ: funcType, tag: ""}]);
	ImagePart.init("", [{prop: "Dst", name: "Dst", embedded: false, exported: true, typ: image.Rectangle, tag: ""}, {prop: "Src", name: "Src", embedded: false, exported: true, typ: image.Rectangle, tag: ""}]);
	ImageParts.init([{prop: "Dst", name: "Dst", pkg: "", typ: $funcType([$Int], [$Int, $Int, $Int, $Int], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Src", name: "Src", pkg: "", typ: $funcType([$Int], [$Int, $Int, $Int, $Int], false)}]);
	imageParts.init(ImagePart);
	mipmap.init("github.com/hajimehoshi/ebiten", [{prop: "orig", name: "orig", embedded: false, exported: false, typ: ptrType$5, tag: ""}, {prop: "imgs", name: "imgs", embedded: false, exported: false, typ: mapType, tag: ""}]);
	uiContext.init("github.com/hajimehoshi/ebiten", [{prop: "f", name: "f", embedded: false, exported: false, typ: funcType, tag: ""}, {prop: "offscreen", name: "offscreen", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "screen", name: "screen", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "screenWidth", name: "screenWidth", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "screenHeight", name: "screenHeight", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "screenScale", name: "screenScale", embedded: false, exported: false, typ: $Float64, tag: ""}, {prop: "initialized", name: "initialized", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "offsetX", name: "offsetX", embedded: false, exported: false, typ: $Float64, tag: ""}, {prop: "offsetY", name: "offsetY", embedded: false, exported: false, typ: $Float64, tag: ""}]);
	verticesBackend.init("github.com/hajimehoshi/ebiten", [{prop: "backend", name: "backend", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "head", name: "head", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "m", name: "m", embedded: false, exported: false, typ: sync.Mutex, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = fmt.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = affine.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = clock.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = driver.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = graphics.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = graphicscommand.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = opengl.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = hooks.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = shareable.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = web.$init(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = image.$init(); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = color.$init(); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = draw.$init(); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 17; case 17: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = time.$init(); /* */ $s = 19; case 19: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		theUIContext = new atomic.Value.ptr($ifaceNil);
		isPlayground = (x = $clone(time.Now(), time.Time).UnixNano(), (x.$high === 292876269 && x.$low === 2870501376));
		isDrawingSkipped = 0;
		currentMaxTPS = 60;
		isRunning = 0;
		theVerticesBackend = new verticesBackend.ptr(sliceType.nil, 0, new sync.Mutex.ptr(0, 0));
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/inpututil"] = (function() {
	var $pkg = {}, $init, ebiten, hooks, sort, sync, inputState, sliceType, structType, sliceType$1, ptrType, mapType, mapType$1, mapType$2, mapType$3, mapType$4, mapType$5, theInputState, init, IsMouseButtonJustPressed, MouseButtonPressDuration, JustPressedTouchIDs;
	ebiten = $packages["github.com/hajimehoshi/ebiten"];
	hooks = $packages["github.com/hajimehoshi/ebiten/internal/hooks"];
	sort = $packages["sort"];
	sync = $packages["sync"];
	inputState = $pkg.inputState = $newType(0, $kindStruct, "inpututil.inputState", true, "github.com/hajimehoshi/ebiten/inpututil", false, function(keyDurations_, prevKeyDurations_, mouseButtonDurations_, prevMouseButtonDurations_, gamepadIDs_, prevGamepadIDs_, gamepadButtonDurations_, prevGamepadButtonDurations_, touchDurations_, prevTouchDurations_, m_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.keyDurations = false;
			this.prevKeyDurations = false;
			this.mouseButtonDurations = false;
			this.prevMouseButtonDurations = false;
			this.gamepadIDs = false;
			this.prevGamepadIDs = false;
			this.gamepadButtonDurations = false;
			this.prevGamepadButtonDurations = false;
			this.touchDurations = false;
			this.prevTouchDurations = false;
			this.m = new sync.RWMutex.ptr(new sync.Mutex.ptr(0, 0), 0, 0, 0, 0);
			return;
		}
		this.keyDurations = keyDurations_;
		this.prevKeyDurations = prevKeyDurations_;
		this.mouseButtonDurations = mouseButtonDurations_;
		this.prevMouseButtonDurations = prevMouseButtonDurations_;
		this.gamepadIDs = gamepadIDs_;
		this.prevGamepadIDs = prevGamepadIDs_;
		this.gamepadButtonDurations = gamepadButtonDurations_;
		this.prevGamepadButtonDurations = prevGamepadButtonDurations_;
		this.touchDurations = touchDurations_;
		this.prevTouchDurations = prevTouchDurations_;
		this.m = m_;
	});
	sliceType = $sliceType(ebiten.MouseButton);
	structType = $structType("", []);
	sliceType$1 = $sliceType($Int);
	ptrType = $ptrType(inputState);
	mapType = $mapType(ebiten.Key, $Int);
	mapType$1 = $mapType(ebiten.MouseButton, $Int);
	mapType$2 = $mapType($Int, structType);
	mapType$3 = $mapType(ebiten.GamepadButton, $Int);
	mapType$4 = $mapType($Int, mapType$3);
	mapType$5 = $mapType($Int, $Int);
	init = function() {
		var $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = hooks.AppendHookOnBeforeUpdate((function $b() {
			var $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			$r = theInputState.update(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return $ifaceNil;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f.$s = $s; $f.$r = $r; return $f;
		})); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	inputState.ptr.prototype.update = function() {
		var _entry, _entry$1, _entry$10, _entry$11, _entry$12, _entry$13, _entry$14, _entry$15, _entry$16, _entry$17, _entry$18, _entry$19, _entry$2, _entry$3, _entry$4, _entry$5, _entry$6, _entry$7, _entry$8, _entry$9, _i, _i$1, _i$10, _i$2, _i$3, _i$4, _i$5, _i$6, _i$7, _i$8, _i$9, _key, _key$1, _key$10, _key$11, _key$12, _key$13, _key$14, _key$15, _key$2, _key$3, _key$4, _key$5, _key$6, _key$7, _key$8, _key$9, _keys, _keys$1, _keys$2, _keys$3, _keys$4, _keys$5, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _ref, _ref$1, _ref$10, _ref$2, _ref$3, _ref$4, _ref$5, _ref$6, _ref$7, _ref$8, _ref$9, _tuple, _tuple$1, _tuple$2, b, b$1, b$2, d, ds, i, id, id$1, id$2, id$3, id$4, id$5, id$6, id$7, id$8, ids, idsToDelete, k, n, ok, ok$1, ok$2, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$10 = $f._entry$10; _entry$11 = $f._entry$11; _entry$12 = $f._entry$12; _entry$13 = $f._entry$13; _entry$14 = $f._entry$14; _entry$15 = $f._entry$15; _entry$16 = $f._entry$16; _entry$17 = $f._entry$17; _entry$18 = $f._entry$18; _entry$19 = $f._entry$19; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _entry$4 = $f._entry$4; _entry$5 = $f._entry$5; _entry$6 = $f._entry$6; _entry$7 = $f._entry$7; _entry$8 = $f._entry$8; _entry$9 = $f._entry$9; _i = $f._i; _i$1 = $f._i$1; _i$10 = $f._i$10; _i$2 = $f._i$2; _i$3 = $f._i$3; _i$4 = $f._i$4; _i$5 = $f._i$5; _i$6 = $f._i$6; _i$7 = $f._i$7; _i$8 = $f._i$8; _i$9 = $f._i$9; _key = $f._key; _key$1 = $f._key$1; _key$10 = $f._key$10; _key$11 = $f._key$11; _key$12 = $f._key$12; _key$13 = $f._key$13; _key$14 = $f._key$14; _key$15 = $f._key$15; _key$2 = $f._key$2; _key$3 = $f._key$3; _key$4 = $f._key$4; _key$5 = $f._key$5; _key$6 = $f._key$6; _key$7 = $f._key$7; _key$8 = $f._key$8; _key$9 = $f._key$9; _keys = $f._keys; _keys$1 = $f._keys$1; _keys$2 = $f._keys$2; _keys$3 = $f._keys$3; _keys$4 = $f._keys$4; _keys$5 = $f._keys$5; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$10 = $f._ref$10; _ref$2 = $f._ref$2; _ref$3 = $f._ref$3; _ref$4 = $f._ref$4; _ref$5 = $f._ref$5; _ref$6 = $f._ref$6; _ref$7 = $f._ref$7; _ref$8 = $f._ref$8; _ref$9 = $f._ref$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; b = $f.b; b$1 = $f.b$1; b$2 = $f.b$2; d = $f.d; ds = $f.ds; i = $f.i; id = $f.id; id$1 = $f.id$1; id$2 = $f.id$2; id$3 = $f.id$3; id$4 = $f.id$4; id$5 = $f.id$5; id$6 = $f.id$6; id$7 = $f.id$7; id$8 = $f.id$8; ids = $f.ids; idsToDelete = $f.idsToDelete; k = $f.k; n = $f.n; ok = $f.ok; ok$1 = $f.ok$1; ok$2 = $f.ok$2; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		i = this;
		$r = i.m.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$deferred.push([$methodVal(i.m, "Unlock"), []]);
		k = 0;
		/* while (true) { */ case 2:
			/* if (!(k <= 99)) { break; } */ if(!(k <= 99)) { $s = 3; continue; }
			_key = k; (i.prevKeyDurations || $throwRuntimeError("assignment to entry in nil map"))[ebiten.Key.keyFor(_key)] = { k: _key, v: (_entry = i.keyDurations[ebiten.Key.keyFor(k)], _entry !== undefined ? _entry.v : 0) };
			_r = ebiten.IsKeyPressed(k); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_r) { */ case 4:
				_key$1 = k; (i.keyDurations || $throwRuntimeError("assignment to entry in nil map"))[ebiten.Key.keyFor(_key$1)] = { k: _key$1, v: (_entry$1 = i.keyDurations[ebiten.Key.keyFor(k)], _entry$1 !== undefined ? _entry$1.v : 0) + (1) >> 0 };
				$s = 6; continue;
			/* } else { */ case 5:
				_key$2 = k; (i.keyDurations || $throwRuntimeError("assignment to entry in nil map"))[ebiten.Key.keyFor(_key$2)] = { k: _key$2, v: 0 };
			/* } */ case 6:
			k = k + (1) >> 0;
		/* } */ $s = 2; continue; case 3:
		_ref = new sliceType([0, 1, 2]);
		_i = 0;
		/* while (true) { */ case 8:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 9; continue; }
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_key$3 = b; (i.prevMouseButtonDurations || $throwRuntimeError("assignment to entry in nil map"))[ebiten.MouseButton.keyFor(_key$3)] = { k: _key$3, v: (_entry$2 = i.mouseButtonDurations[ebiten.MouseButton.keyFor(b)], _entry$2 !== undefined ? _entry$2.v : 0) };
			_r$1 = ebiten.IsMouseButtonPressed(b); /* */ $s = 13; case 13: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (_r$1) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (_r$1) { */ case 10:
				_key$4 = b; (i.mouseButtonDurations || $throwRuntimeError("assignment to entry in nil map"))[ebiten.MouseButton.keyFor(_key$4)] = { k: _key$4, v: (_entry$3 = i.mouseButtonDurations[ebiten.MouseButton.keyFor(b)], _entry$3 !== undefined ? _entry$3.v : 0) + (1) >> 0 };
				$s = 12; continue;
			/* } else { */ case 11:
				_key$5 = b; (i.mouseButtonDurations || $throwRuntimeError("assignment to entry in nil map"))[ebiten.MouseButton.keyFor(_key$5)] = { k: _key$5, v: 0 };
			/* } */ case 12:
			_i++;
		/* } */ $s = 8; continue; case 9:
		i.prevGamepadIDs = $makeMap($Int.keyFor, []);
		_ref$1 = i.gamepadIDs;
		_i$1 = 0;
		_keys = $keys(_ref$1);
		while (true) {
			if (!(_i$1 < _keys.length)) { break; }
			_entry$4 = _ref$1[_keys[_i$1]];
			if (_entry$4 === undefined) {
				_i$1++;
				continue;
			}
			id = _entry$4.k;
			_key$6 = id; (i.prevGamepadIDs || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key$6)] = { k: _key$6, v: new structType.ptr() };
			_i$1++;
		}
		i.prevGamepadButtonDurations = $makeMap($Int.keyFor, []);
		_ref$2 = i.gamepadButtonDurations;
		_i$2 = 0;
		_keys$1 = $keys(_ref$2);
		while (true) {
			if (!(_i$2 < _keys$1.length)) { break; }
			_entry$5 = _ref$2[_keys$1[_i$2]];
			if (_entry$5 === undefined) {
				_i$2++;
				continue;
			}
			id$1 = _entry$5.k;
			ds = _entry$5.v;
			_key$7 = id$1; (i.prevGamepadButtonDurations || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key$7)] = { k: _key$7, v: $makeMap(ebiten.GamepadButton.keyFor, []) };
			_ref$3 = ds;
			_i$3 = 0;
			_keys$2 = $keys(_ref$3);
			while (true) {
				if (!(_i$3 < _keys$2.length)) { break; }
				_entry$6 = _ref$3[_keys$2[_i$3]];
				if (_entry$6 === undefined) {
					_i$3++;
					continue;
				}
				b$1 = _entry$6.k;
				d = _entry$6.v;
				_key$8 = b$1; ((_entry$7 = i.prevGamepadButtonDurations[$Int.keyFor(id$1)], _entry$7 !== undefined ? _entry$7.v : false) || $throwRuntimeError("assignment to entry in nil map"))[ebiten.GamepadButton.keyFor(_key$8)] = { k: _key$8, v: d };
				_i$3++;
			}
			_i$2++;
		}
		i.gamepadIDs = $makeMap($Int.keyFor, []);
		_r$2 = ebiten.GamepadIDs(); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_ref$4 = _r$2;
		_i$4 = 0;
		/* while (true) { */ case 15:
			/* if (!(_i$4 < _ref$4.$length)) { break; } */ if(!(_i$4 < _ref$4.$length)) { $s = 16; continue; }
			id$2 = ((_i$4 < 0 || _i$4 >= _ref$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$4.$array[_ref$4.$offset + _i$4]);
			_key$9 = id$2; (i.gamepadIDs || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key$9)] = { k: _key$9, v: new structType.ptr() };
			_tuple = (_entry$8 = i.gamepadButtonDurations[$Int.keyFor(id$2)], _entry$8 !== undefined ? [_entry$8.v, true] : [false, false]);
			ok = _tuple[1];
			if (!ok) {
				_key$10 = id$2; (i.gamepadButtonDurations || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key$10)] = { k: _key$10, v: $makeMap(ebiten.GamepadButton.keyFor, []) };
			}
			_r$3 = ebiten.GamepadButtonNum(id$2); /* */ $s = 17; case 17: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			n = _r$3;
			b$2 = 0;
			/* while (true) { */ case 18:
				/* if (!(b$2 < ((n >> 0)))) { break; } */ if(!(b$2 < ((n >> 0)))) { $s = 19; continue; }
				_r$4 = ebiten.IsGamepadButtonPressed(id$2, b$2); /* */ $s = 23; case 23: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				/* */ if (_r$4) { $s = 20; continue; }
				/* */ $s = 21; continue;
				/* if (_r$4) { */ case 20:
					_key$11 = b$2; ((_entry$9 = i.gamepadButtonDurations[$Int.keyFor(id$2)], _entry$9 !== undefined ? _entry$9.v : false) || $throwRuntimeError("assignment to entry in nil map"))[ebiten.GamepadButton.keyFor(_key$11)] = { k: _key$11, v: (_entry$10 = (_entry$11 = i.gamepadButtonDurations[$Int.keyFor(id$2)], _entry$11 !== undefined ? _entry$11.v : false)[ebiten.GamepadButton.keyFor(b$2)], _entry$10 !== undefined ? _entry$10.v : 0) + (1) >> 0 };
					$s = 22; continue;
				/* } else { */ case 21:
					_key$12 = b$2; ((_entry$12 = i.gamepadButtonDurations[$Int.keyFor(id$2)], _entry$12 !== undefined ? _entry$12.v : false) || $throwRuntimeError("assignment to entry in nil map"))[ebiten.GamepadButton.keyFor(_key$12)] = { k: _key$12, v: 0 };
				/* } */ case 22:
				b$2 = b$2 + (1) >> 0;
			/* } */ $s = 18; continue; case 19:
			_i$4++;
		/* } */ $s = 15; continue; case 16:
		idsToDelete = new sliceType$1([]);
		_ref$5 = i.gamepadButtonDurations;
		_i$5 = 0;
		_keys$3 = $keys(_ref$5);
		while (true) {
			if (!(_i$5 < _keys$3.length)) { break; }
			_entry$13 = _ref$5[_keys$3[_i$5]];
			if (_entry$13 === undefined) {
				_i$5++;
				continue;
			}
			id$3 = _entry$13.k;
			_tuple$1 = (_entry$14 = i.gamepadIDs[$Int.keyFor(id$3)], _entry$14 !== undefined ? [_entry$14.v, true] : [new structType.ptr(), false]);
			ok$1 = _tuple$1[1];
			if (!ok$1) {
				idsToDelete = $append(idsToDelete, id$3);
			}
			_i$5++;
		}
		_ref$6 = idsToDelete;
		_i$6 = 0;
		while (true) {
			if (!(_i$6 < _ref$6.$length)) { break; }
			id$4 = ((_i$6 < 0 || _i$6 >= _ref$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$6.$array[_ref$6.$offset + _i$6]);
			delete i.gamepadButtonDurations[$Int.keyFor(id$4)];
			_i$6++;
		}
		ids = $makeMap($Int.keyFor, []);
		i.prevTouchDurations = $makeMap($Int.keyFor, []);
		_ref$7 = i.touchDurations;
		_i$7 = 0;
		_keys$4 = $keys(_ref$7);
		while (true) {
			if (!(_i$7 < _keys$4.length)) { break; }
			_entry$15 = _ref$7[_keys$4[_i$7]];
			if (_entry$15 === undefined) {
				_i$7++;
				continue;
			}
			id$5 = _entry$15.k;
			_key$13 = id$5; (i.prevTouchDurations || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key$13)] = { k: _key$13, v: (_entry$16 = i.touchDurations[$Int.keyFor(id$5)], _entry$16 !== undefined ? _entry$16.v : 0) };
			_i$7++;
		}
		_r$5 = ebiten.TouchIDs(); /* */ $s = 24; case 24: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		_ref$8 = _r$5;
		_i$8 = 0;
		/* while (true) { */ case 25:
			/* if (!(_i$8 < _ref$8.$length)) { break; } */ if(!(_i$8 < _ref$8.$length)) { $s = 26; continue; }
			id$6 = ((_i$8 < 0 || _i$8 >= _ref$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$8.$array[_ref$8.$offset + _i$8]);
			_key$14 = id$6; (ids || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key$14)] = { k: _key$14, v: new structType.ptr() };
			_key$15 = id$6; (i.touchDurations || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key$15)] = { k: _key$15, v: (_entry$17 = i.touchDurations[$Int.keyFor(id$6)], _entry$17 !== undefined ? _entry$17.v : 0) + (1) >> 0 };
			_i$8++;
		/* } */ $s = 25; continue; case 26:
		idsToDelete = new sliceType$1([]);
		_ref$9 = i.touchDurations;
		_i$9 = 0;
		_keys$5 = $keys(_ref$9);
		while (true) {
			if (!(_i$9 < _keys$5.length)) { break; }
			_entry$18 = _ref$9[_keys$5[_i$9]];
			if (_entry$18 === undefined) {
				_i$9++;
				continue;
			}
			id$7 = _entry$18.k;
			_tuple$2 = (_entry$19 = ids[$Int.keyFor(id$7)], _entry$19 !== undefined ? [_entry$19.v, true] : [new structType.ptr(), false]);
			ok$2 = _tuple$2[1];
			if (!ok$2) {
				idsToDelete = $append(idsToDelete, id$7);
			}
			_i$9++;
		}
		_ref$10 = idsToDelete;
		_i$10 = 0;
		while (true) {
			if (!(_i$10 < _ref$10.$length)) { break; }
			id$8 = ((_i$10 < 0 || _i$10 >= _ref$10.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$10.$array[_ref$10.$offset + _i$10]);
			delete i.touchDurations[$Int.keyFor(id$8)];
			_i$10++;
		}
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: inputState.ptr.prototype.update }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$10 = _entry$10; $f._entry$11 = _entry$11; $f._entry$12 = _entry$12; $f._entry$13 = _entry$13; $f._entry$14 = _entry$14; $f._entry$15 = _entry$15; $f._entry$16 = _entry$16; $f._entry$17 = _entry$17; $f._entry$18 = _entry$18; $f._entry$19 = _entry$19; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._entry$4 = _entry$4; $f._entry$5 = _entry$5; $f._entry$6 = _entry$6; $f._entry$7 = _entry$7; $f._entry$8 = _entry$8; $f._entry$9 = _entry$9; $f._i = _i; $f._i$1 = _i$1; $f._i$10 = _i$10; $f._i$2 = _i$2; $f._i$3 = _i$3; $f._i$4 = _i$4; $f._i$5 = _i$5; $f._i$6 = _i$6; $f._i$7 = _i$7; $f._i$8 = _i$8; $f._i$9 = _i$9; $f._key = _key; $f._key$1 = _key$1; $f._key$10 = _key$10; $f._key$11 = _key$11; $f._key$12 = _key$12; $f._key$13 = _key$13; $f._key$14 = _key$14; $f._key$15 = _key$15; $f._key$2 = _key$2; $f._key$3 = _key$3; $f._key$4 = _key$4; $f._key$5 = _key$5; $f._key$6 = _key$6; $f._key$7 = _key$7; $f._key$8 = _key$8; $f._key$9 = _key$9; $f._keys = _keys; $f._keys$1 = _keys$1; $f._keys$2 = _keys$2; $f._keys$3 = _keys$3; $f._keys$4 = _keys$4; $f._keys$5 = _keys$5; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$10 = _ref$10; $f._ref$2 = _ref$2; $f._ref$3 = _ref$3; $f._ref$4 = _ref$4; $f._ref$5 = _ref$5; $f._ref$6 = _ref$6; $f._ref$7 = _ref$7; $f._ref$8 = _ref$8; $f._ref$9 = _ref$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.b = b; $f.b$1 = b$1; $f.b$2 = b$2; $f.d = d; $f.ds = ds; $f.i = i; $f.id = id; $f.id$1 = id$1; $f.id$2 = id$2; $f.id$3 = id$3; $f.id$4 = id$4; $f.id$5 = id$5; $f.id$6 = id$6; $f.id$7 = id$7; $f.id$8 = id$8; $f.ids = ids; $f.idsToDelete = idsToDelete; $f.k = k; $f.n = n; $f.ok = ok; $f.ok$1 = ok$1; $f.ok$2 = ok$2; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	inputState.prototype.update = function() { return this.$val.update(); };
	IsMouseButtonJustPressed = function(button) {
		var _r, button, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; button = $f.button; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = MouseButtonPressDuration(button); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r === 1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: IsMouseButtonJustPressed }; } $f._r = _r; $f.button = button; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.IsMouseButtonJustPressed = IsMouseButtonJustPressed;
	MouseButtonPressDuration = function(button) {
		var _entry, button, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; button = $f.button; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = theInputState.m.RLock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		s = (_entry = theInputState.mouseButtonDurations[ebiten.MouseButton.keyFor(button)], _entry !== undefined ? _entry.v : 0);
		$r = theInputState.m.RUnlock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return s;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MouseButtonPressDuration }; } $f._entry = _entry; $f.button = button; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MouseButtonPressDuration = MouseButtonPressDuration;
	JustPressedTouchIDs = function() {
		var _entry, _i, _keys, _ref, id, ids, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _ref = $f._ref; id = $f.id; ids = $f.ids; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ids = sliceType$1.nil;
		$r = theInputState.m.RLock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_ref = theInputState.touchDurations;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			id = _entry.k;
			s = _entry.v;
			if (s === 1) {
				ids = $append(ids, id);
			}
			_i++;
		}
		$r = theInputState.m.RUnlock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sort.Ints(ids); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return ids;
		/* */ } return; } if ($f === undefined) { $f = { $blk: JustPressedTouchIDs }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._ref = _ref; $f.id = id; $f.ids = ids; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.JustPressedTouchIDs = JustPressedTouchIDs;
	ptrType.methods = [{prop: "update", name: "update", pkg: "github.com/hajimehoshi/ebiten/inpututil", typ: $funcType([], [], false)}];
	inputState.init("github.com/hajimehoshi/ebiten/inpututil", [{prop: "keyDurations", name: "keyDurations", embedded: false, exported: false, typ: mapType, tag: ""}, {prop: "prevKeyDurations", name: "prevKeyDurations", embedded: false, exported: false, typ: mapType, tag: ""}, {prop: "mouseButtonDurations", name: "mouseButtonDurations", embedded: false, exported: false, typ: mapType$1, tag: ""}, {prop: "prevMouseButtonDurations", name: "prevMouseButtonDurations", embedded: false, exported: false, typ: mapType$1, tag: ""}, {prop: "gamepadIDs", name: "gamepadIDs", embedded: false, exported: false, typ: mapType$2, tag: ""}, {prop: "prevGamepadIDs", name: "prevGamepadIDs", embedded: false, exported: false, typ: mapType$2, tag: ""}, {prop: "gamepadButtonDurations", name: "gamepadButtonDurations", embedded: false, exported: false, typ: mapType$4, tag: ""}, {prop: "prevGamepadButtonDurations", name: "prevGamepadButtonDurations", embedded: false, exported: false, typ: mapType$4, tag: ""}, {prop: "touchDurations", name: "touchDurations", embedded: false, exported: false, typ: mapType$5, tag: ""}, {prop: "prevTouchDurations", name: "prevTouchDurations", embedded: false, exported: false, typ: mapType$5, tag: ""}, {prop: "m", name: "m", embedded: false, exported: false, typ: sync.RWMutex, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = ebiten.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = hooks.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sort.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		theInputState = new inputState.ptr($makeMap(ebiten.Key.keyFor, []), $makeMap(ebiten.Key.keyFor, []), $makeMap(ebiten.MouseButton.keyFor, []), $makeMap(ebiten.MouseButton.keyFor, []), $makeMap($Int.keyFor, []), $makeMap($Int.keyFor, []), $makeMap($Int.keyFor, []), $makeMap($Int.keyFor, []), $makeMap($Int.keyFor, []), $makeMap($Int.keyFor, []), new sync.RWMutex.ptr(new sync.Mutex.ptr(0, 0), 0, 0, 0, 0));
		$r = init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["github.com/hajimehoshi/ebiten/text"] = (function() {
	var $pkg = {}, $init, ebiten, font, fixed, image, color, math, sync, colorMCacheKey, colorMCacheEntry, glyphImage, glyphImageCacheEntry, ptrType, ptrType$1, sliceType, ptrType$2, ptrType$3, ptrType$4, sliceType$1, structType, ptrType$5, ptrType$6, sliceType$2, glyphAdvanceCache, monotonicClock, glyphBoundsCache, glyphImageCache, emptyGlyphs, textM, colorMCache, emptyColorM, glyphAdvance, now, fixed26_6ToFloat64, drawGlyph, getGlyphBounds, getGlyphImages, init, colorToColorM, Draw;
	ebiten = $packages["github.com/hajimehoshi/ebiten"];
	font = $packages["golang.org/x/image/font"];
	fixed = $packages["golang.org/x/image/math/fixed"];
	image = $packages["image"];
	color = $packages["image/color"];
	math = $packages["math"];
	sync = $packages["sync"];
	colorMCacheKey = $pkg.colorMCacheKey = $newType(4, $kindUint32, "text.colorMCacheKey", true, "github.com/hajimehoshi/ebiten/text", false, null);
	colorMCacheEntry = $pkg.colorMCacheEntry = $newType(0, $kindStruct, "text.colorMCacheEntry", true, "github.com/hajimehoshi/ebiten/text", false, function(m_, atime_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.m = new ebiten.ColorM.ptr(ptrType.nil);
			this.atime = new $Int64(0, 0);
			return;
		}
		this.m = m_;
		this.atime = atime_;
	});
	glyphImage = $pkg.glyphImage = $newType(0, $kindStruct, "text.glyphImage", true, "github.com/hajimehoshi/ebiten/text", false, function(image_, x_, y_, width_, height_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.image = ptrType$3.nil;
			this.x = 0;
			this.y = 0;
			this.width = 0;
			this.height = 0;
			return;
		}
		this.image = image_;
		this.x = x_;
		this.y = y_;
		this.width = width_;
		this.height = height_;
	});
	glyphImageCacheEntry = $pkg.glyphImageCacheEntry = $newType(0, $kindStruct, "text.glyphImageCacheEntry", true, "github.com/hajimehoshi/ebiten/text", false, function(image_, atime_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.image = ptrType$1.nil;
			this.atime = new $Int64(0, 0);
			return;
		}
		this.image = image_;
		this.atime = atime_;
	});
	ptrType = $ptrType($packages["github.com/hajimehoshi/ebiten/internal/affine"].ColorM);
	ptrType$1 = $ptrType(glyphImage);
	sliceType = $sliceType(ebiten.ImagePart);
	ptrType$2 = $ptrType(image.Rectangle);
	ptrType$3 = $ptrType(ebiten.Image);
	ptrType$4 = $ptrType(fixed.Rectangle26_6);
	sliceType$1 = $sliceType(ptrType$1);
	structType = $structType("", []);
	ptrType$5 = $ptrType(glyphImageCacheEntry);
	ptrType$6 = $ptrType(colorMCacheEntry);
	sliceType$2 = $sliceType($Int32);
	glyphAdvance = function(face, r) {
		var _entry, _entry$1, _key, _key$1, _r, _tuple, _tuple$1, _tuple$2, a, face, m, ok, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _key = $f._key; _key$1 = $f._key$1; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; a = $f.a; face = $f.face; m = $f.m; ok = $f.ok; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = (_entry = glyphAdvanceCache[font.Face.keyFor(face)], _entry !== undefined ? [_entry.v, true] : [false, false]);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = $makeMap($Int32.keyFor, []);
			_key = face; (glyphAdvanceCache || $throwRuntimeError("assignment to entry in nil map"))[font.Face.keyFor(_key)] = { k: _key, v: m };
		}
		_tuple$1 = (_entry$1 = m[$Int32.keyFor(r)], _entry$1 !== undefined ? [_entry$1.v, true] : [0, false]);
		a = _tuple$1[0];
		ok = _tuple$1[1];
		/* */ if (!ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!ok) { */ case 1:
			_r = face.GlyphAdvance(r); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple$2 = _r;
			a = _tuple$2[0];
			_key$1 = r; (m || $throwRuntimeError("assignment to entry in nil map"))[$Int32.keyFor(_key$1)] = { k: _key$1, v: a };
		/* } */ case 2:
		$s = -1; return a;
		/* */ } return; } if ($f === undefined) { $f = { $blk: glyphAdvance }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._key = _key; $f._key$1 = _key$1; $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.a = a; $f.face = face; $f.m = m; $f.ok = ok; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	now = function() {
		var x;
		monotonicClock = (x = new $Int64(0, 1), new $Int64(monotonicClock.$high + x.$high, monotonicClock.$low + x.$low));
		return monotonicClock;
	};
	fixed26_6ToFloat64 = function(x) {
		var x;
		return (x) / 64;
	};
	drawGlyph = function(dst, face, r, img, x, y, clr) {
		var _r, _r$1, b, clr, dst, face, img, op, r, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; b = $f.b; clr = $f.clr; dst = $f.dst; face = $f.face; img = $f.img; op = $f.op; r = $f.r; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (img === ptrType$1.nil) {
			$s = -1; return;
		}
		_r = getGlyphBounds(face, r); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		b = _r;
		op = new ebiten.DrawImageOptions.ptr(new ebiten.GeoM.ptr(0, 0, 0, 0, 0, 0), new ebiten.ColorM.ptr(ptrType.nil), 0, 0, $ifaceNil, sliceType.nil, ptrType$2.nil);
		op.GeoM.Translate(fixed26_6ToFloat64(x + b.Min.X >> 0), fixed26_6ToFloat64(y + b.Min.Y >> 0));
		ebiten.ColorM.copy(op.ColorM, clr);
		_r$1 = dst.DrawImage($assertType(img.image.SubImage($clone(image.Rect(img.x, img.y, img.x + img.width >> 0, img.y + img.height >> 0), image.Rectangle)), ptrType$3), op); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$unused(_r$1);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: drawGlyph }; } $f._r = _r; $f._r$1 = _r$1; $f.b = b; $f.clr = clr; $f.dst = dst; $f.face = face; $f.img = img; $f.op = op; $f.r = r; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	getGlyphBounds = function(face, r) {
		var _entry, _entry$1, _entry$2, _entry$3, _key, _key$1, _r, _tuple, _tuple$1, _tuple$2, b, b$1, face, ok, ok$1, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _key = $f._key; _key$1 = $f._key$1; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; b = $f.b; b$1 = $f.b$1; face = $f.face; ok = $f.ok; ok$1 = $f.ok$1; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = [b];
		_tuple = (_entry = glyphBoundsCache[font.Face.keyFor(face)], _entry !== undefined ? [_entry.v, true] : [false, false]);
		ok = _tuple[1];
		if (!ok) {
			_key = face; (glyphBoundsCache || $throwRuntimeError("assignment to entry in nil map"))[font.Face.keyFor(_key)] = { k: _key, v: $makeMap($Int32.keyFor, []) };
		}
		_tuple$1 = (_entry$1 = (_entry$2 = glyphBoundsCache[font.Face.keyFor(face)], _entry$2 !== undefined ? _entry$2.v : false)[$Int32.keyFor(r)], _entry$1 !== undefined ? [_entry$1.v, true] : [ptrType$4.nil, false]);
		b$1 = _tuple$1[0];
		ok$1 = _tuple$1[1];
		if (ok$1) {
			$s = -1; return b$1;
		}
		_r = face.GlyphBounds(r); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple$2 = _r;
		b[0] = $clone(_tuple$2[0], fixed.Rectangle26_6);
		_key$1 = r; ((_entry$3 = glyphBoundsCache[font.Face.keyFor(face)], _entry$3 !== undefined ? _entry$3.v : false) || $throwRuntimeError("assignment to entry in nil map"))[$Int32.keyFor(_key$1)] = { k: _key$1, v: b[0] };
		$s = -1; return b[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: getGlyphBounds }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._key = _key; $f._key$1 = _key$1; $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.b = b; $f.b$1 = b$1; $f.face = face; $f.ok = ok; $f.ok$1 = ok$1; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	getGlyphImages = function(face, runes) {
		var _entry, _entry$1, _entry$10, _entry$11, _entry$12, _entry$13, _entry$14, _entry$15, _entry$16, _entry$17, _entry$18, _entry$2, _entry$3, _entry$4, _entry$5, _entry$6, _entry$7, _entry$8, _entry$9, _i, _i$1, _i$2, _i$3, _i$4, _key, _key$1, _key$2, _key$3, _key$4, _key$5, _key$6, _keys, _keys$1, _keys$2, _keys$3, _r, _r$1, _ref, _ref$1, _ref$2, _ref$3, _ref$4, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, b, b$1, b$2, b$3, d, e, e$1, face, g, glyphBounds, h, h$1, h$2, h2, i, i$1, img, imgs, neededGlyphIndices, ok, ok$1, ok$2, ok$3, ok$4, oldest, oldestKey, r, r$1, r$2, r$3, rgba, runes, w, w$1, w$2, w$3, w2, x, x$1, xs, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$10 = $f._entry$10; _entry$11 = $f._entry$11; _entry$12 = $f._entry$12; _entry$13 = $f._entry$13; _entry$14 = $f._entry$14; _entry$15 = $f._entry$15; _entry$16 = $f._entry$16; _entry$17 = $f._entry$17; _entry$18 = $f._entry$18; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _entry$4 = $f._entry$4; _entry$5 = $f._entry$5; _entry$6 = $f._entry$6; _entry$7 = $f._entry$7; _entry$8 = $f._entry$8; _entry$9 = $f._entry$9; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _i$3 = $f._i$3; _i$4 = $f._i$4; _key = $f._key; _key$1 = $f._key$1; _key$2 = $f._key$2; _key$3 = $f._key$3; _key$4 = $f._key$4; _key$5 = $f._key$5; _key$6 = $f._key$6; _keys = $f._keys; _keys$1 = $f._keys$1; _keys$2 = $f._keys$2; _keys$3 = $f._keys$3; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _ref$3 = $f._ref$3; _ref$4 = $f._ref$4; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; b = $f.b; b$1 = $f.b$1; b$2 = $f.b$2; b$3 = $f.b$3; d = $f.d; e = $f.e; e$1 = $f.e$1; face = $f.face; g = $f.g; glyphBounds = $f.glyphBounds; h = $f.h; h$1 = $f.h$1; h$2 = $f.h$2; h2 = $f.h2; i = $f.i; i$1 = $f.i$1; img = $f.img; imgs = $f.imgs; neededGlyphIndices = $f.neededGlyphIndices; ok = $f.ok; ok$1 = $f.ok$1; ok$2 = $f.ok$2; ok$3 = $f.ok$3; ok$4 = $f.ok$4; oldest = $f.oldest; oldestKey = $f.oldestKey; r = $f.r; r$1 = $f.r$1; r$2 = $f.r$2; r$3 = $f.r$3; rgba = $f.rgba; runes = $f.runes; w = $f.w; w$1 = $f.w$1; w$2 = $f.w$2; w$3 = $f.w$3; w2 = $f.w2; x = $f.x; x$1 = $f.x$1; xs = $f.xs; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = (_entry = emptyGlyphs[font.Face.keyFor(face)], _entry !== undefined ? [_entry.v, true] : [false, false]);
		ok = _tuple[1];
		if (!ok) {
			_key = face; (emptyGlyphs || $throwRuntimeError("assignment to entry in nil map"))[font.Face.keyFor(_key)] = { k: _key, v: $makeMap($Int32.keyFor, []) };
		}
		_tuple$1 = (_entry$1 = glyphImageCache[font.Face.keyFor(face)], _entry$1 !== undefined ? [_entry$1.v, true] : [false, false]);
		ok$1 = _tuple$1[1];
		if (!ok$1) {
			_key$1 = face; (glyphImageCache || $throwRuntimeError("assignment to entry in nil map"))[font.Face.keyFor(_key$1)] = { k: _key$1, v: $makeMap($Int32.keyFor, []) };
		}
		imgs = $makeSlice(sliceType$1, runes.$length);
		glyphBounds = $makeMap($Int32.keyFor, []);
		neededGlyphIndices = $makeMap($Int.keyFor, []);
		_ref = runes;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			r = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_tuple$2 = (_entry$2 = (_entry$3 = emptyGlyphs[font.Face.keyFor(face)], _entry$3 !== undefined ? _entry$3.v : false)[$Int32.keyFor(r)], _entry$2 !== undefined ? [_entry$2.v, true] : [new structType.ptr(), false]);
			ok$2 = _tuple$2[1];
			if (ok$2) {
				_i++;
				/* continue; */ $s = 1; continue;
			}
			_tuple$3 = (_entry$4 = (_entry$5 = glyphImageCache[font.Face.keyFor(face)], _entry$5 !== undefined ? _entry$5.v : false)[$Int32.keyFor(r)], _entry$4 !== undefined ? [_entry$4.v, true] : [ptrType$5.nil, false]);
			e = _tuple$3[0];
			ok$3 = _tuple$3[1];
			if (ok$3) {
				e.atime = now();
				((i < 0 || i >= imgs.$length) ? ($throwRuntimeError("index out of range"), undefined) : imgs.$array[imgs.$offset + i] = e.image);
				_i++;
				/* continue; */ $s = 1; continue;
			}
			_r = getGlyphBounds(face, r); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			b = _r;
			_tmp = new fixed.Int26_6(((b.Max.X - b.Min.X >> 0))).Ceil();
			_tmp$1 = new fixed.Int26_6(((b.Max.Y - b.Min.Y >> 0))).Ceil();
			w = _tmp;
			h = _tmp$1;
			if ((w === 0) || (h === 0)) {
				_key$2 = r; ((_entry$6 = emptyGlyphs[font.Face.keyFor(face)], _entry$6 !== undefined ? _entry$6.v : false) || $throwRuntimeError("assignment to entry in nil map"))[$Int32.keyFor(_key$2)] = { k: _key$2, v: new structType.ptr() };
				_i++;
				/* continue; */ $s = 1; continue;
			}
			if ($keys((_entry$7 = glyphImageCache[font.Face.keyFor(face)], _entry$7 !== undefined ? _entry$7.v : false)).length > 512) {
				oldest = new $Int64(2147483647, 4294967295);
				oldestKey = -1;
				_ref$1 = (_entry$8 = glyphImageCache[font.Face.keyFor(face)], _entry$8 !== undefined ? _entry$8.v : false);
				_i$1 = 0;
				_keys = $keys(_ref$1);
				while (true) {
					if (!(_i$1 < _keys.length)) { break; }
					_entry$9 = _ref$1[_keys[_i$1]];
					if (_entry$9 === undefined) {
						_i$1++;
						continue;
					}
					r$1 = _entry$9.k;
					e$1 = _entry$9.v;
					if ((x = e$1.atime, (x.$high < oldest.$high || (x.$high === oldest.$high && x.$low < oldest.$low)))) {
						oldestKey = r$1;
						oldest = e$1.atime;
					}
					_i$1++;
				}
				delete (_entry$10 = glyphImageCache[font.Face.keyFor(face)], _entry$10 !== undefined ? _entry$10.v : false)[$Int32.keyFor(oldestKey)];
			}
			_key$3 = r; (glyphBounds || $throwRuntimeError("assignment to entry in nil map"))[$Int32.keyFor(_key$3)] = { k: _key$3, v: b };
			_key$4 = i; (neededGlyphIndices || $throwRuntimeError("assignment to entry in nil map"))[$Int.keyFor(_key$4)] = { k: _key$4, v: r };
			_i++;
		/* } */ $s = 1; continue; case 2:
		/* */ if ($keys(neededGlyphIndices).length > 0) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if ($keys(neededGlyphIndices).length > 0) { */ case 4:
			w2 = 0;
			h2 = 0;
			_ref$2 = glyphBounds;
			_i$2 = 0;
			_keys$1 = $keys(_ref$2);
			while (true) {
				if (!(_i$2 < _keys$1.length)) { break; }
				_entry$11 = _ref$2[_keys$1[_i$2]];
				if (_entry$11 === undefined) {
					_i$2++;
					continue;
				}
				b$1 = _entry$11.v;
				_tmp$2 = new fixed.Int26_6(((b$1.Max.X - b$1.Min.X >> 0))).Ceil();
				_tmp$3 = new fixed.Int26_6(((b$1.Max.Y - b$1.Min.Y >> 0))).Ceil();
				w$1 = _tmp$2;
				h$1 = _tmp$3;
				w2 = w2 + (w$1) >> 0;
				if (h2 < h$1) {
					h2 = h$1;
				}
				_i$2++;
			}
			rgba = image.NewRGBA($clone(image.Rect(0, 0, w2, h2), image.Rectangle));
			x$1 = 0;
			xs = $makeMap($Int32.keyFor, []);
			_ref$3 = glyphBounds;
			_i$3 = 0;
			_keys$2 = $keys(_ref$3);
			/* while (true) { */ case 6:
				/* if (!(_i$3 < _keys$2.length)) { break; } */ if(!(_i$3 < _keys$2.length)) { $s = 7; continue; }
				_entry$12 = _ref$3[_keys$2[_i$3]];
				if (_entry$12 === undefined) {
					_i$3++;
					/* continue; */ $s = 6; continue;
				}
				r$2 = _entry$12.k;
				b$2 = _entry$12.v;
				w$2 = new fixed.Int26_6(((b$2.Max.X - b$2.Min.X >> 0))).Ceil();
				d = new font.Drawer.ptr(rgba, image.White, face, new fixed.Point26_6.ptr(0, 0));
				fixed.Point26_6.copy(d.Dot, new fixed.Point26_6.ptr(fixed.I(x$1) - b$2.Min.X >> 0, -b$2.Min.Y));
				$r = d.DrawString(($encodeRune(r$2))); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				_key$5 = r$2; (xs || $throwRuntimeError("assignment to entry in nil map"))[$Int32.keyFor(_key$5)] = { k: _key$5, v: x$1 };
				x$1 = x$1 + (w$2) >> 0;
				_i$3++;
			/* } */ $s = 6; continue; case 7:
			_r$1 = ebiten.NewImageFromImage(rgba, 0); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$4 = _r$1;
			img = _tuple$4[0];
			_ref$4 = neededGlyphIndices;
			_i$4 = 0;
			_keys$3 = $keys(_ref$4);
			while (true) {
				if (!(_i$4 < _keys$3.length)) { break; }
				_entry$13 = _ref$4[_keys$3[_i$4]];
				if (_entry$13 === undefined) {
					_i$4++;
					continue;
				}
				i$1 = _entry$13.k;
				r$3 = _entry$13.v;
				b$3 = (_entry$14 = glyphBounds[$Int32.keyFor(r$3)], _entry$14 !== undefined ? _entry$14.v : ptrType$4.nil);
				_tmp$4 = new fixed.Int26_6(((b$3.Max.X - b$3.Min.X >> 0))).Ceil();
				_tmp$5 = new fixed.Int26_6(((b$3.Max.Y - b$3.Min.Y >> 0))).Ceil();
				w$3 = _tmp$4;
				h$2 = _tmp$5;
				g = new glyphImage.ptr(img, (_entry$15 = xs[$Int32.keyFor(r$3)], _entry$15 !== undefined ? _entry$15.v : 0), 0, w$3, h$2);
				_tuple$5 = (_entry$16 = (_entry$17 = glyphImageCache[font.Face.keyFor(face)], _entry$17 !== undefined ? _entry$17.v : false)[$Int32.keyFor(r$3)], _entry$16 !== undefined ? [_entry$16.v, true] : [ptrType$5.nil, false]);
				ok$4 = _tuple$5[1];
				if (!ok$4) {
					_key$6 = r$3; ((_entry$18 = glyphImageCache[font.Face.keyFor(face)], _entry$18 !== undefined ? _entry$18.v : false) || $throwRuntimeError("assignment to entry in nil map"))[$Int32.keyFor(_key$6)] = { k: _key$6, v: new glyphImageCacheEntry.ptr(g, now()) };
				}
				((i$1 < 0 || i$1 >= imgs.$length) ? ($throwRuntimeError("index out of range"), undefined) : imgs.$array[imgs.$offset + i$1] = g);
				_i$4++;
			}
		/* } */ case 5:
		$s = -1; return imgs;
		/* */ } return; } if ($f === undefined) { $f = { $blk: getGlyphImages }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$10 = _entry$10; $f._entry$11 = _entry$11; $f._entry$12 = _entry$12; $f._entry$13 = _entry$13; $f._entry$14 = _entry$14; $f._entry$15 = _entry$15; $f._entry$16 = _entry$16; $f._entry$17 = _entry$17; $f._entry$18 = _entry$18; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._entry$4 = _entry$4; $f._entry$5 = _entry$5; $f._entry$6 = _entry$6; $f._entry$7 = _entry$7; $f._entry$8 = _entry$8; $f._entry$9 = _entry$9; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._i$3 = _i$3; $f._i$4 = _i$4; $f._key = _key; $f._key$1 = _key$1; $f._key$2 = _key$2; $f._key$3 = _key$3; $f._key$4 = _key$4; $f._key$5 = _key$5; $f._key$6 = _key$6; $f._keys = _keys; $f._keys$1 = _keys$1; $f._keys$2 = _keys$2; $f._keys$3 = _keys$3; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._ref$3 = _ref$3; $f._ref$4 = _ref$4; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f.b = b; $f.b$1 = b$1; $f.b$2 = b$2; $f.b$3 = b$3; $f.d = d; $f.e = e; $f.e$1 = e$1; $f.face = face; $f.g = g; $f.glyphBounds = glyphBounds; $f.h = h; $f.h$1 = h$1; $f.h$2 = h$2; $f.h2 = h2; $f.i = i; $f.i$1 = i$1; $f.img = img; $f.imgs = imgs; $f.neededGlyphIndices = neededGlyphIndices; $f.ok = ok; $f.ok$1 = ok$1; $f.ok$2 = ok$2; $f.ok$3 = ok$3; $f.ok$4 = ok$4; $f.oldest = oldest; $f.oldestKey = oldestKey; $f.r = r; $f.r$1 = r$1; $f.r$2 = r$2; $f.r$3 = r$3; $f.rgba = rgba; $f.runes = runes; $f.w = w; $f.w$1 = w$1; $f.w$2 = w$2; $f.w$3 = w$3; $f.w2 = w2; $f.x = x; $f.x$1 = x$1; $f.xs = xs; $f.$s = $s; $f.$r = $r; return $f;
	};
	init = function() {
		emptyColorM.Scale(0, 0, 0, 0);
	};
	colorToColorM = function(clr) {
		var _entry, _entry$1, _i, _key, _keys, _r, _ref, _tuple, _tuple$1, af, bf, c, ca, cb, cg, clr, cm, cr, e, gf, key, key$1, ok, oldest, oldestKey, rf, x, y, y$1, y$2, y$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _i = $f._i; _key = $f._key; _keys = $f._keys; _r = $f._r; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; af = $f.af; bf = $f.bf; c = $f.c; ca = $f.ca; cb = $f.cb; cg = $f.cg; clr = $f.clr; cm = $f.cm; cr = $f.cr; e = $f.e; gf = $f.gf; key = $f.key; key$1 = $f.key$1; ok = $f.ok; oldest = $f.oldest; oldestKey = $f.oldestKey; rf = $f.rf; x = $f.x; y = $f.y; y$1 = $f.y$1; y$2 = $f.y$2; y$3 = $f.y$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = clr.RGBA(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		cr = _tuple[0];
		cg = _tuple[1];
		cb = _tuple[2];
		ca = _tuple[3];
		cr = (y = (8), y < 32 ? (cr >>> y) : 0) >>> 0;
		cg = (y$1 = (8), y$1 < 32 ? (cg >>> y$1) : 0) >>> 0;
		cb = (y$2 = (8), y$2 < 32 ? (cb >>> y$2) : 0) >>> 0;
		ca = (y$3 = (8), y$3 < 32 ? (ca >>> y$3) : 0) >>> 0;
		if (ca === 0) {
			$s = -1; return emptyColorM;
		}
		key = (((((((((cr) | (((cg) << 8 >>> 0))) >>> 0) | (((cb) << 16 >>> 0))) >>> 0) | (((ca) << 24 >>> 0))) >>> 0) >>> 0));
		_tuple$1 = (_entry = colorMCache[colorMCacheKey.keyFor(key)], _entry !== undefined ? [_entry.v, true] : [ptrType$6.nil, false]);
		e = _tuple$1[0];
		ok = _tuple$1[1];
		if (ok) {
			e.atime = now();
			$s = -1; return e.m;
		}
		if ($keys(colorMCache).length > 512) {
			oldest = new $Int64(2147483647, 4294967295);
			oldestKey = 0;
			_ref = colorMCache;
			_i = 0;
			_keys = $keys(_ref);
			while (true) {
				if (!(_i < _keys.length)) { break; }
				_entry$1 = _ref[_keys[_i]];
				if (_entry$1 === undefined) {
					_i++;
					continue;
				}
				key$1 = _entry$1.k;
				c = _entry$1.v;
				if ((x = c.atime, (x.$high < oldest.$high || (x.$high === oldest.$high && x.$low < oldest.$low)))) {
					oldestKey = key$1;
					oldest = c.atime;
				}
				_i++;
			}
			delete colorMCache[colorMCacheKey.keyFor(oldestKey)];
		}
		cm = new ebiten.ColorM.ptr(ptrType.nil);
		rf = (cr) / (ca);
		gf = (cg) / (ca);
		bf = (cb) / (ca);
		af = (ca) / 255;
		cm.Scale(rf, gf, bf, af);
		e = new colorMCacheEntry.ptr($clone(cm, ebiten.ColorM), now());
		_key = key; (colorMCache || $throwRuntimeError("assignment to entry in nil map"))[colorMCacheKey.keyFor(_key)] = { k: _key, v: e };
		$s = -1; return e.m;
		/* */ } return; } if ($f === undefined) { $f = { $blk: colorToColorM }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._i = _i; $f._key = _key; $f._keys = _keys; $f._r = _r; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.af = af; $f.bf = bf; $f.c = c; $f.ca = ca; $f.cb = cb; $f.cg = cg; $f.clr = clr; $f.cm = cm; $f.cr = cr; $f.e = e; $f.gf = gf; $f.key = key; $f.key$1 = key$1; $f.ok = ok; $f.oldest = oldest; $f.oldestKey = oldestKey; $f.rf = rf; $f.x = x; $f.y = y; $f.y$1 = y$1; $f.y$2 = y$2; $f.y$3 = y$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Draw = function(dst, text, face, x, y, clr) {
		var _i, _r, _r$1, _r$2, _r$3, _ref, clr, colorm, dst, face, fx, glyphImgs, i, prevR, r, runes, text, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; clr = $f.clr; colorm = $f.colorm; dst = $f.dst; face = $f.face; fx = $f.fx; glyphImgs = $f.glyphImgs; i = $f.i; prevR = $f.prevR; r = $f.r; runes = $f.runes; text = $f.text; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = textM.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		fx = fixed.I(x);
		prevR = -1;
		runes = (new sliceType$2($stringToRunes(text)));
		_r = getGlyphImages(face, runes); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		glyphImgs = _r;
		_r$1 = colorToColorM(clr); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		colorm = $clone(_r$1, ebiten.ColorM);
		_ref = runes;
		_i = 0;
		/* while (true) { */ case 4:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
			i = _i;
			r = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			/* */ if (prevR >= 0) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (prevR >= 0) { */ case 6:
				_r$2 = face.Kern(prevR, r); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				fx = fx + (_r$2) >> 0;
			/* } */ case 7:
			$r = drawGlyph(dst, face, r, ((i < 0 || i >= glyphImgs.$length) ? ($throwRuntimeError("index out of range"), undefined) : glyphImgs.$array[glyphImgs.$offset + i]), fx, fixed.I(y), $clone(colorm, ebiten.ColorM)); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_r$3 = glyphAdvance(face, r); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			fx = fx + (_r$3) >> 0;
			prevR = r;
			_i++;
		/* } */ $s = 4; continue; case 5:
		$r = textM.Unlock(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Draw }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f.clr = clr; $f.colorm = colorm; $f.dst = dst; $f.face = face; $f.fx = fx; $f.glyphImgs = glyphImgs; $f.i = i; $f.prevR = prevR; $f.r = r; $f.runes = runes; $f.text = text; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Draw = Draw;
	colorMCacheEntry.init("github.com/hajimehoshi/ebiten/text", [{prop: "m", name: "m", embedded: false, exported: false, typ: ebiten.ColorM, tag: ""}, {prop: "atime", name: "atime", embedded: false, exported: false, typ: $Int64, tag: ""}]);
	glyphImage.init("github.com/hajimehoshi/ebiten/text", [{prop: "image", name: "image", embedded: false, exported: false, typ: ptrType$3, tag: ""}, {prop: "x", name: "x", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "y", name: "y", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "height", name: "height", embedded: false, exported: false, typ: $Int, tag: ""}]);
	glyphImageCacheEntry.init("github.com/hajimehoshi/ebiten/text", [{prop: "image", name: "image", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "atime", name: "atime", embedded: false, exported: false, typ: $Int64, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = ebiten.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = font.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = fixed.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = image.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = color.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		monotonicClock = new $Int64(0, 0);
		textM = new sync.Mutex.ptr(0, 0);
		emptyColorM = new ebiten.ColorM.ptr(ptrType.nil);
		glyphAdvanceCache = $makeMap(font.Face.keyFor, []);
		glyphBoundsCache = $makeMap(font.Face.keyFor, []);
		glyphImageCache = $makeMap(font.Face.keyFor, []);
		emptyGlyphs = $makeMap(font.Face.keyFor, []);
		colorMCache = $makeMap(colorMCacheKey.keyFor, []);
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["golang.org/x/image/colornames"] = (function() {
	var $pkg = {}, $init, color;
	color = $packages["image/color"];
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = color.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.Black = new color.RGBA.ptr(0, 0, 0, 255);
		$pkg.Blue = new color.RGBA.ptr(0, 0, 255, 255);
		$pkg.Red = new color.RGBA.ptr(255, 0, 0, 255);
		$pkg.Silver = new color.RGBA.ptr(192, 192, 192, 255);
		$pkg.White = new color.RGBA.ptr(255, 255, 255, 255);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math/rand"] = (function() {
	var $pkg = {}, $init, nosync, math, Source, Source64, Rand, lockedSource, rngSource, arrayType, ptrType, ptrType$1, sliceType, ptrType$2, ptrType$3, funcType, sliceType$1, ptrType$5, ke, we, fe, kn, wn, fn, globalRand, rngCooked, absInt32, NewSource, New, read, Intn, seedrand;
	nosync = $packages["github.com/gopherjs/gopherjs/nosync"];
	math = $packages["math"];
	Source = $pkg.Source = $newType(8, $kindInterface, "rand.Source", true, "math/rand", true, null);
	Source64 = $pkg.Source64 = $newType(8, $kindInterface, "rand.Source64", true, "math/rand", true, null);
	Rand = $pkg.Rand = $newType(0, $kindStruct, "rand.Rand", true, "math/rand", true, function(src_, s64_, readVal_, readPos_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.src = $ifaceNil;
			this.s64 = $ifaceNil;
			this.readVal = new $Int64(0, 0);
			this.readPos = 0;
			return;
		}
		this.src = src_;
		this.s64 = s64_;
		this.readVal = readVal_;
		this.readPos = readPos_;
	});
	lockedSource = $pkg.lockedSource = $newType(0, $kindStruct, "rand.lockedSource", true, "math/rand", false, function(lk_, src_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.lk = new nosync.Mutex.ptr(false);
			this.src = $ifaceNil;
			return;
		}
		this.lk = lk_;
		this.src = src_;
	});
	rngSource = $pkg.rngSource = $newType(0, $kindStruct, "rand.rngSource", true, "math/rand", false, function(tap_, feed_, vec_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.tap = 0;
			this.feed = 0;
			this.vec = arrayType.zero();
			return;
		}
		this.tap = tap_;
		this.feed = feed_;
		this.vec = vec_;
	});
	arrayType = $arrayType($Int64, 607);
	ptrType = $ptrType(lockedSource);
	ptrType$1 = $ptrType($Int8);
	sliceType = $sliceType($Int);
	ptrType$2 = $ptrType($Int64);
	ptrType$3 = $ptrType(Rand);
	funcType = $funcType([$Int, $Int], [], false);
	sliceType$1 = $sliceType($Uint8);
	ptrType$5 = $ptrType(rngSource);
	Rand.ptr.prototype.ExpFloat64 = function() {
		var _r, _r$1, _r$2, _r$3, i, j, r, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; i = $f.i; j = $f.j; r = $f.r; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* while (true) { */ case 1:
			_r = r.Uint32(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			j = _r;
			i = (j & 255) >>> 0;
			x = (j) * (((i < 0 || i >= we.length) ? ($throwRuntimeError("index out of range"), undefined) : we[i]));
			if (j < ((i < 0 || i >= ke.length) ? ($throwRuntimeError("index out of range"), undefined) : ke[i])) {
				$s = -1; return x;
			}
			/* */ if (i === 0) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (i === 0) { */ case 4:
				_r$1 = r.Float64(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$2 = math.Log(_r$1); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				$s = -1; return 7.69711747013105 - _r$2;
			/* } */ case 5:
			_r$3 = r.Float64(); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			/* */ if ($fround(((i < 0 || i >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[i]) + $fround(($fround(_r$3)) * ($fround((x$1 = i - 1 >>> 0, ((x$1 < 0 || x$1 >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[x$1])) - ((i < 0 || i >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[i]))))) < ($fround(math.Exp(-x)))) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if ($fround(((i < 0 || i >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[i]) + $fround(($fround(_r$3)) * ($fround((x$1 = i - 1 >>> 0, ((x$1 < 0 || x$1 >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[x$1])) - ((i < 0 || i >= fe.length) ? ($throwRuntimeError("index out of range"), undefined) : fe[i]))))) < ($fround(math.Exp(-x)))) { */ case 8:
				$s = -1; return x;
			/* } */ case 9:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.ExpFloat64 }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.i = i; $f.j = j; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.ExpFloat64 = function() { return this.$val.ExpFloat64(); };
	absInt32 = function(i) {
		var i;
		if (i < 0) {
			return ((-i >>> 0));
		}
		return ((i >>> 0));
	};
	Rand.ptr.prototype.NormFloat64 = function() {
		var _r, _r$1, _r$2, _r$3, _r$4, _r$5, i, j, r, x, x$1, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; i = $f.i; j = $f.j; r = $f.r; x = $f.x; x$1 = $f.x$1; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* while (true) { */ case 1:
			_r = r.Uint32(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			j = ((_r >> 0));
			i = j & 127;
			x = (j) * (((i < 0 || i >= wn.length) ? ($throwRuntimeError("index out of range"), undefined) : wn[i]));
			if (absInt32(j) < ((i < 0 || i >= kn.length) ? ($throwRuntimeError("index out of range"), undefined) : kn[i])) {
				$s = -1; return x;
			}
			/* */ if (i === 0) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (i === 0) { */ case 4:
				/* while (true) { */ case 6:
					_r$1 = r.Float64(); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_r$2 = math.Log(_r$1); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					x = -_r$2 * 0.29047645161474317;
					_r$3 = r.Float64(); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					_r$4 = math.Log(_r$3); /* */ $s = 11; case 11: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					y = -_r$4;
					if (y + y >= x * x) {
						/* break; */ $s = 7; continue;
					}
				/* } */ $s = 6; continue; case 7:
				if (j > 0) {
					$s = -1; return 3.442619855899 + x;
				}
				$s = -1; return -3.442619855899 - x;
			/* } */ case 5:
			_r$5 = r.Float64(); /* */ $s = 14; case 14: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
			/* */ if ($fround(((i < 0 || i >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[i]) + $fround(($fround(_r$5)) * ($fround((x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[x$1])) - ((i < 0 || i >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[i]))))) < ($fround(math.Exp(-0.5 * x * x)))) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if ($fround(((i < 0 || i >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[i]) + $fround(($fround(_r$5)) * ($fround((x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[x$1])) - ((i < 0 || i >= fn.length) ? ($throwRuntimeError("index out of range"), undefined) : fn[i]))))) < ($fround(math.Exp(-0.5 * x * x)))) { */ case 12:
				$s = -1; return x;
			/* } */ case 13:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.NormFloat64 }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f.i = i; $f.j = j; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.NormFloat64 = function() { return this.$val.NormFloat64(); };
	NewSource = function(seed) {
		var rng, seed;
		rng = new rngSource.ptr(0, 0, arrayType.zero());
		rng.Seed(seed);
		return rng;
	};
	$pkg.NewSource = NewSource;
	New = function(src) {
		var _tuple, s64, src;
		_tuple = $assertType(src, Source64, true);
		s64 = _tuple[0];
		return new Rand.ptr(src, s64, new $Int64(0, 0), 0);
	};
	$pkg.New = New;
	Rand.ptr.prototype.Seed = function(seed) {
		var _tuple, lk, ok, r, seed, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; lk = $f.lk; ok = $f.ok; r = $f.r; seed = $f.seed; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_tuple = $assertType(r.src, ptrType, true);
		lk = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			$r = lk.seedPos(seed, (r.$ptr_readPos || (r.$ptr_readPos = new ptrType$1(function() { return this.$target.readPos; }, function($v) { this.$target.readPos = $v; }, r)))); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return;
		/* } */ case 2:
		$r = r.src.Seed(seed); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		r.readPos = 0;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Seed }; } $f._tuple = _tuple; $f.lk = lk; $f.ok = ok; $f.r = r; $f.seed = seed; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Seed = function(seed) { return this.$val.Seed(seed); };
	Rand.ptr.prototype.Int63 = function() {
		var _r, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.src.Int63(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Int63 }; } $f._r = _r; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Int63 = function() { return this.$val.Int63(); };
	Rand.ptr.prototype.Uint32 = function() {
		var _r, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.Int63(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (($shiftRightInt64(_r, 31).$low >>> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Uint32 }; } $f._r = _r; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Uint32 = function() { return this.$val.Uint32(); };
	Rand.ptr.prototype.Uint64 = function() {
		var _r, _r$1, _r$2, r, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; r = $f.r; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (!($interfaceIsEqual(r.s64, $ifaceNil))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!($interfaceIsEqual(r.s64, $ifaceNil))) { */ case 1:
			_r = r.s64.Uint64(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		_r$1 = r.Int63(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_r$2 = r.Int63(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return (x = $shiftRightUint64(((x$1 = _r$1, new $Uint64(x$1.$high, x$1.$low))), 31), x$2 = $shiftLeft64(((x$3 = _r$2, new $Uint64(x$3.$high, x$3.$low))), 32), new $Uint64(x.$high | x$2.$high, (x.$low | x$2.$low) >>> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Uint64 }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.r = r; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Uint64 = function() { return this.$val.Uint64(); };
	Rand.ptr.prototype.Int31 = function() {
		var _r, r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.Int63(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return (((x = $shiftRightInt64(_r, 32), x.$low + ((x.$high >> 31) * 4294967296)) >> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Int31 }; } $f._r = _r; $f.r = r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Int31 = function() { return this.$val.Int31(); };
	Rand.ptr.prototype.Int = function() {
		var _r, r, u, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.Int63(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		u = ((_r.$low >>> 0));
		$s = -1; return ((((u << 1 >>> 0) >>> 1 >>> 0) >> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Int }; } $f._r = _r; $f.r = r; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Int = function() { return this.$val.Int(); };
	Rand.ptr.prototype.Int63n = function(n) {
		var _r, _r$1, _r$2, max, n, r, v, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; max = $f.max; n = $f.n; r = $f.r; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if ((n.$high < 0 || (n.$high === 0 && n.$low <= 0))) {
			$panic(new $String("invalid argument to Int63n"));
		}
		/* */ if ((x = (x$1 = new $Int64(n.$high - 0, n.$low - 1), new $Int64(n.$high & x$1.$high, (n.$low & x$1.$low) >>> 0)), (x.$high === 0 && x.$low === 0))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((x = (x$1 = new $Int64(n.$high - 0, n.$low - 1), new $Int64(n.$high & x$1.$high, (n.$low & x$1.$low) >>> 0)), (x.$high === 0 && x.$low === 0))) { */ case 1:
			_r = r.Int63(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return (x$2 = _r, x$3 = new $Int64(n.$high - 0, n.$low - 1), new $Int64(x$2.$high & x$3.$high, (x$2.$low & x$3.$low) >>> 0));
		/* } */ case 2:
		max = ((x$4 = (x$5 = $div64(new $Uint64(2147483648, 0), (new $Uint64(n.$high, n.$low)), true), new $Uint64(2147483647 - x$5.$high, 4294967295 - x$5.$low)), new $Int64(x$4.$high, x$4.$low)));
		_r$1 = r.Int63(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		v = _r$1;
		/* while (true) { */ case 5:
			/* if (!((v.$high > max.$high || (v.$high === max.$high && v.$low > max.$low)))) { break; } */ if(!((v.$high > max.$high || (v.$high === max.$high && v.$low > max.$low)))) { $s = 6; continue; }
			_r$2 = r.Int63(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			v = _r$2;
		/* } */ $s = 5; continue; case 6:
		$s = -1; return $div64(v, n, true);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Int63n }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.max = max; $f.n = n; $f.r = r; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Int63n = function(n) { return this.$val.Int63n(n); };
	Rand.ptr.prototype.Int31n = function(n) {
		var _r, _r$1, _r$2, _r$3, _r$4, max, n, r, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; max = $f.max; n = $f.n; r = $f.r; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (n <= 0) {
			$panic(new $String("invalid argument to Int31n"));
		}
		/* */ if ((n & ((n - 1 >> 0))) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((n & ((n - 1 >> 0))) === 0) { */ case 1:
			_r = r.Int31(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r & ((n - 1 >> 0));
		/* } */ case 2:
		max = (((2147483647 - (_r$1 = 2147483648 % ((n >>> 0)), _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) >>> 0) >> 0));
		_r$2 = r.Int31(); /* */ $s = 4; case 4: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		v = _r$2;
		/* while (true) { */ case 5:
			/* if (!(v > max)) { break; } */ if(!(v > max)) { $s = 6; continue; }
			_r$3 = r.Int31(); /* */ $s = 7; case 7: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			v = _r$3;
		/* } */ $s = 5; continue; case 6:
		$s = -1; return (_r$4 = v % n, _r$4 === _r$4 ? _r$4 : $throwRuntimeError("integer divide by zero"));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Int31n }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.max = max; $f.n = n; $f.r = r; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Int31n = function(n) { return this.$val.Int31n(n); };
	Rand.ptr.prototype.int31n = function(n) {
		var _r, _r$1, _r$2, low, n, prod, r, thresh, v, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; low = $f.low; n = $f.n; prod = $f.prod; r = $f.r; thresh = $f.thresh; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.Uint32(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		v = _r;
		prod = $mul64((new $Uint64(0, v)), (new $Uint64(0, n)));
		low = ((prod.$low >>> 0));
		/* */ if (low < ((n >>> 0))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (low < ((n >>> 0))) { */ case 2:
			thresh = (_r$1 = ((-n >>> 0)) % ((n >>> 0)), _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero"));
			/* while (true) { */ case 4:
				/* if (!(low < thresh)) { break; } */ if(!(low < thresh)) { $s = 5; continue; }
				_r$2 = r.Uint32(); /* */ $s = 6; case 6: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				v = _r$2;
				prod = $mul64((new $Uint64(0, v)), (new $Uint64(0, n)));
				low = ((prod.$low >>> 0));
			/* } */ $s = 4; continue; case 5:
		/* } */ case 3:
		$s = -1; return (($shiftRightUint64(prod, 32).$low >> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.int31n }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.low = low; $f.n = n; $f.prod = prod; $f.r = r; $f.thresh = thresh; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.int31n = function(n) { return this.$val.int31n(n); };
	Rand.ptr.prototype.Intn = function(n) {
		var _r, _r$1, n, r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; n = $f.n; r = $f.r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (n <= 0) {
			$panic(new $String("invalid argument to Intn"));
		}
		/* */ if (n <= 2147483647) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (n <= 2147483647) { */ case 1:
			_r = r.Int31n(((n >> 0))); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return ((_r >> 0));
		/* } */ case 2:
		_r$1 = r.Int63n((new $Int64(0, n))); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return (((x = _r$1, x.$low + ((x.$high >> 31) * 4294967296)) >> 0));
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Intn }; } $f._r = _r; $f._r$1 = _r$1; $f.n = n; $f.r = r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Intn = function(n) { return this.$val.Intn(n); };
	Rand.ptr.prototype.Float64 = function() {
		var _r, f, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* again: */ case 1:
		_r = r.Int63(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		f = ($flatten64(_r)) / 9.223372036854776e+18;
		/* */ if (f === 1) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (f === 1) { */ case 3:
			/* goto again */ $s = 1; continue;
		/* } */ case 4:
		$s = -1; return f;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Float64 }; } $f._r = _r; $f.f = f; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Float64 = function() { return this.$val.Float64(); };
	Rand.ptr.prototype.Float32 = function() {
		var _r, f, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* again: */ case 1:
		_r = r.Float64(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		f = ($fround(_r));
		/* */ if (f === 1) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (f === 1) { */ case 3:
			/* goto again */ $s = 1; continue;
		/* } */ case 4:
		$s = -1; return f;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Float32 }; } $f._r = _r; $f.f = f; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Float32 = function() { return this.$val.Float32(); };
	Rand.ptr.prototype.Perm = function(n) {
		var _r, i, j, m, n, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; i = $f.i; j = $f.j; m = $f.m; n = $f.n; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		m = $makeSlice(sliceType, n);
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 2; continue; }
			_r = r.Intn(i + 1 >> 0); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			j = _r;
			((i < 0 || i >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + i] = ((j < 0 || j >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + j]));
			((j < 0 || j >= m.$length) ? ($throwRuntimeError("index out of range"), undefined) : m.$array[m.$offset + j] = i);
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return m;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Perm }; } $f._r = _r; $f.i = i; $f.j = j; $f.m = m; $f.n = n; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Perm = function(n) { return this.$val.Perm(n); };
	Rand.ptr.prototype.Shuffle = function(n, swap) {
		var _r, _r$1, i, j, j$1, n, r, swap, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; i = $f.i; j = $f.j; j$1 = $f.j$1; n = $f.n; r = $f.r; swap = $f.swap; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (n < 0) {
			$panic(new $String("invalid argument to Shuffle"));
		}
		i = n - 1 >> 0;
		/* while (true) { */ case 1:
			/* if (!(i > 2147483646)) { break; } */ if(!(i > 2147483646)) { $s = 2; continue; }
			_r = r.Int63n((new $Int64(0, (i + 1 >> 0)))); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			j = (((x = _r, x.$low + ((x.$high >> 31) * 4294967296)) >> 0));
			$r = swap(i, j); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i = i - (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		/* while (true) { */ case 5:
			/* if (!(i > 0)) { break; } */ if(!(i > 0)) { $s = 6; continue; }
			_r$1 = r.int31n((((i + 1 >> 0) >> 0))); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			j$1 = ((_r$1 >> 0));
			$r = swap(i, j$1); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			i = i - (1) >> 0;
		/* } */ $s = 5; continue; case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Shuffle }; } $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.j = j; $f.j$1 = j$1; $f.n = n; $f.r = r; $f.swap = swap; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Shuffle = function(n, swap) { return this.$val.Shuffle(n, swap); };
	Rand.ptr.prototype.Read = function(p) {
		var _r, _r$1, _tuple, _tuple$1, _tuple$2, err, lk, n, ok, p, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; err = $f.err; lk = $f.lk; n = $f.n; ok = $f.ok; p = $f.p; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		r = this;
		_tuple = $assertType(r.src, ptrType, true);
		lk = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			_r = lk.read(p, (r.$ptr_readVal || (r.$ptr_readVal = new ptrType$2(function() { return this.$target.readVal; }, function($v) { this.$target.readVal = $v; }, r))), (r.$ptr_readPos || (r.$ptr_readPos = new ptrType$1(function() { return this.$target.readPos; }, function($v) { this.$target.readPos = $v; }, r)))); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple$1 = _r;
			n = _tuple$1[0];
			err = _tuple$1[1];
			$s = -1; return [n, err];
		/* } */ case 2:
		_r$1 = read(p, $methodVal(r, "Int63"), (r.$ptr_readVal || (r.$ptr_readVal = new ptrType$2(function() { return this.$target.readVal; }, function($v) { this.$target.readVal = $v; }, r))), (r.$ptr_readPos || (r.$ptr_readPos = new ptrType$1(function() { return this.$target.readPos; }, function($v) { this.$target.readPos = $v; }, r)))); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$2 = _r$1;
		n = _tuple$2[0];
		err = _tuple$2[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Rand.ptr.prototype.Read }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.err = err; $f.lk = lk; $f.n = n; $f.ok = ok; $f.p = p; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Rand.prototype.Read = function(p) { return this.$val.Read(p); };
	read = function(p, int63, readVal, readPos) {
		var _r, err, int63, n, p, pos, readPos, readVal, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; int63 = $f.int63; n = $f.n; p = $f.p; pos = $f.pos; readPos = $f.readPos; readVal = $f.readVal; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		pos = readPos.$get();
		val = readVal.$get();
		n = 0;
		/* while (true) { */ case 1:
			/* if (!(n < p.$length)) { break; } */ if(!(n < p.$length)) { $s = 2; continue; }
			/* */ if (pos === 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (pos === 0) { */ case 3:
				_r = int63(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				val = _r;
				pos = 7;
			/* } */ case 4:
			((n < 0 || n >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + n] = ((val.$low << 24 >>> 24)));
			val = $shiftRightInt64(val, (8));
			pos = pos - (1) << 24 >> 24;
			n = n + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		readPos.$set(pos);
		readVal.$set(val);
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: read }; } $f._r = _r; $f.err = err; $f.int63 = int63; $f.n = n; $f.p = p; $f.pos = pos; $f.readPos = readPos; $f.readVal = readVal; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	Intn = function(n) {
		var _r, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = globalRand.Intn(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Intn }; } $f._r = _r; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Intn = Intn;
	lockedSource.ptr.prototype.Int63 = function() {
		var _r, n, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		r = this;
		r.lk.Lock();
		_r = r.src.Int63(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		n = _r;
		r.lk.Unlock();
		$s = -1; return n;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lockedSource.ptr.prototype.Int63 }; } $f._r = _r; $f.n = n; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	lockedSource.prototype.Int63 = function() { return this.$val.Int63(); };
	lockedSource.ptr.prototype.Uint64 = function() {
		var _r, n, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Uint64(0, 0);
		r = this;
		r.lk.Lock();
		_r = r.src.Uint64(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		n = _r;
		r.lk.Unlock();
		$s = -1; return n;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lockedSource.ptr.prototype.Uint64 }; } $f._r = _r; $f.n = n; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	lockedSource.prototype.Uint64 = function() { return this.$val.Uint64(); };
	lockedSource.ptr.prototype.Seed = function(seed) {
		var r, seed, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; r = $f.r; seed = $f.seed; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		r.lk.Lock();
		$r = r.src.Seed(seed); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		r.lk.Unlock();
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lockedSource.ptr.prototype.Seed }; } $f.r = r; $f.seed = seed; $f.$s = $s; $f.$r = $r; return $f;
	};
	lockedSource.prototype.Seed = function(seed) { return this.$val.Seed(seed); };
	lockedSource.ptr.prototype.seedPos = function(seed, readPos) {
		var r, readPos, seed, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; r = $f.r; readPos = $f.readPos; seed = $f.seed; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		r.lk.Lock();
		$r = r.src.Seed(seed); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		readPos.$set(0);
		r.lk.Unlock();
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lockedSource.ptr.prototype.seedPos }; } $f.r = r; $f.readPos = readPos; $f.seed = seed; $f.$s = $s; $f.$r = $r; return $f;
	};
	lockedSource.prototype.seedPos = function(seed, readPos) { return this.$val.seedPos(seed, readPos); };
	lockedSource.ptr.prototype.read = function(p, readVal, readPos) {
		var _r, _tuple, err, n, p, r, readPos, readVal, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; err = $f.err; n = $f.n; p = $f.p; r = $f.r; readPos = $f.readPos; readVal = $f.readVal; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		r = this;
		r.lk.Lock();
		_r = read(p, $methodVal(r.src, "Int63"), readVal, readPos); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		r.lk.Unlock();
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: lockedSource.ptr.prototype.read }; } $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.n = n; $f.p = p; $f.r = r; $f.readPos = readPos; $f.readVal = readVal; $f.$s = $s; $f.$r = $r; return $f;
	};
	lockedSource.prototype.read = function(p, readVal, readPos) { return this.$val.read(p, readVal, readPos); };
	seedrand = function(x) {
		var _q, _r, hi, lo, x;
		hi = (_q = x / 44488, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"));
		lo = (_r = x % 44488, _r === _r ? _r : $throwRuntimeError("integer divide by zero"));
		x = ($imul(48271, lo)) - ($imul(3399, hi)) >> 0;
		if (x < 0) {
			x = x + (2147483647) >> 0;
		}
		return x;
	};
	rngSource.ptr.prototype.Seed = function(seed) {
		var i, rng, seed, u, x, x$1, x$2, x$3, x$4, x$5;
		rng = this;
		rng.tap = 0;
		rng.feed = 334;
		seed = $div64(seed, new $Int64(0, 2147483647), true);
		if ((seed.$high < 0 || (seed.$high === 0 && seed.$low < 0))) {
			seed = (x = new $Int64(0, 2147483647), new $Int64(seed.$high + x.$high, seed.$low + x.$low));
		}
		if ((seed.$high === 0 && seed.$low === 0)) {
			seed = new $Int64(0, 89482311);
		}
		x$1 = (((seed.$low + ((seed.$high >> 31) * 4294967296)) >> 0));
		i = -20;
		while (true) {
			if (!(i < 607)) { break; }
			x$1 = seedrand(x$1);
			if (i >= 0) {
				u = new $Int64(0, 0);
				u = $shiftLeft64((new $Int64(0, x$1)), 40);
				x$1 = seedrand(x$1);
				u = (x$2 = $shiftLeft64((new $Int64(0, x$1)), 20), new $Int64(u.$high ^ x$2.$high, (u.$low ^ x$2.$low) >>> 0));
				x$1 = seedrand(x$1);
				u = (x$3 = (new $Int64(0, x$1)), new $Int64(u.$high ^ x$3.$high, (u.$low ^ x$3.$low) >>> 0));
				u = (x$4 = ((i < 0 || i >= rngCooked.length) ? ($throwRuntimeError("index out of range"), undefined) : rngCooked[i]), new $Int64(u.$high ^ x$4.$high, (u.$low ^ x$4.$low) >>> 0));
				(x$5 = rng.vec, ((i < 0 || i >= x$5.length) ? ($throwRuntimeError("index out of range"), undefined) : x$5[i] = u));
			}
			i = i + (1) >> 0;
		}
	};
	rngSource.prototype.Seed = function(seed) { return this.$val.Seed(seed); };
	rngSource.ptr.prototype.Int63 = function() {
		var rng, x, x$1;
		rng = this;
		return ((x = (x$1 = rng.Uint64(), new $Uint64(x$1.$high & 2147483647, (x$1.$low & 4294967295) >>> 0)), new $Int64(x.$high, x.$low)));
	};
	rngSource.prototype.Int63 = function() { return this.$val.Int63(); };
	rngSource.ptr.prototype.Uint64 = function() {
		var rng, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8;
		rng = this;
		rng.tap = rng.tap - (1) >> 0;
		if (rng.tap < 0) {
			rng.tap = rng.tap + (607) >> 0;
		}
		rng.feed = rng.feed - (1) >> 0;
		if (rng.feed < 0) {
			rng.feed = rng.feed + (607) >> 0;
		}
		x$6 = (x = (x$1 = rng.vec, x$2 = rng.feed, ((x$2 < 0 || x$2 >= x$1.length) ? ($throwRuntimeError("index out of range"), undefined) : x$1[x$2])), x$3 = (x$4 = rng.vec, x$5 = rng.tap, ((x$5 < 0 || x$5 >= x$4.length) ? ($throwRuntimeError("index out of range"), undefined) : x$4[x$5])), new $Int64(x.$high + x$3.$high, x.$low + x$3.$low));
		(x$7 = rng.vec, x$8 = rng.feed, ((x$8 < 0 || x$8 >= x$7.length) ? ($throwRuntimeError("index out of range"), undefined) : x$7[x$8] = x$6));
		return (new $Uint64(x$6.$high, x$6.$low));
	};
	rngSource.prototype.Uint64 = function() { return this.$val.Uint64(); };
	ptrType$3.methods = [{prop: "ExpFloat64", name: "ExpFloat64", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "NormFloat64", name: "NormFloat64", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Seed", name: "Seed", pkg: "", typ: $funcType([$Int64], [], false)}, {prop: "Int63", name: "Int63", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint32", name: "Uint32", pkg: "", typ: $funcType([], [$Uint32], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "Int31", name: "Int31", pkg: "", typ: $funcType([], [$Int32], false)}, {prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Int63n", name: "Int63n", pkg: "", typ: $funcType([$Int64], [$Int64], false)}, {prop: "Int31n", name: "Int31n", pkg: "", typ: $funcType([$Int32], [$Int32], false)}, {prop: "int31n", name: "int31n", pkg: "math/rand", typ: $funcType([$Int32], [$Int32], false)}, {prop: "Intn", name: "Intn", pkg: "", typ: $funcType([$Int], [$Int], false)}, {prop: "Float64", name: "Float64", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Float32", name: "Float32", pkg: "", typ: $funcType([], [$Float32], false)}, {prop: "Perm", name: "Perm", pkg: "", typ: $funcType([$Int], [sliceType], false)}, {prop: "Shuffle", name: "Shuffle", pkg: "", typ: $funcType([$Int, funcType], [], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType$1], [$Int, $error], false)}];
	ptrType.methods = [{prop: "Int63", name: "Int63", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "Seed", name: "Seed", pkg: "", typ: $funcType([$Int64], [], false)}, {prop: "seedPos", name: "seedPos", pkg: "math/rand", typ: $funcType([$Int64, ptrType$1], [], false)}, {prop: "read", name: "read", pkg: "math/rand", typ: $funcType([sliceType$1, ptrType$2, ptrType$1], [$Int, $error], false)}];
	ptrType$5.methods = [{prop: "Seed", name: "Seed", pkg: "", typ: $funcType([$Int64], [], false)}, {prop: "Int63", name: "Int63", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}];
	Source.init([{prop: "Int63", name: "Int63", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Seed", name: "Seed", pkg: "", typ: $funcType([$Int64], [], false)}]);
	Source64.init([{prop: "Int63", name: "Int63", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Seed", name: "Seed", pkg: "", typ: $funcType([$Int64], [], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}]);
	Rand.init("math/rand", [{prop: "src", name: "src", embedded: false, exported: false, typ: Source, tag: ""}, {prop: "s64", name: "s64", embedded: false, exported: false, typ: Source64, tag: ""}, {prop: "readVal", name: "readVal", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "readPos", name: "readPos", embedded: false, exported: false, typ: $Int8, tag: ""}]);
	lockedSource.init("math/rand", [{prop: "lk", name: "lk", embedded: false, exported: false, typ: nosync.Mutex, tag: ""}, {prop: "src", name: "src", embedded: false, exported: false, typ: Source64, tag: ""}]);
	rngSource.init("math/rand", [{prop: "tap", name: "tap", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "feed", name: "feed", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "vec", name: "vec", embedded: false, exported: false, typ: arrayType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = nosync.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		ke = $toNativeArray($kindUint32, [3801129273, 0, 2615860924, 3279400049, 3571300752, 3733536696, 3836274812, 3906990442, 3958562475, 3997804264, 4028649213, 4053523342, 4074002619, 4091154507, 4105727352, 4118261130, 4129155133, 4138710916, 4147160435, 4154685009, 4161428406, 4167506077, 4173011791, 4178022498, 4182601930, 4186803325, 4190671498, 4194244443, 4197554582, 4200629752, 4203493986, 4206168142, 4208670408, 4211016720, 4213221098, 4215295924, 4217252177, 4219099625, 4220846988, 4222502074, 4224071896, 4225562770, 4226980400, 4228329951, 4229616109, 4230843138, 4232014925, 4233135020, 4234206673, 4235232866, 4236216336, 4237159604, 4238064994, 4238934652, 4239770563, 4240574564, 4241348362, 4242093539, 4242811568, 4243503822, 4244171579, 4244816032, 4245438297, 4246039419, 4246620374, 4247182079, 4247725394, 4248251127, 4248760037, 4249252839, 4249730206, 4250192773, 4250641138, 4251075867, 4251497493, 4251906522, 4252303431, 4252688672, 4253062674, 4253425844, 4253778565, 4254121205, 4254454110, 4254777611, 4255092022, 4255397640, 4255694750, 4255983622, 4256264513, 4256537670, 4256803325, 4257061702, 4257313014, 4257557464, 4257795244, 4258026541, 4258251531, 4258470383, 4258683258, 4258890309, 4259091685, 4259287526, 4259477966, 4259663135, 4259843154, 4260018142, 4260188212, 4260353470, 4260514019, 4260669958, 4260821380, 4260968374, 4261111028, 4261249421, 4261383632, 4261513736, 4261639802, 4261761900, 4261880092, 4261994441, 4262105003, 4262211835, 4262314988, 4262414513, 4262510454, 4262602857, 4262691764, 4262777212, 4262859239, 4262937878, 4263013162, 4263085118, 4263153776, 4263219158, 4263281289, 4263340187, 4263395872, 4263448358, 4263497660, 4263543789, 4263586755, 4263626565, 4263663224, 4263696735, 4263727099, 4263754314, 4263778377, 4263799282, 4263817020, 4263831582, 4263842955, 4263851124, 4263856071, 4263857776, 4263856218, 4263851370, 4263843206, 4263831695, 4263816804, 4263798497, 4263776735, 4263751476, 4263722676, 4263690284, 4263654251, 4263614520, 4263571032, 4263523724, 4263472530, 4263417377, 4263358192, 4263294892, 4263227394, 4263155608, 4263079437, 4262998781, 4262913534, 4262823581, 4262728804, 4262629075, 4262524261, 4262414220, 4262298801, 4262177846, 4262051187, 4261918645, 4261780032, 4261635148, 4261483780, 4261325704, 4261160681, 4260988457, 4260808763, 4260621313, 4260425802, 4260221905, 4260009277, 4259787550, 4259556329, 4259315195, 4259063697, 4258801357, 4258527656, 4258242044, 4257943926, 4257632664, 4257307571, 4256967906, 4256612870, 4256241598, 4255853155, 4255446525, 4255020608, 4254574202, 4254106002, 4253614578, 4253098370, 4252555662, 4251984571, 4251383021, 4250748722, 4250079132, 4249371435, 4248622490, 4247828790, 4246986404, 4246090910, 4245137315, 4244119963, 4243032411, 4241867296, 4240616155, 4239269214, 4237815118, 4236240596, 4234530035, 4232664930, 4230623176, 4228378137, 4225897409, 4223141146, 4220059768, 4216590757, 4212654085, 4208145538, 4202926710, 4196809522, 4189531420, 4180713890, 4169789475, 4155865042, 4137444620, 4111806704, 4073393724, 4008685917, 3873074895]);
		we = $toNativeArray($kindFloat32, [2.0249555365836613e-09, 1.4866739783681027e-11, 2.4409616689036184e-11, 3.1968806074589295e-11, 3.844677007314168e-11, 4.42282044321729e-11, 4.951644302919611e-11, 5.443358958023836e-11, 5.905943789574764e-11, 6.34494193296753e-11, 6.764381416113352e-11, 7.167294535648239e-11, 7.556032188826833e-11, 7.932458162551725e-11, 8.298078890689453e-11, 8.654132271912474e-11, 9.001651507523079e-11, 9.341507428706208e-11, 9.674443190998971e-11, 1.0001099254308699e-10, 1.0322031424037093e-10, 1.0637725422757427e-10, 1.0948611461891744e-10, 1.1255067711157807e-10, 1.1557434870246297e-10, 1.1856014781042035e-10, 1.2151082917633005e-10, 1.2442885610752796e-10, 1.2731647680563896e-10, 1.3017574518325858e-10, 1.330085347417409e-10, 1.3581656632677408e-10, 1.386014220061682e-10, 1.413645728254309e-10, 1.4410737880776736e-10, 1.4683107507629245e-10, 1.4953686899854546e-10, 1.522258291641876e-10, 1.5489899640730442e-10, 1.575573282952547e-10, 1.6020171300645814e-10, 1.628330109637588e-10, 1.6545202707884954e-10, 1.68059510752272e-10, 1.7065616975120435e-10, 1.73242697965037e-10, 1.758197337720091e-10, 1.783878739169964e-10, 1.8094774290045024e-10, 1.834998542005195e-10, 1.8604476292871652e-10, 1.8858298256319017e-10, 1.9111498494872592e-10, 1.9364125580789704e-10, 1.9616222535212557e-10, 1.9867835154840918e-10, 2.011900368525943e-10, 2.0369768372052732e-10, 2.062016807302669e-10, 2.0870240258208383e-10, 2.1120022397624894e-10, 2.136955057352452e-10, 2.1618855317040442e-10, 2.1867974098199738e-10, 2.2116936060356807e-10, 2.2365774510202385e-10, 2.2614519978869652e-10, 2.2863201609713002e-10, 2.3111849933865614e-10, 2.3360494094681883e-10, 2.3609159072179864e-10, 2.3857874009713953e-10, 2.4106666662859766e-10, 2.4355562011635357e-10, 2.460458781161634e-10, 2.485376904282077e-10, 2.5103127909709144e-10, 2.5352694943414633e-10, 2.560248957284017e-10, 2.585253955356137e-10, 2.610286709003873e-10, 2.6353494386732734e-10, 2.6604446423661443e-10, 2.6855745405285347e-10, 2.71074163116225e-10, 2.7359478571575835e-10, 2.7611959940720965e-10, 2.786487707240326e-10, 2.8118254946640775e-10, 2.8372118543451563e-10, 2.8626484516180994e-10, 2.8881380620404684e-10, 2.9136826285025563e-10, 2.9392840938946563e-10, 2.96494523377433e-10, 2.990667713476114e-10, 3.016454031001814e-10, 3.042306406797479e-10, 3.068226783753403e-10, 3.09421765987139e-10, 3.12028125559749e-10, 3.1464195138219964e-10, 3.17263521010247e-10, 3.1989300097734485e-10, 3.225306410836737e-10, 3.2517669112941405e-10, 3.2783134540359526e-10, 3.3049485370639786e-10, 3.3316743808242677e-10, 3.3584937608743815e-10, 3.385408342548857e-10, 3.4124211789610115e-10, 3.4395342130011386e-10, 3.4667499426710435e-10, 3.494071143528288e-10, 3.521500313574677e-10, 3.54903967325626e-10, 3.576691720574843e-10, 3.6044595086437425e-10, 3.632345535464765e-10, 3.660352021483959e-10, 3.688482297370399e-10, 3.716738583570134e-10, 3.7451239331964814e-10, 3.773641121807003e-10, 3.802292924959261e-10, 3.831082673322328e-10, 3.8600128648980103e-10, 3.8890865527996255e-10, 3.9183070676962473e-10, 3.9476774627011935e-10, 3.977200790927782e-10, 4.006880383045086e-10, 4.0367195697221803e-10, 4.066721681628138e-10, 4.0968900494320337e-10, 4.127228558914453e-10, 4.15774054074447e-10, 4.188429603146915e-10, 4.2192993543466173e-10, 4.25035395767992e-10, 4.2815970213716525e-10, 4.313032986313914e-10, 4.3446651831757777e-10, 4.376498607960855e-10, 4.408536868893975e-10, 4.4407846844229937e-10, 4.4732464954400086e-10, 4.5059267428371186e-10, 4.538830145062178e-10, 4.5719619756745544e-10, 4.605326675566346e-10, 4.638929240741163e-10, 4.672775499869886e-10, 4.706869893844612e-10, 4.74121908400349e-10, 4.775827511238617e-10, 4.810701836888143e-10, 4.845848167178701e-10, 4.881271498113904e-10, 4.916979601254923e-10, 4.952977472605369e-10, 4.989272883726414e-10, 5.025872495956207e-10, 5.062783525744408e-10, 5.100013189540675e-10, 5.13756870379467e-10, 5.175458395179078e-10, 5.21369003525507e-10, 5.252272505806843e-10, 5.29121357839557e-10, 5.330522134805449e-10, 5.3702081670437e-10, 5.41028055689452e-10, 5.450749851476644e-10, 5.491624932574268e-10, 5.532918012640664e-10, 5.574638528571541e-10, 5.616799247931681e-10, 5.659410717839819e-10, 5.702485705860738e-10, 5.746036979559221e-10, 5.790077306500052e-10, 5.83462111958255e-10, 5.879682296594524e-10, 5.925275825546805e-10, 5.971417249561739e-10, 6.01812211176167e-10, 6.065408175714992e-10, 6.113292094767075e-10, 6.16179329782085e-10, 6.21092954844471e-10, 6.260721940876124e-10, 6.311191569352559e-10, 6.362359528111483e-10, 6.414249686947926e-10, 6.466885360545405e-10, 6.520292639144998e-10, 6.574497612987784e-10, 6.629528592760892e-10, 6.685415554485985e-10, 6.742187919073217e-10, 6.799880103436351e-10, 6.858525969377638e-10, 6.918161599145378e-10, 6.978825850545434e-10, 7.040559801829716e-10, 7.103406751696184e-10, 7.167412219288849e-10, 7.232625609532306e-10, 7.2990985477972e-10, 7.366885990123251e-10, 7.436047333442275e-10, 7.506645305355164e-10, 7.57874762946642e-10, 7.652426470272644e-10, 7.727759543385559e-10, 7.804830115532013e-10, 7.883728114777e-10, 7.964550685635174e-10, 8.047402189070851e-10, 8.132396422944055e-10, 8.219657177122031e-10, 8.309318788590758e-10, 8.401527806789488e-10, 8.496445214056791e-10, 8.594246980742071e-10, 8.695127395874636e-10, 8.799300732498239e-10, 8.90700457834015e-10, 9.01850316648023e-10, 9.134091816243028e-10, 9.254100818978372e-10, 9.37890431984556e-10, 9.508922538259412e-10, 9.64463842123564e-10, 9.78660263939446e-10, 9.935448019859905e-10, 1.0091912860943353e-09, 1.0256859805934937e-09, 1.0431305819125214e-09, 1.0616465484503124e-09, 1.0813799855569073e-09, 1.1025096391392708e-09, 1.1252564435793033e-09, 1.149898620766976e-09, 1.176793218427008e-09, 1.2064089727203964e-09, 1.2393785997488749e-09, 1.2765849488616254e-09, 1.319313880365769e-09, 1.36954347862428e-09, 1.4305497897382224e-09, 1.5083649884672923e-09, 1.6160853766322703e-09, 1.7921247819074893e-09]);
		fe = $toNativeArray($kindFloat32, [1, 0.9381436705589294, 0.900469958782196, 0.8717043399810791, 0.847785472869873, 0.8269932866096497, 0.8084216713905334, 0.7915276288986206, 0.7759568691253662, 0.7614634037017822, 0.7478685975074768, 0.7350381016731262, 0.7228676676750183, 0.7112747430801392, 0.7001926302909851, 0.6895664930343628, 0.6793505549430847, 0.669506311416626, 0.6600008606910706, 0.6508058309555054, 0.6418967247009277, 0.633251965045929, 0.62485271692276, 0.6166821718215942, 0.608725368976593, 0.6009689569473267, 0.5934008955955505, 0.5860103368759155, 0.5787873864173889, 0.5717230439186096, 0.5648092031478882, 0.5580382943153381, 0.5514034032821655, 0.5448982119560242, 0.5385168790817261, 0.5322538614273071, 0.526104211807251, 0.5200631618499756, 0.5141264200210571, 0.5082897543907166, 0.5025495290756226, 0.4969019889831543, 0.4913438558578491, 0.4858720004558563, 0.48048335313796997, 0.4751752018928528, 0.4699448347091675, 0.4647897481918335, 0.4597076177597046, 0.4546961486339569, 0.4497532546520233, 0.44487687945365906, 0.4400651156902313, 0.4353161156177521, 0.4306281507015228, 0.42599955201148987, 0.42142874002456665, 0.4169141948223114, 0.4124544560909271, 0.40804818272590637, 0.4036940038204193, 0.39939069747924805, 0.3951369822025299, 0.39093172550201416, 0.38677382469177246, 0.38266217708587646, 0.378595769405365, 0.37457355856895447, 0.37059465050697327, 0.366658091545105, 0.362762987613678, 0.358908474445343, 0.35509374737739563, 0.35131800174713135, 0.3475804924964905, 0.34388044476509094, 0.34021714329719543, 0.33658990263938904, 0.3329980671405792, 0.3294409513473511, 0.32591795921325684, 0.32242849469184875, 0.3189719021320343, 0.3155476748943329, 0.31215524673461914, 0.3087940812110901, 0.30546361207962036, 0.30216339230537415, 0.29889291524887085, 0.29565170407295227, 0.2924392819404602, 0.2892552316188812, 0.28609907627105713, 0.2829704284667969, 0.27986884117126465, 0.2767939269542694, 0.2737452983856201, 0.2707225978374481, 0.26772540807724, 0.26475343108177185, 0.2618062496185303, 0.258883535861969, 0.2559850215911865, 0.25311028957366943, 0.25025907158851624, 0.24743106961250305, 0.2446259707212448, 0.24184346199035645, 0.23908329010009766, 0.23634515702724457, 0.2336287796497345, 0.23093391954898834, 0.22826029360294342, 0.22560766339302063, 0.22297576069831848, 0.22036437690258026, 0.21777324378490448, 0.21520215272903442, 0.212650865316391, 0.21011915802955627, 0.20760682225227356, 0.20511364936828613, 0.20263944566249847, 0.20018397271633148, 0.19774706661701202, 0.1953285187482834, 0.19292815029621124, 0.19054576754570007, 0.18818120658397675, 0.18583425879478455, 0.18350479006767273, 0.18119260668754578, 0.17889754474163055, 0.17661945521831512, 0.17435817420482635, 0.1721135377883911, 0.16988539695739746, 0.16767361760139465, 0.16547803580760956, 0.16329853236675262, 0.16113494336605072, 0.1589871346950531, 0.15685498714447021, 0.15473836660385132, 0.15263713896274567, 0.1505511850118637, 0.1484803706407547, 0.14642459154129028, 0.1443837285041809, 0.14235764741897583, 0.1403462439775467, 0.13834942877292633, 0.136367067694664, 0.13439907133579254, 0.1324453204870224, 0.1305057406425476, 0.12858019769191742, 0.12666863203048706, 0.12477091699838638, 0.12288697808980942, 0.1210167184472084, 0.11916005611419678, 0.11731690168380737, 0.11548716574907303, 0.11367076635360718, 0.11186762899160385, 0.11007767915725708, 0.1083008274435997, 0.10653700679540634, 0.10478614270687103, 0.1030481606721878, 0.10132300108671188, 0.0996105819940567, 0.09791085124015808, 0.09622374176979065, 0.09454918652772903, 0.09288713335990906, 0.09123751521110535, 0.08960027992725372, 0.08797537535429001, 0.08636274188756943, 0.0847623273730278, 0.08317409455776215, 0.08159798383712769, 0.08003395050764084, 0.07848194986581802, 0.07694194465875626, 0.07541389018297195, 0.07389774918556213, 0.07239348441362381, 0.070901058614254, 0.06942043453454971, 0.06795158982276917, 0.06649449467658997, 0.06504911929368973, 0.06361543387174606, 0.06219341605901718, 0.06078304722905159, 0.0593843050301075, 0.05799717456102371, 0.05662164092063904, 0.05525768920779228, 0.05390531197190285, 0.05256449431180954, 0.05123523622751236, 0.04991753399372101, 0.04861138388514519, 0.047316793352365494, 0.04603376239538193, 0.044762298464775085, 0.04350241273641586, 0.04225412383675575, 0.04101744294166565, 0.039792392402887344, 0.03857899457216263, 0.03737728297710419, 0.03618728369474411, 0.03500903770327568, 0.03384258225560188, 0.0326879620552063, 0.031545232981443405, 0.030414443463087082, 0.0292956605553627, 0.028188949450850487, 0.027094384655356407, 0.02601204626262188, 0.024942025542259216, 0.023884421214461327, 0.022839335724711418, 0.021806888282299042, 0.020787203684449196, 0.019780423492193222, 0.018786700442433357, 0.017806200310587883, 0.016839107498526573, 0.015885621309280396, 0.014945968054234982, 0.01402039173990488, 0.013109165243804455, 0.012212592177093029, 0.011331013403832912, 0.010464809834957123, 0.009614413604140282, 0.008780314587056637, 0.007963077165186405, 0.007163353264331818, 0.0063819061033427715, 0.005619642324745655, 0.004877655766904354, 0.004157294984906912, 0.003460264764726162, 0.0027887988835573196, 0.0021459676790982485, 0.001536299823783338, 0.0009672692976891994, 0.0004541343660093844]);
		kn = $toNativeArray($kindUint32, [1991057938, 0, 1611602771, 1826899878, 1918584482, 1969227037, 2001281515, 2023368125, 2039498179, 2051788381, 2061460127, 2069267110, 2075699398, 2081089314, 2085670119, 2089610331, 2093034710, 2096037586, 2098691595, 2101053571, 2103168620, 2105072996, 2106796166, 2108362327, 2109791536, 2111100552, 2112303493, 2113412330, 2114437283, 2115387130, 2116269447, 2117090813, 2117856962, 2118572919, 2119243101, 2119871411, 2120461303, 2121015852, 2121537798, 2122029592, 2122493434, 2122931299, 2123344971, 2123736059, 2124106020, 2124456175, 2124787725, 2125101763, 2125399283, 2125681194, 2125948325, 2126201433, 2126441213, 2126668298, 2126883268, 2127086657, 2127278949, 2127460589, 2127631985, 2127793506, 2127945490, 2128088244, 2128222044, 2128347141, 2128463758, 2128572095, 2128672327, 2128764606, 2128849065, 2128925811, 2128994934, 2129056501, 2129110560, 2129157136, 2129196237, 2129227847, 2129251929, 2129268426, 2129277255, 2129278312, 2129271467, 2129256561, 2129233410, 2129201800, 2129161480, 2129112170, 2129053545, 2128985244, 2128906855, 2128817916, 2128717911, 2128606255, 2128482298, 2128345305, 2128194452, 2128028813, 2127847342, 2127648860, 2127432031, 2127195339, 2126937058, 2126655214, 2126347546, 2126011445, 2125643893, 2125241376, 2124799783, 2124314271, 2123779094, 2123187386, 2122530867, 2121799464, 2120980787, 2120059418, 2119015917, 2117825402, 2116455471, 2114863093, 2112989789, 2110753906, 2108037662, 2104664315, 2100355223, 2094642347, 2086670106, 2074676188, 2054300022, 2010539237]);
		wn = $toNativeArray($kindFloat32, [1.7290404663583558e-09, 1.2680928529462676e-10, 1.689751810696194e-10, 1.9862687883343e-10, 2.223243117382978e-10, 2.4244936613904144e-10, 2.601613091623989e-10, 2.761198769629658e-10, 2.9073962681813725e-10, 3.042996965518796e-10, 3.169979556627567e-10, 3.289802041894774e-10, 3.4035738116777736e-10, 3.5121602848242617e-10, 3.61625090983253e-10, 3.7164057942185025e-10, 3.813085680537398e-10, 3.906675816178762e-10, 3.997501218933053e-10, 4.0858399996679395e-10, 4.1719308563337165e-10, 4.255982233303257e-10, 4.3381759295968436e-10, 4.4186720948857783e-10, 4.497613115272969e-10, 4.57512583373898e-10, 4.6513240481438345e-10, 4.726310454117311e-10, 4.800177477726209e-10, 4.873009773476156e-10, 4.944885056978876e-10, 5.015873272284921e-10, 5.086040477664255e-10, 5.155446070048697e-10, 5.224146670812502e-10, 5.292193350214802e-10, 5.359634958068682e-10, 5.426517013518151e-10, 5.492881705038144e-10, 5.558769555769061e-10, 5.624218868405251e-10, 5.689264614971989e-10, 5.75394121238304e-10, 5.818281967329142e-10, 5.882316855831959e-10, 5.946076964136182e-10, 6.009590047817426e-10, 6.072883862451306e-10, 6.135985053390414e-10, 6.19892026598734e-10, 6.261713370037114e-10, 6.324390455780815e-10, 6.386973727678935e-10, 6.449488165749528e-10, 6.511955974453087e-10, 6.574400468473129e-10, 6.636843297158634e-10, 6.699307220081607e-10, 6.761814441702541e-10, 6.824387166481927e-10, 6.887046488657234e-10, 6.949815167800466e-10, 7.012714853260604e-10, 7.075767749498141e-10, 7.13899661608508e-10, 7.202424212593428e-10, 7.266072743483676e-10, 7.329966078550854e-10, 7.394128087589991e-10, 7.458582640396116e-10, 7.523354716987285e-10, 7.588469852493063e-10, 7.653954137154528e-10, 7.719834771435785e-10, 7.786139510912449e-10, 7.852897221383159e-10, 7.920137878869582e-10, 7.987892014504894e-10, 8.056192379868321e-10, 8.125072836762115e-10, 8.194568912323064e-10, 8.264716688799467e-10, 8.3355555791087e-10, 8.407127216614185e-10, 8.479473234679347e-10, 8.552640262671218e-10, 8.626675485068347e-10, 8.701631637464402e-10, 8.777562010564566e-10, 8.854524335966119e-10, 8.932581896381464e-10, 9.011799639857543e-10, 9.092249730890956e-10, 9.174008219758889e-10, 9.25715837318819e-10, 9.341788453909317e-10, 9.42799727177146e-10, 9.515889187738935e-10, 9.605578554783278e-10, 9.697193048552322e-10, 9.790869226478094e-10, 9.886760299337993e-10, 9.985036131254788e-10, 1.008588212947359e-09, 1.0189509236369076e-09, 1.0296150598776421e-09, 1.040606933955246e-09, 1.0519566329136865e-09, 1.0636980185552147e-09, 1.0758701707302976e-09, 1.0885182755160372e-09, 1.101694735439196e-09, 1.115461056855338e-09, 1.1298901814171813e-09, 1.1450695946990663e-09, 1.1611052119775422e-09, 1.178127595480305e-09, 1.1962995039027646e-09, 1.2158286599728285e-09, 1.2369856250415978e-09, 1.2601323318151003e-09, 1.2857697129220469e-09, 1.3146201904845611e-09, 1.3477839955200466e-09, 1.3870635751089821e-09, 1.43574030442295e-09, 1.5008658760251592e-09, 1.6030947680434338e-09]);
		fn = $toNativeArray($kindFloat32, [1, 0.963599681854248, 0.9362826943397522, 0.9130436182022095, 0.8922816514968872, 0.8732430338859558, 0.8555005788803101, 0.8387836217880249, 0.8229072093963623, 0.8077383041381836, 0.7931770086288452, 0.7791460752487183, 0.7655841708183289, 0.7524415850639343, 0.7396772503852844, 0.7272568941116333, 0.7151514887809753, 0.7033361196517944, 0.6917891502380371, 0.6804918646812439, 0.6694276928901672, 0.6585819721221924, 0.6479418277740479, 0.6374954581260681, 0.6272324919700623, 0.6171433925628662, 0.6072195172309875, 0.5974531769752502, 0.5878370404243469, 0.5783646702766418, 0.5690299868583679, 0.5598273873329163, 0.550751805305481, 0.5417983531951904, 0.5329626798629761, 0.5242405533790588, 0.5156282186508179, 0.5071220397949219, 0.49871864914894104, 0.4904148280620575, 0.48220765590667725, 0.47409430146217346, 0.466072142124176, 0.45813870429992676, 0.45029163360595703, 0.44252872467041016, 0.4348478317260742, 0.42724698781967163, 0.41972434520721436, 0.41227802634239197, 0.40490642189979553, 0.39760786294937134, 0.3903807997703552, 0.3832238018512726, 0.3761354684829712, 0.3691144585609436, 0.36215949058532715, 0.3552693724632263, 0.3484429717063904, 0.3416791558265686, 0.33497685194015503, 0.32833510637283325, 0.3217529058456421, 0.3152293860912323, 0.30876362323760986, 0.3023548424243927, 0.2960021495819092, 0.2897048592567444, 0.28346219658851624, 0.2772735059261322, 0.271138072013855, 0.2650552988052368, 0.25902456045150757, 0.25304529070854187, 0.24711695313453674, 0.24123899638652802, 0.23541094362735748, 0.22963231801986694, 0.22390270233154297, 0.21822164952754974, 0.21258877217769623, 0.20700371265411377, 0.20146611332893372, 0.1959756463766098, 0.19053204357624054, 0.18513499200344086, 0.17978426814079285, 0.1744796335697174, 0.16922089457511902, 0.16400785744190216, 0.1588403731584549, 0.15371830761432648, 0.14864157140254974, 0.14361007511615753, 0.13862377405166626, 0.13368265330791473, 0.12878671288490295, 0.12393598258495331, 0.11913054436445236, 0.11437050998210907, 0.10965602099895477, 0.1049872562289238, 0.10036443918943405, 0.09578784555196762, 0.09125780314207077, 0.08677466958761215, 0.08233889937400818, 0.07795098423957825, 0.07361150532960892, 0.06932111829519272, 0.06508058309555054, 0.06089077144861221, 0.05675266310572624, 0.05266740173101425, 0.048636294901371, 0.044660862535238266, 0.040742866694927216, 0.03688438981771469, 0.03308788686990738, 0.029356317594647408, 0.025693291798233986, 0.02210330404341221, 0.018592102453112602, 0.015167297795414925, 0.011839478276669979, 0.0086244847625494, 0.005548994988203049, 0.0026696291752159595]);
		rngCooked = $toNativeArray($kindInt64, [new $Int64(-973649357, 3952672746), new $Int64(-1065661887, 3130416987), new $Int64(324977939, 3414273807), new $Int64(1241840476, 2806224363), new $Int64(-1477934308, 1997590414), new $Int64(2103305448, 2402795971), new $Int64(1663160183, 1140819369), new $Int64(1120601685, 1788868961), new $Int64(1848035537, 1089001426), new $Int64(1235702047, 873593504), new $Int64(1911387977, 581324885), new $Int64(-1654874170, 1609182556), new $Int64(1069394745, 1241596776), new $Int64(1895445337, 1771189259), new $Int64(-1374618802, 3467012610), new $Int64(-140526423, 2344407434), new $Int64(-1745367887, 782467244), new $Int64(26335124, 3404933915), new $Int64(1063924276, 618867887), new $Int64(-968700782, 520164395), new $Int64(-1591572833, 1341358184), new $Int64(-1515085039, 665794848), new $Int64(1527227641, 3183648150), new $Int64(1781176124, 696329606), new $Int64(1789146075, 4151988961), new $Int64(-2087444114, 998951326), new $Int64(-612324923, 1364957564), new $Int64(63173359, 4090230633), new $Int64(-1498029007, 4009697548), new $Int64(248009524, 2569622517), new $Int64(778703922, 3742421481), new $Int64(-1109106023, 1506914633), new $Int64(1738099768, 1983412561), new $Int64(236311649, 1436266083), new $Int64(-1111517500, 3922894967), new $Int64(-1336974714, 1792680179), new $Int64(563141142, 1188796351), new $Int64(1349617468, 405968250), new $Int64(1044074554, 433754187), new $Int64(870549669, 4073162024), new $Int64(-1094251604, 433121399), new $Int64(2451824, 4162580594), new $Int64(-137262572, 4132415622), new $Int64(-1536231048, 3033822028), new $Int64(2016407895, 824682382), new $Int64(2366218, 3583765414), new $Int64(-624604839, 535386927), new $Int64(1637219058, 2286693689), new $Int64(1453075389, 2968466525), new $Int64(193683513, 1351410206), new $Int64(-283806096, 1412813499), new $Int64(492736522, 4126267639), new $Int64(512765208, 2105529399), new $Int64(2132966268, 2413882233), new $Int64(947457634, 32226200), new $Int64(1149341356, 2032329073), new $Int64(106485445, 1356518208), new $Int64(-2067810156, 3430061722), new $Int64(-1484435135, 3820169661), new $Int64(-1665985194, 2981816134), new $Int64(1017155588, 4184371017), new $Int64(206574701, 2119206761), new $Int64(-852109057, 2472200560), new $Int64(-560457548, 2853524696), new $Int64(1307803389, 1681119904), new $Int64(-174986835, 95608918), new $Int64(392686347, 3690479145), new $Int64(-1205570926, 1397922290), new $Int64(-1159314025, 1516129515), new $Int64(-320178155, 1547420459), new $Int64(1311333971, 1470949486), new $Int64(-1953469798, 1336785672), new $Int64(-45086614, 4131677129), new $Int64(-1392278100, 4246329084), new $Int64(-1142500187, 3788585631), new $Int64(-66478285, 3080389532), new $Int64(-646438364, 2215402037), new $Int64(391002300, 1171593935), new $Int64(1408774047, 1423855166), new $Int64(-519177718, 2276716302), new $Int64(-368453140, 2068027241), new $Int64(1369359303, 3427553297), new $Int64(189241615, 3289637845), new $Int64(1057480830, 3486407650), new $Int64(-1512910664, 3071877822), new $Int64(1159653919, 3363620705), new $Int64(-934256930, 4159821533), new $Int64(-76621938, 1894661), new $Int64(-674493898, 1156868282), new $Int64(348271067, 776219088), new $Int64(-501428838, 2425634259), new $Int64(1716021749, 680510161), new $Int64(-574263456, 1310101429), new $Int64(1095885995, 2964454134), new $Int64(-325695512, 3467098407), new $Int64(1990672920, 2109628894), new $Int64(-2139648704, 1232604732), new $Int64(-1838070714, 3261916179), new $Int64(1699175360, 434597899), new $Int64(235436061, 1624796439), new $Int64(-1626402839, 3589632480), new $Int64(1198416575, 864579159), new $Int64(-1938748161, 1380889830), new $Int64(619206309, 2654509477), new $Int64(1419738251, 1468209306), new $Int64(-1744284772, 100794388), new $Int64(-1191421458, 2991674471), new $Int64(-208666741, 2224662036), new $Int64(-173659161, 977097250), new $Int64(1351320195, 726419512), new $Int64(-183459897, 1747974366), new $Int64(-753095183, 1556430604), new $Int64(-1049492215, 1080776742), new $Int64(-385846958, 280794874), new $Int64(117767733, 919835643), new $Int64(-967009426, 3434019658), new $Int64(-1951414480, 2461941785), new $Int64(133215641, 3615001066), new $Int64(417204809, 3103414427), new $Int64(790056561, 3380809712), new $Int64(-1267681408, 2724693469), new $Int64(547796833, 598827710), new $Int64(-1846559452, 3452273442), new $Int64(-75778224, 649274915), new $Int64(-801301329, 2585724112), new $Int64(-1510934263, 3165579553), new $Int64(1185578221, 2635894283), new $Int64(-52910178, 2053289721), new $Int64(985976581, 3169337108), new $Int64(1170569632, 144717764), new $Int64(1079216270, 1383666384), new $Int64(-124804942, 681540375), new $Int64(1375448925, 537050586), new $Int64(-1964768344, 315246468), new $Int64(226402871, 849323088), new $Int64(-885062465, 45543944), new $Int64(-946445250, 2319052083), new $Int64(-40708194, 3613090841), new $Int64(560472520, 2992171180), new $Int64(-381863169, 2068244785), new $Int64(917538188, 4239862634), new $Int64(-1369555809, 3892253031), new $Int64(720683925, 958186149), new $Int64(-423297785, 1877702262), new $Int64(1357886971, 837674867), new $Int64(1837048883, 1507589294), new $Int64(1905518400, 873336795), new $Int64(-1879761037, 2764496274), new $Int64(-1806480530, 4196182374), new $Int64(-1066765755, 550964545), new $Int64(818747069, 420611474), new $Int64(-1924830376, 204265180), new $Int64(1549974541, 1787046383), new $Int64(1215581865, 3102292318), new $Int64(418321538, 1552199393), new $Int64(1243493047, 980542004), new $Int64(267284263, 3293718720), new $Int64(1179528763, 3771917473), new $Int64(599484404, 2195808264), new $Int64(252818753, 3894702887), new $Int64(-1367475956, 2099949527), new $Int64(1424094358, 338442522), new $Int64(490737398, 637158004), new $Int64(-1727621530, 281976339), new $Int64(574970164, 3619802330), new $Int64(-431930823, 3084554784), new $Int64(-1264611183, 4129772886), new $Int64(-2104399043, 1680378557), new $Int64(-1621962591, 3339087776), new $Int64(1680500332, 4220317857), new $Int64(-1935828963, 2959322499), new $Int64(1675600481, 1488354890), new $Int64(-834863562, 3958162143), new $Int64(-1226511573, 2773705983), new $Int64(1876039582, 225908689), new $Int64(-1183735113, 908216283), new $Int64(-605696219, 3574646075), new $Int64(-1827723091, 1936937569), new $Int64(1519770881, 75492235), new $Int64(816689472, 1935193178), new $Int64(2142521206, 2018250883), new $Int64(455141620, 3943126022), new $Int64(-601399488, 3066544345), new $Int64(1932392669, 2793082663), new $Int64(-1239009361, 3297036421), new $Int64(1640597065, 2206987825), new $Int64(-553246738, 807894872), new $Int64(-1781325307, 766252117), new $Int64(2060649606, 3833114345), new $Int64(845619743, 1255067973), new $Int64(1201145605, 741697208), new $Int64(-1476242608, 2810093753), new $Int64(1109032642, 4229340371), new $Int64(1462188720, 1361684224), new $Int64(-1159399429, 1906263026), new $Int64(475781207, 3904421704), new $Int64(-623537128, 1769075545), new $Int64(1062308525, 2621599764), new $Int64(1279509432, 3431891480), new $Int64(-1742751146, 1871896503), new $Int64(128756421, 1412808876), new $Int64(1605404688, 952876175), new $Int64(-230443691, 1824438899), new $Int64(1662295856, 1005035476), new $Int64(-156574141, 527508597), new $Int64(1288873303, 3066806859), new $Int64(565995893, 3244940914), new $Int64(-889746188, 209092916), new $Int64(-247669406, 1242699167), new $Int64(-713830396, 456723774), new $Int64(1776978905, 1001252870), new $Int64(1468772157, 2026725874), new $Int64(857254202, 2137562569), new $Int64(765939740, 3183366709), new $Int64(1533887628, 2612072960), new $Int64(56977098, 1727148468), new $Int64(-1197583895, 3803658212), new $Int64(1883670356, 479946959), new $Int64(685713571, 1562982345), new $Int64(-1946242443, 1766109365), new $Int64(700596547, 3257093788), new $Int64(-184714929, 2365720207), new $Int64(93384808, 3742754173), new $Int64(-458385235, 2878193673), new $Int64(1096135042, 2174002182), new $Int64(-834260953, 3573511231), new $Int64(-754572527, 1760299077), new $Int64(-1375627191, 2260779833), new $Int64(-866019274, 1452805722), new $Int64(-1229671918, 2940011802), new $Int64(1890251082, 1886183802), new $Int64(893897673, 2514369088), new $Int64(1644345561, 3924317791), new $Int64(-1974867432, 500935732), new $Int64(1403501753, 676580929), new $Int64(-1565912283, 1184984890), new $Int64(-691968413, 1271474274), new $Int64(-1828754738, 3163791473), new $Int64(2051027584, 2842487377), new $Int64(1511537551, 2170968612), new $Int64(573262976, 3535856740), new $Int64(-2053227187, 1488599718), new $Int64(-1180531831, 3408913763), new $Int64(-2086531912, 2501050084), new $Int64(-875130448, 1639124157), new $Int64(-2009482504, 4088176393), new $Int64(1574896563, 3989947576), new $Int64(-165243708, 3414355209), new $Int64(-792329287, 2275136352), new $Int64(-2057774345, 2151835223), new $Int64(-931144933, 1654534827), new $Int64(-679921451, 377892833), new $Int64(-482716010, 660204544), new $Int64(85706799, 390828249), new $Int64(-1422172693, 3402783878), new $Int64(-1468634160, 3717936603), new $Int64(1113532086, 2211058823), new $Int64(1564224320, 2692150867), new $Int64(1952770442, 1928910388), new $Int64(788716862, 3931011137), new $Int64(1083670504, 1112701047), new $Int64(-68150572, 2452299106), new $Int64(-896164822, 2337204777), new $Int64(1774877857, 273889282), new $Int64(1798719843, 1462008793), new $Int64(2138834788, 1554494002), new $Int64(-1194967131, 182675323), new $Int64(-1598554764, 1882802136), new $Int64(589279648, 3700220025), new $Int64(381039426, 3083431543), new $Int64(-851859191, 3622207527), new $Int64(338126939, 432729309), new $Int64(-1667470126, 2391914317), new $Int64(-1849558151, 235747924), new $Int64(2120733629, 3088823825), new $Int64(-745079795, 2314658321), new $Int64(1165929723, 2957634338), new $Int64(501323675, 4117056981), new $Int64(1564699815, 1482500298), new $Int64(-740826490, 840489337), new $Int64(799522364, 3483178565), new $Int64(532129761, 2074004656), new $Int64(724246478, 3643392642), new $Int64(-665153481, 1583624461), new $Int64(-885822954, 287473085), new $Int64(1667835381, 3136843981), new $Int64(1138806821, 1266970974), new $Int64(135185781, 1998688839), new $Int64(392094735, 1492900209), new $Int64(1031326774, 1538112737), new $Int64(-2070568842, 2207265429), new $Int64(-1886797613, 963263315), new $Int64(1671145500, 2295892134), new $Int64(1068469660, 2002560897), new $Int64(-356250305, 1369254035), new $Int64(33436120, 3353312708), new $Int64(57507843, 947771099), new $Int64(-1945755145, 1747061399), new $Int64(1507240140, 2047354631), new $Int64(720000810, 4165367136), new $Int64(479265078, 3388864963), new $Int64(-952181250, 286492130), new $Int64(2045622690, 2795735007), new $Int64(-715730566, 3703961339), new $Int64(-148436487, 1797825479), new $Int64(1429039600, 1116589674), new $Int64(-1665420098, 2593309206), new $Int64(1329049334, 3404995677), new $Int64(-750579440, 3453462936), new $Int64(1014767077, 3016498634), new $Int64(75698599, 1650371545), new $Int64(1592007860, 212344364), new $Int64(1127766888, 3843932156), new $Int64(-748019856, 3573129983), new $Int64(-890581831, 665897820), new $Int64(1071492673, 1675628772), new $Int64(243225682, 2831752928), new $Int64(2120298836, 1486294219), new $Int64(-1954407413, 268782709), new $Int64(-1002123503, 4186179080), new $Int64(624342951, 1613720397), new $Int64(857179861, 2703686015), new $Int64(-911618704, 2205342611), new $Int64(-672703993, 1411666394), new $Int64(-1528454899, 677744900), new $Int64(-1876628533, 4172867247), new $Int64(135494707, 2163418403), new $Int64(849547544, 2841526879), new $Int64(-1117516959, 1082141470), new $Int64(-1770111792, 4046134367), new $Int64(51415528, 2142943655), new $Int64(-249824333, 3124627521), new $Int64(998228909, 219992939), new $Int64(-1078790951, 1756846531), new $Int64(1283749206, 1225118210), new $Int64(-525858006, 1647770243), new $Int64(-2035959705, 444807907), new $Int64(2036369448, 3952076173), new $Int64(53201823, 1461839639), new $Int64(315761893, 3699250910), new $Int64(702974850, 1373688981), new $Int64(734022261, 147523747), new $Int64(-2047330906, 1211276581), new $Int64(1294440951, 2548832680), new $Int64(1144696256, 1995631888), new $Int64(-1992983070, 2011457303), new $Int64(-1351022674, 3057425772), new $Int64(667839456, 81484597), new $Int64(-1681980888, 3646681560), new $Int64(-1372462725, 635548515), new $Int64(602489502, 2508044581), new $Int64(-1794220117, 1014917157), new $Int64(719992433, 3214891315), new $Int64(-1294799037, 959582252), new $Int64(226415134, 3347040449), new $Int64(-362868096, 4102971975), new $Int64(397887437, 4078022210), new $Int64(-536803826, 2851767182), new $Int64(-1398321012, 1540160644), new $Int64(-1549098876, 1057290595), new $Int64(-112592988, 3907769253), new $Int64(579300318, 4248952684), new $Int64(-1054576049, 132554364), new $Int64(-1085862414, 1029351092), new $Int64(697840928, 2583007416), new $Int64(298619124, 1486185789), new $Int64(55905697, 2871589073), new $Int64(2017643612, 723203291), new $Int64(146250550, 2494333952), new $Int64(-1082993397, 2230939180), new $Int64(-1804568072, 3943232912), new $Int64(1768732449, 2181367922), new $Int64(-729261111, 2889274791), new $Int64(1824032949, 2046728161), new $Int64(1653899792, 1376052477), new $Int64(1022327048, 381236993), new $Int64(-1113097690, 3188942166), new $Int64(-74480109, 350070824), new $Int64(144881592, 61758415), new $Int64(-741824226, 3492950336), new $Int64(-2030042720, 3093818430), new $Int64(-453590535, 2962480613), new $Int64(-1912050708, 3154871160), new $Int64(-1636478569, 3228564679), new $Int64(610731502, 888276216), new $Int64(-946702974, 3574998604), new $Int64(-1277068380, 1967526716), new $Int64(-1556147941, 1554691298), new $Int64(-1573024234, 339944798), new $Int64(1223764147, 1154515356), new $Int64(1825645307, 967516237), new $Int64(1546195135, 596588202), new $Int64(-1867600880, 3764362170), new $Int64(-1655392592, 266611402), new $Int64(-393255880, 2047856075), new $Int64(-1000726433, 21444105), new $Int64(-949424754, 3065563181), new $Int64(-232418803, 1140663212), new $Int64(633187674, 2323741028), new $Int64(2126290159, 3103873707), new $Int64(1008658319, 2766828349), new $Int64(-485587503, 1970872996), new $Int64(1628585413, 3766615585), new $Int64(-595148528, 2036813414), new $Int64(-1994877121, 3105536507), new $Int64(13954645, 3396176938), new $Int64(-721402003, 1377154485), new $Int64(-61839181, 3807014186), new $Int64(543009040, 3710110597), new $Int64(-1751425519, 916420443), new $Int64(734556788, 2103831255), new $Int64(-1766161494, 717331943), new $Int64(-1574598896, 3550505941), new $Int64(45939673, 378749927), new $Int64(-1997615719, 611017331), new $Int64(592130075, 758907650), new $Int64(1012992349, 154266815), new $Int64(-1040454942, 1407468696), new $Int64(-1678191250, 970098704), new $Int64(-285057486, 1971660656), new $Int64(998365243, 3332747885), new $Int64(1947089649, 1935189867), new $Int64(1510248801, 203520055), new $Int64(-1305165746, 3916463034), new $Int64(-388598655, 3474113316), new $Int64(1036101639, 316544223), new $Int64(-1773744891, 1650844677), new $Int64(-907191419, 4267565603), new $Int64(-1070275024, 2501167616), new $Int64(-1520651863, 3929401789), new $Int64(-2091360852, 337170252), new $Int64(-960502090, 2061966842), new $Int64(-304190848, 2508461464), new $Int64(-1941471116, 2791377107), new $Int64(1240791848, 1227227588), new $Int64(1813978778, 1709681848), new $Int64(1153692192, 3768820575), new $Int64(-1002297449, 2887126398), new $Int64(-1447111334, 296561685), new $Int64(700300844, 3729960077), new $Int64(-1572311344, 372833036), new $Int64(2078875613, 2409779288), new $Int64(1829161290, 555274064), new $Int64(-1105595719, 4239804901), new $Int64(1839403216, 3723486978), new $Int64(-1649093095, 2145871984), new $Int64(-1582765715, 3565480803), new $Int64(-1568653827, 2197313814), new $Int64(974785092, 3613674566), new $Int64(438638731, 3042093666), new $Int64(-96556264, 3324034321), new $Int64(869420878, 3708873369), new $Int64(946682149, 1698090092), new $Int64(1618900382, 4213940712), new $Int64(-1843479747, 2087477361), new $Int64(-1766167800, 2407950639), new $Int64(-1296225558, 3942568569), new $Int64(-1223900450, 4088074412), new $Int64(723260036, 2964773675), new $Int64(-673921829, 1539178386), new $Int64(1062961552, 2694849566), new $Int64(460977733, 2120273838), new $Int64(-1604570740, 2484608657), new $Int64(880846449, 2956190677), new $Int64(1970902366, 4223313749), new $Int64(662161910, 3502682327), new $Int64(705634754, 4133891139), new $Int64(-1031359300, 1166449596), new $Int64(1038247601, 3362705993), new $Int64(93734798, 3892921029), new $Int64(1876124043, 786869787), new $Int64(1057490746, 1046342263), new $Int64(242763728, 493777327), new $Int64(-853573201, 3304827646), new $Int64(616460742, 125356352), new $Int64(499300063, 74094113), new $Int64(-795586925, 2500816079), new $Int64(-490248444, 514015239), new $Int64(1377565129, 543520454), new $Int64(-2039776725, 3614531153), new $Int64(2056746300, 2356753985), new $Int64(1390062617, 2018141668), new $Int64(131272971, 2087974891), new $Int64(-1502927041, 3166972343), new $Int64(372256200, 1517638666), new $Int64(-935275664, 173466846), new $Int64(-695774461, 4241513471), new $Int64(-1413550842, 2783126920), new $Int64(1972004134, 4167264826), new $Int64(29260506, 3907395640), new $Int64(-910901561, 1539634186), new $Int64(-595957298, 178241987), new $Int64(-113277636, 182168164), new $Int64(-1102530459, 2386154934), new $Int64(1379126408, 4077374341), new $Int64(-2114679722, 1732699140), new $Int64(-421057745, 1041306002), new $Int64(1860414813, 2068001749), new $Int64(1005320202, 3208962910), new $Int64(844054010, 697710380), new $Int64(-1509359403, 2228431183), new $Int64(-810313977, 3554678728), new $Int64(-750989047, 173470263), new $Int64(-85886265, 3848297795), new $Int64(-926936977, 246236185), new $Int64(-1984190461, 2066374846), new $Int64(1771673660, 312890749), new $Int64(703378057, 3573310289), new $Int64(-598851901, 143166754), new $Int64(613554316, 2081511079), new $Int64(1197802104, 486038032), new $Int64(-1906483789, 2982218564), new $Int64(364901986, 1000939191), new $Int64(1902782651, 2750454885), new $Int64(-671844857, 3375313137), new $Int64(-1643868040, 881302957), new $Int64(-1508784745, 2514186393), new $Int64(-1703622845, 360024739), new $Int64(1399671872, 292500025), new $Int64(1381210821, 2276300752), new $Int64(521803381, 4069087683), new $Int64(-1938982667, 1637778212), new $Int64(720490469, 1676670893), new $Int64(1067262482, 3855174429), new $Int64(2114075974, 2067248671), new $Int64(-89426259, 2884561259), new $Int64(-805741095, 2456511185), new $Int64(983726246, 561175414), new $Int64(-1719489563, 432588903), new $Int64(885133709, 4059399550), new $Int64(-93096266, 1075014784), new $Int64(-1733832628, 2728058415), new $Int64(1839142064, 1299703678), new $Int64(1262333188, 2347583393), new $Int64(1285481956, 2468164145), new $Int64(-1158354011, 1140014346), new $Int64(2033889184, 1936972070), new $Int64(-1737578993, 3870530098), new $Int64(-484494257, 1717789158), new $Int64(-232997156, 1153452491), new $Int64(-990424416, 3948827651), new $Int64(-1357145630, 2101413152), new $Int64(1495744672, 3854091229), new $Int64(83644069, 4215565463), new $Int64(-1385277313, 1202710438), new $Int64(-564909037, 2072216740), new $Int64(705690639, 2066751068), new $Int64(-2113583312, 173902580), new $Int64(-741983806, 142459001), new $Int64(172391592, 1889151926), new $Int64(-498943125, 3034199774), new $Int64(1618587731, 516490102), new $Int64(93114264, 3692577783), new $Int64(-2078821353, 2953948865), new $Int64(-320938673, 4041040923), new $Int64(-1942517976, 592046130), new $Int64(-705643640, 384297211), new $Int64(-2051649464, 265863924), new $Int64(2101717619, 1333136237), new $Int64(1499611781, 1406273556), new $Int64(1074670496, 426305476), new $Int64(125704633, 2750898176), new $Int64(488068495, 1633944332), new $Int64(2037723464, 3236349343), new $Int64(-1703423246, 4013676611), new $Int64(1718532237, 2265047407), new $Int64(1433593806, 875071080), new $Int64(-343047503, 1418843655), new $Int64(2009228711, 451657300), new $Int64(1229446621, 1866374663), new $Int64(1653472867, 1551455622), new $Int64(577191481, 3560962459), new $Int64(1669204077, 3347903778), new $Int64(-298327194, 2675874918), new $Int64(-1831355577, 2762991672), new $Int64(530492383, 3689068477), new $Int64(844089962, 4071997905), new $Int64(1508155730, 1381702441), new $Int64(2089931018, 2373284878), new $Int64(-864267462, 2143983064), new $Int64(308739063, 1938207195), new $Int64(1754949306, 1188152253), new $Int64(1272345009, 615870490), new $Int64(742653194, 2662252621), new $Int64(1477718295, 3839976789), new $Int64(-2091334213, 306752547), new $Int64(-1426688067, 2162363077), new $Int64(-57052633, 2767224719), new $Int64(-1471624099, 2628837712), new $Int64(1678405918, 2967771969), new $Int64(1694285728, 499792248), new $Int64(-1744131281, 4285253508), new $Int64(962357072, 2856511070), new $Int64(679471692, 2526409716), new $Int64(-1793706473, 1240875658), new $Int64(-914893422, 2577342868), new $Int64(-1001298215, 4136853496), new $Int64(-1477114974, 2403540137), new $Int64(1372824515, 1371410668), new $Int64(-176562048, 371758825), new $Int64(-441063112, 1528834084), new $Int64(-71688630, 1504757260), new $Int64(-1461820072, 699052551), new $Int64(-505543539, 3347789870), new $Int64(1951619734, 3430604759), new $Int64(2119672219, 1935601723), new $Int64(966789690, 834676166)]);
		globalRand = New(new lockedSource.ptr(new nosync.Mutex.ptr(false), $assertType(NewSource(new $Int64(0, 1)), Source64)));
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["main"] = (function() {
	var $pkg = {}, $init, js, bitmapfont, ebiten, inpututil, text, colornames, log, math, rand, strconv, sprite, ptrType, sliceType, ptrType$1, ptrType$2, sliceType$1, ptrType$3, sliceType$2, buttons, myHand, yourHand, waiting, turn, myPt, yourPt, ready, getPt, gameSet, myName, init, newSprite, update, main, getJustTouchPosition;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	bitmapfont = $packages["github.com/hajimehoshi/bitmapfont"];
	ebiten = $packages["github.com/hajimehoshi/ebiten"];
	inpututil = $packages["github.com/hajimehoshi/ebiten/inpututil"];
	text = $packages["github.com/hajimehoshi/ebiten/text"];
	colornames = $packages["golang.org/x/image/colornames"];
	log = $packages["log"];
	math = $packages["math"];
	rand = $packages["math/rand"];
	strconv = $packages["strconv"];
	sprite = $pkg.sprite = $newType(0, $kindStruct, "main.sprite", true, "main", false, function(image_, x_, y_, scaleX_, scaleY_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.image = ptrType$1.nil;
			this.x = 0;
			this.y = 0;
			this.scaleX = 0;
			this.scaleY = 0;
			return;
		}
		this.image = image_;
		this.x = x_;
		this.y = y_;
		this.scaleX = scaleX_;
		this.scaleY = scaleY_;
	});
	ptrType = $ptrType(sprite);
	sliceType = $sliceType(ptrType);
	ptrType$1 = $ptrType(ebiten.Image);
	ptrType$2 = $ptrType($packages["github.com/hajimehoshi/ebiten/internal/affine"].ColorM);
	sliceType$1 = $sliceType(ebiten.ImagePart);
	ptrType$3 = $ptrType($packages["image"].Rectangle);
	sliceType$2 = $sliceType($emptyInterface);

	//---------------------------------------------------------------------
	var room = 0
	var next = true
	var player = 0
	//---------------------------------------------------------------------

	init = function() {

		//----------------------------------------------------------------
		db.ref('/room1/'+'player1').once('value',function(obj){
			var data=obj.val(); //
			if (data == 0) {
				room = 1
				db.ref('room1').set({
					"player1":100,
				});
				next = false
				player = 1
			}else {
				db.ref('/room1/'+'player2').once('value',function(obj){
					var data=obj.val(); //
					if (data == 0) {
						room = 1
						db.ref('room1').set({
							"player2":100,
						});
						next = false
						player = 2
					}
				});
			}
		});

		if (next) {
			db.ref('/room2/'+'player1').once('value',function(obj){
				var data=obj.val(); //
				if (data == 0) {
					room = 2
					db.ref('room2').set({
						"player1":100,
					});
					next = false
					player = 1
				}else {
					db.ref('/room2/'+'player2').once('value',function(obj){
						var data=obj.val(); //
						if (data == 0) {
							room = 2
							db.ref('room2').set({
								"player2":100,
							});
							next = false
							player = 2
						}
					});
				}
			});
		}

		if (next) {
			db.ref('/room3/'+'player1').once('value',function(obj){
				var data=obj.val(); //
				if (data == 0) {
					room = 3
					db.ref('room3').set({
						"player1":100,
					});
					next = false
					player = 1
				}else {
					db.ref('/room3/'+'player2').once('value',function(obj){
						var data=obj.val(); //
						if (data == 0) {
							room = 3
							db.ref('room3').set({
								"player2":100,
							});
							next = false
							player = 2
						}
					});
				}
			});
		}

		if (next) {
			console.log("")
		}

		
		//----------------------------------------------------------------

		var _r, _r$1, _tuple, buttonImage, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; buttonImage = $f.buttonImage; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		myName = $internalize($global.prompt($externalize("\xE5\x90\x8D\xE5\x89\x8D\xE3\x82\x92\xE5\x85\xA5\xE5\x8A\x9B\xE3\x81\x97\xE3\x81\xA6\xE3\x81\x8F\xE3\x81\xA0\xE3\x81\x95\xE3\x81\x84(\xE4\xBA\x8C\xE6\x96\x87\xE5\xAD\x97\xE3\x81\xBE\xE3\x81\xA7)", $String)), $String);
		_tuple = ebiten.NewImage(20, 20, 0);
		buttonImage = _tuple[0];
		_r = buttonImage.Fill((x = colornames.Silver, new x.constructor.elem(x))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		buttons = $append(buttons, newSprite(buttonImage, 15, 100), newSprite(buttonImage, 30, 130), newSprite(buttonImage, 60, 130), newSprite(buttonImage, 90, 130), newSprite(buttonImage, 108, 100));
		_r$1 = rand.Intn(2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		turn = _r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.buttonImage = buttonImage; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	newSprite = function(image, x, y) {
		var image, x, y;
		return new sprite.ptr(image, x, y, 1, 1);
	};
	sprite.ptr.prototype.Draw = function(screen) {
		var _r, op, s, screen, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; op = $f.op; s = $f.s; screen = $f.screen; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		op = new ebiten.DrawImageOptions.ptr(new ebiten.GeoM.ptr(0, 0, 0, 0, 0, 0), new ebiten.ColorM.ptr(ptrType$2.nil), 0, 0, $ifaceNil, sliceType$1.nil, ptrType$3.nil);
		op.GeoM.Scale(s.scaleX, s.scaleY);
		op.GeoM.Translate(s.x, s.y);
		_r = screen.DrawImage(s.image, op); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: sprite.ptr.prototype.Draw }; } $f._r = _r; $f.op = op; $f.s = s; $f.screen = screen; $f.$s = $s; $f.$r = $r; return $f;
	};
	sprite.prototype.Draw = function(screen) { return this.$val.Draw(screen); };

	//----------------------------------------
	var start = false
	//----------------------------------------

	update = function(screen) {
		//-------------------------------------------------------
		if (room == 1 && player == 1) {
			db.ref('/room1/'+'player2').once('value',function(obj){
				var data=obj.val(); //
				if (data != 0) {
					start = true
				}
			});
		}else if (room == 1 && player == 2) {
			db.ref('/room1/'+'player1').once('value',function(obj){
				var data=obj.val(); //
				if (data != 0) {
					start = true
				}
			});
		}else if (room == 2 && player == 1) {
			db.ref('/room2/'+'player2').once('value',function(obj){
				var data=obj.val(); //
				if (data != 0) {
					start = true
				}
			});
		}else if (room == 2 && player == 2) {
			db.ref('/room2/'+'player1').once('value',function(obj){
				var data=obj.val(); //
				if (data != 0) {
					start = true
				}
			});
		}else if (room == 3 && player == 1) {
			db.ref('/room3/'+'player2').once('value',function(obj){
				var data=obj.val(); //
				if (data != 0) {
					start = true
				}
			});
		}else if (room == 3 && player == 2) {
			db.ref('/room3/'+'player1').once('value',function(obj){
				var data=obj.val(); //
				if (data != 0) {
					start = true
				}
			});
		} 
		//------------------------------------------------------

		var _i, _i$1, _r, _r$1, _r$2, _r$3, _r$4, _ref, _ref$1, i, screen, v, v$1, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; _ref$1 = $f._ref$1; i = $f.i; screen = $f.screen; v = $f.v; v$1 = $f.v$1; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$16 = $f.x$16; x$17 = $f.x$17; x$18 = $f.x$18; x$19 = $f.x$19; x$2 = $f.x$2; x$20 = $f.x$20; x$21 = $f.x$21; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_ref = buttons;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			v = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			_r = v.IsJustPressed(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r && !waiting && !gameSet && start) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r && !waiting && !gameSet) { */ case 3:
				console.log(i + 1 >> 0);
				myHand = i + 1 >> 0;
				waiting = true;

				//-------------------------------------------------------------------------------
				if (room == 1 && player == 1) {
					db.ref('room1').update({
						"player1":myHand,
					});
				}else if (room == 1 && player == 2) {
					db.ref('room1').update({
						"player2":myHand,
					});
				}else if (room == 2 && player == 1) {
					db.ref('room2').update({
						"player1":myHand,
					});
				}else if (room == 2 && player == 2) {
					db.ref('room2').update({
						"player2":myHand,
					});
				}else if (room == 3 && player == 1) {
					db.ref('room3').update({
						"player1":myHand,
					});
				}else if (room == 3 && player == 2) {
					db.ref('room3').update({
						"player2":myHand,
					});
				} 

				//-------------------------------------------------------------------------------

				/* break; */ $s = 2; continue;
			/* } */ case 4:
			_i++;
		/* } */ $s = 1; continue; case 2:
		$r = text.Draw(screen, "2\xE5\x86\x86\xE3\x81\x8C...", bitmapfont.Gothic12r, 20, 20, (x = colornames.White, new x.constructor.elem(x))); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_ref$1 = buttons;
		_i$1 = 0;
		/* while (true) { */ case 7:
			/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 8; continue; }
			v$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			$r = v$1.Draw(screen); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i$1++;
		/* } */ $s = 7; continue; case 8:
		$r = text.Draw(screen, "1", bitmapfont.Gothic12r, 25, 110, (x$1 = colornames.Black, new x$1.constructor.elem(x$1))); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = text.Draw(screen, "2", bitmapfont.Gothic12r, 40, 140, (x$2 = colornames.Black, new x$2.constructor.elem(x$2))); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = text.Draw(screen, "3", bitmapfont.Gothic12r, 70, 140, (x$3 = colornames.Black, new x$3.constructor.elem(x$3))); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = text.Draw(screen, "4", bitmapfont.Gothic12r, 100, 140, (x$4 = colornames.Black, new x$4.constructor.elem(x$4))); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = text.Draw(screen, "5", bitmapfont.Gothic12r, 118, 110, (x$5 = colornames.Black, new x$5.constructor.elem(x$5))); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = text.Draw(screen, myName, bitmapfont.Gothic12r, 40, 58, (x$6 = colornames.White, new x$6.constructor.elem(x$6))); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = text.Draw(screen, "\xE7\x9B\xB8\xE6\x89\x8B", bitmapfont.Gothic12r, 86, 58, (x$7 = colornames.White, new x$7.constructor.elem(x$7))); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ if (myHand > 0) { $s = 17; continue; }
		/* */ $s = 18; continue;
		/* if (myHand > 0) { */ case 17:
			$r = text.Draw(screen, strconv.Itoa(myHand), bitmapfont.Gothic12r, 50, 75, (x$8 = colornames.White, new x$8.constructor.elem(x$8))); /* */ $s = 19; case 19: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 18:
		/* */ if (yourHand > 0) { $s = 20; continue; }
		/* */ $s = 21; continue;
		/* if (yourHand > 0) { */ case 20:
			$r = text.Draw(screen, strconv.Itoa(yourHand), bitmapfont.Gothic12r, 96, 75, (x$9 = colornames.White, new x$9.constructor.elem(x$9))); /* */ $s = 22; case 22: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 21:
		/* */ if ((_r$1 = turn % 2, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0) { $s = 23; continue; }
		/* */ $s = 24; continue;
		/* if ((_r$1 = turn % 2, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0) { */ case 23:
			$r = text.Draw(screen, "\xE6\x94\xBB\xE3\x82\x81", bitmapfont.Gothic12r, 40, 40, (x$10 = colornames.White, new x$10.constructor.elem(x$10))); /* */ $s = 26; case 26: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = text.Draw(screen, "\xE5\xAE\x88\xE3\x82\x8A", bitmapfont.Gothic12r, 86, 40, (x$11 = colornames.White, new x$11.constructor.elem(x$11))); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 25; continue;
		/* } else { */ case 24:
			$r = text.Draw(screen, "\xE5\xAE\x88\xE3\x82\x8A", bitmapfont.Gothic12r, 40, 40, (x$12 = colornames.White, new x$12.constructor.elem(x$12))); /* */ $s = 28; case 28: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = text.Draw(screen, "\xE6\x94\xBB\xE3\x82\x81", bitmapfont.Gothic12r, 86, 40, (x$13 = colornames.White, new x$13.constructor.elem(x$13))); /* */ $s = 29; case 29: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 25:
		/* */ if (waiting) { $s = 30; continue; }
		/* */ $s = 31; continue;
		/* if (waiting) { */ case 30:
			// _r$2 = rand.Intn(5); /* */ $s = 32; case 32: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			// yourHand = _r$2 + 1 >> 0;

			//---------------------------------------------------------------------------
			var yourHand2 = 0

			if (room == 1 && player == 1) {
				db.ref('room1').update({
					"player2":yourHand2,
				});
			}else if (room == 1 && player == 2) {
				db.ref('room1').update({
					"player1":yourHand2,
				});
			}else if (room == 2 && player == 1) {
				db.ref('room2').update({
					"player2":yourHand2,
				});
			}else if (room == 2 && player == 2) {
				db.ref('room2').update({
					"player1":yourHand2,
				});
			}else if (room == 3 && player == 1) {
				db.ref('room3').update({
					"player2":yourHand2,
				});
			}else if (room == 3 && player == 2) {
				db.ref('room3').update({
					"player1":yourHand2,
				});
			} 
			//----------------------------------------------------------------------------
			ready = true;
			waiting = false;
		/* } */ case 31:
		if (ready) {
			getPt = ((math.Abs(((myHand - yourHand2 >> 0))) >> 0));
			if ((_r$3 = turn % 2, _r$3 === _r$3 ? _r$3 : $throwRuntimeError("integer divide by zero")) === 0) {
				myPt = myPt + (getPt) >> 0;
			} else {
				yourPt = yourPt + (getPt) >> 0;
			}
			ready = false;
			turn = turn + (3) >> 0;
		}
		$r = text.Draw(screen, myName, bitmapfont.Gothic12r, 40, 180, (x$14 = colornames.White, new x$14.constructor.elem(x$14))); /* */ $s = 33; case 33: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = text.Draw(screen, "\xE7\x9B\xB8\xE6\x89\x8B", bitmapfont.Gothic12r, 86, 180, (x$15 = colornames.White, new x$15.constructor.elem(x$15))); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = text.Draw(screen, strconv.Itoa(myPt), bitmapfont.Gothic12r, 50, 197, (x$16 = colornames.White, new x$16.constructor.elem(x$16))); /* */ $s = 35; case 35: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = text.Draw(screen, strconv.Itoa(yourPt), bitmapfont.Gothic12r, 96, 197, (x$17 = colornames.White, new x$17.constructor.elem(x$17))); /* */ $s = 36; case 36: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ if (turn > 2) { $s = 37; continue; }
		/* */ $s = 38; continue;
		/* if (turn > 2) { */ case 37:
			/* */ if ((_r$4 = turn % 2, _r$4 === _r$4 ? _r$4 : $throwRuntimeError("integer divide by zero")) === 0) { $s = 39; continue; }
			/* */ $s = 40; continue;
			/* if ((_r$4 = turn % 2, _r$4 === _r$4 ? _r$4 : $throwRuntimeError("integer divide by zero")) === 0) { */ case 39:
				$r = text.Draw(screen, "+" + strconv.Itoa(getPt), bitmapfont.Gothic12r, 93, 214, (x$18 = colornames.Red, new x$18.constructor.elem(x$18))); /* */ $s = 42; case 42: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = 41; continue;
			/* } else { */ case 40:
				$r = text.Draw(screen, "+" + strconv.Itoa(getPt), bitmapfont.Gothic12r, 47, 214, (x$19 = colornames.Red, new x$19.constructor.elem(x$19))); /* */ $s = 43; case 43: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 41:
		/* } */ case 38:
		/* */ if (myPt >= 10) { $s = 44; continue; }
		/* */ if (yourPt >= 10) { $s = 45; continue; }
		/* */ $s = 46; continue;
		/* if (myPt >= 10) { */ case 44:
			$r = text.Draw(screen, "\xE5\x8B\x9D\xE3\x81\xA1\xEF\xBC\x81", bitmapfont.Gothic12r, 62, 232, (x$20 = colornames.Red, new x$20.constructor.elem(x$20))); /* */ $s = 47; case 47: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			gameSet = true;
			$s = 46; continue;
		/* } else if (yourPt >= 10) { */ case 45:
			$r = text.Draw(screen, "\xE8\xB2\xA0\xE3\x81\x91...", bitmapfont.Gothic12r, 62, 232, (x$21 = colornames.Blue, new x$21.constructor.elem(x$21))); /* */ $s = 48; case 48: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			gameSet = true;
		/* } */ case 46:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: update }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f._ref$1 = _ref$1; $f.i = i; $f.screen = screen; $f.v = v; $f.v$1 = v$1; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$16 = x$16; $f.x$17 = x$17; $f.x$18 = x$18; $f.x$19 = x$19; $f.x$2 = x$2; $f.x$20 = x$20; $f.x$21 = x$21; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	main = function() {
		var _r, err, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = ebiten.Run(update, 144, 256, 3, "2\xE5\x86\x86"); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		/* */ if (!($interfaceIsEqual(err, $ifaceNil))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 2:
			$r = log.Fatal(new sliceType$2([err])); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: main }; } $f._r = _r; $f.err = err; $f.$s = $s; $f.$r = $r; return $f;
	};
	sprite.ptr.prototype.IsJustPressed = function() {
		var _r, _r$1, _r$2, _tuple, _tuple$1, cursorX, cursorY, rect, rx, ry, s, touchX, touchY, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; cursorX = $f.cursorX; cursorY = $f.cursorY; rect = $f.rect; rx = $f.rx; ry = $f.ry; s = $f.s; touchX = $f.touchX; touchY = $f.touchY; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s = this;
		rect = $clone(s.image.Bounds(), $packages["image"].Rectangle);
		rx = ((($clone(rect, $packages["image"].Rectangle).Dx()) * s.scaleX >> 0));
		ry = ((($clone(rect, $packages["image"].Rectangle).Dy()) * s.scaleY >> 0));
		_r = ebiten.CursorPosition(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		cursorX = _tuple[0];
		cursorY = _tuple[1];
		_r$1 = inpututil.IsMouseButtonJustPressed(0); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (_r$1) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (_r$1) { */ case 2:
			if (cursorX >= ((s.x >> 0)) && cursorX <= (((s.x >> 0)) + rx >> 0) && cursorY >= ((s.y >> 0)) && cursorY <= (((s.y >> 0)) + ry >> 0)) {
				$s = -1; return true;
			}
		/* } */ case 3:
		_r$2 = getJustTouchPosition(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_tuple$1 = _r$2;
		touchX = _tuple$1[0];
		touchY = _tuple$1[1];
		if (touchX >= ((s.x >> 0)) && touchX <= (((s.x >> 0)) + rx >> 0) && touchY >= ((s.y >> 0)) && touchY <= (((s.y >> 0)) + ry >> 0)) {
			$s = -1; return true;
		}
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: sprite.ptr.prototype.IsJustPressed }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.cursorX = cursorX; $f.cursorY = cursorY; $f.rect = rect; $f.rx = rx; $f.ry = ry; $f.s = s; $f.touchX = touchX; $f.touchY = touchY; $f.$s = $s; $f.$r = $r; return $f;
	};
	sprite.prototype.IsJustPressed = function() { return this.$val.IsJustPressed(); };
	getJustTouchPosition = function() {
		var _r, _r$1, _tmp, _tmp$1, _tuple, ts, x, y, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; ts = $f.ts; x = $f.x; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tmp = 0;
		_tmp$1 = 0;
		x = _tmp;
		y = _tmp$1;
		_r = inpututil.JustPressedTouchIDs(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		ts = _r;
		/* */ if (ts.$length === 1) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (ts.$length === 1) { */ case 2:
			_r$1 = ebiten.TouchPosition((0 >= ts.$length ? ($throwRuntimeError("index out of range"), undefined) : ts.$array[ts.$offset + 0])); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple = _r$1;
			x = _tuple[0];
			y = _tuple[1];
		/* } */ case 3:
		$s = -1; return [x, y];
		/* */ } return; } if ($f === undefined) { $f = { $blk: getJustTouchPosition }; } $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.ts = ts; $f.x = x; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;
	};
	ptrType.methods = [{prop: "Draw", name: "Draw", pkg: "", typ: $funcType([ptrType$1], [], false)}, {prop: "IsJustPressed", name: "IsJustPressed", pkg: "", typ: $funcType([], [$Bool], false)}];
	sprite.init("main", [{prop: "image", name: "image", embedded: false, exported: false, typ: ptrType$1, tag: ""}, {prop: "x", name: "x", embedded: false, exported: false, typ: $Float64, tag: ""}, {prop: "y", name: "y", embedded: false, exported: false, typ: $Float64, tag: ""}, {prop: "scaleX", name: "scaleX", embedded: false, exported: false, typ: $Float64, tag: ""}, {prop: "scaleY", name: "scaleY", embedded: false, exported: false, typ: $Float64, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bitmapfont.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = ebiten.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = inpututil.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = text.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = colornames.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = log.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = rand.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		buttons = sliceType.nil;
		myHand = 0;
		yourHand = 0;
		waiting = false;
		turn = 0;
		myPt = 0;
		yourPt = 0;
		ready = false;
		getPt = 0;
		gameSet = false;
		myName = "";
		$r = init(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ if ($pkg === $mainPkg) { $s = 12; continue; }
		/* */ $s = 13; continue;
		/* if ($pkg === $mainPkg) { */ case 12:
			$r = main(); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$mainFinished = true;
		/* } */ case 13:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$synthesizeMethods();
var $mainPkg = $packages["main"];
$packages["runtime"].$init();
$go($mainPkg.$init, []);
$flushConsole();

}).call(this);
//# sourceMappingURL=main.js.map
